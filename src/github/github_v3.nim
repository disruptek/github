
import
  json, options, hashes, uri, strutils, rest, os, uri, httpcore

## auto-generated via openapi macro
## title: GitHub
## version: v3
## termsOfService: https://help.github.com/articles/github-terms-of-service/#b-api-terms
## license: (not provided)
## 
## Powerful collaboration, code review, and code management for open source and private projects.
## 
## 
## https://developer.github.com/v3/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (query: JsonNode = nil; body: JsonNode = nil;
                          header: JsonNode = nil; path: JsonNode = nil;
                          formData: JsonNode = nil): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_576564 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_576564](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_576564): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low ..
      Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js ==
      nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result ==
      nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind ==
        kind, $kind & " expected; received " &
        $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string {.used.} =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] {.used.} =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    case js.kind
    of JInt, JFloat, JNull, JBool:
      head = $js
    of JString:
      head = js.getStr
    else:
      return
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.}
type
  Call_GetEmojis_576769 = ref object of OpenApiRestCall_576564
proc url_GetEmojis_576771(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEmojis_576770(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists all the emojis available to use on GitHub.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_576919 = header.getOrDefault("Accept")
  valid_576919 = validateParameter(valid_576919, JString, required = false,
                                 default = nil)
  if valid_576919 != nil:
    section.add "Accept", valid_576919
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_576946: Call_GetEmojis_576769; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists all the emojis available to use on GitHub.
  ## 
  let valid = call_576946.validator(path, query, header, formData, body)
  let scheme = call_576946.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_576946.url(scheme.get, call_576946.host, call_576946.base,
                         call_576946.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_576946, url, valid)

proc call*(call_577017: Call_GetEmojis_576769; Accept: string = ""): Recallable =
  ## getEmojis
  ## Lists all the emojis available to use on GitHub.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_577018 = newJObject()
  add(header_577018, "Accept", newJString(Accept))
  result = call_577017.call(nil, nil, header_577018, nil, nil)

var getEmojis* = Call_GetEmojis_576769(name: "getEmojis", meth: HttpMethod.HttpGet,
                                    host: "api.github.com", route: "/emojis",
                                    validator: validate_GetEmojis_576770,
                                    base: "/", url: url_GetEmojis_576771,
                                    schemes: {Scheme.Https})
type
  Call_GetEvents_577058 = ref object of OpenApiRestCall_576564
proc url_GetEvents_577060(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEvents_577059(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## List public events.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577061 = header.getOrDefault("Accept")
  valid_577061 = validateParameter(valid_577061, JString, required = false,
                                 default = nil)
  if valid_577061 != nil:
    section.add "Accept", valid_577061
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577062: Call_GetEvents_577058; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List public events.
  ## 
  let valid = call_577062.validator(path, query, header, formData, body)
  let scheme = call_577062.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577062.url(scheme.get, call_577062.host, call_577062.base,
                         call_577062.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577062, url, valid)

proc call*(call_577063: Call_GetEvents_577058; Accept: string = ""): Recallable =
  ## getEvents
  ## List public events.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_577064 = newJObject()
  add(header_577064, "Accept", newJString(Accept))
  result = call_577063.call(nil, nil, header_577064, nil, nil)

var getEvents* = Call_GetEvents_577058(name: "getEvents", meth: HttpMethod.HttpGet,
                                    host: "api.github.com", route: "/events",
                                    validator: validate_GetEvents_577059,
                                    base: "/", url: url_GetEvents_577060,
                                    schemes: {Scheme.Https})
type
  Call_GetFeeds_577065 = ref object of OpenApiRestCall_576564
proc url_GetFeeds_577067(protocol: Scheme; host: string; base: string; route: string;
                        path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetFeeds_577066(path: JsonNode; query: JsonNode; header: JsonNode;
                             formData: JsonNode; body: JsonNode): JsonNode =
  ## List Feeds.
  ## GitHub provides several timeline resources in Atom format. The Feeds API
  ##  lists all the feeds available to the authenticating user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577068 = header.getOrDefault("Accept")
  valid_577068 = validateParameter(valid_577068, JString, required = false,
                                 default = nil)
  if valid_577068 != nil:
    section.add "Accept", valid_577068
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577069: Call_GetFeeds_577065; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List Feeds.
  ## GitHub provides several timeline resources in Atom format. The Feeds API
  ##  lists all the feeds available to the authenticating user.
  ## 
  ## 
  let valid = call_577069.validator(path, query, header, formData, body)
  let scheme = call_577069.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577069.url(scheme.get, call_577069.host, call_577069.base,
                         call_577069.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577069, url, valid)

proc call*(call_577070: Call_GetFeeds_577065; Accept: string = ""): Recallable =
  ## getFeeds
  ## List Feeds.
  ## GitHub provides several timeline resources in Atom format. The Feeds API
  ##  lists all the feeds available to the authenticating user.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_577071 = newJObject()
  add(header_577071, "Accept", newJString(Accept))
  result = call_577070.call(nil, nil, header_577071, nil, nil)

var getFeeds* = Call_GetFeeds_577065(name: "getFeeds", meth: HttpMethod.HttpGet,
                                  host: "api.github.com", route: "/feeds",
                                  validator: validate_GetFeeds_577066, base: "/",
                                  url: url_GetFeeds_577067,
                                  schemes: {Scheme.Https})
type
  Call_PostGists_577081 = ref object of OpenApiRestCall_576564
proc url_PostGists_577083(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostGists_577082(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577093 = header.getOrDefault("Accept")
  valid_577093 = validateParameter(valid_577093, JString, required = false,
                                 default = nil)
  if valid_577093 != nil:
    section.add "Accept", valid_577093
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_577095: Call_PostGists_577081; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a gist.
  ## 
  let valid = call_577095.validator(path, query, header, formData, body)
  let scheme = call_577095.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577095.url(scheme.get, call_577095.host, call_577095.base,
                         call_577095.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577095, url, valid)

proc call*(call_577096: Call_PostGists_577081; body: JsonNode; Accept: string = ""): Recallable =
  ## postGists
  ## Create a gist.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_577097 = newJObject()
  var body_577098 = newJObject()
  if body != nil:
    body_577098 = body
  add(header_577097, "Accept", newJString(Accept))
  result = call_577096.call(nil, nil, header_577097, nil, body_577098)

var postGists* = Call_PostGists_577081(name: "postGists", meth: HttpMethod.HttpPost,
                                    host: "api.github.com", route: "/gists",
                                    validator: validate_PostGists_577082,
                                    base: "/", url: url_PostGists_577083,
                                    schemes: {Scheme.Https})
type
  Call_GetGists_577072 = ref object of OpenApiRestCall_576564
proc url_GetGists_577074(protocol: Scheme; host: string; base: string; route: string;
                        path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGists_577073(path: JsonNode; query: JsonNode; header: JsonNode;
                             formData: JsonNode; body: JsonNode): JsonNode =
  ## List the authenticated user's gists or if called anonymously, this will
  ## return all public gists.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_577075 = query.getOrDefault("since")
  valid_577075 = validateParameter(valid_577075, JString, required = false,
                                 default = nil)
  if valid_577075 != nil:
    section.add "since", valid_577075
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577076 = header.getOrDefault("Accept")
  valid_577076 = validateParameter(valid_577076, JString, required = false,
                                 default = nil)
  if valid_577076 != nil:
    section.add "Accept", valid_577076
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577077: Call_GetGists_577072; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the authenticated user's gists or if called anonymously, this will
  ## return all public gists.
  ## 
  ## 
  let valid = call_577077.validator(path, query, header, formData, body)
  let scheme = call_577077.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577077.url(scheme.get, call_577077.host, call_577077.base,
                         call_577077.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577077, url, valid)

proc call*(call_577078: Call_GetGists_577072; since: string = ""; Accept: string = ""): Recallable =
  ## getGists
  ## List the authenticated user's gists or if called anonymously, this will
  ## return all public gists.
  ## 
  ##   since: string
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var query_577079 = newJObject()
  var header_577080 = newJObject()
  add(query_577079, "since", newJString(since))
  add(header_577080, "Accept", newJString(Accept))
  result = call_577078.call(nil, query_577079, header_577080, nil, nil)

var getGists* = Call_GetGists_577072(name: "getGists", meth: HttpMethod.HttpGet,
                                  host: "api.github.com", route: "/gists",
                                  validator: validate_GetGists_577073, base: "/",
                                  url: url_GetGists_577074,
                                  schemes: {Scheme.Https})
type
  Call_GetGistsPublic_577099 = ref object of OpenApiRestCall_576564
proc url_GetGistsPublic_577101(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGistsPublic_577100(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## List all public gists.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_577102 = query.getOrDefault("since")
  valid_577102 = validateParameter(valid_577102, JString, required = false,
                                 default = nil)
  if valid_577102 != nil:
    section.add "since", valid_577102
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577103 = header.getOrDefault("Accept")
  valid_577103 = validateParameter(valid_577103, JString, required = false,
                                 default = nil)
  if valid_577103 != nil:
    section.add "Accept", valid_577103
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577104: Call_GetGistsPublic_577099; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List all public gists.
  ## 
  let valid = call_577104.validator(path, query, header, formData, body)
  let scheme = call_577104.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577104.url(scheme.get, call_577104.host, call_577104.base,
                         call_577104.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577104, url, valid)

proc call*(call_577105: Call_GetGistsPublic_577099; since: string = "";
          Accept: string = ""): Recallable =
  ## getGistsPublic
  ## List all public gists.
  ##   since: string
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var query_577106 = newJObject()
  var header_577107 = newJObject()
  add(query_577106, "since", newJString(since))
  add(header_577107, "Accept", newJString(Accept))
  result = call_577105.call(nil, query_577106, header_577107, nil, nil)

var getGistsPublic* = Call_GetGistsPublic_577099(name: "getGistsPublic",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/gists/public",
    validator: validate_GetGistsPublic_577100, base: "/", url: url_GetGistsPublic_577101,
    schemes: {Scheme.Https})
type
  Call_GetGistsStarred_577108 = ref object of OpenApiRestCall_576564
proc url_GetGistsStarred_577110(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGistsStarred_577109(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## List the authenticated user's starred gists.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_577111 = query.getOrDefault("since")
  valid_577111 = validateParameter(valid_577111, JString, required = false,
                                 default = nil)
  if valid_577111 != nil:
    section.add "since", valid_577111
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577112 = header.getOrDefault("Accept")
  valid_577112 = validateParameter(valid_577112, JString, required = false,
                                 default = nil)
  if valid_577112 != nil:
    section.add "Accept", valid_577112
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577113: Call_GetGistsStarred_577108; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the authenticated user's starred gists.
  ## 
  let valid = call_577113.validator(path, query, header, formData, body)
  let scheme = call_577113.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577113.url(scheme.get, call_577113.host, call_577113.base,
                         call_577113.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577113, url, valid)

proc call*(call_577114: Call_GetGistsStarred_577108; since: string = "";
          Accept: string = ""): Recallable =
  ## getGistsStarred
  ## List the authenticated user's starred gists.
  ##   since: string
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var query_577115 = newJObject()
  var header_577116 = newJObject()
  add(query_577115, "since", newJString(since))
  add(header_577116, "Accept", newJString(Accept))
  result = call_577114.call(nil, query_577115, header_577116, nil, nil)

var getGistsStarred* = Call_GetGistsStarred_577108(name: "getGistsStarred",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/gists/starred",
    validator: validate_GetGistsStarred_577109, base: "/", url: url_GetGistsStarred_577110,
    schemes: {Scheme.Https})
type
  Call_GetGistsId_577117 = ref object of OpenApiRestCall_576564
proc url_GetGistsId_577119(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsId_577118(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_577134 = path.getOrDefault("id")
  valid_577134 = validateParameter(valid_577134, JInt, required = true, default = nil)
  if valid_577134 != nil:
    section.add "id", valid_577134
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577135 = header.getOrDefault("Accept")
  valid_577135 = validateParameter(valid_577135, JString, required = false,
                                 default = nil)
  if valid_577135 != nil:
    section.add "Accept", valid_577135
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577136: Call_GetGistsId_577117; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a single gist.
  ## 
  let valid = call_577136.validator(path, query, header, formData, body)
  let scheme = call_577136.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577136.url(scheme.get, call_577136.host, call_577136.base,
                         call_577136.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577136, url, valid)

proc call*(call_577137: Call_GetGistsId_577117; id: int; Accept: string = ""): Recallable =
  ## getGistsId
  ## Get a single gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577138 = newJObject()
  var header_577139 = newJObject()
  add(path_577138, "id", newJInt(id))
  add(header_577139, "Accept", newJString(Accept))
  result = call_577137.call(path_577138, nil, header_577139, nil, nil)

var getGistsId* = Call_GetGistsId_577117(name: "getGistsId",
                                      meth: HttpMethod.HttpGet,
                                      host: "api.github.com",
                                      route: "/gists/{id}",
                                      validator: validate_GetGistsId_577118,
                                      base: "/", url: url_GetGistsId_577119,
                                      schemes: {Scheme.Https})
type
  Call_PatchGistsId_577149 = ref object of OpenApiRestCall_576564
proc url_PatchGistsId_577151(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchGistsId_577150(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Edit a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_577152 = path.getOrDefault("id")
  valid_577152 = validateParameter(valid_577152, JInt, required = true, default = nil)
  if valid_577152 != nil:
    section.add "id", valid_577152
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577153 = header.getOrDefault("Accept")
  valid_577153 = validateParameter(valid_577153, JString, required = false,
                                 default = nil)
  if valid_577153 != nil:
    section.add "Accept", valid_577153
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_577155: Call_PatchGistsId_577149; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Edit a gist.
  ## 
  let valid = call_577155.validator(path, query, header, formData, body)
  let scheme = call_577155.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577155.url(scheme.get, call_577155.host, call_577155.base,
                         call_577155.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577155, url, valid)

proc call*(call_577156: Call_PatchGistsId_577149; id: int; body: JsonNode;
          Accept: string = ""): Recallable =
  ## patchGistsId
  ## Edit a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577157 = newJObject()
  var header_577158 = newJObject()
  var body_577159 = newJObject()
  add(path_577157, "id", newJInt(id))
  if body != nil:
    body_577159 = body
  add(header_577158, "Accept", newJString(Accept))
  result = call_577156.call(path_577157, nil, header_577158, nil, body_577159)

var patchGistsId* = Call_PatchGistsId_577149(name: "patchGistsId",
    meth: HttpMethod.HttpPatch, host: "api.github.com", route: "/gists/{id}",
    validator: validate_PatchGistsId_577150, base: "/", url: url_PatchGistsId_577151,
    schemes: {Scheme.Https})
type
  Call_DeleteGistsId_577140 = ref object of OpenApiRestCall_576564
proc url_DeleteGistsId_577142(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteGistsId_577141(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_577143 = path.getOrDefault("id")
  valid_577143 = validateParameter(valid_577143, JInt, required = true, default = nil)
  if valid_577143 != nil:
    section.add "id", valid_577143
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577144 = header.getOrDefault("Accept")
  valid_577144 = validateParameter(valid_577144, JString, required = false,
                                 default = nil)
  if valid_577144 != nil:
    section.add "Accept", valid_577144
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577145: Call_DeleteGistsId_577140; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete a gist.
  ## 
  let valid = call_577145.validator(path, query, header, formData, body)
  let scheme = call_577145.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577145.url(scheme.get, call_577145.host, call_577145.base,
                         call_577145.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577145, url, valid)

proc call*(call_577146: Call_DeleteGistsId_577140; id: int; Accept: string = ""): Recallable =
  ## deleteGistsId
  ## Delete a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577147 = newJObject()
  var header_577148 = newJObject()
  add(path_577147, "id", newJInt(id))
  add(header_577148, "Accept", newJString(Accept))
  result = call_577146.call(path_577147, nil, header_577148, nil, nil)

var deleteGistsId* = Call_DeleteGistsId_577140(name: "deleteGistsId",
    meth: HttpMethod.HttpDelete, host: "api.github.com", route: "/gists/{id}",
    validator: validate_DeleteGistsId_577141, base: "/", url: url_DeleteGistsId_577142,
    schemes: {Scheme.Https})
type
  Call_PostGistsIdComments_577169 = ref object of OpenApiRestCall_576564
proc url_PostGistsIdComments_577171(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostGistsIdComments_577170(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Create a commen
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_577172 = path.getOrDefault("id")
  valid_577172 = validateParameter(valid_577172, JInt, required = true, default = nil)
  if valid_577172 != nil:
    section.add "id", valid_577172
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577173 = header.getOrDefault("Accept")
  valid_577173 = validateParameter(valid_577173, JString, required = false,
                                 default = nil)
  if valid_577173 != nil:
    section.add "Accept", valid_577173
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_577175: Call_PostGistsIdComments_577169; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a commen
  ## 
  let valid = call_577175.validator(path, query, header, formData, body)
  let scheme = call_577175.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577175.url(scheme.get, call_577175.host, call_577175.base,
                         call_577175.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577175, url, valid)

proc call*(call_577176: Call_PostGistsIdComments_577169; id: int; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postGistsIdComments
  ## Create a commen
  ##   id: int (required)
  ##     : Id of gist.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577177 = newJObject()
  var header_577178 = newJObject()
  var body_577179 = newJObject()
  add(path_577177, "id", newJInt(id))
  if body != nil:
    body_577179 = body
  add(header_577178, "Accept", newJString(Accept))
  result = call_577176.call(path_577177, nil, header_577178, nil, body_577179)

var postGistsIdComments* = Call_PostGistsIdComments_577169(
    name: "postGistsIdComments", meth: HttpMethod.HttpPost, host: "api.github.com",
    route: "/gists/{id}/comments", validator: validate_PostGistsIdComments_577170,
    base: "/", url: url_PostGistsIdComments_577171, schemes: {Scheme.Https})
type
  Call_GetGistsIdComments_577160 = ref object of OpenApiRestCall_576564
proc url_GetGistsIdComments_577162(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsIdComments_577161(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## List comments on a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_577163 = path.getOrDefault("id")
  valid_577163 = validateParameter(valid_577163, JInt, required = true, default = nil)
  if valid_577163 != nil:
    section.add "id", valid_577163
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577164 = header.getOrDefault("Accept")
  valid_577164 = validateParameter(valid_577164, JString, required = false,
                                 default = nil)
  if valid_577164 != nil:
    section.add "Accept", valid_577164
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577165: Call_GetGistsIdComments_577160; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List comments on a gist.
  ## 
  let valid = call_577165.validator(path, query, header, formData, body)
  let scheme = call_577165.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577165.url(scheme.get, call_577165.host, call_577165.base,
                         call_577165.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577165, url, valid)

proc call*(call_577166: Call_GetGistsIdComments_577160; id: int; Accept: string = ""): Recallable =
  ## getGistsIdComments
  ## List comments on a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577167 = newJObject()
  var header_577168 = newJObject()
  add(path_577167, "id", newJInt(id))
  add(header_577168, "Accept", newJString(Accept))
  result = call_577166.call(path_577167, nil, header_577168, nil, nil)

var getGistsIdComments* = Call_GetGistsIdComments_577160(
    name: "getGistsIdComments", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/gists/{id}/comments", validator: validate_GetGistsIdComments_577161,
    base: "/", url: url_GetGistsIdComments_577162, schemes: {Scheme.Https})
type
  Call_GetGistsIdCommentsCommentId_577180 = ref object of OpenApiRestCall_576564
proc url_GetGistsIdCommentsCommentId_577182(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsIdCommentsCommentId_577181(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_577183 = path.getOrDefault("id")
  valid_577183 = validateParameter(valid_577183, JInt, required = true, default = nil)
  if valid_577183 != nil:
    section.add "id", valid_577183
  var valid_577184 = path.getOrDefault("commentId")
  valid_577184 = validateParameter(valid_577184, JInt, required = true, default = nil)
  if valid_577184 != nil:
    section.add "commentId", valid_577184
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577185 = header.getOrDefault("Accept")
  valid_577185 = validateParameter(valid_577185, JString, required = false,
                                 default = nil)
  if valid_577185 != nil:
    section.add "Accept", valid_577185
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577186: Call_GetGistsIdCommentsCommentId_577180; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a single comment.
  ## 
  let valid = call_577186.validator(path, query, header, formData, body)
  let scheme = call_577186.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577186.url(scheme.get, call_577186.host, call_577186.base,
                         call_577186.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577186, url, valid)

proc call*(call_577187: Call_GetGistsIdCommentsCommentId_577180; id: int;
          commentId: int; Accept: string = ""): Recallable =
  ## getGistsIdCommentsCommentId
  ## Get a single comment.
  ##   id: int (required)
  ##     : Id of gist.
  ##   commentId: int (required)
  ##            : Id of comment.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577188 = newJObject()
  var header_577189 = newJObject()
  add(path_577188, "id", newJInt(id))
  add(path_577188, "commentId", newJInt(commentId))
  add(header_577189, "Accept", newJString(Accept))
  result = call_577187.call(path_577188, nil, header_577189, nil, nil)

var getGistsIdCommentsCommentId* = Call_GetGistsIdCommentsCommentId_577180(
    name: "getGistsIdCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/gists/{id}/comments/{commentId}",
    validator: validate_GetGistsIdCommentsCommentId_577181, base: "/",
    url: url_GetGistsIdCommentsCommentId_577182, schemes: {Scheme.Https})
type
  Call_PatchGistsIdCommentsCommentId_577200 = ref object of OpenApiRestCall_576564
proc url_PatchGistsIdCommentsCommentId_577202(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchGistsIdCommentsCommentId_577201(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Edit a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_577203 = path.getOrDefault("id")
  valid_577203 = validateParameter(valid_577203, JInt, required = true, default = nil)
  if valid_577203 != nil:
    section.add "id", valid_577203
  var valid_577204 = path.getOrDefault("commentId")
  valid_577204 = validateParameter(valid_577204, JInt, required = true, default = nil)
  if valid_577204 != nil:
    section.add "commentId", valid_577204
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577205 = header.getOrDefault("Accept")
  valid_577205 = validateParameter(valid_577205, JString, required = false,
                                 default = nil)
  if valid_577205 != nil:
    section.add "Accept", valid_577205
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_577207: Call_PatchGistsIdCommentsCommentId_577200; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Edit a comment.
  ## 
  let valid = call_577207.validator(path, query, header, formData, body)
  let scheme = call_577207.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577207.url(scheme.get, call_577207.host, call_577207.base,
                         call_577207.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577207, url, valid)

proc call*(call_577208: Call_PatchGistsIdCommentsCommentId_577200; id: int;
          commentId: int; body: JsonNode; Accept: string = ""): Recallable =
  ## patchGistsIdCommentsCommentId
  ## Edit a comment.
  ##   id: int (required)
  ##     : Id of gist.
  ##   commentId: int (required)
  ##            : Id of comment.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577209 = newJObject()
  var header_577210 = newJObject()
  var body_577211 = newJObject()
  add(path_577209, "id", newJInt(id))
  add(path_577209, "commentId", newJInt(commentId))
  if body != nil:
    body_577211 = body
  add(header_577210, "Accept", newJString(Accept))
  result = call_577208.call(path_577209, nil, header_577210, nil, body_577211)

var patchGistsIdCommentsCommentId* = Call_PatchGistsIdCommentsCommentId_577200(
    name: "patchGistsIdCommentsCommentId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/gists/{id}/comments/{commentId}",
    validator: validate_PatchGistsIdCommentsCommentId_577201, base: "/",
    url: url_PatchGistsIdCommentsCommentId_577202, schemes: {Scheme.Https})
type
  Call_DeleteGistsIdCommentsCommentId_577190 = ref object of OpenApiRestCall_576564
proc url_DeleteGistsIdCommentsCommentId_577192(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteGistsIdCommentsCommentId_577191(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_577193 = path.getOrDefault("id")
  valid_577193 = validateParameter(valid_577193, JInt, required = true, default = nil)
  if valid_577193 != nil:
    section.add "id", valid_577193
  var valid_577194 = path.getOrDefault("commentId")
  valid_577194 = validateParameter(valid_577194, JInt, required = true, default = nil)
  if valid_577194 != nil:
    section.add "commentId", valid_577194
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577195 = header.getOrDefault("Accept")
  valid_577195 = validateParameter(valid_577195, JString, required = false,
                                 default = nil)
  if valid_577195 != nil:
    section.add "Accept", valid_577195
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577196: Call_DeleteGistsIdCommentsCommentId_577190; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete a comment.
  ## 
  let valid = call_577196.validator(path, query, header, formData, body)
  let scheme = call_577196.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577196.url(scheme.get, call_577196.host, call_577196.base,
                         call_577196.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577196, url, valid)

proc call*(call_577197: Call_DeleteGistsIdCommentsCommentId_577190; id: int;
          commentId: int; Accept: string = ""): Recallable =
  ## deleteGistsIdCommentsCommentId
  ## Delete a comment.
  ##   id: int (required)
  ##     : Id of gist.
  ##   commentId: int (required)
  ##            : Id of comment.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577198 = newJObject()
  var header_577199 = newJObject()
  add(path_577198, "id", newJInt(id))
  add(path_577198, "commentId", newJInt(commentId))
  add(header_577199, "Accept", newJString(Accept))
  result = call_577197.call(path_577198, nil, header_577199, nil, nil)

var deleteGistsIdCommentsCommentId* = Call_DeleteGistsIdCommentsCommentId_577190(
    name: "deleteGistsIdCommentsCommentId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/gists/{id}/comments/{commentId}",
    validator: validate_DeleteGistsIdCommentsCommentId_577191, base: "/",
    url: url_DeleteGistsIdCommentsCommentId_577192, schemes: {Scheme.Https})
type
  Call_PostGistsIdForks_577212 = ref object of OpenApiRestCall_576564
proc url_PostGistsIdForks_577214(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/forks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostGistsIdForks_577213(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Fork a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_577215 = path.getOrDefault("id")
  valid_577215 = validateParameter(valid_577215, JInt, required = true, default = nil)
  if valid_577215 != nil:
    section.add "id", valid_577215
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577216 = header.getOrDefault("Accept")
  valid_577216 = validateParameter(valid_577216, JString, required = false,
                                 default = nil)
  if valid_577216 != nil:
    section.add "Accept", valid_577216
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577217: Call_PostGistsIdForks_577212; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Fork a gist.
  ## 
  let valid = call_577217.validator(path, query, header, formData, body)
  let scheme = call_577217.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577217.url(scheme.get, call_577217.host, call_577217.base,
                         call_577217.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577217, url, valid)

proc call*(call_577218: Call_PostGistsIdForks_577212; id: int; Accept: string = ""): Recallable =
  ## postGistsIdForks
  ## Fork a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577219 = newJObject()
  var header_577220 = newJObject()
  add(path_577219, "id", newJInt(id))
  add(header_577220, "Accept", newJString(Accept))
  result = call_577218.call(path_577219, nil, header_577220, nil, nil)

var postGistsIdForks* = Call_PostGistsIdForks_577212(name: "postGistsIdForks",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/gists/{id}/forks",
    validator: validate_PostGistsIdForks_577213, base: "/",
    url: url_PostGistsIdForks_577214, schemes: {Scheme.Https})
type
  Call_PutGistsIdStar_577230 = ref object of OpenApiRestCall_576564
proc url_PutGistsIdStar_577232(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/star")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutGistsIdStar_577231(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Star a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_577233 = path.getOrDefault("id")
  valid_577233 = validateParameter(valid_577233, JInt, required = true, default = nil)
  if valid_577233 != nil:
    section.add "id", valid_577233
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577234 = header.getOrDefault("Accept")
  valid_577234 = validateParameter(valid_577234, JString, required = false,
                                 default = nil)
  if valid_577234 != nil:
    section.add "Accept", valid_577234
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577235: Call_PutGistsIdStar_577230; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Star a gist.
  ## 
  let valid = call_577235.validator(path, query, header, formData, body)
  let scheme = call_577235.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577235.url(scheme.get, call_577235.host, call_577235.base,
                         call_577235.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577235, url, valid)

proc call*(call_577236: Call_PutGistsIdStar_577230; id: int; Accept: string = ""): Recallable =
  ## putGistsIdStar
  ## Star a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577237 = newJObject()
  var header_577238 = newJObject()
  add(path_577237, "id", newJInt(id))
  add(header_577238, "Accept", newJString(Accept))
  result = call_577236.call(path_577237, nil, header_577238, nil, nil)

var putGistsIdStar* = Call_PutGistsIdStar_577230(name: "putGistsIdStar",
    meth: HttpMethod.HttpPut, host: "api.github.com", route: "/gists/{id}/star",
    validator: validate_PutGistsIdStar_577231, base: "/", url: url_PutGistsIdStar_577232,
    schemes: {Scheme.Https})
type
  Call_GetGistsIdStar_577221 = ref object of OpenApiRestCall_576564
proc url_GetGistsIdStar_577223(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/star")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsIdStar_577222(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Check if a gist is starred.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_577224 = path.getOrDefault("id")
  valid_577224 = validateParameter(valid_577224, JInt, required = true, default = nil)
  if valid_577224 != nil:
    section.add "id", valid_577224
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577225 = header.getOrDefault("Accept")
  valid_577225 = validateParameter(valid_577225, JString, required = false,
                                 default = nil)
  if valid_577225 != nil:
    section.add "Accept", valid_577225
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577226: Call_GetGistsIdStar_577221; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Check if a gist is starred.
  ## 
  let valid = call_577226.validator(path, query, header, formData, body)
  let scheme = call_577226.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577226.url(scheme.get, call_577226.host, call_577226.base,
                         call_577226.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577226, url, valid)

proc call*(call_577227: Call_GetGistsIdStar_577221; id: int; Accept: string = ""): Recallable =
  ## getGistsIdStar
  ## Check if a gist is starred.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577228 = newJObject()
  var header_577229 = newJObject()
  add(path_577228, "id", newJInt(id))
  add(header_577229, "Accept", newJString(Accept))
  result = call_577227.call(path_577228, nil, header_577229, nil, nil)

var getGistsIdStar* = Call_GetGistsIdStar_577221(name: "getGistsIdStar",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/gists/{id}/star",
    validator: validate_GetGistsIdStar_577222, base: "/", url: url_GetGistsIdStar_577223,
    schemes: {Scheme.Https})
type
  Call_DeleteGistsIdStar_577239 = ref object of OpenApiRestCall_576564
proc url_DeleteGistsIdStar_577241(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/star")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteGistsIdStar_577240(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Unstar a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_577242 = path.getOrDefault("id")
  valid_577242 = validateParameter(valid_577242, JInt, required = true, default = nil)
  if valid_577242 != nil:
    section.add "id", valid_577242
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577243 = header.getOrDefault("Accept")
  valid_577243 = validateParameter(valid_577243, JString, required = false,
                                 default = nil)
  if valid_577243 != nil:
    section.add "Accept", valid_577243
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577244: Call_DeleteGistsIdStar_577239; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Unstar a gist.
  ## 
  let valid = call_577244.validator(path, query, header, formData, body)
  let scheme = call_577244.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577244.url(scheme.get, call_577244.host, call_577244.base,
                         call_577244.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577244, url, valid)

proc call*(call_577245: Call_DeleteGistsIdStar_577239; id: int; Accept: string = ""): Recallable =
  ## deleteGistsIdStar
  ## Unstar a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577246 = newJObject()
  var header_577247 = newJObject()
  add(path_577246, "id", newJInt(id))
  add(header_577247, "Accept", newJString(Accept))
  result = call_577245.call(path_577246, nil, header_577247, nil, nil)

var deleteGistsIdStar* = Call_DeleteGistsIdStar_577239(name: "deleteGistsIdStar",
    meth: HttpMethod.HttpDelete, host: "api.github.com", route: "/gists/{id}/star",
    validator: validate_DeleteGistsIdStar_577240, base: "/",
    url: url_DeleteGistsIdStar_577241, schemes: {Scheme.Https})
type
  Call_GetGitignoreTemplates_577248 = ref object of OpenApiRestCall_576564
proc url_GetGitignoreTemplates_577250(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGitignoreTemplates_577249(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Listing available templates.
  ## List all templates available to pass as an option when creating a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577251 = header.getOrDefault("Accept")
  valid_577251 = validateParameter(valid_577251, JString, required = false,
                                 default = nil)
  if valid_577251 != nil:
    section.add "Accept", valid_577251
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577252: Call_GetGitignoreTemplates_577248; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Listing available templates.
  ## List all templates available to pass as an option when creating a repository.
  ## 
  ## 
  let valid = call_577252.validator(path, query, header, formData, body)
  let scheme = call_577252.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577252.url(scheme.get, call_577252.host, call_577252.base,
                         call_577252.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577252, url, valid)

proc call*(call_577253: Call_GetGitignoreTemplates_577248; Accept: string = ""): Recallable =
  ## getGitignoreTemplates
  ## Listing available templates.
  ## List all templates available to pass as an option when creating a repository.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_577254 = newJObject()
  add(header_577254, "Accept", newJString(Accept))
  result = call_577253.call(nil, nil, header_577254, nil, nil)

var getGitignoreTemplates* = Call_GetGitignoreTemplates_577248(
    name: "getGitignoreTemplates", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/gitignore/templates", validator: validate_GetGitignoreTemplates_577249,
    base: "/", url: url_GetGitignoreTemplates_577250, schemes: {Scheme.Https})
type
  Call_GetGitignoreTemplatesLanguage_577255 = ref object of OpenApiRestCall_576564
proc url_GetGitignoreTemplatesLanguage_577257(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "language" in path, "`language` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gitignore/templates/"),
               (kind: VariableSegment, value: "language")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGitignoreTemplatesLanguage_577256(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   language: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `language` field"
  var valid_577258 = path.getOrDefault("language")
  valid_577258 = validateParameter(valid_577258, JString, required = true,
                                 default = nil)
  if valid_577258 != nil:
    section.add "language", valid_577258
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577259 = header.getOrDefault("Accept")
  valid_577259 = validateParameter(valid_577259, JString, required = false,
                                 default = nil)
  if valid_577259 != nil:
    section.add "Accept", valid_577259
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577260: Call_GetGitignoreTemplatesLanguage_577255; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a single template.
  ## 
  let valid = call_577260.validator(path, query, header, formData, body)
  let scheme = call_577260.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577260.url(scheme.get, call_577260.host, call_577260.base,
                         call_577260.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577260, url, valid)

proc call*(call_577261: Call_GetGitignoreTemplatesLanguage_577255;
          language: string; Accept: string = ""): Recallable =
  ## getGitignoreTemplatesLanguage
  ## Get a single template.
  ##   language: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577262 = newJObject()
  var header_577263 = newJObject()
  add(path_577262, "language", newJString(language))
  add(header_577263, "Accept", newJString(Accept))
  result = call_577261.call(path_577262, nil, header_577263, nil, nil)

var getGitignoreTemplatesLanguage* = Call_GetGitignoreTemplatesLanguage_577255(
    name: "getGitignoreTemplatesLanguage", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/gitignore/templates/{language}",
    validator: validate_GetGitignoreTemplatesLanguage_577256, base: "/",
    url: url_GetGitignoreTemplatesLanguage_577257, schemes: {Scheme.Https})
type
  Call_GetIssues_577264 = ref object of OpenApiRestCall_576564
proc url_GetIssues_577266(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetIssues_577265(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## List issues.
  ## List all issues across all the authenticated user's visible repositories.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   direction: JString (required)
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  ##   state: JString (required)
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   sort: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `labels` field"
  var valid_577267 = query.getOrDefault("labels")
  valid_577267 = validateParameter(valid_577267, JString, required = true,
                                 default = nil)
  if valid_577267 != nil:
    section.add "labels", valid_577267
  var valid_577281 = query.getOrDefault("direction")
  valid_577281 = validateParameter(valid_577281, JString, required = true,
                                 default = newJString("desc"))
  if valid_577281 != nil:
    section.add "direction", valid_577281
  var valid_577282 = query.getOrDefault("since")
  valid_577282 = validateParameter(valid_577282, JString, required = false,
                                 default = nil)
  if valid_577282 != nil:
    section.add "since", valid_577282
  var valid_577283 = query.getOrDefault("state")
  valid_577283 = validateParameter(valid_577283, JString, required = true,
                                 default = newJString("open"))
  if valid_577283 != nil:
    section.add "state", valid_577283
  var valid_577284 = query.getOrDefault("filter")
  valid_577284 = validateParameter(valid_577284, JString, required = true,
                                 default = newJString("all"))
  if valid_577284 != nil:
    section.add "filter", valid_577284
  var valid_577285 = query.getOrDefault("sort")
  valid_577285 = validateParameter(valid_577285, JString, required = true,
                                 default = newJString("created"))
  if valid_577285 != nil:
    section.add "sort", valid_577285
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577286 = header.getOrDefault("Accept")
  valid_577286 = validateParameter(valid_577286, JString, required = false,
                                 default = nil)
  if valid_577286 != nil:
    section.add "Accept", valid_577286
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577287: Call_GetIssues_577264; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List issues.
  ## List all issues across all the authenticated user's visible repositories.
  ## 
  ## 
  let valid = call_577287.validator(path, query, header, formData, body)
  let scheme = call_577287.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577287.url(scheme.get, call_577287.host, call_577287.base,
                         call_577287.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577287, url, valid)

proc call*(call_577288: Call_GetIssues_577264; labels: string;
          direction: string = "desc"; since: string = ""; state: string = "open";
          filter: string = "all"; Accept: string = ""; sort: string = "created"): Recallable =
  ## getIssues
  ## List issues.
  ## List all issues across all the authenticated user's visible repositories.
  ## 
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   direction: string (required)
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  ##   state: string (required)
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string (required)
  var query_577289 = newJObject()
  var header_577290 = newJObject()
  add(query_577289, "labels", newJString(labels))
  add(query_577289, "direction", newJString(direction))
  add(query_577289, "since", newJString(since))
  add(query_577289, "state", newJString(state))
  add(query_577289, "filter", newJString(filter))
  add(header_577290, "Accept", newJString(Accept))
  add(query_577289, "sort", newJString(sort))
  result = call_577288.call(nil, query_577289, header_577290, nil, nil)

var getIssues* = Call_GetIssues_577264(name: "getIssues", meth: HttpMethod.HttpGet,
                                    host: "api.github.com", route: "/issues",
                                    validator: validate_GetIssues_577265,
                                    base: "/", url: url_GetIssues_577266,
                                    schemes: {Scheme.Https})
type
  Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_577291 = ref object of OpenApiRestCall_576564
proc url_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_577293(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repository" in path, "`repository` is a required path parameter"
  assert "state" in path, "`state` is a required path parameter"
  assert "keyword" in path, "`keyword` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/issues/search/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repository"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "state"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "keyword")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_577292(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Find issues by state and keyword.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repository: JString (required)
  ##   state: JString (required)
  ##        : Indicates the state of the issues to return. Can be either open or closed.
  ##   owner: JString (required)
  ##   keyword: JString (required)
  ##          : The search term.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `repository` field"
  var valid_577294 = path.getOrDefault("repository")
  valid_577294 = validateParameter(valid_577294, JString, required = true,
                                 default = nil)
  if valid_577294 != nil:
    section.add "repository", valid_577294
  var valid_577295 = path.getOrDefault("state")
  valid_577295 = validateParameter(valid_577295, JString, required = true,
                                 default = newJString("open"))
  if valid_577295 != nil:
    section.add "state", valid_577295
  var valid_577296 = path.getOrDefault("owner")
  valid_577296 = validateParameter(valid_577296, JString, required = true,
                                 default = nil)
  if valid_577296 != nil:
    section.add "owner", valid_577296
  var valid_577297 = path.getOrDefault("keyword")
  valid_577297 = validateParameter(valid_577297, JString, required = true,
                                 default = nil)
  if valid_577297 != nil:
    section.add "keyword", valid_577297
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577298 = header.getOrDefault("Accept")
  valid_577298 = validateParameter(valid_577298, JString, required = false,
                                 default = nil)
  if valid_577298 != nil:
    section.add "Accept", valid_577298
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577299: Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_577291;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Find issues by state and keyword.
  ## 
  let valid = call_577299.validator(path, query, header, formData, body)
  let scheme = call_577299.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577299.url(scheme.get, call_577299.host, call_577299.base,
                         call_577299.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577299, url, valid)

proc call*(call_577300: Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_577291;
          repository: string; owner: string; keyword: string; state: string = "open";
          Accept: string = ""): Recallable =
  ## getLegacyIssuesSearchOwnerRepositoryStateKeyword
  ## Find issues by state and keyword.
  ##   repository: string (required)
  ##   state: string (required)
  ##        : Indicates the state of the issues to return. Can be either open or closed.
  ##   owner: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   keyword: string (required)
  ##          : The search term.
  var path_577301 = newJObject()
  var header_577302 = newJObject()
  add(path_577301, "repository", newJString(repository))
  add(path_577301, "state", newJString(state))
  add(path_577301, "owner", newJString(owner))
  add(header_577302, "Accept", newJString(Accept))
  add(path_577301, "keyword", newJString(keyword))
  result = call_577300.call(path_577301, nil, header_577302, nil, nil)

var getLegacyIssuesSearchOwnerRepositoryStateKeyword* = Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_577291(
    name: "getLegacyIssuesSearchOwnerRepositoryStateKeyword",
    meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/legacy/issues/search/{owner}/{repository}/{state}/{keyword}",
    validator: validate_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_577292,
    base: "/", url: url_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_577293,
    schemes: {Scheme.Https})
type
  Call_GetLegacyReposSearchKeyword_577303 = ref object of OpenApiRestCall_576564
proc url_GetLegacyReposSearchKeyword_577305(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyword" in path, "`keyword` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/repos/search/"),
               (kind: VariableSegment, value: "keyword")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyReposSearchKeyword_577304(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Find repositories by keyword. Note, this legacy method does not follow the v3 pagination pattern. This method returns up to 100 results per page and pages can be fetched using the start_page parameter.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyword: JString (required)
  ##          : The search term
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyword` field"
  var valid_577306 = path.getOrDefault("keyword")
  valid_577306 = validateParameter(valid_577306, JString, required = true,
                                 default = nil)
  if valid_577306 != nil:
    section.add "keyword", valid_577306
  result.add "path", section
  ## parameters in `query` object:
  ##   start_page: JString
  ##             : The page number to fetch
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   language: JString
  ##           : Filter results by language
  ##   sort: JString
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  section = newJObject()
  var valid_577307 = query.getOrDefault("start_page")
  valid_577307 = validateParameter(valid_577307, JString, required = false,
                                 default = nil)
  if valid_577307 != nil:
    section.add "start_page", valid_577307
  var valid_577308 = query.getOrDefault("order")
  valid_577308 = validateParameter(valid_577308, JString, required = false,
                                 default = newJString("desc"))
  if valid_577308 != nil:
    section.add "order", valid_577308
  var valid_577309 = query.getOrDefault("language")
  valid_577309 = validateParameter(valid_577309, JString, required = false,
                                 default = nil)
  if valid_577309 != nil:
    section.add "language", valid_577309
  var valid_577310 = query.getOrDefault("sort")
  valid_577310 = validateParameter(valid_577310, JString, required = false,
                                 default = newJString("updated"))
  if valid_577310 != nil:
    section.add "sort", valid_577310
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577311 = header.getOrDefault("Accept")
  valid_577311 = validateParameter(valid_577311, JString, required = false,
                                 default = nil)
  if valid_577311 != nil:
    section.add "Accept", valid_577311
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577312: Call_GetLegacyReposSearchKeyword_577303; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Find repositories by keyword. Note, this legacy method does not follow the v3 pagination pattern. This method returns up to 100 results per page and pages can be fetched using the start_page parameter.
  ## 
  let valid = call_577312.validator(path, query, header, formData, body)
  let scheme = call_577312.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577312.url(scheme.get, call_577312.host, call_577312.base,
                         call_577312.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577312, url, valid)

proc call*(call_577313: Call_GetLegacyReposSearchKeyword_577303; keyword: string;
          startPage: string = ""; order: string = "desc"; Accept: string = "";
          language: string = ""; sort: string = "updated"): Recallable =
  ## getLegacyReposSearchKeyword
  ## Find repositories by keyword. Note, this legacy method does not follow the v3 pagination pattern. This method returns up to 100 results per page and pages can be fetched using the start_page parameter.
  ##   startPage: string
  ##            : The page number to fetch
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   keyword: string (required)
  ##          : The search term
  ##   language: string
  ##           : Filter results by language
  ##   sort: string
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  var path_577314 = newJObject()
  var query_577315 = newJObject()
  var header_577316 = newJObject()
  add(query_577315, "start_page", newJString(startPage))
  add(query_577315, "order", newJString(order))
  add(header_577316, "Accept", newJString(Accept))
  add(path_577314, "keyword", newJString(keyword))
  add(query_577315, "language", newJString(language))
  add(query_577315, "sort", newJString(sort))
  result = call_577313.call(path_577314, query_577315, header_577316, nil, nil)

var getLegacyReposSearchKeyword* = Call_GetLegacyReposSearchKeyword_577303(
    name: "getLegacyReposSearchKeyword", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/legacy/repos/search/{keyword}",
    validator: validate_GetLegacyReposSearchKeyword_577304, base: "/",
    url: url_GetLegacyReposSearchKeyword_577305, schemes: {Scheme.Https})
type
  Call_GetLegacyUserEmailEmail_577317 = ref object of OpenApiRestCall_576564
proc url_GetLegacyUserEmailEmail_577319(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "email" in path, "`email` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/user/email/"),
               (kind: VariableSegment, value: "email")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyUserEmailEmail_577318(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This API call is added for compatibility reasons only.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   email: JString (required)
  ##        : The email address
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `email` field"
  var valid_577320 = path.getOrDefault("email")
  valid_577320 = validateParameter(valid_577320, JString, required = true,
                                 default = nil)
  if valid_577320 != nil:
    section.add "email", valid_577320
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577321 = header.getOrDefault("Accept")
  valid_577321 = validateParameter(valid_577321, JString, required = false,
                                 default = nil)
  if valid_577321 != nil:
    section.add "Accept", valid_577321
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577322: Call_GetLegacyUserEmailEmail_577317; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This API call is added for compatibility reasons only.
  ## 
  let valid = call_577322.validator(path, query, header, formData, body)
  let scheme = call_577322.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577322.url(scheme.get, call_577322.host, call_577322.base,
                         call_577322.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577322, url, valid)

proc call*(call_577323: Call_GetLegacyUserEmailEmail_577317; email: string;
          Accept: string = ""): Recallable =
  ## getLegacyUserEmailEmail
  ## This API call is added for compatibility reasons only.
  ##   email: string (required)
  ##        : The email address
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577324 = newJObject()
  var header_577325 = newJObject()
  add(path_577324, "email", newJString(email))
  add(header_577325, "Accept", newJString(Accept))
  result = call_577323.call(path_577324, nil, header_577325, nil, nil)

var getLegacyUserEmailEmail* = Call_GetLegacyUserEmailEmail_577317(
    name: "getLegacyUserEmailEmail", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/legacy/user/email/{email}",
    validator: validate_GetLegacyUserEmailEmail_577318, base: "/",
    url: url_GetLegacyUserEmailEmail_577319, schemes: {Scheme.Https})
type
  Call_GetLegacyUserSearchKeyword_577326 = ref object of OpenApiRestCall_576564
proc url_GetLegacyUserSearchKeyword_577328(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyword" in path, "`keyword` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/user/search/"),
               (kind: VariableSegment, value: "keyword")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyUserSearchKeyword_577327(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Find users by keyword.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyword: JString (required)
  ##          : The search term
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyword` field"
  var valid_577329 = path.getOrDefault("keyword")
  valid_577329 = validateParameter(valid_577329, JString, required = true,
                                 default = nil)
  if valid_577329 != nil:
    section.add "keyword", valid_577329
  result.add "path", section
  ## parameters in `query` object:
  ##   start_page: JString
  ##             : The page number to fetch
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   sort: JString
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  section = newJObject()
  var valid_577330 = query.getOrDefault("start_page")
  valid_577330 = validateParameter(valid_577330, JString, required = false,
                                 default = nil)
  if valid_577330 != nil:
    section.add "start_page", valid_577330
  var valid_577331 = query.getOrDefault("order")
  valid_577331 = validateParameter(valid_577331, JString, required = false,
                                 default = newJString("desc"))
  if valid_577331 != nil:
    section.add "order", valid_577331
  var valid_577332 = query.getOrDefault("sort")
  valid_577332 = validateParameter(valid_577332, JString, required = false,
                                 default = newJString("updated"))
  if valid_577332 != nil:
    section.add "sort", valid_577332
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577333 = header.getOrDefault("Accept")
  valid_577333 = validateParameter(valid_577333, JString, required = false,
                                 default = nil)
  if valid_577333 != nil:
    section.add "Accept", valid_577333
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577334: Call_GetLegacyUserSearchKeyword_577326; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Find users by keyword.
  ## 
  let valid = call_577334.validator(path, query, header, formData, body)
  let scheme = call_577334.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577334.url(scheme.get, call_577334.host, call_577334.base,
                         call_577334.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577334, url, valid)

proc call*(call_577335: Call_GetLegacyUserSearchKeyword_577326; keyword: string;
          startPage: string = ""; order: string = "desc"; Accept: string = "";
          sort: string = "updated"): Recallable =
  ## getLegacyUserSearchKeyword
  ## Find users by keyword.
  ##   startPage: string
  ##            : The page number to fetch
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   keyword: string (required)
  ##          : The search term
  ##   sort: string
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  var path_577336 = newJObject()
  var query_577337 = newJObject()
  var header_577338 = newJObject()
  add(query_577337, "start_page", newJString(startPage))
  add(query_577337, "order", newJString(order))
  add(header_577338, "Accept", newJString(Accept))
  add(path_577336, "keyword", newJString(keyword))
  add(query_577337, "sort", newJString(sort))
  result = call_577335.call(path_577336, query_577337, header_577338, nil, nil)

var getLegacyUserSearchKeyword* = Call_GetLegacyUserSearchKeyword_577326(
    name: "getLegacyUserSearchKeyword", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/legacy/user/search/{keyword}",
    validator: validate_GetLegacyUserSearchKeyword_577327, base: "/",
    url: url_GetLegacyUserSearchKeyword_577328, schemes: {Scheme.Https})
type
  Call_PostMarkdown_577339 = ref object of OpenApiRestCall_576564
proc url_PostMarkdown_577341(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostMarkdown_577340(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Render an arbitrary Markdown document
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577342 = header.getOrDefault("Accept")
  valid_577342 = validateParameter(valid_577342, JString, required = false,
                                 default = nil)
  if valid_577342 != nil:
    section.add "Accept", valid_577342
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_577344: Call_PostMarkdown_577339; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Render an arbitrary Markdown document
  ## 
  let valid = call_577344.validator(path, query, header, formData, body)
  let scheme = call_577344.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577344.url(scheme.get, call_577344.host, call_577344.base,
                         call_577344.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577344, url, valid)

proc call*(call_577345: Call_PostMarkdown_577339; body: JsonNode; Accept: string = ""): Recallable =
  ## postMarkdown
  ## Render an arbitrary Markdown document
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_577346 = newJObject()
  var body_577347 = newJObject()
  if body != nil:
    body_577347 = body
  add(header_577346, "Accept", newJString(Accept))
  result = call_577345.call(nil, nil, header_577346, nil, body_577347)

var postMarkdown* = Call_PostMarkdown_577339(name: "postMarkdown",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/markdown",
    validator: validate_PostMarkdown_577340, base: "/", url: url_PostMarkdown_577341,
    schemes: {Scheme.Https})
type
  Call_PostMarkdownRaw_577348 = ref object of OpenApiRestCall_576564
proc url_PostMarkdownRaw_577350(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostMarkdownRaw_577349(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Render a Markdown document in raw mode
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577351 = header.getOrDefault("Accept")
  valid_577351 = validateParameter(valid_577351, JString, required = false,
                                 default = nil)
  if valid_577351 != nil:
    section.add "Accept", valid_577351
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577352: Call_PostMarkdownRaw_577348; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Render a Markdown document in raw mode
  ## 
  let valid = call_577352.validator(path, query, header, formData, body)
  let scheme = call_577352.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577352.url(scheme.get, call_577352.host, call_577352.base,
                         call_577352.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577352, url, valid)

proc call*(call_577353: Call_PostMarkdownRaw_577348; Accept: string = ""): Recallable =
  ## postMarkdownRaw
  ## Render a Markdown document in raw mode
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_577354 = newJObject()
  add(header_577354, "Accept", newJString(Accept))
  result = call_577353.call(nil, nil, header_577354, nil, nil)

var postMarkdownRaw* = Call_PostMarkdownRaw_577348(name: "postMarkdownRaw",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/markdown/raw",
    validator: validate_PostMarkdownRaw_577349, base: "/", url: url_PostMarkdownRaw_577350,
    schemes: {Scheme.Https})
type
  Call_GetMeta_577355 = ref object of OpenApiRestCall_576564
proc url_GetMeta_577357(protocol: Scheme; host: string; base: string; route: string;
                       path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetMeta_577356(path: JsonNode; query: JsonNode; header: JsonNode;
                            formData: JsonNode; body: JsonNode): JsonNode =
  ## This gives some information about GitHub.com, the service.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577358 = header.getOrDefault("Accept")
  valid_577358 = validateParameter(valid_577358, JString, required = false,
                                 default = nil)
  if valid_577358 != nil:
    section.add "Accept", valid_577358
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577359: Call_GetMeta_577355; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This gives some information about GitHub.com, the service.
  ## 
  let valid = call_577359.validator(path, query, header, formData, body)
  let scheme = call_577359.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577359.url(scheme.get, call_577359.host, call_577359.base,
                         call_577359.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577359, url, valid)

proc call*(call_577360: Call_GetMeta_577355; Accept: string = ""): Recallable =
  ## getMeta
  ## This gives some information about GitHub.com, the service.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_577361 = newJObject()
  add(header_577361, "Accept", newJString(Accept))
  result = call_577360.call(nil, nil, header_577361, nil, nil)

var getMeta* = Call_GetMeta_577355(name: "getMeta", meth: HttpMethod.HttpGet,
                                host: "api.github.com", route: "/meta",
                                validator: validate_GetMeta_577356, base: "/",
                                url: url_GetMeta_577357, schemes: {Scheme.Https})
type
  Call_GetNetworksOwnerRepoEvents_577362 = ref object of OpenApiRestCall_576564
proc url_GetNetworksOwnerRepoEvents_577364(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/networks/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetNetworksOwnerRepoEvents_577363(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List public events for a network of repositories.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of the owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577365 = path.getOrDefault("repo")
  valid_577365 = validateParameter(valid_577365, JString, required = true,
                                 default = nil)
  if valid_577365 != nil:
    section.add "repo", valid_577365
  var valid_577366 = path.getOrDefault("owner")
  valid_577366 = validateParameter(valid_577366, JString, required = true,
                                 default = nil)
  if valid_577366 != nil:
    section.add "owner", valid_577366
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577367 = header.getOrDefault("Accept")
  valid_577367 = validateParameter(valid_577367, JString, required = false,
                                 default = nil)
  if valid_577367 != nil:
    section.add "Accept", valid_577367
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577368: Call_GetNetworksOwnerRepoEvents_577362; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List public events for a network of repositories.
  ## 
  let valid = call_577368.validator(path, query, header, formData, body)
  let scheme = call_577368.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577368.url(scheme.get, call_577368.host, call_577368.base,
                         call_577368.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577368, url, valid)

proc call*(call_577369: Call_GetNetworksOwnerRepoEvents_577362; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getNetworksOwnerRepoEvents
  ## List public events for a network of repositories.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of the owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577370 = newJObject()
  var header_577371 = newJObject()
  add(path_577370, "repo", newJString(repo))
  add(path_577370, "owner", newJString(owner))
  add(header_577371, "Accept", newJString(Accept))
  result = call_577369.call(path_577370, nil, header_577371, nil, nil)

var getNetworksOwnerRepoEvents* = Call_GetNetworksOwnerRepoEvents_577362(
    name: "getNetworksOwnerRepoEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/networks/{owner}/{repo}/events",
    validator: validate_GetNetworksOwnerRepoEvents_577363, base: "/",
    url: url_GetNetworksOwnerRepoEvents_577364, schemes: {Scheme.Https})
type
  Call_PutNotifications_577383 = ref object of OpenApiRestCall_576564
proc url_PutNotifications_577385(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PutNotifications_577384(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Mark as read.
  ## Marking a notification as "read" removes it from the default view on GitHub.com.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577386 = header.getOrDefault("Accept")
  valid_577386 = validateParameter(valid_577386, JString, required = false,
                                 default = nil)
  if valid_577386 != nil:
    section.add "Accept", valid_577386
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_577388: Call_PutNotifications_577383; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Mark as read.
  ## Marking a notification as "read" removes it from the default view on GitHub.com.
  ## 
  ## 
  let valid = call_577388.validator(path, query, header, formData, body)
  let scheme = call_577388.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577388.url(scheme.get, call_577388.host, call_577388.base,
                         call_577388.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577388, url, valid)

proc call*(call_577389: Call_PutNotifications_577383; body: JsonNode;
          Accept: string = ""): Recallable =
  ## putNotifications
  ## Mark as read.
  ## Marking a notification as "read" removes it from the default view on GitHub.com.
  ## 
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_577390 = newJObject()
  var body_577391 = newJObject()
  if body != nil:
    body_577391 = body
  add(header_577390, "Accept", newJString(Accept))
  result = call_577389.call(nil, nil, header_577390, nil, body_577391)

var putNotifications* = Call_PutNotifications_577383(name: "putNotifications",
    meth: HttpMethod.HttpPut, host: "api.github.com", route: "/notifications",
    validator: validate_PutNotifications_577384, base: "/",
    url: url_PutNotifications_577385, schemes: {Scheme.Https})
type
  Call_GetNotifications_577372 = ref object of OpenApiRestCall_576564
proc url_GetNotifications_577374(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetNotifications_577373(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## List your notifications.
  ## List all notifications for the current user, grouped by repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   all: JBool
  ##      : True to show notifications marked as read.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   participating: JBool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  section = newJObject()
  var valid_577375 = query.getOrDefault("all")
  valid_577375 = validateParameter(valid_577375, JBool, required = false, default = nil)
  if valid_577375 != nil:
    section.add "all", valid_577375
  var valid_577376 = query.getOrDefault("since")
  valid_577376 = validateParameter(valid_577376, JString, required = false,
                                 default = nil)
  if valid_577376 != nil:
    section.add "since", valid_577376
  var valid_577377 = query.getOrDefault("participating")
  valid_577377 = validateParameter(valid_577377, JBool, required = false, default = nil)
  if valid_577377 != nil:
    section.add "participating", valid_577377
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577378 = header.getOrDefault("Accept")
  valid_577378 = validateParameter(valid_577378, JString, required = false,
                                 default = nil)
  if valid_577378 != nil:
    section.add "Accept", valid_577378
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577379: Call_GetNotifications_577372; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List your notifications.
  ## List all notifications for the current user, grouped by repository.
  ## 
  ## 
  let valid = call_577379.validator(path, query, header, formData, body)
  let scheme = call_577379.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577379.url(scheme.get, call_577379.host, call_577379.base,
                         call_577379.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577379, url, valid)

proc call*(call_577380: Call_GetNotifications_577372; all: bool = false;
          since: string = ""; participating: bool = false; Accept: string = ""): Recallable =
  ## getNotifications
  ## List your notifications.
  ## List all notifications for the current user, grouped by repository.
  ## 
  ##   all: bool
  ##      : True to show notifications marked as read.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   participating: bool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var query_577381 = newJObject()
  var header_577382 = newJObject()
  add(query_577381, "all", newJBool(all))
  add(query_577381, "since", newJString(since))
  add(query_577381, "participating", newJBool(participating))
  add(header_577382, "Accept", newJString(Accept))
  result = call_577380.call(nil, query_577381, header_577382, nil, nil)

var getNotifications* = Call_GetNotifications_577372(name: "getNotifications",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/notifications",
    validator: validate_GetNotifications_577373, base: "/",
    url: url_GetNotifications_577374, schemes: {Scheme.Https})
type
  Call_GetNotificationsThreadsId_577392 = ref object of OpenApiRestCall_576564
proc url_GetNotificationsThreadsId_577394(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetNotificationsThreadsId_577393(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## View a single thread.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_577395 = path.getOrDefault("id")
  valid_577395 = validateParameter(valid_577395, JInt, required = true, default = nil)
  if valid_577395 != nil:
    section.add "id", valid_577395
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577396 = header.getOrDefault("Accept")
  valid_577396 = validateParameter(valid_577396, JString, required = false,
                                 default = nil)
  if valid_577396 != nil:
    section.add "Accept", valid_577396
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577397: Call_GetNotificationsThreadsId_577392; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## View a single thread.
  ## 
  let valid = call_577397.validator(path, query, header, formData, body)
  let scheme = call_577397.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577397.url(scheme.get, call_577397.host, call_577397.base,
                         call_577397.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577397, url, valid)

proc call*(call_577398: Call_GetNotificationsThreadsId_577392; id: int;
          Accept: string = ""): Recallable =
  ## getNotificationsThreadsId
  ## View a single thread.
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577399 = newJObject()
  var header_577400 = newJObject()
  add(path_577399, "id", newJInt(id))
  add(header_577400, "Accept", newJString(Accept))
  result = call_577398.call(path_577399, nil, header_577400, nil, nil)

var getNotificationsThreadsId* = Call_GetNotificationsThreadsId_577392(
    name: "getNotificationsThreadsId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/notifications/threads/{id}",
    validator: validate_GetNotificationsThreadsId_577393, base: "/",
    url: url_GetNotificationsThreadsId_577394, schemes: {Scheme.Https})
type
  Call_PatchNotificationsThreadsId_577401 = ref object of OpenApiRestCall_576564
proc url_PatchNotificationsThreadsId_577403(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchNotificationsThreadsId_577402(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Mark a thread as read
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_577404 = path.getOrDefault("id")
  valid_577404 = validateParameter(valid_577404, JInt, required = true, default = nil)
  if valid_577404 != nil:
    section.add "id", valid_577404
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577405 = header.getOrDefault("Accept")
  valid_577405 = validateParameter(valid_577405, JString, required = false,
                                 default = nil)
  if valid_577405 != nil:
    section.add "Accept", valid_577405
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577406: Call_PatchNotificationsThreadsId_577401; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Mark a thread as read
  ## 
  let valid = call_577406.validator(path, query, header, formData, body)
  let scheme = call_577406.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577406.url(scheme.get, call_577406.host, call_577406.base,
                         call_577406.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577406, url, valid)

proc call*(call_577407: Call_PatchNotificationsThreadsId_577401; id: int;
          Accept: string = ""): Recallable =
  ## patchNotificationsThreadsId
  ## Mark a thread as read
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577408 = newJObject()
  var header_577409 = newJObject()
  add(path_577408, "id", newJInt(id))
  add(header_577409, "Accept", newJString(Accept))
  result = call_577407.call(path_577408, nil, header_577409, nil, nil)

var patchNotificationsThreadsId* = Call_PatchNotificationsThreadsId_577401(
    name: "patchNotificationsThreadsId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/notifications/threads/{id}",
    validator: validate_PatchNotificationsThreadsId_577402, base: "/",
    url: url_PatchNotificationsThreadsId_577403, schemes: {Scheme.Https})
type
  Call_PutNotificationsThreadsIdSubscription_577419 = ref object of OpenApiRestCall_576564
proc url_PutNotificationsThreadsIdSubscription_577421(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutNotificationsThreadsIdSubscription_577420(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set a Thread Subscription.
  ## This lets you subscribe to a thread, or ignore it. Subscribing to a thread
  ## is unnecessary if the user is already subscribed to the repository. Ignoring
  ## a thread will mute all future notifications (until you comment or get @mentioned).
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_577422 = path.getOrDefault("id")
  valid_577422 = validateParameter(valid_577422, JInt, required = true, default = nil)
  if valid_577422 != nil:
    section.add "id", valid_577422
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577423 = header.getOrDefault("Accept")
  valid_577423 = validateParameter(valid_577423, JString, required = false,
                                 default = nil)
  if valid_577423 != nil:
    section.add "Accept", valid_577423
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_577425: Call_PutNotificationsThreadsIdSubscription_577419;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Set a Thread Subscription.
  ## This lets you subscribe to a thread, or ignore it. Subscribing to a thread
  ## is unnecessary if the user is already subscribed to the repository. Ignoring
  ## a thread will mute all future notifications (until you comment or get @mentioned).
  ## 
  ## 
  let valid = call_577425.validator(path, query, header, formData, body)
  let scheme = call_577425.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577425.url(scheme.get, call_577425.host, call_577425.base,
                         call_577425.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577425, url, valid)

proc call*(call_577426: Call_PutNotificationsThreadsIdSubscription_577419; id: int;
          body: JsonNode; Accept: string = ""): Recallable =
  ## putNotificationsThreadsIdSubscription
  ## Set a Thread Subscription.
  ## This lets you subscribe to a thread, or ignore it. Subscribing to a thread
  ## is unnecessary if the user is already subscribed to the repository. Ignoring
  ## a thread will mute all future notifications (until you comment or get @mentioned).
  ## 
  ##   id: int (required)
  ##     : Id of thread.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577427 = newJObject()
  var header_577428 = newJObject()
  var body_577429 = newJObject()
  add(path_577427, "id", newJInt(id))
  if body != nil:
    body_577429 = body
  add(header_577428, "Accept", newJString(Accept))
  result = call_577426.call(path_577427, nil, header_577428, nil, body_577429)

var putNotificationsThreadsIdSubscription* = Call_PutNotificationsThreadsIdSubscription_577419(
    name: "putNotificationsThreadsIdSubscription", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/notifications/threads/{id}/subscription",
    validator: validate_PutNotificationsThreadsIdSubscription_577420, base: "/",
    url: url_PutNotificationsThreadsIdSubscription_577421, schemes: {Scheme.Https})
type
  Call_GetNotificationsThreadsIdSubscription_577410 = ref object of OpenApiRestCall_576564
proc url_GetNotificationsThreadsIdSubscription_577412(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetNotificationsThreadsIdSubscription_577411(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a Thread Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_577413 = path.getOrDefault("id")
  valid_577413 = validateParameter(valid_577413, JInt, required = true, default = nil)
  if valid_577413 != nil:
    section.add "id", valid_577413
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577414 = header.getOrDefault("Accept")
  valid_577414 = validateParameter(valid_577414, JString, required = false,
                                 default = nil)
  if valid_577414 != nil:
    section.add "Accept", valid_577414
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577415: Call_GetNotificationsThreadsIdSubscription_577410;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a Thread Subscription.
  ## 
  let valid = call_577415.validator(path, query, header, formData, body)
  let scheme = call_577415.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577415.url(scheme.get, call_577415.host, call_577415.base,
                         call_577415.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577415, url, valid)

proc call*(call_577416: Call_GetNotificationsThreadsIdSubscription_577410; id: int;
          Accept: string = ""): Recallable =
  ## getNotificationsThreadsIdSubscription
  ## Get a Thread Subscription.
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577417 = newJObject()
  var header_577418 = newJObject()
  add(path_577417, "id", newJInt(id))
  add(header_577418, "Accept", newJString(Accept))
  result = call_577416.call(path_577417, nil, header_577418, nil, nil)

var getNotificationsThreadsIdSubscription* = Call_GetNotificationsThreadsIdSubscription_577410(
    name: "getNotificationsThreadsIdSubscription", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/notifications/threads/{id}/subscription",
    validator: validate_GetNotificationsThreadsIdSubscription_577411, base: "/",
    url: url_GetNotificationsThreadsIdSubscription_577412, schemes: {Scheme.Https})
type
  Call_DeleteNotificationsThreadsIdSubscription_577430 = ref object of OpenApiRestCall_576564
proc url_DeleteNotificationsThreadsIdSubscription_577432(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteNotificationsThreadsIdSubscription_577431(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a Thread Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_577433 = path.getOrDefault("id")
  valid_577433 = validateParameter(valid_577433, JInt, required = true, default = nil)
  if valid_577433 != nil:
    section.add "id", valid_577433
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577434 = header.getOrDefault("Accept")
  valid_577434 = validateParameter(valid_577434, JString, required = false,
                                 default = nil)
  if valid_577434 != nil:
    section.add "Accept", valid_577434
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577435: Call_DeleteNotificationsThreadsIdSubscription_577430;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a Thread Subscription.
  ## 
  let valid = call_577435.validator(path, query, header, formData, body)
  let scheme = call_577435.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577435.url(scheme.get, call_577435.host, call_577435.base,
                         call_577435.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577435, url, valid)

proc call*(call_577436: Call_DeleteNotificationsThreadsIdSubscription_577430;
          id: int; Accept: string = ""): Recallable =
  ## deleteNotificationsThreadsIdSubscription
  ## Delete a Thread Subscription.
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577437 = newJObject()
  var header_577438 = newJObject()
  add(path_577437, "id", newJInt(id))
  add(header_577438, "Accept", newJString(Accept))
  result = call_577436.call(path_577437, nil, header_577438, nil, nil)

var deleteNotificationsThreadsIdSubscription* = Call_DeleteNotificationsThreadsIdSubscription_577430(
    name: "deleteNotificationsThreadsIdSubscription", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/notifications/threads/{id}/subscription",
    validator: validate_DeleteNotificationsThreadsIdSubscription_577431,
    base: "/", url: url_DeleteNotificationsThreadsIdSubscription_577432,
    schemes: {Scheme.Https})
type
  Call_GetOrgsOrg_577439 = ref object of OpenApiRestCall_576564
proc url_GetOrgsOrg_577441(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrg_577440(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## Get an Organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_577442 = path.getOrDefault("org")
  valid_577442 = validateParameter(valid_577442, JString, required = true,
                                 default = nil)
  if valid_577442 != nil:
    section.add "org", valid_577442
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577443 = header.getOrDefault("Accept")
  valid_577443 = validateParameter(valid_577443, JString, required = false,
                                 default = nil)
  if valid_577443 != nil:
    section.add "Accept", valid_577443
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577444: Call_GetOrgsOrg_577439; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get an Organization.
  ## 
  let valid = call_577444.validator(path, query, header, formData, body)
  let scheme = call_577444.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577444.url(scheme.get, call_577444.host, call_577444.base,
                         call_577444.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577444, url, valid)

proc call*(call_577445: Call_GetOrgsOrg_577439; org: string; Accept: string = ""): Recallable =
  ## getOrgsOrg
  ## Get an Organization.
  ##   org: string (required)
  ##      : Name of organisation.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577446 = newJObject()
  var header_577447 = newJObject()
  add(path_577446, "org", newJString(org))
  add(header_577447, "Accept", newJString(Accept))
  result = call_577445.call(path_577446, nil, header_577447, nil, nil)

var getOrgsOrg* = Call_GetOrgsOrg_577439(name: "getOrgsOrg",
                                      meth: HttpMethod.HttpGet,
                                      host: "api.github.com",
                                      route: "/orgs/{org}",
                                      validator: validate_GetOrgsOrg_577440,
                                      base: "/", url: url_GetOrgsOrg_577441,
                                      schemes: {Scheme.Https})
type
  Call_PatchOrgsOrg_577448 = ref object of OpenApiRestCall_576564
proc url_PatchOrgsOrg_577450(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchOrgsOrg_577449(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Edit an Organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_577451 = path.getOrDefault("org")
  valid_577451 = validateParameter(valid_577451, JString, required = true,
                                 default = nil)
  if valid_577451 != nil:
    section.add "org", valid_577451
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577452 = header.getOrDefault("Accept")
  valid_577452 = validateParameter(valid_577452, JString, required = false,
                                 default = nil)
  if valid_577452 != nil:
    section.add "Accept", valid_577452
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_577454: Call_PatchOrgsOrg_577448; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Edit an Organization.
  ## 
  let valid = call_577454.validator(path, query, header, formData, body)
  let scheme = call_577454.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577454.url(scheme.get, call_577454.host, call_577454.base,
                         call_577454.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577454, url, valid)

proc call*(call_577455: Call_PatchOrgsOrg_577448; org: string; body: JsonNode;
          Accept: string = ""): Recallable =
  ## patchOrgsOrg
  ## Edit an Organization.
  ##   org: string (required)
  ##      : Name of organisation.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577456 = newJObject()
  var header_577457 = newJObject()
  var body_577458 = newJObject()
  add(path_577456, "org", newJString(org))
  if body != nil:
    body_577458 = body
  add(header_577457, "Accept", newJString(Accept))
  result = call_577455.call(path_577456, nil, header_577457, nil, body_577458)

var patchOrgsOrg* = Call_PatchOrgsOrg_577448(name: "patchOrgsOrg",
    meth: HttpMethod.HttpPatch, host: "api.github.com", route: "/orgs/{org}",
    validator: validate_PatchOrgsOrg_577449, base: "/", url: url_PatchOrgsOrg_577450,
    schemes: {Scheme.Https})
type
  Call_GetOrgsOrgEvents_577459 = ref object of OpenApiRestCall_576564
proc url_GetOrgsOrgEvents_577461(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgEvents_577460(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## List public events for an organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_577462 = path.getOrDefault("org")
  valid_577462 = validateParameter(valid_577462, JString, required = true,
                                 default = nil)
  if valid_577462 != nil:
    section.add "org", valid_577462
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577463 = header.getOrDefault("Accept")
  valid_577463 = validateParameter(valid_577463, JString, required = false,
                                 default = nil)
  if valid_577463 != nil:
    section.add "Accept", valid_577463
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577464: Call_GetOrgsOrgEvents_577459; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List public events for an organization.
  ## 
  let valid = call_577464.validator(path, query, header, formData, body)
  let scheme = call_577464.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577464.url(scheme.get, call_577464.host, call_577464.base,
                         call_577464.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577464, url, valid)

proc call*(call_577465: Call_GetOrgsOrgEvents_577459; org: string;
          Accept: string = ""): Recallable =
  ## getOrgsOrgEvents
  ## List public events for an organization.
  ##   org: string (required)
  ##      : Name of organisation.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577466 = newJObject()
  var header_577467 = newJObject()
  add(path_577466, "org", newJString(org))
  add(header_577467, "Accept", newJString(Accept))
  result = call_577465.call(path_577466, nil, header_577467, nil, nil)

var getOrgsOrgEvents* = Call_GetOrgsOrgEvents_577459(name: "getOrgsOrgEvents",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/events",
    validator: validate_GetOrgsOrgEvents_577460, base: "/",
    url: url_GetOrgsOrgEvents_577461, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgIssues_577468 = ref object of OpenApiRestCall_576564
proc url_GetOrgsOrgIssues_577470(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/issues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgIssues_577469(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## List issues.
  ## List all issues for a given organization for the authenticated user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_577471 = path.getOrDefault("org")
  valid_577471 = validateParameter(valid_577471, JString, required = true,
                                 default = nil)
  if valid_577471 != nil:
    section.add "org", valid_577471
  result.add "path", section
  ## parameters in `query` object:
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   direction: JString (required)
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  ##   state: JString (required)
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   sort: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `labels` field"
  var valid_577472 = query.getOrDefault("labels")
  valid_577472 = validateParameter(valid_577472, JString, required = true,
                                 default = nil)
  if valid_577472 != nil:
    section.add "labels", valid_577472
  var valid_577473 = query.getOrDefault("direction")
  valid_577473 = validateParameter(valid_577473, JString, required = true,
                                 default = newJString("desc"))
  if valid_577473 != nil:
    section.add "direction", valid_577473
  var valid_577474 = query.getOrDefault("since")
  valid_577474 = validateParameter(valid_577474, JString, required = false,
                                 default = nil)
  if valid_577474 != nil:
    section.add "since", valid_577474
  var valid_577475 = query.getOrDefault("state")
  valid_577475 = validateParameter(valid_577475, JString, required = true,
                                 default = newJString("open"))
  if valid_577475 != nil:
    section.add "state", valid_577475
  var valid_577476 = query.getOrDefault("filter")
  valid_577476 = validateParameter(valid_577476, JString, required = true,
                                 default = newJString("all"))
  if valid_577476 != nil:
    section.add "filter", valid_577476
  var valid_577477 = query.getOrDefault("sort")
  valid_577477 = validateParameter(valid_577477, JString, required = true,
                                 default = newJString("created"))
  if valid_577477 != nil:
    section.add "sort", valid_577477
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577478 = header.getOrDefault("Accept")
  valid_577478 = validateParameter(valid_577478, JString, required = false,
                                 default = nil)
  if valid_577478 != nil:
    section.add "Accept", valid_577478
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577479: Call_GetOrgsOrgIssues_577468; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List issues.
  ## List all issues for a given organization for the authenticated user.
  ## 
  ## 
  let valid = call_577479.validator(path, query, header, formData, body)
  let scheme = call_577479.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577479.url(scheme.get, call_577479.host, call_577479.base,
                         call_577479.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577479, url, valid)

proc call*(call_577480: Call_GetOrgsOrgIssues_577468; labels: string; org: string;
          direction: string = "desc"; since: string = ""; state: string = "open";
          filter: string = "all"; Accept: string = ""; sort: string = "created"): Recallable =
  ## getOrgsOrgIssues
  ## List issues.
  ## List all issues for a given organization for the authenticated user.
  ## 
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   direction: string (required)
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  ##   state: string (required)
  ##   org: string (required)
  ##      : Name of organisation.
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string (required)
  var path_577481 = newJObject()
  var query_577482 = newJObject()
  var header_577483 = newJObject()
  add(query_577482, "labels", newJString(labels))
  add(query_577482, "direction", newJString(direction))
  add(query_577482, "since", newJString(since))
  add(query_577482, "state", newJString(state))
  add(path_577481, "org", newJString(org))
  add(query_577482, "filter", newJString(filter))
  add(header_577483, "Accept", newJString(Accept))
  add(query_577482, "sort", newJString(sort))
  result = call_577480.call(path_577481, query_577482, header_577483, nil, nil)

var getOrgsOrgIssues* = Call_GetOrgsOrgIssues_577468(name: "getOrgsOrgIssues",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/issues",
    validator: validate_GetOrgsOrgIssues_577469, base: "/",
    url: url_GetOrgsOrgIssues_577470, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgMembers_577484 = ref object of OpenApiRestCall_576564
proc url_GetOrgsOrgMembers_577486(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/members")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgMembers_577485(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Members list.
  ## List all users who are members of an organization. A member is a user tha
  ## belongs to at least 1 team in the organization. If the authenticated user
  ## is also an owner of this organization then both concealed and public members
  ## will be returned. If the requester is not an owner of the organization the
  ## query will be redirected to the public members list.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_577487 = path.getOrDefault("org")
  valid_577487 = validateParameter(valid_577487, JString, required = true,
                                 default = nil)
  if valid_577487 != nil:
    section.add "org", valid_577487
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577488 = header.getOrDefault("Accept")
  valid_577488 = validateParameter(valid_577488, JString, required = false,
                                 default = nil)
  if valid_577488 != nil:
    section.add "Accept", valid_577488
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577489: Call_GetOrgsOrgMembers_577484; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Members list.
  ## List all users who are members of an organization. A member is a user tha
  ## belongs to at least 1 team in the organization. If the authenticated user
  ## is also an owner of this organization then both concealed and public members
  ## will be returned. If the requester is not an owner of the organization the
  ## query will be redirected to the public members list.
  ## 
  ## 
  let valid = call_577489.validator(path, query, header, formData, body)
  let scheme = call_577489.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577489.url(scheme.get, call_577489.host, call_577489.base,
                         call_577489.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577489, url, valid)

proc call*(call_577490: Call_GetOrgsOrgMembers_577484; org: string;
          Accept: string = ""): Recallable =
  ## getOrgsOrgMembers
  ## Members list.
  ## List all users who are members of an organization. A member is a user tha
  ## belongs to at least 1 team in the organization. If the authenticated user
  ## is also an owner of this organization then both concealed and public members
  ## will be returned. If the requester is not an owner of the organization the
  ## query will be redirected to the public members list.
  ## 
  ##   org: string (required)
  ##      : Name of organisation.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577491 = newJObject()
  var header_577492 = newJObject()
  add(path_577491, "org", newJString(org))
  add(header_577492, "Accept", newJString(Accept))
  result = call_577490.call(path_577491, nil, header_577492, nil, nil)

var getOrgsOrgMembers* = Call_GetOrgsOrgMembers_577484(name: "getOrgsOrgMembers",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/members",
    validator: validate_GetOrgsOrgMembers_577485, base: "/",
    url: url_GetOrgsOrgMembers_577486, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgMembersUsername_577493 = ref object of OpenApiRestCall_576564
proc url_GetOrgsOrgMembersUsername_577495(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgMembersUsername_577494(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Check if a user is, publicly or privately, a member of the organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  ##   username: JString (required)
  ##           : Name of the user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_577496 = path.getOrDefault("org")
  valid_577496 = validateParameter(valid_577496, JString, required = true,
                                 default = nil)
  if valid_577496 != nil:
    section.add "org", valid_577496
  var valid_577497 = path.getOrDefault("username")
  valid_577497 = validateParameter(valid_577497, JString, required = true,
                                 default = nil)
  if valid_577497 != nil:
    section.add "username", valid_577497
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577498 = header.getOrDefault("Accept")
  valid_577498 = validateParameter(valid_577498, JString, required = false,
                                 default = nil)
  if valid_577498 != nil:
    section.add "Accept", valid_577498
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577499: Call_GetOrgsOrgMembersUsername_577493; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Check if a user is, publicly or privately, a member of the organization.
  ## 
  let valid = call_577499.validator(path, query, header, formData, body)
  let scheme = call_577499.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577499.url(scheme.get, call_577499.host, call_577499.base,
                         call_577499.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577499, url, valid)

proc call*(call_577500: Call_GetOrgsOrgMembersUsername_577493; org: string;
          username: string; Accept: string = ""): Recallable =
  ## getOrgsOrgMembersUsername
  ## Check if a user is, publicly or privately, a member of the organization.
  ##   org: string (required)
  ##      : Name of organisation.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577501 = newJObject()
  var header_577502 = newJObject()
  add(path_577501, "org", newJString(org))
  add(path_577501, "username", newJString(username))
  add(header_577502, "Accept", newJString(Accept))
  result = call_577500.call(path_577501, nil, header_577502, nil, nil)

var getOrgsOrgMembersUsername* = Call_GetOrgsOrgMembersUsername_577493(
    name: "getOrgsOrgMembersUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/orgs/{org}/members/{username}",
    validator: validate_GetOrgsOrgMembersUsername_577494, base: "/",
    url: url_GetOrgsOrgMembersUsername_577495, schemes: {Scheme.Https})
type
  Call_DeleteOrgsOrgMembersUsername_577503 = ref object of OpenApiRestCall_576564
proc url_DeleteOrgsOrgMembersUsername_577505(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteOrgsOrgMembersUsername_577504(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Remove a member.
  ## Removing a user from this list will remove them from all teams and they
  ## will no longer have any access to the organization's repositories.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  ##   username: JString (required)
  ##           : Name of the user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_577506 = path.getOrDefault("org")
  valid_577506 = validateParameter(valid_577506, JString, required = true,
                                 default = nil)
  if valid_577506 != nil:
    section.add "org", valid_577506
  var valid_577507 = path.getOrDefault("username")
  valid_577507 = validateParameter(valid_577507, JString, required = true,
                                 default = nil)
  if valid_577507 != nil:
    section.add "username", valid_577507
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577508 = header.getOrDefault("Accept")
  valid_577508 = validateParameter(valid_577508, JString, required = false,
                                 default = nil)
  if valid_577508 != nil:
    section.add "Accept", valid_577508
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577509: Call_DeleteOrgsOrgMembersUsername_577503; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Remove a member.
  ## Removing a user from this list will remove them from all teams and they
  ## will no longer have any access to the organization's repositories.
  ## 
  ## 
  let valid = call_577509.validator(path, query, header, formData, body)
  let scheme = call_577509.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577509.url(scheme.get, call_577509.host, call_577509.base,
                         call_577509.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577509, url, valid)

proc call*(call_577510: Call_DeleteOrgsOrgMembersUsername_577503; org: string;
          username: string; Accept: string = ""): Recallable =
  ## deleteOrgsOrgMembersUsername
  ## Remove a member.
  ## Removing a user from this list will remove them from all teams and they
  ## will no longer have any access to the organization's repositories.
  ## 
  ##   org: string (required)
  ##      : Name of organisation.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577511 = newJObject()
  var header_577512 = newJObject()
  add(path_577511, "org", newJString(org))
  add(path_577511, "username", newJString(username))
  add(header_577512, "Accept", newJString(Accept))
  result = call_577510.call(path_577511, nil, header_577512, nil, nil)

var deleteOrgsOrgMembersUsername* = Call_DeleteOrgsOrgMembersUsername_577503(
    name: "deleteOrgsOrgMembersUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/orgs/{org}/members/{username}",
    validator: validate_DeleteOrgsOrgMembersUsername_577504, base: "/",
    url: url_DeleteOrgsOrgMembersUsername_577505, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgPublicMembers_577513 = ref object of OpenApiRestCall_576564
proc url_GetOrgsOrgPublicMembers_577515(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/public_members")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgPublicMembers_577514(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Public members list.
  ## Members of an organization can choose to have their membership publicized
  ## or not.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_577516 = path.getOrDefault("org")
  valid_577516 = validateParameter(valid_577516, JString, required = true,
                                 default = nil)
  if valid_577516 != nil:
    section.add "org", valid_577516
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577517 = header.getOrDefault("Accept")
  valid_577517 = validateParameter(valid_577517, JString, required = false,
                                 default = nil)
  if valid_577517 != nil:
    section.add "Accept", valid_577517
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577518: Call_GetOrgsOrgPublicMembers_577513; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Public members list.
  ## Members of an organization can choose to have their membership publicized
  ## or not.
  ## 
  ## 
  let valid = call_577518.validator(path, query, header, formData, body)
  let scheme = call_577518.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577518.url(scheme.get, call_577518.host, call_577518.base,
                         call_577518.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577518, url, valid)

proc call*(call_577519: Call_GetOrgsOrgPublicMembers_577513; org: string;
          Accept: string = ""): Recallable =
  ## getOrgsOrgPublicMembers
  ## Public members list.
  ## Members of an organization can choose to have their membership publicized
  ## or not.
  ## 
  ##   org: string (required)
  ##      : Name of organisation.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577520 = newJObject()
  var header_577521 = newJObject()
  add(path_577520, "org", newJString(org))
  add(header_577521, "Accept", newJString(Accept))
  result = call_577519.call(path_577520, nil, header_577521, nil, nil)

var getOrgsOrgPublicMembers* = Call_GetOrgsOrgPublicMembers_577513(
    name: "getOrgsOrgPublicMembers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/orgs/{org}/public_members",
    validator: validate_GetOrgsOrgPublicMembers_577514, base: "/",
    url: url_GetOrgsOrgPublicMembers_577515, schemes: {Scheme.Https})
type
  Call_PutOrgsOrgPublicMembersUsername_577532 = ref object of OpenApiRestCall_576564
proc url_PutOrgsOrgPublicMembersUsername_577534(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/public_members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutOrgsOrgPublicMembersUsername_577533(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Publicize a user's membership.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  ##   username: JString (required)
  ##           : Name of the user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_577535 = path.getOrDefault("org")
  valid_577535 = validateParameter(valid_577535, JString, required = true,
                                 default = nil)
  if valid_577535 != nil:
    section.add "org", valid_577535
  var valid_577536 = path.getOrDefault("username")
  valid_577536 = validateParameter(valid_577536, JString, required = true,
                                 default = nil)
  if valid_577536 != nil:
    section.add "username", valid_577536
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577537 = header.getOrDefault("Accept")
  valid_577537 = validateParameter(valid_577537, JString, required = false,
                                 default = nil)
  if valid_577537 != nil:
    section.add "Accept", valid_577537
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577538: Call_PutOrgsOrgPublicMembersUsername_577532;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Publicize a user's membership.
  ## 
  let valid = call_577538.validator(path, query, header, formData, body)
  let scheme = call_577538.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577538.url(scheme.get, call_577538.host, call_577538.base,
                         call_577538.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577538, url, valid)

proc call*(call_577539: Call_PutOrgsOrgPublicMembersUsername_577532; org: string;
          username: string; Accept: string = ""): Recallable =
  ## putOrgsOrgPublicMembersUsername
  ## Publicize a user's membership.
  ##   org: string (required)
  ##      : Name of organisation.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577540 = newJObject()
  var header_577541 = newJObject()
  add(path_577540, "org", newJString(org))
  add(path_577540, "username", newJString(username))
  add(header_577541, "Accept", newJString(Accept))
  result = call_577539.call(path_577540, nil, header_577541, nil, nil)

var putOrgsOrgPublicMembersUsername* = Call_PutOrgsOrgPublicMembersUsername_577532(
    name: "putOrgsOrgPublicMembersUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/orgs/{org}/public_members/{username}",
    validator: validate_PutOrgsOrgPublicMembersUsername_577533, base: "/",
    url: url_PutOrgsOrgPublicMembersUsername_577534, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgPublicMembersUsername_577522 = ref object of OpenApiRestCall_576564
proc url_GetOrgsOrgPublicMembersUsername_577524(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/public_members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgPublicMembersUsername_577523(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Check public membership.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  ##   username: JString (required)
  ##           : Name of the user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_577525 = path.getOrDefault("org")
  valid_577525 = validateParameter(valid_577525, JString, required = true,
                                 default = nil)
  if valid_577525 != nil:
    section.add "org", valid_577525
  var valid_577526 = path.getOrDefault("username")
  valid_577526 = validateParameter(valid_577526, JString, required = true,
                                 default = nil)
  if valid_577526 != nil:
    section.add "username", valid_577526
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577527 = header.getOrDefault("Accept")
  valid_577527 = validateParameter(valid_577527, JString, required = false,
                                 default = nil)
  if valid_577527 != nil:
    section.add "Accept", valid_577527
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577528: Call_GetOrgsOrgPublicMembersUsername_577522;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Check public membership.
  ## 
  let valid = call_577528.validator(path, query, header, formData, body)
  let scheme = call_577528.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577528.url(scheme.get, call_577528.host, call_577528.base,
                         call_577528.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577528, url, valid)

proc call*(call_577529: Call_GetOrgsOrgPublicMembersUsername_577522; org: string;
          username: string; Accept: string = ""): Recallable =
  ## getOrgsOrgPublicMembersUsername
  ## Check public membership.
  ##   org: string (required)
  ##      : Name of organisation.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577530 = newJObject()
  var header_577531 = newJObject()
  add(path_577530, "org", newJString(org))
  add(path_577530, "username", newJString(username))
  add(header_577531, "Accept", newJString(Accept))
  result = call_577529.call(path_577530, nil, header_577531, nil, nil)

var getOrgsOrgPublicMembersUsername* = Call_GetOrgsOrgPublicMembersUsername_577522(
    name: "getOrgsOrgPublicMembersUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/orgs/{org}/public_members/{username}",
    validator: validate_GetOrgsOrgPublicMembersUsername_577523, base: "/",
    url: url_GetOrgsOrgPublicMembersUsername_577524, schemes: {Scheme.Https})
type
  Call_DeleteOrgsOrgPublicMembersUsername_577542 = ref object of OpenApiRestCall_576564
proc url_DeleteOrgsOrgPublicMembersUsername_577544(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/public_members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteOrgsOrgPublicMembersUsername_577543(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Conceal a user's membership.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  ##   username: JString (required)
  ##           : Name of the user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_577545 = path.getOrDefault("org")
  valid_577545 = validateParameter(valid_577545, JString, required = true,
                                 default = nil)
  if valid_577545 != nil:
    section.add "org", valid_577545
  var valid_577546 = path.getOrDefault("username")
  valid_577546 = validateParameter(valid_577546, JString, required = true,
                                 default = nil)
  if valid_577546 != nil:
    section.add "username", valid_577546
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577547 = header.getOrDefault("Accept")
  valid_577547 = validateParameter(valid_577547, JString, required = false,
                                 default = nil)
  if valid_577547 != nil:
    section.add "Accept", valid_577547
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577548: Call_DeleteOrgsOrgPublicMembersUsername_577542;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Conceal a user's membership.
  ## 
  let valid = call_577548.validator(path, query, header, formData, body)
  let scheme = call_577548.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577548.url(scheme.get, call_577548.host, call_577548.base,
                         call_577548.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577548, url, valid)

proc call*(call_577549: Call_DeleteOrgsOrgPublicMembersUsername_577542;
          org: string; username: string; Accept: string = ""): Recallable =
  ## deleteOrgsOrgPublicMembersUsername
  ## Conceal a user's membership.
  ##   org: string (required)
  ##      : Name of organisation.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577550 = newJObject()
  var header_577551 = newJObject()
  add(path_577550, "org", newJString(org))
  add(path_577550, "username", newJString(username))
  add(header_577551, "Accept", newJString(Accept))
  result = call_577549.call(path_577550, nil, header_577551, nil, nil)

var deleteOrgsOrgPublicMembersUsername* = Call_DeleteOrgsOrgPublicMembersUsername_577542(
    name: "deleteOrgsOrgPublicMembersUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/orgs/{org}/public_members/{username}",
    validator: validate_DeleteOrgsOrgPublicMembersUsername_577543, base: "/",
    url: url_DeleteOrgsOrgPublicMembersUsername_577544, schemes: {Scheme.Https})
type
  Call_PostOrgsOrgRepos_577563 = ref object of OpenApiRestCall_576564
proc url_PostOrgsOrgRepos_577565(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostOrgsOrgRepos_577564(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_577566 = path.getOrDefault("org")
  valid_577566 = validateParameter(valid_577566, JString, required = true,
                                 default = nil)
  if valid_577566 != nil:
    section.add "org", valid_577566
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577567 = header.getOrDefault("Accept")
  valid_577567 = validateParameter(valid_577567, JString, required = false,
                                 default = nil)
  if valid_577567 != nil:
    section.add "Accept", valid_577567
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_577569: Call_PostOrgsOrgRepos_577563; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  let valid = call_577569.validator(path, query, header, formData, body)
  let scheme = call_577569.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577569.url(scheme.get, call_577569.host, call_577569.base,
                         call_577569.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577569, url, valid)

proc call*(call_577570: Call_PostOrgsOrgRepos_577563; org: string; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postOrgsOrgRepos
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ##   org: string (required)
  ##      : Name of organisation.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577571 = newJObject()
  var header_577572 = newJObject()
  var body_577573 = newJObject()
  add(path_577571, "org", newJString(org))
  if body != nil:
    body_577573 = body
  add(header_577572, "Accept", newJString(Accept))
  result = call_577570.call(path_577571, nil, header_577572, nil, body_577573)

var postOrgsOrgRepos* = Call_PostOrgsOrgRepos_577563(name: "postOrgsOrgRepos",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/orgs/{org}/repos",
    validator: validate_PostOrgsOrgRepos_577564, base: "/",
    url: url_PostOrgsOrgRepos_577565, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgRepos_577552 = ref object of OpenApiRestCall_576564
proc url_GetOrgsOrgRepos_577554(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgRepos_577553(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## List repositories for the specified org.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_577555 = path.getOrDefault("org")
  valid_577555 = validateParameter(valid_577555, JString, required = true,
                                 default = nil)
  if valid_577555 != nil:
    section.add "org", valid_577555
  result.add "path", section
  ## parameters in `query` object:
  ##   type: JString
  section = newJObject()
  var valid_577556 = query.getOrDefault("type")
  valid_577556 = validateParameter(valid_577556, JString, required = false,
                                 default = newJString("all"))
  if valid_577556 != nil:
    section.add "type", valid_577556
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577557 = header.getOrDefault("Accept")
  valid_577557 = validateParameter(valid_577557, JString, required = false,
                                 default = nil)
  if valid_577557 != nil:
    section.add "Accept", valid_577557
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577558: Call_GetOrgsOrgRepos_577552; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List repositories for the specified org.
  ## 
  let valid = call_577558.validator(path, query, header, formData, body)
  let scheme = call_577558.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577558.url(scheme.get, call_577558.host, call_577558.base,
                         call_577558.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577558, url, valid)

proc call*(call_577559: Call_GetOrgsOrgRepos_577552; org: string;
          `type`: string = "all"; Accept: string = ""): Recallable =
  ## getOrgsOrgRepos
  ## List repositories for the specified org.
  ##   org: string (required)
  ##      : Name of organisation.
  ##   type: string
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577560 = newJObject()
  var query_577561 = newJObject()
  var header_577562 = newJObject()
  add(path_577560, "org", newJString(org))
  add(query_577561, "type", newJString(`type`))
  add(header_577562, "Accept", newJString(Accept))
  result = call_577559.call(path_577560, query_577561, header_577562, nil, nil)

var getOrgsOrgRepos* = Call_GetOrgsOrgRepos_577552(name: "getOrgsOrgRepos",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/repos",
    validator: validate_GetOrgsOrgRepos_577553, base: "/", url: url_GetOrgsOrgRepos_577554,
    schemes: {Scheme.Https})
type
  Call_PostOrgsOrgTeams_577583 = ref object of OpenApiRestCall_576564
proc url_PostOrgsOrgTeams_577585(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/teams")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostOrgsOrgTeams_577584(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Create team.
  ## In order to create a team, the authenticated user must be an owner of organization.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_577586 = path.getOrDefault("org")
  valid_577586 = validateParameter(valid_577586, JString, required = true,
                                 default = nil)
  if valid_577586 != nil:
    section.add "org", valid_577586
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577587 = header.getOrDefault("Accept")
  valid_577587 = validateParameter(valid_577587, JString, required = false,
                                 default = nil)
  if valid_577587 != nil:
    section.add "Accept", valid_577587
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_577589: Call_PostOrgsOrgTeams_577583; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create team.
  ## In order to create a team, the authenticated user must be an owner of organization.
  ## 
  ## 
  let valid = call_577589.validator(path, query, header, formData, body)
  let scheme = call_577589.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577589.url(scheme.get, call_577589.host, call_577589.base,
                         call_577589.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577589, url, valid)

proc call*(call_577590: Call_PostOrgsOrgTeams_577583; org: string; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postOrgsOrgTeams
  ## Create team.
  ## In order to create a team, the authenticated user must be an owner of organization.
  ## 
  ##   org: string (required)
  ##      : Name of organisation.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577591 = newJObject()
  var header_577592 = newJObject()
  var body_577593 = newJObject()
  add(path_577591, "org", newJString(org))
  if body != nil:
    body_577593 = body
  add(header_577592, "Accept", newJString(Accept))
  result = call_577590.call(path_577591, nil, header_577592, nil, body_577593)

var postOrgsOrgTeams* = Call_PostOrgsOrgTeams_577583(name: "postOrgsOrgTeams",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/orgs/{org}/teams",
    validator: validate_PostOrgsOrgTeams_577584, base: "/",
    url: url_PostOrgsOrgTeams_577585, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgTeams_577574 = ref object of OpenApiRestCall_576564
proc url_GetOrgsOrgTeams_577576(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/teams")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgTeams_577575(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## List teams.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_577577 = path.getOrDefault("org")
  valid_577577 = validateParameter(valid_577577, JString, required = true,
                                 default = nil)
  if valid_577577 != nil:
    section.add "org", valid_577577
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577578 = header.getOrDefault("Accept")
  valid_577578 = validateParameter(valid_577578, JString, required = false,
                                 default = nil)
  if valid_577578 != nil:
    section.add "Accept", valid_577578
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577579: Call_GetOrgsOrgTeams_577574; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List teams.
  ## 
  let valid = call_577579.validator(path, query, header, formData, body)
  let scheme = call_577579.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577579.url(scheme.get, call_577579.host, call_577579.base,
                         call_577579.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577579, url, valid)

proc call*(call_577580: Call_GetOrgsOrgTeams_577574; org: string; Accept: string = ""): Recallable =
  ## getOrgsOrgTeams
  ## List teams.
  ##   org: string (required)
  ##      : Name of organisation.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577581 = newJObject()
  var header_577582 = newJObject()
  add(path_577581, "org", newJString(org))
  add(header_577582, "Accept", newJString(Accept))
  result = call_577580.call(path_577581, nil, header_577582, nil, nil)

var getOrgsOrgTeams* = Call_GetOrgsOrgTeams_577574(name: "getOrgsOrgTeams",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/teams",
    validator: validate_GetOrgsOrgTeams_577575, base: "/", url: url_GetOrgsOrgTeams_577576,
    schemes: {Scheme.Https})
type
  Call_GetRateLimit_577594 = ref object of OpenApiRestCall_576564
proc url_GetRateLimit_577596(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRateLimit_577595(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Get your current rate limit status
  ## Note: Accessing this endpoint does not count against your rate limit.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577597 = header.getOrDefault("Accept")
  valid_577597 = validateParameter(valid_577597, JString, required = false,
                                 default = nil)
  if valid_577597 != nil:
    section.add "Accept", valid_577597
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577598: Call_GetRateLimit_577594; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get your current rate limit status
  ## Note: Accessing this endpoint does not count against your rate limit.
  ## 
  ## 
  let valid = call_577598.validator(path, query, header, formData, body)
  let scheme = call_577598.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577598.url(scheme.get, call_577598.host, call_577598.base,
                         call_577598.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577598, url, valid)

proc call*(call_577599: Call_GetRateLimit_577594; Accept: string = ""): Recallable =
  ## getRateLimit
  ## Get your current rate limit status
  ## Note: Accessing this endpoint does not count against your rate limit.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_577600 = newJObject()
  add(header_577600, "Accept", newJString(Accept))
  result = call_577599.call(nil, nil, header_577600, nil, nil)

var getRateLimit* = Call_GetRateLimit_577594(name: "getRateLimit",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/rate_limit",
    validator: validate_GetRateLimit_577595, base: "/", url: url_GetRateLimit_577596,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepo_577601 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepo_577603(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepo_577602(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Get repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577604 = path.getOrDefault("repo")
  valid_577604 = validateParameter(valid_577604, JString, required = true,
                                 default = nil)
  if valid_577604 != nil:
    section.add "repo", valid_577604
  var valid_577605 = path.getOrDefault("owner")
  valid_577605 = validateParameter(valid_577605, JString, required = true,
                                 default = nil)
  if valid_577605 != nil:
    section.add "owner", valid_577605
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577606 = header.getOrDefault("Accept")
  valid_577606 = validateParameter(valid_577606, JString, required = false,
                                 default = nil)
  if valid_577606 != nil:
    section.add "Accept", valid_577606
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577607: Call_GetReposOwnerRepo_577601; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get repository.
  ## 
  let valid = call_577607.validator(path, query, header, formData, body)
  let scheme = call_577607.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577607.url(scheme.get, call_577607.host, call_577607.base,
                         call_577607.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577607, url, valid)

proc call*(call_577608: Call_GetReposOwnerRepo_577601; repo: string; owner: string;
          Accept: string = ""): Recallable =
  ## getReposOwnerRepo
  ## Get repository.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577609 = newJObject()
  var header_577610 = newJObject()
  add(path_577609, "repo", newJString(repo))
  add(path_577609, "owner", newJString(owner))
  add(header_577610, "Accept", newJString(Accept))
  result = call_577608.call(path_577609, nil, header_577610, nil, nil)

var getReposOwnerRepo* = Call_GetReposOwnerRepo_577601(name: "getReposOwnerRepo",
    meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/repos/{owner}/{repo}", validator: validate_GetReposOwnerRepo_577602,
    base: "/", url: url_GetReposOwnerRepo_577603, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepo_577621 = ref object of OpenApiRestCall_576564
proc url_PatchReposOwnerRepo_577623(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepo_577622(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Edit repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577624 = path.getOrDefault("repo")
  valid_577624 = validateParameter(valid_577624, JString, required = true,
                                 default = nil)
  if valid_577624 != nil:
    section.add "repo", valid_577624
  var valid_577625 = path.getOrDefault("owner")
  valid_577625 = validateParameter(valid_577625, JString, required = true,
                                 default = nil)
  if valid_577625 != nil:
    section.add "owner", valid_577625
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577626 = header.getOrDefault("Accept")
  valid_577626 = validateParameter(valid_577626, JString, required = false,
                                 default = nil)
  if valid_577626 != nil:
    section.add "Accept", valid_577626
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_577628: Call_PatchReposOwnerRepo_577621; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Edit repository.
  ## 
  let valid = call_577628.validator(path, query, header, formData, body)
  let scheme = call_577628.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577628.url(scheme.get, call_577628.host, call_577628.base,
                         call_577628.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577628, url, valid)

proc call*(call_577629: Call_PatchReposOwnerRepo_577621; repo: string; owner: string;
          body: JsonNode; Accept: string = ""): Recallable =
  ## patchReposOwnerRepo
  ## Edit repository.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577630 = newJObject()
  var header_577631 = newJObject()
  var body_577632 = newJObject()
  add(path_577630, "repo", newJString(repo))
  add(path_577630, "owner", newJString(owner))
  if body != nil:
    body_577632 = body
  add(header_577631, "Accept", newJString(Accept))
  result = call_577629.call(path_577630, nil, header_577631, nil, body_577632)

var patchReposOwnerRepo* = Call_PatchReposOwnerRepo_577621(
    name: "patchReposOwnerRepo", meth: HttpMethod.HttpPatch, host: "api.github.com",
    route: "/repos/{owner}/{repo}", validator: validate_PatchReposOwnerRepo_577622,
    base: "/", url: url_PatchReposOwnerRepo_577623, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepo_577611 = ref object of OpenApiRestCall_576564
proc url_DeleteReposOwnerRepo_577613(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepo_577612(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a Repository.
  ## Deleting a repository requires admin access. If OAuth is used, the delete_repo
  ## scope is required.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577614 = path.getOrDefault("repo")
  valid_577614 = validateParameter(valid_577614, JString, required = true,
                                 default = nil)
  if valid_577614 != nil:
    section.add "repo", valid_577614
  var valid_577615 = path.getOrDefault("owner")
  valid_577615 = validateParameter(valid_577615, JString, required = true,
                                 default = nil)
  if valid_577615 != nil:
    section.add "owner", valid_577615
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577616 = header.getOrDefault("Accept")
  valid_577616 = validateParameter(valid_577616, JString, required = false,
                                 default = nil)
  if valid_577616 != nil:
    section.add "Accept", valid_577616
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577617: Call_DeleteReposOwnerRepo_577611; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete a Repository.
  ## Deleting a repository requires admin access. If OAuth is used, the delete_repo
  ## scope is required.
  ## 
  ## 
  let valid = call_577617.validator(path, query, header, formData, body)
  let scheme = call_577617.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577617.url(scheme.get, call_577617.host, call_577617.base,
                         call_577617.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577617, url, valid)

proc call*(call_577618: Call_DeleteReposOwnerRepo_577611; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepo
  ## Delete a Repository.
  ## Deleting a repository requires admin access. If OAuth is used, the delete_repo
  ## scope is required.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577619 = newJObject()
  var header_577620 = newJObject()
  add(path_577619, "repo", newJString(repo))
  add(path_577619, "owner", newJString(owner))
  add(header_577620, "Accept", newJString(Accept))
  result = call_577618.call(path_577619, nil, header_577620, nil, nil)

var deleteReposOwnerRepo* = Call_DeleteReposOwnerRepo_577611(
    name: "deleteReposOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}",
    validator: validate_DeleteReposOwnerRepo_577612, base: "/",
    url: url_DeleteReposOwnerRepo_577613, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoAssignees_577633 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoAssignees_577635(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/assignees")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoAssignees_577634(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List assignees.
  ## This call lists all the available assignees (owner + collaborators) to which
  ## issues may be assigned.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577636 = path.getOrDefault("repo")
  valid_577636 = validateParameter(valid_577636, JString, required = true,
                                 default = nil)
  if valid_577636 != nil:
    section.add "repo", valid_577636
  var valid_577637 = path.getOrDefault("owner")
  valid_577637 = validateParameter(valid_577637, JString, required = true,
                                 default = nil)
  if valid_577637 != nil:
    section.add "owner", valid_577637
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577638 = header.getOrDefault("Accept")
  valid_577638 = validateParameter(valid_577638, JString, required = false,
                                 default = nil)
  if valid_577638 != nil:
    section.add "Accept", valid_577638
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577639: Call_GetReposOwnerRepoAssignees_577633; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List assignees.
  ## This call lists all the available assignees (owner + collaborators) to which
  ## issues may be assigned.
  ## 
  ## 
  let valid = call_577639.validator(path, query, header, formData, body)
  let scheme = call_577639.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577639.url(scheme.get, call_577639.host, call_577639.base,
                         call_577639.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577639, url, valid)

proc call*(call_577640: Call_GetReposOwnerRepoAssignees_577633; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoAssignees
  ## List assignees.
  ## This call lists all the available assignees (owner + collaborators) to which
  ## issues may be assigned.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577641 = newJObject()
  var header_577642 = newJObject()
  add(path_577641, "repo", newJString(repo))
  add(path_577641, "owner", newJString(owner))
  add(header_577642, "Accept", newJString(Accept))
  result = call_577640.call(path_577641, nil, header_577642, nil, nil)

var getReposOwnerRepoAssignees* = Call_GetReposOwnerRepoAssignees_577633(
    name: "getReposOwnerRepoAssignees", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/assignees",
    validator: validate_GetReposOwnerRepoAssignees_577634, base: "/",
    url: url_GetReposOwnerRepoAssignees_577635, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoAssigneesAssignee_577643 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoAssigneesAssignee_577645(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "assignee" in path, "`assignee` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/assignees/"),
               (kind: VariableSegment, value: "assignee")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoAssigneesAssignee_577644(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Check assignee.
  ## You may also check to see if a particular user is an assignee for a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   assignee: JString (required)
  ##           : Login of the assignee.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577646 = path.getOrDefault("repo")
  valid_577646 = validateParameter(valid_577646, JString, required = true,
                                 default = nil)
  if valid_577646 != nil:
    section.add "repo", valid_577646
  var valid_577647 = path.getOrDefault("owner")
  valid_577647 = validateParameter(valid_577647, JString, required = true,
                                 default = nil)
  if valid_577647 != nil:
    section.add "owner", valid_577647
  var valid_577648 = path.getOrDefault("assignee")
  valid_577648 = validateParameter(valid_577648, JString, required = true,
                                 default = nil)
  if valid_577648 != nil:
    section.add "assignee", valid_577648
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577649 = header.getOrDefault("Accept")
  valid_577649 = validateParameter(valid_577649, JString, required = false,
                                 default = nil)
  if valid_577649 != nil:
    section.add "Accept", valid_577649
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577650: Call_GetReposOwnerRepoAssigneesAssignee_577643;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Check assignee.
  ## You may also check to see if a particular user is an assignee for a repository.
  ## 
  ## 
  let valid = call_577650.validator(path, query, header, formData, body)
  let scheme = call_577650.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577650.url(scheme.get, call_577650.host, call_577650.base,
                         call_577650.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577650, url, valid)

proc call*(call_577651: Call_GetReposOwnerRepoAssigneesAssignee_577643;
          repo: string; owner: string; assignee: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoAssigneesAssignee
  ## Check assignee.
  ## You may also check to see if a particular user is an assignee for a repository.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   assignee: string (required)
  ##           : Login of the assignee.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577652 = newJObject()
  var header_577653 = newJObject()
  add(path_577652, "repo", newJString(repo))
  add(path_577652, "owner", newJString(owner))
  add(path_577652, "assignee", newJString(assignee))
  add(header_577653, "Accept", newJString(Accept))
  result = call_577651.call(path_577652, nil, header_577653, nil, nil)

var getReposOwnerRepoAssigneesAssignee* = Call_GetReposOwnerRepoAssigneesAssignee_577643(
    name: "getReposOwnerRepoAssigneesAssignee", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/assignees/{assignee}",
    validator: validate_GetReposOwnerRepoAssigneesAssignee_577644, base: "/",
    url: url_GetReposOwnerRepoAssigneesAssignee_577645, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoBranches_577654 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoBranches_577656(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/branches")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoBranches_577655(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get list of branches
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577657 = path.getOrDefault("repo")
  valid_577657 = validateParameter(valid_577657, JString, required = true,
                                 default = nil)
  if valid_577657 != nil:
    section.add "repo", valid_577657
  var valid_577658 = path.getOrDefault("owner")
  valid_577658 = validateParameter(valid_577658, JString, required = true,
                                 default = nil)
  if valid_577658 != nil:
    section.add "owner", valid_577658
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577659 = header.getOrDefault("Accept")
  valid_577659 = validateParameter(valid_577659, JString, required = false,
                                 default = nil)
  if valid_577659 != nil:
    section.add "Accept", valid_577659
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577660: Call_GetReposOwnerRepoBranches_577654; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get list of branches
  ## 
  let valid = call_577660.validator(path, query, header, formData, body)
  let scheme = call_577660.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577660.url(scheme.get, call_577660.host, call_577660.base,
                         call_577660.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577660, url, valid)

proc call*(call_577661: Call_GetReposOwnerRepoBranches_577654; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoBranches
  ## Get list of branches
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577662 = newJObject()
  var header_577663 = newJObject()
  add(path_577662, "repo", newJString(repo))
  add(path_577662, "owner", newJString(owner))
  add(header_577663, "Accept", newJString(Accept))
  result = call_577661.call(path_577662, nil, header_577663, nil, nil)

var getReposOwnerRepoBranches* = Call_GetReposOwnerRepoBranches_577654(
    name: "getReposOwnerRepoBranches", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/branches",
    validator: validate_GetReposOwnerRepoBranches_577655, base: "/",
    url: url_GetReposOwnerRepoBranches_577656, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoBranchesBranch_577664 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoBranchesBranch_577666(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "branch" in path, "`branch` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/branches/"),
               (kind: VariableSegment, value: "branch")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoBranchesBranch_577665(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get Branch
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   branch: JString (required)
  ##         : Name of the branch.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577667 = path.getOrDefault("repo")
  valid_577667 = validateParameter(valid_577667, JString, required = true,
                                 default = nil)
  if valid_577667 != nil:
    section.add "repo", valid_577667
  var valid_577668 = path.getOrDefault("owner")
  valid_577668 = validateParameter(valid_577668, JString, required = true,
                                 default = nil)
  if valid_577668 != nil:
    section.add "owner", valid_577668
  var valid_577669 = path.getOrDefault("branch")
  valid_577669 = validateParameter(valid_577669, JString, required = true,
                                 default = nil)
  if valid_577669 != nil:
    section.add "branch", valid_577669
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577670 = header.getOrDefault("Accept")
  valid_577670 = validateParameter(valid_577670, JString, required = false,
                                 default = nil)
  if valid_577670 != nil:
    section.add "Accept", valid_577670
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577671: Call_GetReposOwnerRepoBranchesBranch_577664;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get Branch
  ## 
  let valid = call_577671.validator(path, query, header, formData, body)
  let scheme = call_577671.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577671.url(scheme.get, call_577671.host, call_577671.base,
                         call_577671.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577671, url, valid)

proc call*(call_577672: Call_GetReposOwnerRepoBranchesBranch_577664; repo: string;
          owner: string; branch: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoBranchesBranch
  ## Get Branch
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   branch: string (required)
  ##         : Name of the branch.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577673 = newJObject()
  var header_577674 = newJObject()
  add(path_577673, "repo", newJString(repo))
  add(path_577673, "owner", newJString(owner))
  add(path_577673, "branch", newJString(branch))
  add(header_577674, "Accept", newJString(Accept))
  result = call_577672.call(path_577673, nil, header_577674, nil, nil)

var getReposOwnerRepoBranchesBranch* = Call_GetReposOwnerRepoBranchesBranch_577664(
    name: "getReposOwnerRepoBranchesBranch", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/branches/{branch}",
    validator: validate_GetReposOwnerRepoBranchesBranch_577665, base: "/",
    url: url_GetReposOwnerRepoBranchesBranch_577666, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCollaborators_577675 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoCollaborators_577677(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/collaborators")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCollaborators_577676(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List.
  ## When authenticating as an organization owner of an organization-owned
  ## repository, all organization owners are included in the list of
  ## collaborators. Otherwise, only users with access to the repository are
  ## returned in the collaborators list.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577678 = path.getOrDefault("repo")
  valid_577678 = validateParameter(valid_577678, JString, required = true,
                                 default = nil)
  if valid_577678 != nil:
    section.add "repo", valid_577678
  var valid_577679 = path.getOrDefault("owner")
  valid_577679 = validateParameter(valid_577679, JString, required = true,
                                 default = nil)
  if valid_577679 != nil:
    section.add "owner", valid_577679
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577680 = header.getOrDefault("Accept")
  valid_577680 = validateParameter(valid_577680, JString, required = false,
                                 default = nil)
  if valid_577680 != nil:
    section.add "Accept", valid_577680
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577681: Call_GetReposOwnerRepoCollaborators_577675; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List.
  ## When authenticating as an organization owner of an organization-owned
  ## repository, all organization owners are included in the list of
  ## collaborators. Otherwise, only users with access to the repository are
  ## returned in the collaborators list.
  ## 
  ## 
  let valid = call_577681.validator(path, query, header, formData, body)
  let scheme = call_577681.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577681.url(scheme.get, call_577681.host, call_577681.base,
                         call_577681.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577681, url, valid)

proc call*(call_577682: Call_GetReposOwnerRepoCollaborators_577675; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCollaborators
  ## List.
  ## When authenticating as an organization owner of an organization-owned
  ## repository, all organization owners are included in the list of
  ## collaborators. Otherwise, only users with access to the repository are
  ## returned in the collaborators list.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577683 = newJObject()
  var header_577684 = newJObject()
  add(path_577683, "repo", newJString(repo))
  add(path_577683, "owner", newJString(owner))
  add(header_577684, "Accept", newJString(Accept))
  result = call_577682.call(path_577683, nil, header_577684, nil, nil)

var getReposOwnerRepoCollaborators* = Call_GetReposOwnerRepoCollaborators_577675(
    name: "getReposOwnerRepoCollaborators", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators",
    validator: validate_GetReposOwnerRepoCollaborators_577676, base: "/",
    url: url_GetReposOwnerRepoCollaborators_577677, schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoCollaboratorsUser_577696 = ref object of OpenApiRestCall_576564
proc url_PutReposOwnerRepoCollaboratorsUser_577698(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "user" in path, "`user` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/collaborators/"),
               (kind: VariableSegment, value: "user")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoCollaboratorsUser_577697(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Add collaborator.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   user: JString (required)
  ##       : Login of the user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577699 = path.getOrDefault("repo")
  valid_577699 = validateParameter(valid_577699, JString, required = true,
                                 default = nil)
  if valid_577699 != nil:
    section.add "repo", valid_577699
  var valid_577700 = path.getOrDefault("owner")
  valid_577700 = validateParameter(valid_577700, JString, required = true,
                                 default = nil)
  if valid_577700 != nil:
    section.add "owner", valid_577700
  var valid_577701 = path.getOrDefault("user")
  valid_577701 = validateParameter(valid_577701, JString, required = true,
                                 default = nil)
  if valid_577701 != nil:
    section.add "user", valid_577701
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577702 = header.getOrDefault("Accept")
  valid_577702 = validateParameter(valid_577702, JString, required = false,
                                 default = nil)
  if valid_577702 != nil:
    section.add "Accept", valid_577702
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577703: Call_PutReposOwnerRepoCollaboratorsUser_577696;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Add collaborator.
  ## 
  let valid = call_577703.validator(path, query, header, formData, body)
  let scheme = call_577703.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577703.url(scheme.get, call_577703.host, call_577703.base,
                         call_577703.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577703, url, valid)

proc call*(call_577704: Call_PutReposOwnerRepoCollaboratorsUser_577696;
          repo: string; owner: string; user: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoCollaboratorsUser
  ## Add collaborator.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   user: string (required)
  ##       : Login of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577705 = newJObject()
  var header_577706 = newJObject()
  add(path_577705, "repo", newJString(repo))
  add(path_577705, "owner", newJString(owner))
  add(path_577705, "user", newJString(user))
  add(header_577706, "Accept", newJString(Accept))
  result = call_577704.call(path_577705, nil, header_577706, nil, nil)

var putReposOwnerRepoCollaboratorsUser* = Call_PutReposOwnerRepoCollaboratorsUser_577696(
    name: "putReposOwnerRepoCollaboratorsUser", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators/{user}",
    validator: validate_PutReposOwnerRepoCollaboratorsUser_577697, base: "/",
    url: url_PutReposOwnerRepoCollaboratorsUser_577698, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCollaboratorsUser_577685 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoCollaboratorsUser_577687(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "user" in path, "`user` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/collaborators/"),
               (kind: VariableSegment, value: "user")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCollaboratorsUser_577686(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Check if user is a collaborator
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   user: JString (required)
  ##       : Login of the user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577688 = path.getOrDefault("repo")
  valid_577688 = validateParameter(valid_577688, JString, required = true,
                                 default = nil)
  if valid_577688 != nil:
    section.add "repo", valid_577688
  var valid_577689 = path.getOrDefault("owner")
  valid_577689 = validateParameter(valid_577689, JString, required = true,
                                 default = nil)
  if valid_577689 != nil:
    section.add "owner", valid_577689
  var valid_577690 = path.getOrDefault("user")
  valid_577690 = validateParameter(valid_577690, JString, required = true,
                                 default = nil)
  if valid_577690 != nil:
    section.add "user", valid_577690
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577691 = header.getOrDefault("Accept")
  valid_577691 = validateParameter(valid_577691, JString, required = false,
                                 default = nil)
  if valid_577691 != nil:
    section.add "Accept", valid_577691
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577692: Call_GetReposOwnerRepoCollaboratorsUser_577685;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Check if user is a collaborator
  ## 
  let valid = call_577692.validator(path, query, header, formData, body)
  let scheme = call_577692.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577692.url(scheme.get, call_577692.host, call_577692.base,
                         call_577692.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577692, url, valid)

proc call*(call_577693: Call_GetReposOwnerRepoCollaboratorsUser_577685;
          repo: string; owner: string; user: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCollaboratorsUser
  ## Check if user is a collaborator
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   user: string (required)
  ##       : Login of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577694 = newJObject()
  var header_577695 = newJObject()
  add(path_577694, "repo", newJString(repo))
  add(path_577694, "owner", newJString(owner))
  add(path_577694, "user", newJString(user))
  add(header_577695, "Accept", newJString(Accept))
  result = call_577693.call(path_577694, nil, header_577695, nil, nil)

var getReposOwnerRepoCollaboratorsUser* = Call_GetReposOwnerRepoCollaboratorsUser_577685(
    name: "getReposOwnerRepoCollaboratorsUser", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators/{user}",
    validator: validate_GetReposOwnerRepoCollaboratorsUser_577686, base: "/",
    url: url_GetReposOwnerRepoCollaboratorsUser_577687, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoCollaboratorsUser_577707 = ref object of OpenApiRestCall_576564
proc url_DeleteReposOwnerRepoCollaboratorsUser_577709(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "user" in path, "`user` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/collaborators/"),
               (kind: VariableSegment, value: "user")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoCollaboratorsUser_577708(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Remove collaborator.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   user: JString (required)
  ##       : Login of the user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577710 = path.getOrDefault("repo")
  valid_577710 = validateParameter(valid_577710, JString, required = true,
                                 default = nil)
  if valid_577710 != nil:
    section.add "repo", valid_577710
  var valid_577711 = path.getOrDefault("owner")
  valid_577711 = validateParameter(valid_577711, JString, required = true,
                                 default = nil)
  if valid_577711 != nil:
    section.add "owner", valid_577711
  var valid_577712 = path.getOrDefault("user")
  valid_577712 = validateParameter(valid_577712, JString, required = true,
                                 default = nil)
  if valid_577712 != nil:
    section.add "user", valid_577712
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577713 = header.getOrDefault("Accept")
  valid_577713 = validateParameter(valid_577713, JString, required = false,
                                 default = nil)
  if valid_577713 != nil:
    section.add "Accept", valid_577713
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577714: Call_DeleteReposOwnerRepoCollaboratorsUser_577707;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Remove collaborator.
  ## 
  let valid = call_577714.validator(path, query, header, formData, body)
  let scheme = call_577714.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577714.url(scheme.get, call_577714.host, call_577714.base,
                         call_577714.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577714, url, valid)

proc call*(call_577715: Call_DeleteReposOwnerRepoCollaboratorsUser_577707;
          repo: string; owner: string; user: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoCollaboratorsUser
  ## Remove collaborator.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   user: string (required)
  ##       : Login of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577716 = newJObject()
  var header_577717 = newJObject()
  add(path_577716, "repo", newJString(repo))
  add(path_577716, "owner", newJString(owner))
  add(path_577716, "user", newJString(user))
  add(header_577717, "Accept", newJString(Accept))
  result = call_577715.call(path_577716, nil, header_577717, nil, nil)

var deleteReposOwnerRepoCollaboratorsUser* = Call_DeleteReposOwnerRepoCollaboratorsUser_577707(
    name: "deleteReposOwnerRepoCollaboratorsUser", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators/{user}",
    validator: validate_DeleteReposOwnerRepoCollaboratorsUser_577708, base: "/",
    url: url_DeleteReposOwnerRepoCollaboratorsUser_577709, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoComments_577718 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoComments_577720(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoComments_577719(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List commit comments for a repository.
  ## Comments are ordered by ascending ID.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577721 = path.getOrDefault("repo")
  valid_577721 = validateParameter(valid_577721, JString, required = true,
                                 default = nil)
  if valid_577721 != nil:
    section.add "repo", valid_577721
  var valid_577722 = path.getOrDefault("owner")
  valid_577722 = validateParameter(valid_577722, JString, required = true,
                                 default = nil)
  if valid_577722 != nil:
    section.add "owner", valid_577722
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577723 = header.getOrDefault("Accept")
  valid_577723 = validateParameter(valid_577723, JString, required = false,
                                 default = nil)
  if valid_577723 != nil:
    section.add "Accept", valid_577723
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577724: Call_GetReposOwnerRepoComments_577718; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List commit comments for a repository.
  ## Comments are ordered by ascending ID.
  ## 
  ## 
  let valid = call_577724.validator(path, query, header, formData, body)
  let scheme = call_577724.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577724.url(scheme.get, call_577724.host, call_577724.base,
                         call_577724.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577724, url, valid)

proc call*(call_577725: Call_GetReposOwnerRepoComments_577718; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoComments
  ## List commit comments for a repository.
  ## Comments are ordered by ascending ID.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577726 = newJObject()
  var header_577727 = newJObject()
  add(path_577726, "repo", newJString(repo))
  add(path_577726, "owner", newJString(owner))
  add(header_577727, "Accept", newJString(Accept))
  result = call_577725.call(path_577726, nil, header_577727, nil, nil)

var getReposOwnerRepoComments* = Call_GetReposOwnerRepoComments_577718(
    name: "getReposOwnerRepoComments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments",
    validator: validate_GetReposOwnerRepoComments_577719, base: "/",
    url: url_GetReposOwnerRepoComments_577720, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommentsCommentId_577728 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoCommentsCommentId_577730(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommentsCommentId_577729(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single commit comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577731 = path.getOrDefault("repo")
  valid_577731 = validateParameter(valid_577731, JString, required = true,
                                 default = nil)
  if valid_577731 != nil:
    section.add "repo", valid_577731
  var valid_577732 = path.getOrDefault("commentId")
  valid_577732 = validateParameter(valid_577732, JInt, required = true, default = nil)
  if valid_577732 != nil:
    section.add "commentId", valid_577732
  var valid_577733 = path.getOrDefault("owner")
  valid_577733 = validateParameter(valid_577733, JString, required = true,
                                 default = nil)
  if valid_577733 != nil:
    section.add "owner", valid_577733
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577734 = header.getOrDefault("Accept")
  valid_577734 = validateParameter(valid_577734, JString, required = false,
                                 default = nil)
  if valid_577734 != nil:
    section.add "Accept", valid_577734
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577735: Call_GetReposOwnerRepoCommentsCommentId_577728;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single commit comment.
  ## 
  let valid = call_577735.validator(path, query, header, formData, body)
  let scheme = call_577735.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577735.url(scheme.get, call_577735.host, call_577735.base,
                         call_577735.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577735, url, valid)

proc call*(call_577736: Call_GetReposOwnerRepoCommentsCommentId_577728;
          repo: string; commentId: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommentsCommentId
  ## Get a single commit comment.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577737 = newJObject()
  var header_577738 = newJObject()
  add(path_577737, "repo", newJString(repo))
  add(path_577737, "commentId", newJInt(commentId))
  add(path_577737, "owner", newJString(owner))
  add(header_577738, "Accept", newJString(Accept))
  result = call_577736.call(path_577737, nil, header_577738, nil, nil)

var getReposOwnerRepoCommentsCommentId* = Call_GetReposOwnerRepoCommentsCommentId_577728(
    name: "getReposOwnerRepoCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments/{commentId}",
    validator: validate_GetReposOwnerRepoCommentsCommentId_577729, base: "/",
    url: url_GetReposOwnerRepoCommentsCommentId_577730, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoCommentsCommentId_577750 = ref object of OpenApiRestCall_576564
proc url_PatchReposOwnerRepoCommentsCommentId_577752(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoCommentsCommentId_577751(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Update a commit comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577753 = path.getOrDefault("repo")
  valid_577753 = validateParameter(valid_577753, JString, required = true,
                                 default = nil)
  if valid_577753 != nil:
    section.add "repo", valid_577753
  var valid_577754 = path.getOrDefault("commentId")
  valid_577754 = validateParameter(valid_577754, JInt, required = true, default = nil)
  if valid_577754 != nil:
    section.add "commentId", valid_577754
  var valid_577755 = path.getOrDefault("owner")
  valid_577755 = validateParameter(valid_577755, JString, required = true,
                                 default = nil)
  if valid_577755 != nil:
    section.add "owner", valid_577755
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577756 = header.getOrDefault("Accept")
  valid_577756 = validateParameter(valid_577756, JString, required = false,
                                 default = nil)
  if valid_577756 != nil:
    section.add "Accept", valid_577756
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_577758: Call_PatchReposOwnerRepoCommentsCommentId_577750;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Update a commit comment.
  ## 
  let valid = call_577758.validator(path, query, header, formData, body)
  let scheme = call_577758.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577758.url(scheme.get, call_577758.host, call_577758.base,
                         call_577758.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577758, url, valid)

proc call*(call_577759: Call_PatchReposOwnerRepoCommentsCommentId_577750;
          repo: string; commentId: int; owner: string; body: JsonNode;
          Accept: string = ""): Recallable =
  ## patchReposOwnerRepoCommentsCommentId
  ## Update a commit comment.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577760 = newJObject()
  var header_577761 = newJObject()
  var body_577762 = newJObject()
  add(path_577760, "repo", newJString(repo))
  add(path_577760, "commentId", newJInt(commentId))
  add(path_577760, "owner", newJString(owner))
  if body != nil:
    body_577762 = body
  add(header_577761, "Accept", newJString(Accept))
  result = call_577759.call(path_577760, nil, header_577761, nil, body_577762)

var patchReposOwnerRepoCommentsCommentId* = Call_PatchReposOwnerRepoCommentsCommentId_577750(
    name: "patchReposOwnerRepoCommentsCommentId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments/{commentId}",
    validator: validate_PatchReposOwnerRepoCommentsCommentId_577751, base: "/",
    url: url_PatchReposOwnerRepoCommentsCommentId_577752, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoCommentsCommentId_577739 = ref object of OpenApiRestCall_576564
proc url_DeleteReposOwnerRepoCommentsCommentId_577741(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoCommentsCommentId_577740(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a commit comment
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577742 = path.getOrDefault("repo")
  valid_577742 = validateParameter(valid_577742, JString, required = true,
                                 default = nil)
  if valid_577742 != nil:
    section.add "repo", valid_577742
  var valid_577743 = path.getOrDefault("commentId")
  valid_577743 = validateParameter(valid_577743, JInt, required = true, default = nil)
  if valid_577743 != nil:
    section.add "commentId", valid_577743
  var valid_577744 = path.getOrDefault("owner")
  valid_577744 = validateParameter(valid_577744, JString, required = true,
                                 default = nil)
  if valid_577744 != nil:
    section.add "owner", valid_577744
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577745 = header.getOrDefault("Accept")
  valid_577745 = validateParameter(valid_577745, JString, required = false,
                                 default = nil)
  if valid_577745 != nil:
    section.add "Accept", valid_577745
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577746: Call_DeleteReposOwnerRepoCommentsCommentId_577739;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a commit comment
  ## 
  let valid = call_577746.validator(path, query, header, formData, body)
  let scheme = call_577746.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577746.url(scheme.get, call_577746.host, call_577746.base,
                         call_577746.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577746, url, valid)

proc call*(call_577747: Call_DeleteReposOwnerRepoCommentsCommentId_577739;
          repo: string; commentId: int; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoCommentsCommentId
  ## Delete a commit comment
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577748 = newJObject()
  var header_577749 = newJObject()
  add(path_577748, "repo", newJString(repo))
  add(path_577748, "commentId", newJInt(commentId))
  add(path_577748, "owner", newJString(owner))
  add(header_577749, "Accept", newJString(Accept))
  result = call_577747.call(path_577748, nil, header_577749, nil, nil)

var deleteReposOwnerRepoCommentsCommentId* = Call_DeleteReposOwnerRepoCommentsCommentId_577739(
    name: "deleteReposOwnerRepoCommentsCommentId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments/{commentId}",
    validator: validate_DeleteReposOwnerRepoCommentsCommentId_577740, base: "/",
    url: url_DeleteReposOwnerRepoCommentsCommentId_577741, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommits_577763 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoCommits_577765(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommits_577764(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List commits on a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577766 = path.getOrDefault("repo")
  valid_577766 = validateParameter(valid_577766, JString, required = true,
                                 default = nil)
  if valid_577766 != nil:
    section.add "repo", valid_577766
  var valid_577767 = path.getOrDefault("owner")
  valid_577767 = validateParameter(valid_577767, JString, required = true,
                                 default = nil)
  if valid_577767 != nil:
    section.add "owner", valid_577767
  result.add "path", section
  ## parameters in `query` object:
  ##   author: JString
  ##         : GitHub login, name, or email by which to filter by commit author.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   sha: JString
  ##      : Sha or branch to start listing commits from.
  ##   path: JString
  ##       : Only commits containing this file path will be returned.
  ##   until: JString
  ##        : ISO 8601 Date - Only commits before this date will be returned.
  section = newJObject()
  var valid_577768 = query.getOrDefault("author")
  valid_577768 = validateParameter(valid_577768, JString, required = false,
                                 default = nil)
  if valid_577768 != nil:
    section.add "author", valid_577768
  var valid_577769 = query.getOrDefault("since")
  valid_577769 = validateParameter(valid_577769, JString, required = false,
                                 default = nil)
  if valid_577769 != nil:
    section.add "since", valid_577769
  var valid_577770 = query.getOrDefault("sha")
  valid_577770 = validateParameter(valid_577770, JString, required = false,
                                 default = nil)
  if valid_577770 != nil:
    section.add "sha", valid_577770
  var valid_577771 = query.getOrDefault("path")
  valid_577771 = validateParameter(valid_577771, JString, required = false,
                                 default = nil)
  if valid_577771 != nil:
    section.add "path", valid_577771
  var valid_577772 = query.getOrDefault("until")
  valid_577772 = validateParameter(valid_577772, JString, required = false,
                                 default = nil)
  if valid_577772 != nil:
    section.add "until", valid_577772
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577773 = header.getOrDefault("Accept")
  valid_577773 = validateParameter(valid_577773, JString, required = false,
                                 default = nil)
  if valid_577773 != nil:
    section.add "Accept", valid_577773
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577774: Call_GetReposOwnerRepoCommits_577763; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List commits on a repository.
  ## 
  let valid = call_577774.validator(path, query, header, formData, body)
  let scheme = call_577774.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577774.url(scheme.get, call_577774.host, call_577774.base,
                         call_577774.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577774, url, valid)

proc call*(call_577775: Call_GetReposOwnerRepoCommits_577763; repo: string;
          owner: string; author: string = ""; since: string = ""; sha: string = "";
          path: string = ""; until: string = ""; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommits
  ## List commits on a repository.
  ##   author: string
  ##         : GitHub login, name, or email by which to filter by commit author.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   sha: string
  ##      : Sha or branch to start listing commits from.
  ##   path: string
  ##       : Only commits containing this file path will be returned.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   until: string
  ##        : ISO 8601 Date - Only commits before this date will be returned.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577776 = newJObject()
  var query_577777 = newJObject()
  var header_577778 = newJObject()
  add(query_577777, "author", newJString(author))
  add(path_577776, "repo", newJString(repo))
  add(query_577777, "since", newJString(since))
  add(query_577777, "sha", newJString(sha))
  add(query_577777, "path", newJString(path))
  add(path_577776, "owner", newJString(owner))
  add(query_577777, "until", newJString(until))
  add(header_577778, "Accept", newJString(Accept))
  result = call_577775.call(path_577776, query_577777, header_577778, nil, nil)

var getReposOwnerRepoCommits* = Call_GetReposOwnerRepoCommits_577763(
    name: "getReposOwnerRepoCommits", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/commits",
    validator: validate_GetReposOwnerRepoCommits_577764, base: "/",
    url: url_GetReposOwnerRepoCommits_577765, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommitsRefStatus_577779 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoCommitsRefStatus_577781(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits/"),
               (kind: VariableSegment, value: "ref"),
               (kind: ConstantSegment, value: "/status")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommitsRefStatus_577780(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the combined Status for a specific Ref
  ## The Combined status endpoint is currently available for developers to preview. During the preview period, the API may change without advance notice. Please see the blog post for full details.
  ## To access this endpoint during the preview period, you must provide a custom media type in the Accept header:
  ## application/vnd.github.she-hulk-preview+json
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   ref: JString (required)
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577782 = path.getOrDefault("repo")
  valid_577782 = validateParameter(valid_577782, JString, required = true,
                                 default = nil)
  if valid_577782 != nil:
    section.add "repo", valid_577782
  var valid_577783 = path.getOrDefault("ref")
  valid_577783 = validateParameter(valid_577783, JString, required = true,
                                 default = nil)
  if valid_577783 != nil:
    section.add "ref", valid_577783
  var valid_577784 = path.getOrDefault("owner")
  valid_577784 = validateParameter(valid_577784, JString, required = true,
                                 default = nil)
  if valid_577784 != nil:
    section.add "owner", valid_577784
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577785 = header.getOrDefault("Accept")
  valid_577785 = validateParameter(valid_577785, JString, required = false,
                                 default = nil)
  if valid_577785 != nil:
    section.add "Accept", valid_577785
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577786: Call_GetReposOwnerRepoCommitsRefStatus_577779;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get the combined Status for a specific Ref
  ## The Combined status endpoint is currently available for developers to preview. During the preview period, the API may change without advance notice. Please see the blog post for full details.
  ## To access this endpoint during the preview period, you must provide a custom media type in the Accept header:
  ## application/vnd.github.she-hulk-preview+json
  ## 
  ## 
  let valid = call_577786.validator(path, query, header, formData, body)
  let scheme = call_577786.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577786.url(scheme.get, call_577786.host, call_577786.base,
                         call_577786.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577786, url, valid)

proc call*(call_577787: Call_GetReposOwnerRepoCommitsRefStatus_577779;
          repo: string; `ref`: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommitsRefStatus
  ## Get the combined Status for a specific Ref
  ## The Combined status endpoint is currently available for developers to preview. During the preview period, the API may change without advance notice. Please see the blog post for full details.
  ## To access this endpoint during the preview period, you must provide a custom media type in the Accept header:
  ## application/vnd.github.she-hulk-preview+json
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   ref: string (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577788 = newJObject()
  var header_577789 = newJObject()
  add(path_577788, "repo", newJString(repo))
  add(path_577788, "ref", newJString(`ref`))
  add(path_577788, "owner", newJString(owner))
  add(header_577789, "Accept", newJString(Accept))
  result = call_577787.call(path_577788, nil, header_577789, nil, nil)

var getReposOwnerRepoCommitsRefStatus* = Call_GetReposOwnerRepoCommitsRefStatus_577779(
    name: "getReposOwnerRepoCommitsRefStatus", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/commits/{ref}/status",
    validator: validate_GetReposOwnerRepoCommitsRefStatus_577780, base: "/",
    url: url_GetReposOwnerRepoCommitsRefStatus_577781, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommitsShaCode_577790 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoCommitsShaCode_577792(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommitsShaCode_577791(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   shaCode: JString (required)
  ##          : SHA-1 code of the commit.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577793 = path.getOrDefault("repo")
  valid_577793 = validateParameter(valid_577793, JString, required = true,
                                 default = nil)
  if valid_577793 != nil:
    section.add "repo", valid_577793
  var valid_577794 = path.getOrDefault("owner")
  valid_577794 = validateParameter(valid_577794, JString, required = true,
                                 default = nil)
  if valid_577794 != nil:
    section.add "owner", valid_577794
  var valid_577795 = path.getOrDefault("shaCode")
  valid_577795 = validateParameter(valid_577795, JString, required = true,
                                 default = nil)
  if valid_577795 != nil:
    section.add "shaCode", valid_577795
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577796 = header.getOrDefault("Accept")
  valid_577796 = validateParameter(valid_577796, JString, required = false,
                                 default = nil)
  if valid_577796 != nil:
    section.add "Accept", valid_577796
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577797: Call_GetReposOwnerRepoCommitsShaCode_577790;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single commit.
  ## 
  let valid = call_577797.validator(path, query, header, formData, body)
  let scheme = call_577797.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577797.url(scheme.get, call_577797.host, call_577797.base,
                         call_577797.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577797, url, valid)

proc call*(call_577798: Call_GetReposOwnerRepoCommitsShaCode_577790; repo: string;
          owner: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommitsShaCode
  ## Get a single commit.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   shaCode: string (required)
  ##          : SHA-1 code of the commit.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577799 = newJObject()
  var header_577800 = newJObject()
  add(path_577799, "repo", newJString(repo))
  add(path_577799, "owner", newJString(owner))
  add(path_577799, "shaCode", newJString(shaCode))
  add(header_577800, "Accept", newJString(Accept))
  result = call_577798.call(path_577799, nil, header_577800, nil, nil)

var getReposOwnerRepoCommitsShaCode* = Call_GetReposOwnerRepoCommitsShaCode_577790(
    name: "getReposOwnerRepoCommitsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/commits/{shaCode}",
    validator: validate_GetReposOwnerRepoCommitsShaCode_577791, base: "/",
    url: url_GetReposOwnerRepoCommitsShaCode_577792, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoCommitsShaCodeComments_577812 = ref object of OpenApiRestCall_576564
proc url_PostReposOwnerRepoCommitsShaCodeComments_577814(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits/"),
               (kind: VariableSegment, value: "shaCode"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoCommitsShaCodeComments_577813(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a commit comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   shaCode: JString (required)
  ##          : SHA-1 code of the commit.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577815 = path.getOrDefault("repo")
  valid_577815 = validateParameter(valid_577815, JString, required = true,
                                 default = nil)
  if valid_577815 != nil:
    section.add "repo", valid_577815
  var valid_577816 = path.getOrDefault("owner")
  valid_577816 = validateParameter(valid_577816, JString, required = true,
                                 default = nil)
  if valid_577816 != nil:
    section.add "owner", valid_577816
  var valid_577817 = path.getOrDefault("shaCode")
  valid_577817 = validateParameter(valid_577817, JString, required = true,
                                 default = nil)
  if valid_577817 != nil:
    section.add "shaCode", valid_577817
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577818 = header.getOrDefault("Accept")
  valid_577818 = validateParameter(valid_577818, JString, required = false,
                                 default = nil)
  if valid_577818 != nil:
    section.add "Accept", valid_577818
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_577820: Call_PostReposOwnerRepoCommitsShaCodeComments_577812;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Create a commit comment.
  ## 
  let valid = call_577820.validator(path, query, header, formData, body)
  let scheme = call_577820.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577820.url(scheme.get, call_577820.host, call_577820.base,
                         call_577820.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577820, url, valid)

proc call*(call_577821: Call_PostReposOwnerRepoCommitsShaCodeComments_577812;
          repo: string; owner: string; body: JsonNode; shaCode: string;
          Accept: string = ""): Recallable =
  ## postReposOwnerRepoCommitsShaCodeComments
  ## Create a commit comment.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   shaCode: string (required)
  ##          : SHA-1 code of the commit.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577822 = newJObject()
  var header_577823 = newJObject()
  var body_577824 = newJObject()
  add(path_577822, "repo", newJString(repo))
  add(path_577822, "owner", newJString(owner))
  if body != nil:
    body_577824 = body
  add(path_577822, "shaCode", newJString(shaCode))
  add(header_577823, "Accept", newJString(Accept))
  result = call_577821.call(path_577822, nil, header_577823, nil, body_577824)

var postReposOwnerRepoCommitsShaCodeComments* = Call_PostReposOwnerRepoCommitsShaCodeComments_577812(
    name: "postReposOwnerRepoCommitsShaCodeComments", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/commits/{shaCode}/comments",
    validator: validate_PostReposOwnerRepoCommitsShaCodeComments_577813,
    base: "/", url: url_PostReposOwnerRepoCommitsShaCodeComments_577814,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommitsShaCodeComments_577801 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoCommitsShaCodeComments_577803(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits/"),
               (kind: VariableSegment, value: "shaCode"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommitsShaCodeComments_577802(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List comments for a single commitList comments for a single commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   shaCode: JString (required)
  ##          : SHA-1 code of the commit.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577804 = path.getOrDefault("repo")
  valid_577804 = validateParameter(valid_577804, JString, required = true,
                                 default = nil)
  if valid_577804 != nil:
    section.add "repo", valid_577804
  var valid_577805 = path.getOrDefault("owner")
  valid_577805 = validateParameter(valid_577805, JString, required = true,
                                 default = nil)
  if valid_577805 != nil:
    section.add "owner", valid_577805
  var valid_577806 = path.getOrDefault("shaCode")
  valid_577806 = validateParameter(valid_577806, JString, required = true,
                                 default = nil)
  if valid_577806 != nil:
    section.add "shaCode", valid_577806
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577807 = header.getOrDefault("Accept")
  valid_577807 = validateParameter(valid_577807, JString, required = false,
                                 default = nil)
  if valid_577807 != nil:
    section.add "Accept", valid_577807
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577808: Call_GetReposOwnerRepoCommitsShaCodeComments_577801;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List comments for a single commitList comments for a single commit.
  ## 
  let valid = call_577808.validator(path, query, header, formData, body)
  let scheme = call_577808.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577808.url(scheme.get, call_577808.host, call_577808.base,
                         call_577808.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577808, url, valid)

proc call*(call_577809: Call_GetReposOwnerRepoCommitsShaCodeComments_577801;
          repo: string; owner: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommitsShaCodeComments
  ## List comments for a single commitList comments for a single commit.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   shaCode: string (required)
  ##          : SHA-1 code of the commit.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577810 = newJObject()
  var header_577811 = newJObject()
  add(path_577810, "repo", newJString(repo))
  add(path_577810, "owner", newJString(owner))
  add(path_577810, "shaCode", newJString(shaCode))
  add(header_577811, "Accept", newJString(Accept))
  result = call_577809.call(path_577810, nil, header_577811, nil, nil)

var getReposOwnerRepoCommitsShaCodeComments* = Call_GetReposOwnerRepoCommitsShaCodeComments_577801(
    name: "getReposOwnerRepoCommitsShaCodeComments", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/commits/{shaCode}/comments",
    validator: validate_GetReposOwnerRepoCommitsShaCodeComments_577802, base: "/",
    url: url_GetReposOwnerRepoCommitsShaCodeComments_577803,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCompareBaseIdHeadId_577825 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoCompareBaseIdHeadId_577827(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "baseId" in path, "`baseId` is a required path parameter"
  assert "headId" in path, "`headId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/compare/"),
               (kind: VariableSegment, value: "baseId"),
               (kind: ConstantSegment, value: "..."),
               (kind: VariableSegment, value: "headId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCompareBaseIdHeadId_577826(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Compare two commits
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   baseId: JString (required)
  ##   headId: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577828 = path.getOrDefault("repo")
  valid_577828 = validateParameter(valid_577828, JString, required = true,
                                 default = nil)
  if valid_577828 != nil:
    section.add "repo", valid_577828
  var valid_577829 = path.getOrDefault("owner")
  valid_577829 = validateParameter(valid_577829, JString, required = true,
                                 default = nil)
  if valid_577829 != nil:
    section.add "owner", valid_577829
  var valid_577830 = path.getOrDefault("baseId")
  valid_577830 = validateParameter(valid_577830, JString, required = true,
                                 default = nil)
  if valid_577830 != nil:
    section.add "baseId", valid_577830
  var valid_577831 = path.getOrDefault("headId")
  valid_577831 = validateParameter(valid_577831, JString, required = true,
                                 default = nil)
  if valid_577831 != nil:
    section.add "headId", valid_577831
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577832 = header.getOrDefault("Accept")
  valid_577832 = validateParameter(valid_577832, JString, required = false,
                                 default = nil)
  if valid_577832 != nil:
    section.add "Accept", valid_577832
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577833: Call_GetReposOwnerRepoCompareBaseIdHeadId_577825;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Compare two commits
  ## 
  let valid = call_577833.validator(path, query, header, formData, body)
  let scheme = call_577833.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577833.url(scheme.get, call_577833.host, call_577833.base,
                         call_577833.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577833, url, valid)

proc call*(call_577834: Call_GetReposOwnerRepoCompareBaseIdHeadId_577825;
          repo: string; owner: string; baseId: string; headId: string;
          Accept: string = ""): Recallable =
  ## getReposOwnerRepoCompareBaseIdHeadId
  ## Compare two commits
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   baseId: string (required)
  ##   headId: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577835 = newJObject()
  var header_577836 = newJObject()
  add(path_577835, "repo", newJString(repo))
  add(path_577835, "owner", newJString(owner))
  add(path_577835, "baseId", newJString(baseId))
  add(path_577835, "headId", newJString(headId))
  add(header_577836, "Accept", newJString(Accept))
  result = call_577834.call(path_577835, nil, header_577836, nil, nil)

var getReposOwnerRepoCompareBaseIdHeadId* = Call_GetReposOwnerRepoCompareBaseIdHeadId_577825(
    name: "getReposOwnerRepoCompareBaseIdHeadId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/compare/{baseId}...{headId}",
    validator: validate_GetReposOwnerRepoCompareBaseIdHeadId_577826, base: "/",
    url: url_GetReposOwnerRepoCompareBaseIdHeadId_577827, schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoContentsPath_577851 = ref object of OpenApiRestCall_576564
proc url_PutReposOwnerRepoContentsPath_577853(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/contents/"),
               (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoContentsPath_577852(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a file.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   path: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577854 = path.getOrDefault("repo")
  valid_577854 = validateParameter(valid_577854, JString, required = true,
                                 default = nil)
  if valid_577854 != nil:
    section.add "repo", valid_577854
  var valid_577855 = path.getOrDefault("owner")
  valid_577855 = validateParameter(valid_577855, JString, required = true,
                                 default = nil)
  if valid_577855 != nil:
    section.add "owner", valid_577855
  var valid_577856 = path.getOrDefault("path")
  valid_577856 = validateParameter(valid_577856, JString, required = true,
                                 default = nil)
  if valid_577856 != nil:
    section.add "path", valid_577856
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577857 = header.getOrDefault("Accept")
  valid_577857 = validateParameter(valid_577857, JString, required = false,
                                 default = nil)
  if valid_577857 != nil:
    section.add "Accept", valid_577857
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_577859: Call_PutReposOwnerRepoContentsPath_577851; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a file.
  ## 
  let valid = call_577859.validator(path, query, header, formData, body)
  let scheme = call_577859.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577859.url(scheme.get, call_577859.host, call_577859.base,
                         call_577859.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577859, url, valid)

proc call*(call_577860: Call_PutReposOwnerRepoContentsPath_577851; repo: string;
          owner: string; body: JsonNode; path: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoContentsPath
  ## Create a file.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   path: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577861 = newJObject()
  var header_577862 = newJObject()
  var body_577863 = newJObject()
  add(path_577861, "repo", newJString(repo))
  add(path_577861, "owner", newJString(owner))
  if body != nil:
    body_577863 = body
  add(path_577861, "path", newJString(path))
  add(header_577862, "Accept", newJString(Accept))
  result = call_577860.call(path_577861, nil, header_577862, nil, body_577863)

var putReposOwnerRepoContentsPath* = Call_PutReposOwnerRepoContentsPath_577851(
    name: "putReposOwnerRepoContentsPath", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contents/{path}",
    validator: validate_PutReposOwnerRepoContentsPath_577852, base: "/",
    url: url_PutReposOwnerRepoContentsPath_577853, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoContentsPath_577837 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoContentsPath_577839(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/contents/"),
               (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoContentsPath_577838(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get contents.
  ## This method returns the contents of a file or directory in a repository.
  ## Files and symlinks support a custom media type for getting the raw content.
  ## Directories and submodules do not support custom media types.
  ## Note: This API supports files up to 1 megabyte in size.
  ## Here can be many outcomes. For details see "http://developer.github.com/v3/repos/contents/"
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   path: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577840 = path.getOrDefault("repo")
  valid_577840 = validateParameter(valid_577840, JString, required = true,
                                 default = nil)
  if valid_577840 != nil:
    section.add "repo", valid_577840
  var valid_577841 = path.getOrDefault("owner")
  valid_577841 = validateParameter(valid_577841, JString, required = true,
                                 default = nil)
  if valid_577841 != nil:
    section.add "owner", valid_577841
  var valid_577842 = path.getOrDefault("path")
  valid_577842 = validateParameter(valid_577842, JString, required = true,
                                 default = nil)
  if valid_577842 != nil:
    section.add "path", valid_577842
  result.add "path", section
  ## parameters in `query` object:
  ##   path: JString
  ##       : The content path.
  ##   ref: JString
  ##      : The String name of the Commit/Branch/Tag. Defaults to 'master'.
  section = newJObject()
  var valid_577843 = query.getOrDefault("path")
  valid_577843 = validateParameter(valid_577843, JString, required = false,
                                 default = nil)
  if valid_577843 != nil:
    section.add "path", valid_577843
  var valid_577844 = query.getOrDefault("ref")
  valid_577844 = validateParameter(valid_577844, JString, required = false,
                                 default = nil)
  if valid_577844 != nil:
    section.add "ref", valid_577844
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577845 = header.getOrDefault("Accept")
  valid_577845 = validateParameter(valid_577845, JString, required = false,
                                 default = nil)
  if valid_577845 != nil:
    section.add "Accept", valid_577845
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577846: Call_GetReposOwnerRepoContentsPath_577837; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get contents.
  ## This method returns the contents of a file or directory in a repository.
  ## Files and symlinks support a custom media type for getting the raw content.
  ## Directories and submodules do not support custom media types.
  ## Note: This API supports files up to 1 megabyte in size.
  ## Here can be many outcomes. For details see "http://developer.github.com/v3/repos/contents/"
  ## 
  ## 
  let valid = call_577846.validator(path, query, header, formData, body)
  let scheme = call_577846.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577846.url(scheme.get, call_577846.host, call_577846.base,
                         call_577846.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577846, url, valid)

var getReposOwnerRepoContentsPath* = Call_GetReposOwnerRepoContentsPath_577837(
    name: "getReposOwnerRepoContentsPath", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contents/{path}",
    validator: validate_GetReposOwnerRepoContentsPath_577838, base: "/",
    url: url_GetReposOwnerRepoContentsPath_577839, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoContentsPath_577864 = ref object of OpenApiRestCall_576564
proc url_DeleteReposOwnerRepoContentsPath_577866(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/contents/"),
               (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoContentsPath_577865(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a file.
  ## This method deletes a file in a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   path: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577867 = path.getOrDefault("repo")
  valid_577867 = validateParameter(valid_577867, JString, required = true,
                                 default = nil)
  if valid_577867 != nil:
    section.add "repo", valid_577867
  var valid_577868 = path.getOrDefault("owner")
  valid_577868 = validateParameter(valid_577868, JString, required = true,
                                 default = nil)
  if valid_577868 != nil:
    section.add "owner", valid_577868
  var valid_577869 = path.getOrDefault("path")
  valid_577869 = validateParameter(valid_577869, JString, required = true,
                                 default = nil)
  if valid_577869 != nil:
    section.add "path", valid_577869
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577870 = header.getOrDefault("Accept")
  valid_577870 = validateParameter(valid_577870, JString, required = false,
                                 default = nil)
  if valid_577870 != nil:
    section.add "Accept", valid_577870
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_577872: Call_DeleteReposOwnerRepoContentsPath_577864;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a file.
  ## This method deletes a file in a repository.
  ## 
  ## 
  let valid = call_577872.validator(path, query, header, formData, body)
  let scheme = call_577872.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577872.url(scheme.get, call_577872.host, call_577872.base,
                         call_577872.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577872, url, valid)

proc call*(call_577873: Call_DeleteReposOwnerRepoContentsPath_577864; repo: string;
          owner: string; body: JsonNode; path: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoContentsPath
  ## Delete a file.
  ## This method deletes a file in a repository.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   path: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577874 = newJObject()
  var header_577875 = newJObject()
  var body_577876 = newJObject()
  add(path_577874, "repo", newJString(repo))
  add(path_577874, "owner", newJString(owner))
  if body != nil:
    body_577876 = body
  add(path_577874, "path", newJString(path))
  add(header_577875, "Accept", newJString(Accept))
  result = call_577873.call(path_577874, nil, header_577875, nil, body_577876)

var deleteReposOwnerRepoContentsPath* = Call_DeleteReposOwnerRepoContentsPath_577864(
    name: "deleteReposOwnerRepoContentsPath", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contents/{path}",
    validator: validate_DeleteReposOwnerRepoContentsPath_577865, base: "/",
    url: url_DeleteReposOwnerRepoContentsPath_577866, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoContributors_577877 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoContributors_577879(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/contributors")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoContributors_577878(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get list of contributors.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577880 = path.getOrDefault("repo")
  valid_577880 = validateParameter(valid_577880, JString, required = true,
                                 default = nil)
  if valid_577880 != nil:
    section.add "repo", valid_577880
  var valid_577881 = path.getOrDefault("owner")
  valid_577881 = validateParameter(valid_577881, JString, required = true,
                                 default = nil)
  if valid_577881 != nil:
    section.add "owner", valid_577881
  result.add "path", section
  ## parameters in `query` object:
  ##   anon: JString (required)
  ##       : Set to 1 or true to include anonymous contributors in results.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `anon` field"
  var valid_577882 = query.getOrDefault("anon")
  valid_577882 = validateParameter(valid_577882, JString, required = true,
                                 default = nil)
  if valid_577882 != nil:
    section.add "anon", valid_577882
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577883 = header.getOrDefault("Accept")
  valid_577883 = validateParameter(valid_577883, JString, required = false,
                                 default = nil)
  if valid_577883 != nil:
    section.add "Accept", valid_577883
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577884: Call_GetReposOwnerRepoContributors_577877; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get list of contributors.
  ## 
  let valid = call_577884.validator(path, query, header, formData, body)
  let scheme = call_577884.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577884.url(scheme.get, call_577884.host, call_577884.base,
                         call_577884.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577884, url, valid)

proc call*(call_577885: Call_GetReposOwnerRepoContributors_577877; repo: string;
          owner: string; anon: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoContributors
  ## Get list of contributors.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   anon: string (required)
  ##       : Set to 1 or true to include anonymous contributors in results.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577886 = newJObject()
  var query_577887 = newJObject()
  var header_577888 = newJObject()
  add(path_577886, "repo", newJString(repo))
  add(path_577886, "owner", newJString(owner))
  add(query_577887, "anon", newJString(anon))
  add(header_577888, "Accept", newJString(Accept))
  result = call_577885.call(path_577886, query_577887, header_577888, nil, nil)

var getReposOwnerRepoContributors* = Call_GetReposOwnerRepoContributors_577877(
    name: "getReposOwnerRepoContributors", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contributors",
    validator: validate_GetReposOwnerRepoContributors_577878, base: "/",
    url: url_GetReposOwnerRepoContributors_577879, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoDeployments_577899 = ref object of OpenApiRestCall_576564
proc url_PostReposOwnerRepoDeployments_577901(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/deployments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoDeployments_577900(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Users with push access can create a deployment for a given ref
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577902 = path.getOrDefault("repo")
  valid_577902 = validateParameter(valid_577902, JString, required = true,
                                 default = nil)
  if valid_577902 != nil:
    section.add "repo", valid_577902
  var valid_577903 = path.getOrDefault("owner")
  valid_577903 = validateParameter(valid_577903, JString, required = true,
                                 default = nil)
  if valid_577903 != nil:
    section.add "owner", valid_577903
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577904 = header.getOrDefault("Accept")
  valid_577904 = validateParameter(valid_577904, JString, required = false,
                                 default = nil)
  if valid_577904 != nil:
    section.add "Accept", valid_577904
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_577906: Call_PostReposOwnerRepoDeployments_577899; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Users with push access can create a deployment for a given ref
  ## 
  let valid = call_577906.validator(path, query, header, formData, body)
  let scheme = call_577906.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577906.url(scheme.get, call_577906.host, call_577906.base,
                         call_577906.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577906, url, valid)

proc call*(call_577907: Call_PostReposOwnerRepoDeployments_577899; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoDeployments
  ## Users with push access can create a deployment for a given ref
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577908 = newJObject()
  var header_577909 = newJObject()
  var body_577910 = newJObject()
  add(path_577908, "repo", newJString(repo))
  add(path_577908, "owner", newJString(owner))
  if body != nil:
    body_577910 = body
  add(header_577909, "Accept", newJString(Accept))
  result = call_577907.call(path_577908, nil, header_577909, nil, body_577910)

var postReposOwnerRepoDeployments* = Call_PostReposOwnerRepoDeployments_577899(
    name: "postReposOwnerRepoDeployments", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/deployments",
    validator: validate_PostReposOwnerRepoDeployments_577900, base: "/",
    url: url_PostReposOwnerRepoDeployments_577901, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDeployments_577889 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoDeployments_577891(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/deployments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDeployments_577890(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Users with pull access can view deployments for a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577892 = path.getOrDefault("repo")
  valid_577892 = validateParameter(valid_577892, JString, required = true,
                                 default = nil)
  if valid_577892 != nil:
    section.add "repo", valid_577892
  var valid_577893 = path.getOrDefault("owner")
  valid_577893 = validateParameter(valid_577893, JString, required = true,
                                 default = nil)
  if valid_577893 != nil:
    section.add "owner", valid_577893
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577894 = header.getOrDefault("Accept")
  valid_577894 = validateParameter(valid_577894, JString, required = false,
                                 default = nil)
  if valid_577894 != nil:
    section.add "Accept", valid_577894
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577895: Call_GetReposOwnerRepoDeployments_577889; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Users with pull access can view deployments for a repository
  ## 
  let valid = call_577895.validator(path, query, header, formData, body)
  let scheme = call_577895.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577895.url(scheme.get, call_577895.host, call_577895.base,
                         call_577895.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577895, url, valid)

proc call*(call_577896: Call_GetReposOwnerRepoDeployments_577889; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDeployments
  ## Users with pull access can view deployments for a repository
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577897 = newJObject()
  var header_577898 = newJObject()
  add(path_577897, "repo", newJString(repo))
  add(path_577897, "owner", newJString(owner))
  add(header_577898, "Accept", newJString(Accept))
  result = call_577896.call(path_577897, nil, header_577898, nil, nil)

var getReposOwnerRepoDeployments* = Call_GetReposOwnerRepoDeployments_577889(
    name: "getReposOwnerRepoDeployments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/deployments",
    validator: validate_GetReposOwnerRepoDeployments_577890, base: "/",
    url: url_GetReposOwnerRepoDeployments_577891, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoDeploymentsIdStatuses_577922 = ref object of OpenApiRestCall_576564
proc url_PostReposOwnerRepoDeploymentsIdStatuses_577924(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/deployments/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/statuses")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoDeploymentsIdStatuses_577923(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a Deployment Status
  ## Users with push access can create deployment statuses for a given deployment:
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   id: JInt (required)
  ##     : The Deployment ID to list the statuses from.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577925 = path.getOrDefault("repo")
  valid_577925 = validateParameter(valid_577925, JString, required = true,
                                 default = nil)
  if valid_577925 != nil:
    section.add "repo", valid_577925
  var valid_577926 = path.getOrDefault("id")
  valid_577926 = validateParameter(valid_577926, JInt, required = true, default = nil)
  if valid_577926 != nil:
    section.add "id", valid_577926
  var valid_577927 = path.getOrDefault("owner")
  valid_577927 = validateParameter(valid_577927, JString, required = true,
                                 default = nil)
  if valid_577927 != nil:
    section.add "owner", valid_577927
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577928 = header.getOrDefault("Accept")
  valid_577928 = validateParameter(valid_577928, JString, required = false,
                                 default = nil)
  if valid_577928 != nil:
    section.add "Accept", valid_577928
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_577930: Call_PostReposOwnerRepoDeploymentsIdStatuses_577922;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Create a Deployment Status
  ## Users with push access can create deployment statuses for a given deployment:
  ## 
  ## 
  let valid = call_577930.validator(path, query, header, formData, body)
  let scheme = call_577930.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577930.url(scheme.get, call_577930.host, call_577930.base,
                         call_577930.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577930, url, valid)

proc call*(call_577931: Call_PostReposOwnerRepoDeploymentsIdStatuses_577922;
          repo: string; id: int; owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoDeploymentsIdStatuses
  ## Create a Deployment Status
  ## Users with push access can create deployment statuses for a given deployment:
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   id: int (required)
  ##     : The Deployment ID to list the statuses from.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577932 = newJObject()
  var header_577933 = newJObject()
  var body_577934 = newJObject()
  add(path_577932, "repo", newJString(repo))
  add(path_577932, "id", newJInt(id))
  add(path_577932, "owner", newJString(owner))
  if body != nil:
    body_577934 = body
  add(header_577933, "Accept", newJString(Accept))
  result = call_577931.call(path_577932, nil, header_577933, nil, body_577934)

var postReposOwnerRepoDeploymentsIdStatuses* = Call_PostReposOwnerRepoDeploymentsIdStatuses_577922(
    name: "postReposOwnerRepoDeploymentsIdStatuses", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/deployments/{id}/statuses",
    validator: validate_PostReposOwnerRepoDeploymentsIdStatuses_577923, base: "/",
    url: url_PostReposOwnerRepoDeploymentsIdStatuses_577924,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDeploymentsIdStatuses_577911 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoDeploymentsIdStatuses_577913(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/deployments/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/statuses")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDeploymentsIdStatuses_577912(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Users with pull access can view deployment statuses for a deployment
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   id: JInt (required)
  ##     : The Deployment ID to list the statuses from.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577914 = path.getOrDefault("repo")
  valid_577914 = validateParameter(valid_577914, JString, required = true,
                                 default = nil)
  if valid_577914 != nil:
    section.add "repo", valid_577914
  var valid_577915 = path.getOrDefault("id")
  valid_577915 = validateParameter(valid_577915, JInt, required = true, default = nil)
  if valid_577915 != nil:
    section.add "id", valid_577915
  var valid_577916 = path.getOrDefault("owner")
  valid_577916 = validateParameter(valid_577916, JString, required = true,
                                 default = nil)
  if valid_577916 != nil:
    section.add "owner", valid_577916
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577917 = header.getOrDefault("Accept")
  valid_577917 = validateParameter(valid_577917, JString, required = false,
                                 default = nil)
  if valid_577917 != nil:
    section.add "Accept", valid_577917
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577918: Call_GetReposOwnerRepoDeploymentsIdStatuses_577911;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Users with pull access can view deployment statuses for a deployment
  ## 
  let valid = call_577918.validator(path, query, header, formData, body)
  let scheme = call_577918.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577918.url(scheme.get, call_577918.host, call_577918.base,
                         call_577918.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577918, url, valid)

proc call*(call_577919: Call_GetReposOwnerRepoDeploymentsIdStatuses_577911;
          repo: string; id: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDeploymentsIdStatuses
  ## Users with pull access can view deployment statuses for a deployment
  ##   repo: string (required)
  ##       : Name of repository.
  ##   id: int (required)
  ##     : The Deployment ID to list the statuses from.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577920 = newJObject()
  var header_577921 = newJObject()
  add(path_577920, "repo", newJString(repo))
  add(path_577920, "id", newJInt(id))
  add(path_577920, "owner", newJString(owner))
  add(header_577921, "Accept", newJString(Accept))
  result = call_577919.call(path_577920, nil, header_577921, nil, nil)

var getReposOwnerRepoDeploymentsIdStatuses* = Call_GetReposOwnerRepoDeploymentsIdStatuses_577911(
    name: "getReposOwnerRepoDeploymentsIdStatuses", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/deployments/{id}/statuses",
    validator: validate_GetReposOwnerRepoDeploymentsIdStatuses_577912, base: "/",
    url: url_GetReposOwnerRepoDeploymentsIdStatuses_577913,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDownloads_577935 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoDownloads_577937(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/downloads")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDownloads_577936(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deprecated. List downloads for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577938 = path.getOrDefault("repo")
  valid_577938 = validateParameter(valid_577938, JString, required = true,
                                 default = nil)
  if valid_577938 != nil:
    section.add "repo", valid_577938
  var valid_577939 = path.getOrDefault("owner")
  valid_577939 = validateParameter(valid_577939, JString, required = true,
                                 default = nil)
  if valid_577939 != nil:
    section.add "owner", valid_577939
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577940 = header.getOrDefault("Accept")
  valid_577940 = validateParameter(valid_577940, JString, required = false,
                                 default = nil)
  if valid_577940 != nil:
    section.add "Accept", valid_577940
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577941: Call_GetReposOwnerRepoDownloads_577935; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deprecated. List downloads for a repository.
  ## 
  let valid = call_577941.validator(path, query, header, formData, body)
  let scheme = call_577941.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577941.url(scheme.get, call_577941.host, call_577941.base,
                         call_577941.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577941, url, valid)

proc call*(call_577942: Call_GetReposOwnerRepoDownloads_577935; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDownloads
  ## Deprecated. List downloads for a repository.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577943 = newJObject()
  var header_577944 = newJObject()
  add(path_577943, "repo", newJString(repo))
  add(path_577943, "owner", newJString(owner))
  add(header_577944, "Accept", newJString(Accept))
  result = call_577942.call(path_577943, nil, header_577944, nil, nil)

var getReposOwnerRepoDownloads* = Call_GetReposOwnerRepoDownloads_577935(
    name: "getReposOwnerRepoDownloads", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/downloads",
    validator: validate_GetReposOwnerRepoDownloads_577936, base: "/",
    url: url_GetReposOwnerRepoDownloads_577937, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDownloadsDownloadId_577945 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoDownloadsDownloadId_577947(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "downloadId" in path, "`downloadId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/downloads/"),
               (kind: VariableSegment, value: "downloadId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDownloadsDownloadId_577946(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deprecated. Get a single download.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   downloadId: JInt (required)
  ##             : Id of download.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577948 = path.getOrDefault("repo")
  valid_577948 = validateParameter(valid_577948, JString, required = true,
                                 default = nil)
  if valid_577948 != nil:
    section.add "repo", valid_577948
  var valid_577949 = path.getOrDefault("downloadId")
  valid_577949 = validateParameter(valid_577949, JInt, required = true, default = nil)
  if valid_577949 != nil:
    section.add "downloadId", valid_577949
  var valid_577950 = path.getOrDefault("owner")
  valid_577950 = validateParameter(valid_577950, JString, required = true,
                                 default = nil)
  if valid_577950 != nil:
    section.add "owner", valid_577950
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577951 = header.getOrDefault("Accept")
  valid_577951 = validateParameter(valid_577951, JString, required = false,
                                 default = nil)
  if valid_577951 != nil:
    section.add "Accept", valid_577951
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577952: Call_GetReposOwnerRepoDownloadsDownloadId_577945;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deprecated. Get a single download.
  ## 
  let valid = call_577952.validator(path, query, header, formData, body)
  let scheme = call_577952.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577952.url(scheme.get, call_577952.host, call_577952.base,
                         call_577952.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577952, url, valid)

proc call*(call_577953: Call_GetReposOwnerRepoDownloadsDownloadId_577945;
          repo: string; downloadId: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDownloadsDownloadId
  ## Deprecated. Get a single download.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   downloadId: int (required)
  ##             : Id of download.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577954 = newJObject()
  var header_577955 = newJObject()
  add(path_577954, "repo", newJString(repo))
  add(path_577954, "downloadId", newJInt(downloadId))
  add(path_577954, "owner", newJString(owner))
  add(header_577955, "Accept", newJString(Accept))
  result = call_577953.call(path_577954, nil, header_577955, nil, nil)

var getReposOwnerRepoDownloadsDownloadId* = Call_GetReposOwnerRepoDownloadsDownloadId_577945(
    name: "getReposOwnerRepoDownloadsDownloadId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/downloads/{downloadId}",
    validator: validate_GetReposOwnerRepoDownloadsDownloadId_577946, base: "/",
    url: url_GetReposOwnerRepoDownloadsDownloadId_577947, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoDownloadsDownloadId_577956 = ref object of OpenApiRestCall_576564
proc url_DeleteReposOwnerRepoDownloadsDownloadId_577958(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "downloadId" in path, "`downloadId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/downloads/"),
               (kind: VariableSegment, value: "downloadId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoDownloadsDownloadId_577957(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deprecated. Delete a download.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   downloadId: JInt (required)
  ##             : Id of download.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577959 = path.getOrDefault("repo")
  valid_577959 = validateParameter(valid_577959, JString, required = true,
                                 default = nil)
  if valid_577959 != nil:
    section.add "repo", valid_577959
  var valid_577960 = path.getOrDefault("downloadId")
  valid_577960 = validateParameter(valid_577960, JInt, required = true, default = nil)
  if valid_577960 != nil:
    section.add "downloadId", valid_577960
  var valid_577961 = path.getOrDefault("owner")
  valid_577961 = validateParameter(valid_577961, JString, required = true,
                                 default = nil)
  if valid_577961 != nil:
    section.add "owner", valid_577961
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577962 = header.getOrDefault("Accept")
  valid_577962 = validateParameter(valid_577962, JString, required = false,
                                 default = nil)
  if valid_577962 != nil:
    section.add "Accept", valid_577962
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577963: Call_DeleteReposOwnerRepoDownloadsDownloadId_577956;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deprecated. Delete a download.
  ## 
  let valid = call_577963.validator(path, query, header, formData, body)
  let scheme = call_577963.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577963.url(scheme.get, call_577963.host, call_577963.base,
                         call_577963.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577963, url, valid)

proc call*(call_577964: Call_DeleteReposOwnerRepoDownloadsDownloadId_577956;
          repo: string; downloadId: int; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoDownloadsDownloadId
  ## Deprecated. Delete a download.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   downloadId: int (required)
  ##             : Id of download.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577965 = newJObject()
  var header_577966 = newJObject()
  add(path_577965, "repo", newJString(repo))
  add(path_577965, "downloadId", newJInt(downloadId))
  add(path_577965, "owner", newJString(owner))
  add(header_577966, "Accept", newJString(Accept))
  result = call_577964.call(path_577965, nil, header_577966, nil, nil)

var deleteReposOwnerRepoDownloadsDownloadId* = Call_DeleteReposOwnerRepoDownloadsDownloadId_577956(
    name: "deleteReposOwnerRepoDownloadsDownloadId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/downloads/{downloadId}",
    validator: validate_DeleteReposOwnerRepoDownloadsDownloadId_577957, base: "/",
    url: url_DeleteReposOwnerRepoDownloadsDownloadId_577958,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoEvents_577967 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoEvents_577969(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoEvents_577968(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get list of repository events.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577970 = path.getOrDefault("repo")
  valid_577970 = validateParameter(valid_577970, JString, required = true,
                                 default = nil)
  if valid_577970 != nil:
    section.add "repo", valid_577970
  var valid_577971 = path.getOrDefault("owner")
  valid_577971 = validateParameter(valid_577971, JString, required = true,
                                 default = nil)
  if valid_577971 != nil:
    section.add "owner", valid_577971
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577972 = header.getOrDefault("Accept")
  valid_577972 = validateParameter(valid_577972, JString, required = false,
                                 default = nil)
  if valid_577972 != nil:
    section.add "Accept", valid_577972
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577973: Call_GetReposOwnerRepoEvents_577967; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get list of repository events.
  ## 
  let valid = call_577973.validator(path, query, header, formData, body)
  let scheme = call_577973.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577973.url(scheme.get, call_577973.host, call_577973.base,
                         call_577973.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577973, url, valid)

proc call*(call_577974: Call_GetReposOwnerRepoEvents_577967; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoEvents
  ## Get list of repository events.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577975 = newJObject()
  var header_577976 = newJObject()
  add(path_577975, "repo", newJString(repo))
  add(path_577975, "owner", newJString(owner))
  add(header_577976, "Accept", newJString(Accept))
  result = call_577974.call(path_577975, nil, header_577976, nil, nil)

var getReposOwnerRepoEvents* = Call_GetReposOwnerRepoEvents_577967(
    name: "getReposOwnerRepoEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/events",
    validator: validate_GetReposOwnerRepoEvents_577968, base: "/",
    url: url_GetReposOwnerRepoEvents_577969, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoForks_577989 = ref object of OpenApiRestCall_576564
proc url_PostReposOwnerRepoForks_577991(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/forks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoForks_577990(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a fork.
  ## Forking a Repository happens asynchronously. Therefore, you may have to wai
  ## a short period before accessing the git objects. If this takes longer than 5
  ## minutes, be sure to contact Support.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577992 = path.getOrDefault("repo")
  valid_577992 = validateParameter(valid_577992, JString, required = true,
                                 default = nil)
  if valid_577992 != nil:
    section.add "repo", valid_577992
  var valid_577993 = path.getOrDefault("owner")
  valid_577993 = validateParameter(valid_577993, JString, required = true,
                                 default = nil)
  if valid_577993 != nil:
    section.add "owner", valid_577993
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577994 = header.getOrDefault("Accept")
  valid_577994 = validateParameter(valid_577994, JString, required = false,
                                 default = nil)
  if valid_577994 != nil:
    section.add "Accept", valid_577994
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_577996: Call_PostReposOwnerRepoForks_577989; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a fork.
  ## Forking a Repository happens asynchronously. Therefore, you may have to wai
  ## a short period before accessing the git objects. If this takes longer than 5
  ## minutes, be sure to contact Support.
  ## 
  ## 
  let valid = call_577996.validator(path, query, header, formData, body)
  let scheme = call_577996.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577996.url(scheme.get, call_577996.host, call_577996.base,
                         call_577996.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577996, url, valid)

proc call*(call_577997: Call_PostReposOwnerRepoForks_577989; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoForks
  ## Create a fork.
  ## Forking a Repository happens asynchronously. Therefore, you may have to wai
  ## a short period before accessing the git objects. If this takes longer than 5
  ## minutes, be sure to contact Support.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_577998 = newJObject()
  var header_577999 = newJObject()
  var body_578000 = newJObject()
  add(path_577998, "repo", newJString(repo))
  add(path_577998, "owner", newJString(owner))
  if body != nil:
    body_578000 = body
  add(header_577999, "Accept", newJString(Accept))
  result = call_577997.call(path_577998, nil, header_577999, nil, body_578000)

var postReposOwnerRepoForks* = Call_PostReposOwnerRepoForks_577989(
    name: "postReposOwnerRepoForks", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/forks",
    validator: validate_PostReposOwnerRepoForks_577990, base: "/",
    url: url_PostReposOwnerRepoForks_577991, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoForks_577977 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoForks_577979(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/forks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoForks_577978(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List forks.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_577980 = path.getOrDefault("repo")
  valid_577980 = validateParameter(valid_577980, JString, required = true,
                                 default = nil)
  if valid_577980 != nil:
    section.add "repo", valid_577980
  var valid_577981 = path.getOrDefault("owner")
  valid_577981 = validateParameter(valid_577981, JString, required = true,
                                 default = nil)
  if valid_577981 != nil:
    section.add "owner", valid_577981
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  section = newJObject()
  var valid_577982 = query.getOrDefault("sort")
  valid_577982 = validateParameter(valid_577982, JString, required = false,
                                 default = newJString("newes"))
  if valid_577982 != nil:
    section.add "sort", valid_577982
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_577983 = header.getOrDefault("Accept")
  valid_577983 = validateParameter(valid_577983, JString, required = false,
                                 default = nil)
  if valid_577983 != nil:
    section.add "Accept", valid_577983
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_577984: Call_GetReposOwnerRepoForks_577977; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List forks.
  ## 
  let valid = call_577984.validator(path, query, header, formData, body)
  let scheme = call_577984.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_577984.url(scheme.get, call_577984.host, call_577984.base,
                         call_577984.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_577984, url, valid)

proc call*(call_577985: Call_GetReposOwnerRepoForks_577977; repo: string;
          owner: string; Accept: string = ""; sort: string = "newes"): Recallable =
  ## getReposOwnerRepoForks
  ## List forks.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  var path_577986 = newJObject()
  var query_577987 = newJObject()
  var header_577988 = newJObject()
  add(path_577986, "repo", newJString(repo))
  add(path_577986, "owner", newJString(owner))
  add(header_577988, "Accept", newJString(Accept))
  add(query_577987, "sort", newJString(sort))
  result = call_577985.call(path_577986, query_577987, header_577988, nil, nil)

var getReposOwnerRepoForks* = Call_GetReposOwnerRepoForks_577977(
    name: "getReposOwnerRepoForks", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/forks",
    validator: validate_GetReposOwnerRepoForks_577978, base: "/",
    url: url_GetReposOwnerRepoForks_577979, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitBlobs_578001 = ref object of OpenApiRestCall_576564
proc url_PostReposOwnerRepoGitBlobs_578003(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/blobs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitBlobs_578002(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a Blob.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578004 = path.getOrDefault("repo")
  valid_578004 = validateParameter(valid_578004, JString, required = true,
                                 default = nil)
  if valid_578004 != nil:
    section.add "repo", valid_578004
  var valid_578005 = path.getOrDefault("owner")
  valid_578005 = validateParameter(valid_578005, JString, required = true,
                                 default = nil)
  if valid_578005 != nil:
    section.add "owner", valid_578005
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578006 = header.getOrDefault("Accept")
  valid_578006 = validateParameter(valid_578006, JString, required = false,
                                 default = nil)
  if valid_578006 != nil:
    section.add "Accept", valid_578006
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578008: Call_PostReposOwnerRepoGitBlobs_578001; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a Blob.
  ## 
  let valid = call_578008.validator(path, query, header, formData, body)
  let scheme = call_578008.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578008.url(scheme.get, call_578008.host, call_578008.base,
                         call_578008.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578008, url, valid)

proc call*(call_578009: Call_PostReposOwnerRepoGitBlobs_578001; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitBlobs
  ## Create a Blob.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578010 = newJObject()
  var header_578011 = newJObject()
  var body_578012 = newJObject()
  add(path_578010, "repo", newJString(repo))
  add(path_578010, "owner", newJString(owner))
  if body != nil:
    body_578012 = body
  add(header_578011, "Accept", newJString(Accept))
  result = call_578009.call(path_578010, nil, header_578011, nil, body_578012)

var postReposOwnerRepoGitBlobs* = Call_PostReposOwnerRepoGitBlobs_578001(
    name: "postReposOwnerRepoGitBlobs", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/blobs",
    validator: validate_PostReposOwnerRepoGitBlobs_578002, base: "/",
    url: url_PostReposOwnerRepoGitBlobs_578003, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitBlobsShaCode_578013 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoGitBlobsShaCode_578015(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/blobs/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitBlobsShaCode_578014(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a Blob.
  ## Since blobs can be any arbitrary binary data, the input and responses for
  ## the blob API takes an encoding parameter that can be either utf-8 or
  ## base64. If your data cannot be losslessly sent as a UTF-8 string, you can
  ## base64 encode it.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   shaCode: JString (required)
  ##          : SHA-1 code.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578016 = path.getOrDefault("repo")
  valid_578016 = validateParameter(valid_578016, JString, required = true,
                                 default = nil)
  if valid_578016 != nil:
    section.add "repo", valid_578016
  var valid_578017 = path.getOrDefault("owner")
  valid_578017 = validateParameter(valid_578017, JString, required = true,
                                 default = nil)
  if valid_578017 != nil:
    section.add "owner", valid_578017
  var valid_578018 = path.getOrDefault("shaCode")
  valid_578018 = validateParameter(valid_578018, JString, required = true,
                                 default = nil)
  if valid_578018 != nil:
    section.add "shaCode", valid_578018
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578019 = header.getOrDefault("Accept")
  valid_578019 = validateParameter(valid_578019, JString, required = false,
                                 default = nil)
  if valid_578019 != nil:
    section.add "Accept", valid_578019
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578020: Call_GetReposOwnerRepoGitBlobsShaCode_578013;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a Blob.
  ## Since blobs can be any arbitrary binary data, the input and responses for
  ## the blob API takes an encoding parameter that can be either utf-8 or
  ## base64. If your data cannot be losslessly sent as a UTF-8 string, you can
  ## base64 encode it.
  ## 
  ## 
  let valid = call_578020.validator(path, query, header, formData, body)
  let scheme = call_578020.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578020.url(scheme.get, call_578020.host, call_578020.base,
                         call_578020.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578020, url, valid)

proc call*(call_578021: Call_GetReposOwnerRepoGitBlobsShaCode_578013; repo: string;
          owner: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitBlobsShaCode
  ## Get a Blob.
  ## Since blobs can be any arbitrary binary data, the input and responses for
  ## the blob API takes an encoding parameter that can be either utf-8 or
  ## base64. If your data cannot be losslessly sent as a UTF-8 string, you can
  ## base64 encode it.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   shaCode: string (required)
  ##          : SHA-1 code.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578022 = newJObject()
  var header_578023 = newJObject()
  add(path_578022, "repo", newJString(repo))
  add(path_578022, "owner", newJString(owner))
  add(path_578022, "shaCode", newJString(shaCode))
  add(header_578023, "Accept", newJString(Accept))
  result = call_578021.call(path_578022, nil, header_578023, nil, nil)

var getReposOwnerRepoGitBlobsShaCode* = Call_GetReposOwnerRepoGitBlobsShaCode_578013(
    name: "getReposOwnerRepoGitBlobsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/blobs/{shaCode}",
    validator: validate_GetReposOwnerRepoGitBlobsShaCode_578014, base: "/",
    url: url_GetReposOwnerRepoGitBlobsShaCode_578015, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitCommits_578024 = ref object of OpenApiRestCall_576564
proc url_PostReposOwnerRepoGitCommits_578026(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/commits")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitCommits_578025(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a Commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578027 = path.getOrDefault("repo")
  valid_578027 = validateParameter(valid_578027, JString, required = true,
                                 default = nil)
  if valid_578027 != nil:
    section.add "repo", valid_578027
  var valid_578028 = path.getOrDefault("owner")
  valid_578028 = validateParameter(valid_578028, JString, required = true,
                                 default = nil)
  if valid_578028 != nil:
    section.add "owner", valid_578028
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578029 = header.getOrDefault("Accept")
  valid_578029 = validateParameter(valid_578029, JString, required = false,
                                 default = nil)
  if valid_578029 != nil:
    section.add "Accept", valid_578029
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578031: Call_PostReposOwnerRepoGitCommits_578024; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a Commit.
  ## 
  let valid = call_578031.validator(path, query, header, formData, body)
  let scheme = call_578031.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578031.url(scheme.get, call_578031.host, call_578031.base,
                         call_578031.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578031, url, valid)

proc call*(call_578032: Call_PostReposOwnerRepoGitCommits_578024; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitCommits
  ## Create a Commit.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578033 = newJObject()
  var header_578034 = newJObject()
  var body_578035 = newJObject()
  add(path_578033, "repo", newJString(repo))
  add(path_578033, "owner", newJString(owner))
  if body != nil:
    body_578035 = body
  add(header_578034, "Accept", newJString(Accept))
  result = call_578032.call(path_578033, nil, header_578034, nil, body_578035)

var postReposOwnerRepoGitCommits* = Call_PostReposOwnerRepoGitCommits_578024(
    name: "postReposOwnerRepoGitCommits", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/commits",
    validator: validate_PostReposOwnerRepoGitCommits_578025, base: "/",
    url: url_PostReposOwnerRepoGitCommits_578026, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitCommitsShaCode_578036 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoGitCommitsShaCode_578038(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/commits/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitCommitsShaCode_578037(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a Commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   shaCode: JString (required)
  ##          : SHA-1 code.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578039 = path.getOrDefault("repo")
  valid_578039 = validateParameter(valid_578039, JString, required = true,
                                 default = nil)
  if valid_578039 != nil:
    section.add "repo", valid_578039
  var valid_578040 = path.getOrDefault("owner")
  valid_578040 = validateParameter(valid_578040, JString, required = true,
                                 default = nil)
  if valid_578040 != nil:
    section.add "owner", valid_578040
  var valid_578041 = path.getOrDefault("shaCode")
  valid_578041 = validateParameter(valid_578041, JString, required = true,
                                 default = nil)
  if valid_578041 != nil:
    section.add "shaCode", valid_578041
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578042 = header.getOrDefault("Accept")
  valid_578042 = validateParameter(valid_578042, JString, required = false,
                                 default = nil)
  if valid_578042 != nil:
    section.add "Accept", valid_578042
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578043: Call_GetReposOwnerRepoGitCommitsShaCode_578036;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a Commit.
  ## 
  let valid = call_578043.validator(path, query, header, formData, body)
  let scheme = call_578043.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578043.url(scheme.get, call_578043.host, call_578043.base,
                         call_578043.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578043, url, valid)

proc call*(call_578044: Call_GetReposOwnerRepoGitCommitsShaCode_578036;
          repo: string; owner: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitCommitsShaCode
  ## Get a Commit.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   shaCode: string (required)
  ##          : SHA-1 code.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578045 = newJObject()
  var header_578046 = newJObject()
  add(path_578045, "repo", newJString(repo))
  add(path_578045, "owner", newJString(owner))
  add(path_578045, "shaCode", newJString(shaCode))
  add(header_578046, "Accept", newJString(Accept))
  result = call_578044.call(path_578045, nil, header_578046, nil, nil)

var getReposOwnerRepoGitCommitsShaCode* = Call_GetReposOwnerRepoGitCommitsShaCode_578036(
    name: "getReposOwnerRepoGitCommitsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/commits/{shaCode}",
    validator: validate_GetReposOwnerRepoGitCommitsShaCode_578037, base: "/",
    url: url_GetReposOwnerRepoGitCommitsShaCode_578038, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitRefs_578057 = ref object of OpenApiRestCall_576564
proc url_PostReposOwnerRepoGitRefs_578059(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitRefs_578058(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a Reference
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578060 = path.getOrDefault("repo")
  valid_578060 = validateParameter(valid_578060, JString, required = true,
                                 default = nil)
  if valid_578060 != nil:
    section.add "repo", valid_578060
  var valid_578061 = path.getOrDefault("owner")
  valid_578061 = validateParameter(valid_578061, JString, required = true,
                                 default = nil)
  if valid_578061 != nil:
    section.add "owner", valid_578061
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578062 = header.getOrDefault("Accept")
  valid_578062 = validateParameter(valid_578062, JString, required = false,
                                 default = nil)
  if valid_578062 != nil:
    section.add "Accept", valid_578062
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578064: Call_PostReposOwnerRepoGitRefs_578057; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a Reference
  ## 
  let valid = call_578064.validator(path, query, header, formData, body)
  let scheme = call_578064.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578064.url(scheme.get, call_578064.host, call_578064.base,
                         call_578064.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578064, url, valid)

proc call*(call_578065: Call_PostReposOwnerRepoGitRefs_578057; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitRefs
  ## Create a Reference
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578066 = newJObject()
  var header_578067 = newJObject()
  var body_578068 = newJObject()
  add(path_578066, "repo", newJString(repo))
  add(path_578066, "owner", newJString(owner))
  if body != nil:
    body_578068 = body
  add(header_578067, "Accept", newJString(Accept))
  result = call_578065.call(path_578066, nil, header_578067, nil, body_578068)

var postReposOwnerRepoGitRefs* = Call_PostReposOwnerRepoGitRefs_578057(
    name: "postReposOwnerRepoGitRefs", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs",
    validator: validate_PostReposOwnerRepoGitRefs_578058, base: "/",
    url: url_PostReposOwnerRepoGitRefs_578059, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitRefs_578047 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoGitRefs_578049(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitRefs_578048(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get all References
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578050 = path.getOrDefault("repo")
  valid_578050 = validateParameter(valid_578050, JString, required = true,
                                 default = nil)
  if valid_578050 != nil:
    section.add "repo", valid_578050
  var valid_578051 = path.getOrDefault("owner")
  valid_578051 = validateParameter(valid_578051, JString, required = true,
                                 default = nil)
  if valid_578051 != nil:
    section.add "owner", valid_578051
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578052 = header.getOrDefault("Accept")
  valid_578052 = validateParameter(valid_578052, JString, required = false,
                                 default = nil)
  if valid_578052 != nil:
    section.add "Accept", valid_578052
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578053: Call_GetReposOwnerRepoGitRefs_578047; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get all References
  ## 
  let valid = call_578053.validator(path, query, header, formData, body)
  let scheme = call_578053.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578053.url(scheme.get, call_578053.host, call_578053.base,
                         call_578053.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578053, url, valid)

proc call*(call_578054: Call_GetReposOwnerRepoGitRefs_578047; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitRefs
  ## Get all References
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578055 = newJObject()
  var header_578056 = newJObject()
  add(path_578055, "repo", newJString(repo))
  add(path_578055, "owner", newJString(owner))
  add(header_578056, "Accept", newJString(Accept))
  result = call_578054.call(path_578055, nil, header_578056, nil, nil)

var getReposOwnerRepoGitRefs* = Call_GetReposOwnerRepoGitRefs_578047(
    name: "getReposOwnerRepoGitRefs", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs",
    validator: validate_GetReposOwnerRepoGitRefs_578048, base: "/",
    url: url_GetReposOwnerRepoGitRefs_578049, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitRefsRef_578069 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoGitRefsRef_578071(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitRefsRef_578070(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a Reference
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   ref: JString (required)
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578072 = path.getOrDefault("repo")
  valid_578072 = validateParameter(valid_578072, JString, required = true,
                                 default = nil)
  if valid_578072 != nil:
    section.add "repo", valid_578072
  var valid_578073 = path.getOrDefault("ref")
  valid_578073 = validateParameter(valid_578073, JString, required = true,
                                 default = nil)
  if valid_578073 != nil:
    section.add "ref", valid_578073
  var valid_578074 = path.getOrDefault("owner")
  valid_578074 = validateParameter(valid_578074, JString, required = true,
                                 default = nil)
  if valid_578074 != nil:
    section.add "owner", valid_578074
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578075 = header.getOrDefault("Accept")
  valid_578075 = validateParameter(valid_578075, JString, required = false,
                                 default = nil)
  if valid_578075 != nil:
    section.add "Accept", valid_578075
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578076: Call_GetReposOwnerRepoGitRefsRef_578069; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a Reference
  ## 
  let valid = call_578076.validator(path, query, header, formData, body)
  let scheme = call_578076.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578076.url(scheme.get, call_578076.host, call_578076.base,
                         call_578076.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578076, url, valid)

proc call*(call_578077: Call_GetReposOwnerRepoGitRefsRef_578069; repo: string;
          `ref`: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitRefsRef
  ## Get a Reference
  ##   repo: string (required)
  ##       : Name of repository.
  ##   ref: string (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578078 = newJObject()
  var header_578079 = newJObject()
  add(path_578078, "repo", newJString(repo))
  add(path_578078, "ref", newJString(`ref`))
  add(path_578078, "owner", newJString(owner))
  add(header_578079, "Accept", newJString(Accept))
  result = call_578077.call(path_578078, nil, header_578079, nil, nil)

var getReposOwnerRepoGitRefsRef* = Call_GetReposOwnerRepoGitRefsRef_578069(
    name: "getReposOwnerRepoGitRefsRef", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs/{ref}",
    validator: validate_GetReposOwnerRepoGitRefsRef_578070, base: "/",
    url: url_GetReposOwnerRepoGitRefsRef_578071, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoGitRefsRef_578091 = ref object of OpenApiRestCall_576564
proc url_PatchReposOwnerRepoGitRefsRef_578093(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoGitRefsRef_578092(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Update a Reference
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   ref: JString (required)
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578094 = path.getOrDefault("repo")
  valid_578094 = validateParameter(valid_578094, JString, required = true,
                                 default = nil)
  if valid_578094 != nil:
    section.add "repo", valid_578094
  var valid_578095 = path.getOrDefault("ref")
  valid_578095 = validateParameter(valid_578095, JString, required = true,
                                 default = nil)
  if valid_578095 != nil:
    section.add "ref", valid_578095
  var valid_578096 = path.getOrDefault("owner")
  valid_578096 = validateParameter(valid_578096, JString, required = true,
                                 default = nil)
  if valid_578096 != nil:
    section.add "owner", valid_578096
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578097 = header.getOrDefault("Accept")
  valid_578097 = validateParameter(valid_578097, JString, required = false,
                                 default = nil)
  if valid_578097 != nil:
    section.add "Accept", valid_578097
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578099: Call_PatchReposOwnerRepoGitRefsRef_578091; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Update a Reference
  ## 
  let valid = call_578099.validator(path, query, header, formData, body)
  let scheme = call_578099.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578099.url(scheme.get, call_578099.host, call_578099.base,
                         call_578099.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578099, url, valid)

proc call*(call_578100: Call_PatchReposOwnerRepoGitRefsRef_578091; repo: string;
          `ref`: string; owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoGitRefsRef
  ## Update a Reference
  ##   repo: string (required)
  ##       : Name of repository.
  ##   ref: string (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578101 = newJObject()
  var header_578102 = newJObject()
  var body_578103 = newJObject()
  add(path_578101, "repo", newJString(repo))
  add(path_578101, "ref", newJString(`ref`))
  add(path_578101, "owner", newJString(owner))
  if body != nil:
    body_578103 = body
  add(header_578102, "Accept", newJString(Accept))
  result = call_578100.call(path_578101, nil, header_578102, nil, body_578103)

var patchReposOwnerRepoGitRefsRef* = Call_PatchReposOwnerRepoGitRefsRef_578091(
    name: "patchReposOwnerRepoGitRefsRef", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs/{ref}",
    validator: validate_PatchReposOwnerRepoGitRefsRef_578092, base: "/",
    url: url_PatchReposOwnerRepoGitRefsRef_578093, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoGitRefsRef_578080 = ref object of OpenApiRestCall_576564
proc url_DeleteReposOwnerRepoGitRefsRef_578082(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoGitRefsRef_578081(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a Reference
  ## Example: Deleting a branch: DELETE /repos/octocat/Hello-World/git/refs/heads/feature-a 
  ## Example: Deleting a tag:        DELETE /repos/octocat/Hello-World/git/refs/tags/v1.0
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   ref: JString (required)
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578083 = path.getOrDefault("repo")
  valid_578083 = validateParameter(valid_578083, JString, required = true,
                                 default = nil)
  if valid_578083 != nil:
    section.add "repo", valid_578083
  var valid_578084 = path.getOrDefault("ref")
  valid_578084 = validateParameter(valid_578084, JString, required = true,
                                 default = nil)
  if valid_578084 != nil:
    section.add "ref", valid_578084
  var valid_578085 = path.getOrDefault("owner")
  valid_578085 = validateParameter(valid_578085, JString, required = true,
                                 default = nil)
  if valid_578085 != nil:
    section.add "owner", valid_578085
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578086 = header.getOrDefault("Accept")
  valid_578086 = validateParameter(valid_578086, JString, required = false,
                                 default = nil)
  if valid_578086 != nil:
    section.add "Accept", valid_578086
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578087: Call_DeleteReposOwnerRepoGitRefsRef_578080; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete a Reference
  ## Example: Deleting a branch: DELETE /repos/octocat/Hello-World/git/refs/heads/feature-a 
  ## Example: Deleting a tag:        DELETE /repos/octocat/Hello-World/git/refs/tags/v1.0
  ## 
  ## 
  let valid = call_578087.validator(path, query, header, formData, body)
  let scheme = call_578087.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578087.url(scheme.get, call_578087.host, call_578087.base,
                         call_578087.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578087, url, valid)

proc call*(call_578088: Call_DeleteReposOwnerRepoGitRefsRef_578080; repo: string;
          `ref`: string; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoGitRefsRef
  ## Delete a Reference
  ## Example: Deleting a branch: DELETE /repos/octocat/Hello-World/git/refs/heads/feature-a 
  ## Example: Deleting a tag:        DELETE /repos/octocat/Hello-World/git/refs/tags/v1.0
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   ref: string (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578089 = newJObject()
  var header_578090 = newJObject()
  add(path_578089, "repo", newJString(repo))
  add(path_578089, "ref", newJString(`ref`))
  add(path_578089, "owner", newJString(owner))
  add(header_578090, "Accept", newJString(Accept))
  result = call_578088.call(path_578089, nil, header_578090, nil, nil)

var deleteReposOwnerRepoGitRefsRef* = Call_DeleteReposOwnerRepoGitRefsRef_578080(
    name: "deleteReposOwnerRepoGitRefsRef", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs/{ref}",
    validator: validate_DeleteReposOwnerRepoGitRefsRef_578081, base: "/",
    url: url_DeleteReposOwnerRepoGitRefsRef_578082, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitTags_578104 = ref object of OpenApiRestCall_576564
proc url_PostReposOwnerRepoGitTags_578106(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/tags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitTags_578105(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a Tag Object.
  ## Note that creating a tag object does not create the reference that makes a
  ## tag in Git. If you want to create an annotated tag in Git, you have to do
  ## this call to create the tag object, and then create the refs/tags/[tag]
  ## reference. If you want to create a lightweight tag, you only have to create
  ## the tag reference - this call would be unnecessary.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578107 = path.getOrDefault("repo")
  valid_578107 = validateParameter(valid_578107, JString, required = true,
                                 default = nil)
  if valid_578107 != nil:
    section.add "repo", valid_578107
  var valid_578108 = path.getOrDefault("owner")
  valid_578108 = validateParameter(valid_578108, JString, required = true,
                                 default = nil)
  if valid_578108 != nil:
    section.add "owner", valid_578108
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578109 = header.getOrDefault("Accept")
  valid_578109 = validateParameter(valid_578109, JString, required = false,
                                 default = nil)
  if valid_578109 != nil:
    section.add "Accept", valid_578109
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578111: Call_PostReposOwnerRepoGitTags_578104; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a Tag Object.
  ## Note that creating a tag object does not create the reference that makes a
  ## tag in Git. If you want to create an annotated tag in Git, you have to do
  ## this call to create the tag object, and then create the refs/tags/[tag]
  ## reference. If you want to create a lightweight tag, you only have to create
  ## the tag reference - this call would be unnecessary.
  ## 
  ## 
  let valid = call_578111.validator(path, query, header, formData, body)
  let scheme = call_578111.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578111.url(scheme.get, call_578111.host, call_578111.base,
                         call_578111.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578111, url, valid)

proc call*(call_578112: Call_PostReposOwnerRepoGitTags_578104; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitTags
  ## Create a Tag Object.
  ## Note that creating a tag object does not create the reference that makes a
  ## tag in Git. If you want to create an annotated tag in Git, you have to do
  ## this call to create the tag object, and then create the refs/tags/[tag]
  ## reference. If you want to create a lightweight tag, you only have to create
  ## the tag reference - this call would be unnecessary.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578113 = newJObject()
  var header_578114 = newJObject()
  var body_578115 = newJObject()
  add(path_578113, "repo", newJString(repo))
  add(path_578113, "owner", newJString(owner))
  if body != nil:
    body_578115 = body
  add(header_578114, "Accept", newJString(Accept))
  result = call_578112.call(path_578113, nil, header_578114, nil, body_578115)

var postReposOwnerRepoGitTags* = Call_PostReposOwnerRepoGitTags_578104(
    name: "postReposOwnerRepoGitTags", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/tags",
    validator: validate_PostReposOwnerRepoGitTags_578105, base: "/",
    url: url_PostReposOwnerRepoGitTags_578106, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitTagsShaCode_578116 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoGitTagsShaCode_578118(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/tags/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitTagsShaCode_578117(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a Tag.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   shaCode: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578119 = path.getOrDefault("repo")
  valid_578119 = validateParameter(valid_578119, JString, required = true,
                                 default = nil)
  if valid_578119 != nil:
    section.add "repo", valid_578119
  var valid_578120 = path.getOrDefault("owner")
  valid_578120 = validateParameter(valid_578120, JString, required = true,
                                 default = nil)
  if valid_578120 != nil:
    section.add "owner", valid_578120
  var valid_578121 = path.getOrDefault("shaCode")
  valid_578121 = validateParameter(valid_578121, JString, required = true,
                                 default = nil)
  if valid_578121 != nil:
    section.add "shaCode", valid_578121
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578122 = header.getOrDefault("Accept")
  valid_578122 = validateParameter(valid_578122, JString, required = false,
                                 default = nil)
  if valid_578122 != nil:
    section.add "Accept", valid_578122
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578123: Call_GetReposOwnerRepoGitTagsShaCode_578116;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a Tag.
  ## 
  let valid = call_578123.validator(path, query, header, formData, body)
  let scheme = call_578123.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578123.url(scheme.get, call_578123.host, call_578123.base,
                         call_578123.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578123, url, valid)

proc call*(call_578124: Call_GetReposOwnerRepoGitTagsShaCode_578116; repo: string;
          owner: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitTagsShaCode
  ## Get a Tag.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   shaCode: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578125 = newJObject()
  var header_578126 = newJObject()
  add(path_578125, "repo", newJString(repo))
  add(path_578125, "owner", newJString(owner))
  add(path_578125, "shaCode", newJString(shaCode))
  add(header_578126, "Accept", newJString(Accept))
  result = call_578124.call(path_578125, nil, header_578126, nil, nil)

var getReposOwnerRepoGitTagsShaCode* = Call_GetReposOwnerRepoGitTagsShaCode_578116(
    name: "getReposOwnerRepoGitTagsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/tags/{shaCode}",
    validator: validate_GetReposOwnerRepoGitTagsShaCode_578117, base: "/",
    url: url_GetReposOwnerRepoGitTagsShaCode_578118, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitTrees_578127 = ref object of OpenApiRestCall_576564
proc url_PostReposOwnerRepoGitTrees_578129(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/trees")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitTrees_578128(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a Tree.
  ## The tree creation API will take nested entries as well. If both a tree and
  ## a nested path modifying that tree are specified, it will overwrite the
  ## contents of that tree with the new path contents and write a new tree out.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578130 = path.getOrDefault("repo")
  valid_578130 = validateParameter(valid_578130, JString, required = true,
                                 default = nil)
  if valid_578130 != nil:
    section.add "repo", valid_578130
  var valid_578131 = path.getOrDefault("owner")
  valid_578131 = validateParameter(valid_578131, JString, required = true,
                                 default = nil)
  if valid_578131 != nil:
    section.add "owner", valid_578131
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578132 = header.getOrDefault("Accept")
  valid_578132 = validateParameter(valid_578132, JString, required = false,
                                 default = nil)
  if valid_578132 != nil:
    section.add "Accept", valid_578132
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578134: Call_PostReposOwnerRepoGitTrees_578127; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a Tree.
  ## The tree creation API will take nested entries as well. If both a tree and
  ## a nested path modifying that tree are specified, it will overwrite the
  ## contents of that tree with the new path contents and write a new tree out.
  ## 
  ## 
  let valid = call_578134.validator(path, query, header, formData, body)
  let scheme = call_578134.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578134.url(scheme.get, call_578134.host, call_578134.base,
                         call_578134.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578134, url, valid)

proc call*(call_578135: Call_PostReposOwnerRepoGitTrees_578127; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitTrees
  ## Create a Tree.
  ## The tree creation API will take nested entries as well. If both a tree and
  ## a nested path modifying that tree are specified, it will overwrite the
  ## contents of that tree with the new path contents and write a new tree out.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578136 = newJObject()
  var header_578137 = newJObject()
  var body_578138 = newJObject()
  add(path_578136, "repo", newJString(repo))
  add(path_578136, "owner", newJString(owner))
  if body != nil:
    body_578138 = body
  add(header_578137, "Accept", newJString(Accept))
  result = call_578135.call(path_578136, nil, header_578137, nil, body_578138)

var postReposOwnerRepoGitTrees* = Call_PostReposOwnerRepoGitTrees_578127(
    name: "postReposOwnerRepoGitTrees", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/trees",
    validator: validate_PostReposOwnerRepoGitTrees_578128, base: "/",
    url: url_PostReposOwnerRepoGitTrees_578129, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitTreesShaCode_578139 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoGitTreesShaCode_578141(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/trees/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitTreesShaCode_578140(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a Tree.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   shaCode: JString (required)
  ##          : Tree SHA.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578142 = path.getOrDefault("repo")
  valid_578142 = validateParameter(valid_578142, JString, required = true,
                                 default = nil)
  if valid_578142 != nil:
    section.add "repo", valid_578142
  var valid_578143 = path.getOrDefault("owner")
  valid_578143 = validateParameter(valid_578143, JString, required = true,
                                 default = nil)
  if valid_578143 != nil:
    section.add "owner", valid_578143
  var valid_578144 = path.getOrDefault("shaCode")
  valid_578144 = validateParameter(valid_578144, JString, required = true,
                                 default = nil)
  if valid_578144 != nil:
    section.add "shaCode", valid_578144
  result.add "path", section
  ## parameters in `query` object:
  ##   recursive: JInt
  ##            : Get a Tree Recursively. (0 or 1)
  section = newJObject()
  var valid_578145 = query.getOrDefault("recursive")
  valid_578145 = validateParameter(valid_578145, JInt, required = false, default = nil)
  if valid_578145 != nil:
    section.add "recursive", valid_578145
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578146 = header.getOrDefault("Accept")
  valid_578146 = validateParameter(valid_578146, JString, required = false,
                                 default = nil)
  if valid_578146 != nil:
    section.add "Accept", valid_578146
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578147: Call_GetReposOwnerRepoGitTreesShaCode_578139;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a Tree.
  ## 
  let valid = call_578147.validator(path, query, header, formData, body)
  let scheme = call_578147.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578147.url(scheme.get, call_578147.host, call_578147.base,
                         call_578147.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578147, url, valid)

proc call*(call_578148: Call_GetReposOwnerRepoGitTreesShaCode_578139; repo: string;
          owner: string; shaCode: string; recursive: int = 0; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitTreesShaCode
  ## Get a Tree.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   recursive: int
  ##            : Get a Tree Recursively. (0 or 1)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   shaCode: string (required)
  ##          : Tree SHA.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578149 = newJObject()
  var query_578150 = newJObject()
  var header_578151 = newJObject()
  add(path_578149, "repo", newJString(repo))
  add(query_578150, "recursive", newJInt(recursive))
  add(path_578149, "owner", newJString(owner))
  add(path_578149, "shaCode", newJString(shaCode))
  add(header_578151, "Accept", newJString(Accept))
  result = call_578148.call(path_578149, query_578150, header_578151, nil, nil)

var getReposOwnerRepoGitTreesShaCode* = Call_GetReposOwnerRepoGitTreesShaCode_578139(
    name: "getReposOwnerRepoGitTreesShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/trees/{shaCode}",
    validator: validate_GetReposOwnerRepoGitTreesShaCode_578140, base: "/",
    url: url_GetReposOwnerRepoGitTreesShaCode_578141, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoHooks_578162 = ref object of OpenApiRestCall_576564
proc url_PostReposOwnerRepoHooks_578164(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoHooks_578163(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578165 = path.getOrDefault("repo")
  valid_578165 = validateParameter(valid_578165, JString, required = true,
                                 default = nil)
  if valid_578165 != nil:
    section.add "repo", valid_578165
  var valid_578166 = path.getOrDefault("owner")
  valid_578166 = validateParameter(valid_578166, JString, required = true,
                                 default = nil)
  if valid_578166 != nil:
    section.add "owner", valid_578166
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578167 = header.getOrDefault("Accept")
  valid_578167 = validateParameter(valid_578167, JString, required = false,
                                 default = nil)
  if valid_578167 != nil:
    section.add "Accept", valid_578167
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578169: Call_PostReposOwnerRepoHooks_578162; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a hook.
  ## 
  let valid = call_578169.validator(path, query, header, formData, body)
  let scheme = call_578169.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578169.url(scheme.get, call_578169.host, call_578169.base,
                         call_578169.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578169, url, valid)

proc call*(call_578170: Call_PostReposOwnerRepoHooks_578162; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoHooks
  ## Create a hook.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578171 = newJObject()
  var header_578172 = newJObject()
  var body_578173 = newJObject()
  add(path_578171, "repo", newJString(repo))
  add(path_578171, "owner", newJString(owner))
  if body != nil:
    body_578173 = body
  add(header_578172, "Accept", newJString(Accept))
  result = call_578170.call(path_578171, nil, header_578172, nil, body_578173)

var postReposOwnerRepoHooks* = Call_PostReposOwnerRepoHooks_578162(
    name: "postReposOwnerRepoHooks", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks",
    validator: validate_PostReposOwnerRepoHooks_578163, base: "/",
    url: url_PostReposOwnerRepoHooks_578164, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoHooks_578152 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoHooks_578154(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoHooks_578153(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get list of hooks.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578155 = path.getOrDefault("repo")
  valid_578155 = validateParameter(valid_578155, JString, required = true,
                                 default = nil)
  if valid_578155 != nil:
    section.add "repo", valid_578155
  var valid_578156 = path.getOrDefault("owner")
  valid_578156 = validateParameter(valid_578156, JString, required = true,
                                 default = nil)
  if valid_578156 != nil:
    section.add "owner", valid_578156
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578157 = header.getOrDefault("Accept")
  valid_578157 = validateParameter(valid_578157, JString, required = false,
                                 default = nil)
  if valid_578157 != nil:
    section.add "Accept", valid_578157
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578158: Call_GetReposOwnerRepoHooks_578152; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get list of hooks.
  ## 
  let valid = call_578158.validator(path, query, header, formData, body)
  let scheme = call_578158.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578158.url(scheme.get, call_578158.host, call_578158.base,
                         call_578158.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578158, url, valid)

proc call*(call_578159: Call_GetReposOwnerRepoHooks_578152; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoHooks
  ## Get list of hooks.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578160 = newJObject()
  var header_578161 = newJObject()
  add(path_578160, "repo", newJString(repo))
  add(path_578160, "owner", newJString(owner))
  add(header_578161, "Accept", newJString(Accept))
  result = call_578159.call(path_578160, nil, header_578161, nil, nil)

var getReposOwnerRepoHooks* = Call_GetReposOwnerRepoHooks_578152(
    name: "getReposOwnerRepoHooks", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks",
    validator: validate_GetReposOwnerRepoHooks_578153, base: "/",
    url: url_GetReposOwnerRepoHooks_578154, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoHooksHookId_578174 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoHooksHookId_578176(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hookId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoHooksHookId_578175(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get single hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   hookId: JInt (required)
  ##         : Id of hook.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578177 = path.getOrDefault("repo")
  valid_578177 = validateParameter(valid_578177, JString, required = true,
                                 default = nil)
  if valid_578177 != nil:
    section.add "repo", valid_578177
  var valid_578178 = path.getOrDefault("owner")
  valid_578178 = validateParameter(valid_578178, JString, required = true,
                                 default = nil)
  if valid_578178 != nil:
    section.add "owner", valid_578178
  var valid_578179 = path.getOrDefault("hookId")
  valid_578179 = validateParameter(valid_578179, JInt, required = true, default = nil)
  if valid_578179 != nil:
    section.add "hookId", valid_578179
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578180 = header.getOrDefault("Accept")
  valid_578180 = validateParameter(valid_578180, JString, required = false,
                                 default = nil)
  if valid_578180 != nil:
    section.add "Accept", valid_578180
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578181: Call_GetReposOwnerRepoHooksHookId_578174; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get single hook.
  ## 
  let valid = call_578181.validator(path, query, header, formData, body)
  let scheme = call_578181.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578181.url(scheme.get, call_578181.host, call_578181.base,
                         call_578181.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578181, url, valid)

proc call*(call_578182: Call_GetReposOwnerRepoHooksHookId_578174; repo: string;
          owner: string; hookId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoHooksHookId
  ## Get single hook.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   hookId: int (required)
  ##         : Id of hook.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578183 = newJObject()
  var header_578184 = newJObject()
  add(path_578183, "repo", newJString(repo))
  add(path_578183, "owner", newJString(owner))
  add(path_578183, "hookId", newJInt(hookId))
  add(header_578184, "Accept", newJString(Accept))
  result = call_578182.call(path_578183, nil, header_578184, nil, nil)

var getReposOwnerRepoHooksHookId* = Call_GetReposOwnerRepoHooksHookId_578174(
    name: "getReposOwnerRepoHooksHookId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}",
    validator: validate_GetReposOwnerRepoHooksHookId_578175, base: "/",
    url: url_GetReposOwnerRepoHooksHookId_578176, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoHooksHookId_578196 = ref object of OpenApiRestCall_576564
proc url_PatchReposOwnerRepoHooksHookId_578198(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hookId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoHooksHookId_578197(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Edit a hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   hookId: JInt (required)
  ##         : Id of hook.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578199 = path.getOrDefault("repo")
  valid_578199 = validateParameter(valid_578199, JString, required = true,
                                 default = nil)
  if valid_578199 != nil:
    section.add "repo", valid_578199
  var valid_578200 = path.getOrDefault("owner")
  valid_578200 = validateParameter(valid_578200, JString, required = true,
                                 default = nil)
  if valid_578200 != nil:
    section.add "owner", valid_578200
  var valid_578201 = path.getOrDefault("hookId")
  valid_578201 = validateParameter(valid_578201, JInt, required = true, default = nil)
  if valid_578201 != nil:
    section.add "hookId", valid_578201
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578202 = header.getOrDefault("Accept")
  valid_578202 = validateParameter(valid_578202, JString, required = false,
                                 default = nil)
  if valid_578202 != nil:
    section.add "Accept", valid_578202
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578204: Call_PatchReposOwnerRepoHooksHookId_578196; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Edit a hook.
  ## 
  let valid = call_578204.validator(path, query, header, formData, body)
  let scheme = call_578204.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578204.url(scheme.get, call_578204.host, call_578204.base,
                         call_578204.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578204, url, valid)

proc call*(call_578205: Call_PatchReposOwnerRepoHooksHookId_578196; repo: string;
          owner: string; body: JsonNode; hookId: int; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoHooksHookId
  ## Edit a hook.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   hookId: int (required)
  ##         : Id of hook.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578206 = newJObject()
  var header_578207 = newJObject()
  var body_578208 = newJObject()
  add(path_578206, "repo", newJString(repo))
  add(path_578206, "owner", newJString(owner))
  if body != nil:
    body_578208 = body
  add(path_578206, "hookId", newJInt(hookId))
  add(header_578207, "Accept", newJString(Accept))
  result = call_578205.call(path_578206, nil, header_578207, nil, body_578208)

var patchReposOwnerRepoHooksHookId* = Call_PatchReposOwnerRepoHooksHookId_578196(
    name: "patchReposOwnerRepoHooksHookId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}",
    validator: validate_PatchReposOwnerRepoHooksHookId_578197, base: "/",
    url: url_PatchReposOwnerRepoHooksHookId_578198, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoHooksHookId_578185 = ref object of OpenApiRestCall_576564
proc url_DeleteReposOwnerRepoHooksHookId_578187(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hookId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoHooksHookId_578186(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   hookId: JInt (required)
  ##         : Id of hook.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578188 = path.getOrDefault("repo")
  valid_578188 = validateParameter(valid_578188, JString, required = true,
                                 default = nil)
  if valid_578188 != nil:
    section.add "repo", valid_578188
  var valid_578189 = path.getOrDefault("owner")
  valid_578189 = validateParameter(valid_578189, JString, required = true,
                                 default = nil)
  if valid_578189 != nil:
    section.add "owner", valid_578189
  var valid_578190 = path.getOrDefault("hookId")
  valid_578190 = validateParameter(valid_578190, JInt, required = true, default = nil)
  if valid_578190 != nil:
    section.add "hookId", valid_578190
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578191 = header.getOrDefault("Accept")
  valid_578191 = validateParameter(valid_578191, JString, required = false,
                                 default = nil)
  if valid_578191 != nil:
    section.add "Accept", valid_578191
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578192: Call_DeleteReposOwnerRepoHooksHookId_578185;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a hook.
  ## 
  let valid = call_578192.validator(path, query, header, formData, body)
  let scheme = call_578192.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578192.url(scheme.get, call_578192.host, call_578192.base,
                         call_578192.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578192, url, valid)

proc call*(call_578193: Call_DeleteReposOwnerRepoHooksHookId_578185; repo: string;
          owner: string; hookId: int; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoHooksHookId
  ## Delete a hook.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   hookId: int (required)
  ##         : Id of hook.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578194 = newJObject()
  var header_578195 = newJObject()
  add(path_578194, "repo", newJString(repo))
  add(path_578194, "owner", newJString(owner))
  add(path_578194, "hookId", newJInt(hookId))
  add(header_578195, "Accept", newJString(Accept))
  result = call_578193.call(path_578194, nil, header_578195, nil, nil)

var deleteReposOwnerRepoHooksHookId* = Call_DeleteReposOwnerRepoHooksHookId_578185(
    name: "deleteReposOwnerRepoHooksHookId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}",
    validator: validate_DeleteReposOwnerRepoHooksHookId_578186, base: "/",
    url: url_DeleteReposOwnerRepoHooksHookId_578187, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoHooksHookIdTests_578209 = ref object of OpenApiRestCall_576564
proc url_PostReposOwnerRepoHooksHookIdTests_578211(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hookId"),
               (kind: ConstantSegment, value: "/tests")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoHooksHookIdTests_578210(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Test a push hook.
  ## This will trigger the hook with the latest push to the current repository
  ## if the hook is subscribed to push events. If the hook is not subscribed
  ## to push events, the server will respond with 204 but no test POST will
  ## be generated.
  ## Note: Previously /repos/:owner/:repo/hooks/:id/tes
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   hookId: JInt (required)
  ##         : Id of hook.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578212 = path.getOrDefault("repo")
  valid_578212 = validateParameter(valid_578212, JString, required = true,
                                 default = nil)
  if valid_578212 != nil:
    section.add "repo", valid_578212
  var valid_578213 = path.getOrDefault("owner")
  valid_578213 = validateParameter(valid_578213, JString, required = true,
                                 default = nil)
  if valid_578213 != nil:
    section.add "owner", valid_578213
  var valid_578214 = path.getOrDefault("hookId")
  valid_578214 = validateParameter(valid_578214, JInt, required = true, default = nil)
  if valid_578214 != nil:
    section.add "hookId", valid_578214
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578215 = header.getOrDefault("Accept")
  valid_578215 = validateParameter(valid_578215, JString, required = false,
                                 default = nil)
  if valid_578215 != nil:
    section.add "Accept", valid_578215
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578216: Call_PostReposOwnerRepoHooksHookIdTests_578209;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Test a push hook.
  ## This will trigger the hook with the latest push to the current repository
  ## if the hook is subscribed to push events. If the hook is not subscribed
  ## to push events, the server will respond with 204 but no test POST will
  ## be generated.
  ## Note: Previously /repos/:owner/:repo/hooks/:id/tes
  ## 
  ## 
  let valid = call_578216.validator(path, query, header, formData, body)
  let scheme = call_578216.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578216.url(scheme.get, call_578216.host, call_578216.base,
                         call_578216.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578216, url, valid)

proc call*(call_578217: Call_PostReposOwnerRepoHooksHookIdTests_578209;
          repo: string; owner: string; hookId: int; Accept: string = ""): Recallable =
  ## postReposOwnerRepoHooksHookIdTests
  ## Test a push hook.
  ## This will trigger the hook with the latest push to the current repository
  ## if the hook is subscribed to push events. If the hook is not subscribed
  ## to push events, the server will respond with 204 but no test POST will
  ## be generated.
  ## Note: Previously /repos/:owner/:repo/hooks/:id/tes
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   hookId: int (required)
  ##         : Id of hook.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578218 = newJObject()
  var header_578219 = newJObject()
  add(path_578218, "repo", newJString(repo))
  add(path_578218, "owner", newJString(owner))
  add(path_578218, "hookId", newJInt(hookId))
  add(header_578219, "Accept", newJString(Accept))
  result = call_578217.call(path_578218, nil, header_578219, nil, nil)

var postReposOwnerRepoHooksHookIdTests* = Call_PostReposOwnerRepoHooksHookIdTests_578209(
    name: "postReposOwnerRepoHooksHookIdTests", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}/tests",
    validator: validate_PostReposOwnerRepoHooksHookIdTests_578210, base: "/",
    url: url_PostReposOwnerRepoHooksHookIdTests_578211, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoIssues_578237 = ref object of OpenApiRestCall_576564
proc url_PostReposOwnerRepoIssues_578239(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoIssues_578238(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create an issue.
  ## Any user with pull access to a repository can create an issue.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578240 = path.getOrDefault("repo")
  valid_578240 = validateParameter(valid_578240, JString, required = true,
                                 default = nil)
  if valid_578240 != nil:
    section.add "repo", valid_578240
  var valid_578241 = path.getOrDefault("owner")
  valid_578241 = validateParameter(valid_578241, JString, required = true,
                                 default = nil)
  if valid_578241 != nil:
    section.add "owner", valid_578241
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578242 = header.getOrDefault("Accept")
  valid_578242 = validateParameter(valid_578242, JString, required = false,
                                 default = nil)
  if valid_578242 != nil:
    section.add "Accept", valid_578242
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578244: Call_PostReposOwnerRepoIssues_578237; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create an issue.
  ## Any user with pull access to a repository can create an issue.
  ## 
  ## 
  let valid = call_578244.validator(path, query, header, formData, body)
  let scheme = call_578244.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578244.url(scheme.get, call_578244.host, call_578244.base,
                         call_578244.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578244, url, valid)

proc call*(call_578245: Call_PostReposOwnerRepoIssues_578237; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoIssues
  ## Create an issue.
  ## Any user with pull access to a repository can create an issue.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578246 = newJObject()
  var header_578247 = newJObject()
  var body_578248 = newJObject()
  add(path_578246, "repo", newJString(repo))
  add(path_578246, "owner", newJString(owner))
  if body != nil:
    body_578248 = body
  add(header_578247, "Accept", newJString(Accept))
  result = call_578245.call(path_578246, nil, header_578247, nil, body_578248)

var postReposOwnerRepoIssues* = Call_PostReposOwnerRepoIssues_578237(
    name: "postReposOwnerRepoIssues", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues",
    validator: validate_PostReposOwnerRepoIssues_578238, base: "/",
    url: url_PostReposOwnerRepoIssues_578239, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssues_578220 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoIssues_578222(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssues_578221(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List issues for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578223 = path.getOrDefault("repo")
  valid_578223 = validateParameter(valid_578223, JString, required = true,
                                 default = nil)
  if valid_578223 != nil:
    section.add "repo", valid_578223
  var valid_578224 = path.getOrDefault("owner")
  valid_578224 = validateParameter(valid_578224, JString, required = true,
                                 default = nil)
  if valid_578224 != nil:
    section.add "owner", valid_578224
  result.add "path", section
  ## parameters in `query` object:
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   direction: JString (required)
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  ##   state: JString (required)
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   sort: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `labels` field"
  var valid_578225 = query.getOrDefault("labels")
  valid_578225 = validateParameter(valid_578225, JString, required = true,
                                 default = nil)
  if valid_578225 != nil:
    section.add "labels", valid_578225
  var valid_578226 = query.getOrDefault("direction")
  valid_578226 = validateParameter(valid_578226, JString, required = true,
                                 default = newJString("desc"))
  if valid_578226 != nil:
    section.add "direction", valid_578226
  var valid_578227 = query.getOrDefault("since")
  valid_578227 = validateParameter(valid_578227, JString, required = false,
                                 default = nil)
  if valid_578227 != nil:
    section.add "since", valid_578227
  var valid_578228 = query.getOrDefault("state")
  valid_578228 = validateParameter(valid_578228, JString, required = true,
                                 default = newJString("open"))
  if valid_578228 != nil:
    section.add "state", valid_578228
  var valid_578229 = query.getOrDefault("filter")
  valid_578229 = validateParameter(valid_578229, JString, required = true,
                                 default = newJString("all"))
  if valid_578229 != nil:
    section.add "filter", valid_578229
  var valid_578230 = query.getOrDefault("sort")
  valid_578230 = validateParameter(valid_578230, JString, required = true,
                                 default = newJString("created"))
  if valid_578230 != nil:
    section.add "sort", valid_578230
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578231 = header.getOrDefault("Accept")
  valid_578231 = validateParameter(valid_578231, JString, required = false,
                                 default = nil)
  if valid_578231 != nil:
    section.add "Accept", valid_578231
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578232: Call_GetReposOwnerRepoIssues_578220; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List issues for a repository.
  ## 
  let valid = call_578232.validator(path, query, header, formData, body)
  let scheme = call_578232.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578232.url(scheme.get, call_578232.host, call_578232.base,
                         call_578232.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578232, url, valid)

proc call*(call_578233: Call_GetReposOwnerRepoIssues_578220; labels: string;
          repo: string; owner: string; direction: string = "desc"; since: string = "";
          state: string = "open"; filter: string = "all"; Accept: string = "";
          sort: string = "created"): Recallable =
  ## getReposOwnerRepoIssues
  ## List issues for a repository.
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   direction: string (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  ##   state: string (required)
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string (required)
  var path_578234 = newJObject()
  var query_578235 = newJObject()
  var header_578236 = newJObject()
  add(query_578235, "labels", newJString(labels))
  add(query_578235, "direction", newJString(direction))
  add(path_578234, "repo", newJString(repo))
  add(query_578235, "since", newJString(since))
  add(query_578235, "state", newJString(state))
  add(query_578235, "filter", newJString(filter))
  add(path_578234, "owner", newJString(owner))
  add(header_578236, "Accept", newJString(Accept))
  add(query_578235, "sort", newJString(sort))
  result = call_578233.call(path_578234, query_578235, header_578236, nil, nil)

var getReposOwnerRepoIssues* = Call_GetReposOwnerRepoIssues_578220(
    name: "getReposOwnerRepoIssues", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues",
    validator: validate_GetReposOwnerRepoIssues_578221, base: "/",
    url: url_GetReposOwnerRepoIssues_578222, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesComments_578249 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoIssuesComments_578251(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesComments_578250(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List comments in a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578252 = path.getOrDefault("repo")
  valid_578252 = validateParameter(valid_578252, JString, required = true,
                                 default = nil)
  if valid_578252 != nil:
    section.add "repo", valid_578252
  var valid_578253 = path.getOrDefault("owner")
  valid_578253 = validateParameter(valid_578253, JString, required = true,
                                 default = nil)
  if valid_578253 != nil:
    section.add "owner", valid_578253
  result.add "path", section
  ## parameters in `query` object:
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   sort: JString
  section = newJObject()
  var valid_578254 = query.getOrDefault("direction")
  valid_578254 = validateParameter(valid_578254, JString, required = false,
                                 default = nil)
  if valid_578254 != nil:
    section.add "direction", valid_578254
  var valid_578255 = query.getOrDefault("since")
  valid_578255 = validateParameter(valid_578255, JString, required = false,
                                 default = nil)
  if valid_578255 != nil:
    section.add "since", valid_578255
  var valid_578256 = query.getOrDefault("sort")
  valid_578256 = validateParameter(valid_578256, JString, required = false,
                                 default = newJString("created"))
  if valid_578256 != nil:
    section.add "sort", valid_578256
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578257 = header.getOrDefault("Accept")
  valid_578257 = validateParameter(valid_578257, JString, required = false,
                                 default = nil)
  if valid_578257 != nil:
    section.add "Accept", valid_578257
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578258: Call_GetReposOwnerRepoIssuesComments_578249;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List comments in a repository.
  ## 
  let valid = call_578258.validator(path, query, header, formData, body)
  let scheme = call_578258.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578258.url(scheme.get, call_578258.host, call_578258.base,
                         call_578258.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578258, url, valid)

proc call*(call_578259: Call_GetReposOwnerRepoIssuesComments_578249; repo: string;
          owner: string; direction: string = ""; since: string = ""; Accept: string = "";
          sort: string = "created"): Recallable =
  ## getReposOwnerRepoIssuesComments
  ## List comments in a repository.
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  var path_578260 = newJObject()
  var query_578261 = newJObject()
  var header_578262 = newJObject()
  add(query_578261, "direction", newJString(direction))
  add(path_578260, "repo", newJString(repo))
  add(query_578261, "since", newJString(since))
  add(path_578260, "owner", newJString(owner))
  add(header_578262, "Accept", newJString(Accept))
  add(query_578261, "sort", newJString(sort))
  result = call_578259.call(path_578260, query_578261, header_578262, nil, nil)

var getReposOwnerRepoIssuesComments* = Call_GetReposOwnerRepoIssuesComments_578249(
    name: "getReposOwnerRepoIssuesComments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/comments",
    validator: validate_GetReposOwnerRepoIssuesComments_578250, base: "/",
    url: url_GetReposOwnerRepoIssuesComments_578251, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesCommentsCommentId_578263 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoIssuesCommentsCommentId_578265(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesCommentsCommentId_578264(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : ID of comment.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578266 = path.getOrDefault("repo")
  valid_578266 = validateParameter(valid_578266, JString, required = true,
                                 default = nil)
  if valid_578266 != nil:
    section.add "repo", valid_578266
  var valid_578267 = path.getOrDefault("commentId")
  valid_578267 = validateParameter(valid_578267, JInt, required = true, default = nil)
  if valid_578267 != nil:
    section.add "commentId", valid_578267
  var valid_578268 = path.getOrDefault("owner")
  valid_578268 = validateParameter(valid_578268, JString, required = true,
                                 default = nil)
  if valid_578268 != nil:
    section.add "owner", valid_578268
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578269 = header.getOrDefault("Accept")
  valid_578269 = validateParameter(valid_578269, JString, required = false,
                                 default = nil)
  if valid_578269 != nil:
    section.add "Accept", valid_578269
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578270: Call_GetReposOwnerRepoIssuesCommentsCommentId_578263;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single comment.
  ## 
  let valid = call_578270.validator(path, query, header, formData, body)
  let scheme = call_578270.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578270.url(scheme.get, call_578270.host, call_578270.base,
                         call_578270.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578270, url, valid)

proc call*(call_578271: Call_GetReposOwnerRepoIssuesCommentsCommentId_578263;
          repo: string; commentId: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesCommentsCommentId
  ## Get a single comment.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : ID of comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578272 = newJObject()
  var header_578273 = newJObject()
  add(path_578272, "repo", newJString(repo))
  add(path_578272, "commentId", newJInt(commentId))
  add(path_578272, "owner", newJString(owner))
  add(header_578273, "Accept", newJString(Accept))
  result = call_578271.call(path_578272, nil, header_578273, nil, nil)

var getReposOwnerRepoIssuesCommentsCommentId* = Call_GetReposOwnerRepoIssuesCommentsCommentId_578263(
    name: "getReposOwnerRepoIssuesCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/comments/{commentId}",
    validator: validate_GetReposOwnerRepoIssuesCommentsCommentId_578264,
    base: "/", url: url_GetReposOwnerRepoIssuesCommentsCommentId_578265,
    schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoIssuesCommentsCommentId_578285 = ref object of OpenApiRestCall_576564
proc url_PatchReposOwnerRepoIssuesCommentsCommentId_578287(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoIssuesCommentsCommentId_578286(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Edit a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : ID of comment.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578288 = path.getOrDefault("repo")
  valid_578288 = validateParameter(valid_578288, JString, required = true,
                                 default = nil)
  if valid_578288 != nil:
    section.add "repo", valid_578288
  var valid_578289 = path.getOrDefault("commentId")
  valid_578289 = validateParameter(valid_578289, JInt, required = true, default = nil)
  if valid_578289 != nil:
    section.add "commentId", valid_578289
  var valid_578290 = path.getOrDefault("owner")
  valid_578290 = validateParameter(valid_578290, JString, required = true,
                                 default = nil)
  if valid_578290 != nil:
    section.add "owner", valid_578290
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578291 = header.getOrDefault("Accept")
  valid_578291 = validateParameter(valid_578291, JString, required = false,
                                 default = nil)
  if valid_578291 != nil:
    section.add "Accept", valid_578291
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578293: Call_PatchReposOwnerRepoIssuesCommentsCommentId_578285;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Edit a comment.
  ## 
  let valid = call_578293.validator(path, query, header, formData, body)
  let scheme = call_578293.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578293.url(scheme.get, call_578293.host, call_578293.base,
                         call_578293.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578293, url, valid)

proc call*(call_578294: Call_PatchReposOwnerRepoIssuesCommentsCommentId_578285;
          repo: string; commentId: int; owner: string; body: JsonNode;
          Accept: string = ""): Recallable =
  ## patchReposOwnerRepoIssuesCommentsCommentId
  ## Edit a comment.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : ID of comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578295 = newJObject()
  var header_578296 = newJObject()
  var body_578297 = newJObject()
  add(path_578295, "repo", newJString(repo))
  add(path_578295, "commentId", newJInt(commentId))
  add(path_578295, "owner", newJString(owner))
  if body != nil:
    body_578297 = body
  add(header_578296, "Accept", newJString(Accept))
  result = call_578294.call(path_578295, nil, header_578296, nil, body_578297)

var patchReposOwnerRepoIssuesCommentsCommentId* = Call_PatchReposOwnerRepoIssuesCommentsCommentId_578285(
    name: "patchReposOwnerRepoIssuesCommentsCommentId",
    meth: HttpMethod.HttpPatch, host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/comments/{commentId}",
    validator: validate_PatchReposOwnerRepoIssuesCommentsCommentId_578286,
    base: "/", url: url_PatchReposOwnerRepoIssuesCommentsCommentId_578287,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoIssuesCommentsCommentId_578274 = ref object of OpenApiRestCall_576564
proc url_DeleteReposOwnerRepoIssuesCommentsCommentId_578276(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoIssuesCommentsCommentId_578275(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : ID of comment.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578277 = path.getOrDefault("repo")
  valid_578277 = validateParameter(valid_578277, JString, required = true,
                                 default = nil)
  if valid_578277 != nil:
    section.add "repo", valid_578277
  var valid_578278 = path.getOrDefault("commentId")
  valid_578278 = validateParameter(valid_578278, JInt, required = true, default = nil)
  if valid_578278 != nil:
    section.add "commentId", valid_578278
  var valid_578279 = path.getOrDefault("owner")
  valid_578279 = validateParameter(valid_578279, JString, required = true,
                                 default = nil)
  if valid_578279 != nil:
    section.add "owner", valid_578279
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578280 = header.getOrDefault("Accept")
  valid_578280 = validateParameter(valid_578280, JString, required = false,
                                 default = nil)
  if valid_578280 != nil:
    section.add "Accept", valid_578280
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578281: Call_DeleteReposOwnerRepoIssuesCommentsCommentId_578274;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a comment.
  ## 
  let valid = call_578281.validator(path, query, header, formData, body)
  let scheme = call_578281.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578281.url(scheme.get, call_578281.host, call_578281.base,
                         call_578281.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578281, url, valid)

proc call*(call_578282: Call_DeleteReposOwnerRepoIssuesCommentsCommentId_578274;
          repo: string; commentId: int; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoIssuesCommentsCommentId
  ## Delete a comment.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : ID of comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578283 = newJObject()
  var header_578284 = newJObject()
  add(path_578283, "repo", newJString(repo))
  add(path_578283, "commentId", newJInt(commentId))
  add(path_578283, "owner", newJString(owner))
  add(header_578284, "Accept", newJString(Accept))
  result = call_578282.call(path_578283, nil, header_578284, nil, nil)

var deleteReposOwnerRepoIssuesCommentsCommentId* = Call_DeleteReposOwnerRepoIssuesCommentsCommentId_578274(
    name: "deleteReposOwnerRepoIssuesCommentsCommentId",
    meth: HttpMethod.HttpDelete, host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/comments/{commentId}",
    validator: validate_DeleteReposOwnerRepoIssuesCommentsCommentId_578275,
    base: "/", url: url_DeleteReposOwnerRepoIssuesCommentsCommentId_578276,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesEvents_578298 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoIssuesEvents_578300(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesEvents_578299(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List issue events for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578301 = path.getOrDefault("repo")
  valid_578301 = validateParameter(valid_578301, JString, required = true,
                                 default = nil)
  if valid_578301 != nil:
    section.add "repo", valid_578301
  var valid_578302 = path.getOrDefault("owner")
  valid_578302 = validateParameter(valid_578302, JString, required = true,
                                 default = nil)
  if valid_578302 != nil:
    section.add "owner", valid_578302
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578303 = header.getOrDefault("Accept")
  valid_578303 = validateParameter(valid_578303, JString, required = false,
                                 default = nil)
  if valid_578303 != nil:
    section.add "Accept", valid_578303
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578304: Call_GetReposOwnerRepoIssuesEvents_578298; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List issue events for a repository.
  ## 
  let valid = call_578304.validator(path, query, header, formData, body)
  let scheme = call_578304.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578304.url(scheme.get, call_578304.host, call_578304.base,
                         call_578304.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578304, url, valid)

proc call*(call_578305: Call_GetReposOwnerRepoIssuesEvents_578298; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesEvents
  ## List issue events for a repository.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578306 = newJObject()
  var header_578307 = newJObject()
  add(path_578306, "repo", newJString(repo))
  add(path_578306, "owner", newJString(owner))
  add(header_578307, "Accept", newJString(Accept))
  result = call_578305.call(path_578306, nil, header_578307, nil, nil)

var getReposOwnerRepoIssuesEvents* = Call_GetReposOwnerRepoIssuesEvents_578298(
    name: "getReposOwnerRepoIssuesEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/events",
    validator: validate_GetReposOwnerRepoIssuesEvents_578299, base: "/",
    url: url_GetReposOwnerRepoIssuesEvents_578300, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesEventsEventId_578308 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoIssuesEventsEventId_578310(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "eventId" in path, "`eventId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/events/"),
               (kind: VariableSegment, value: "eventId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesEventsEventId_578309(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single event.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   eventId: JInt (required)
  ##          : Id of the event.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578311 = path.getOrDefault("repo")
  valid_578311 = validateParameter(valid_578311, JString, required = true,
                                 default = nil)
  if valid_578311 != nil:
    section.add "repo", valid_578311
  var valid_578312 = path.getOrDefault("eventId")
  valid_578312 = validateParameter(valid_578312, JInt, required = true, default = nil)
  if valid_578312 != nil:
    section.add "eventId", valid_578312
  var valid_578313 = path.getOrDefault("owner")
  valid_578313 = validateParameter(valid_578313, JString, required = true,
                                 default = nil)
  if valid_578313 != nil:
    section.add "owner", valid_578313
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578314 = header.getOrDefault("Accept")
  valid_578314 = validateParameter(valid_578314, JString, required = false,
                                 default = nil)
  if valid_578314 != nil:
    section.add "Accept", valid_578314
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578315: Call_GetReposOwnerRepoIssuesEventsEventId_578308;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single event.
  ## 
  let valid = call_578315.validator(path, query, header, formData, body)
  let scheme = call_578315.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578315.url(scheme.get, call_578315.host, call_578315.base,
                         call_578315.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578315, url, valid)

proc call*(call_578316: Call_GetReposOwnerRepoIssuesEventsEventId_578308;
          repo: string; eventId: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesEventsEventId
  ## Get a single event.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   eventId: int (required)
  ##          : Id of the event.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578317 = newJObject()
  var header_578318 = newJObject()
  add(path_578317, "repo", newJString(repo))
  add(path_578317, "eventId", newJInt(eventId))
  add(path_578317, "owner", newJString(owner))
  add(header_578318, "Accept", newJString(Accept))
  result = call_578316.call(path_578317, nil, header_578318, nil, nil)

var getReposOwnerRepoIssuesEventsEventId* = Call_GetReposOwnerRepoIssuesEventsEventId_578308(
    name: "getReposOwnerRepoIssuesEventsEventId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/events/{eventId}",
    validator: validate_GetReposOwnerRepoIssuesEventsEventId_578309, base: "/",
    url: url_GetReposOwnerRepoIssuesEventsEventId_578310, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumber_578319 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoIssuesNumber_578321(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumber_578320(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single issue
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578322 = path.getOrDefault("repo")
  valid_578322 = validateParameter(valid_578322, JString, required = true,
                                 default = nil)
  if valid_578322 != nil:
    section.add "repo", valid_578322
  var valid_578323 = path.getOrDefault("number")
  valid_578323 = validateParameter(valid_578323, JInt, required = true, default = nil)
  if valid_578323 != nil:
    section.add "number", valid_578323
  var valid_578324 = path.getOrDefault("owner")
  valid_578324 = validateParameter(valid_578324, JString, required = true,
                                 default = nil)
  if valid_578324 != nil:
    section.add "owner", valid_578324
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578325 = header.getOrDefault("Accept")
  valid_578325 = validateParameter(valid_578325, JString, required = false,
                                 default = nil)
  if valid_578325 != nil:
    section.add "Accept", valid_578325
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578326: Call_GetReposOwnerRepoIssuesNumber_578319; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a single issue
  ## 
  let valid = call_578326.validator(path, query, header, formData, body)
  let scheme = call_578326.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578326.url(scheme.get, call_578326.host, call_578326.base,
                         call_578326.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578326, url, valid)

proc call*(call_578327: Call_GetReposOwnerRepoIssuesNumber_578319; repo: string;
          number: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumber
  ## Get a single issue
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Number of issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578328 = newJObject()
  var header_578329 = newJObject()
  add(path_578328, "repo", newJString(repo))
  add(path_578328, "number", newJInt(number))
  add(path_578328, "owner", newJString(owner))
  add(header_578329, "Accept", newJString(Accept))
  result = call_578327.call(path_578328, nil, header_578329, nil, nil)

var getReposOwnerRepoIssuesNumber* = Call_GetReposOwnerRepoIssuesNumber_578319(
    name: "getReposOwnerRepoIssuesNumber", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}",
    validator: validate_GetReposOwnerRepoIssuesNumber_578320, base: "/",
    url: url_GetReposOwnerRepoIssuesNumber_578321, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoIssuesNumber_578330 = ref object of OpenApiRestCall_576564
proc url_PatchReposOwnerRepoIssuesNumber_578332(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoIssuesNumber_578331(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Edit an issue.
  ## Issue owners and users with push access can edit an issue.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578333 = path.getOrDefault("repo")
  valid_578333 = validateParameter(valid_578333, JString, required = true,
                                 default = nil)
  if valid_578333 != nil:
    section.add "repo", valid_578333
  var valid_578334 = path.getOrDefault("number")
  valid_578334 = validateParameter(valid_578334, JInt, required = true, default = nil)
  if valid_578334 != nil:
    section.add "number", valid_578334
  var valid_578335 = path.getOrDefault("owner")
  valid_578335 = validateParameter(valid_578335, JString, required = true,
                                 default = nil)
  if valid_578335 != nil:
    section.add "owner", valid_578335
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578336 = header.getOrDefault("Accept")
  valid_578336 = validateParameter(valid_578336, JString, required = false,
                                 default = nil)
  if valid_578336 != nil:
    section.add "Accept", valid_578336
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578338: Call_PatchReposOwnerRepoIssuesNumber_578330;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Edit an issue.
  ## Issue owners and users with push access can edit an issue.
  ## 
  ## 
  let valid = call_578338.validator(path, query, header, formData, body)
  let scheme = call_578338.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578338.url(scheme.get, call_578338.host, call_578338.base,
                         call_578338.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578338, url, valid)

proc call*(call_578339: Call_PatchReposOwnerRepoIssuesNumber_578330; repo: string;
          number: int; owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoIssuesNumber
  ## Edit an issue.
  ## Issue owners and users with push access can edit an issue.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Number of issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578340 = newJObject()
  var header_578341 = newJObject()
  var body_578342 = newJObject()
  add(path_578340, "repo", newJString(repo))
  add(path_578340, "number", newJInt(number))
  add(path_578340, "owner", newJString(owner))
  if body != nil:
    body_578342 = body
  add(header_578341, "Accept", newJString(Accept))
  result = call_578339.call(path_578340, nil, header_578341, nil, body_578342)

var patchReposOwnerRepoIssuesNumber* = Call_PatchReposOwnerRepoIssuesNumber_578330(
    name: "patchReposOwnerRepoIssuesNumber", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}",
    validator: validate_PatchReposOwnerRepoIssuesNumber_578331, base: "/",
    url: url_PatchReposOwnerRepoIssuesNumber_578332, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoIssuesNumberComments_578354 = ref object of OpenApiRestCall_576564
proc url_PostReposOwnerRepoIssuesNumberComments_578356(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoIssuesNumberComments_578355(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578357 = path.getOrDefault("repo")
  valid_578357 = validateParameter(valid_578357, JString, required = true,
                                 default = nil)
  if valid_578357 != nil:
    section.add "repo", valid_578357
  var valid_578358 = path.getOrDefault("number")
  valid_578358 = validateParameter(valid_578358, JInt, required = true, default = nil)
  if valid_578358 != nil:
    section.add "number", valid_578358
  var valid_578359 = path.getOrDefault("owner")
  valid_578359 = validateParameter(valid_578359, JString, required = true,
                                 default = nil)
  if valid_578359 != nil:
    section.add "owner", valid_578359
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578360 = header.getOrDefault("Accept")
  valid_578360 = validateParameter(valid_578360, JString, required = false,
                                 default = nil)
  if valid_578360 != nil:
    section.add "Accept", valid_578360
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578362: Call_PostReposOwnerRepoIssuesNumberComments_578354;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Create a comment.
  ## 
  let valid = call_578362.validator(path, query, header, formData, body)
  let scheme = call_578362.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578362.url(scheme.get, call_578362.host, call_578362.base,
                         call_578362.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578362, url, valid)

proc call*(call_578363: Call_PostReposOwnerRepoIssuesNumberComments_578354;
          repo: string; number: int; owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoIssuesNumberComments
  ## Create a comment.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Number of issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578364 = newJObject()
  var header_578365 = newJObject()
  var body_578366 = newJObject()
  add(path_578364, "repo", newJString(repo))
  add(path_578364, "number", newJInt(number))
  add(path_578364, "owner", newJString(owner))
  if body != nil:
    body_578366 = body
  add(header_578365, "Accept", newJString(Accept))
  result = call_578363.call(path_578364, nil, header_578365, nil, body_578366)

var postReposOwnerRepoIssuesNumberComments* = Call_PostReposOwnerRepoIssuesNumberComments_578354(
    name: "postReposOwnerRepoIssuesNumberComments", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/{number}/comments",
    validator: validate_PostReposOwnerRepoIssuesNumberComments_578355, base: "/",
    url: url_PostReposOwnerRepoIssuesNumberComments_578356,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumberComments_578343 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoIssuesNumberComments_578345(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumberComments_578344(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List comments on an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578346 = path.getOrDefault("repo")
  valid_578346 = validateParameter(valid_578346, JString, required = true,
                                 default = nil)
  if valid_578346 != nil:
    section.add "repo", valid_578346
  var valid_578347 = path.getOrDefault("number")
  valid_578347 = validateParameter(valid_578347, JInt, required = true, default = nil)
  if valid_578347 != nil:
    section.add "number", valid_578347
  var valid_578348 = path.getOrDefault("owner")
  valid_578348 = validateParameter(valid_578348, JString, required = true,
                                 default = nil)
  if valid_578348 != nil:
    section.add "owner", valid_578348
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578349 = header.getOrDefault("Accept")
  valid_578349 = validateParameter(valid_578349, JString, required = false,
                                 default = nil)
  if valid_578349 != nil:
    section.add "Accept", valid_578349
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578350: Call_GetReposOwnerRepoIssuesNumberComments_578343;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List comments on an issue.
  ## 
  let valid = call_578350.validator(path, query, header, formData, body)
  let scheme = call_578350.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578350.url(scheme.get, call_578350.host, call_578350.base,
                         call_578350.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578350, url, valid)

proc call*(call_578351: Call_GetReposOwnerRepoIssuesNumberComments_578343;
          repo: string; number: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumberComments
  ## List comments on an issue.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Number of issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578352 = newJObject()
  var header_578353 = newJObject()
  add(path_578352, "repo", newJString(repo))
  add(path_578352, "number", newJInt(number))
  add(path_578352, "owner", newJString(owner))
  add(header_578353, "Accept", newJString(Accept))
  result = call_578351.call(path_578352, nil, header_578353, nil, nil)

var getReposOwnerRepoIssuesNumberComments* = Call_GetReposOwnerRepoIssuesNumberComments_578343(
    name: "getReposOwnerRepoIssuesNumberComments", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/{number}/comments",
    validator: validate_GetReposOwnerRepoIssuesNumberComments_578344, base: "/",
    url: url_GetReposOwnerRepoIssuesNumberComments_578345, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumberEvents_578367 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoIssuesNumberEvents_578369(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumberEvents_578368(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List events for an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578370 = path.getOrDefault("repo")
  valid_578370 = validateParameter(valid_578370, JString, required = true,
                                 default = nil)
  if valid_578370 != nil:
    section.add "repo", valid_578370
  var valid_578371 = path.getOrDefault("number")
  valid_578371 = validateParameter(valid_578371, JInt, required = true, default = nil)
  if valid_578371 != nil:
    section.add "number", valid_578371
  var valid_578372 = path.getOrDefault("owner")
  valid_578372 = validateParameter(valid_578372, JString, required = true,
                                 default = nil)
  if valid_578372 != nil:
    section.add "owner", valid_578372
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578373 = header.getOrDefault("Accept")
  valid_578373 = validateParameter(valid_578373, JString, required = false,
                                 default = nil)
  if valid_578373 != nil:
    section.add "Accept", valid_578373
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578374: Call_GetReposOwnerRepoIssuesNumberEvents_578367;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List events for an issue.
  ## 
  let valid = call_578374.validator(path, query, header, formData, body)
  let scheme = call_578374.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578374.url(scheme.get, call_578374.host, call_578374.base,
                         call_578374.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578374, url, valid)

proc call*(call_578375: Call_GetReposOwnerRepoIssuesNumberEvents_578367;
          repo: string; number: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumberEvents
  ## List events for an issue.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Number of issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578376 = newJObject()
  var header_578377 = newJObject()
  add(path_578376, "repo", newJString(repo))
  add(path_578376, "number", newJInt(number))
  add(path_578376, "owner", newJString(owner))
  add(header_578377, "Accept", newJString(Accept))
  result = call_578375.call(path_578376, nil, header_578377, nil, nil)

var getReposOwnerRepoIssuesNumberEvents* = Call_GetReposOwnerRepoIssuesNumberEvents_578367(
    name: "getReposOwnerRepoIssuesNumberEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/events",
    validator: validate_GetReposOwnerRepoIssuesNumberEvents_578368, base: "/",
    url: url_GetReposOwnerRepoIssuesNumberEvents_578369, schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoIssuesNumberLabels_578389 = ref object of OpenApiRestCall_576564
proc url_PutReposOwnerRepoIssuesNumberLabels_578391(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoIssuesNumberLabels_578390(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Replace all labels for an issue.
  ## Sending an empty array ([]) will remove all Labels from the Issue.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578392 = path.getOrDefault("repo")
  valid_578392 = validateParameter(valid_578392, JString, required = true,
                                 default = nil)
  if valid_578392 != nil:
    section.add "repo", valid_578392
  var valid_578393 = path.getOrDefault("number")
  valid_578393 = validateParameter(valid_578393, JInt, required = true, default = nil)
  if valid_578393 != nil:
    section.add "number", valid_578393
  var valid_578394 = path.getOrDefault("owner")
  valid_578394 = validateParameter(valid_578394, JString, required = true,
                                 default = nil)
  if valid_578394 != nil:
    section.add "owner", valid_578394
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578395 = header.getOrDefault("Accept")
  valid_578395 = validateParameter(valid_578395, JString, required = false,
                                 default = nil)
  if valid_578395 != nil:
    section.add "Accept", valid_578395
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578397: Call_PutReposOwnerRepoIssuesNumberLabels_578389;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Replace all labels for an issue.
  ## Sending an empty array ([]) will remove all Labels from the Issue.
  ## 
  ## 
  let valid = call_578397.validator(path, query, header, formData, body)
  let scheme = call_578397.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578397.url(scheme.get, call_578397.host, call_578397.base,
                         call_578397.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578397, url, valid)

proc call*(call_578398: Call_PutReposOwnerRepoIssuesNumberLabels_578389;
          repo: string; number: int; owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## putReposOwnerRepoIssuesNumberLabels
  ## Replace all labels for an issue.
  ## Sending an empty array ([]) will remove all Labels from the Issue.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Number of issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JArray (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578399 = newJObject()
  var header_578400 = newJObject()
  var body_578401 = newJObject()
  add(path_578399, "repo", newJString(repo))
  add(path_578399, "number", newJInt(number))
  add(path_578399, "owner", newJString(owner))
  if body != nil:
    body_578401 = body
  add(header_578400, "Accept", newJString(Accept))
  result = call_578398.call(path_578399, nil, header_578400, nil, body_578401)

var putReposOwnerRepoIssuesNumberLabels* = Call_PutReposOwnerRepoIssuesNumberLabels_578389(
    name: "putReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_PutReposOwnerRepoIssuesNumberLabels_578390, base: "/",
    url: url_PutReposOwnerRepoIssuesNumberLabels_578391, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoIssuesNumberLabels_578402 = ref object of OpenApiRestCall_576564
proc url_PostReposOwnerRepoIssuesNumberLabels_578404(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoIssuesNumberLabels_578403(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Add labels to an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578405 = path.getOrDefault("repo")
  valid_578405 = validateParameter(valid_578405, JString, required = true,
                                 default = nil)
  if valid_578405 != nil:
    section.add "repo", valid_578405
  var valid_578406 = path.getOrDefault("number")
  valid_578406 = validateParameter(valid_578406, JInt, required = true, default = nil)
  if valid_578406 != nil:
    section.add "number", valid_578406
  var valid_578407 = path.getOrDefault("owner")
  valid_578407 = validateParameter(valid_578407, JString, required = true,
                                 default = nil)
  if valid_578407 != nil:
    section.add "owner", valid_578407
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578408 = header.getOrDefault("Accept")
  valid_578408 = validateParameter(valid_578408, JString, required = false,
                                 default = nil)
  if valid_578408 != nil:
    section.add "Accept", valid_578408
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578410: Call_PostReposOwnerRepoIssuesNumberLabels_578402;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Add labels to an issue.
  ## 
  let valid = call_578410.validator(path, query, header, formData, body)
  let scheme = call_578410.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578410.url(scheme.get, call_578410.host, call_578410.base,
                         call_578410.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578410, url, valid)

proc call*(call_578411: Call_PostReposOwnerRepoIssuesNumberLabels_578402;
          repo: string; number: int; owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoIssuesNumberLabels
  ## Add labels to an issue.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Number of issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JArray (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578412 = newJObject()
  var header_578413 = newJObject()
  var body_578414 = newJObject()
  add(path_578412, "repo", newJString(repo))
  add(path_578412, "number", newJInt(number))
  add(path_578412, "owner", newJString(owner))
  if body != nil:
    body_578414 = body
  add(header_578413, "Accept", newJString(Accept))
  result = call_578411.call(path_578412, nil, header_578413, nil, body_578414)

var postReposOwnerRepoIssuesNumberLabels* = Call_PostReposOwnerRepoIssuesNumberLabels_578402(
    name: "postReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_PostReposOwnerRepoIssuesNumberLabels_578403, base: "/",
    url: url_PostReposOwnerRepoIssuesNumberLabels_578404, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumberLabels_578378 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoIssuesNumberLabels_578380(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumberLabels_578379(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List labels on an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578381 = path.getOrDefault("repo")
  valid_578381 = validateParameter(valid_578381, JString, required = true,
                                 default = nil)
  if valid_578381 != nil:
    section.add "repo", valid_578381
  var valid_578382 = path.getOrDefault("number")
  valid_578382 = validateParameter(valid_578382, JInt, required = true, default = nil)
  if valid_578382 != nil:
    section.add "number", valid_578382
  var valid_578383 = path.getOrDefault("owner")
  valid_578383 = validateParameter(valid_578383, JString, required = true,
                                 default = nil)
  if valid_578383 != nil:
    section.add "owner", valid_578383
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578384 = header.getOrDefault("Accept")
  valid_578384 = validateParameter(valid_578384, JString, required = false,
                                 default = nil)
  if valid_578384 != nil:
    section.add "Accept", valid_578384
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578385: Call_GetReposOwnerRepoIssuesNumberLabels_578378;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List labels on an issue.
  ## 
  let valid = call_578385.validator(path, query, header, formData, body)
  let scheme = call_578385.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578385.url(scheme.get, call_578385.host, call_578385.base,
                         call_578385.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578385, url, valid)

proc call*(call_578386: Call_GetReposOwnerRepoIssuesNumberLabels_578378;
          repo: string; number: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumberLabels
  ## List labels on an issue.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Number of issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578387 = newJObject()
  var header_578388 = newJObject()
  add(path_578387, "repo", newJString(repo))
  add(path_578387, "number", newJInt(number))
  add(path_578387, "owner", newJString(owner))
  add(header_578388, "Accept", newJString(Accept))
  result = call_578386.call(path_578387, nil, header_578388, nil, nil)

var getReposOwnerRepoIssuesNumberLabels* = Call_GetReposOwnerRepoIssuesNumberLabels_578378(
    name: "getReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_GetReposOwnerRepoIssuesNumberLabels_578379, base: "/",
    url: url_GetReposOwnerRepoIssuesNumberLabels_578380, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoIssuesNumberLabels_578415 = ref object of OpenApiRestCall_576564
proc url_DeleteReposOwnerRepoIssuesNumberLabels_578417(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoIssuesNumberLabels_578416(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Remove all labels from an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578418 = path.getOrDefault("repo")
  valid_578418 = validateParameter(valid_578418, JString, required = true,
                                 default = nil)
  if valid_578418 != nil:
    section.add "repo", valid_578418
  var valid_578419 = path.getOrDefault("number")
  valid_578419 = validateParameter(valid_578419, JInt, required = true, default = nil)
  if valid_578419 != nil:
    section.add "number", valid_578419
  var valid_578420 = path.getOrDefault("owner")
  valid_578420 = validateParameter(valid_578420, JString, required = true,
                                 default = nil)
  if valid_578420 != nil:
    section.add "owner", valid_578420
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578421 = header.getOrDefault("Accept")
  valid_578421 = validateParameter(valid_578421, JString, required = false,
                                 default = nil)
  if valid_578421 != nil:
    section.add "Accept", valid_578421
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578422: Call_DeleteReposOwnerRepoIssuesNumberLabels_578415;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Remove all labels from an issue.
  ## 
  let valid = call_578422.validator(path, query, header, formData, body)
  let scheme = call_578422.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578422.url(scheme.get, call_578422.host, call_578422.base,
                         call_578422.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578422, url, valid)

proc call*(call_578423: Call_DeleteReposOwnerRepoIssuesNumberLabels_578415;
          repo: string; number: int; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoIssuesNumberLabels
  ## Remove all labels from an issue.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Number of issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578424 = newJObject()
  var header_578425 = newJObject()
  add(path_578424, "repo", newJString(repo))
  add(path_578424, "number", newJInt(number))
  add(path_578424, "owner", newJString(owner))
  add(header_578425, "Accept", newJString(Accept))
  result = call_578423.call(path_578424, nil, header_578425, nil, nil)

var deleteReposOwnerRepoIssuesNumberLabels* = Call_DeleteReposOwnerRepoIssuesNumberLabels_578415(
    name: "deleteReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_DeleteReposOwnerRepoIssuesNumberLabels_578416, base: "/",
    url: url_DeleteReposOwnerRepoIssuesNumberLabels_578417,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoIssuesNumberLabelsName_578426 = ref object of OpenApiRestCall_576564
proc url_DeleteReposOwnerRepoIssuesNumberLabelsName_578428(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoIssuesNumberLabelsName_578427(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Remove a label from an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   name: JString (required)
  ##       : Name of the label.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578429 = path.getOrDefault("repo")
  valid_578429 = validateParameter(valid_578429, JString, required = true,
                                 default = nil)
  if valid_578429 != nil:
    section.add "repo", valid_578429
  var valid_578430 = path.getOrDefault("name")
  valid_578430 = validateParameter(valid_578430, JString, required = true,
                                 default = nil)
  if valid_578430 != nil:
    section.add "name", valid_578430
  var valid_578431 = path.getOrDefault("number")
  valid_578431 = validateParameter(valid_578431, JInt, required = true, default = nil)
  if valid_578431 != nil:
    section.add "number", valid_578431
  var valid_578432 = path.getOrDefault("owner")
  valid_578432 = validateParameter(valid_578432, JString, required = true,
                                 default = nil)
  if valid_578432 != nil:
    section.add "owner", valid_578432
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578433 = header.getOrDefault("Accept")
  valid_578433 = validateParameter(valid_578433, JString, required = false,
                                 default = nil)
  if valid_578433 != nil:
    section.add "Accept", valid_578433
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578434: Call_DeleteReposOwnerRepoIssuesNumberLabelsName_578426;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Remove a label from an issue.
  ## 
  let valid = call_578434.validator(path, query, header, formData, body)
  let scheme = call_578434.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578434.url(scheme.get, call_578434.host, call_578434.base,
                         call_578434.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578434, url, valid)

proc call*(call_578435: Call_DeleteReposOwnerRepoIssuesNumberLabelsName_578426;
          repo: string; name: string; number: int; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoIssuesNumberLabelsName
  ## Remove a label from an issue.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   name: string (required)
  ##       : Name of the label.
  ##   number: int (required)
  ##         : Number of issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578436 = newJObject()
  var header_578437 = newJObject()
  add(path_578436, "repo", newJString(repo))
  add(path_578436, "name", newJString(name))
  add(path_578436, "number", newJInt(number))
  add(path_578436, "owner", newJString(owner))
  add(header_578437, "Accept", newJString(Accept))
  result = call_578435.call(path_578436, nil, header_578437, nil, nil)

var deleteReposOwnerRepoIssuesNumberLabelsName* = Call_DeleteReposOwnerRepoIssuesNumberLabelsName_578426(
    name: "deleteReposOwnerRepoIssuesNumberLabelsName",
    meth: HttpMethod.HttpDelete, host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/{number}/labels/{name}",
    validator: validate_DeleteReposOwnerRepoIssuesNumberLabelsName_578427,
    base: "/", url: url_DeleteReposOwnerRepoIssuesNumberLabelsName_578428,
    schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoKeys_578448 = ref object of OpenApiRestCall_576564
proc url_PostReposOwnerRepoKeys_578450(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/keys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoKeys_578449(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a key.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578451 = path.getOrDefault("repo")
  valid_578451 = validateParameter(valid_578451, JString, required = true,
                                 default = nil)
  if valid_578451 != nil:
    section.add "repo", valid_578451
  var valid_578452 = path.getOrDefault("owner")
  valid_578452 = validateParameter(valid_578452, JString, required = true,
                                 default = nil)
  if valid_578452 != nil:
    section.add "owner", valid_578452
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578453 = header.getOrDefault("Accept")
  valid_578453 = validateParameter(valid_578453, JString, required = false,
                                 default = nil)
  if valid_578453 != nil:
    section.add "Accept", valid_578453
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578455: Call_PostReposOwnerRepoKeys_578448; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a key.
  ## 
  let valid = call_578455.validator(path, query, header, formData, body)
  let scheme = call_578455.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578455.url(scheme.get, call_578455.host, call_578455.base,
                         call_578455.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578455, url, valid)

proc call*(call_578456: Call_PostReposOwnerRepoKeys_578448; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoKeys
  ## Create a key.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578457 = newJObject()
  var header_578458 = newJObject()
  var body_578459 = newJObject()
  add(path_578457, "repo", newJString(repo))
  add(path_578457, "owner", newJString(owner))
  if body != nil:
    body_578459 = body
  add(header_578458, "Accept", newJString(Accept))
  result = call_578456.call(path_578457, nil, header_578458, nil, body_578459)

var postReposOwnerRepoKeys* = Call_PostReposOwnerRepoKeys_578448(
    name: "postReposOwnerRepoKeys", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/keys",
    validator: validate_PostReposOwnerRepoKeys_578449, base: "/",
    url: url_PostReposOwnerRepoKeys_578450, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoKeys_578438 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoKeys_578440(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/keys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoKeys_578439(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get list of keys.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578441 = path.getOrDefault("repo")
  valid_578441 = validateParameter(valid_578441, JString, required = true,
                                 default = nil)
  if valid_578441 != nil:
    section.add "repo", valid_578441
  var valid_578442 = path.getOrDefault("owner")
  valid_578442 = validateParameter(valid_578442, JString, required = true,
                                 default = nil)
  if valid_578442 != nil:
    section.add "owner", valid_578442
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578443 = header.getOrDefault("Accept")
  valid_578443 = validateParameter(valid_578443, JString, required = false,
                                 default = nil)
  if valid_578443 != nil:
    section.add "Accept", valid_578443
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578444: Call_GetReposOwnerRepoKeys_578438; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get list of keys.
  ## 
  let valid = call_578444.validator(path, query, header, formData, body)
  let scheme = call_578444.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578444.url(scheme.get, call_578444.host, call_578444.base,
                         call_578444.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578444, url, valid)

proc call*(call_578445: Call_GetReposOwnerRepoKeys_578438; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoKeys
  ## Get list of keys.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578446 = newJObject()
  var header_578447 = newJObject()
  add(path_578446, "repo", newJString(repo))
  add(path_578446, "owner", newJString(owner))
  add(header_578447, "Accept", newJString(Accept))
  result = call_578445.call(path_578446, nil, header_578447, nil, nil)

var getReposOwnerRepoKeys* = Call_GetReposOwnerRepoKeys_578438(
    name: "getReposOwnerRepoKeys", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/repos/{owner}/{repo}/keys",
    validator: validate_GetReposOwnerRepoKeys_578439, base: "/",
    url: url_GetReposOwnerRepoKeys_578440, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoKeysKeyId_578460 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoKeysKeyId_578462(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/keys/"),
               (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoKeysKeyId_578461(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a key
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   keyId: JInt (required)
  ##        : Id of key.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578463 = path.getOrDefault("repo")
  valid_578463 = validateParameter(valid_578463, JString, required = true,
                                 default = nil)
  if valid_578463 != nil:
    section.add "repo", valid_578463
  var valid_578464 = path.getOrDefault("keyId")
  valid_578464 = validateParameter(valid_578464, JInt, required = true, default = nil)
  if valid_578464 != nil:
    section.add "keyId", valid_578464
  var valid_578465 = path.getOrDefault("owner")
  valid_578465 = validateParameter(valid_578465, JString, required = true,
                                 default = nil)
  if valid_578465 != nil:
    section.add "owner", valid_578465
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578466 = header.getOrDefault("Accept")
  valid_578466 = validateParameter(valid_578466, JString, required = false,
                                 default = nil)
  if valid_578466 != nil:
    section.add "Accept", valid_578466
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578467: Call_GetReposOwnerRepoKeysKeyId_578460; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a key
  ## 
  let valid = call_578467.validator(path, query, header, formData, body)
  let scheme = call_578467.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578467.url(scheme.get, call_578467.host, call_578467.base,
                         call_578467.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578467, url, valid)

proc call*(call_578468: Call_GetReposOwnerRepoKeysKeyId_578460; repo: string;
          keyId: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoKeysKeyId
  ## Get a key
  ##   repo: string (required)
  ##       : Name of repository.
  ##   keyId: int (required)
  ##        : Id of key.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578469 = newJObject()
  var header_578470 = newJObject()
  add(path_578469, "repo", newJString(repo))
  add(path_578469, "keyId", newJInt(keyId))
  add(path_578469, "owner", newJString(owner))
  add(header_578470, "Accept", newJString(Accept))
  result = call_578468.call(path_578469, nil, header_578470, nil, nil)

var getReposOwnerRepoKeysKeyId* = Call_GetReposOwnerRepoKeysKeyId_578460(
    name: "getReposOwnerRepoKeysKeyId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/keys/{keyId}",
    validator: validate_GetReposOwnerRepoKeysKeyId_578461, base: "/",
    url: url_GetReposOwnerRepoKeysKeyId_578462, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoKeysKeyId_578471 = ref object of OpenApiRestCall_576564
proc url_DeleteReposOwnerRepoKeysKeyId_578473(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/keys/"),
               (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoKeysKeyId_578472(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a key.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   keyId: JInt (required)
  ##        : Id of key.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578474 = path.getOrDefault("repo")
  valid_578474 = validateParameter(valid_578474, JString, required = true,
                                 default = nil)
  if valid_578474 != nil:
    section.add "repo", valid_578474
  var valid_578475 = path.getOrDefault("keyId")
  valid_578475 = validateParameter(valid_578475, JInt, required = true, default = nil)
  if valid_578475 != nil:
    section.add "keyId", valid_578475
  var valid_578476 = path.getOrDefault("owner")
  valid_578476 = validateParameter(valid_578476, JString, required = true,
                                 default = nil)
  if valid_578476 != nil:
    section.add "owner", valid_578476
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578477 = header.getOrDefault("Accept")
  valid_578477 = validateParameter(valid_578477, JString, required = false,
                                 default = nil)
  if valid_578477 != nil:
    section.add "Accept", valid_578477
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578478: Call_DeleteReposOwnerRepoKeysKeyId_578471; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete a key.
  ## 
  let valid = call_578478.validator(path, query, header, formData, body)
  let scheme = call_578478.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578478.url(scheme.get, call_578478.host, call_578478.base,
                         call_578478.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578478, url, valid)

proc call*(call_578479: Call_DeleteReposOwnerRepoKeysKeyId_578471; repo: string;
          keyId: int; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoKeysKeyId
  ## Delete a key.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   keyId: int (required)
  ##        : Id of key.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578480 = newJObject()
  var header_578481 = newJObject()
  add(path_578480, "repo", newJString(repo))
  add(path_578480, "keyId", newJInt(keyId))
  add(path_578480, "owner", newJString(owner))
  add(header_578481, "Accept", newJString(Accept))
  result = call_578479.call(path_578480, nil, header_578481, nil, nil)

var deleteReposOwnerRepoKeysKeyId* = Call_DeleteReposOwnerRepoKeysKeyId_578471(
    name: "deleteReposOwnerRepoKeysKeyId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/keys/{keyId}",
    validator: validate_DeleteReposOwnerRepoKeysKeyId_578472, base: "/",
    url: url_DeleteReposOwnerRepoKeysKeyId_578473, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoLabels_578492 = ref object of OpenApiRestCall_576564
proc url_PostReposOwnerRepoLabels_578494(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoLabels_578493(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578495 = path.getOrDefault("repo")
  valid_578495 = validateParameter(valid_578495, JString, required = true,
                                 default = nil)
  if valid_578495 != nil:
    section.add "repo", valid_578495
  var valid_578496 = path.getOrDefault("owner")
  valid_578496 = validateParameter(valid_578496, JString, required = true,
                                 default = nil)
  if valid_578496 != nil:
    section.add "owner", valid_578496
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578497 = header.getOrDefault("Accept")
  valid_578497 = validateParameter(valid_578497, JString, required = false,
                                 default = nil)
  if valid_578497 != nil:
    section.add "Accept", valid_578497
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578499: Call_PostReposOwnerRepoLabels_578492; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a label.
  ## 
  let valid = call_578499.validator(path, query, header, formData, body)
  let scheme = call_578499.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578499.url(scheme.get, call_578499.host, call_578499.base,
                         call_578499.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578499, url, valid)

proc call*(call_578500: Call_PostReposOwnerRepoLabels_578492; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoLabels
  ## Create a label.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JArray (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578501 = newJObject()
  var header_578502 = newJObject()
  var body_578503 = newJObject()
  add(path_578501, "repo", newJString(repo))
  add(path_578501, "owner", newJString(owner))
  if body != nil:
    body_578503 = body
  add(header_578502, "Accept", newJString(Accept))
  result = call_578500.call(path_578501, nil, header_578502, nil, body_578503)

var postReposOwnerRepoLabels* = Call_PostReposOwnerRepoLabels_578492(
    name: "postReposOwnerRepoLabels", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels",
    validator: validate_PostReposOwnerRepoLabels_578493, base: "/",
    url: url_PostReposOwnerRepoLabels_578494, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoLabels_578482 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoLabels_578484(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoLabels_578483(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List all labels for this repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578485 = path.getOrDefault("repo")
  valid_578485 = validateParameter(valid_578485, JString, required = true,
                                 default = nil)
  if valid_578485 != nil:
    section.add "repo", valid_578485
  var valid_578486 = path.getOrDefault("owner")
  valid_578486 = validateParameter(valid_578486, JString, required = true,
                                 default = nil)
  if valid_578486 != nil:
    section.add "owner", valid_578486
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578487 = header.getOrDefault("Accept")
  valid_578487 = validateParameter(valid_578487, JString, required = false,
                                 default = nil)
  if valid_578487 != nil:
    section.add "Accept", valid_578487
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578488: Call_GetReposOwnerRepoLabels_578482; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List all labels for this repository.
  ## 
  let valid = call_578488.validator(path, query, header, formData, body)
  let scheme = call_578488.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578488.url(scheme.get, call_578488.host, call_578488.base,
                         call_578488.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578488, url, valid)

proc call*(call_578489: Call_GetReposOwnerRepoLabels_578482; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoLabels
  ## List all labels for this repository.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578490 = newJObject()
  var header_578491 = newJObject()
  add(path_578490, "repo", newJString(repo))
  add(path_578490, "owner", newJString(owner))
  add(header_578491, "Accept", newJString(Accept))
  result = call_578489.call(path_578490, nil, header_578491, nil, nil)

var getReposOwnerRepoLabels* = Call_GetReposOwnerRepoLabels_578482(
    name: "getReposOwnerRepoLabels", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels",
    validator: validate_GetReposOwnerRepoLabels_578483, base: "/",
    url: url_GetReposOwnerRepoLabels_578484, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoLabelsName_578504 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoLabelsName_578506(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoLabelsName_578505(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   name: JString (required)
  ##       : Name of the label.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578507 = path.getOrDefault("repo")
  valid_578507 = validateParameter(valid_578507, JString, required = true,
                                 default = nil)
  if valid_578507 != nil:
    section.add "repo", valid_578507
  var valid_578508 = path.getOrDefault("name")
  valid_578508 = validateParameter(valid_578508, JString, required = true,
                                 default = nil)
  if valid_578508 != nil:
    section.add "name", valid_578508
  var valid_578509 = path.getOrDefault("owner")
  valid_578509 = validateParameter(valid_578509, JString, required = true,
                                 default = nil)
  if valid_578509 != nil:
    section.add "owner", valid_578509
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578510 = header.getOrDefault("Accept")
  valid_578510 = validateParameter(valid_578510, JString, required = false,
                                 default = nil)
  if valid_578510 != nil:
    section.add "Accept", valid_578510
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578511: Call_GetReposOwnerRepoLabelsName_578504; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a single label.
  ## 
  let valid = call_578511.validator(path, query, header, formData, body)
  let scheme = call_578511.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578511.url(scheme.get, call_578511.host, call_578511.base,
                         call_578511.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578511, url, valid)

proc call*(call_578512: Call_GetReposOwnerRepoLabelsName_578504; repo: string;
          name: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoLabelsName
  ## Get a single label.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   name: string (required)
  ##       : Name of the label.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578513 = newJObject()
  var header_578514 = newJObject()
  add(path_578513, "repo", newJString(repo))
  add(path_578513, "name", newJString(name))
  add(path_578513, "owner", newJString(owner))
  add(header_578514, "Accept", newJString(Accept))
  result = call_578512.call(path_578513, nil, header_578514, nil, nil)

var getReposOwnerRepoLabelsName* = Call_GetReposOwnerRepoLabelsName_578504(
    name: "getReposOwnerRepoLabelsName", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels/{name}",
    validator: validate_GetReposOwnerRepoLabelsName_578505, base: "/",
    url: url_GetReposOwnerRepoLabelsName_578506, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoLabelsName_578526 = ref object of OpenApiRestCall_576564
proc url_PatchReposOwnerRepoLabelsName_578528(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoLabelsName_578527(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Update a label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   name: JString (required)
  ##       : Name of the label.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578529 = path.getOrDefault("repo")
  valid_578529 = validateParameter(valid_578529, JString, required = true,
                                 default = nil)
  if valid_578529 != nil:
    section.add "repo", valid_578529
  var valid_578530 = path.getOrDefault("name")
  valid_578530 = validateParameter(valid_578530, JString, required = true,
                                 default = nil)
  if valid_578530 != nil:
    section.add "name", valid_578530
  var valid_578531 = path.getOrDefault("owner")
  valid_578531 = validateParameter(valid_578531, JString, required = true,
                                 default = nil)
  if valid_578531 != nil:
    section.add "owner", valid_578531
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578532 = header.getOrDefault("Accept")
  valid_578532 = validateParameter(valid_578532, JString, required = false,
                                 default = nil)
  if valid_578532 != nil:
    section.add "Accept", valid_578532
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578534: Call_PatchReposOwnerRepoLabelsName_578526; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Update a label.
  ## 
  let valid = call_578534.validator(path, query, header, formData, body)
  let scheme = call_578534.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578534.url(scheme.get, call_578534.host, call_578534.base,
                         call_578534.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578534, url, valid)

proc call*(call_578535: Call_PatchReposOwnerRepoLabelsName_578526; repo: string;
          name: string; owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoLabelsName
  ## Update a label.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   name: string (required)
  ##       : Name of the label.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JArray (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578536 = newJObject()
  var header_578537 = newJObject()
  var body_578538 = newJObject()
  add(path_578536, "repo", newJString(repo))
  add(path_578536, "name", newJString(name))
  add(path_578536, "owner", newJString(owner))
  if body != nil:
    body_578538 = body
  add(header_578537, "Accept", newJString(Accept))
  result = call_578535.call(path_578536, nil, header_578537, nil, body_578538)

var patchReposOwnerRepoLabelsName* = Call_PatchReposOwnerRepoLabelsName_578526(
    name: "patchReposOwnerRepoLabelsName", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels/{name}",
    validator: validate_PatchReposOwnerRepoLabelsName_578527, base: "/",
    url: url_PatchReposOwnerRepoLabelsName_578528, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoLabelsName_578515 = ref object of OpenApiRestCall_576564
proc url_DeleteReposOwnerRepoLabelsName_578517(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoLabelsName_578516(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   name: JString (required)
  ##       : Name of the label.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578518 = path.getOrDefault("repo")
  valid_578518 = validateParameter(valid_578518, JString, required = true,
                                 default = nil)
  if valid_578518 != nil:
    section.add "repo", valid_578518
  var valid_578519 = path.getOrDefault("name")
  valid_578519 = validateParameter(valid_578519, JString, required = true,
                                 default = nil)
  if valid_578519 != nil:
    section.add "name", valid_578519
  var valid_578520 = path.getOrDefault("owner")
  valid_578520 = validateParameter(valid_578520, JString, required = true,
                                 default = nil)
  if valid_578520 != nil:
    section.add "owner", valid_578520
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578521 = header.getOrDefault("Accept")
  valid_578521 = validateParameter(valid_578521, JString, required = false,
                                 default = nil)
  if valid_578521 != nil:
    section.add "Accept", valid_578521
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578522: Call_DeleteReposOwnerRepoLabelsName_578515; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete a label.
  ## 
  let valid = call_578522.validator(path, query, header, formData, body)
  let scheme = call_578522.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578522.url(scheme.get, call_578522.host, call_578522.base,
                         call_578522.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578522, url, valid)

proc call*(call_578523: Call_DeleteReposOwnerRepoLabelsName_578515; repo: string;
          name: string; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoLabelsName
  ## Delete a label.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   name: string (required)
  ##       : Name of the label.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578524 = newJObject()
  var header_578525 = newJObject()
  add(path_578524, "repo", newJString(repo))
  add(path_578524, "name", newJString(name))
  add(path_578524, "owner", newJString(owner))
  add(header_578525, "Accept", newJString(Accept))
  result = call_578523.call(path_578524, nil, header_578525, nil, nil)

var deleteReposOwnerRepoLabelsName* = Call_DeleteReposOwnerRepoLabelsName_578515(
    name: "deleteReposOwnerRepoLabelsName", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels/{name}",
    validator: validate_DeleteReposOwnerRepoLabelsName_578516, base: "/",
    url: url_DeleteReposOwnerRepoLabelsName_578517, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoLanguages_578539 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoLanguages_578541(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/languages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoLanguages_578540(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List languages.
  ## List languages for the specified repository. The value on the right of a
  ## language is the number of bytes of code written in that language.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578542 = path.getOrDefault("repo")
  valid_578542 = validateParameter(valid_578542, JString, required = true,
                                 default = nil)
  if valid_578542 != nil:
    section.add "repo", valid_578542
  var valid_578543 = path.getOrDefault("owner")
  valid_578543 = validateParameter(valid_578543, JString, required = true,
                                 default = nil)
  if valid_578543 != nil:
    section.add "owner", valid_578543
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578544 = header.getOrDefault("Accept")
  valid_578544 = validateParameter(valid_578544, JString, required = false,
                                 default = nil)
  if valid_578544 != nil:
    section.add "Accept", valid_578544
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578545: Call_GetReposOwnerRepoLanguages_578539; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List languages.
  ## List languages for the specified repository. The value on the right of a
  ## language is the number of bytes of code written in that language.
  ## 
  ## 
  let valid = call_578545.validator(path, query, header, formData, body)
  let scheme = call_578545.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578545.url(scheme.get, call_578545.host, call_578545.base,
                         call_578545.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578545, url, valid)

proc call*(call_578546: Call_GetReposOwnerRepoLanguages_578539; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoLanguages
  ## List languages.
  ## List languages for the specified repository. The value on the right of a
  ## language is the number of bytes of code written in that language.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578547 = newJObject()
  var header_578548 = newJObject()
  add(path_578547, "repo", newJString(repo))
  add(path_578547, "owner", newJString(owner))
  add(header_578548, "Accept", newJString(Accept))
  result = call_578546.call(path_578547, nil, header_578548, nil, nil)

var getReposOwnerRepoLanguages* = Call_GetReposOwnerRepoLanguages_578539(
    name: "getReposOwnerRepoLanguages", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/languages",
    validator: validate_GetReposOwnerRepoLanguages_578540, base: "/",
    url: url_GetReposOwnerRepoLanguages_578541, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoMerges_578549 = ref object of OpenApiRestCall_576564
proc url_PostReposOwnerRepoMerges_578551(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/merges")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoMerges_578550(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Perform a merge.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578552 = path.getOrDefault("repo")
  valid_578552 = validateParameter(valid_578552, JString, required = true,
                                 default = nil)
  if valid_578552 != nil:
    section.add "repo", valid_578552
  var valid_578553 = path.getOrDefault("owner")
  valid_578553 = validateParameter(valid_578553, JString, required = true,
                                 default = nil)
  if valid_578553 != nil:
    section.add "owner", valid_578553
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578554 = header.getOrDefault("Accept")
  valid_578554 = validateParameter(valid_578554, JString, required = false,
                                 default = nil)
  if valid_578554 != nil:
    section.add "Accept", valid_578554
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578556: Call_PostReposOwnerRepoMerges_578549; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Perform a merge.
  ## 
  let valid = call_578556.validator(path, query, header, formData, body)
  let scheme = call_578556.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578556.url(scheme.get, call_578556.host, call_578556.base,
                         call_578556.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578556, url, valid)

proc call*(call_578557: Call_PostReposOwnerRepoMerges_578549; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoMerges
  ## Perform a merge.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578558 = newJObject()
  var header_578559 = newJObject()
  var body_578560 = newJObject()
  add(path_578558, "repo", newJString(repo))
  add(path_578558, "owner", newJString(owner))
  if body != nil:
    body_578560 = body
  add(header_578559, "Accept", newJString(Accept))
  result = call_578557.call(path_578558, nil, header_578559, nil, body_578560)

var postReposOwnerRepoMerges* = Call_PostReposOwnerRepoMerges_578549(
    name: "postReposOwnerRepoMerges", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/merges",
    validator: validate_PostReposOwnerRepoMerges_578550, base: "/",
    url: url_PostReposOwnerRepoMerges_578551, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoMilestones_578575 = ref object of OpenApiRestCall_576564
proc url_PostReposOwnerRepoMilestones_578577(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoMilestones_578576(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578578 = path.getOrDefault("repo")
  valid_578578 = validateParameter(valid_578578, JString, required = true,
                                 default = nil)
  if valid_578578 != nil:
    section.add "repo", valid_578578
  var valid_578579 = path.getOrDefault("owner")
  valid_578579 = validateParameter(valid_578579, JString, required = true,
                                 default = nil)
  if valid_578579 != nil:
    section.add "owner", valid_578579
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578580 = header.getOrDefault("Accept")
  valid_578580 = validateParameter(valid_578580, JString, required = false,
                                 default = nil)
  if valid_578580 != nil:
    section.add "Accept", valid_578580
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578582: Call_PostReposOwnerRepoMilestones_578575; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a milestone.
  ## 
  let valid = call_578582.validator(path, query, header, formData, body)
  let scheme = call_578582.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578582.url(scheme.get, call_578582.host, call_578582.base,
                         call_578582.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578582, url, valid)

proc call*(call_578583: Call_PostReposOwnerRepoMilestones_578575; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoMilestones
  ## Create a milestone.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578584 = newJObject()
  var header_578585 = newJObject()
  var body_578586 = newJObject()
  add(path_578584, "repo", newJString(repo))
  add(path_578584, "owner", newJString(owner))
  if body != nil:
    body_578586 = body
  add(header_578585, "Accept", newJString(Accept))
  result = call_578583.call(path_578584, nil, header_578585, nil, body_578586)

var postReposOwnerRepoMilestones* = Call_PostReposOwnerRepoMilestones_578575(
    name: "postReposOwnerRepoMilestones", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones",
    validator: validate_PostReposOwnerRepoMilestones_578576, base: "/",
    url: url_PostReposOwnerRepoMilestones_578577, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoMilestones_578561 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoMilestones_578563(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoMilestones_578562(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List milestones for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578564 = path.getOrDefault("repo")
  valid_578564 = validateParameter(valid_578564, JString, required = true,
                                 default = nil)
  if valid_578564 != nil:
    section.add "repo", valid_578564
  var valid_578565 = path.getOrDefault("owner")
  valid_578565 = validateParameter(valid_578565, JString, required = true,
                                 default = nil)
  if valid_578565 != nil:
    section.add "owner", valid_578565
  result.add "path", section
  ## parameters in `query` object:
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  ##   state: JString
  ##        : String to filter by state.
  ##   sort: JString
  section = newJObject()
  var valid_578566 = query.getOrDefault("direction")
  valid_578566 = validateParameter(valid_578566, JString, required = false,
                                 default = nil)
  if valid_578566 != nil:
    section.add "direction", valid_578566
  var valid_578567 = query.getOrDefault("state")
  valid_578567 = validateParameter(valid_578567, JString, required = false,
                                 default = newJString("open"))
  if valid_578567 != nil:
    section.add "state", valid_578567
  var valid_578568 = query.getOrDefault("sort")
  valid_578568 = validateParameter(valid_578568, JString, required = false,
                                 default = newJString("due_date"))
  if valid_578568 != nil:
    section.add "sort", valid_578568
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578569 = header.getOrDefault("Accept")
  valid_578569 = validateParameter(valid_578569, JString, required = false,
                                 default = nil)
  if valid_578569 != nil:
    section.add "Accept", valid_578569
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578570: Call_GetReposOwnerRepoMilestones_578561; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List milestones for a repository.
  ## 
  let valid = call_578570.validator(path, query, header, formData, body)
  let scheme = call_578570.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578570.url(scheme.get, call_578570.host, call_578570.base,
                         call_578570.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578570, url, valid)

proc call*(call_578571: Call_GetReposOwnerRepoMilestones_578561; repo: string;
          owner: string; direction: string = ""; state: string = "open";
          Accept: string = ""; sort: string = "due_date"): Recallable =
  ## getReposOwnerRepoMilestones
  ## List milestones for a repository.
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   state: string
  ##        : String to filter by state.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  var path_578572 = newJObject()
  var query_578573 = newJObject()
  var header_578574 = newJObject()
  add(query_578573, "direction", newJString(direction))
  add(path_578572, "repo", newJString(repo))
  add(query_578573, "state", newJString(state))
  add(path_578572, "owner", newJString(owner))
  add(header_578574, "Accept", newJString(Accept))
  add(query_578573, "sort", newJString(sort))
  result = call_578571.call(path_578572, query_578573, header_578574, nil, nil)

var getReposOwnerRepoMilestones* = Call_GetReposOwnerRepoMilestones_578561(
    name: "getReposOwnerRepoMilestones", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones",
    validator: validate_GetReposOwnerRepoMilestones_578562, base: "/",
    url: url_GetReposOwnerRepoMilestones_578563, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoMilestonesNumber_578587 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoMilestonesNumber_578589(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoMilestonesNumber_578588(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578590 = path.getOrDefault("repo")
  valid_578590 = validateParameter(valid_578590, JString, required = true,
                                 default = nil)
  if valid_578590 != nil:
    section.add "repo", valid_578590
  var valid_578591 = path.getOrDefault("number")
  valid_578591 = validateParameter(valid_578591, JInt, required = true, default = nil)
  if valid_578591 != nil:
    section.add "number", valid_578591
  var valid_578592 = path.getOrDefault("owner")
  valid_578592 = validateParameter(valid_578592, JString, required = true,
                                 default = nil)
  if valid_578592 != nil:
    section.add "owner", valid_578592
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578593 = header.getOrDefault("Accept")
  valid_578593 = validateParameter(valid_578593, JString, required = false,
                                 default = nil)
  if valid_578593 != nil:
    section.add "Accept", valid_578593
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578594: Call_GetReposOwnerRepoMilestonesNumber_578587;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single milestone.
  ## 
  let valid = call_578594.validator(path, query, header, formData, body)
  let scheme = call_578594.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578594.url(scheme.get, call_578594.host, call_578594.base,
                         call_578594.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578594, url, valid)

proc call*(call_578595: Call_GetReposOwnerRepoMilestonesNumber_578587;
          repo: string; number: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoMilestonesNumber
  ## Get a single milestone.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578596 = newJObject()
  var header_578597 = newJObject()
  add(path_578596, "repo", newJString(repo))
  add(path_578596, "number", newJInt(number))
  add(path_578596, "owner", newJString(owner))
  add(header_578597, "Accept", newJString(Accept))
  result = call_578595.call(path_578596, nil, header_578597, nil, nil)

var getReposOwnerRepoMilestonesNumber* = Call_GetReposOwnerRepoMilestonesNumber_578587(
    name: "getReposOwnerRepoMilestonesNumber", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones/{number}",
    validator: validate_GetReposOwnerRepoMilestonesNumber_578588, base: "/",
    url: url_GetReposOwnerRepoMilestonesNumber_578589, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoMilestonesNumber_578609 = ref object of OpenApiRestCall_576564
proc url_PatchReposOwnerRepoMilestonesNumber_578611(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoMilestonesNumber_578610(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Update a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578612 = path.getOrDefault("repo")
  valid_578612 = validateParameter(valid_578612, JString, required = true,
                                 default = nil)
  if valid_578612 != nil:
    section.add "repo", valid_578612
  var valid_578613 = path.getOrDefault("number")
  valid_578613 = validateParameter(valid_578613, JInt, required = true, default = nil)
  if valid_578613 != nil:
    section.add "number", valid_578613
  var valid_578614 = path.getOrDefault("owner")
  valid_578614 = validateParameter(valid_578614, JString, required = true,
                                 default = nil)
  if valid_578614 != nil:
    section.add "owner", valid_578614
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578615 = header.getOrDefault("Accept")
  valid_578615 = validateParameter(valid_578615, JString, required = false,
                                 default = nil)
  if valid_578615 != nil:
    section.add "Accept", valid_578615
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578617: Call_PatchReposOwnerRepoMilestonesNumber_578609;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Update a milestone.
  ## 
  let valid = call_578617.validator(path, query, header, formData, body)
  let scheme = call_578617.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578617.url(scheme.get, call_578617.host, call_578617.base,
                         call_578617.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578617, url, valid)

proc call*(call_578618: Call_PatchReposOwnerRepoMilestonesNumber_578609;
          repo: string; number: int; owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoMilestonesNumber
  ## Update a milestone.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578619 = newJObject()
  var header_578620 = newJObject()
  var body_578621 = newJObject()
  add(path_578619, "repo", newJString(repo))
  add(path_578619, "number", newJInt(number))
  add(path_578619, "owner", newJString(owner))
  if body != nil:
    body_578621 = body
  add(header_578620, "Accept", newJString(Accept))
  result = call_578618.call(path_578619, nil, header_578620, nil, body_578621)

var patchReposOwnerRepoMilestonesNumber* = Call_PatchReposOwnerRepoMilestonesNumber_578609(
    name: "patchReposOwnerRepoMilestonesNumber", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones/{number}",
    validator: validate_PatchReposOwnerRepoMilestonesNumber_578610, base: "/",
    url: url_PatchReposOwnerRepoMilestonesNumber_578611, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoMilestonesNumber_578598 = ref object of OpenApiRestCall_576564
proc url_DeleteReposOwnerRepoMilestonesNumber_578600(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoMilestonesNumber_578599(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578601 = path.getOrDefault("repo")
  valid_578601 = validateParameter(valid_578601, JString, required = true,
                                 default = nil)
  if valid_578601 != nil:
    section.add "repo", valid_578601
  var valid_578602 = path.getOrDefault("number")
  valid_578602 = validateParameter(valid_578602, JInt, required = true, default = nil)
  if valid_578602 != nil:
    section.add "number", valid_578602
  var valid_578603 = path.getOrDefault("owner")
  valid_578603 = validateParameter(valid_578603, JString, required = true,
                                 default = nil)
  if valid_578603 != nil:
    section.add "owner", valid_578603
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578604 = header.getOrDefault("Accept")
  valid_578604 = validateParameter(valid_578604, JString, required = false,
                                 default = nil)
  if valid_578604 != nil:
    section.add "Accept", valid_578604
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578605: Call_DeleteReposOwnerRepoMilestonesNumber_578598;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a milestone.
  ## 
  let valid = call_578605.validator(path, query, header, formData, body)
  let scheme = call_578605.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578605.url(scheme.get, call_578605.host, call_578605.base,
                         call_578605.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578605, url, valid)

proc call*(call_578606: Call_DeleteReposOwnerRepoMilestonesNumber_578598;
          repo: string; number: int; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoMilestonesNumber
  ## Delete a milestone.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578607 = newJObject()
  var header_578608 = newJObject()
  add(path_578607, "repo", newJString(repo))
  add(path_578607, "number", newJInt(number))
  add(path_578607, "owner", newJString(owner))
  add(header_578608, "Accept", newJString(Accept))
  result = call_578606.call(path_578607, nil, header_578608, nil, nil)

var deleteReposOwnerRepoMilestonesNumber* = Call_DeleteReposOwnerRepoMilestonesNumber_578598(
    name: "deleteReposOwnerRepoMilestonesNumber", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones/{number}",
    validator: validate_DeleteReposOwnerRepoMilestonesNumber_578599, base: "/",
    url: url_DeleteReposOwnerRepoMilestonesNumber_578600, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoMilestonesNumberLabels_578622 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoMilestonesNumberLabels_578624(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoMilestonesNumberLabels_578623(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get labels for every issue in a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578625 = path.getOrDefault("repo")
  valid_578625 = validateParameter(valid_578625, JString, required = true,
                                 default = nil)
  if valid_578625 != nil:
    section.add "repo", valid_578625
  var valid_578626 = path.getOrDefault("number")
  valid_578626 = validateParameter(valid_578626, JInt, required = true, default = nil)
  if valid_578626 != nil:
    section.add "number", valid_578626
  var valid_578627 = path.getOrDefault("owner")
  valid_578627 = validateParameter(valid_578627, JString, required = true,
                                 default = nil)
  if valid_578627 != nil:
    section.add "owner", valid_578627
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578628 = header.getOrDefault("Accept")
  valid_578628 = validateParameter(valid_578628, JString, required = false,
                                 default = nil)
  if valid_578628 != nil:
    section.add "Accept", valid_578628
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578629: Call_GetReposOwnerRepoMilestonesNumberLabels_578622;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get labels for every issue in a milestone.
  ## 
  let valid = call_578629.validator(path, query, header, formData, body)
  let scheme = call_578629.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578629.url(scheme.get, call_578629.host, call_578629.base,
                         call_578629.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578629, url, valid)

proc call*(call_578630: Call_GetReposOwnerRepoMilestonesNumberLabels_578622;
          repo: string; number: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoMilestonesNumberLabels
  ## Get labels for every issue in a milestone.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578631 = newJObject()
  var header_578632 = newJObject()
  add(path_578631, "repo", newJString(repo))
  add(path_578631, "number", newJInt(number))
  add(path_578631, "owner", newJString(owner))
  add(header_578632, "Accept", newJString(Accept))
  result = call_578630.call(path_578631, nil, header_578632, nil, nil)

var getReposOwnerRepoMilestonesNumberLabels* = Call_GetReposOwnerRepoMilestonesNumberLabels_578622(
    name: "getReposOwnerRepoMilestonesNumberLabels", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/milestones/{number}/labels",
    validator: validate_GetReposOwnerRepoMilestonesNumberLabels_578623, base: "/",
    url: url_GetReposOwnerRepoMilestonesNumberLabels_578624,
    schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoNotifications_578647 = ref object of OpenApiRestCall_576564
proc url_PutReposOwnerRepoNotifications_578649(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/notifications")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoNotifications_578648(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Mark notifications as read in a repository.
  ## Marking all notifications in a repository as "read" removes them from the
  ## default view on GitHub.com.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578650 = path.getOrDefault("repo")
  valid_578650 = validateParameter(valid_578650, JString, required = true,
                                 default = nil)
  if valid_578650 != nil:
    section.add "repo", valid_578650
  var valid_578651 = path.getOrDefault("owner")
  valid_578651 = validateParameter(valid_578651, JString, required = true,
                                 default = nil)
  if valid_578651 != nil:
    section.add "owner", valid_578651
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578652 = header.getOrDefault("Accept")
  valid_578652 = validateParameter(valid_578652, JString, required = false,
                                 default = nil)
  if valid_578652 != nil:
    section.add "Accept", valid_578652
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578654: Call_PutReposOwnerRepoNotifications_578647; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Mark notifications as read in a repository.
  ## Marking all notifications in a repository as "read" removes them from the
  ## default view on GitHub.com.
  ## 
  ## 
  let valid = call_578654.validator(path, query, header, formData, body)
  let scheme = call_578654.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578654.url(scheme.get, call_578654.host, call_578654.base,
                         call_578654.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578654, url, valid)

proc call*(call_578655: Call_PutReposOwnerRepoNotifications_578647; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## putReposOwnerRepoNotifications
  ## Mark notifications as read in a repository.
  ## Marking all notifications in a repository as "read" removes them from the
  ## default view on GitHub.com.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578656 = newJObject()
  var header_578657 = newJObject()
  var body_578658 = newJObject()
  add(path_578656, "repo", newJString(repo))
  add(path_578656, "owner", newJString(owner))
  if body != nil:
    body_578658 = body
  add(header_578657, "Accept", newJString(Accept))
  result = call_578655.call(path_578656, nil, header_578657, nil, body_578658)

var putReposOwnerRepoNotifications* = Call_PutReposOwnerRepoNotifications_578647(
    name: "putReposOwnerRepoNotifications", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/notifications",
    validator: validate_PutReposOwnerRepoNotifications_578648, base: "/",
    url: url_PutReposOwnerRepoNotifications_578649, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoNotifications_578633 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoNotifications_578635(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/notifications")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoNotifications_578634(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List your notifications in a repository
  ## List all notifications for the current user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578636 = path.getOrDefault("repo")
  valid_578636 = validateParameter(valid_578636, JString, required = true,
                                 default = nil)
  if valid_578636 != nil:
    section.add "repo", valid_578636
  var valid_578637 = path.getOrDefault("owner")
  valid_578637 = validateParameter(valid_578637, JString, required = true,
                                 default = nil)
  if valid_578637 != nil:
    section.add "owner", valid_578637
  result.add "path", section
  ## parameters in `query` object:
  ##   all: JBool
  ##      : True to show notifications marked as read.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   participating: JBool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  section = newJObject()
  var valid_578638 = query.getOrDefault("all")
  valid_578638 = validateParameter(valid_578638, JBool, required = false, default = nil)
  if valid_578638 != nil:
    section.add "all", valid_578638
  var valid_578639 = query.getOrDefault("since")
  valid_578639 = validateParameter(valid_578639, JString, required = false,
                                 default = nil)
  if valid_578639 != nil:
    section.add "since", valid_578639
  var valid_578640 = query.getOrDefault("participating")
  valid_578640 = validateParameter(valid_578640, JBool, required = false, default = nil)
  if valid_578640 != nil:
    section.add "participating", valid_578640
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578641 = header.getOrDefault("Accept")
  valid_578641 = validateParameter(valid_578641, JString, required = false,
                                 default = nil)
  if valid_578641 != nil:
    section.add "Accept", valid_578641
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578642: Call_GetReposOwnerRepoNotifications_578633; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List your notifications in a repository
  ## List all notifications for the current user.
  ## 
  ## 
  let valid = call_578642.validator(path, query, header, formData, body)
  let scheme = call_578642.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578642.url(scheme.get, call_578642.host, call_578642.base,
                         call_578642.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578642, url, valid)

proc call*(call_578643: Call_GetReposOwnerRepoNotifications_578633; repo: string;
          owner: string; all: bool = false; since: string = "";
          participating: bool = false; Accept: string = ""): Recallable =
  ## getReposOwnerRepoNotifications
  ## List your notifications in a repository
  ## List all notifications for the current user.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   all: bool
  ##      : True to show notifications marked as read.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   participating: bool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578644 = newJObject()
  var query_578645 = newJObject()
  var header_578646 = newJObject()
  add(path_578644, "repo", newJString(repo))
  add(query_578645, "all", newJBool(all))
  add(query_578645, "since", newJString(since))
  add(query_578645, "participating", newJBool(participating))
  add(path_578644, "owner", newJString(owner))
  add(header_578646, "Accept", newJString(Accept))
  result = call_578643.call(path_578644, query_578645, header_578646, nil, nil)

var getReposOwnerRepoNotifications* = Call_GetReposOwnerRepoNotifications_578633(
    name: "getReposOwnerRepoNotifications", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/notifications",
    validator: validate_GetReposOwnerRepoNotifications_578634, base: "/",
    url: url_GetReposOwnerRepoNotifications_578635, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoPulls_578673 = ref object of OpenApiRestCall_576564
proc url_PostReposOwnerRepoPulls_578675(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoPulls_578674(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578676 = path.getOrDefault("repo")
  valid_578676 = validateParameter(valid_578676, JString, required = true,
                                 default = nil)
  if valid_578676 != nil:
    section.add "repo", valid_578676
  var valid_578677 = path.getOrDefault("owner")
  valid_578677 = validateParameter(valid_578677, JString, required = true,
                                 default = nil)
  if valid_578677 != nil:
    section.add "owner", valid_578677
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578678 = header.getOrDefault("Accept")
  valid_578678 = validateParameter(valid_578678, JString, required = false,
                                 default = nil)
  if valid_578678 != nil:
    section.add "Accept", valid_578678
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578680: Call_PostReposOwnerRepoPulls_578673; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a pull request.
  ## 
  let valid = call_578680.validator(path, query, header, formData, body)
  let scheme = call_578680.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578680.url(scheme.get, call_578680.host, call_578680.base,
                         call_578680.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578680, url, valid)

proc call*(call_578681: Call_PostReposOwnerRepoPulls_578673; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoPulls
  ## Create a pull request.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578682 = newJObject()
  var header_578683 = newJObject()
  var body_578684 = newJObject()
  add(path_578682, "repo", newJString(repo))
  add(path_578682, "owner", newJString(owner))
  if body != nil:
    body_578684 = body
  add(header_578683, "Accept", newJString(Accept))
  result = call_578681.call(path_578682, nil, header_578683, nil, body_578684)

var postReposOwnerRepoPulls* = Call_PostReposOwnerRepoPulls_578673(
    name: "postReposOwnerRepoPulls", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls",
    validator: validate_PostReposOwnerRepoPulls_578674, base: "/",
    url: url_PostReposOwnerRepoPulls_578675, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPulls_578659 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoPulls_578661(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPulls_578660(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List pull requests.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578662 = path.getOrDefault("repo")
  valid_578662 = validateParameter(valid_578662, JString, required = true,
                                 default = nil)
  if valid_578662 != nil:
    section.add "repo", valid_578662
  var valid_578663 = path.getOrDefault("owner")
  valid_578663 = validateParameter(valid_578663, JString, required = true,
                                 default = nil)
  if valid_578663 != nil:
    section.add "owner", valid_578663
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString
  ##        : String to filter by state.
  ##   head: JString
  ##       : Filter pulls by head user and branch name in the format of 'user:ref-name'.
  ## Example: github:new-script-format.
  ## 
  ##   base: JString
  ##       : Filter pulls by base branch name. Example - gh-pages.
  section = newJObject()
  var valid_578664 = query.getOrDefault("state")
  valid_578664 = validateParameter(valid_578664, JString, required = false,
                                 default = newJString("open"))
  if valid_578664 != nil:
    section.add "state", valid_578664
  var valid_578665 = query.getOrDefault("head")
  valid_578665 = validateParameter(valid_578665, JString, required = false,
                                 default = nil)
  if valid_578665 != nil:
    section.add "head", valid_578665
  var valid_578666 = query.getOrDefault("base")
  valid_578666 = validateParameter(valid_578666, JString, required = false,
                                 default = nil)
  if valid_578666 != nil:
    section.add "base", valid_578666
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578667 = header.getOrDefault("Accept")
  valid_578667 = validateParameter(valid_578667, JString, required = false,
                                 default = nil)
  if valid_578667 != nil:
    section.add "Accept", valid_578667
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578668: Call_GetReposOwnerRepoPulls_578659; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List pull requests.
  ## 
  let valid = call_578668.validator(path, query, header, formData, body)
  let scheme = call_578668.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578668.url(scheme.get, call_578668.host, call_578668.base,
                         call_578668.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578668, url, valid)

proc call*(call_578669: Call_GetReposOwnerRepoPulls_578659; repo: string;
          owner: string; state: string = "open"; head: string = ""; Accept: string = "";
          base: string = ""): Recallable =
  ## getReposOwnerRepoPulls
  ## List pull requests.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   state: string
  ##        : String to filter by state.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   head: string
  ##       : Filter pulls by head user and branch name in the format of 'user:ref-name'.
  ## Example: github:new-script-format.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   base: string
  ##       : Filter pulls by base branch name. Example - gh-pages.
  var path_578670 = newJObject()
  var query_578671 = newJObject()
  var header_578672 = newJObject()
  add(path_578670, "repo", newJString(repo))
  add(query_578671, "state", newJString(state))
  add(path_578670, "owner", newJString(owner))
  add(query_578671, "head", newJString(head))
  add(header_578672, "Accept", newJString(Accept))
  add(query_578671, "base", newJString(base))
  result = call_578669.call(path_578670, query_578671, header_578672, nil, nil)

var getReposOwnerRepoPulls* = Call_GetReposOwnerRepoPulls_578659(
    name: "getReposOwnerRepoPulls", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls",
    validator: validate_GetReposOwnerRepoPulls_578660, base: "/",
    url: url_GetReposOwnerRepoPulls_578661, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsComments_578685 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoPullsComments_578687(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsComments_578686(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List comments in a repository.
  ## By default, Review Comments are ordered by ascending ID.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578688 = path.getOrDefault("repo")
  valid_578688 = validateParameter(valid_578688, JString, required = true,
                                 default = nil)
  if valid_578688 != nil:
    section.add "repo", valid_578688
  var valid_578689 = path.getOrDefault("owner")
  valid_578689 = validateParameter(valid_578689, JString, required = true,
                                 default = nil)
  if valid_578689 != nil:
    section.add "owner", valid_578689
  result.add "path", section
  ## parameters in `query` object:
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   sort: JString
  section = newJObject()
  var valid_578690 = query.getOrDefault("direction")
  valid_578690 = validateParameter(valid_578690, JString, required = false,
                                 default = nil)
  if valid_578690 != nil:
    section.add "direction", valid_578690
  var valid_578691 = query.getOrDefault("since")
  valid_578691 = validateParameter(valid_578691, JString, required = false,
                                 default = nil)
  if valid_578691 != nil:
    section.add "since", valid_578691
  var valid_578692 = query.getOrDefault("sort")
  valid_578692 = validateParameter(valid_578692, JString, required = false,
                                 default = newJString("created"))
  if valid_578692 != nil:
    section.add "sort", valid_578692
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578693 = header.getOrDefault("Accept")
  valid_578693 = validateParameter(valid_578693, JString, required = false,
                                 default = nil)
  if valid_578693 != nil:
    section.add "Accept", valid_578693
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578694: Call_GetReposOwnerRepoPullsComments_578685; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List comments in a repository.
  ## By default, Review Comments are ordered by ascending ID.
  ## 
  ## 
  let valid = call_578694.validator(path, query, header, formData, body)
  let scheme = call_578694.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578694.url(scheme.get, call_578694.host, call_578694.base,
                         call_578694.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578694, url, valid)

proc call*(call_578695: Call_GetReposOwnerRepoPullsComments_578685; repo: string;
          owner: string; direction: string = ""; since: string = ""; Accept: string = "";
          sort: string = "created"): Recallable =
  ## getReposOwnerRepoPullsComments
  ## List comments in a repository.
  ## By default, Review Comments are ordered by ascending ID.
  ## 
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  var path_578696 = newJObject()
  var query_578697 = newJObject()
  var header_578698 = newJObject()
  add(query_578697, "direction", newJString(direction))
  add(path_578696, "repo", newJString(repo))
  add(query_578697, "since", newJString(since))
  add(path_578696, "owner", newJString(owner))
  add(header_578698, "Accept", newJString(Accept))
  add(query_578697, "sort", newJString(sort))
  result = call_578695.call(path_578696, query_578697, header_578698, nil, nil)

var getReposOwnerRepoPullsComments* = Call_GetReposOwnerRepoPullsComments_578685(
    name: "getReposOwnerRepoPullsComments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/comments",
    validator: validate_GetReposOwnerRepoPullsComments_578686, base: "/",
    url: url_GetReposOwnerRepoPullsComments_578687, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsCommentsCommentId_578699 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoPullsCommentsCommentId_578701(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsCommentsCommentId_578700(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578702 = path.getOrDefault("repo")
  valid_578702 = validateParameter(valid_578702, JString, required = true,
                                 default = nil)
  if valid_578702 != nil:
    section.add "repo", valid_578702
  var valid_578703 = path.getOrDefault("commentId")
  valid_578703 = validateParameter(valid_578703, JInt, required = true, default = nil)
  if valid_578703 != nil:
    section.add "commentId", valid_578703
  var valid_578704 = path.getOrDefault("owner")
  valid_578704 = validateParameter(valid_578704, JString, required = true,
                                 default = nil)
  if valid_578704 != nil:
    section.add "owner", valid_578704
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578705 = header.getOrDefault("Accept")
  valid_578705 = validateParameter(valid_578705, JString, required = false,
                                 default = nil)
  if valid_578705 != nil:
    section.add "Accept", valid_578705
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578706: Call_GetReposOwnerRepoPullsCommentsCommentId_578699;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single comment.
  ## 
  let valid = call_578706.validator(path, query, header, formData, body)
  let scheme = call_578706.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578706.url(scheme.get, call_578706.host, call_578706.base,
                         call_578706.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578706, url, valid)

proc call*(call_578707: Call_GetReposOwnerRepoPullsCommentsCommentId_578699;
          repo: string; commentId: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsCommentsCommentId
  ## Get a single comment.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578708 = newJObject()
  var header_578709 = newJObject()
  add(path_578708, "repo", newJString(repo))
  add(path_578708, "commentId", newJInt(commentId))
  add(path_578708, "owner", newJString(owner))
  add(header_578709, "Accept", newJString(Accept))
  result = call_578707.call(path_578708, nil, header_578709, nil, nil)

var getReposOwnerRepoPullsCommentsCommentId* = Call_GetReposOwnerRepoPullsCommentsCommentId_578699(
    name: "getReposOwnerRepoPullsCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/comments/{commentId}",
    validator: validate_GetReposOwnerRepoPullsCommentsCommentId_578700, base: "/",
    url: url_GetReposOwnerRepoPullsCommentsCommentId_578701,
    schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoPullsCommentsCommentId_578721 = ref object of OpenApiRestCall_576564
proc url_PatchReposOwnerRepoPullsCommentsCommentId_578723(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoPullsCommentsCommentId_578722(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Edit a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578724 = path.getOrDefault("repo")
  valid_578724 = validateParameter(valid_578724, JString, required = true,
                                 default = nil)
  if valid_578724 != nil:
    section.add "repo", valid_578724
  var valid_578725 = path.getOrDefault("commentId")
  valid_578725 = validateParameter(valid_578725, JInt, required = true, default = nil)
  if valid_578725 != nil:
    section.add "commentId", valid_578725
  var valid_578726 = path.getOrDefault("owner")
  valid_578726 = validateParameter(valid_578726, JString, required = true,
                                 default = nil)
  if valid_578726 != nil:
    section.add "owner", valid_578726
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578727 = header.getOrDefault("Accept")
  valid_578727 = validateParameter(valid_578727, JString, required = false,
                                 default = nil)
  if valid_578727 != nil:
    section.add "Accept", valid_578727
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578729: Call_PatchReposOwnerRepoPullsCommentsCommentId_578721;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Edit a comment.
  ## 
  let valid = call_578729.validator(path, query, header, formData, body)
  let scheme = call_578729.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578729.url(scheme.get, call_578729.host, call_578729.base,
                         call_578729.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578729, url, valid)

proc call*(call_578730: Call_PatchReposOwnerRepoPullsCommentsCommentId_578721;
          repo: string; commentId: int; owner: string; body: JsonNode;
          Accept: string = ""): Recallable =
  ## patchReposOwnerRepoPullsCommentsCommentId
  ## Edit a comment.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578731 = newJObject()
  var header_578732 = newJObject()
  var body_578733 = newJObject()
  add(path_578731, "repo", newJString(repo))
  add(path_578731, "commentId", newJInt(commentId))
  add(path_578731, "owner", newJString(owner))
  if body != nil:
    body_578733 = body
  add(header_578732, "Accept", newJString(Accept))
  result = call_578730.call(path_578731, nil, header_578732, nil, body_578733)

var patchReposOwnerRepoPullsCommentsCommentId* = Call_PatchReposOwnerRepoPullsCommentsCommentId_578721(
    name: "patchReposOwnerRepoPullsCommentsCommentId", meth: HttpMethod.HttpPatch,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/comments/{commentId}",
    validator: validate_PatchReposOwnerRepoPullsCommentsCommentId_578722,
    base: "/", url: url_PatchReposOwnerRepoPullsCommentsCommentId_578723,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoPullsCommentsCommentId_578710 = ref object of OpenApiRestCall_576564
proc url_DeleteReposOwnerRepoPullsCommentsCommentId_578712(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoPullsCommentsCommentId_578711(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578713 = path.getOrDefault("repo")
  valid_578713 = validateParameter(valid_578713, JString, required = true,
                                 default = nil)
  if valid_578713 != nil:
    section.add "repo", valid_578713
  var valid_578714 = path.getOrDefault("commentId")
  valid_578714 = validateParameter(valid_578714, JInt, required = true, default = nil)
  if valid_578714 != nil:
    section.add "commentId", valid_578714
  var valid_578715 = path.getOrDefault("owner")
  valid_578715 = validateParameter(valid_578715, JString, required = true,
                                 default = nil)
  if valid_578715 != nil:
    section.add "owner", valid_578715
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578716 = header.getOrDefault("Accept")
  valid_578716 = validateParameter(valid_578716, JString, required = false,
                                 default = nil)
  if valid_578716 != nil:
    section.add "Accept", valid_578716
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578717: Call_DeleteReposOwnerRepoPullsCommentsCommentId_578710;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a comment.
  ## 
  let valid = call_578717.validator(path, query, header, formData, body)
  let scheme = call_578717.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578717.url(scheme.get, call_578717.host, call_578717.base,
                         call_578717.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578717, url, valid)

proc call*(call_578718: Call_DeleteReposOwnerRepoPullsCommentsCommentId_578710;
          repo: string; commentId: int; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoPullsCommentsCommentId
  ## Delete a comment.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578719 = newJObject()
  var header_578720 = newJObject()
  add(path_578719, "repo", newJString(repo))
  add(path_578719, "commentId", newJInt(commentId))
  add(path_578719, "owner", newJString(owner))
  add(header_578720, "Accept", newJString(Accept))
  result = call_578718.call(path_578719, nil, header_578720, nil, nil)

var deleteReposOwnerRepoPullsCommentsCommentId* = Call_DeleteReposOwnerRepoPullsCommentsCommentId_578710(
    name: "deleteReposOwnerRepoPullsCommentsCommentId",
    meth: HttpMethod.HttpDelete, host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/comments/{commentId}",
    validator: validate_DeleteReposOwnerRepoPullsCommentsCommentId_578711,
    base: "/", url: url_DeleteReposOwnerRepoPullsCommentsCommentId_578712,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumber_578734 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoPullsNumber_578736(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumber_578735(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578737 = path.getOrDefault("repo")
  valid_578737 = validateParameter(valid_578737, JString, required = true,
                                 default = nil)
  if valid_578737 != nil:
    section.add "repo", valid_578737
  var valid_578738 = path.getOrDefault("number")
  valid_578738 = validateParameter(valid_578738, JInt, required = true, default = nil)
  if valid_578738 != nil:
    section.add "number", valid_578738
  var valid_578739 = path.getOrDefault("owner")
  valid_578739 = validateParameter(valid_578739, JString, required = true,
                                 default = nil)
  if valid_578739 != nil:
    section.add "owner", valid_578739
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578740 = header.getOrDefault("Accept")
  valid_578740 = validateParameter(valid_578740, JString, required = false,
                                 default = nil)
  if valid_578740 != nil:
    section.add "Accept", valid_578740
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578741: Call_GetReposOwnerRepoPullsNumber_578734; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a single pull request.
  ## 
  let valid = call_578741.validator(path, query, header, formData, body)
  let scheme = call_578741.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578741.url(scheme.get, call_578741.host, call_578741.base,
                         call_578741.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578741, url, valid)

proc call*(call_578742: Call_GetReposOwnerRepoPullsNumber_578734; repo: string;
          number: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumber
  ## Get a single pull request.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Id of pull.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578743 = newJObject()
  var header_578744 = newJObject()
  add(path_578743, "repo", newJString(repo))
  add(path_578743, "number", newJInt(number))
  add(path_578743, "owner", newJString(owner))
  add(header_578744, "Accept", newJString(Accept))
  result = call_578742.call(path_578743, nil, header_578744, nil, nil)

var getReposOwnerRepoPullsNumber* = Call_GetReposOwnerRepoPullsNumber_578734(
    name: "getReposOwnerRepoPullsNumber", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}",
    validator: validate_GetReposOwnerRepoPullsNumber_578735, base: "/",
    url: url_GetReposOwnerRepoPullsNumber_578736, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoPullsNumber_578745 = ref object of OpenApiRestCall_576564
proc url_PatchReposOwnerRepoPullsNumber_578747(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoPullsNumber_578746(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Update a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578748 = path.getOrDefault("repo")
  valid_578748 = validateParameter(valid_578748, JString, required = true,
                                 default = nil)
  if valid_578748 != nil:
    section.add "repo", valid_578748
  var valid_578749 = path.getOrDefault("number")
  valid_578749 = validateParameter(valid_578749, JInt, required = true, default = nil)
  if valid_578749 != nil:
    section.add "number", valid_578749
  var valid_578750 = path.getOrDefault("owner")
  valid_578750 = validateParameter(valid_578750, JString, required = true,
                                 default = nil)
  if valid_578750 != nil:
    section.add "owner", valid_578750
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578751 = header.getOrDefault("Accept")
  valid_578751 = validateParameter(valid_578751, JString, required = false,
                                 default = nil)
  if valid_578751 != nil:
    section.add "Accept", valid_578751
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578753: Call_PatchReposOwnerRepoPullsNumber_578745; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Update a pull request.
  ## 
  let valid = call_578753.validator(path, query, header, formData, body)
  let scheme = call_578753.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578753.url(scheme.get, call_578753.host, call_578753.base,
                         call_578753.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578753, url, valid)

proc call*(call_578754: Call_PatchReposOwnerRepoPullsNumber_578745; repo: string;
          number: int; owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoPullsNumber
  ## Update a pull request.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Id of pull.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578755 = newJObject()
  var header_578756 = newJObject()
  var body_578757 = newJObject()
  add(path_578755, "repo", newJString(repo))
  add(path_578755, "number", newJInt(number))
  add(path_578755, "owner", newJString(owner))
  if body != nil:
    body_578757 = body
  add(header_578756, "Accept", newJString(Accept))
  result = call_578754.call(path_578755, nil, header_578756, nil, body_578757)

var patchReposOwnerRepoPullsNumber* = Call_PatchReposOwnerRepoPullsNumber_578745(
    name: "patchReposOwnerRepoPullsNumber", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}",
    validator: validate_PatchReposOwnerRepoPullsNumber_578746, base: "/",
    url: url_PatchReposOwnerRepoPullsNumber_578747, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoPullsNumberComments_578769 = ref object of OpenApiRestCall_576564
proc url_PostReposOwnerRepoPullsNumberComments_578771(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoPullsNumberComments_578770(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a comment.
  ##   #TODO Alternative input ( http://developer.github.com/v3/pulls/comments/ )
  ##   description: |
  ##     Alternative Input.
  ##     Instead of passing commit_id, path, and position you can reply to an
  ##     existing Pull Request Comment like this:
  ## 
  ##         body
  ##            Required string
  ##         in_reply_to
  ##            Required number - Comment id to reply to.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578772 = path.getOrDefault("repo")
  valid_578772 = validateParameter(valid_578772, JString, required = true,
                                 default = nil)
  if valid_578772 != nil:
    section.add "repo", valid_578772
  var valid_578773 = path.getOrDefault("number")
  valid_578773 = validateParameter(valid_578773, JInt, required = true, default = nil)
  if valid_578773 != nil:
    section.add "number", valid_578773
  var valid_578774 = path.getOrDefault("owner")
  valid_578774 = validateParameter(valid_578774, JString, required = true,
                                 default = nil)
  if valid_578774 != nil:
    section.add "owner", valid_578774
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578775 = header.getOrDefault("Accept")
  valid_578775 = validateParameter(valid_578775, JString, required = false,
                                 default = nil)
  if valid_578775 != nil:
    section.add "Accept", valid_578775
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578777: Call_PostReposOwnerRepoPullsNumberComments_578769;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Create a comment.
  ##   #TODO Alternative input ( http://developer.github.com/v3/pulls/comments/ )
  ##   description: |
  ##     Alternative Input.
  ##     Instead of passing commit_id, path, and position you can reply to an
  ##     existing Pull Request Comment like this:
  ## 
  ##         body
  ##            Required string
  ##         in_reply_to
  ##            Required number - Comment id to reply to.
  ## 
  ## 
  let valid = call_578777.validator(path, query, header, formData, body)
  let scheme = call_578777.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578777.url(scheme.get, call_578777.host, call_578777.base,
                         call_578777.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578777, url, valid)

proc call*(call_578778: Call_PostReposOwnerRepoPullsNumberComments_578769;
          repo: string; number: int; owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoPullsNumberComments
  ## Create a comment.
  ##   #TODO Alternative input ( http://developer.github.com/v3/pulls/comments/ )
  ##   description: |
  ##     Alternative Input.
  ##     Instead of passing commit_id, path, and position you can reply to an
  ##     existing Pull Request Comment like this:
  ## 
  ##         body
  ##            Required string
  ##         in_reply_to
  ##            Required number - Comment id to reply to.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Id of pull.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578779 = newJObject()
  var header_578780 = newJObject()
  var body_578781 = newJObject()
  add(path_578779, "repo", newJString(repo))
  add(path_578779, "number", newJInt(number))
  add(path_578779, "owner", newJString(owner))
  if body != nil:
    body_578781 = body
  add(header_578780, "Accept", newJString(Accept))
  result = call_578778.call(path_578779, nil, header_578780, nil, body_578781)

var postReposOwnerRepoPullsNumberComments* = Call_PostReposOwnerRepoPullsNumberComments_578769(
    name: "postReposOwnerRepoPullsNumberComments", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/{number}/comments",
    validator: validate_PostReposOwnerRepoPullsNumberComments_578770, base: "/",
    url: url_PostReposOwnerRepoPullsNumberComments_578771, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberComments_578758 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoPullsNumberComments_578760(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberComments_578759(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List comments on a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578761 = path.getOrDefault("repo")
  valid_578761 = validateParameter(valid_578761, JString, required = true,
                                 default = nil)
  if valid_578761 != nil:
    section.add "repo", valid_578761
  var valid_578762 = path.getOrDefault("number")
  valid_578762 = validateParameter(valid_578762, JInt, required = true, default = nil)
  if valid_578762 != nil:
    section.add "number", valid_578762
  var valid_578763 = path.getOrDefault("owner")
  valid_578763 = validateParameter(valid_578763, JString, required = true,
                                 default = nil)
  if valid_578763 != nil:
    section.add "owner", valid_578763
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578764 = header.getOrDefault("Accept")
  valid_578764 = validateParameter(valid_578764, JString, required = false,
                                 default = nil)
  if valid_578764 != nil:
    section.add "Accept", valid_578764
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578765: Call_GetReposOwnerRepoPullsNumberComments_578758;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List comments on a pull request.
  ## 
  let valid = call_578765.validator(path, query, header, formData, body)
  let scheme = call_578765.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578765.url(scheme.get, call_578765.host, call_578765.base,
                         call_578765.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578765, url, valid)

proc call*(call_578766: Call_GetReposOwnerRepoPullsNumberComments_578758;
          repo: string; number: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberComments
  ## List comments on a pull request.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Id of pull.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578767 = newJObject()
  var header_578768 = newJObject()
  add(path_578767, "repo", newJString(repo))
  add(path_578767, "number", newJInt(number))
  add(path_578767, "owner", newJString(owner))
  add(header_578768, "Accept", newJString(Accept))
  result = call_578766.call(path_578767, nil, header_578768, nil, nil)

var getReposOwnerRepoPullsNumberComments* = Call_GetReposOwnerRepoPullsNumberComments_578758(
    name: "getReposOwnerRepoPullsNumberComments", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/{number}/comments",
    validator: validate_GetReposOwnerRepoPullsNumberComments_578759, base: "/",
    url: url_GetReposOwnerRepoPullsNumberComments_578760, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberCommits_578782 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoPullsNumberCommits_578784(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/commits")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberCommits_578783(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List commits on a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578785 = path.getOrDefault("repo")
  valid_578785 = validateParameter(valid_578785, JString, required = true,
                                 default = nil)
  if valid_578785 != nil:
    section.add "repo", valid_578785
  var valid_578786 = path.getOrDefault("number")
  valid_578786 = validateParameter(valid_578786, JInt, required = true, default = nil)
  if valid_578786 != nil:
    section.add "number", valid_578786
  var valid_578787 = path.getOrDefault("owner")
  valid_578787 = validateParameter(valid_578787, JString, required = true,
                                 default = nil)
  if valid_578787 != nil:
    section.add "owner", valid_578787
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578788 = header.getOrDefault("Accept")
  valid_578788 = validateParameter(valid_578788, JString, required = false,
                                 default = nil)
  if valid_578788 != nil:
    section.add "Accept", valid_578788
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578789: Call_GetReposOwnerRepoPullsNumberCommits_578782;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List commits on a pull request.
  ## 
  let valid = call_578789.validator(path, query, header, formData, body)
  let scheme = call_578789.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578789.url(scheme.get, call_578789.host, call_578789.base,
                         call_578789.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578789, url, valid)

proc call*(call_578790: Call_GetReposOwnerRepoPullsNumberCommits_578782;
          repo: string; number: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberCommits
  ## List commits on a pull request.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Id of pull.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578791 = newJObject()
  var header_578792 = newJObject()
  add(path_578791, "repo", newJString(repo))
  add(path_578791, "number", newJInt(number))
  add(path_578791, "owner", newJString(owner))
  add(header_578792, "Accept", newJString(Accept))
  result = call_578790.call(path_578791, nil, header_578792, nil, nil)

var getReposOwnerRepoPullsNumberCommits* = Call_GetReposOwnerRepoPullsNumberCommits_578782(
    name: "getReposOwnerRepoPullsNumberCommits", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/commits",
    validator: validate_GetReposOwnerRepoPullsNumberCommits_578783, base: "/",
    url: url_GetReposOwnerRepoPullsNumberCommits_578784, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberFiles_578793 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoPullsNumberFiles_578795(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/files")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberFiles_578794(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List pull requests files.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578796 = path.getOrDefault("repo")
  valid_578796 = validateParameter(valid_578796, JString, required = true,
                                 default = nil)
  if valid_578796 != nil:
    section.add "repo", valid_578796
  var valid_578797 = path.getOrDefault("number")
  valid_578797 = validateParameter(valid_578797, JInt, required = true, default = nil)
  if valid_578797 != nil:
    section.add "number", valid_578797
  var valid_578798 = path.getOrDefault("owner")
  valid_578798 = validateParameter(valid_578798, JString, required = true,
                                 default = nil)
  if valid_578798 != nil:
    section.add "owner", valid_578798
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578799 = header.getOrDefault("Accept")
  valid_578799 = validateParameter(valid_578799, JString, required = false,
                                 default = nil)
  if valid_578799 != nil:
    section.add "Accept", valid_578799
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578800: Call_GetReposOwnerRepoPullsNumberFiles_578793;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List pull requests files.
  ## 
  let valid = call_578800.validator(path, query, header, formData, body)
  let scheme = call_578800.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578800.url(scheme.get, call_578800.host, call_578800.base,
                         call_578800.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578800, url, valid)

proc call*(call_578801: Call_GetReposOwnerRepoPullsNumberFiles_578793;
          repo: string; number: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberFiles
  ## List pull requests files.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Id of pull.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578802 = newJObject()
  var header_578803 = newJObject()
  add(path_578802, "repo", newJString(repo))
  add(path_578802, "number", newJInt(number))
  add(path_578802, "owner", newJString(owner))
  add(header_578803, "Accept", newJString(Accept))
  result = call_578801.call(path_578802, nil, header_578803, nil, nil)

var getReposOwnerRepoPullsNumberFiles* = Call_GetReposOwnerRepoPullsNumberFiles_578793(
    name: "getReposOwnerRepoPullsNumberFiles", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/files",
    validator: validate_GetReposOwnerRepoPullsNumberFiles_578794, base: "/",
    url: url_GetReposOwnerRepoPullsNumberFiles_578795, schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoPullsNumberMerge_578815 = ref object of OpenApiRestCall_576564
proc url_PutReposOwnerRepoPullsNumberMerge_578817(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/merge")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoPullsNumberMerge_578816(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Merge a pull request (Merge Button's)
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578818 = path.getOrDefault("repo")
  valid_578818 = validateParameter(valid_578818, JString, required = true,
                                 default = nil)
  if valid_578818 != nil:
    section.add "repo", valid_578818
  var valid_578819 = path.getOrDefault("number")
  valid_578819 = validateParameter(valid_578819, JInt, required = true, default = nil)
  if valid_578819 != nil:
    section.add "number", valid_578819
  var valid_578820 = path.getOrDefault("owner")
  valid_578820 = validateParameter(valid_578820, JString, required = true,
                                 default = nil)
  if valid_578820 != nil:
    section.add "owner", valid_578820
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578821 = header.getOrDefault("Accept")
  valid_578821 = validateParameter(valid_578821, JString, required = false,
                                 default = nil)
  if valid_578821 != nil:
    section.add "Accept", valid_578821
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578823: Call_PutReposOwnerRepoPullsNumberMerge_578815;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Merge a pull request (Merge Button's)
  ## 
  let valid = call_578823.validator(path, query, header, formData, body)
  let scheme = call_578823.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578823.url(scheme.get, call_578823.host, call_578823.base,
                         call_578823.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578823, url, valid)

proc call*(call_578824: Call_PutReposOwnerRepoPullsNumberMerge_578815;
          repo: string; number: int; owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## putReposOwnerRepoPullsNumberMerge
  ## Merge a pull request (Merge Button's)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Id of pull.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578825 = newJObject()
  var header_578826 = newJObject()
  var body_578827 = newJObject()
  add(path_578825, "repo", newJString(repo))
  add(path_578825, "number", newJInt(number))
  add(path_578825, "owner", newJString(owner))
  if body != nil:
    body_578827 = body
  add(header_578826, "Accept", newJString(Accept))
  result = call_578824.call(path_578825, nil, header_578826, nil, body_578827)

var putReposOwnerRepoPullsNumberMerge* = Call_PutReposOwnerRepoPullsNumberMerge_578815(
    name: "putReposOwnerRepoPullsNumberMerge", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/merge",
    validator: validate_PutReposOwnerRepoPullsNumberMerge_578816, base: "/",
    url: url_PutReposOwnerRepoPullsNumberMerge_578817, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberMerge_578804 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoPullsNumberMerge_578806(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/merge")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberMerge_578805(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get if a pull request has been merged.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578807 = path.getOrDefault("repo")
  valid_578807 = validateParameter(valid_578807, JString, required = true,
                                 default = nil)
  if valid_578807 != nil:
    section.add "repo", valid_578807
  var valid_578808 = path.getOrDefault("number")
  valid_578808 = validateParameter(valid_578808, JInt, required = true, default = nil)
  if valid_578808 != nil:
    section.add "number", valid_578808
  var valid_578809 = path.getOrDefault("owner")
  valid_578809 = validateParameter(valid_578809, JString, required = true,
                                 default = nil)
  if valid_578809 != nil:
    section.add "owner", valid_578809
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578810 = header.getOrDefault("Accept")
  valid_578810 = validateParameter(valid_578810, JString, required = false,
                                 default = nil)
  if valid_578810 != nil:
    section.add "Accept", valid_578810
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578811: Call_GetReposOwnerRepoPullsNumberMerge_578804;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get if a pull request has been merged.
  ## 
  let valid = call_578811.validator(path, query, header, formData, body)
  let scheme = call_578811.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578811.url(scheme.get, call_578811.host, call_578811.base,
                         call_578811.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578811, url, valid)

proc call*(call_578812: Call_GetReposOwnerRepoPullsNumberMerge_578804;
          repo: string; number: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberMerge
  ## Get if a pull request has been merged.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Id of pull.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578813 = newJObject()
  var header_578814 = newJObject()
  add(path_578813, "repo", newJString(repo))
  add(path_578813, "number", newJInt(number))
  add(path_578813, "owner", newJString(owner))
  add(header_578814, "Accept", newJString(Accept))
  result = call_578812.call(path_578813, nil, header_578814, nil, nil)

var getReposOwnerRepoPullsNumberMerge* = Call_GetReposOwnerRepoPullsNumberMerge_578804(
    name: "getReposOwnerRepoPullsNumberMerge", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/merge",
    validator: validate_GetReposOwnerRepoPullsNumberMerge_578805, base: "/",
    url: url_GetReposOwnerRepoPullsNumberMerge_578806, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReadme_578828 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoReadme_578830(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/readme")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReadme_578829(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the README.
  ## This method returns the preferred README for a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578831 = path.getOrDefault("repo")
  valid_578831 = validateParameter(valid_578831, JString, required = true,
                                 default = nil)
  if valid_578831 != nil:
    section.add "repo", valid_578831
  var valid_578832 = path.getOrDefault("owner")
  valid_578832 = validateParameter(valid_578832, JString, required = true,
                                 default = nil)
  if valid_578832 != nil:
    section.add "owner", valid_578832
  result.add "path", section
  ## parameters in `query` object:
  ##   ref: JString
  ##      : The String name of the Commit/Branch/Tag. Defaults to master.
  section = newJObject()
  var valid_578833 = query.getOrDefault("ref")
  valid_578833 = validateParameter(valid_578833, JString, required = false,
                                 default = nil)
  if valid_578833 != nil:
    section.add "ref", valid_578833
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578834 = header.getOrDefault("Accept")
  valid_578834 = validateParameter(valid_578834, JString, required = false,
                                 default = nil)
  if valid_578834 != nil:
    section.add "Accept", valid_578834
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578835: Call_GetReposOwnerRepoReadme_578828; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get the README.
  ## This method returns the preferred README for a repository.
  ## 
  ## 
  let valid = call_578835.validator(path, query, header, formData, body)
  let scheme = call_578835.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578835.url(scheme.get, call_578835.host, call_578835.base,
                         call_578835.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578835, url, valid)

proc call*(call_578836: Call_GetReposOwnerRepoReadme_578828; repo: string;
          owner: string; Accept: string = ""; `ref`: string = ""): Recallable =
  ## getReposOwnerRepoReadme
  ## Get the README.
  ## This method returns the preferred README for a repository.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   ref: string
  ##      : The String name of the Commit/Branch/Tag. Defaults to master.
  var path_578837 = newJObject()
  var query_578838 = newJObject()
  var header_578839 = newJObject()
  add(path_578837, "repo", newJString(repo))
  add(path_578837, "owner", newJString(owner))
  add(header_578839, "Accept", newJString(Accept))
  add(query_578838, "ref", newJString(`ref`))
  result = call_578836.call(path_578837, query_578838, header_578839, nil, nil)

var getReposOwnerRepoReadme* = Call_GetReposOwnerRepoReadme_578828(
    name: "getReposOwnerRepoReadme", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/readme",
    validator: validate_GetReposOwnerRepoReadme_578829, base: "/",
    url: url_GetReposOwnerRepoReadme_578830, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoReleases_578850 = ref object of OpenApiRestCall_576564
proc url_PostReposOwnerRepoReleases_578852(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoReleases_578851(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a release
  ## Users with push access to the repository can create a release.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578853 = path.getOrDefault("repo")
  valid_578853 = validateParameter(valid_578853, JString, required = true,
                                 default = nil)
  if valid_578853 != nil:
    section.add "repo", valid_578853
  var valid_578854 = path.getOrDefault("owner")
  valid_578854 = validateParameter(valid_578854, JString, required = true,
                                 default = nil)
  if valid_578854 != nil:
    section.add "owner", valid_578854
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578855 = header.getOrDefault("Accept")
  valid_578855 = validateParameter(valid_578855, JString, required = false,
                                 default = nil)
  if valid_578855 != nil:
    section.add "Accept", valid_578855
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578857: Call_PostReposOwnerRepoReleases_578850; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a release
  ## Users with push access to the repository can create a release.
  ## 
  ## 
  let valid = call_578857.validator(path, query, header, formData, body)
  let scheme = call_578857.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578857.url(scheme.get, call_578857.host, call_578857.base,
                         call_578857.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578857, url, valid)

proc call*(call_578858: Call_PostReposOwnerRepoReleases_578850; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoReleases
  ## Create a release
  ## Users with push access to the repository can create a release.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578859 = newJObject()
  var header_578860 = newJObject()
  var body_578861 = newJObject()
  add(path_578859, "repo", newJString(repo))
  add(path_578859, "owner", newJString(owner))
  if body != nil:
    body_578861 = body
  add(header_578860, "Accept", newJString(Accept))
  result = call_578858.call(path_578859, nil, header_578860, nil, body_578861)

var postReposOwnerRepoReleases* = Call_PostReposOwnerRepoReleases_578850(
    name: "postReposOwnerRepoReleases", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases",
    validator: validate_PostReposOwnerRepoReleases_578851, base: "/",
    url: url_PostReposOwnerRepoReleases_578852, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleases_578840 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoReleases_578842(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleases_578841(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Users with push access to the repository will receive all releases (i.e., published releases and draft releases). Users with pull access will receive published releases only
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578843 = path.getOrDefault("repo")
  valid_578843 = validateParameter(valid_578843, JString, required = true,
                                 default = nil)
  if valid_578843 != nil:
    section.add "repo", valid_578843
  var valid_578844 = path.getOrDefault("owner")
  valid_578844 = validateParameter(valid_578844, JString, required = true,
                                 default = nil)
  if valid_578844 != nil:
    section.add "owner", valid_578844
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578845 = header.getOrDefault("Accept")
  valid_578845 = validateParameter(valid_578845, JString, required = false,
                                 default = nil)
  if valid_578845 != nil:
    section.add "Accept", valid_578845
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578846: Call_GetReposOwnerRepoReleases_578840; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Users with push access to the repository will receive all releases (i.e., published releases and draft releases). Users with pull access will receive published releases only
  ## 
  let valid = call_578846.validator(path, query, header, formData, body)
  let scheme = call_578846.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578846.url(scheme.get, call_578846.host, call_578846.base,
                         call_578846.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578846, url, valid)

proc call*(call_578847: Call_GetReposOwnerRepoReleases_578840; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleases
  ## Users with push access to the repository will receive all releases (i.e., published releases and draft releases). Users with pull access will receive published releases only
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578848 = newJObject()
  var header_578849 = newJObject()
  add(path_578848, "repo", newJString(repo))
  add(path_578848, "owner", newJString(owner))
  add(header_578849, "Accept", newJString(Accept))
  result = call_578847.call(path_578848, nil, header_578849, nil, nil)

var getReposOwnerRepoReleases* = Call_GetReposOwnerRepoReleases_578840(
    name: "getReposOwnerRepoReleases", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases",
    validator: validate_GetReposOwnerRepoReleases_578841, base: "/",
    url: url_GetReposOwnerRepoReleases_578842, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleasesAssetsId_578862 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoReleasesAssetsId_578864(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/assets/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleasesAssetsId_578863(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single release asset
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   id: JString (required)
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578865 = path.getOrDefault("repo")
  valid_578865 = validateParameter(valid_578865, JString, required = true,
                                 default = nil)
  if valid_578865 != nil:
    section.add "repo", valid_578865
  var valid_578866 = path.getOrDefault("id")
  valid_578866 = validateParameter(valid_578866, JString, required = true,
                                 default = nil)
  if valid_578866 != nil:
    section.add "id", valid_578866
  var valid_578867 = path.getOrDefault("owner")
  valid_578867 = validateParameter(valid_578867, JString, required = true,
                                 default = nil)
  if valid_578867 != nil:
    section.add "owner", valid_578867
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578868 = header.getOrDefault("Accept")
  valid_578868 = validateParameter(valid_578868, JString, required = false,
                                 default = nil)
  if valid_578868 != nil:
    section.add "Accept", valid_578868
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578869: Call_GetReposOwnerRepoReleasesAssetsId_578862;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single release asset
  ## 
  let valid = call_578869.validator(path, query, header, formData, body)
  let scheme = call_578869.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578869.url(scheme.get, call_578869.host, call_578869.base,
                         call_578869.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578869, url, valid)

proc call*(call_578870: Call_GetReposOwnerRepoReleasesAssetsId_578862;
          repo: string; id: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleasesAssetsId
  ## Get a single release asset
  ##   repo: string (required)
  ##       : Name of repository.
  ##   id: string (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578871 = newJObject()
  var header_578872 = newJObject()
  add(path_578871, "repo", newJString(repo))
  add(path_578871, "id", newJString(id))
  add(path_578871, "owner", newJString(owner))
  add(header_578872, "Accept", newJString(Accept))
  result = call_578870.call(path_578871, nil, header_578872, nil, nil)

var getReposOwnerRepoReleasesAssetsId* = Call_GetReposOwnerRepoReleasesAssetsId_578862(
    name: "getReposOwnerRepoReleasesAssetsId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/assets/{id}",
    validator: validate_GetReposOwnerRepoReleasesAssetsId_578863, base: "/",
    url: url_GetReposOwnerRepoReleasesAssetsId_578864, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoReleasesAssetsId_578884 = ref object of OpenApiRestCall_576564
proc url_PatchReposOwnerRepoReleasesAssetsId_578886(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/assets/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoReleasesAssetsId_578885(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Edit a release asset
  ## Users with push access to the repository can edit a release asset.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   id: JString (required)
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578887 = path.getOrDefault("repo")
  valid_578887 = validateParameter(valid_578887, JString, required = true,
                                 default = nil)
  if valid_578887 != nil:
    section.add "repo", valid_578887
  var valid_578888 = path.getOrDefault("id")
  valid_578888 = validateParameter(valid_578888, JString, required = true,
                                 default = nil)
  if valid_578888 != nil:
    section.add "id", valid_578888
  var valid_578889 = path.getOrDefault("owner")
  valid_578889 = validateParameter(valid_578889, JString, required = true,
                                 default = nil)
  if valid_578889 != nil:
    section.add "owner", valid_578889
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578890 = header.getOrDefault("Accept")
  valid_578890 = validateParameter(valid_578890, JString, required = false,
                                 default = nil)
  if valid_578890 != nil:
    section.add "Accept", valid_578890
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578892: Call_PatchReposOwnerRepoReleasesAssetsId_578884;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Edit a release asset
  ## Users with push access to the repository can edit a release asset.
  ## 
  ## 
  let valid = call_578892.validator(path, query, header, formData, body)
  let scheme = call_578892.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578892.url(scheme.get, call_578892.host, call_578892.base,
                         call_578892.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578892, url, valid)

proc call*(call_578893: Call_PatchReposOwnerRepoReleasesAssetsId_578884;
          repo: string; id: string; owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoReleasesAssetsId
  ## Edit a release asset
  ## Users with push access to the repository can edit a release asset.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   id: string (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578894 = newJObject()
  var header_578895 = newJObject()
  var body_578896 = newJObject()
  add(path_578894, "repo", newJString(repo))
  add(path_578894, "id", newJString(id))
  add(path_578894, "owner", newJString(owner))
  if body != nil:
    body_578896 = body
  add(header_578895, "Accept", newJString(Accept))
  result = call_578893.call(path_578894, nil, header_578895, nil, body_578896)

var patchReposOwnerRepoReleasesAssetsId* = Call_PatchReposOwnerRepoReleasesAssetsId_578884(
    name: "patchReposOwnerRepoReleasesAssetsId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/assets/{id}",
    validator: validate_PatchReposOwnerRepoReleasesAssetsId_578885, base: "/",
    url: url_PatchReposOwnerRepoReleasesAssetsId_578886, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoReleasesAssetsId_578873 = ref object of OpenApiRestCall_576564
proc url_DeleteReposOwnerRepoReleasesAssetsId_578875(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/assets/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoReleasesAssetsId_578874(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a release asset
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   id: JString (required)
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578876 = path.getOrDefault("repo")
  valid_578876 = validateParameter(valid_578876, JString, required = true,
                                 default = nil)
  if valid_578876 != nil:
    section.add "repo", valid_578876
  var valid_578877 = path.getOrDefault("id")
  valid_578877 = validateParameter(valid_578877, JString, required = true,
                                 default = nil)
  if valid_578877 != nil:
    section.add "id", valid_578877
  var valid_578878 = path.getOrDefault("owner")
  valid_578878 = validateParameter(valid_578878, JString, required = true,
                                 default = nil)
  if valid_578878 != nil:
    section.add "owner", valid_578878
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578879 = header.getOrDefault("Accept")
  valid_578879 = validateParameter(valid_578879, JString, required = false,
                                 default = nil)
  if valid_578879 != nil:
    section.add "Accept", valid_578879
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578880: Call_DeleteReposOwnerRepoReleasesAssetsId_578873;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a release asset
  ## 
  let valid = call_578880.validator(path, query, header, formData, body)
  let scheme = call_578880.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578880.url(scheme.get, call_578880.host, call_578880.base,
                         call_578880.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578880, url, valid)

proc call*(call_578881: Call_DeleteReposOwnerRepoReleasesAssetsId_578873;
          repo: string; id: string; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoReleasesAssetsId
  ## Delete a release asset
  ##   repo: string (required)
  ##       : Name of repository.
  ##   id: string (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578882 = newJObject()
  var header_578883 = newJObject()
  add(path_578882, "repo", newJString(repo))
  add(path_578882, "id", newJString(id))
  add(path_578882, "owner", newJString(owner))
  add(header_578883, "Accept", newJString(Accept))
  result = call_578881.call(path_578882, nil, header_578883, nil, nil)

var deleteReposOwnerRepoReleasesAssetsId* = Call_DeleteReposOwnerRepoReleasesAssetsId_578873(
    name: "deleteReposOwnerRepoReleasesAssetsId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/assets/{id}",
    validator: validate_DeleteReposOwnerRepoReleasesAssetsId_578874, base: "/",
    url: url_DeleteReposOwnerRepoReleasesAssetsId_578875, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleasesId_578897 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoReleasesId_578899(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleasesId_578898(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single release
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   id: JString (required)
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578900 = path.getOrDefault("repo")
  valid_578900 = validateParameter(valid_578900, JString, required = true,
                                 default = nil)
  if valid_578900 != nil:
    section.add "repo", valid_578900
  var valid_578901 = path.getOrDefault("id")
  valid_578901 = validateParameter(valid_578901, JString, required = true,
                                 default = nil)
  if valid_578901 != nil:
    section.add "id", valid_578901
  var valid_578902 = path.getOrDefault("owner")
  valid_578902 = validateParameter(valid_578902, JString, required = true,
                                 default = nil)
  if valid_578902 != nil:
    section.add "owner", valid_578902
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578903 = header.getOrDefault("Accept")
  valid_578903 = validateParameter(valid_578903, JString, required = false,
                                 default = nil)
  if valid_578903 != nil:
    section.add "Accept", valid_578903
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578904: Call_GetReposOwnerRepoReleasesId_578897; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a single release
  ## 
  let valid = call_578904.validator(path, query, header, formData, body)
  let scheme = call_578904.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578904.url(scheme.get, call_578904.host, call_578904.base,
                         call_578904.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578904, url, valid)

proc call*(call_578905: Call_GetReposOwnerRepoReleasesId_578897; repo: string;
          id: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleasesId
  ## Get a single release
  ##   repo: string (required)
  ##       : Name of repository.
  ##   id: string (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578906 = newJObject()
  var header_578907 = newJObject()
  add(path_578906, "repo", newJString(repo))
  add(path_578906, "id", newJString(id))
  add(path_578906, "owner", newJString(owner))
  add(header_578907, "Accept", newJString(Accept))
  result = call_578905.call(path_578906, nil, header_578907, nil, nil)

var getReposOwnerRepoReleasesId* = Call_GetReposOwnerRepoReleasesId_578897(
    name: "getReposOwnerRepoReleasesId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}",
    validator: validate_GetReposOwnerRepoReleasesId_578898, base: "/",
    url: url_GetReposOwnerRepoReleasesId_578899, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoReleasesId_578919 = ref object of OpenApiRestCall_576564
proc url_PatchReposOwnerRepoReleasesId_578921(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoReleasesId_578920(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Users with push access to the repository can edit a release
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   id: JString (required)
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578922 = path.getOrDefault("repo")
  valid_578922 = validateParameter(valid_578922, JString, required = true,
                                 default = nil)
  if valid_578922 != nil:
    section.add "repo", valid_578922
  var valid_578923 = path.getOrDefault("id")
  valid_578923 = validateParameter(valid_578923, JString, required = true,
                                 default = nil)
  if valid_578923 != nil:
    section.add "id", valid_578923
  var valid_578924 = path.getOrDefault("owner")
  valid_578924 = validateParameter(valid_578924, JString, required = true,
                                 default = nil)
  if valid_578924 != nil:
    section.add "owner", valid_578924
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578925 = header.getOrDefault("Accept")
  valid_578925 = validateParameter(valid_578925, JString, required = false,
                                 default = nil)
  if valid_578925 != nil:
    section.add "Accept", valid_578925
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_578927: Call_PatchReposOwnerRepoReleasesId_578919; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Users with push access to the repository can edit a release
  ## 
  let valid = call_578927.validator(path, query, header, formData, body)
  let scheme = call_578927.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578927.url(scheme.get, call_578927.host, call_578927.base,
                         call_578927.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578927, url, valid)

proc call*(call_578928: Call_PatchReposOwnerRepoReleasesId_578919; repo: string;
          id: string; owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoReleasesId
  ## Users with push access to the repository can edit a release
  ##   repo: string (required)
  ##       : Name of repository.
  ##   id: string (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578929 = newJObject()
  var header_578930 = newJObject()
  var body_578931 = newJObject()
  add(path_578929, "repo", newJString(repo))
  add(path_578929, "id", newJString(id))
  add(path_578929, "owner", newJString(owner))
  if body != nil:
    body_578931 = body
  add(header_578930, "Accept", newJString(Accept))
  result = call_578928.call(path_578929, nil, header_578930, nil, body_578931)

var patchReposOwnerRepoReleasesId* = Call_PatchReposOwnerRepoReleasesId_578919(
    name: "patchReposOwnerRepoReleasesId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}",
    validator: validate_PatchReposOwnerRepoReleasesId_578920, base: "/",
    url: url_PatchReposOwnerRepoReleasesId_578921, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoReleasesId_578908 = ref object of OpenApiRestCall_576564
proc url_DeleteReposOwnerRepoReleasesId_578910(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoReleasesId_578909(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Users with push access to the repository can delete a release.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   id: JString (required)
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578911 = path.getOrDefault("repo")
  valid_578911 = validateParameter(valid_578911, JString, required = true,
                                 default = nil)
  if valid_578911 != nil:
    section.add "repo", valid_578911
  var valid_578912 = path.getOrDefault("id")
  valid_578912 = validateParameter(valid_578912, JString, required = true,
                                 default = nil)
  if valid_578912 != nil:
    section.add "id", valid_578912
  var valid_578913 = path.getOrDefault("owner")
  valid_578913 = validateParameter(valid_578913, JString, required = true,
                                 default = nil)
  if valid_578913 != nil:
    section.add "owner", valid_578913
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578914 = header.getOrDefault("Accept")
  valid_578914 = validateParameter(valid_578914, JString, required = false,
                                 default = nil)
  if valid_578914 != nil:
    section.add "Accept", valid_578914
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578915: Call_DeleteReposOwnerRepoReleasesId_578908; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Users with push access to the repository can delete a release.
  ## 
  let valid = call_578915.validator(path, query, header, formData, body)
  let scheme = call_578915.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578915.url(scheme.get, call_578915.host, call_578915.base,
                         call_578915.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578915, url, valid)

proc call*(call_578916: Call_DeleteReposOwnerRepoReleasesId_578908; repo: string;
          id: string; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoReleasesId
  ## Users with push access to the repository can delete a release.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   id: string (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578917 = newJObject()
  var header_578918 = newJObject()
  add(path_578917, "repo", newJString(repo))
  add(path_578917, "id", newJString(id))
  add(path_578917, "owner", newJString(owner))
  add(header_578918, "Accept", newJString(Accept))
  result = call_578916.call(path_578917, nil, header_578918, nil, nil)

var deleteReposOwnerRepoReleasesId* = Call_DeleteReposOwnerRepoReleasesId_578908(
    name: "deleteReposOwnerRepoReleasesId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}",
    validator: validate_DeleteReposOwnerRepoReleasesId_578909, base: "/",
    url: url_DeleteReposOwnerRepoReleasesId_578910, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleasesIdAssets_578932 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoReleasesIdAssets_578934(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/assets")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleasesIdAssets_578933(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List assets for a release
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   id: JString (required)
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578935 = path.getOrDefault("repo")
  valid_578935 = validateParameter(valid_578935, JString, required = true,
                                 default = nil)
  if valid_578935 != nil:
    section.add "repo", valid_578935
  var valid_578936 = path.getOrDefault("id")
  valid_578936 = validateParameter(valid_578936, JString, required = true,
                                 default = nil)
  if valid_578936 != nil:
    section.add "id", valid_578936
  var valid_578937 = path.getOrDefault("owner")
  valid_578937 = validateParameter(valid_578937, JString, required = true,
                                 default = nil)
  if valid_578937 != nil:
    section.add "owner", valid_578937
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578938 = header.getOrDefault("Accept")
  valid_578938 = validateParameter(valid_578938, JString, required = false,
                                 default = nil)
  if valid_578938 != nil:
    section.add "Accept", valid_578938
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578939: Call_GetReposOwnerRepoReleasesIdAssets_578932;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List assets for a release
  ## 
  let valid = call_578939.validator(path, query, header, formData, body)
  let scheme = call_578939.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578939.url(scheme.get, call_578939.host, call_578939.base,
                         call_578939.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578939, url, valid)

proc call*(call_578940: Call_GetReposOwnerRepoReleasesIdAssets_578932;
          repo: string; id: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleasesIdAssets
  ## List assets for a release
  ##   repo: string (required)
  ##       : Name of repository.
  ##   id: string (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578941 = newJObject()
  var header_578942 = newJObject()
  add(path_578941, "repo", newJString(repo))
  add(path_578941, "id", newJString(id))
  add(path_578941, "owner", newJString(owner))
  add(header_578942, "Accept", newJString(Accept))
  result = call_578940.call(path_578941, nil, header_578942, nil, nil)

var getReposOwnerRepoReleasesIdAssets* = Call_GetReposOwnerRepoReleasesIdAssets_578932(
    name: "getReposOwnerRepoReleasesIdAssets", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}/assets",
    validator: validate_GetReposOwnerRepoReleasesIdAssets_578933, base: "/",
    url: url_GetReposOwnerRepoReleasesIdAssets_578934, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStargazers_578943 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoStargazers_578945(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stargazers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStargazers_578944(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List Stargazers.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578946 = path.getOrDefault("repo")
  valid_578946 = validateParameter(valid_578946, JString, required = true,
                                 default = nil)
  if valid_578946 != nil:
    section.add "repo", valid_578946
  var valid_578947 = path.getOrDefault("owner")
  valid_578947 = validateParameter(valid_578947, JString, required = true,
                                 default = nil)
  if valid_578947 != nil:
    section.add "owner", valid_578947
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578948 = header.getOrDefault("Accept")
  valid_578948 = validateParameter(valid_578948, JString, required = false,
                                 default = nil)
  if valid_578948 != nil:
    section.add "Accept", valid_578948
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578949: Call_GetReposOwnerRepoStargazers_578943; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List Stargazers.
  ## 
  let valid = call_578949.validator(path, query, header, formData, body)
  let scheme = call_578949.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578949.url(scheme.get, call_578949.host, call_578949.base,
                         call_578949.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578949, url, valid)

proc call*(call_578950: Call_GetReposOwnerRepoStargazers_578943; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStargazers
  ## List Stargazers.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578951 = newJObject()
  var header_578952 = newJObject()
  add(path_578951, "repo", newJString(repo))
  add(path_578951, "owner", newJString(owner))
  add(header_578952, "Accept", newJString(Accept))
  result = call_578950.call(path_578951, nil, header_578952, nil, nil)

var getReposOwnerRepoStargazers* = Call_GetReposOwnerRepoStargazers_578943(
    name: "getReposOwnerRepoStargazers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stargazers",
    validator: validate_GetReposOwnerRepoStargazers_578944, base: "/",
    url: url_GetReposOwnerRepoStargazers_578945, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsCodeFrequency_578953 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoStatsCodeFrequency_578955(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/code_frequency")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsCodeFrequency_578954(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the number of additions and deletions per week.
  ## Returns a weekly aggregate of the number of additions and deletions pushed
  ## to a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578956 = path.getOrDefault("repo")
  valid_578956 = validateParameter(valid_578956, JString, required = true,
                                 default = nil)
  if valid_578956 != nil:
    section.add "repo", valid_578956
  var valid_578957 = path.getOrDefault("owner")
  valid_578957 = validateParameter(valid_578957, JString, required = true,
                                 default = nil)
  if valid_578957 != nil:
    section.add "owner", valid_578957
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578958 = header.getOrDefault("Accept")
  valid_578958 = validateParameter(valid_578958, JString, required = false,
                                 default = nil)
  if valid_578958 != nil:
    section.add "Accept", valid_578958
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578959: Call_GetReposOwnerRepoStatsCodeFrequency_578953;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get the number of additions and deletions per week.
  ## Returns a weekly aggregate of the number of additions and deletions pushed
  ## to a repository.
  ## 
  ## 
  let valid = call_578959.validator(path, query, header, formData, body)
  let scheme = call_578959.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578959.url(scheme.get, call_578959.host, call_578959.base,
                         call_578959.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578959, url, valid)

proc call*(call_578960: Call_GetReposOwnerRepoStatsCodeFrequency_578953;
          repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsCodeFrequency
  ## Get the number of additions and deletions per week.
  ## Returns a weekly aggregate of the number of additions and deletions pushed
  ## to a repository.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578961 = newJObject()
  var header_578962 = newJObject()
  add(path_578961, "repo", newJString(repo))
  add(path_578961, "owner", newJString(owner))
  add(header_578962, "Accept", newJString(Accept))
  result = call_578960.call(path_578961, nil, header_578962, nil, nil)

var getReposOwnerRepoStatsCodeFrequency* = Call_GetReposOwnerRepoStatsCodeFrequency_578953(
    name: "getReposOwnerRepoStatsCodeFrequency", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/code_frequency",
    validator: validate_GetReposOwnerRepoStatsCodeFrequency_578954, base: "/",
    url: url_GetReposOwnerRepoStatsCodeFrequency_578955, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsCommitActivity_578963 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoStatsCommitActivity_578965(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/commit_activity")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsCommitActivity_578964(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the last year of commit activity data.
  ## Returns the last year of commit activity grouped by week. The days array
  ## is a group of commits per day, starting on Sunday.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578966 = path.getOrDefault("repo")
  valid_578966 = validateParameter(valid_578966, JString, required = true,
                                 default = nil)
  if valid_578966 != nil:
    section.add "repo", valid_578966
  var valid_578967 = path.getOrDefault("owner")
  valid_578967 = validateParameter(valid_578967, JString, required = true,
                                 default = nil)
  if valid_578967 != nil:
    section.add "owner", valid_578967
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578968 = header.getOrDefault("Accept")
  valid_578968 = validateParameter(valid_578968, JString, required = false,
                                 default = nil)
  if valid_578968 != nil:
    section.add "Accept", valid_578968
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578969: Call_GetReposOwnerRepoStatsCommitActivity_578963;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get the last year of commit activity data.
  ## Returns the last year of commit activity grouped by week. The days array
  ## is a group of commits per day, starting on Sunday.
  ## 
  ## 
  let valid = call_578969.validator(path, query, header, formData, body)
  let scheme = call_578969.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578969.url(scheme.get, call_578969.host, call_578969.base,
                         call_578969.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578969, url, valid)

proc call*(call_578970: Call_GetReposOwnerRepoStatsCommitActivity_578963;
          repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsCommitActivity
  ## Get the last year of commit activity data.
  ## Returns the last year of commit activity grouped by week. The days array
  ## is a group of commits per day, starting on Sunday.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578971 = newJObject()
  var header_578972 = newJObject()
  add(path_578971, "repo", newJString(repo))
  add(path_578971, "owner", newJString(owner))
  add(header_578972, "Accept", newJString(Accept))
  result = call_578970.call(path_578971, nil, header_578972, nil, nil)

var getReposOwnerRepoStatsCommitActivity* = Call_GetReposOwnerRepoStatsCommitActivity_578963(
    name: "getReposOwnerRepoStatsCommitActivity", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/commit_activity",
    validator: validate_GetReposOwnerRepoStatsCommitActivity_578964, base: "/",
    url: url_GetReposOwnerRepoStatsCommitActivity_578965, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsContributors_578973 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoStatsContributors_578975(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/contributors")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsContributors_578974(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get contributors list with additions, deletions, and commit counts.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578976 = path.getOrDefault("repo")
  valid_578976 = validateParameter(valid_578976, JString, required = true,
                                 default = nil)
  if valid_578976 != nil:
    section.add "repo", valid_578976
  var valid_578977 = path.getOrDefault("owner")
  valid_578977 = validateParameter(valid_578977, JString, required = true,
                                 default = nil)
  if valid_578977 != nil:
    section.add "owner", valid_578977
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578978 = header.getOrDefault("Accept")
  valid_578978 = validateParameter(valid_578978, JString, required = false,
                                 default = nil)
  if valid_578978 != nil:
    section.add "Accept", valid_578978
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578979: Call_GetReposOwnerRepoStatsContributors_578973;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get contributors list with additions, deletions, and commit counts.
  ## 
  let valid = call_578979.validator(path, query, header, formData, body)
  let scheme = call_578979.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578979.url(scheme.get, call_578979.host, call_578979.base,
                         call_578979.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578979, url, valid)

proc call*(call_578980: Call_GetReposOwnerRepoStatsContributors_578973;
          repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsContributors
  ## Get contributors list with additions, deletions, and commit counts.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578981 = newJObject()
  var header_578982 = newJObject()
  add(path_578981, "repo", newJString(repo))
  add(path_578981, "owner", newJString(owner))
  add(header_578982, "Accept", newJString(Accept))
  result = call_578980.call(path_578981, nil, header_578982, nil, nil)

var getReposOwnerRepoStatsContributors* = Call_GetReposOwnerRepoStatsContributors_578973(
    name: "getReposOwnerRepoStatsContributors", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/contributors",
    validator: validate_GetReposOwnerRepoStatsContributors_578974, base: "/",
    url: url_GetReposOwnerRepoStatsContributors_578975, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsParticipation_578983 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoStatsParticipation_578985(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/participation")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsParticipation_578984(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the weekly commit count for the repo owner and everyone else.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578986 = path.getOrDefault("repo")
  valid_578986 = validateParameter(valid_578986, JString, required = true,
                                 default = nil)
  if valid_578986 != nil:
    section.add "repo", valid_578986
  var valid_578987 = path.getOrDefault("owner")
  valid_578987 = validateParameter(valid_578987, JString, required = true,
                                 default = nil)
  if valid_578987 != nil:
    section.add "owner", valid_578987
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578988 = header.getOrDefault("Accept")
  valid_578988 = validateParameter(valid_578988, JString, required = false,
                                 default = nil)
  if valid_578988 != nil:
    section.add "Accept", valid_578988
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578989: Call_GetReposOwnerRepoStatsParticipation_578983;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get the weekly commit count for the repo owner and everyone else.
  ## 
  let valid = call_578989.validator(path, query, header, formData, body)
  let scheme = call_578989.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578989.url(scheme.get, call_578989.host, call_578989.base,
                         call_578989.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578989, url, valid)

proc call*(call_578990: Call_GetReposOwnerRepoStatsParticipation_578983;
          repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsParticipation
  ## Get the weekly commit count for the repo owner and everyone else.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_578991 = newJObject()
  var header_578992 = newJObject()
  add(path_578991, "repo", newJString(repo))
  add(path_578991, "owner", newJString(owner))
  add(header_578992, "Accept", newJString(Accept))
  result = call_578990.call(path_578991, nil, header_578992, nil, nil)

var getReposOwnerRepoStatsParticipation* = Call_GetReposOwnerRepoStatsParticipation_578983(
    name: "getReposOwnerRepoStatsParticipation", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/participation",
    validator: validate_GetReposOwnerRepoStatsParticipation_578984, base: "/",
    url: url_GetReposOwnerRepoStatsParticipation_578985, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsPunchCard_578993 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoStatsPunchCard_578995(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/punch_card")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsPunchCard_578994(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the number of commits per hour in each day.
  ## Each array contains the day number, hour number, and number of commits
  ## 0-6 Sunday - Saturday
  ## 0-23 Hour of day
  ## Number of commits
  ## 
  ## For example, [2, 14, 25] indicates that there were 25 total commits, during
  ## the 2.00pm hour on Tuesdays. All times are based on the time zone of
  ## individual commits.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_578996 = path.getOrDefault("repo")
  valid_578996 = validateParameter(valid_578996, JString, required = true,
                                 default = nil)
  if valid_578996 != nil:
    section.add "repo", valid_578996
  var valid_578997 = path.getOrDefault("owner")
  valid_578997 = validateParameter(valid_578997, JString, required = true,
                                 default = nil)
  if valid_578997 != nil:
    section.add "owner", valid_578997
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_578998 = header.getOrDefault("Accept")
  valid_578998 = validateParameter(valid_578998, JString, required = false,
                                 default = nil)
  if valid_578998 != nil:
    section.add "Accept", valid_578998
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_578999: Call_GetReposOwnerRepoStatsPunchCard_578993;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get the number of commits per hour in each day.
  ## Each array contains the day number, hour number, and number of commits
  ## 0-6 Sunday - Saturday
  ## 0-23 Hour of day
  ## Number of commits
  ## 
  ## For example, [2, 14, 25] indicates that there were 25 total commits, during
  ## the 2.00pm hour on Tuesdays. All times are based on the time zone of
  ## individual commits.
  ## 
  ## 
  let valid = call_578999.validator(path, query, header, formData, body)
  let scheme = call_578999.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_578999.url(scheme.get, call_578999.host, call_578999.base,
                         call_578999.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_578999, url, valid)

proc call*(call_579000: Call_GetReposOwnerRepoStatsPunchCard_578993; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsPunchCard
  ## Get the number of commits per hour in each day.
  ## Each array contains the day number, hour number, and number of commits
  ## 0-6 Sunday - Saturday
  ## 0-23 Hour of day
  ## Number of commits
  ## 
  ## For example, [2, 14, 25] indicates that there were 25 total commits, during
  ## the 2.00pm hour on Tuesdays. All times are based on the time zone of
  ## individual commits.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579001 = newJObject()
  var header_579002 = newJObject()
  add(path_579001, "repo", newJString(repo))
  add(path_579001, "owner", newJString(owner))
  add(header_579002, "Accept", newJString(Accept))
  result = call_579000.call(path_579001, nil, header_579002, nil, nil)

var getReposOwnerRepoStatsPunchCard* = Call_GetReposOwnerRepoStatsPunchCard_578993(
    name: "getReposOwnerRepoStatsPunchCard", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/punch_card",
    validator: validate_GetReposOwnerRepoStatsPunchCard_578994, base: "/",
    url: url_GetReposOwnerRepoStatsPunchCard_578995, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoStatusesRef_579014 = ref object of OpenApiRestCall_576564
proc url_PostReposOwnerRepoStatusesRef_579016(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/statuses/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoStatusesRef_579015(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a Status.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   ref: JString (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_579017 = path.getOrDefault("repo")
  valid_579017 = validateParameter(valid_579017, JString, required = true,
                                 default = nil)
  if valid_579017 != nil:
    section.add "repo", valid_579017
  var valid_579018 = path.getOrDefault("ref")
  valid_579018 = validateParameter(valid_579018, JString, required = true,
                                 default = nil)
  if valid_579018 != nil:
    section.add "ref", valid_579018
  var valid_579019 = path.getOrDefault("owner")
  valid_579019 = validateParameter(valid_579019, JString, required = true,
                                 default = nil)
  if valid_579019 != nil:
    section.add "owner", valid_579019
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579020 = header.getOrDefault("Accept")
  valid_579020 = validateParameter(valid_579020, JString, required = false,
                                 default = nil)
  if valid_579020 != nil:
    section.add "Accept", valid_579020
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579022: Call_PostReposOwnerRepoStatusesRef_579014; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a Status.
  ## 
  let valid = call_579022.validator(path, query, header, formData, body)
  let scheme = call_579022.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579022.url(scheme.get, call_579022.host, call_579022.base,
                         call_579022.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579022, url, valid)

proc call*(call_579023: Call_PostReposOwnerRepoStatusesRef_579014; repo: string;
          `ref`: string; owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoStatusesRef
  ## Create a Status.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   ref: string (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579024 = newJObject()
  var header_579025 = newJObject()
  var body_579026 = newJObject()
  add(path_579024, "repo", newJString(repo))
  add(path_579024, "ref", newJString(`ref`))
  add(path_579024, "owner", newJString(owner))
  if body != nil:
    body_579026 = body
  add(header_579025, "Accept", newJString(Accept))
  result = call_579023.call(path_579024, nil, header_579025, nil, body_579026)

var postReposOwnerRepoStatusesRef* = Call_PostReposOwnerRepoStatusesRef_579014(
    name: "postReposOwnerRepoStatusesRef", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/statuses/{ref}",
    validator: validate_PostReposOwnerRepoStatusesRef_579015, base: "/",
    url: url_PostReposOwnerRepoStatusesRef_579016, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatusesRef_579003 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoStatusesRef_579005(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/statuses/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatusesRef_579004(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List Statuses for a specific Ref.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   ref: JString (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_579006 = path.getOrDefault("repo")
  valid_579006 = validateParameter(valid_579006, JString, required = true,
                                 default = nil)
  if valid_579006 != nil:
    section.add "repo", valid_579006
  var valid_579007 = path.getOrDefault("ref")
  valid_579007 = validateParameter(valid_579007, JString, required = true,
                                 default = nil)
  if valid_579007 != nil:
    section.add "ref", valid_579007
  var valid_579008 = path.getOrDefault("owner")
  valid_579008 = validateParameter(valid_579008, JString, required = true,
                                 default = nil)
  if valid_579008 != nil:
    section.add "owner", valid_579008
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579009 = header.getOrDefault("Accept")
  valid_579009 = validateParameter(valid_579009, JString, required = false,
                                 default = nil)
  if valid_579009 != nil:
    section.add "Accept", valid_579009
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579010: Call_GetReposOwnerRepoStatusesRef_579003; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List Statuses for a specific Ref.
  ## 
  let valid = call_579010.validator(path, query, header, formData, body)
  let scheme = call_579010.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579010.url(scheme.get, call_579010.host, call_579010.base,
                         call_579010.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579010, url, valid)

proc call*(call_579011: Call_GetReposOwnerRepoStatusesRef_579003; repo: string;
          `ref`: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatusesRef
  ## List Statuses for a specific Ref.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   ref: string (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579012 = newJObject()
  var header_579013 = newJObject()
  add(path_579012, "repo", newJString(repo))
  add(path_579012, "ref", newJString(`ref`))
  add(path_579012, "owner", newJString(owner))
  add(header_579013, "Accept", newJString(Accept))
  result = call_579011.call(path_579012, nil, header_579013, nil, nil)

var getReposOwnerRepoStatusesRef* = Call_GetReposOwnerRepoStatusesRef_579003(
    name: "getReposOwnerRepoStatusesRef", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/statuses/{ref}",
    validator: validate_GetReposOwnerRepoStatusesRef_579004, base: "/",
    url: url_GetReposOwnerRepoStatusesRef_579005, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoSubscribers_579027 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoSubscribers_579029(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/subscribers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoSubscribers_579028(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List watchers.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_579030 = path.getOrDefault("repo")
  valid_579030 = validateParameter(valid_579030, JString, required = true,
                                 default = nil)
  if valid_579030 != nil:
    section.add "repo", valid_579030
  var valid_579031 = path.getOrDefault("owner")
  valid_579031 = validateParameter(valid_579031, JString, required = true,
                                 default = nil)
  if valid_579031 != nil:
    section.add "owner", valid_579031
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579032 = header.getOrDefault("Accept")
  valid_579032 = validateParameter(valid_579032, JString, required = false,
                                 default = nil)
  if valid_579032 != nil:
    section.add "Accept", valid_579032
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579033: Call_GetReposOwnerRepoSubscribers_579027; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List watchers.
  ## 
  let valid = call_579033.validator(path, query, header, formData, body)
  let scheme = call_579033.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579033.url(scheme.get, call_579033.host, call_579033.base,
                         call_579033.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579033, url, valid)

proc call*(call_579034: Call_GetReposOwnerRepoSubscribers_579027; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoSubscribers
  ## List watchers.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579035 = newJObject()
  var header_579036 = newJObject()
  add(path_579035, "repo", newJString(repo))
  add(path_579035, "owner", newJString(owner))
  add(header_579036, "Accept", newJString(Accept))
  result = call_579034.call(path_579035, nil, header_579036, nil, nil)

var getReposOwnerRepoSubscribers* = Call_GetReposOwnerRepoSubscribers_579027(
    name: "getReposOwnerRepoSubscribers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscribers",
    validator: validate_GetReposOwnerRepoSubscribers_579028, base: "/",
    url: url_GetReposOwnerRepoSubscribers_579029, schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoSubscription_579047 = ref object of OpenApiRestCall_576564
proc url_PutReposOwnerRepoSubscription_579049(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoSubscription_579048(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set a Repository Subscription
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_579050 = path.getOrDefault("repo")
  valid_579050 = validateParameter(valid_579050, JString, required = true,
                                 default = nil)
  if valid_579050 != nil:
    section.add "repo", valid_579050
  var valid_579051 = path.getOrDefault("owner")
  valid_579051 = validateParameter(valid_579051, JString, required = true,
                                 default = nil)
  if valid_579051 != nil:
    section.add "owner", valid_579051
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579052 = header.getOrDefault("Accept")
  valid_579052 = validateParameter(valid_579052, JString, required = false,
                                 default = nil)
  if valid_579052 != nil:
    section.add "Accept", valid_579052
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579054: Call_PutReposOwnerRepoSubscription_579047; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Set a Repository Subscription
  ## 
  let valid = call_579054.validator(path, query, header, formData, body)
  let scheme = call_579054.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579054.url(scheme.get, call_579054.host, call_579054.base,
                         call_579054.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579054, url, valid)

proc call*(call_579055: Call_PutReposOwnerRepoSubscription_579047; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## putReposOwnerRepoSubscription
  ## Set a Repository Subscription
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579056 = newJObject()
  var header_579057 = newJObject()
  var body_579058 = newJObject()
  add(path_579056, "repo", newJString(repo))
  add(path_579056, "owner", newJString(owner))
  if body != nil:
    body_579058 = body
  add(header_579057, "Accept", newJString(Accept))
  result = call_579055.call(path_579056, nil, header_579057, nil, body_579058)

var putReposOwnerRepoSubscription* = Call_PutReposOwnerRepoSubscription_579047(
    name: "putReposOwnerRepoSubscription", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscription",
    validator: validate_PutReposOwnerRepoSubscription_579048, base: "/",
    url: url_PutReposOwnerRepoSubscription_579049, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoSubscription_579037 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoSubscription_579039(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoSubscription_579038(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a Repository Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_579040 = path.getOrDefault("repo")
  valid_579040 = validateParameter(valid_579040, JString, required = true,
                                 default = nil)
  if valid_579040 != nil:
    section.add "repo", valid_579040
  var valid_579041 = path.getOrDefault("owner")
  valid_579041 = validateParameter(valid_579041, JString, required = true,
                                 default = nil)
  if valid_579041 != nil:
    section.add "owner", valid_579041
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579042 = header.getOrDefault("Accept")
  valid_579042 = validateParameter(valid_579042, JString, required = false,
                                 default = nil)
  if valid_579042 != nil:
    section.add "Accept", valid_579042
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579043: Call_GetReposOwnerRepoSubscription_579037; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a Repository Subscription.
  ## 
  let valid = call_579043.validator(path, query, header, formData, body)
  let scheme = call_579043.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579043.url(scheme.get, call_579043.host, call_579043.base,
                         call_579043.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579043, url, valid)

proc call*(call_579044: Call_GetReposOwnerRepoSubscription_579037; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoSubscription
  ## Get a Repository Subscription.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579045 = newJObject()
  var header_579046 = newJObject()
  add(path_579045, "repo", newJString(repo))
  add(path_579045, "owner", newJString(owner))
  add(header_579046, "Accept", newJString(Accept))
  result = call_579044.call(path_579045, nil, header_579046, nil, nil)

var getReposOwnerRepoSubscription* = Call_GetReposOwnerRepoSubscription_579037(
    name: "getReposOwnerRepoSubscription", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscription",
    validator: validate_GetReposOwnerRepoSubscription_579038, base: "/",
    url: url_GetReposOwnerRepoSubscription_579039, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoSubscription_579059 = ref object of OpenApiRestCall_576564
proc url_DeleteReposOwnerRepoSubscription_579061(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoSubscription_579060(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a Repository Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_579062 = path.getOrDefault("repo")
  valid_579062 = validateParameter(valid_579062, JString, required = true,
                                 default = nil)
  if valid_579062 != nil:
    section.add "repo", valid_579062
  var valid_579063 = path.getOrDefault("owner")
  valid_579063 = validateParameter(valid_579063, JString, required = true,
                                 default = nil)
  if valid_579063 != nil:
    section.add "owner", valid_579063
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579064 = header.getOrDefault("Accept")
  valid_579064 = validateParameter(valid_579064, JString, required = false,
                                 default = nil)
  if valid_579064 != nil:
    section.add "Accept", valid_579064
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579065: Call_DeleteReposOwnerRepoSubscription_579059;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a Repository Subscription.
  ## 
  let valid = call_579065.validator(path, query, header, formData, body)
  let scheme = call_579065.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579065.url(scheme.get, call_579065.host, call_579065.base,
                         call_579065.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579065, url, valid)

proc call*(call_579066: Call_DeleteReposOwnerRepoSubscription_579059; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoSubscription
  ## Delete a Repository Subscription.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579067 = newJObject()
  var header_579068 = newJObject()
  add(path_579067, "repo", newJString(repo))
  add(path_579067, "owner", newJString(owner))
  add(header_579068, "Accept", newJString(Accept))
  result = call_579066.call(path_579067, nil, header_579068, nil, nil)

var deleteReposOwnerRepoSubscription* = Call_DeleteReposOwnerRepoSubscription_579059(
    name: "deleteReposOwnerRepoSubscription", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscription",
    validator: validate_DeleteReposOwnerRepoSubscription_579060, base: "/",
    url: url_DeleteReposOwnerRepoSubscription_579061, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoTags_579069 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoTags_579071(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/tags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoTags_579070(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get list of tags.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_579072 = path.getOrDefault("repo")
  valid_579072 = validateParameter(valid_579072, JString, required = true,
                                 default = nil)
  if valid_579072 != nil:
    section.add "repo", valid_579072
  var valid_579073 = path.getOrDefault("owner")
  valid_579073 = validateParameter(valid_579073, JString, required = true,
                                 default = nil)
  if valid_579073 != nil:
    section.add "owner", valid_579073
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579074 = header.getOrDefault("Accept")
  valid_579074 = validateParameter(valid_579074, JString, required = false,
                                 default = nil)
  if valid_579074 != nil:
    section.add "Accept", valid_579074
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579075: Call_GetReposOwnerRepoTags_579069; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get list of tags.
  ## 
  let valid = call_579075.validator(path, query, header, formData, body)
  let scheme = call_579075.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579075.url(scheme.get, call_579075.host, call_579075.base,
                         call_579075.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579075, url, valid)

proc call*(call_579076: Call_GetReposOwnerRepoTags_579069; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoTags
  ## Get list of tags.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579077 = newJObject()
  var header_579078 = newJObject()
  add(path_579077, "repo", newJString(repo))
  add(path_579077, "owner", newJString(owner))
  add(header_579078, "Accept", newJString(Accept))
  result = call_579076.call(path_579077, nil, header_579078, nil, nil)

var getReposOwnerRepoTags* = Call_GetReposOwnerRepoTags_579069(
    name: "getReposOwnerRepoTags", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/repos/{owner}/{repo}/tags",
    validator: validate_GetReposOwnerRepoTags_579070, base: "/",
    url: url_GetReposOwnerRepoTags_579071, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoTeams_579079 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoTeams_579081(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/teams")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoTeams_579080(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get list of teams
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_579082 = path.getOrDefault("repo")
  valid_579082 = validateParameter(valid_579082, JString, required = true,
                                 default = nil)
  if valid_579082 != nil:
    section.add "repo", valid_579082
  var valid_579083 = path.getOrDefault("owner")
  valid_579083 = validateParameter(valid_579083, JString, required = true,
                                 default = nil)
  if valid_579083 != nil:
    section.add "owner", valid_579083
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579084 = header.getOrDefault("Accept")
  valid_579084 = validateParameter(valid_579084, JString, required = false,
                                 default = nil)
  if valid_579084 != nil:
    section.add "Accept", valid_579084
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579085: Call_GetReposOwnerRepoTeams_579079; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get list of teams
  ## 
  let valid = call_579085.validator(path, query, header, formData, body)
  let scheme = call_579085.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579085.url(scheme.get, call_579085.host, call_579085.base,
                         call_579085.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579085, url, valid)

proc call*(call_579086: Call_GetReposOwnerRepoTeams_579079; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoTeams
  ## Get list of teams
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579087 = newJObject()
  var header_579088 = newJObject()
  add(path_579087, "repo", newJString(repo))
  add(path_579087, "owner", newJString(owner))
  add(header_579088, "Accept", newJString(Accept))
  result = call_579086.call(path_579087, nil, header_579088, nil, nil)

var getReposOwnerRepoTeams* = Call_GetReposOwnerRepoTeams_579079(
    name: "getReposOwnerRepoTeams", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/teams",
    validator: validate_GetReposOwnerRepoTeams_579080, base: "/",
    url: url_GetReposOwnerRepoTeams_579081, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoWatchers_579089 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoWatchers_579091(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/watchers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoWatchers_579090(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List Stargazers. New implementation.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_579092 = path.getOrDefault("repo")
  valid_579092 = validateParameter(valid_579092, JString, required = true,
                                 default = nil)
  if valid_579092 != nil:
    section.add "repo", valid_579092
  var valid_579093 = path.getOrDefault("owner")
  valid_579093 = validateParameter(valid_579093, JString, required = true,
                                 default = nil)
  if valid_579093 != nil:
    section.add "owner", valid_579093
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579094 = header.getOrDefault("Accept")
  valid_579094 = validateParameter(valid_579094, JString, required = false,
                                 default = nil)
  if valid_579094 != nil:
    section.add "Accept", valid_579094
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579095: Call_GetReposOwnerRepoWatchers_579089; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List Stargazers. New implementation.
  ## 
  let valid = call_579095.validator(path, query, header, formData, body)
  let scheme = call_579095.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579095.url(scheme.get, call_579095.host, call_579095.base,
                         call_579095.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579095, url, valid)

proc call*(call_579096: Call_GetReposOwnerRepoWatchers_579089; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoWatchers
  ## List Stargazers. New implementation.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579097 = newJObject()
  var header_579098 = newJObject()
  add(path_579097, "repo", newJString(repo))
  add(path_579097, "owner", newJString(owner))
  add(header_579098, "Accept", newJString(Accept))
  result = call_579096.call(path_579097, nil, header_579098, nil, nil)

var getReposOwnerRepoWatchers* = Call_GetReposOwnerRepoWatchers_579089(
    name: "getReposOwnerRepoWatchers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/watchers",
    validator: validate_GetReposOwnerRepoWatchers_579090, base: "/",
    url: url_GetReposOwnerRepoWatchers_579091, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoArchiveFormatPath_579099 = ref object of OpenApiRestCall_576564
proc url_GetReposOwnerRepoArchiveFormatPath_579101(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "archive_format" in path, "`archive_format` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "archive_format"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoArchiveFormatPath_579100(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get archive link.
  ## This method will return a 302 to a URL to download a tarball or zipball
  ## archive for a repository. Please make sure your HTTP framework is
  ## configured to follow redirects or you will need to use the Location header
  ## to make a second GET request.
  ## Note: For private repositories, these links are temporary and expire quickly.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   archive_format: JString (required)
  ##   path: JString (required)
  ##       : Valid Git reference, defaults to 'master'.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_579102 = path.getOrDefault("repo")
  valid_579102 = validateParameter(valid_579102, JString, required = true,
                                 default = nil)
  if valid_579102 != nil:
    section.add "repo", valid_579102
  var valid_579103 = path.getOrDefault("owner")
  valid_579103 = validateParameter(valid_579103, JString, required = true,
                                 default = nil)
  if valid_579103 != nil:
    section.add "owner", valid_579103
  var valid_579104 = path.getOrDefault("archive_format")
  valid_579104 = validateParameter(valid_579104, JString, required = true,
                                 default = newJString("tarball"))
  if valid_579104 != nil:
    section.add "archive_format", valid_579104
  var valid_579105 = path.getOrDefault("path")
  valid_579105 = validateParameter(valid_579105, JString, required = true,
                                 default = nil)
  if valid_579105 != nil:
    section.add "path", valid_579105
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579106 = header.getOrDefault("Accept")
  valid_579106 = validateParameter(valid_579106, JString, required = false,
                                 default = nil)
  if valid_579106 != nil:
    section.add "Accept", valid_579106
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579107: Call_GetReposOwnerRepoArchiveFormatPath_579099;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get archive link.
  ## This method will return a 302 to a URL to download a tarball or zipball
  ## archive for a repository. Please make sure your HTTP framework is
  ## configured to follow redirects or you will need to use the Location header
  ## to make a second GET request.
  ## Note: For private repositories, these links are temporary and expire quickly.
  ## 
  ## 
  let valid = call_579107.validator(path, query, header, formData, body)
  let scheme = call_579107.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579107.url(scheme.get, call_579107.host, call_579107.base,
                         call_579107.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579107, url, valid)

proc call*(call_579108: Call_GetReposOwnerRepoArchiveFormatPath_579099;
          repo: string; owner: string; path: string;
          archiveFormat: string = "tarball"; Accept: string = ""): Recallable =
  ## getReposOwnerRepoArchiveFormatPath
  ## Get archive link.
  ## This method will return a 302 to a URL to download a tarball or zipball
  ## archive for a repository. Please make sure your HTTP framework is
  ## configured to follow redirects or you will need to use the Location header
  ## to make a second GET request.
  ## Note: For private repositories, these links are temporary and expire quickly.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   archiveFormat: string (required)
  ##   path: string (required)
  ##       : Valid Git reference, defaults to 'master'.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579109 = newJObject()
  var header_579110 = newJObject()
  add(path_579109, "repo", newJString(repo))
  add(path_579109, "owner", newJString(owner))
  add(path_579109, "archive_format", newJString(archiveFormat))
  add(path_579109, "path", newJString(path))
  add(header_579110, "Accept", newJString(Accept))
  result = call_579108.call(path_579109, nil, header_579110, nil, nil)

var getReposOwnerRepoArchiveFormatPath* = Call_GetReposOwnerRepoArchiveFormatPath_579099(
    name: "getReposOwnerRepoArchiveFormatPath", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/{archive_format}/{path}",
    validator: validate_GetReposOwnerRepoArchiveFormatPath_579100, base: "/",
    url: url_GetReposOwnerRepoArchiveFormatPath_579101, schemes: {Scheme.Https})
type
  Call_GetRepositories_579111 = ref object of OpenApiRestCall_576564
proc url_GetRepositories_579113(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRepositories_579112(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## List all public repositories.
  ## This provides a dump of every public repository, in the order that they
  ## were created.
  ## Note: Pagination is powered exclusively by the since parameter. is the
  ## Link header to get the URL for the next page of repositories.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_579114 = query.getOrDefault("since")
  valid_579114 = validateParameter(valid_579114, JString, required = false,
                                 default = nil)
  if valid_579114 != nil:
    section.add "since", valid_579114
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579115 = header.getOrDefault("Accept")
  valid_579115 = validateParameter(valid_579115, JString, required = false,
                                 default = nil)
  if valid_579115 != nil:
    section.add "Accept", valid_579115
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579116: Call_GetRepositories_579111; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List all public repositories.
  ## This provides a dump of every public repository, in the order that they
  ## were created.
  ## Note: Pagination is powered exclusively by the since parameter. is the
  ## Link header to get the URL for the next page of repositories.
  ## 
  ## 
  let valid = call_579116.validator(path, query, header, formData, body)
  let scheme = call_579116.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579116.url(scheme.get, call_579116.host, call_579116.base,
                         call_579116.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579116, url, valid)

proc call*(call_579117: Call_GetRepositories_579111; since: string = "";
          Accept: string = ""): Recallable =
  ## getRepositories
  ## List all public repositories.
  ## This provides a dump of every public repository, in the order that they
  ## were created.
  ## Note: Pagination is powered exclusively by the since parameter. is the
  ## Link header to get the URL for the next page of repositories.
  ## 
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var query_579118 = newJObject()
  var header_579119 = newJObject()
  add(query_579118, "since", newJString(since))
  add(header_579119, "Accept", newJString(Accept))
  result = call_579117.call(nil, query_579118, header_579119, nil, nil)

var getRepositories* = Call_GetRepositories_579111(name: "getRepositories",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/repositories",
    validator: validate_GetRepositories_579112, base: "/", url: url_GetRepositories_579113,
    schemes: {Scheme.Https})
type
  Call_GetSearchCode_579120 = ref object of OpenApiRestCall_576564
proc url_GetSearchCode_579122(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchCode_579121(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Search code.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   q: JString (required)
  ##    : The search terms. This can be any combination of the supported code
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier
  ## you can restrict the search to just the file contents, the file path,
  ## or both.
  ## 'Languages' Searches code based on the language it's written in.
  ## 'Forks' Filters repositories based on the number of forks, and/or
  ## whether code from forked repositories should be included in the results
  ## at all.
  ## 'Size' Finds files that match a certain size (in bytes).
  ## 'Path' Specifies the path that the resulting file must be at.
  ## 'Extension' Matches files with a certain extension.
  ## 'Users' or 'Repositories' Limits searches to a specific user or repository.
  ## 
  ##   sort: JString
  ##       : Can only be 'indexed', which indicates how recently a file has been indexed
  ## by the GitHub search infrastructure. If not provided, results are sorted
  ## by best match.
  ## 
  section = newJObject()
  var valid_579123 = query.getOrDefault("order")
  valid_579123 = validateParameter(valid_579123, JString, required = false,
                                 default = newJString("desc"))
  if valid_579123 != nil:
    section.add "order", valid_579123
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_579124 = query.getOrDefault("q")
  valid_579124 = validateParameter(valid_579124, JString, required = true,
                                 default = nil)
  if valid_579124 != nil:
    section.add "q", valid_579124
  var valid_579125 = query.getOrDefault("sort")
  valid_579125 = validateParameter(valid_579125, JString, required = false,
                                 default = newJString("indexed"))
  if valid_579125 != nil:
    section.add "sort", valid_579125
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579126 = header.getOrDefault("Accept")
  valid_579126 = validateParameter(valid_579126, JString, required = false,
                                 default = nil)
  if valid_579126 != nil:
    section.add "Accept", valid_579126
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579127: Call_GetSearchCode_579120; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Search code.
  ## 
  let valid = call_579127.validator(path, query, header, formData, body)
  let scheme = call_579127.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579127.url(scheme.get, call_579127.host, call_579127.base,
                         call_579127.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579127, url, valid)

proc call*(call_579128: Call_GetSearchCode_579120; q: string; order: string = "desc";
          Accept: string = ""; sort: string = "indexed"): Recallable =
  ## getSearchCode
  ## Search code.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   q: string (required)
  ##    : The search terms. This can be any combination of the supported code
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier
  ## you can restrict the search to just the file contents, the file path,
  ## or both.
  ## 'Languages' Searches code based on the language it's written in.
  ## 'Forks' Filters repositories based on the number of forks, and/or
  ## whether code from forked repositories should be included in the results
  ## at all.
  ## 'Size' Finds files that match a certain size (in bytes).
  ## 'Path' Specifies the path that the resulting file must be at.
  ## 'Extension' Matches files with a certain extension.
  ## 'Users' or 'Repositories' Limits searches to a specific user or repository.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##       : Can only be 'indexed', which indicates how recently a file has been indexed
  ## by the GitHub search infrastructure. If not provided, results are sorted
  ## by best match.
  ## 
  var query_579129 = newJObject()
  var header_579130 = newJObject()
  add(query_579129, "order", newJString(order))
  add(query_579129, "q", newJString(q))
  add(header_579130, "Accept", newJString(Accept))
  add(query_579129, "sort", newJString(sort))
  result = call_579128.call(nil, query_579129, header_579130, nil, nil)

var getSearchCode* = Call_GetSearchCode_579120(name: "getSearchCode",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/search/code",
    validator: validate_GetSearchCode_579121, base: "/", url: url_GetSearchCode_579122,
    schemes: {Scheme.Https})
type
  Call_GetSearchIssues_579131 = ref object of OpenApiRestCall_576564
proc url_GetSearchIssues_579133(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchIssues_579132(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Find issues by state and keyword. (This method returns up to 100 results per page.)
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   q: JString (required)
  ##    : The q search term can also contain any combination of the supported issue search qualifiers:
  ##   sort: JString
  ##       : The sort field. Can be comments, created, or updated. Default: results are sorted by best match.
  section = newJObject()
  var valid_579134 = query.getOrDefault("order")
  valid_579134 = validateParameter(valid_579134, JString, required = false,
                                 default = newJString("desc"))
  if valid_579134 != nil:
    section.add "order", valid_579134
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_579135 = query.getOrDefault("q")
  valid_579135 = validateParameter(valid_579135, JString, required = true,
                                 default = nil)
  if valid_579135 != nil:
    section.add "q", valid_579135
  var valid_579136 = query.getOrDefault("sort")
  valid_579136 = validateParameter(valid_579136, JString, required = false,
                                 default = newJString("updated"))
  if valid_579136 != nil:
    section.add "sort", valid_579136
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579137 = header.getOrDefault("Accept")
  valid_579137 = validateParameter(valid_579137, JString, required = false,
                                 default = nil)
  if valid_579137 != nil:
    section.add "Accept", valid_579137
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579138: Call_GetSearchIssues_579131; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Find issues by state and keyword. (This method returns up to 100 results per page.)
  ## 
  let valid = call_579138.validator(path, query, header, formData, body)
  let scheme = call_579138.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579138.url(scheme.get, call_579138.host, call_579138.base,
                         call_579138.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579138, url, valid)

proc call*(call_579139: Call_GetSearchIssues_579131; q: string;
          order: string = "desc"; Accept: string = ""; sort: string = "updated"): Recallable =
  ## getSearchIssues
  ## Find issues by state and keyword. (This method returns up to 100 results per page.)
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   q: string (required)
  ##    : The q search term can also contain any combination of the supported issue search qualifiers:
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##       : The sort field. Can be comments, created, or updated. Default: results are sorted by best match.
  var query_579140 = newJObject()
  var header_579141 = newJObject()
  add(query_579140, "order", newJString(order))
  add(query_579140, "q", newJString(q))
  add(header_579141, "Accept", newJString(Accept))
  add(query_579140, "sort", newJString(sort))
  result = call_579139.call(nil, query_579140, header_579141, nil, nil)

var getSearchIssues* = Call_GetSearchIssues_579131(name: "getSearchIssues",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/search/issues",
    validator: validate_GetSearchIssues_579132, base: "/", url: url_GetSearchIssues_579133,
    schemes: {Scheme.Https})
type
  Call_GetSearchRepositories_579142 = ref object of OpenApiRestCall_576564
proc url_GetSearchRepositories_579144(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchRepositories_579143(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Search repositories.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   q: JString (required)
  ##    : The search terms. This can be any combination of the supported repository
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the repository name, description, readme,
  ## or any combination of these.
  ## 'Size' Finds repositories that match a certain size (in kilobytes).
  ## 'Forks' Filters repositories based on the number of forks, and/or whether
  ## forked repositories should be included in the results at all.
  ## 'Created' and 'Last Updated' Filters repositories based on times of
  ## creation, or when they were last updated.
  ## 'Users or Repositories' Limits searches to a specific user or repository.
  ## 'Languages' Searches repositories based on the language they are written in.
  ## 'Stars' Searches repositories based on the number of stars.
  ## 
  ##   sort: JString
  ##       : If not provided, results are sorted by best match.
  section = newJObject()
  var valid_579145 = query.getOrDefault("order")
  valid_579145 = validateParameter(valid_579145, JString, required = false,
                                 default = newJString("desc"))
  if valid_579145 != nil:
    section.add "order", valid_579145
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_579146 = query.getOrDefault("q")
  valid_579146 = validateParameter(valid_579146, JString, required = true,
                                 default = nil)
  if valid_579146 != nil:
    section.add "q", valid_579146
  var valid_579147 = query.getOrDefault("sort")
  valid_579147 = validateParameter(valid_579147, JString, required = false,
                                 default = newJString("stars"))
  if valid_579147 != nil:
    section.add "sort", valid_579147
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579148 = header.getOrDefault("Accept")
  valid_579148 = validateParameter(valid_579148, JString, required = false,
                                 default = nil)
  if valid_579148 != nil:
    section.add "Accept", valid_579148
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579149: Call_GetSearchRepositories_579142; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Search repositories.
  ## 
  let valid = call_579149.validator(path, query, header, formData, body)
  let scheme = call_579149.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579149.url(scheme.get, call_579149.host, call_579149.base,
                         call_579149.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579149, url, valid)

proc call*(call_579150: Call_GetSearchRepositories_579142; q: string;
          order: string = "desc"; Accept: string = ""; sort: string = "stars"): Recallable =
  ## getSearchRepositories
  ## Search repositories.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   q: string (required)
  ##    : The search terms. This can be any combination of the supported repository
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the repository name, description, readme,
  ## or any combination of these.
  ## 'Size' Finds repositories that match a certain size (in kilobytes).
  ## 'Forks' Filters repositories based on the number of forks, and/or whether
  ## forked repositories should be included in the results at all.
  ## 'Created' and 'Last Updated' Filters repositories based on times of
  ## creation, or when they were last updated.
  ## 'Users or Repositories' Limits searches to a specific user or repository.
  ## 'Languages' Searches repositories based on the language they are written in.
  ## 'Stars' Searches repositories based on the number of stars.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##       : If not provided, results are sorted by best match.
  var query_579151 = newJObject()
  var header_579152 = newJObject()
  add(query_579151, "order", newJString(order))
  add(query_579151, "q", newJString(q))
  add(header_579152, "Accept", newJString(Accept))
  add(query_579151, "sort", newJString(sort))
  result = call_579150.call(nil, query_579151, header_579152, nil, nil)

var getSearchRepositories* = Call_GetSearchRepositories_579142(
    name: "getSearchRepositories", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/search/repositories", validator: validate_GetSearchRepositories_579143,
    base: "/", url: url_GetSearchRepositories_579144, schemes: {Scheme.Https})
type
  Call_GetSearchUsers_579153 = ref object of OpenApiRestCall_576564
proc url_GetSearchUsers_579155(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchUsers_579154(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Search users.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   q: JString (required)
  ##    : The search terms. This can be any combination of the supported user
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the username, public email, full name,
  ## location, or any combination of these.
  ## 'Repository count' Filters users based on the number of repositories they
  ## have.
  ## 'Location' Filter users by the location indicated in their profile.
  ## 'Language' Search for users that have repositories that match a certain
  ## language.
  ## 'Created' Filter users based on when they joined.
  ## 'Followers' Filter users based on the number of followers they have.
  ## 
  ##   sort: JString
  ##       : If not provided, results are sorted by best match.
  section = newJObject()
  var valid_579156 = query.getOrDefault("order")
  valid_579156 = validateParameter(valid_579156, JString, required = false,
                                 default = newJString("desc"))
  if valid_579156 != nil:
    section.add "order", valid_579156
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_579157 = query.getOrDefault("q")
  valid_579157 = validateParameter(valid_579157, JString, required = true,
                                 default = nil)
  if valid_579157 != nil:
    section.add "q", valid_579157
  var valid_579158 = query.getOrDefault("sort")
  valid_579158 = validateParameter(valid_579158, JString, required = false,
                                 default = newJString("followers"))
  if valid_579158 != nil:
    section.add "sort", valid_579158
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579159 = header.getOrDefault("Accept")
  valid_579159 = validateParameter(valid_579159, JString, required = false,
                                 default = nil)
  if valid_579159 != nil:
    section.add "Accept", valid_579159
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579160: Call_GetSearchUsers_579153; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Search users.
  ## 
  let valid = call_579160.validator(path, query, header, formData, body)
  let scheme = call_579160.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579160.url(scheme.get, call_579160.host, call_579160.base,
                         call_579160.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579160, url, valid)

proc call*(call_579161: Call_GetSearchUsers_579153; q: string;
          order: string = "desc"; Accept: string = ""; sort: string = "followers"): Recallable =
  ## getSearchUsers
  ## Search users.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   q: string (required)
  ##    : The search terms. This can be any combination of the supported user
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the username, public email, full name,
  ## location, or any combination of these.
  ## 'Repository count' Filters users based on the number of repositories they
  ## have.
  ## 'Location' Filter users by the location indicated in their profile.
  ## 'Language' Search for users that have repositories that match a certain
  ## language.
  ## 'Created' Filter users based on when they joined.
  ## 'Followers' Filter users based on the number of followers they have.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##       : If not provided, results are sorted by best match.
  var query_579162 = newJObject()
  var header_579163 = newJObject()
  add(query_579162, "order", newJString(order))
  add(query_579162, "q", newJString(q))
  add(header_579163, "Accept", newJString(Accept))
  add(query_579162, "sort", newJString(sort))
  result = call_579161.call(nil, query_579162, header_579163, nil, nil)

var getSearchUsers* = Call_GetSearchUsers_579153(name: "getSearchUsers",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/search/users",
    validator: validate_GetSearchUsers_579154, base: "/", url: url_GetSearchUsers_579155,
    schemes: {Scheme.Https})
type
  Call_GetTeamsTeamId_579164 = ref object of OpenApiRestCall_576564
proc url_GetTeamsTeamId_579166(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamId_579165(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Get team.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_579167 = path.getOrDefault("teamId")
  valid_579167 = validateParameter(valid_579167, JInt, required = true, default = nil)
  if valid_579167 != nil:
    section.add "teamId", valid_579167
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579168 = header.getOrDefault("Accept")
  valid_579168 = validateParameter(valid_579168, JString, required = false,
                                 default = nil)
  if valid_579168 != nil:
    section.add "Accept", valid_579168
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579169: Call_GetTeamsTeamId_579164; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get team.
  ## 
  let valid = call_579169.validator(path, query, header, formData, body)
  let scheme = call_579169.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579169.url(scheme.get, call_579169.host, call_579169.base,
                         call_579169.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579169, url, valid)

proc call*(call_579170: Call_GetTeamsTeamId_579164; teamId: int; Accept: string = ""): Recallable =
  ## getTeamsTeamId
  ## Get team.
  ##   teamId: int (required)
  ##         : Id of team.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579171 = newJObject()
  var header_579172 = newJObject()
  add(path_579171, "teamId", newJInt(teamId))
  add(header_579172, "Accept", newJString(Accept))
  result = call_579170.call(path_579171, nil, header_579172, nil, nil)

var getTeamsTeamId* = Call_GetTeamsTeamId_579164(name: "getTeamsTeamId",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/teams/{teamId}",
    validator: validate_GetTeamsTeamId_579165, base: "/", url: url_GetTeamsTeamId_579166,
    schemes: {Scheme.Https})
type
  Call_PatchTeamsTeamId_579182 = ref object of OpenApiRestCall_576564
proc url_PatchTeamsTeamId_579184(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchTeamsTeamId_579183(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Edit team.
  ## In order to edit a team, the authenticated user must be an owner of the org
  ## that the team is associated with.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_579185 = path.getOrDefault("teamId")
  valid_579185 = validateParameter(valid_579185, JInt, required = true, default = nil)
  if valid_579185 != nil:
    section.add "teamId", valid_579185
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579186 = header.getOrDefault("Accept")
  valid_579186 = validateParameter(valid_579186, JString, required = false,
                                 default = nil)
  if valid_579186 != nil:
    section.add "Accept", valid_579186
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579188: Call_PatchTeamsTeamId_579182; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Edit team.
  ## In order to edit a team, the authenticated user must be an owner of the org
  ## that the team is associated with.
  ## 
  ## 
  let valid = call_579188.validator(path, query, header, formData, body)
  let scheme = call_579188.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579188.url(scheme.get, call_579188.host, call_579188.base,
                         call_579188.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579188, url, valid)

proc call*(call_579189: Call_PatchTeamsTeamId_579182; teamId: int; body: JsonNode;
          Accept: string = ""): Recallable =
  ## patchTeamsTeamId
  ## Edit team.
  ## In order to edit a team, the authenticated user must be an owner of the org
  ## that the team is associated with.
  ## 
  ##   teamId: int (required)
  ##         : Id of team.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579190 = newJObject()
  var header_579191 = newJObject()
  var body_579192 = newJObject()
  add(path_579190, "teamId", newJInt(teamId))
  if body != nil:
    body_579192 = body
  add(header_579191, "Accept", newJString(Accept))
  result = call_579189.call(path_579190, nil, header_579191, nil, body_579192)

var patchTeamsTeamId* = Call_PatchTeamsTeamId_579182(name: "patchTeamsTeamId",
    meth: HttpMethod.HttpPatch, host: "api.github.com", route: "/teams/{teamId}",
    validator: validate_PatchTeamsTeamId_579183, base: "/",
    url: url_PatchTeamsTeamId_579184, schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamId_579173 = ref object of OpenApiRestCall_576564
proc url_DeleteTeamsTeamId_579175(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamId_579174(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Delete team.
  ## In order to delete a team, the authenticated user must be an owner of the
  ## org that the team is associated with.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_579176 = path.getOrDefault("teamId")
  valid_579176 = validateParameter(valid_579176, JInt, required = true, default = nil)
  if valid_579176 != nil:
    section.add "teamId", valid_579176
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579177 = header.getOrDefault("Accept")
  valid_579177 = validateParameter(valid_579177, JString, required = false,
                                 default = nil)
  if valid_579177 != nil:
    section.add "Accept", valid_579177
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579178: Call_DeleteTeamsTeamId_579173; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete team.
  ## In order to delete a team, the authenticated user must be an owner of the
  ## org that the team is associated with.
  ## 
  ## 
  let valid = call_579178.validator(path, query, header, formData, body)
  let scheme = call_579178.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579178.url(scheme.get, call_579178.host, call_579178.base,
                         call_579178.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579178, url, valid)

proc call*(call_579179: Call_DeleteTeamsTeamId_579173; teamId: int;
          Accept: string = ""): Recallable =
  ## deleteTeamsTeamId
  ## Delete team.
  ## In order to delete a team, the authenticated user must be an owner of the
  ## org that the team is associated with.
  ## 
  ##   teamId: int (required)
  ##         : Id of team.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579180 = newJObject()
  var header_579181 = newJObject()
  add(path_579180, "teamId", newJInt(teamId))
  add(header_579181, "Accept", newJString(Accept))
  result = call_579179.call(path_579180, nil, header_579181, nil, nil)

var deleteTeamsTeamId* = Call_DeleteTeamsTeamId_579173(name: "deleteTeamsTeamId",
    meth: HttpMethod.HttpDelete, host: "api.github.com", route: "/teams/{teamId}",
    validator: validate_DeleteTeamsTeamId_579174, base: "/",
    url: url_DeleteTeamsTeamId_579175, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdMembers_579193 = ref object of OpenApiRestCall_576564
proc url_GetTeamsTeamIdMembers_579195(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/members")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdMembers_579194(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List team members.
  ## In order to list members in a team, the authenticated user must be a member
  ## of the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_579196 = path.getOrDefault("teamId")
  valid_579196 = validateParameter(valid_579196, JInt, required = true, default = nil)
  if valid_579196 != nil:
    section.add "teamId", valid_579196
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579197 = header.getOrDefault("Accept")
  valid_579197 = validateParameter(valid_579197, JString, required = false,
                                 default = nil)
  if valid_579197 != nil:
    section.add "Accept", valid_579197
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579198: Call_GetTeamsTeamIdMembers_579193; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List team members.
  ## In order to list members in a team, the authenticated user must be a member
  ## of the team.
  ## 
  ## 
  let valid = call_579198.validator(path, query, header, formData, body)
  let scheme = call_579198.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579198.url(scheme.get, call_579198.host, call_579198.base,
                         call_579198.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579198, url, valid)

proc call*(call_579199: Call_GetTeamsTeamIdMembers_579193; teamId: int;
          Accept: string = ""): Recallable =
  ## getTeamsTeamIdMembers
  ## List team members.
  ## In order to list members in a team, the authenticated user must be a member
  ## of the team.
  ## 
  ##   teamId: int (required)
  ##         : Id of team.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579200 = newJObject()
  var header_579201 = newJObject()
  add(path_579200, "teamId", newJInt(teamId))
  add(header_579201, "Accept", newJString(Accept))
  result = call_579199.call(path_579200, nil, header_579201, nil, nil)

var getTeamsTeamIdMembers* = Call_GetTeamsTeamIdMembers_579193(
    name: "getTeamsTeamIdMembers", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/teams/{teamId}/members", validator: validate_GetTeamsTeamIdMembers_579194,
    base: "/", url: url_GetTeamsTeamIdMembers_579195, schemes: {Scheme.Https})
type
  Call_PutTeamsTeamIdMembersUsername_579212 = ref object of OpenApiRestCall_576564
proc url_PutTeamsTeamIdMembersUsername_579214(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutTeamsTeamIdMembersUsername_579213(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## The API (described below) is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Add team membership API instead. It allows you to invite new organization members to your teams.
  ## 
  ## Add team member.
  ## In order to add a user to a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  ##   username: JString (required)
  ##           : Name of a member.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_579215 = path.getOrDefault("teamId")
  valid_579215 = validateParameter(valid_579215, JInt, required = true, default = nil)
  if valid_579215 != nil:
    section.add "teamId", valid_579215
  var valid_579216 = path.getOrDefault("username")
  valid_579216 = validateParameter(valid_579216, JString, required = true,
                                 default = nil)
  if valid_579216 != nil:
    section.add "username", valid_579216
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579217 = header.getOrDefault("Accept")
  valid_579217 = validateParameter(valid_579217, JString, required = false,
                                 default = nil)
  if valid_579217 != nil:
    section.add "Accept", valid_579217
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579218: Call_PutTeamsTeamIdMembersUsername_579212; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The API (described below) is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Add team membership API instead. It allows you to invite new organization members to your teams.
  ## 
  ## Add team member.
  ## In order to add a user to a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## 
  ## 
  let valid = call_579218.validator(path, query, header, formData, body)
  let scheme = call_579218.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579218.url(scheme.get, call_579218.host, call_579218.base,
                         call_579218.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579218, url, valid)

proc call*(call_579219: Call_PutTeamsTeamIdMembersUsername_579212; teamId: int;
          username: string; Accept: string = ""): Recallable =
  ## putTeamsTeamIdMembersUsername
  ## The API (described below) is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Add team membership API instead. It allows you to invite new organization members to your teams.
  ## 
  ## Add team member.
  ## In order to add a user to a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## 
  ##   teamId: int (required)
  ##         : Id of team.
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579220 = newJObject()
  var header_579221 = newJObject()
  add(path_579220, "teamId", newJInt(teamId))
  add(path_579220, "username", newJString(username))
  add(header_579221, "Accept", newJString(Accept))
  result = call_579219.call(path_579220, nil, header_579221, nil, nil)

var putTeamsTeamIdMembersUsername* = Call_PutTeamsTeamIdMembersUsername_579212(
    name: "putTeamsTeamIdMembersUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/teams/{teamId}/members/{username}",
    validator: validate_PutTeamsTeamIdMembersUsername_579213, base: "/",
    url: url_PutTeamsTeamIdMembersUsername_579214, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdMembersUsername_579202 = ref object of OpenApiRestCall_576564
proc url_GetTeamsTeamIdMembersUsername_579204(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdMembersUsername_579203(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## The "Get team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Get team membership API instead. It allows you to get both active and pending memberships.
  ## 
  ## Get team member.
  ## In order to get if a user is a member of a team, the authenticated user mus
  ## be a member of the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  ##   username: JString (required)
  ##           : Name of a member.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_579205 = path.getOrDefault("teamId")
  valid_579205 = validateParameter(valid_579205, JInt, required = true, default = nil)
  if valid_579205 != nil:
    section.add "teamId", valid_579205
  var valid_579206 = path.getOrDefault("username")
  valid_579206 = validateParameter(valid_579206, JString, required = true,
                                 default = nil)
  if valid_579206 != nil:
    section.add "username", valid_579206
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579207 = header.getOrDefault("Accept")
  valid_579207 = validateParameter(valid_579207, JString, required = false,
                                 default = nil)
  if valid_579207 != nil:
    section.add "Accept", valid_579207
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579208: Call_GetTeamsTeamIdMembersUsername_579202; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The "Get team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Get team membership API instead. It allows you to get both active and pending memberships.
  ## 
  ## Get team member.
  ## In order to get if a user is a member of a team, the authenticated user mus
  ## be a member of the team.
  ## 
  ## 
  let valid = call_579208.validator(path, query, header, formData, body)
  let scheme = call_579208.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579208.url(scheme.get, call_579208.host, call_579208.base,
                         call_579208.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579208, url, valid)

proc call*(call_579209: Call_GetTeamsTeamIdMembersUsername_579202; teamId: int;
          username: string; Accept: string = ""): Recallable =
  ## getTeamsTeamIdMembersUsername
  ## The "Get team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Get team membership API instead. It allows you to get both active and pending memberships.
  ## 
  ## Get team member.
  ## In order to get if a user is a member of a team, the authenticated user mus
  ## be a member of the team.
  ## 
  ##   teamId: int (required)
  ##         : Id of team.
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579210 = newJObject()
  var header_579211 = newJObject()
  add(path_579210, "teamId", newJInt(teamId))
  add(path_579210, "username", newJString(username))
  add(header_579211, "Accept", newJString(Accept))
  result = call_579209.call(path_579210, nil, header_579211, nil, nil)

var getTeamsTeamIdMembersUsername* = Call_GetTeamsTeamIdMembersUsername_579202(
    name: "getTeamsTeamIdMembersUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/teams/{teamId}/members/{username}",
    validator: validate_GetTeamsTeamIdMembersUsername_579203, base: "/",
    url: url_GetTeamsTeamIdMembersUsername_579204, schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamIdMembersUsername_579222 = ref object of OpenApiRestCall_576564
proc url_DeleteTeamsTeamIdMembersUsername_579224(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamIdMembersUsername_579223(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## The "Remove team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Remove team membership API instead. It allows you to remove both active and pending memberships.
  ## 
  ## Remove team member.
  ## In order to remove a user from a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## NOTE This does not delete the user, it just remove them from the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  ##   username: JString (required)
  ##           : Name of a member.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_579225 = path.getOrDefault("teamId")
  valid_579225 = validateParameter(valid_579225, JInt, required = true, default = nil)
  if valid_579225 != nil:
    section.add "teamId", valid_579225
  var valid_579226 = path.getOrDefault("username")
  valid_579226 = validateParameter(valid_579226, JString, required = true,
                                 default = nil)
  if valid_579226 != nil:
    section.add "username", valid_579226
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579227 = header.getOrDefault("Accept")
  valid_579227 = validateParameter(valid_579227, JString, required = false,
                                 default = nil)
  if valid_579227 != nil:
    section.add "Accept", valid_579227
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579228: Call_DeleteTeamsTeamIdMembersUsername_579222;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## The "Remove team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Remove team membership API instead. It allows you to remove both active and pending memberships.
  ## 
  ## Remove team member.
  ## In order to remove a user from a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## NOTE This does not delete the user, it just remove them from the team.
  ## 
  ## 
  let valid = call_579228.validator(path, query, header, formData, body)
  let scheme = call_579228.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579228.url(scheme.get, call_579228.host, call_579228.base,
                         call_579228.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579228, url, valid)

proc call*(call_579229: Call_DeleteTeamsTeamIdMembersUsername_579222; teamId: int;
          username: string; Accept: string = ""): Recallable =
  ## deleteTeamsTeamIdMembersUsername
  ## The "Remove team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Remove team membership API instead. It allows you to remove both active and pending memberships.
  ## 
  ## Remove team member.
  ## In order to remove a user from a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## NOTE This does not delete the user, it just remove them from the team.
  ## 
  ##   teamId: int (required)
  ##         : Id of team.
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579230 = newJObject()
  var header_579231 = newJObject()
  add(path_579230, "teamId", newJInt(teamId))
  add(path_579230, "username", newJString(username))
  add(header_579231, "Accept", newJString(Accept))
  result = call_579229.call(path_579230, nil, header_579231, nil, nil)

var deleteTeamsTeamIdMembersUsername* = Call_DeleteTeamsTeamIdMembersUsername_579222(
    name: "deleteTeamsTeamIdMembersUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/teams/{teamId}/members/{username}",
    validator: validate_DeleteTeamsTeamIdMembersUsername_579223, base: "/",
    url: url_DeleteTeamsTeamIdMembersUsername_579224, schemes: {Scheme.Https})
type
  Call_PutTeamsTeamIdMembershipsUsername_579242 = ref object of OpenApiRestCall_576564
proc url_PutTeamsTeamIdMembershipsUsername_579244(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/memberships/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutTeamsTeamIdMembershipsUsername_579243(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Add team membership.
  ## In order to add a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with.
  ## 
  ## If the user is already a part of the team's organization (meaning they're on at least one other team in the organization), this endpoint will add the user to the team.
  ## 
  ## If the user is completely unaffiliated with the team's organization (meaning they're on none of the organization's teams), this endpoint will send an invitation to the user via email. This newly-created membership will be in the 'pending' state until the user accepts the invitation, at which point the membership will transition to the 'active' state and the user will be added as a member of the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  ##   username: JString (required)
  ##           : Name of a member.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_579245 = path.getOrDefault("teamId")
  valid_579245 = validateParameter(valid_579245, JInt, required = true, default = nil)
  if valid_579245 != nil:
    section.add "teamId", valid_579245
  var valid_579246 = path.getOrDefault("username")
  valid_579246 = validateParameter(valid_579246, JString, required = true,
                                 default = nil)
  if valid_579246 != nil:
    section.add "username", valid_579246
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579247 = header.getOrDefault("Accept")
  valid_579247 = validateParameter(valid_579247, JString, required = false,
                                 default = nil)
  if valid_579247 != nil:
    section.add "Accept", valid_579247
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579248: Call_PutTeamsTeamIdMembershipsUsername_579242;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Add team membership.
  ## In order to add a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with.
  ## 
  ## If the user is already a part of the team's organization (meaning they're on at least one other team in the organization), this endpoint will add the user to the team.
  ## 
  ## If the user is completely unaffiliated with the team's organization (meaning they're on none of the organization's teams), this endpoint will send an invitation to the user via email. This newly-created membership will be in the 'pending' state until the user accepts the invitation, at which point the membership will transition to the 'active' state and the user will be added as a member of the team.
  ## 
  ## 
  let valid = call_579248.validator(path, query, header, formData, body)
  let scheme = call_579248.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579248.url(scheme.get, call_579248.host, call_579248.base,
                         call_579248.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579248, url, valid)

proc call*(call_579249: Call_PutTeamsTeamIdMembershipsUsername_579242; teamId: int;
          username: string; Accept: string = ""): Recallable =
  ## putTeamsTeamIdMembershipsUsername
  ## Add team membership.
  ## In order to add a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with.
  ## 
  ## If the user is already a part of the team's organization (meaning they're on at least one other team in the organization), this endpoint will add the user to the team.
  ## 
  ## If the user is completely unaffiliated with the team's organization (meaning they're on none of the organization's teams), this endpoint will send an invitation to the user via email. This newly-created membership will be in the 'pending' state until the user accepts the invitation, at which point the membership will transition to the 'active' state and the user will be added as a member of the team.
  ## 
  ##   teamId: int (required)
  ##         : Id of team.
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579250 = newJObject()
  var header_579251 = newJObject()
  add(path_579250, "teamId", newJInt(teamId))
  add(path_579250, "username", newJString(username))
  add(header_579251, "Accept", newJString(Accept))
  result = call_579249.call(path_579250, nil, header_579251, nil, nil)

var putTeamsTeamIdMembershipsUsername* = Call_PutTeamsTeamIdMembershipsUsername_579242(
    name: "putTeamsTeamIdMembershipsUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/teams/{teamId}/memberships/{username}",
    validator: validate_PutTeamsTeamIdMembershipsUsername_579243, base: "/",
    url: url_PutTeamsTeamIdMembershipsUsername_579244, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdMembershipsUsername_579232 = ref object of OpenApiRestCall_576564
proc url_GetTeamsTeamIdMembershipsUsername_579234(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/memberships/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdMembershipsUsername_579233(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get team membership.
  ## In order to get a user's membership with a team, the authenticated user must be a member of the team or an owner of the team's organization.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  ##   username: JString (required)
  ##           : Name of a member.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_579235 = path.getOrDefault("teamId")
  valid_579235 = validateParameter(valid_579235, JInt, required = true, default = nil)
  if valid_579235 != nil:
    section.add "teamId", valid_579235
  var valid_579236 = path.getOrDefault("username")
  valid_579236 = validateParameter(valid_579236, JString, required = true,
                                 default = nil)
  if valid_579236 != nil:
    section.add "username", valid_579236
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579237 = header.getOrDefault("Accept")
  valid_579237 = validateParameter(valid_579237, JString, required = false,
                                 default = nil)
  if valid_579237 != nil:
    section.add "Accept", valid_579237
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579238: Call_GetTeamsTeamIdMembershipsUsername_579232;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get team membership.
  ## In order to get a user's membership with a team, the authenticated user must be a member of the team or an owner of the team's organization.
  ## 
  ## 
  let valid = call_579238.validator(path, query, header, formData, body)
  let scheme = call_579238.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579238.url(scheme.get, call_579238.host, call_579238.base,
                         call_579238.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579238, url, valid)

proc call*(call_579239: Call_GetTeamsTeamIdMembershipsUsername_579232; teamId: int;
          username: string; Accept: string = ""): Recallable =
  ## getTeamsTeamIdMembershipsUsername
  ## Get team membership.
  ## In order to get a user's membership with a team, the authenticated user must be a member of the team or an owner of the team's organization.
  ## 
  ##   teamId: int (required)
  ##         : Id of team.
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579240 = newJObject()
  var header_579241 = newJObject()
  add(path_579240, "teamId", newJInt(teamId))
  add(path_579240, "username", newJString(username))
  add(header_579241, "Accept", newJString(Accept))
  result = call_579239.call(path_579240, nil, header_579241, nil, nil)

var getTeamsTeamIdMembershipsUsername* = Call_GetTeamsTeamIdMembershipsUsername_579232(
    name: "getTeamsTeamIdMembershipsUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/teams/{teamId}/memberships/{username}",
    validator: validate_GetTeamsTeamIdMembershipsUsername_579233, base: "/",
    url: url_GetTeamsTeamIdMembershipsUsername_579234, schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamIdMembershipsUsername_579252 = ref object of OpenApiRestCall_576564
proc url_DeleteTeamsTeamIdMembershipsUsername_579254(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/memberships/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamIdMembershipsUsername_579253(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Remove team membership.
  ## In order to remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. NOTE: This does not delete the user, it just removes their membership from the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  ##   username: JString (required)
  ##           : Name of a member.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_579255 = path.getOrDefault("teamId")
  valid_579255 = validateParameter(valid_579255, JInt, required = true, default = nil)
  if valid_579255 != nil:
    section.add "teamId", valid_579255
  var valid_579256 = path.getOrDefault("username")
  valid_579256 = validateParameter(valid_579256, JString, required = true,
                                 default = nil)
  if valid_579256 != nil:
    section.add "username", valid_579256
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579257 = header.getOrDefault("Accept")
  valid_579257 = validateParameter(valid_579257, JString, required = false,
                                 default = nil)
  if valid_579257 != nil:
    section.add "Accept", valid_579257
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579258: Call_DeleteTeamsTeamIdMembershipsUsername_579252;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Remove team membership.
  ## In order to remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. NOTE: This does not delete the user, it just removes their membership from the team.
  ## 
  ## 
  let valid = call_579258.validator(path, query, header, formData, body)
  let scheme = call_579258.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579258.url(scheme.get, call_579258.host, call_579258.base,
                         call_579258.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579258, url, valid)

proc call*(call_579259: Call_DeleteTeamsTeamIdMembershipsUsername_579252;
          teamId: int; username: string; Accept: string = ""): Recallable =
  ## deleteTeamsTeamIdMembershipsUsername
  ## Remove team membership.
  ## In order to remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. NOTE: This does not delete the user, it just removes their membership from the team.
  ## 
  ##   teamId: int (required)
  ##         : Id of team.
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579260 = newJObject()
  var header_579261 = newJObject()
  add(path_579260, "teamId", newJInt(teamId))
  add(path_579260, "username", newJString(username))
  add(header_579261, "Accept", newJString(Accept))
  result = call_579259.call(path_579260, nil, header_579261, nil, nil)

var deleteTeamsTeamIdMembershipsUsername* = Call_DeleteTeamsTeamIdMembershipsUsername_579252(
    name: "deleteTeamsTeamIdMembershipsUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/teams/{teamId}/memberships/{username}",
    validator: validate_DeleteTeamsTeamIdMembershipsUsername_579253, base: "/",
    url: url_DeleteTeamsTeamIdMembershipsUsername_579254, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdRepos_579262 = ref object of OpenApiRestCall_576564
proc url_GetTeamsTeamIdRepos_579264(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdRepos_579263(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## List team repos
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_579265 = path.getOrDefault("teamId")
  valid_579265 = validateParameter(valid_579265, JInt, required = true, default = nil)
  if valid_579265 != nil:
    section.add "teamId", valid_579265
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579266 = header.getOrDefault("Accept")
  valid_579266 = validateParameter(valid_579266, JString, required = false,
                                 default = nil)
  if valid_579266 != nil:
    section.add "Accept", valid_579266
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579267: Call_GetTeamsTeamIdRepos_579262; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List team repos
  ## 
  let valid = call_579267.validator(path, query, header, formData, body)
  let scheme = call_579267.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579267.url(scheme.get, call_579267.host, call_579267.base,
                         call_579267.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579267, url, valid)

proc call*(call_579268: Call_GetTeamsTeamIdRepos_579262; teamId: int;
          Accept: string = ""): Recallable =
  ## getTeamsTeamIdRepos
  ## List team repos
  ##   teamId: int (required)
  ##         : Id of team.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579269 = newJObject()
  var header_579270 = newJObject()
  add(path_579269, "teamId", newJInt(teamId))
  add(header_579270, "Accept", newJString(Accept))
  result = call_579268.call(path_579269, nil, header_579270, nil, nil)

var getTeamsTeamIdRepos* = Call_GetTeamsTeamIdRepos_579262(
    name: "getTeamsTeamIdRepos", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/teams/{teamId}/repos", validator: validate_GetTeamsTeamIdRepos_579263,
    base: "/", url: url_GetTeamsTeamIdRepos_579264, schemes: {Scheme.Https})
type
  Call_PutTeamsTeamIdReposOwnerRepo_579282 = ref object of OpenApiRestCall_576564
proc url_PutTeamsTeamIdReposOwnerRepo_579284(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutTeamsTeamIdReposOwnerRepo_579283(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## In order to add a repository to a team, the authenticated user must be an owner of the org that the team is associated with. Also, the repository must be owned by the organization, or a direct fork of a repository owned by the organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   teamId: JInt (required)
  ##         : Id of team.
  ##   owner: JString (required)
  ##        : Name of a organization.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_579285 = path.getOrDefault("repo")
  valid_579285 = validateParameter(valid_579285, JString, required = true,
                                 default = nil)
  if valid_579285 != nil:
    section.add "repo", valid_579285
  var valid_579286 = path.getOrDefault("teamId")
  valid_579286 = validateParameter(valid_579286, JInt, required = true, default = nil)
  if valid_579286 != nil:
    section.add "teamId", valid_579286
  var valid_579287 = path.getOrDefault("owner")
  valid_579287 = validateParameter(valid_579287, JString, required = true,
                                 default = nil)
  if valid_579287 != nil:
    section.add "owner", valid_579287
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579288 = header.getOrDefault("Accept")
  valid_579288 = validateParameter(valid_579288, JString, required = false,
                                 default = nil)
  if valid_579288 != nil:
    section.add "Accept", valid_579288
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579289: Call_PutTeamsTeamIdReposOwnerRepo_579282; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## In order to add a repository to a team, the authenticated user must be an owner of the org that the team is associated with. Also, the repository must be owned by the organization, or a direct fork of a repository owned by the organization.
  ## 
  let valid = call_579289.validator(path, query, header, formData, body)
  let scheme = call_579289.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579289.url(scheme.get, call_579289.host, call_579289.base,
                         call_579289.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579289, url, valid)

proc call*(call_579290: Call_PutTeamsTeamIdReposOwnerRepo_579282; repo: string;
          teamId: int; owner: string; Accept: string = ""): Recallable =
  ## putTeamsTeamIdReposOwnerRepo
  ## In order to add a repository to a team, the authenticated user must be an owner of the org that the team is associated with. Also, the repository must be owned by the organization, or a direct fork of a repository owned by the organization.
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   teamId: int (required)
  ##         : Id of team.
  ##   owner: string (required)
  ##        : Name of a organization.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579291 = newJObject()
  var header_579292 = newJObject()
  add(path_579291, "repo", newJString(repo))
  add(path_579291, "teamId", newJInt(teamId))
  add(path_579291, "owner", newJString(owner))
  add(header_579292, "Accept", newJString(Accept))
  result = call_579290.call(path_579291, nil, header_579292, nil, nil)

var putTeamsTeamIdReposOwnerRepo* = Call_PutTeamsTeamIdReposOwnerRepo_579282(
    name: "putTeamsTeamIdReposOwnerRepo", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/teams/{teamId}/repos/{owner}/{repo}",
    validator: validate_PutTeamsTeamIdReposOwnerRepo_579283, base: "/",
    url: url_PutTeamsTeamIdReposOwnerRepo_579284, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdReposOwnerRepo_579271 = ref object of OpenApiRestCall_576564
proc url_GetTeamsTeamIdReposOwnerRepo_579273(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdReposOwnerRepo_579272(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Check if a team manages a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   teamId: JInt (required)
  ##         : Id of team.
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_579274 = path.getOrDefault("repo")
  valid_579274 = validateParameter(valid_579274, JString, required = true,
                                 default = nil)
  if valid_579274 != nil:
    section.add "repo", valid_579274
  var valid_579275 = path.getOrDefault("teamId")
  valid_579275 = validateParameter(valid_579275, JInt, required = true, default = nil)
  if valid_579275 != nil:
    section.add "teamId", valid_579275
  var valid_579276 = path.getOrDefault("owner")
  valid_579276 = validateParameter(valid_579276, JString, required = true,
                                 default = nil)
  if valid_579276 != nil:
    section.add "owner", valid_579276
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579277 = header.getOrDefault("Accept")
  valid_579277 = validateParameter(valid_579277, JString, required = false,
                                 default = nil)
  if valid_579277 != nil:
    section.add "Accept", valid_579277
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579278: Call_GetTeamsTeamIdReposOwnerRepo_579271; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Check if a team manages a repository
  ## 
  let valid = call_579278.validator(path, query, header, formData, body)
  let scheme = call_579278.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579278.url(scheme.get, call_579278.host, call_579278.base,
                         call_579278.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579278, url, valid)

proc call*(call_579279: Call_GetTeamsTeamIdReposOwnerRepo_579271; repo: string;
          teamId: int; owner: string; Accept: string = ""): Recallable =
  ## getTeamsTeamIdReposOwnerRepo
  ## Check if a team manages a repository
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   teamId: int (required)
  ##         : Id of team.
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579280 = newJObject()
  var header_579281 = newJObject()
  add(path_579280, "repo", newJString(repo))
  add(path_579280, "teamId", newJInt(teamId))
  add(path_579280, "owner", newJString(owner))
  add(header_579281, "Accept", newJString(Accept))
  result = call_579279.call(path_579280, nil, header_579281, nil, nil)

var getTeamsTeamIdReposOwnerRepo* = Call_GetTeamsTeamIdReposOwnerRepo_579271(
    name: "getTeamsTeamIdReposOwnerRepo", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/teams/{teamId}/repos/{owner}/{repo}",
    validator: validate_GetTeamsTeamIdReposOwnerRepo_579272, base: "/",
    url: url_GetTeamsTeamIdReposOwnerRepo_579273, schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamIdReposOwnerRepo_579293 = ref object of OpenApiRestCall_576564
proc url_DeleteTeamsTeamIdReposOwnerRepo_579295(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamIdReposOwnerRepo_579294(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## In order to remove a repository from a team, the authenticated user must be an owner of the org that the team is associated with. NOTE: This does not delete the repository, it just removes it from the team.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   teamId: JInt (required)
  ##         : Id of team.
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_579296 = path.getOrDefault("repo")
  valid_579296 = validateParameter(valid_579296, JString, required = true,
                                 default = nil)
  if valid_579296 != nil:
    section.add "repo", valid_579296
  var valid_579297 = path.getOrDefault("teamId")
  valid_579297 = validateParameter(valid_579297, JInt, required = true, default = nil)
  if valid_579297 != nil:
    section.add "teamId", valid_579297
  var valid_579298 = path.getOrDefault("owner")
  valid_579298 = validateParameter(valid_579298, JString, required = true,
                                 default = nil)
  if valid_579298 != nil:
    section.add "owner", valid_579298
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579299 = header.getOrDefault("Accept")
  valid_579299 = validateParameter(valid_579299, JString, required = false,
                                 default = nil)
  if valid_579299 != nil:
    section.add "Accept", valid_579299
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579300: Call_DeleteTeamsTeamIdReposOwnerRepo_579293;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## In order to remove a repository from a team, the authenticated user must be an owner of the org that the team is associated with. NOTE: This does not delete the repository, it just removes it from the team.
  ## 
  let valid = call_579300.validator(path, query, header, formData, body)
  let scheme = call_579300.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579300.url(scheme.get, call_579300.host, call_579300.base,
                         call_579300.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579300, url, valid)

proc call*(call_579301: Call_DeleteTeamsTeamIdReposOwnerRepo_579293; repo: string;
          teamId: int; owner: string; Accept: string = ""): Recallable =
  ## deleteTeamsTeamIdReposOwnerRepo
  ## In order to remove a repository from a team, the authenticated user must be an owner of the org that the team is associated with. NOTE: This does not delete the repository, it just removes it from the team.
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   teamId: int (required)
  ##         : Id of team.
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579302 = newJObject()
  var header_579303 = newJObject()
  add(path_579302, "repo", newJString(repo))
  add(path_579302, "teamId", newJInt(teamId))
  add(path_579302, "owner", newJString(owner))
  add(header_579303, "Accept", newJString(Accept))
  result = call_579301.call(path_579302, nil, header_579303, nil, nil)

var deleteTeamsTeamIdReposOwnerRepo* = Call_DeleteTeamsTeamIdReposOwnerRepo_579293(
    name: "deleteTeamsTeamIdReposOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/teams/{teamId}/repos/{owner}/{repo}",
    validator: validate_DeleteTeamsTeamIdReposOwnerRepo_579294, base: "/",
    url: url_DeleteTeamsTeamIdReposOwnerRepo_579295, schemes: {Scheme.Https})
type
  Call_GetUser_579304 = ref object of OpenApiRestCall_576564
proc url_GetUser_579306(protocol: Scheme; host: string; base: string; route: string;
                       path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUser_579305(path: JsonNode; query: JsonNode; header: JsonNode;
                            formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579307 = header.getOrDefault("Accept")
  valid_579307 = validateParameter(valid_579307, JString, required = false,
                                 default = nil)
  if valid_579307 != nil:
    section.add "Accept", valid_579307
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579308: Call_GetUser_579304; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get the authenticated user.
  ## 
  let valid = call_579308.validator(path, query, header, formData, body)
  let scheme = call_579308.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579308.url(scheme.get, call_579308.host, call_579308.base,
                         call_579308.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579308, url, valid)

proc call*(call_579309: Call_GetUser_579304; Accept: string = ""): Recallable =
  ## getUser
  ## Get the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_579310 = newJObject()
  add(header_579310, "Accept", newJString(Accept))
  result = call_579309.call(nil, nil, header_579310, nil, nil)

var getUser* = Call_GetUser_579304(name: "getUser", meth: HttpMethod.HttpGet,
                                host: "api.github.com", route: "/user",
                                validator: validate_GetUser_579305, base: "/",
                                url: url_GetUser_579306, schemes: {Scheme.Https})
type
  Call_PatchUser_579311 = ref object of OpenApiRestCall_576564
proc url_PatchUser_579313(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PatchUser_579312(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Update the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579314 = header.getOrDefault("Accept")
  valid_579314 = validateParameter(valid_579314, JString, required = false,
                                 default = nil)
  if valid_579314 != nil:
    section.add "Accept", valid_579314
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579316: Call_PatchUser_579311; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Update the authenticated user.
  ## 
  let valid = call_579316.validator(path, query, header, formData, body)
  let scheme = call_579316.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579316.url(scheme.get, call_579316.host, call_579316.base,
                         call_579316.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579316, url, valid)

proc call*(call_579317: Call_PatchUser_579311; body: JsonNode; Accept: string = ""): Recallable =
  ## patchUser
  ## Update the authenticated user.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_579318 = newJObject()
  var body_579319 = newJObject()
  if body != nil:
    body_579319 = body
  add(header_579318, "Accept", newJString(Accept))
  result = call_579317.call(nil, nil, header_579318, nil, body_579319)

var patchUser* = Call_PatchUser_579311(name: "patchUser", meth: HttpMethod.HttpPatch,
                                    host: "api.github.com", route: "/user",
                                    validator: validate_PatchUser_579312,
                                    base: "/", url: url_PatchUser_579313,
                                    schemes: {Scheme.Https})
type
  Call_PostUserEmails_579327 = ref object of OpenApiRestCall_576564
proc url_PostUserEmails_579329(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostUserEmails_579328(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Add email address(es).
  ## You can post a single email address or an array of addresses.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579330 = header.getOrDefault("Accept")
  valid_579330 = validateParameter(valid_579330, JString, required = false,
                                 default = nil)
  if valid_579330 != nil:
    section.add "Accept", valid_579330
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579332: Call_PostUserEmails_579327; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Add email address(es).
  ## You can post a single email address or an array of addresses.
  ## 
  ## 
  let valid = call_579332.validator(path, query, header, formData, body)
  let scheme = call_579332.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579332.url(scheme.get, call_579332.host, call_579332.base,
                         call_579332.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579332, url, valid)

proc call*(call_579333: Call_PostUserEmails_579327; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postUserEmails
  ## Add email address(es).
  ## You can post a single email address or an array of addresses.
  ## 
  ##   body: JArray (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_579334 = newJObject()
  var body_579335 = newJObject()
  if body != nil:
    body_579335 = body
  add(header_579334, "Accept", newJString(Accept))
  result = call_579333.call(nil, nil, header_579334, nil, body_579335)

var postUserEmails* = Call_PostUserEmails_579327(name: "postUserEmails",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/user/emails",
    validator: validate_PostUserEmails_579328, base: "/", url: url_PostUserEmails_579329,
    schemes: {Scheme.Https})
type
  Call_GetUserEmails_579320 = ref object of OpenApiRestCall_576564
proc url_GetUserEmails_579322(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserEmails_579321(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## List email addresses for a user.
  ## In the final version of the API, this method will return an array of hashes
  ## with extended information for each email address indicating if the address
  ## has been verified and if it's primary email address for GitHub.
  ## Until API v3 is finalized, use the application/vnd.github.v3 media type to
  ## get other response format.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579323 = header.getOrDefault("Accept")
  valid_579323 = validateParameter(valid_579323, JString, required = false,
                                 default = nil)
  if valid_579323 != nil:
    section.add "Accept", valid_579323
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579324: Call_GetUserEmails_579320; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List email addresses for a user.
  ## In the final version of the API, this method will return an array of hashes
  ## with extended information for each email address indicating if the address
  ## has been verified and if it's primary email address for GitHub.
  ## Until API v3 is finalized, use the application/vnd.github.v3 media type to
  ## get other response format.
  ## 
  ## 
  let valid = call_579324.validator(path, query, header, formData, body)
  let scheme = call_579324.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579324.url(scheme.get, call_579324.host, call_579324.base,
                         call_579324.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579324, url, valid)

proc call*(call_579325: Call_GetUserEmails_579320; Accept: string = ""): Recallable =
  ## getUserEmails
  ## List email addresses for a user.
  ## In the final version of the API, this method will return an array of hashes
  ## with extended information for each email address indicating if the address
  ## has been verified and if it's primary email address for GitHub.
  ## Until API v3 is finalized, use the application/vnd.github.v3 media type to
  ## get other response format.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_579326 = newJObject()
  add(header_579326, "Accept", newJString(Accept))
  result = call_579325.call(nil, nil, header_579326, nil, nil)

var getUserEmails* = Call_GetUserEmails_579320(name: "getUserEmails",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/emails",
    validator: validate_GetUserEmails_579321, base: "/", url: url_GetUserEmails_579322,
    schemes: {Scheme.Https})
type
  Call_DeleteUserEmails_579336 = ref object of OpenApiRestCall_576564
proc url_DeleteUserEmails_579338(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DeleteUserEmails_579337(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Delete email address(es).
  ## You can include a single email address or an array of addresses.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579339 = header.getOrDefault("Accept")
  valid_579339 = validateParameter(valid_579339, JString, required = false,
                                 default = nil)
  if valid_579339 != nil:
    section.add "Accept", valid_579339
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579341: Call_DeleteUserEmails_579336; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete email address(es).
  ## You can include a single email address or an array of addresses.
  ## 
  ## 
  let valid = call_579341.validator(path, query, header, formData, body)
  let scheme = call_579341.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579341.url(scheme.get, call_579341.host, call_579341.base,
                         call_579341.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579341, url, valid)

proc call*(call_579342: Call_DeleteUserEmails_579336; body: JsonNode;
          Accept: string = ""): Recallable =
  ## deleteUserEmails
  ## Delete email address(es).
  ## You can include a single email address or an array of addresses.
  ## 
  ##   body: JArray (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_579343 = newJObject()
  var body_579344 = newJObject()
  if body != nil:
    body_579344 = body
  add(header_579343, "Accept", newJString(Accept))
  result = call_579342.call(nil, nil, header_579343, nil, body_579344)

var deleteUserEmails* = Call_DeleteUserEmails_579336(name: "deleteUserEmails",
    meth: HttpMethod.HttpDelete, host: "api.github.com", route: "/user/emails",
    validator: validate_DeleteUserEmails_579337, base: "/",
    url: url_DeleteUserEmails_579338, schemes: {Scheme.Https})
type
  Call_GetUserFollowers_579345 = ref object of OpenApiRestCall_576564
proc url_GetUserFollowers_579347(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserFollowers_579346(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## List the authenticated user's followers
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579348 = header.getOrDefault("Accept")
  valid_579348 = validateParameter(valid_579348, JString, required = false,
                                 default = nil)
  if valid_579348 != nil:
    section.add "Accept", valid_579348
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579349: Call_GetUserFollowers_579345; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the authenticated user's followers
  ## 
  let valid = call_579349.validator(path, query, header, formData, body)
  let scheme = call_579349.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579349.url(scheme.get, call_579349.host, call_579349.base,
                         call_579349.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579349, url, valid)

proc call*(call_579350: Call_GetUserFollowers_579345; Accept: string = ""): Recallable =
  ## getUserFollowers
  ## List the authenticated user's followers
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_579351 = newJObject()
  add(header_579351, "Accept", newJString(Accept))
  result = call_579350.call(nil, nil, header_579351, nil, nil)

var getUserFollowers* = Call_GetUserFollowers_579345(name: "getUserFollowers",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/followers",
    validator: validate_GetUserFollowers_579346, base: "/",
    url: url_GetUserFollowers_579347, schemes: {Scheme.Https})
type
  Call_GetUserFollowing_579352 = ref object of OpenApiRestCall_576564
proc url_GetUserFollowing_579354(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserFollowing_579353(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## List who the authenticated user is following.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579355 = header.getOrDefault("Accept")
  valid_579355 = validateParameter(valid_579355, JString, required = false,
                                 default = nil)
  if valid_579355 != nil:
    section.add "Accept", valid_579355
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579356: Call_GetUserFollowing_579352; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List who the authenticated user is following.
  ## 
  let valid = call_579356.validator(path, query, header, formData, body)
  let scheme = call_579356.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579356.url(scheme.get, call_579356.host, call_579356.base,
                         call_579356.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579356, url, valid)

proc call*(call_579357: Call_GetUserFollowing_579352; Accept: string = ""): Recallable =
  ## getUserFollowing
  ## List who the authenticated user is following.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_579358 = newJObject()
  add(header_579358, "Accept", newJString(Accept))
  result = call_579357.call(nil, nil, header_579358, nil, nil)

var getUserFollowing* = Call_GetUserFollowing_579352(name: "getUserFollowing",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/following",
    validator: validate_GetUserFollowing_579353, base: "/",
    url: url_GetUserFollowing_579354, schemes: {Scheme.Https})
type
  Call_PutUserFollowingUsername_579368 = ref object of OpenApiRestCall_576564
proc url_PutUserFollowingUsername_579370(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/following/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutUserFollowingUsername_579369(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Follow a user.
  ## Following a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_579371 = path.getOrDefault("username")
  valid_579371 = validateParameter(valid_579371, JString, required = true,
                                 default = nil)
  if valid_579371 != nil:
    section.add "username", valid_579371
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579372 = header.getOrDefault("Accept")
  valid_579372 = validateParameter(valid_579372, JString, required = false,
                                 default = nil)
  if valid_579372 != nil:
    section.add "Accept", valid_579372
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579373: Call_PutUserFollowingUsername_579368; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Follow a user.
  ## Following a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  let valid = call_579373.validator(path, query, header, formData, body)
  let scheme = call_579373.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579373.url(scheme.get, call_579373.host, call_579373.base,
                         call_579373.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579373, url, valid)

proc call*(call_579374: Call_PutUserFollowingUsername_579368; username: string;
          Accept: string = ""): Recallable =
  ## putUserFollowingUsername
  ## Follow a user.
  ## Following a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579375 = newJObject()
  var header_579376 = newJObject()
  add(path_579375, "username", newJString(username))
  add(header_579376, "Accept", newJString(Accept))
  result = call_579374.call(path_579375, nil, header_579376, nil, nil)

var putUserFollowingUsername* = Call_PutUserFollowingUsername_579368(
    name: "putUserFollowingUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/user/following/{username}",
    validator: validate_PutUserFollowingUsername_579369, base: "/",
    url: url_PutUserFollowingUsername_579370, schemes: {Scheme.Https})
type
  Call_GetUserFollowingUsername_579359 = ref object of OpenApiRestCall_576564
proc url_GetUserFollowingUsername_579361(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/following/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserFollowingUsername_579360(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Check if you are following a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_579362 = path.getOrDefault("username")
  valid_579362 = validateParameter(valid_579362, JString, required = true,
                                 default = nil)
  if valid_579362 != nil:
    section.add "username", valid_579362
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579363 = header.getOrDefault("Accept")
  valid_579363 = validateParameter(valid_579363, JString, required = false,
                                 default = nil)
  if valid_579363 != nil:
    section.add "Accept", valid_579363
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579364: Call_GetUserFollowingUsername_579359; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Check if you are following a user.
  ## 
  let valid = call_579364.validator(path, query, header, formData, body)
  let scheme = call_579364.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579364.url(scheme.get, call_579364.host, call_579364.base,
                         call_579364.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579364, url, valid)

proc call*(call_579365: Call_GetUserFollowingUsername_579359; username: string;
          Accept: string = ""): Recallable =
  ## getUserFollowingUsername
  ## Check if you are following a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579366 = newJObject()
  var header_579367 = newJObject()
  add(path_579366, "username", newJString(username))
  add(header_579367, "Accept", newJString(Accept))
  result = call_579365.call(path_579366, nil, header_579367, nil, nil)

var getUserFollowingUsername* = Call_GetUserFollowingUsername_579359(
    name: "getUserFollowingUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/user/following/{username}",
    validator: validate_GetUserFollowingUsername_579360, base: "/",
    url: url_GetUserFollowingUsername_579361, schemes: {Scheme.Https})
type
  Call_DeleteUserFollowingUsername_579377 = ref object of OpenApiRestCall_576564
proc url_DeleteUserFollowingUsername_579379(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/following/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserFollowingUsername_579378(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Unfollow a user.
  ## Unfollowing a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_579380 = path.getOrDefault("username")
  valid_579380 = validateParameter(valid_579380, JString, required = true,
                                 default = nil)
  if valid_579380 != nil:
    section.add "username", valid_579380
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579381 = header.getOrDefault("Accept")
  valid_579381 = validateParameter(valid_579381, JString, required = false,
                                 default = nil)
  if valid_579381 != nil:
    section.add "Accept", valid_579381
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579382: Call_DeleteUserFollowingUsername_579377; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Unfollow a user.
  ## Unfollowing a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  let valid = call_579382.validator(path, query, header, formData, body)
  let scheme = call_579382.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579382.url(scheme.get, call_579382.host, call_579382.base,
                         call_579382.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579382, url, valid)

proc call*(call_579383: Call_DeleteUserFollowingUsername_579377; username: string;
          Accept: string = ""): Recallable =
  ## deleteUserFollowingUsername
  ## Unfollow a user.
  ## Unfollowing a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579384 = newJObject()
  var header_579385 = newJObject()
  add(path_579384, "username", newJString(username))
  add(header_579385, "Accept", newJString(Accept))
  result = call_579383.call(path_579384, nil, header_579385, nil, nil)

var deleteUserFollowingUsername* = Call_DeleteUserFollowingUsername_579377(
    name: "deleteUserFollowingUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/following/{username}",
    validator: validate_DeleteUserFollowingUsername_579378, base: "/",
    url: url_DeleteUserFollowingUsername_579379, schemes: {Scheme.Https})
type
  Call_GetUserIssues_579386 = ref object of OpenApiRestCall_576564
proc url_GetUserIssues_579388(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserIssues_579387(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## List issues.
  ## List all issues across owned and member repositories for the authenticated
  ## user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   direction: JString (required)
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  ##   state: JString (required)
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   sort: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `labels` field"
  var valid_579389 = query.getOrDefault("labels")
  valid_579389 = validateParameter(valid_579389, JString, required = true,
                                 default = nil)
  if valid_579389 != nil:
    section.add "labels", valid_579389
  var valid_579390 = query.getOrDefault("direction")
  valid_579390 = validateParameter(valid_579390, JString, required = true,
                                 default = newJString("desc"))
  if valid_579390 != nil:
    section.add "direction", valid_579390
  var valid_579391 = query.getOrDefault("since")
  valid_579391 = validateParameter(valid_579391, JString, required = false,
                                 default = nil)
  if valid_579391 != nil:
    section.add "since", valid_579391
  var valid_579392 = query.getOrDefault("state")
  valid_579392 = validateParameter(valid_579392, JString, required = true,
                                 default = newJString("open"))
  if valid_579392 != nil:
    section.add "state", valid_579392
  var valid_579393 = query.getOrDefault("filter")
  valid_579393 = validateParameter(valid_579393, JString, required = true,
                                 default = newJString("all"))
  if valid_579393 != nil:
    section.add "filter", valid_579393
  var valid_579394 = query.getOrDefault("sort")
  valid_579394 = validateParameter(valid_579394, JString, required = true,
                                 default = newJString("created"))
  if valid_579394 != nil:
    section.add "sort", valid_579394
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579395 = header.getOrDefault("Accept")
  valid_579395 = validateParameter(valid_579395, JString, required = false,
                                 default = nil)
  if valid_579395 != nil:
    section.add "Accept", valid_579395
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579396: Call_GetUserIssues_579386; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List issues.
  ## List all issues across owned and member repositories for the authenticated
  ## user.
  ## 
  ## 
  let valid = call_579396.validator(path, query, header, formData, body)
  let scheme = call_579396.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579396.url(scheme.get, call_579396.host, call_579396.base,
                         call_579396.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579396, url, valid)

proc call*(call_579397: Call_GetUserIssues_579386; labels: string;
          direction: string = "desc"; since: string = ""; state: string = "open";
          filter: string = "all"; Accept: string = ""; sort: string = "created"): Recallable =
  ## getUserIssues
  ## List issues.
  ## List all issues across owned and member repositories for the authenticated
  ## user.
  ## 
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   direction: string (required)
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  ##   state: string (required)
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string (required)
  var query_579398 = newJObject()
  var header_579399 = newJObject()
  add(query_579398, "labels", newJString(labels))
  add(query_579398, "direction", newJString(direction))
  add(query_579398, "since", newJString(since))
  add(query_579398, "state", newJString(state))
  add(query_579398, "filter", newJString(filter))
  add(header_579399, "Accept", newJString(Accept))
  add(query_579398, "sort", newJString(sort))
  result = call_579397.call(nil, query_579398, header_579399, nil, nil)

var getUserIssues* = Call_GetUserIssues_579386(name: "getUserIssues",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/issues",
    validator: validate_GetUserIssues_579387, base: "/", url: url_GetUserIssues_579388,
    schemes: {Scheme.Https})
type
  Call_PostUserKeys_579407 = ref object of OpenApiRestCall_576564
proc url_PostUserKeys_579409(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostUserKeys_579408(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a public key.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579410 = header.getOrDefault("Accept")
  valid_579410 = validateParameter(valid_579410, JString, required = false,
                                 default = nil)
  if valid_579410 != nil:
    section.add "Accept", valid_579410
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579412: Call_PostUserKeys_579407; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a public key.
  ## 
  let valid = call_579412.validator(path, query, header, formData, body)
  let scheme = call_579412.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579412.url(scheme.get, call_579412.host, call_579412.base,
                         call_579412.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579412, url, valid)

proc call*(call_579413: Call_PostUserKeys_579407; body: JsonNode; Accept: string = ""): Recallable =
  ## postUserKeys
  ## Create a public key.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_579414 = newJObject()
  var body_579415 = newJObject()
  if body != nil:
    body_579415 = body
  add(header_579414, "Accept", newJString(Accept))
  result = call_579413.call(nil, nil, header_579414, nil, body_579415)

var postUserKeys* = Call_PostUserKeys_579407(name: "postUserKeys",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/user/keys",
    validator: validate_PostUserKeys_579408, base: "/", url: url_PostUserKeys_579409,
    schemes: {Scheme.Https})
type
  Call_GetUserKeys_579400 = ref object of OpenApiRestCall_576564
proc url_GetUserKeys_579402(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserKeys_579401(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## List your public keys.
  ## Lists the current user's keys. Management of public keys via the API requires
  ## that you are authenticated through basic auth, or OAuth with the 'user', 'write:public_key' scopes.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579403 = header.getOrDefault("Accept")
  valid_579403 = validateParameter(valid_579403, JString, required = false,
                                 default = nil)
  if valid_579403 != nil:
    section.add "Accept", valid_579403
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579404: Call_GetUserKeys_579400; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List your public keys.
  ## Lists the current user's keys. Management of public keys via the API requires
  ## that you are authenticated through basic auth, or OAuth with the 'user', 'write:public_key' scopes.
  ## 
  ## 
  let valid = call_579404.validator(path, query, header, formData, body)
  let scheme = call_579404.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579404.url(scheme.get, call_579404.host, call_579404.base,
                         call_579404.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579404, url, valid)

proc call*(call_579405: Call_GetUserKeys_579400; Accept: string = ""): Recallable =
  ## getUserKeys
  ## List your public keys.
  ## Lists the current user's keys. Management of public keys via the API requires
  ## that you are authenticated through basic auth, or OAuth with the 'user', 'write:public_key' scopes.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_579406 = newJObject()
  add(header_579406, "Accept", newJString(Accept))
  result = call_579405.call(nil, nil, header_579406, nil, nil)

var getUserKeys* = Call_GetUserKeys_579400(name: "getUserKeys",
                                        meth: HttpMethod.HttpGet,
                                        host: "api.github.com",
                                        route: "/user/keys",
                                        validator: validate_GetUserKeys_579401,
                                        base: "/", url: url_GetUserKeys_579402,
                                        schemes: {Scheme.Https})
type
  Call_GetUserKeysKeyId_579416 = ref object of OpenApiRestCall_576564
proc url_GetUserKeysKeyId_579418(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/keys/"),
               (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserKeysKeyId_579417(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Get a single public key.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyId: JInt (required)
  ##        : ID of key.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyId` field"
  var valid_579419 = path.getOrDefault("keyId")
  valid_579419 = validateParameter(valid_579419, JInt, required = true, default = nil)
  if valid_579419 != nil:
    section.add "keyId", valid_579419
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579420 = header.getOrDefault("Accept")
  valid_579420 = validateParameter(valid_579420, JString, required = false,
                                 default = nil)
  if valid_579420 != nil:
    section.add "Accept", valid_579420
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579421: Call_GetUserKeysKeyId_579416; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a single public key.
  ## 
  let valid = call_579421.validator(path, query, header, formData, body)
  let scheme = call_579421.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579421.url(scheme.get, call_579421.host, call_579421.base,
                         call_579421.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579421, url, valid)

proc call*(call_579422: Call_GetUserKeysKeyId_579416; keyId: int; Accept: string = ""): Recallable =
  ## getUserKeysKeyId
  ## Get a single public key.
  ##   keyId: int (required)
  ##        : ID of key.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579423 = newJObject()
  var header_579424 = newJObject()
  add(path_579423, "keyId", newJInt(keyId))
  add(header_579424, "Accept", newJString(Accept))
  result = call_579422.call(path_579423, nil, header_579424, nil, nil)

var getUserKeysKeyId* = Call_GetUserKeysKeyId_579416(name: "getUserKeysKeyId",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/keys/{keyId}",
    validator: validate_GetUserKeysKeyId_579417, base: "/",
    url: url_GetUserKeysKeyId_579418, schemes: {Scheme.Https})
type
  Call_DeleteUserKeysKeyId_579425 = ref object of OpenApiRestCall_576564
proc url_DeleteUserKeysKeyId_579427(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/keys/"),
               (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserKeysKeyId_579426(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Delete a public key. Removes a public key. Requires that you are authenticated via Basic Auth or via OAuth with at least admin:public_key scope.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyId: JInt (required)
  ##        : ID of key.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyId` field"
  var valid_579428 = path.getOrDefault("keyId")
  valid_579428 = validateParameter(valid_579428, JInt, required = true, default = nil)
  if valid_579428 != nil:
    section.add "keyId", valid_579428
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579429 = header.getOrDefault("Accept")
  valid_579429 = validateParameter(valid_579429, JString, required = false,
                                 default = nil)
  if valid_579429 != nil:
    section.add "Accept", valid_579429
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579430: Call_DeleteUserKeysKeyId_579425; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete a public key. Removes a public key. Requires that you are authenticated via Basic Auth or via OAuth with at least admin:public_key scope.
  ## 
  let valid = call_579430.validator(path, query, header, formData, body)
  let scheme = call_579430.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579430.url(scheme.get, call_579430.host, call_579430.base,
                         call_579430.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579430, url, valid)

proc call*(call_579431: Call_DeleteUserKeysKeyId_579425; keyId: int;
          Accept: string = ""): Recallable =
  ## deleteUserKeysKeyId
  ## Delete a public key. Removes a public key. Requires that you are authenticated via Basic Auth or via OAuth with at least admin:public_key scope.
  ##   keyId: int (required)
  ##        : ID of key.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579432 = newJObject()
  var header_579433 = newJObject()
  add(path_579432, "keyId", newJInt(keyId))
  add(header_579433, "Accept", newJString(Accept))
  result = call_579431.call(path_579432, nil, header_579433, nil, nil)

var deleteUserKeysKeyId* = Call_DeleteUserKeysKeyId_579425(
    name: "deleteUserKeysKeyId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/keys/{keyId}",
    validator: validate_DeleteUserKeysKeyId_579426, base: "/",
    url: url_DeleteUserKeysKeyId_579427, schemes: {Scheme.Https})
type
  Call_GetUserOrgs_579434 = ref object of OpenApiRestCall_576564
proc url_GetUserOrgs_579436(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserOrgs_579435(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## List public and private organizations for the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579437 = header.getOrDefault("Accept")
  valid_579437 = validateParameter(valid_579437, JString, required = false,
                                 default = nil)
  if valid_579437 != nil:
    section.add "Accept", valid_579437
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579438: Call_GetUserOrgs_579434; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List public and private organizations for the authenticated user.
  ## 
  let valid = call_579438.validator(path, query, header, formData, body)
  let scheme = call_579438.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579438.url(scheme.get, call_579438.host, call_579438.base,
                         call_579438.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579438, url, valid)

proc call*(call_579439: Call_GetUserOrgs_579434; Accept: string = ""): Recallable =
  ## getUserOrgs
  ## List public and private organizations for the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_579440 = newJObject()
  add(header_579440, "Accept", newJString(Accept))
  result = call_579439.call(nil, nil, header_579440, nil, nil)

var getUserOrgs* = Call_GetUserOrgs_579434(name: "getUserOrgs",
                                        meth: HttpMethod.HttpGet,
                                        host: "api.github.com",
                                        route: "/user/orgs",
                                        validator: validate_GetUserOrgs_579435,
                                        base: "/", url: url_GetUserOrgs_579436,
                                        schemes: {Scheme.Https})
type
  Call_PostUserRepos_579450 = ref object of OpenApiRestCall_576564
proc url_PostUserRepos_579452(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostUserRepos_579451(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579453 = header.getOrDefault("Accept")
  valid_579453 = validateParameter(valid_579453, JString, required = false,
                                 default = nil)
  if valid_579453 != nil:
    section.add "Accept", valid_579453
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_579455: Call_PostUserRepos_579450; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  let valid = call_579455.validator(path, query, header, formData, body)
  let scheme = call_579455.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579455.url(scheme.get, call_579455.host, call_579455.base,
                         call_579455.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579455, url, valid)

proc call*(call_579456: Call_PostUserRepos_579450; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postUserRepos
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_579457 = newJObject()
  var body_579458 = newJObject()
  if body != nil:
    body_579458 = body
  add(header_579457, "Accept", newJString(Accept))
  result = call_579456.call(nil, nil, header_579457, nil, body_579458)

var postUserRepos* = Call_PostUserRepos_579450(name: "postUserRepos",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/user/repos",
    validator: validate_PostUserRepos_579451, base: "/", url: url_PostUserRepos_579452,
    schemes: {Scheme.Https})
type
  Call_GetUserRepos_579441 = ref object of OpenApiRestCall_576564
proc url_GetUserRepos_579443(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserRepos_579442(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## List repositories for the authenticated user. Note that this does not include
  ## repositories owned by organizations which the user can access. You can lis
  ## user organizations and list organization repositories separately.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   type: JString
  section = newJObject()
  var valid_579444 = query.getOrDefault("type")
  valid_579444 = validateParameter(valid_579444, JString, required = false,
                                 default = newJString("all"))
  if valid_579444 != nil:
    section.add "type", valid_579444
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579445 = header.getOrDefault("Accept")
  valid_579445 = validateParameter(valid_579445, JString, required = false,
                                 default = nil)
  if valid_579445 != nil:
    section.add "Accept", valid_579445
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579446: Call_GetUserRepos_579441; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List repositories for the authenticated user. Note that this does not include
  ## repositories owned by organizations which the user can access. You can lis
  ## user organizations and list organization repositories separately.
  ## 
  ## 
  let valid = call_579446.validator(path, query, header, formData, body)
  let scheme = call_579446.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579446.url(scheme.get, call_579446.host, call_579446.base,
                         call_579446.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579446, url, valid)

proc call*(call_579447: Call_GetUserRepos_579441; `type`: string = "all";
          Accept: string = ""): Recallable =
  ## getUserRepos
  ## List repositories for the authenticated user. Note that this does not include
  ## repositories owned by organizations which the user can access. You can lis
  ## user organizations and list organization repositories separately.
  ## 
  ##   type: string
  ##   Accept: string
  ##         : Is used to set specified media type.
  var query_579448 = newJObject()
  var header_579449 = newJObject()
  add(query_579448, "type", newJString(`type`))
  add(header_579449, "Accept", newJString(Accept))
  result = call_579447.call(nil, query_579448, header_579449, nil, nil)

var getUserRepos* = Call_GetUserRepos_579441(name: "getUserRepos",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/repos",
    validator: validate_GetUserRepos_579442, base: "/", url: url_GetUserRepos_579443,
    schemes: {Scheme.Https})
type
  Call_GetUserStarred_579459 = ref object of OpenApiRestCall_576564
proc url_GetUserStarred_579461(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserStarred_579460(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## List repositories being starred by the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  ##   sort: JString
  section = newJObject()
  var valid_579462 = query.getOrDefault("direction")
  valid_579462 = validateParameter(valid_579462, JString, required = false,
                                 default = nil)
  if valid_579462 != nil:
    section.add "direction", valid_579462
  var valid_579463 = query.getOrDefault("sort")
  valid_579463 = validateParameter(valid_579463, JString, required = false,
                                 default = newJString("created"))
  if valid_579463 != nil:
    section.add "sort", valid_579463
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579464 = header.getOrDefault("Accept")
  valid_579464 = validateParameter(valid_579464, JString, required = false,
                                 default = nil)
  if valid_579464 != nil:
    section.add "Accept", valid_579464
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579465: Call_GetUserStarred_579459; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List repositories being starred by the authenticated user.
  ## 
  let valid = call_579465.validator(path, query, header, formData, body)
  let scheme = call_579465.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579465.url(scheme.get, call_579465.host, call_579465.base,
                         call_579465.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579465, url, valid)

proc call*(call_579466: Call_GetUserStarred_579459; direction: string = "";
          Accept: string = ""; sort: string = "created"): Recallable =
  ## getUserStarred
  ## List repositories being starred by the authenticated user.
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  var query_579467 = newJObject()
  var header_579468 = newJObject()
  add(query_579467, "direction", newJString(direction))
  add(header_579468, "Accept", newJString(Accept))
  add(query_579467, "sort", newJString(sort))
  result = call_579466.call(nil, query_579467, header_579468, nil, nil)

var getUserStarred* = Call_GetUserStarred_579459(name: "getUserStarred",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/starred",
    validator: validate_GetUserStarred_579460, base: "/", url: url_GetUserStarred_579461,
    schemes: {Scheme.Https})
type
  Call_PutUserStarredOwnerRepo_579479 = ref object of OpenApiRestCall_576564
proc url_PutUserStarredOwnerRepo_579481(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/starred/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutUserStarredOwnerRepo_579480(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Star a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_579482 = path.getOrDefault("repo")
  valid_579482 = validateParameter(valid_579482, JString, required = true,
                                 default = nil)
  if valid_579482 != nil:
    section.add "repo", valid_579482
  var valid_579483 = path.getOrDefault("owner")
  valid_579483 = validateParameter(valid_579483, JString, required = true,
                                 default = nil)
  if valid_579483 != nil:
    section.add "owner", valid_579483
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579484 = header.getOrDefault("Accept")
  valid_579484 = validateParameter(valid_579484, JString, required = false,
                                 default = nil)
  if valid_579484 != nil:
    section.add "Accept", valid_579484
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579485: Call_PutUserStarredOwnerRepo_579479; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Star a repository.
  ## 
  let valid = call_579485.validator(path, query, header, formData, body)
  let scheme = call_579485.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579485.url(scheme.get, call_579485.host, call_579485.base,
                         call_579485.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579485, url, valid)

proc call*(call_579486: Call_PutUserStarredOwnerRepo_579479; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## putUserStarredOwnerRepo
  ## Star a repository.
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579487 = newJObject()
  var header_579488 = newJObject()
  add(path_579487, "repo", newJString(repo))
  add(path_579487, "owner", newJString(owner))
  add(header_579488, "Accept", newJString(Accept))
  result = call_579486.call(path_579487, nil, header_579488, nil, nil)

var putUserStarredOwnerRepo* = Call_PutUserStarredOwnerRepo_579479(
    name: "putUserStarredOwnerRepo", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/user/starred/{owner}/{repo}",
    validator: validate_PutUserStarredOwnerRepo_579480, base: "/",
    url: url_PutUserStarredOwnerRepo_579481, schemes: {Scheme.Https})
type
  Call_GetUserStarredOwnerRepo_579469 = ref object of OpenApiRestCall_576564
proc url_GetUserStarredOwnerRepo_579471(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/starred/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserStarredOwnerRepo_579470(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Check if you are starring a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_579472 = path.getOrDefault("repo")
  valid_579472 = validateParameter(valid_579472, JString, required = true,
                                 default = nil)
  if valid_579472 != nil:
    section.add "repo", valid_579472
  var valid_579473 = path.getOrDefault("owner")
  valid_579473 = validateParameter(valid_579473, JString, required = true,
                                 default = nil)
  if valid_579473 != nil:
    section.add "owner", valid_579473
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579474 = header.getOrDefault("Accept")
  valid_579474 = validateParameter(valid_579474, JString, required = false,
                                 default = nil)
  if valid_579474 != nil:
    section.add "Accept", valid_579474
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579475: Call_GetUserStarredOwnerRepo_579469; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Check if you are starring a repository.
  ## 
  let valid = call_579475.validator(path, query, header, formData, body)
  let scheme = call_579475.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579475.url(scheme.get, call_579475.host, call_579475.base,
                         call_579475.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579475, url, valid)

proc call*(call_579476: Call_GetUserStarredOwnerRepo_579469; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getUserStarredOwnerRepo
  ## Check if you are starring a repository.
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579477 = newJObject()
  var header_579478 = newJObject()
  add(path_579477, "repo", newJString(repo))
  add(path_579477, "owner", newJString(owner))
  add(header_579478, "Accept", newJString(Accept))
  result = call_579476.call(path_579477, nil, header_579478, nil, nil)

var getUserStarredOwnerRepo* = Call_GetUserStarredOwnerRepo_579469(
    name: "getUserStarredOwnerRepo", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/user/starred/{owner}/{repo}",
    validator: validate_GetUserStarredOwnerRepo_579470, base: "/",
    url: url_GetUserStarredOwnerRepo_579471, schemes: {Scheme.Https})
type
  Call_DeleteUserStarredOwnerRepo_579489 = ref object of OpenApiRestCall_576564
proc url_DeleteUserStarredOwnerRepo_579491(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/starred/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserStarredOwnerRepo_579490(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Unstar a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_579492 = path.getOrDefault("repo")
  valid_579492 = validateParameter(valid_579492, JString, required = true,
                                 default = nil)
  if valid_579492 != nil:
    section.add "repo", valid_579492
  var valid_579493 = path.getOrDefault("owner")
  valid_579493 = validateParameter(valid_579493, JString, required = true,
                                 default = nil)
  if valid_579493 != nil:
    section.add "owner", valid_579493
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579494 = header.getOrDefault("Accept")
  valid_579494 = validateParameter(valid_579494, JString, required = false,
                                 default = nil)
  if valid_579494 != nil:
    section.add "Accept", valid_579494
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579495: Call_DeleteUserStarredOwnerRepo_579489; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Unstar a repository
  ## 
  let valid = call_579495.validator(path, query, header, formData, body)
  let scheme = call_579495.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579495.url(scheme.get, call_579495.host, call_579495.base,
                         call_579495.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579495, url, valid)

proc call*(call_579496: Call_DeleteUserStarredOwnerRepo_579489; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## deleteUserStarredOwnerRepo
  ## Unstar a repository
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579497 = newJObject()
  var header_579498 = newJObject()
  add(path_579497, "repo", newJString(repo))
  add(path_579497, "owner", newJString(owner))
  add(header_579498, "Accept", newJString(Accept))
  result = call_579496.call(path_579497, nil, header_579498, nil, nil)

var deleteUserStarredOwnerRepo* = Call_DeleteUserStarredOwnerRepo_579489(
    name: "deleteUserStarredOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/starred/{owner}/{repo}",
    validator: validate_DeleteUserStarredOwnerRepo_579490, base: "/",
    url: url_DeleteUserStarredOwnerRepo_579491, schemes: {Scheme.Https})
type
  Call_GetUserSubscriptions_579499 = ref object of OpenApiRestCall_576564
proc url_GetUserSubscriptions_579501(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserSubscriptions_579500(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List repositories being watched by the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579502 = header.getOrDefault("Accept")
  valid_579502 = validateParameter(valid_579502, JString, required = false,
                                 default = nil)
  if valid_579502 != nil:
    section.add "Accept", valid_579502
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579503: Call_GetUserSubscriptions_579499; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List repositories being watched by the authenticated user.
  ## 
  let valid = call_579503.validator(path, query, header, formData, body)
  let scheme = call_579503.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579503.url(scheme.get, call_579503.host, call_579503.base,
                         call_579503.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579503, url, valid)

proc call*(call_579504: Call_GetUserSubscriptions_579499; Accept: string = ""): Recallable =
  ## getUserSubscriptions
  ## List repositories being watched by the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_579505 = newJObject()
  add(header_579505, "Accept", newJString(Accept))
  result = call_579504.call(nil, nil, header_579505, nil, nil)

var getUserSubscriptions* = Call_GetUserSubscriptions_579499(
    name: "getUserSubscriptions", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/user/subscriptions", validator: validate_GetUserSubscriptions_579500,
    base: "/", url: url_GetUserSubscriptions_579501, schemes: {Scheme.Https})
type
  Call_PutUserSubscriptionsOwnerRepo_579516 = ref object of OpenApiRestCall_576564
proc url_PutUserSubscriptionsOwnerRepo_579518(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/subscriptions/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutUserSubscriptionsOwnerRepo_579517(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Watch a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of the owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_579519 = path.getOrDefault("repo")
  valid_579519 = validateParameter(valid_579519, JString, required = true,
                                 default = nil)
  if valid_579519 != nil:
    section.add "repo", valid_579519
  var valid_579520 = path.getOrDefault("owner")
  valid_579520 = validateParameter(valid_579520, JString, required = true,
                                 default = nil)
  if valid_579520 != nil:
    section.add "owner", valid_579520
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579521 = header.getOrDefault("Accept")
  valid_579521 = validateParameter(valid_579521, JString, required = false,
                                 default = nil)
  if valid_579521 != nil:
    section.add "Accept", valid_579521
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579522: Call_PutUserSubscriptionsOwnerRepo_579516; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Watch a repository.
  ## 
  let valid = call_579522.validator(path, query, header, formData, body)
  let scheme = call_579522.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579522.url(scheme.get, call_579522.host, call_579522.base,
                         call_579522.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579522, url, valid)

proc call*(call_579523: Call_PutUserSubscriptionsOwnerRepo_579516; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## putUserSubscriptionsOwnerRepo
  ## Watch a repository.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of the owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579524 = newJObject()
  var header_579525 = newJObject()
  add(path_579524, "repo", newJString(repo))
  add(path_579524, "owner", newJString(owner))
  add(header_579525, "Accept", newJString(Accept))
  result = call_579523.call(path_579524, nil, header_579525, nil, nil)

var putUserSubscriptionsOwnerRepo* = Call_PutUserSubscriptionsOwnerRepo_579516(
    name: "putUserSubscriptionsOwnerRepo", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/user/subscriptions/{owner}/{repo}",
    validator: validate_PutUserSubscriptionsOwnerRepo_579517, base: "/",
    url: url_PutUserSubscriptionsOwnerRepo_579518, schemes: {Scheme.Https})
type
  Call_GetUserSubscriptionsOwnerRepo_579506 = ref object of OpenApiRestCall_576564
proc url_GetUserSubscriptionsOwnerRepo_579508(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/subscriptions/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserSubscriptionsOwnerRepo_579507(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Check if you are watching a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of the owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_579509 = path.getOrDefault("repo")
  valid_579509 = validateParameter(valid_579509, JString, required = true,
                                 default = nil)
  if valid_579509 != nil:
    section.add "repo", valid_579509
  var valid_579510 = path.getOrDefault("owner")
  valid_579510 = validateParameter(valid_579510, JString, required = true,
                                 default = nil)
  if valid_579510 != nil:
    section.add "owner", valid_579510
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579511 = header.getOrDefault("Accept")
  valid_579511 = validateParameter(valid_579511, JString, required = false,
                                 default = nil)
  if valid_579511 != nil:
    section.add "Accept", valid_579511
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579512: Call_GetUserSubscriptionsOwnerRepo_579506; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Check if you are watching a repository.
  ## 
  let valid = call_579512.validator(path, query, header, formData, body)
  let scheme = call_579512.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579512.url(scheme.get, call_579512.host, call_579512.base,
                         call_579512.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579512, url, valid)

proc call*(call_579513: Call_GetUserSubscriptionsOwnerRepo_579506; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getUserSubscriptionsOwnerRepo
  ## Check if you are watching a repository.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of the owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579514 = newJObject()
  var header_579515 = newJObject()
  add(path_579514, "repo", newJString(repo))
  add(path_579514, "owner", newJString(owner))
  add(header_579515, "Accept", newJString(Accept))
  result = call_579513.call(path_579514, nil, header_579515, nil, nil)

var getUserSubscriptionsOwnerRepo* = Call_GetUserSubscriptionsOwnerRepo_579506(
    name: "getUserSubscriptionsOwnerRepo", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/user/subscriptions/{owner}/{repo}",
    validator: validate_GetUserSubscriptionsOwnerRepo_579507, base: "/",
    url: url_GetUserSubscriptionsOwnerRepo_579508, schemes: {Scheme.Https})
type
  Call_DeleteUserSubscriptionsOwnerRepo_579526 = ref object of OpenApiRestCall_576564
proc url_DeleteUserSubscriptionsOwnerRepo_579528(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/subscriptions/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserSubscriptionsOwnerRepo_579527(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Stop watching a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of the owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_579529 = path.getOrDefault("repo")
  valid_579529 = validateParameter(valid_579529, JString, required = true,
                                 default = nil)
  if valid_579529 != nil:
    section.add "repo", valid_579529
  var valid_579530 = path.getOrDefault("owner")
  valid_579530 = validateParameter(valid_579530, JString, required = true,
                                 default = nil)
  if valid_579530 != nil:
    section.add "owner", valid_579530
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579531 = header.getOrDefault("Accept")
  valid_579531 = validateParameter(valid_579531, JString, required = false,
                                 default = nil)
  if valid_579531 != nil:
    section.add "Accept", valid_579531
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579532: Call_DeleteUserSubscriptionsOwnerRepo_579526;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Stop watching a repository
  ## 
  let valid = call_579532.validator(path, query, header, formData, body)
  let scheme = call_579532.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579532.url(scheme.get, call_579532.host, call_579532.base,
                         call_579532.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579532, url, valid)

proc call*(call_579533: Call_DeleteUserSubscriptionsOwnerRepo_579526; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## deleteUserSubscriptionsOwnerRepo
  ## Stop watching a repository
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of the owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579534 = newJObject()
  var header_579535 = newJObject()
  add(path_579534, "repo", newJString(repo))
  add(path_579534, "owner", newJString(owner))
  add(header_579535, "Accept", newJString(Accept))
  result = call_579533.call(path_579534, nil, header_579535, nil, nil)

var deleteUserSubscriptionsOwnerRepo* = Call_DeleteUserSubscriptionsOwnerRepo_579526(
    name: "deleteUserSubscriptionsOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/subscriptions/{owner}/{repo}",
    validator: validate_DeleteUserSubscriptionsOwnerRepo_579527, base: "/",
    url: url_DeleteUserSubscriptionsOwnerRepo_579528, schemes: {Scheme.Https})
type
  Call_GetUserTeams_579536 = ref object of OpenApiRestCall_576564
proc url_GetUserTeams_579538(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserTeams_579537(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## List all of the teams across all of the organizations to which the authenticated user belongs. This method requires user or repo scope when authenticating via OAuth.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579539 = header.getOrDefault("Accept")
  valid_579539 = validateParameter(valid_579539, JString, required = false,
                                 default = nil)
  if valid_579539 != nil:
    section.add "Accept", valid_579539
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579540: Call_GetUserTeams_579536; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List all of the teams across all of the organizations to which the authenticated user belongs. This method requires user or repo scope when authenticating via OAuth.
  ## 
  let valid = call_579540.validator(path, query, header, formData, body)
  let scheme = call_579540.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579540.url(scheme.get, call_579540.host, call_579540.base,
                         call_579540.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579540, url, valid)

proc call*(call_579541: Call_GetUserTeams_579536; Accept: string = ""): Recallable =
  ## getUserTeams
  ## List all of the teams across all of the organizations to which the authenticated user belongs. This method requires user or repo scope when authenticating via OAuth.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_579542 = newJObject()
  add(header_579542, "Accept", newJString(Accept))
  result = call_579541.call(nil, nil, header_579542, nil, nil)

var getUserTeams* = Call_GetUserTeams_579536(name: "getUserTeams",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/teams",
    validator: validate_GetUserTeams_579537, base: "/", url: url_GetUserTeams_579538,
    schemes: {Scheme.Https})
type
  Call_GetUsers_579543 = ref object of OpenApiRestCall_576564
proc url_GetUsers_579545(protocol: Scheme; host: string; base: string; route: string;
                        path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUsers_579544(path: JsonNode; query: JsonNode; header: JsonNode;
                             formData: JsonNode; body: JsonNode): JsonNode =
  ## Get all users.
  ## This provides a dump of every user, in the order that they signed up for GitHub.
  ## Note: Pagination is powered exclusively by the since parameter. Use the Link
  ## header to get the URL for the next page of users.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JInt
  ##        : The integer ID of the last user that you've seen.
  section = newJObject()
  var valid_579546 = query.getOrDefault("since")
  valid_579546 = validateParameter(valid_579546, JInt, required = false, default = nil)
  if valid_579546 != nil:
    section.add "since", valid_579546
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579547 = header.getOrDefault("Accept")
  valid_579547 = validateParameter(valid_579547, JString, required = false,
                                 default = nil)
  if valid_579547 != nil:
    section.add "Accept", valid_579547
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579548: Call_GetUsers_579543; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get all users.
  ## This provides a dump of every user, in the order that they signed up for GitHub.
  ## Note: Pagination is powered exclusively by the since parameter. Use the Link
  ## header to get the URL for the next page of users.
  ## 
  ## 
  let valid = call_579548.validator(path, query, header, formData, body)
  let scheme = call_579548.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579548.url(scheme.get, call_579548.host, call_579548.base,
                         call_579548.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579548, url, valid)

proc call*(call_579549: Call_GetUsers_579543; since: int = 0; Accept: string = ""): Recallable =
  ## getUsers
  ## Get all users.
  ## This provides a dump of every user, in the order that they signed up for GitHub.
  ## Note: Pagination is powered exclusively by the since parameter. Use the Link
  ## header to get the URL for the next page of users.
  ## 
  ##   since: int
  ##        : The integer ID of the last user that you've seen.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var query_579550 = newJObject()
  var header_579551 = newJObject()
  add(query_579550, "since", newJInt(since))
  add(header_579551, "Accept", newJString(Accept))
  result = call_579549.call(nil, query_579550, header_579551, nil, nil)

var getUsers* = Call_GetUsers_579543(name: "getUsers", meth: HttpMethod.HttpGet,
                                  host: "api.github.com", route: "/users",
                                  validator: validate_GetUsers_579544, base: "/",
                                  url: url_GetUsers_579545,
                                  schemes: {Scheme.Https})
type
  Call_GetUsersUsername_579552 = ref object of OpenApiRestCall_576564
proc url_GetUsersUsername_579554(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsername_579553(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Get a single user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_579555 = path.getOrDefault("username")
  valid_579555 = validateParameter(valid_579555, JString, required = true,
                                 default = nil)
  if valid_579555 != nil:
    section.add "username", valid_579555
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579556 = header.getOrDefault("Accept")
  valid_579556 = validateParameter(valid_579556, JString, required = false,
                                 default = nil)
  if valid_579556 != nil:
    section.add "Accept", valid_579556
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579557: Call_GetUsersUsername_579552; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a single user.
  ## 
  let valid = call_579557.validator(path, query, header, formData, body)
  let scheme = call_579557.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579557.url(scheme.get, call_579557.host, call_579557.base,
                         call_579557.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579557, url, valid)

proc call*(call_579558: Call_GetUsersUsername_579552; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsername
  ## Get a single user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579559 = newJObject()
  var header_579560 = newJObject()
  add(path_579559, "username", newJString(username))
  add(header_579560, "Accept", newJString(Accept))
  result = call_579558.call(path_579559, nil, header_579560, nil, nil)

var getUsersUsername* = Call_GetUsersUsername_579552(name: "getUsersUsername",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/users/{username}",
    validator: validate_GetUsersUsername_579553, base: "/",
    url: url_GetUsersUsername_579554, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameEvents_579561 = ref object of OpenApiRestCall_576564
proc url_GetUsersUsernameEvents_579563(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameEvents_579562(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_579564 = path.getOrDefault("username")
  valid_579564 = validateParameter(valid_579564, JString, required = true,
                                 default = nil)
  if valid_579564 != nil:
    section.add "username", valid_579564
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579565 = header.getOrDefault("Accept")
  valid_579565 = validateParameter(valid_579565, JString, required = false,
                                 default = nil)
  if valid_579565 != nil:
    section.add "Accept", valid_579565
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579566: Call_GetUsersUsernameEvents_579561; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
  ## 
  let valid = call_579566.validator(path, query, header, formData, body)
  let scheme = call_579566.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579566.url(scheme.get, call_579566.host, call_579566.base,
                         call_579566.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579566, url, valid)

proc call*(call_579567: Call_GetUsersUsernameEvents_579561; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameEvents
  ## If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579568 = newJObject()
  var header_579569 = newJObject()
  add(path_579568, "username", newJString(username))
  add(header_579569, "Accept", newJString(Accept))
  result = call_579567.call(path_579568, nil, header_579569, nil, nil)

var getUsersUsernameEvents* = Call_GetUsersUsernameEvents_579561(
    name: "getUsersUsernameEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/events",
    validator: validate_GetUsersUsernameEvents_579562, base: "/",
    url: url_GetUsersUsernameEvents_579563, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameEventsOrgsOrg_579570 = ref object of OpenApiRestCall_576564
proc url_GetUsersUsernameEventsOrgsOrg_579572(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/events/orgs/"),
               (kind: VariableSegment, value: "org")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameEventsOrgsOrg_579571(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This is the user's organization dashboard. You must be authenticated as the user to view this.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_579573 = path.getOrDefault("org")
  valid_579573 = validateParameter(valid_579573, JString, required = true,
                                 default = nil)
  if valid_579573 != nil:
    section.add "org", valid_579573
  var valid_579574 = path.getOrDefault("username")
  valid_579574 = validateParameter(valid_579574, JString, required = true,
                                 default = nil)
  if valid_579574 != nil:
    section.add "username", valid_579574
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579575 = header.getOrDefault("Accept")
  valid_579575 = validateParameter(valid_579575, JString, required = false,
                                 default = nil)
  if valid_579575 != nil:
    section.add "Accept", valid_579575
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579576: Call_GetUsersUsernameEventsOrgsOrg_579570; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This is the user's organization dashboard. You must be authenticated as the user to view this.
  ## 
  let valid = call_579576.validator(path, query, header, formData, body)
  let scheme = call_579576.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579576.url(scheme.get, call_579576.host, call_579576.base,
                         call_579576.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579576, url, valid)

proc call*(call_579577: Call_GetUsersUsernameEventsOrgsOrg_579570; org: string;
          username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameEventsOrgsOrg
  ## This is the user's organization dashboard. You must be authenticated as the user to view this.
  ##   org: string (required)
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579578 = newJObject()
  var header_579579 = newJObject()
  add(path_579578, "org", newJString(org))
  add(path_579578, "username", newJString(username))
  add(header_579579, "Accept", newJString(Accept))
  result = call_579577.call(path_579578, nil, header_579579, nil, nil)

var getUsersUsernameEventsOrgsOrg* = Call_GetUsersUsernameEventsOrgsOrg_579570(
    name: "getUsersUsernameEventsOrgsOrg", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/events/orgs/{org}",
    validator: validate_GetUsersUsernameEventsOrgsOrg_579571, base: "/",
    url: url_GetUsersUsernameEventsOrgsOrg_579572, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameFollowers_579580 = ref object of OpenApiRestCall_576564
proc url_GetUsersUsernameFollowers_579582(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/followers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameFollowers_579581(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List a user's followers
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_579583 = path.getOrDefault("username")
  valid_579583 = validateParameter(valid_579583, JString, required = true,
                                 default = nil)
  if valid_579583 != nil:
    section.add "username", valid_579583
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579584 = header.getOrDefault("Accept")
  valid_579584 = validateParameter(valid_579584, JString, required = false,
                                 default = nil)
  if valid_579584 != nil:
    section.add "Accept", valid_579584
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579585: Call_GetUsersUsernameFollowers_579580; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List a user's followers
  ## 
  let valid = call_579585.validator(path, query, header, formData, body)
  let scheme = call_579585.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579585.url(scheme.get, call_579585.host, call_579585.base,
                         call_579585.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579585, url, valid)

proc call*(call_579586: Call_GetUsersUsernameFollowers_579580; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameFollowers
  ## List a user's followers
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579587 = newJObject()
  var header_579588 = newJObject()
  add(path_579587, "username", newJString(username))
  add(header_579588, "Accept", newJString(Accept))
  result = call_579586.call(path_579587, nil, header_579588, nil, nil)

var getUsersUsernameFollowers* = Call_GetUsersUsernameFollowers_579580(
    name: "getUsersUsernameFollowers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/followers",
    validator: validate_GetUsersUsernameFollowers_579581, base: "/",
    url: url_GetUsersUsernameFollowers_579582, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameFollowingTargetUser_579589 = ref object of OpenApiRestCall_576564
proc url_GetUsersUsernameFollowingTargetUser_579591(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  assert "targetUser" in path, "`targetUser` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/following/"),
               (kind: VariableSegment, value: "targetUser")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameFollowingTargetUser_579590(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Check if one user follows another.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   targetUser: JString (required)
  ##             : Name of user.
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `targetUser` field"
  var valid_579592 = path.getOrDefault("targetUser")
  valid_579592 = validateParameter(valid_579592, JString, required = true,
                                 default = nil)
  if valid_579592 != nil:
    section.add "targetUser", valid_579592
  var valid_579593 = path.getOrDefault("username")
  valid_579593 = validateParameter(valid_579593, JString, required = true,
                                 default = nil)
  if valid_579593 != nil:
    section.add "username", valid_579593
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579594 = header.getOrDefault("Accept")
  valid_579594 = validateParameter(valid_579594, JString, required = false,
                                 default = nil)
  if valid_579594 != nil:
    section.add "Accept", valid_579594
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579595: Call_GetUsersUsernameFollowingTargetUser_579589;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Check if one user follows another.
  ## 
  let valid = call_579595.validator(path, query, header, formData, body)
  let scheme = call_579595.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579595.url(scheme.get, call_579595.host, call_579595.base,
                         call_579595.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579595, url, valid)

proc call*(call_579596: Call_GetUsersUsernameFollowingTargetUser_579589;
          targetUser: string; username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameFollowingTargetUser
  ## Check if one user follows another.
  ##   targetUser: string (required)
  ##             : Name of user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579597 = newJObject()
  var header_579598 = newJObject()
  add(path_579597, "targetUser", newJString(targetUser))
  add(path_579597, "username", newJString(username))
  add(header_579598, "Accept", newJString(Accept))
  result = call_579596.call(path_579597, nil, header_579598, nil, nil)

var getUsersUsernameFollowingTargetUser* = Call_GetUsersUsernameFollowingTargetUser_579589(
    name: "getUsersUsernameFollowingTargetUser", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/following/{targetUser}",
    validator: validate_GetUsersUsernameFollowingTargetUser_579590, base: "/",
    url: url_GetUsersUsernameFollowingTargetUser_579591, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameGists_579599 = ref object of OpenApiRestCall_576564
proc url_GetUsersUsernameGists_579601(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/gists")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameGists_579600(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List a users gists.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_579602 = path.getOrDefault("username")
  valid_579602 = validateParameter(valid_579602, JString, required = true,
                                 default = nil)
  if valid_579602 != nil:
    section.add "username", valid_579602
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_579603 = query.getOrDefault("since")
  valid_579603 = validateParameter(valid_579603, JString, required = false,
                                 default = nil)
  if valid_579603 != nil:
    section.add "since", valid_579603
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579604 = header.getOrDefault("Accept")
  valid_579604 = validateParameter(valid_579604, JString, required = false,
                                 default = nil)
  if valid_579604 != nil:
    section.add "Accept", valid_579604
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579605: Call_GetUsersUsernameGists_579599; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List a users gists.
  ## 
  let valid = call_579605.validator(path, query, header, formData, body)
  let scheme = call_579605.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579605.url(scheme.get, call_579605.host, call_579605.base,
                         call_579605.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579605, url, valid)

proc call*(call_579606: Call_GetUsersUsernameGists_579599; username: string;
          since: string = ""; Accept: string = ""): Recallable =
  ## getUsersUsernameGists
  ## List a users gists.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579607 = newJObject()
  var query_579608 = newJObject()
  var header_579609 = newJObject()
  add(query_579608, "since", newJString(since))
  add(path_579607, "username", newJString(username))
  add(header_579609, "Accept", newJString(Accept))
  result = call_579606.call(path_579607, query_579608, header_579609, nil, nil)

var getUsersUsernameGists* = Call_GetUsersUsernameGists_579599(
    name: "getUsersUsernameGists", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/users/{username}/gists", validator: validate_GetUsersUsernameGists_579600,
    base: "/", url: url_GetUsersUsernameGists_579601, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameKeys_579610 = ref object of OpenApiRestCall_576564
proc url_GetUsersUsernameKeys_579612(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/keys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameKeys_579611(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List public keys for a user.
  ## Lists the verified public keys for a user. This is accessible by anyone.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_579613 = path.getOrDefault("username")
  valid_579613 = validateParameter(valid_579613, JString, required = true,
                                 default = nil)
  if valid_579613 != nil:
    section.add "username", valid_579613
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579614 = header.getOrDefault("Accept")
  valid_579614 = validateParameter(valid_579614, JString, required = false,
                                 default = nil)
  if valid_579614 != nil:
    section.add "Accept", valid_579614
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579615: Call_GetUsersUsernameKeys_579610; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List public keys for a user.
  ## Lists the verified public keys for a user. This is accessible by anyone.
  ## 
  ## 
  let valid = call_579615.validator(path, query, header, formData, body)
  let scheme = call_579615.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579615.url(scheme.get, call_579615.host, call_579615.base,
                         call_579615.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579615, url, valid)

proc call*(call_579616: Call_GetUsersUsernameKeys_579610; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameKeys
  ## List public keys for a user.
  ## Lists the verified public keys for a user. This is accessible by anyone.
  ## 
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579617 = newJObject()
  var header_579618 = newJObject()
  add(path_579617, "username", newJString(username))
  add(header_579618, "Accept", newJString(Accept))
  result = call_579616.call(path_579617, nil, header_579618, nil, nil)

var getUsersUsernameKeys* = Call_GetUsersUsernameKeys_579610(
    name: "getUsersUsernameKeys", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/users/{username}/keys", validator: validate_GetUsersUsernameKeys_579611,
    base: "/", url: url_GetUsersUsernameKeys_579612, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameOrgs_579619 = ref object of OpenApiRestCall_576564
proc url_GetUsersUsernameOrgs_579621(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/orgs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameOrgs_579620(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List all public organizations for a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_579622 = path.getOrDefault("username")
  valid_579622 = validateParameter(valid_579622, JString, required = true,
                                 default = nil)
  if valid_579622 != nil:
    section.add "username", valid_579622
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579623 = header.getOrDefault("Accept")
  valid_579623 = validateParameter(valid_579623, JString, required = false,
                                 default = nil)
  if valid_579623 != nil:
    section.add "Accept", valid_579623
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579624: Call_GetUsersUsernameOrgs_579619; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List all public organizations for a user.
  ## 
  let valid = call_579624.validator(path, query, header, formData, body)
  let scheme = call_579624.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579624.url(scheme.get, call_579624.host, call_579624.base,
                         call_579624.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579624, url, valid)

proc call*(call_579625: Call_GetUsersUsernameOrgs_579619; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameOrgs
  ## List all public organizations for a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579626 = newJObject()
  var header_579627 = newJObject()
  add(path_579626, "username", newJString(username))
  add(header_579627, "Accept", newJString(Accept))
  result = call_579625.call(path_579626, nil, header_579627, nil, nil)

var getUsersUsernameOrgs* = Call_GetUsersUsernameOrgs_579619(
    name: "getUsersUsernameOrgs", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/users/{username}/orgs", validator: validate_GetUsersUsernameOrgs_579620,
    base: "/", url: url_GetUsersUsernameOrgs_579621, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameReceivedEvents_579628 = ref object of OpenApiRestCall_576564
proc url_GetUsersUsernameReceivedEvents_579630(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/received_events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameReceivedEvents_579629(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## These are events that you'll only see public events.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_579631 = path.getOrDefault("username")
  valid_579631 = validateParameter(valid_579631, JString, required = true,
                                 default = nil)
  if valid_579631 != nil:
    section.add "username", valid_579631
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579632 = header.getOrDefault("Accept")
  valid_579632 = validateParameter(valid_579632, JString, required = false,
                                 default = nil)
  if valid_579632 != nil:
    section.add "Accept", valid_579632
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579633: Call_GetUsersUsernameReceivedEvents_579628; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## These are events that you'll only see public events.
  ## 
  let valid = call_579633.validator(path, query, header, formData, body)
  let scheme = call_579633.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579633.url(scheme.get, call_579633.host, call_579633.base,
                         call_579633.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579633, url, valid)

proc call*(call_579634: Call_GetUsersUsernameReceivedEvents_579628;
          username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameReceivedEvents
  ## These are events that you'll only see public events.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579635 = newJObject()
  var header_579636 = newJObject()
  add(path_579635, "username", newJString(username))
  add(header_579636, "Accept", newJString(Accept))
  result = call_579634.call(path_579635, nil, header_579636, nil, nil)

var getUsersUsernameReceivedEvents* = Call_GetUsersUsernameReceivedEvents_579628(
    name: "getUsersUsernameReceivedEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/received_events",
    validator: validate_GetUsersUsernameReceivedEvents_579629, base: "/",
    url: url_GetUsersUsernameReceivedEvents_579630, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameReceivedEventsPublic_579637 = ref object of OpenApiRestCall_576564
proc url_GetUsersUsernameReceivedEventsPublic_579639(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/received_events/public")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameReceivedEventsPublic_579638(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List public events that a user has received
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_579640 = path.getOrDefault("username")
  valid_579640 = validateParameter(valid_579640, JString, required = true,
                                 default = nil)
  if valid_579640 != nil:
    section.add "username", valid_579640
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579641 = header.getOrDefault("Accept")
  valid_579641 = validateParameter(valid_579641, JString, required = false,
                                 default = nil)
  if valid_579641 != nil:
    section.add "Accept", valid_579641
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579642: Call_GetUsersUsernameReceivedEventsPublic_579637;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List public events that a user has received
  ## 
  let valid = call_579642.validator(path, query, header, formData, body)
  let scheme = call_579642.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579642.url(scheme.get, call_579642.host, call_579642.base,
                         call_579642.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579642, url, valid)

proc call*(call_579643: Call_GetUsersUsernameReceivedEventsPublic_579637;
          username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameReceivedEventsPublic
  ## List public events that a user has received
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579644 = newJObject()
  var header_579645 = newJObject()
  add(path_579644, "username", newJString(username))
  add(header_579645, "Accept", newJString(Accept))
  result = call_579643.call(path_579644, nil, header_579645, nil, nil)

var getUsersUsernameReceivedEventsPublic* = Call_GetUsersUsernameReceivedEventsPublic_579637(
    name: "getUsersUsernameReceivedEventsPublic", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/received_events/public",
    validator: validate_GetUsersUsernameReceivedEventsPublic_579638, base: "/",
    url: url_GetUsersUsernameReceivedEventsPublic_579639, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameRepos_579646 = ref object of OpenApiRestCall_576564
proc url_GetUsersUsernameRepos_579648(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameRepos_579647(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List public repositories for the specified user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_579649 = path.getOrDefault("username")
  valid_579649 = validateParameter(valid_579649, JString, required = true,
                                 default = nil)
  if valid_579649 != nil:
    section.add "username", valid_579649
  result.add "path", section
  ## parameters in `query` object:
  ##   type: JString
  section = newJObject()
  var valid_579650 = query.getOrDefault("type")
  valid_579650 = validateParameter(valid_579650, JString, required = false,
                                 default = newJString("all"))
  if valid_579650 != nil:
    section.add "type", valid_579650
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579651 = header.getOrDefault("Accept")
  valid_579651 = validateParameter(valid_579651, JString, required = false,
                                 default = nil)
  if valid_579651 != nil:
    section.add "Accept", valid_579651
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579652: Call_GetUsersUsernameRepos_579646; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List public repositories for the specified user.
  ## 
  let valid = call_579652.validator(path, query, header, formData, body)
  let scheme = call_579652.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579652.url(scheme.get, call_579652.host, call_579652.base,
                         call_579652.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579652, url, valid)

proc call*(call_579653: Call_GetUsersUsernameRepos_579646; username: string;
          `type`: string = "all"; Accept: string = ""): Recallable =
  ## getUsersUsernameRepos
  ## List public repositories for the specified user.
  ##   type: string
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579654 = newJObject()
  var query_579655 = newJObject()
  var header_579656 = newJObject()
  add(query_579655, "type", newJString(`type`))
  add(path_579654, "username", newJString(username))
  add(header_579656, "Accept", newJString(Accept))
  result = call_579653.call(path_579654, query_579655, header_579656, nil, nil)

var getUsersUsernameRepos* = Call_GetUsersUsernameRepos_579646(
    name: "getUsersUsernameRepos", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/users/{username}/repos", validator: validate_GetUsersUsernameRepos_579647,
    base: "/", url: url_GetUsersUsernameRepos_579648, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameStarred_579657 = ref object of OpenApiRestCall_576564
proc url_GetUsersUsernameStarred_579659(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/starred")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameStarred_579658(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List repositories being starred by a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_579660 = path.getOrDefault("username")
  valid_579660 = validateParameter(valid_579660, JString, required = true,
                                 default = nil)
  if valid_579660 != nil:
    section.add "username", valid_579660
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579661 = header.getOrDefault("Accept")
  valid_579661 = validateParameter(valid_579661, JString, required = false,
                                 default = nil)
  if valid_579661 != nil:
    section.add "Accept", valid_579661
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579662: Call_GetUsersUsernameStarred_579657; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List repositories being starred by a user.
  ## 
  let valid = call_579662.validator(path, query, header, formData, body)
  let scheme = call_579662.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579662.url(scheme.get, call_579662.host, call_579662.base,
                         call_579662.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579662, url, valid)

proc call*(call_579663: Call_GetUsersUsernameStarred_579657; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameStarred
  ## List repositories being starred by a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579664 = newJObject()
  var header_579665 = newJObject()
  add(path_579664, "username", newJString(username))
  add(header_579665, "Accept", newJString(Accept))
  result = call_579663.call(path_579664, nil, header_579665, nil, nil)

var getUsersUsernameStarred* = Call_GetUsersUsernameStarred_579657(
    name: "getUsersUsernameStarred", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/starred",
    validator: validate_GetUsersUsernameStarred_579658, base: "/",
    url: url_GetUsersUsernameStarred_579659, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameSubscriptions_579666 = ref object of OpenApiRestCall_576564
proc url_GetUsersUsernameSubscriptions_579668(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/subscriptions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameSubscriptions_579667(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List repositories being watched by a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_579669 = path.getOrDefault("username")
  valid_579669 = validateParameter(valid_579669, JString, required = true,
                                 default = nil)
  if valid_579669 != nil:
    section.add "username", valid_579669
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_579670 = header.getOrDefault("Accept")
  valid_579670 = validateParameter(valid_579670, JString, required = false,
                                 default = nil)
  if valid_579670 != nil:
    section.add "Accept", valid_579670
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_579671: Call_GetUsersUsernameSubscriptions_579666; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List repositories being watched by a user.
  ## 
  let valid = call_579671.validator(path, query, header, formData, body)
  let scheme = call_579671.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_579671.url(scheme.get, call_579671.host, call_579671.base,
                         call_579671.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_579671, url, valid)

proc call*(call_579672: Call_GetUsersUsernameSubscriptions_579666;
          username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameSubscriptions
  ## List repositories being watched by a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_579673 = newJObject()
  var header_579674 = newJObject()
  add(path_579673, "username", newJString(username))
  add(header_579674, "Accept", newJString(Accept))
  result = call_579672.call(path_579673, nil, header_579674, nil, nil)

var getUsersUsernameSubscriptions* = Call_GetUsersUsernameSubscriptions_579666(
    name: "getUsersUsernameSubscriptions", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/subscriptions",
    validator: validate_GetUsersUsernameSubscriptions_579667, base: "/",
    url: url_GetUsersUsernameSubscriptions_579668, schemes: {Scheme.Https})
export
  rest

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.} =
  var headers = massageHeaders(input.getOrDefault("header")).newHttpHeaders
  if not headers.hasKey "Authorization":
    headers.add "Authorization", "token " & os.getEnv "GITHUB_TOKEN"
  if headers.hasKey "Accept":
    headers.del "Accept"
  headers.add "Accept", "application/vnd.github.v3+json"
  result = newRecallable(call, url, headers, input.getOrDefault("body").getStr)
