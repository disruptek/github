
import
  json, options, hashes, uri, strutils, rest, os, uri, httpcore

## auto-generated via openapi macro
## title: GitHub
## version: v3
## termsOfService: https://help.github.com/articles/github-terms-of-service/#b-api-terms
## license: (not provided)
## 
## Powerful collaboration, code review, and code management for open source and private projects.
## 
## 
## https://developer.github.com/v3/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (query: JsonNode = nil; body: JsonNode = nil;
                          header: JsonNode = nil; path: JsonNode = nil;
                          formData: JsonNode = nil): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_28375350 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_28375350](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_28375350): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low .. Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js == nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result == nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind == kind, $kind & " expected; received " & $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string {.used.} =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] {.used.} =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    case js.kind
    of JInt, JFloat, JNull, JBool:
      head = $js
    of JString:
      head = js.getStr
    else:
      return
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.}
type
  Call_GetEmojis_28375537 = ref object of OpenApiRestCall_28375350
proc url_GetEmojis_28375539(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEmojis_28375538(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists all the emojis available to use on GitHub.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28375672 = header.getOrDefault("Accept")
  valid_28375672 = validateParameter(valid_28375672, JString, required = false,
                                   default = nil)
  if valid_28375672 != nil:
    section.add "Accept", valid_28375672
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28375696: Call_GetEmojis_28375537; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists all the emojis available to use on GitHub.
  ## 
  let valid = call_28375696.validator(path, query, header, formData, body)
  let scheme = call_28375696.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28375696.url(scheme.get, call_28375696.host, call_28375696.base,
                           call_28375696.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28375696, url, valid)

proc call*(call_28375759: Call_GetEmojis_28375537; Accept: string = ""): Recallable =
  ## getEmojis
  ## Lists all the emojis available to use on GitHub.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_28375761 = newJObject()
  add(header_28375761, "Accept", newJString(Accept))
  result = call_28375759.call(nil, nil, header_28375761, nil, nil)

var getEmojis* = Call_GetEmojis_28375537(name: "getEmojis", meth: HttpMethod.HttpGet,
                                      host: "api.github.com", route: "/emojis",
                                      validator: validate_GetEmojis_28375538,
                                      base: "/", url: url_GetEmojis_28375539,
                                      schemes: {Scheme.Https})
type
  Call_GetEvents_28375803 = ref object of OpenApiRestCall_28375350
proc url_GetEvents_28375805(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEvents_28375804(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## List public events.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28375806 = header.getOrDefault("Accept")
  valid_28375806 = validateParameter(valid_28375806, JString, required = false,
                                   default = nil)
  if valid_28375806 != nil:
    section.add "Accept", valid_28375806
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28375807: Call_GetEvents_28375803; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List public events.
  ## 
  let valid = call_28375807.validator(path, query, header, formData, body)
  let scheme = call_28375807.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28375807.url(scheme.get, call_28375807.host, call_28375807.base,
                           call_28375807.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28375807, url, valid)

proc call*(call_28375808: Call_GetEvents_28375803; Accept: string = ""): Recallable =
  ## getEvents
  ## List public events.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_28375809 = newJObject()
  add(header_28375809, "Accept", newJString(Accept))
  result = call_28375808.call(nil, nil, header_28375809, nil, nil)

var getEvents* = Call_GetEvents_28375803(name: "getEvents", meth: HttpMethod.HttpGet,
                                      host: "api.github.com", route: "/events",
                                      validator: validate_GetEvents_28375804,
                                      base: "/", url: url_GetEvents_28375805,
                                      schemes: {Scheme.Https})
type
  Call_GetFeeds_28375810 = ref object of OpenApiRestCall_28375350
proc url_GetFeeds_28375812(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetFeeds_28375811(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## List Feeds.
  ## GitHub provides several timeline resources in Atom format. The Feeds API
  ##  lists all the feeds available to the authenticating user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28375813 = header.getOrDefault("Accept")
  valid_28375813 = validateParameter(valid_28375813, JString, required = false,
                                   default = nil)
  if valid_28375813 != nil:
    section.add "Accept", valid_28375813
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28375814: Call_GetFeeds_28375810; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List Feeds.
  ## GitHub provides several timeline resources in Atom format. The Feeds API
  ##  lists all the feeds available to the authenticating user.
  ## 
  ## 
  let valid = call_28375814.validator(path, query, header, formData, body)
  let scheme = call_28375814.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28375814.url(scheme.get, call_28375814.host, call_28375814.base,
                           call_28375814.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28375814, url, valid)

proc call*(call_28375815: Call_GetFeeds_28375810; Accept: string = ""): Recallable =
  ## getFeeds
  ## List Feeds.
  ## GitHub provides several timeline resources in Atom format. The Feeds API
  ##  lists all the feeds available to the authenticating user.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_28375816 = newJObject()
  add(header_28375816, "Accept", newJString(Accept))
  result = call_28375815.call(nil, nil, header_28375816, nil, nil)

var getFeeds* = Call_GetFeeds_28375810(name: "getFeeds", meth: HttpMethod.HttpGet,
                                    host: "api.github.com", route: "/feeds",
                                    validator: validate_GetFeeds_28375811,
                                    base: "/", url: url_GetFeeds_28375812,
                                    schemes: {Scheme.Https})
type
  Call_PostGists_28375826 = ref object of OpenApiRestCall_28375350
proc url_PostGists_28375828(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostGists_28375827(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28375838 = header.getOrDefault("Accept")
  valid_28375838 = validateParameter(valid_28375838, JString, required = false,
                                   default = nil)
  if valid_28375838 != nil:
    section.add "Accept", valid_28375838
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28375840: Call_PostGists_28375826; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a gist.
  ## 
  let valid = call_28375840.validator(path, query, header, formData, body)
  let scheme = call_28375840.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28375840.url(scheme.get, call_28375840.host, call_28375840.base,
                           call_28375840.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28375840, url, valid)

proc call*(call_28375841: Call_PostGists_28375826; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postGists
  ## Create a gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_28375842 = newJObject()
  var body_28375843 = newJObject()
  add(header_28375842, "Accept", newJString(Accept))
  if body != nil:
    body_28375843 = body
  result = call_28375841.call(nil, nil, header_28375842, nil, body_28375843)

var postGists* = Call_PostGists_28375826(name: "postGists",
                                      meth: HttpMethod.HttpPost,
                                      host: "api.github.com", route: "/gists",
                                      validator: validate_PostGists_28375827,
                                      base: "/", url: url_PostGists_28375828,
                                      schemes: {Scheme.Https})
type
  Call_GetGists_28375817 = ref object of OpenApiRestCall_28375350
proc url_GetGists_28375819(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGists_28375818(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## List the authenticated user's gists or if called anonymously, this will
  ## return all public gists.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_28375820 = query.getOrDefault("since")
  valid_28375820 = validateParameter(valid_28375820, JString, required = false,
                                   default = nil)
  if valid_28375820 != nil:
    section.add "since", valid_28375820
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28375821 = header.getOrDefault("Accept")
  valid_28375821 = validateParameter(valid_28375821, JString, required = false,
                                   default = nil)
  if valid_28375821 != nil:
    section.add "Accept", valid_28375821
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28375822: Call_GetGists_28375817; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the authenticated user's gists or if called anonymously, this will
  ## return all public gists.
  ## 
  ## 
  let valid = call_28375822.validator(path, query, header, formData, body)
  let scheme = call_28375822.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28375822.url(scheme.get, call_28375822.host, call_28375822.base,
                           call_28375822.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28375822, url, valid)

proc call*(call_28375823: Call_GetGists_28375817; Accept: string = "";
          since: string = ""): Recallable =
  ## getGists
  ## List the authenticated user's gists or if called anonymously, this will
  ## return all public gists.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: string
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  var query_28375824 = newJObject()
  var header_28375825 = newJObject()
  add(header_28375825, "Accept", newJString(Accept))
  add(query_28375824, "since", newJString(since))
  result = call_28375823.call(nil, query_28375824, header_28375825, nil, nil)

var getGists* = Call_GetGists_28375817(name: "getGists", meth: HttpMethod.HttpGet,
                                    host: "api.github.com", route: "/gists",
                                    validator: validate_GetGists_28375818,
                                    base: "/", url: url_GetGists_28375819,
                                    schemes: {Scheme.Https})
type
  Call_GetGistsPublic_28375844 = ref object of OpenApiRestCall_28375350
proc url_GetGistsPublic_28375846(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGistsPublic_28375845(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## List all public gists.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_28375847 = query.getOrDefault("since")
  valid_28375847 = validateParameter(valid_28375847, JString, required = false,
                                   default = nil)
  if valid_28375847 != nil:
    section.add "since", valid_28375847
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28375848 = header.getOrDefault("Accept")
  valid_28375848 = validateParameter(valid_28375848, JString, required = false,
                                   default = nil)
  if valid_28375848 != nil:
    section.add "Accept", valid_28375848
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28375849: Call_GetGistsPublic_28375844; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List all public gists.
  ## 
  let valid = call_28375849.validator(path, query, header, formData, body)
  let scheme = call_28375849.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28375849.url(scheme.get, call_28375849.host, call_28375849.base,
                           call_28375849.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28375849, url, valid)

proc call*(call_28375850: Call_GetGistsPublic_28375844; Accept: string = "";
          since: string = ""): Recallable =
  ## getGistsPublic
  ## List all public gists.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: string
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  var query_28375851 = newJObject()
  var header_28375852 = newJObject()
  add(header_28375852, "Accept", newJString(Accept))
  add(query_28375851, "since", newJString(since))
  result = call_28375850.call(nil, query_28375851, header_28375852, nil, nil)

var getGistsPublic* = Call_GetGistsPublic_28375844(name: "getGistsPublic",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/gists/public",
    validator: validate_GetGistsPublic_28375845, base: "/", url: url_GetGistsPublic_28375846,
    schemes: {Scheme.Https})
type
  Call_GetGistsStarred_28375853 = ref object of OpenApiRestCall_28375350
proc url_GetGistsStarred_28375855(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGistsStarred_28375854(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## List the authenticated user's starred gists.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_28375856 = query.getOrDefault("since")
  valid_28375856 = validateParameter(valid_28375856, JString, required = false,
                                   default = nil)
  if valid_28375856 != nil:
    section.add "since", valid_28375856
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28375857 = header.getOrDefault("Accept")
  valid_28375857 = validateParameter(valid_28375857, JString, required = false,
                                   default = nil)
  if valid_28375857 != nil:
    section.add "Accept", valid_28375857
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28375858: Call_GetGistsStarred_28375853; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the authenticated user's starred gists.
  ## 
  let valid = call_28375858.validator(path, query, header, formData, body)
  let scheme = call_28375858.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28375858.url(scheme.get, call_28375858.host, call_28375858.base,
                           call_28375858.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28375858, url, valid)

proc call*(call_28375859: Call_GetGistsStarred_28375853; Accept: string = "";
          since: string = ""): Recallable =
  ## getGistsStarred
  ## List the authenticated user's starred gists.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: string
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  var query_28375860 = newJObject()
  var header_28375861 = newJObject()
  add(header_28375861, "Accept", newJString(Accept))
  add(query_28375860, "since", newJString(since))
  result = call_28375859.call(nil, query_28375860, header_28375861, nil, nil)

var getGistsStarred* = Call_GetGistsStarred_28375853(name: "getGistsStarred",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/gists/starred",
    validator: validate_GetGistsStarred_28375854, base: "/",
    url: url_GetGistsStarred_28375855, schemes: {Scheme.Https})
type
  Call_GetGistsId_28375862 = ref object of OpenApiRestCall_28375350
proc url_GetGistsId_28375864(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsId_28375863(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_28375878 = path.getOrDefault("id")
  valid_28375878 = validateParameter(valid_28375878, JInt, required = true,
                                   default = nil)
  if valid_28375878 != nil:
    section.add "id", valid_28375878
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28375879 = header.getOrDefault("Accept")
  valid_28375879 = validateParameter(valid_28375879, JString, required = false,
                                   default = nil)
  if valid_28375879 != nil:
    section.add "Accept", valid_28375879
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28375880: Call_GetGistsId_28375862; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a single gist.
  ## 
  let valid = call_28375880.validator(path, query, header, formData, body)
  let scheme = call_28375880.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28375880.url(scheme.get, call_28375880.host, call_28375880.base,
                           call_28375880.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28375880, url, valid)

proc call*(call_28375881: Call_GetGistsId_28375862; id: int; Accept: string = ""): Recallable =
  ## getGistsId
  ## Get a single gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_28375882 = newJObject()
  var header_28375883 = newJObject()
  add(path_28375882, "id", newJInt(id))
  add(header_28375883, "Accept", newJString(Accept))
  result = call_28375881.call(path_28375882, nil, header_28375883, nil, nil)

var getGistsId* = Call_GetGistsId_28375862(name: "getGistsId",
                                        meth: HttpMethod.HttpGet,
                                        host: "api.github.com",
                                        route: "/gists/{id}",
                                        validator: validate_GetGistsId_28375863,
                                        base: "/", url: url_GetGistsId_28375864,
                                        schemes: {Scheme.Https})
type
  Call_PatchGistsId_28375893 = ref object of OpenApiRestCall_28375350
proc url_PatchGistsId_28375895(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchGistsId_28375894(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Edit a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_28375896 = path.getOrDefault("id")
  valid_28375896 = validateParameter(valid_28375896, JInt, required = true,
                                   default = nil)
  if valid_28375896 != nil:
    section.add "id", valid_28375896
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28375897 = header.getOrDefault("Accept")
  valid_28375897 = validateParameter(valid_28375897, JString, required = false,
                                   default = nil)
  if valid_28375897 != nil:
    section.add "Accept", valid_28375897
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28375899: Call_PatchGistsId_28375893; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Edit a gist.
  ## 
  let valid = call_28375899.validator(path, query, header, formData, body)
  let scheme = call_28375899.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28375899.url(scheme.get, call_28375899.host, call_28375899.base,
                           call_28375899.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28375899, url, valid)

proc call*(call_28375900: Call_PatchGistsId_28375893; id: int; body: JsonNode;
          Accept: string = ""): Recallable =
  ## patchGistsId
  ## Edit a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var path_28375901 = newJObject()
  var header_28375902 = newJObject()
  var body_28375903 = newJObject()
  add(path_28375901, "id", newJInt(id))
  add(header_28375902, "Accept", newJString(Accept))
  if body != nil:
    body_28375903 = body
  result = call_28375900.call(path_28375901, nil, header_28375902, nil, body_28375903)

var patchGistsId* = Call_PatchGistsId_28375893(name: "patchGistsId",
    meth: HttpMethod.HttpPatch, host: "api.github.com", route: "/gists/{id}",
    validator: validate_PatchGistsId_28375894, base: "/", url: url_PatchGistsId_28375895,
    schemes: {Scheme.Https})
type
  Call_DeleteGistsId_28375884 = ref object of OpenApiRestCall_28375350
proc url_DeleteGistsId_28375886(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteGistsId_28375885(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Delete a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_28375887 = path.getOrDefault("id")
  valid_28375887 = validateParameter(valid_28375887, JInt, required = true,
                                   default = nil)
  if valid_28375887 != nil:
    section.add "id", valid_28375887
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28375888 = header.getOrDefault("Accept")
  valid_28375888 = validateParameter(valid_28375888, JString, required = false,
                                   default = nil)
  if valid_28375888 != nil:
    section.add "Accept", valid_28375888
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28375889: Call_DeleteGistsId_28375884; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete a gist.
  ## 
  let valid = call_28375889.validator(path, query, header, formData, body)
  let scheme = call_28375889.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28375889.url(scheme.get, call_28375889.host, call_28375889.base,
                           call_28375889.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28375889, url, valid)

proc call*(call_28375890: Call_DeleteGistsId_28375884; id: int; Accept: string = ""): Recallable =
  ## deleteGistsId
  ## Delete a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_28375891 = newJObject()
  var header_28375892 = newJObject()
  add(path_28375891, "id", newJInt(id))
  add(header_28375892, "Accept", newJString(Accept))
  result = call_28375890.call(path_28375891, nil, header_28375892, nil, nil)

var deleteGistsId* = Call_DeleteGistsId_28375884(name: "deleteGistsId",
    meth: HttpMethod.HttpDelete, host: "api.github.com", route: "/gists/{id}",
    validator: validate_DeleteGistsId_28375885, base: "/", url: url_DeleteGistsId_28375886,
    schemes: {Scheme.Https})
type
  Call_PostGistsIdComments_28375913 = ref object of OpenApiRestCall_28375350
proc url_PostGistsIdComments_28375915(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostGistsIdComments_28375914(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a commen
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_28375916 = path.getOrDefault("id")
  valid_28375916 = validateParameter(valid_28375916, JInt, required = true,
                                   default = nil)
  if valid_28375916 != nil:
    section.add "id", valid_28375916
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28375917 = header.getOrDefault("Accept")
  valid_28375917 = validateParameter(valid_28375917, JString, required = false,
                                   default = nil)
  if valid_28375917 != nil:
    section.add "Accept", valid_28375917
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28375919: Call_PostGistsIdComments_28375913; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a commen
  ## 
  let valid = call_28375919.validator(path, query, header, formData, body)
  let scheme = call_28375919.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28375919.url(scheme.get, call_28375919.host, call_28375919.base,
                           call_28375919.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28375919, url, valid)

proc call*(call_28375920: Call_PostGistsIdComments_28375913; id: int; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postGistsIdComments
  ## Create a commen
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var path_28375921 = newJObject()
  var header_28375922 = newJObject()
  var body_28375923 = newJObject()
  add(path_28375921, "id", newJInt(id))
  add(header_28375922, "Accept", newJString(Accept))
  if body != nil:
    body_28375923 = body
  result = call_28375920.call(path_28375921, nil, header_28375922, nil, body_28375923)

var postGistsIdComments* = Call_PostGistsIdComments_28375913(
    name: "postGistsIdComments", meth: HttpMethod.HttpPost, host: "api.github.com",
    route: "/gists/{id}/comments", validator: validate_PostGistsIdComments_28375914,
    base: "/", url: url_PostGistsIdComments_28375915, schemes: {Scheme.Https})
type
  Call_GetGistsIdComments_28375904 = ref object of OpenApiRestCall_28375350
proc url_GetGistsIdComments_28375906(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsIdComments_28375905(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List comments on a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_28375907 = path.getOrDefault("id")
  valid_28375907 = validateParameter(valid_28375907, JInt, required = true,
                                   default = nil)
  if valid_28375907 != nil:
    section.add "id", valid_28375907
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28375908 = header.getOrDefault("Accept")
  valid_28375908 = validateParameter(valid_28375908, JString, required = false,
                                   default = nil)
  if valid_28375908 != nil:
    section.add "Accept", valid_28375908
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28375909: Call_GetGistsIdComments_28375904; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List comments on a gist.
  ## 
  let valid = call_28375909.validator(path, query, header, formData, body)
  let scheme = call_28375909.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28375909.url(scheme.get, call_28375909.host, call_28375909.base,
                           call_28375909.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28375909, url, valid)

proc call*(call_28375910: Call_GetGistsIdComments_28375904; id: int;
          Accept: string = ""): Recallable =
  ## getGistsIdComments
  ## List comments on a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_28375911 = newJObject()
  var header_28375912 = newJObject()
  add(path_28375911, "id", newJInt(id))
  add(header_28375912, "Accept", newJString(Accept))
  result = call_28375910.call(path_28375911, nil, header_28375912, nil, nil)

var getGistsIdComments* = Call_GetGistsIdComments_28375904(
    name: "getGistsIdComments", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/gists/{id}/comments", validator: validate_GetGistsIdComments_28375905,
    base: "/", url: url_GetGistsIdComments_28375906, schemes: {Scheme.Https})
type
  Call_GetGistsIdCommentsCommentId_28375924 = ref object of OpenApiRestCall_28375350
proc url_GetGistsIdCommentsCommentId_28375926(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsIdCommentsCommentId_28375925(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_28375927 = path.getOrDefault("id")
  valid_28375927 = validateParameter(valid_28375927, JInt, required = true,
                                   default = nil)
  if valid_28375927 != nil:
    section.add "id", valid_28375927
  var valid_28375928 = path.getOrDefault("commentId")
  valid_28375928 = validateParameter(valid_28375928, JInt, required = true,
                                   default = nil)
  if valid_28375928 != nil:
    section.add "commentId", valid_28375928
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28375929 = header.getOrDefault("Accept")
  valid_28375929 = validateParameter(valid_28375929, JString, required = false,
                                   default = nil)
  if valid_28375929 != nil:
    section.add "Accept", valid_28375929
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28375930: Call_GetGistsIdCommentsCommentId_28375924;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single comment.
  ## 
  let valid = call_28375930.validator(path, query, header, formData, body)
  let scheme = call_28375930.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28375930.url(scheme.get, call_28375930.host, call_28375930.base,
                           call_28375930.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28375930, url, valid)

proc call*(call_28375931: Call_GetGistsIdCommentsCommentId_28375924; id: int;
          commentId: int; Accept: string = ""): Recallable =
  ## getGistsIdCommentsCommentId
  ## Get a single comment.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_28375932 = newJObject()
  var header_28375933 = newJObject()
  add(path_28375932, "id", newJInt(id))
  add(header_28375933, "Accept", newJString(Accept))
  add(path_28375932, "commentId", newJInt(commentId))
  result = call_28375931.call(path_28375932, nil, header_28375933, nil, nil)

var getGistsIdCommentsCommentId* = Call_GetGistsIdCommentsCommentId_28375924(
    name: "getGistsIdCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/gists/{id}/comments/{commentId}",
    validator: validate_GetGistsIdCommentsCommentId_28375925, base: "/",
    url: url_GetGistsIdCommentsCommentId_28375926, schemes: {Scheme.Https})
type
  Call_PatchGistsIdCommentsCommentId_28375944 = ref object of OpenApiRestCall_28375350
proc url_PatchGistsIdCommentsCommentId_28375946(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchGistsIdCommentsCommentId_28375945(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Edit a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_28375947 = path.getOrDefault("id")
  valid_28375947 = validateParameter(valid_28375947, JInt, required = true,
                                   default = nil)
  if valid_28375947 != nil:
    section.add "id", valid_28375947
  var valid_28375948 = path.getOrDefault("commentId")
  valid_28375948 = validateParameter(valid_28375948, JInt, required = true,
                                   default = nil)
  if valid_28375948 != nil:
    section.add "commentId", valid_28375948
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28375949 = header.getOrDefault("Accept")
  valid_28375949 = validateParameter(valid_28375949, JString, required = false,
                                   default = nil)
  if valid_28375949 != nil:
    section.add "Accept", valid_28375949
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28375951: Call_PatchGistsIdCommentsCommentId_28375944;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Edit a comment.
  ## 
  let valid = call_28375951.validator(path, query, header, formData, body)
  let scheme = call_28375951.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28375951.url(scheme.get, call_28375951.host, call_28375951.base,
                           call_28375951.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28375951, url, valid)

proc call*(call_28375952: Call_PatchGistsIdCommentsCommentId_28375944; id: int;
          body: JsonNode; commentId: int; Accept: string = ""): Recallable =
  ## patchGistsIdCommentsCommentId
  ## Edit a comment.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_28375953 = newJObject()
  var header_28375954 = newJObject()
  var body_28375955 = newJObject()
  add(path_28375953, "id", newJInt(id))
  add(header_28375954, "Accept", newJString(Accept))
  if body != nil:
    body_28375955 = body
  add(path_28375953, "commentId", newJInt(commentId))
  result = call_28375952.call(path_28375953, nil, header_28375954, nil, body_28375955)

var patchGistsIdCommentsCommentId* = Call_PatchGistsIdCommentsCommentId_28375944(
    name: "patchGistsIdCommentsCommentId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/gists/{id}/comments/{commentId}",
    validator: validate_PatchGistsIdCommentsCommentId_28375945, base: "/",
    url: url_PatchGistsIdCommentsCommentId_28375946, schemes: {Scheme.Https})
type
  Call_DeleteGistsIdCommentsCommentId_28375934 = ref object of OpenApiRestCall_28375350
proc url_DeleteGistsIdCommentsCommentId_28375936(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteGistsIdCommentsCommentId_28375935(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_28375937 = path.getOrDefault("id")
  valid_28375937 = validateParameter(valid_28375937, JInt, required = true,
                                   default = nil)
  if valid_28375937 != nil:
    section.add "id", valid_28375937
  var valid_28375938 = path.getOrDefault("commentId")
  valid_28375938 = validateParameter(valid_28375938, JInt, required = true,
                                   default = nil)
  if valid_28375938 != nil:
    section.add "commentId", valid_28375938
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28375939 = header.getOrDefault("Accept")
  valid_28375939 = validateParameter(valid_28375939, JString, required = false,
                                   default = nil)
  if valid_28375939 != nil:
    section.add "Accept", valid_28375939
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28375940: Call_DeleteGistsIdCommentsCommentId_28375934;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a comment.
  ## 
  let valid = call_28375940.validator(path, query, header, formData, body)
  let scheme = call_28375940.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28375940.url(scheme.get, call_28375940.host, call_28375940.base,
                           call_28375940.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28375940, url, valid)

proc call*(call_28375941: Call_DeleteGistsIdCommentsCommentId_28375934; id: int;
          commentId: int; Accept: string = ""): Recallable =
  ## deleteGistsIdCommentsCommentId
  ## Delete a comment.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_28375942 = newJObject()
  var header_28375943 = newJObject()
  add(path_28375942, "id", newJInt(id))
  add(header_28375943, "Accept", newJString(Accept))
  add(path_28375942, "commentId", newJInt(commentId))
  result = call_28375941.call(path_28375942, nil, header_28375943, nil, nil)

var deleteGistsIdCommentsCommentId* = Call_DeleteGistsIdCommentsCommentId_28375934(
    name: "deleteGistsIdCommentsCommentId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/gists/{id}/comments/{commentId}",
    validator: validate_DeleteGistsIdCommentsCommentId_28375935, base: "/",
    url: url_DeleteGistsIdCommentsCommentId_28375936, schemes: {Scheme.Https})
type
  Call_PostGistsIdForks_28375956 = ref object of OpenApiRestCall_28375350
proc url_PostGistsIdForks_28375958(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/forks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostGistsIdForks_28375957(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Fork a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_28375959 = path.getOrDefault("id")
  valid_28375959 = validateParameter(valid_28375959, JInt, required = true,
                                   default = nil)
  if valid_28375959 != nil:
    section.add "id", valid_28375959
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28375960 = header.getOrDefault("Accept")
  valid_28375960 = validateParameter(valid_28375960, JString, required = false,
                                   default = nil)
  if valid_28375960 != nil:
    section.add "Accept", valid_28375960
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28375961: Call_PostGistsIdForks_28375956; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Fork a gist.
  ## 
  let valid = call_28375961.validator(path, query, header, formData, body)
  let scheme = call_28375961.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28375961.url(scheme.get, call_28375961.host, call_28375961.base,
                           call_28375961.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28375961, url, valid)

proc call*(call_28375962: Call_PostGistsIdForks_28375956; id: int;
          Accept: string = ""): Recallable =
  ## postGistsIdForks
  ## Fork a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_28375963 = newJObject()
  var header_28375964 = newJObject()
  add(path_28375963, "id", newJInt(id))
  add(header_28375964, "Accept", newJString(Accept))
  result = call_28375962.call(path_28375963, nil, header_28375964, nil, nil)

var postGistsIdForks* = Call_PostGistsIdForks_28375956(name: "postGistsIdForks",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/gists/{id}/forks",
    validator: validate_PostGistsIdForks_28375957, base: "/",
    url: url_PostGistsIdForks_28375958, schemes: {Scheme.Https})
type
  Call_PutGistsIdStar_28375974 = ref object of OpenApiRestCall_28375350
proc url_PutGistsIdStar_28375976(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/star")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutGistsIdStar_28375975(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Star a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_28375977 = path.getOrDefault("id")
  valid_28375977 = validateParameter(valid_28375977, JInt, required = true,
                                   default = nil)
  if valid_28375977 != nil:
    section.add "id", valid_28375977
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28375978 = header.getOrDefault("Accept")
  valid_28375978 = validateParameter(valid_28375978, JString, required = false,
                                   default = nil)
  if valid_28375978 != nil:
    section.add "Accept", valid_28375978
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28375979: Call_PutGistsIdStar_28375974; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Star a gist.
  ## 
  let valid = call_28375979.validator(path, query, header, formData, body)
  let scheme = call_28375979.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28375979.url(scheme.get, call_28375979.host, call_28375979.base,
                           call_28375979.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28375979, url, valid)

proc call*(call_28375980: Call_PutGistsIdStar_28375974; id: int; Accept: string = ""): Recallable =
  ## putGistsIdStar
  ## Star a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_28375981 = newJObject()
  var header_28375982 = newJObject()
  add(path_28375981, "id", newJInt(id))
  add(header_28375982, "Accept", newJString(Accept))
  result = call_28375980.call(path_28375981, nil, header_28375982, nil, nil)

var putGistsIdStar* = Call_PutGistsIdStar_28375974(name: "putGistsIdStar",
    meth: HttpMethod.HttpPut, host: "api.github.com", route: "/gists/{id}/star",
    validator: validate_PutGistsIdStar_28375975, base: "/", url: url_PutGistsIdStar_28375976,
    schemes: {Scheme.Https})
type
  Call_GetGistsIdStar_28375965 = ref object of OpenApiRestCall_28375350
proc url_GetGistsIdStar_28375967(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/star")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsIdStar_28375966(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Check if a gist is starred.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_28375968 = path.getOrDefault("id")
  valid_28375968 = validateParameter(valid_28375968, JInt, required = true,
                                   default = nil)
  if valid_28375968 != nil:
    section.add "id", valid_28375968
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28375969 = header.getOrDefault("Accept")
  valid_28375969 = validateParameter(valid_28375969, JString, required = false,
                                   default = nil)
  if valid_28375969 != nil:
    section.add "Accept", valid_28375969
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28375970: Call_GetGistsIdStar_28375965; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Check if a gist is starred.
  ## 
  let valid = call_28375970.validator(path, query, header, formData, body)
  let scheme = call_28375970.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28375970.url(scheme.get, call_28375970.host, call_28375970.base,
                           call_28375970.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28375970, url, valid)

proc call*(call_28375971: Call_GetGistsIdStar_28375965; id: int; Accept: string = ""): Recallable =
  ## getGistsIdStar
  ## Check if a gist is starred.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_28375972 = newJObject()
  var header_28375973 = newJObject()
  add(path_28375972, "id", newJInt(id))
  add(header_28375973, "Accept", newJString(Accept))
  result = call_28375971.call(path_28375972, nil, header_28375973, nil, nil)

var getGistsIdStar* = Call_GetGistsIdStar_28375965(name: "getGistsIdStar",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/gists/{id}/star",
    validator: validate_GetGistsIdStar_28375966, base: "/", url: url_GetGistsIdStar_28375967,
    schemes: {Scheme.Https})
type
  Call_DeleteGistsIdStar_28375983 = ref object of OpenApiRestCall_28375350
proc url_DeleteGistsIdStar_28375985(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/star")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteGistsIdStar_28375984(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Unstar a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_28375986 = path.getOrDefault("id")
  valid_28375986 = validateParameter(valid_28375986, JInt, required = true,
                                   default = nil)
  if valid_28375986 != nil:
    section.add "id", valid_28375986
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28375987 = header.getOrDefault("Accept")
  valid_28375987 = validateParameter(valid_28375987, JString, required = false,
                                   default = nil)
  if valid_28375987 != nil:
    section.add "Accept", valid_28375987
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28375988: Call_DeleteGistsIdStar_28375983; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Unstar a gist.
  ## 
  let valid = call_28375988.validator(path, query, header, formData, body)
  let scheme = call_28375988.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28375988.url(scheme.get, call_28375988.host, call_28375988.base,
                           call_28375988.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28375988, url, valid)

proc call*(call_28375989: Call_DeleteGistsIdStar_28375983; id: int;
          Accept: string = ""): Recallable =
  ## deleteGistsIdStar
  ## Unstar a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_28375990 = newJObject()
  var header_28375991 = newJObject()
  add(path_28375990, "id", newJInt(id))
  add(header_28375991, "Accept", newJString(Accept))
  result = call_28375989.call(path_28375990, nil, header_28375991, nil, nil)

var deleteGistsIdStar* = Call_DeleteGistsIdStar_28375983(name: "deleteGistsIdStar",
    meth: HttpMethod.HttpDelete, host: "api.github.com", route: "/gists/{id}/star",
    validator: validate_DeleteGistsIdStar_28375984, base: "/",
    url: url_DeleteGistsIdStar_28375985, schemes: {Scheme.Https})
type
  Call_GetGitignoreTemplates_28375992 = ref object of OpenApiRestCall_28375350
proc url_GetGitignoreTemplates_28375994(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGitignoreTemplates_28375993(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Listing available templates.
  ## List all templates available to pass as an option when creating a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28375995 = header.getOrDefault("Accept")
  valid_28375995 = validateParameter(valid_28375995, JString, required = false,
                                   default = nil)
  if valid_28375995 != nil:
    section.add "Accept", valid_28375995
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28375996: Call_GetGitignoreTemplates_28375992; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Listing available templates.
  ## List all templates available to pass as an option when creating a repository.
  ## 
  ## 
  let valid = call_28375996.validator(path, query, header, formData, body)
  let scheme = call_28375996.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28375996.url(scheme.get, call_28375996.host, call_28375996.base,
                           call_28375996.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28375996, url, valid)

proc call*(call_28375997: Call_GetGitignoreTemplates_28375992; Accept: string = ""): Recallable =
  ## getGitignoreTemplates
  ## Listing available templates.
  ## List all templates available to pass as an option when creating a repository.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_28375998 = newJObject()
  add(header_28375998, "Accept", newJString(Accept))
  result = call_28375997.call(nil, nil, header_28375998, nil, nil)

var getGitignoreTemplates* = Call_GetGitignoreTemplates_28375992(
    name: "getGitignoreTemplates", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/gitignore/templates", validator: validate_GetGitignoreTemplates_28375993,
    base: "/", url: url_GetGitignoreTemplates_28375994, schemes: {Scheme.Https})
type
  Call_GetGitignoreTemplatesLanguage_28375999 = ref object of OpenApiRestCall_28375350
proc url_GetGitignoreTemplatesLanguage_28376001(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "language" in path, "`language` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gitignore/templates/"),
               (kind: VariableSegment, value: "language")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGitignoreTemplatesLanguage_28376000(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   language: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `language` field"
  var valid_28376002 = path.getOrDefault("language")
  valid_28376002 = validateParameter(valid_28376002, JString, required = true,
                                   default = nil)
  if valid_28376002 != nil:
    section.add "language", valid_28376002
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376003 = header.getOrDefault("Accept")
  valid_28376003 = validateParameter(valid_28376003, JString, required = false,
                                   default = nil)
  if valid_28376003 != nil:
    section.add "Accept", valid_28376003
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376004: Call_GetGitignoreTemplatesLanguage_28375999;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single template.
  ## 
  let valid = call_28376004.validator(path, query, header, formData, body)
  let scheme = call_28376004.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376004.url(scheme.get, call_28376004.host, call_28376004.base,
                           call_28376004.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376004, url, valid)

proc call*(call_28376005: Call_GetGitignoreTemplatesLanguage_28375999;
          language: string; Accept: string = ""): Recallable =
  ## getGitignoreTemplatesLanguage
  ## Get a single template.
  ##   language: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_28376006 = newJObject()
  var header_28376007 = newJObject()
  add(path_28376006, "language", newJString(language))
  add(header_28376007, "Accept", newJString(Accept))
  result = call_28376005.call(path_28376006, nil, header_28376007, nil, nil)

var getGitignoreTemplatesLanguage* = Call_GetGitignoreTemplatesLanguage_28375999(
    name: "getGitignoreTemplatesLanguage", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/gitignore/templates/{language}",
    validator: validate_GetGitignoreTemplatesLanguage_28376000, base: "/",
    url: url_GetGitignoreTemplatesLanguage_28376001, schemes: {Scheme.Https})
type
  Call_GetIssues_28376008 = ref object of OpenApiRestCall_28375350
proc url_GetIssues_28376010(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetIssues_28376009(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## List issues.
  ## List all issues across all the authenticated user's visible repositories.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString (required)
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: JString (required)
  ##   direction: JString (required)
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_28376025 = query.getOrDefault("state")
  valid_28376025 = validateParameter(valid_28376025, JString, required = true,
                                   default = newJString("open"))
  if valid_28376025 != nil:
    section.add "state", valid_28376025
  var valid_28376026 = query.getOrDefault("labels")
  valid_28376026 = validateParameter(valid_28376026, JString, required = true,
                                   default = nil)
  if valid_28376026 != nil:
    section.add "labels", valid_28376026
  var valid_28376027 = query.getOrDefault("sort")
  valid_28376027 = validateParameter(valid_28376027, JString, required = true,
                                   default = newJString("created"))
  if valid_28376027 != nil:
    section.add "sort", valid_28376027
  var valid_28376028 = query.getOrDefault("direction")
  valid_28376028 = validateParameter(valid_28376028, JString, required = true,
                                   default = newJString("desc"))
  if valid_28376028 != nil:
    section.add "direction", valid_28376028
  var valid_28376029 = query.getOrDefault("filter")
  valid_28376029 = validateParameter(valid_28376029, JString, required = true,
                                   default = newJString("all"))
  if valid_28376029 != nil:
    section.add "filter", valid_28376029
  var valid_28376030 = query.getOrDefault("since")
  valid_28376030 = validateParameter(valid_28376030, JString, required = false,
                                   default = nil)
  if valid_28376030 != nil:
    section.add "since", valid_28376030
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376031 = header.getOrDefault("Accept")
  valid_28376031 = validateParameter(valid_28376031, JString, required = false,
                                   default = nil)
  if valid_28376031 != nil:
    section.add "Accept", valid_28376031
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376032: Call_GetIssues_28376008; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List issues.
  ## List all issues across all the authenticated user's visible repositories.
  ## 
  ## 
  let valid = call_28376032.validator(path, query, header, formData, body)
  let scheme = call_28376032.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376032.url(scheme.get, call_28376032.host, call_28376032.base,
                           call_28376032.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376032, url, valid)

proc call*(call_28376033: Call_GetIssues_28376008; labels: string;
          state: string = "open"; Accept: string = ""; sort: string = "created";
          direction: string = "desc"; filter: string = "all"; since: string = ""): Recallable =
  ## getIssues
  ## List issues.
  ## List all issues across all the authenticated user's visible repositories.
  ## 
  ##   state: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: string (required)
  ##   direction: string (required)
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  var query_28376034 = newJObject()
  var header_28376035 = newJObject()
  add(query_28376034, "state", newJString(state))
  add(header_28376035, "Accept", newJString(Accept))
  add(query_28376034, "labels", newJString(labels))
  add(query_28376034, "sort", newJString(sort))
  add(query_28376034, "direction", newJString(direction))
  add(query_28376034, "filter", newJString(filter))
  add(query_28376034, "since", newJString(since))
  result = call_28376033.call(nil, query_28376034, header_28376035, nil, nil)

var getIssues* = Call_GetIssues_28376008(name: "getIssues", meth: HttpMethod.HttpGet,
                                      host: "api.github.com", route: "/issues",
                                      validator: validate_GetIssues_28376009,
                                      base: "/", url: url_GetIssues_28376010,
                                      schemes: {Scheme.Https})
type
  Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_28376037 = ref object of OpenApiRestCall_28375350
proc url_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_28376039(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repository" in path, "`repository` is a required path parameter"
  assert "state" in path, "`state` is a required path parameter"
  assert "keyword" in path, "`keyword` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/issues/search/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repository"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "state"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "keyword")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_28376038(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Find issues by state and keyword.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##   repository: JString (required)
  ##   keyword: JString (required)
  ##          : The search term.
  ##   state: JString (required)
  ##        : Indicates the state of the issues to return. Can be either open or closed.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376040 = path.getOrDefault("owner")
  valid_28376040 = validateParameter(valid_28376040, JString, required = true,
                                   default = nil)
  if valid_28376040 != nil:
    section.add "owner", valid_28376040
  var valid_28376041 = path.getOrDefault("repository")
  valid_28376041 = validateParameter(valid_28376041, JString, required = true,
                                   default = nil)
  if valid_28376041 != nil:
    section.add "repository", valid_28376041
  var valid_28376042 = path.getOrDefault("keyword")
  valid_28376042 = validateParameter(valid_28376042, JString, required = true,
                                   default = nil)
  if valid_28376042 != nil:
    section.add "keyword", valid_28376042
  var valid_28376043 = path.getOrDefault("state")
  valid_28376043 = validateParameter(valid_28376043, JString, required = true,
                                   default = newJString("open"))
  if valid_28376043 != nil:
    section.add "state", valid_28376043
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376044 = header.getOrDefault("Accept")
  valid_28376044 = validateParameter(valid_28376044, JString, required = false,
                                   default = nil)
  if valid_28376044 != nil:
    section.add "Accept", valid_28376044
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376045: Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_28376037;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Find issues by state and keyword.
  ## 
  let valid = call_28376045.validator(path, query, header, formData, body)
  let scheme = call_28376045.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376045.url(scheme.get, call_28376045.host, call_28376045.base,
                           call_28376045.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376045, url, valid)

proc call*(call_28376046: Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_28376037;
          owner: string; repository: string; keyword: string; Accept: string = "";
          state: string = "open"): Recallable =
  ## getLegacyIssuesSearchOwnerRepositoryStateKeyword
  ## Find issues by state and keyword.
  ##   owner: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repository: string (required)
  ##   keyword: string (required)
  ##          : The search term.
  ##   state: string (required)
  ##        : Indicates the state of the issues to return. Can be either open or closed.
  var path_28376047 = newJObject()
  var header_28376048 = newJObject()
  add(path_28376047, "owner", newJString(owner))
  add(header_28376048, "Accept", newJString(Accept))
  add(path_28376047, "repository", newJString(repository))
  add(path_28376047, "keyword", newJString(keyword))
  add(path_28376047, "state", newJString(state))
  result = call_28376046.call(path_28376047, nil, header_28376048, nil, nil)

var getLegacyIssuesSearchOwnerRepositoryStateKeyword* = Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_28376037(
    name: "getLegacyIssuesSearchOwnerRepositoryStateKeyword",
    meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/legacy/issues/search/{owner}/{repository}/{state}/{keyword}",
    validator: validate_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_28376038,
    base: "/", url: url_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_28376039,
    schemes: {Scheme.Https})
type
  Call_GetLegacyReposSearchKeyword_28376049 = ref object of OpenApiRestCall_28375350
proc url_GetLegacyReposSearchKeyword_28376051(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyword" in path, "`keyword` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/repos/search/"),
               (kind: VariableSegment, value: "keyword")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyReposSearchKeyword_28376050(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Find repositories by keyword. Note, this legacy method does not follow the v3 pagination pattern. This method returns up to 100 results per page and pages can be fetched using the start_page parameter.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyword: JString (required)
  ##          : The search term
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyword` field"
  var valid_28376052 = path.getOrDefault("keyword")
  valid_28376052 = validateParameter(valid_28376052, JString, required = true,
                                   default = nil)
  if valid_28376052 != nil:
    section.add "keyword", valid_28376052
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   language: JString
  ##           : Filter results by language
  ##   start_page: JString
  ##             : The page number to fetch
  ##   sort: JString
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  section = newJObject()
  var valid_28376053 = query.getOrDefault("order")
  valid_28376053 = validateParameter(valid_28376053, JString, required = false,
                                   default = newJString("desc"))
  if valid_28376053 != nil:
    section.add "order", valid_28376053
  var valid_28376054 = query.getOrDefault("language")
  valid_28376054 = validateParameter(valid_28376054, JString, required = false,
                                   default = nil)
  if valid_28376054 != nil:
    section.add "language", valid_28376054
  var valid_28376055 = query.getOrDefault("start_page")
  valid_28376055 = validateParameter(valid_28376055, JString, required = false,
                                   default = nil)
  if valid_28376055 != nil:
    section.add "start_page", valid_28376055
  var valid_28376056 = query.getOrDefault("sort")
  valid_28376056 = validateParameter(valid_28376056, JString, required = false,
                                   default = newJString("updated"))
  if valid_28376056 != nil:
    section.add "sort", valid_28376056
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376057 = header.getOrDefault("Accept")
  valid_28376057 = validateParameter(valid_28376057, JString, required = false,
                                   default = nil)
  if valid_28376057 != nil:
    section.add "Accept", valid_28376057
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376058: Call_GetLegacyReposSearchKeyword_28376049;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Find repositories by keyword. Note, this legacy method does not follow the v3 pagination pattern. This method returns up to 100 results per page and pages can be fetched using the start_page parameter.
  ## 
  let valid = call_28376058.validator(path, query, header, formData, body)
  let scheme = call_28376058.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376058.url(scheme.get, call_28376058.host, call_28376058.base,
                           call_28376058.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376058, url, valid)

proc call*(call_28376059: Call_GetLegacyReposSearchKeyword_28376049;
          keyword: string; order: string = "desc"; language: string = "";
          Accept: string = ""; startPage: string = ""; sort: string = "updated"): Recallable =
  ## getLegacyReposSearchKeyword
  ## Find repositories by keyword. Note, this legacy method does not follow the v3 pagination pattern. This method returns up to 100 results per page and pages can be fetched using the start_page parameter.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   language: string
  ##           : Filter results by language
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   startPage: string
  ##            : The page number to fetch
  ##   sort: string
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  ##   keyword: string (required)
  ##          : The search term
  var path_28376060 = newJObject()
  var query_28376061 = newJObject()
  var header_28376062 = newJObject()
  add(query_28376061, "order", newJString(order))
  add(query_28376061, "language", newJString(language))
  add(header_28376062, "Accept", newJString(Accept))
  add(query_28376061, "start_page", newJString(startPage))
  add(query_28376061, "sort", newJString(sort))
  add(path_28376060, "keyword", newJString(keyword))
  result = call_28376059.call(path_28376060, query_28376061, header_28376062, nil, nil)

var getLegacyReposSearchKeyword* = Call_GetLegacyReposSearchKeyword_28376049(
    name: "getLegacyReposSearchKeyword", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/legacy/repos/search/{keyword}",
    validator: validate_GetLegacyReposSearchKeyword_28376050, base: "/",
    url: url_GetLegacyReposSearchKeyword_28376051, schemes: {Scheme.Https})
type
  Call_GetLegacyUserEmailEmail_28376063 = ref object of OpenApiRestCall_28375350
proc url_GetLegacyUserEmailEmail_28376065(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "email" in path, "`email` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/user/email/"),
               (kind: VariableSegment, value: "email")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyUserEmailEmail_28376064(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This API call is added for compatibility reasons only.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   email: JString (required)
  ##        : The email address
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `email` field"
  var valid_28376066 = path.getOrDefault("email")
  valid_28376066 = validateParameter(valid_28376066, JString, required = true,
                                   default = nil)
  if valid_28376066 != nil:
    section.add "email", valid_28376066
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376067 = header.getOrDefault("Accept")
  valid_28376067 = validateParameter(valid_28376067, JString, required = false,
                                   default = nil)
  if valid_28376067 != nil:
    section.add "Accept", valid_28376067
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376068: Call_GetLegacyUserEmailEmail_28376063; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This API call is added for compatibility reasons only.
  ## 
  let valid = call_28376068.validator(path, query, header, formData, body)
  let scheme = call_28376068.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376068.url(scheme.get, call_28376068.host, call_28376068.base,
                           call_28376068.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376068, url, valid)

proc call*(call_28376069: Call_GetLegacyUserEmailEmail_28376063; email: string;
          Accept: string = ""): Recallable =
  ## getLegacyUserEmailEmail
  ## This API call is added for compatibility reasons only.
  ##   email: string (required)
  ##        : The email address
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_28376070 = newJObject()
  var header_28376071 = newJObject()
  add(path_28376070, "email", newJString(email))
  add(header_28376071, "Accept", newJString(Accept))
  result = call_28376069.call(path_28376070, nil, header_28376071, nil, nil)

var getLegacyUserEmailEmail* = Call_GetLegacyUserEmailEmail_28376063(
    name: "getLegacyUserEmailEmail", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/legacy/user/email/{email}",
    validator: validate_GetLegacyUserEmailEmail_28376064, base: "/",
    url: url_GetLegacyUserEmailEmail_28376065, schemes: {Scheme.Https})
type
  Call_GetLegacyUserSearchKeyword_28376072 = ref object of OpenApiRestCall_28375350
proc url_GetLegacyUserSearchKeyword_28376074(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyword" in path, "`keyword` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/user/search/"),
               (kind: VariableSegment, value: "keyword")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyUserSearchKeyword_28376073(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Find users by keyword.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyword: JString (required)
  ##          : The search term
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyword` field"
  var valid_28376075 = path.getOrDefault("keyword")
  valid_28376075 = validateParameter(valid_28376075, JString, required = true,
                                   default = nil)
  if valid_28376075 != nil:
    section.add "keyword", valid_28376075
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   start_page: JString
  ##             : The page number to fetch
  ##   sort: JString
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  section = newJObject()
  var valid_28376076 = query.getOrDefault("order")
  valid_28376076 = validateParameter(valid_28376076, JString, required = false,
                                   default = newJString("desc"))
  if valid_28376076 != nil:
    section.add "order", valid_28376076
  var valid_28376077 = query.getOrDefault("start_page")
  valid_28376077 = validateParameter(valid_28376077, JString, required = false,
                                   default = nil)
  if valid_28376077 != nil:
    section.add "start_page", valid_28376077
  var valid_28376078 = query.getOrDefault("sort")
  valid_28376078 = validateParameter(valid_28376078, JString, required = false,
                                   default = newJString("updated"))
  if valid_28376078 != nil:
    section.add "sort", valid_28376078
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376079 = header.getOrDefault("Accept")
  valid_28376079 = validateParameter(valid_28376079, JString, required = false,
                                   default = nil)
  if valid_28376079 != nil:
    section.add "Accept", valid_28376079
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376080: Call_GetLegacyUserSearchKeyword_28376072; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Find users by keyword.
  ## 
  let valid = call_28376080.validator(path, query, header, formData, body)
  let scheme = call_28376080.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376080.url(scheme.get, call_28376080.host, call_28376080.base,
                           call_28376080.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376080, url, valid)

proc call*(call_28376081: Call_GetLegacyUserSearchKeyword_28376072;
          keyword: string; order: string = "desc"; Accept: string = "";
          startPage: string = ""; sort: string = "updated"): Recallable =
  ## getLegacyUserSearchKeyword
  ## Find users by keyword.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   startPage: string
  ##            : The page number to fetch
  ##   sort: string
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  ##   keyword: string (required)
  ##          : The search term
  var path_28376082 = newJObject()
  var query_28376083 = newJObject()
  var header_28376084 = newJObject()
  add(query_28376083, "order", newJString(order))
  add(header_28376084, "Accept", newJString(Accept))
  add(query_28376083, "start_page", newJString(startPage))
  add(query_28376083, "sort", newJString(sort))
  add(path_28376082, "keyword", newJString(keyword))
  result = call_28376081.call(path_28376082, query_28376083, header_28376084, nil, nil)

var getLegacyUserSearchKeyword* = Call_GetLegacyUserSearchKeyword_28376072(
    name: "getLegacyUserSearchKeyword", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/legacy/user/search/{keyword}",
    validator: validate_GetLegacyUserSearchKeyword_28376073, base: "/",
    url: url_GetLegacyUserSearchKeyword_28376074, schemes: {Scheme.Https})
type
  Call_PostMarkdown_28376085 = ref object of OpenApiRestCall_28375350
proc url_PostMarkdown_28376087(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostMarkdown_28376086(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Render an arbitrary Markdown document
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376088 = header.getOrDefault("Accept")
  valid_28376088 = validateParameter(valid_28376088, JString, required = false,
                                   default = nil)
  if valid_28376088 != nil:
    section.add "Accept", valid_28376088
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28376090: Call_PostMarkdown_28376085; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Render an arbitrary Markdown document
  ## 
  let valid = call_28376090.validator(path, query, header, formData, body)
  let scheme = call_28376090.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376090.url(scheme.get, call_28376090.host, call_28376090.base,
                           call_28376090.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376090, url, valid)

proc call*(call_28376091: Call_PostMarkdown_28376085; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postMarkdown
  ## Render an arbitrary Markdown document
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_28376092 = newJObject()
  var body_28376093 = newJObject()
  add(header_28376092, "Accept", newJString(Accept))
  if body != nil:
    body_28376093 = body
  result = call_28376091.call(nil, nil, header_28376092, nil, body_28376093)

var postMarkdown* = Call_PostMarkdown_28376085(name: "postMarkdown",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/markdown",
    validator: validate_PostMarkdown_28376086, base: "/", url: url_PostMarkdown_28376087,
    schemes: {Scheme.Https})
type
  Call_PostMarkdownRaw_28376094 = ref object of OpenApiRestCall_28375350
proc url_PostMarkdownRaw_28376096(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostMarkdownRaw_28376095(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Render a Markdown document in raw mode
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376097 = header.getOrDefault("Accept")
  valid_28376097 = validateParameter(valid_28376097, JString, required = false,
                                   default = nil)
  if valid_28376097 != nil:
    section.add "Accept", valid_28376097
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376098: Call_PostMarkdownRaw_28376094; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Render a Markdown document in raw mode
  ## 
  let valid = call_28376098.validator(path, query, header, formData, body)
  let scheme = call_28376098.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376098.url(scheme.get, call_28376098.host, call_28376098.base,
                           call_28376098.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376098, url, valid)

proc call*(call_28376099: Call_PostMarkdownRaw_28376094; Accept: string = ""): Recallable =
  ## postMarkdownRaw
  ## Render a Markdown document in raw mode
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_28376100 = newJObject()
  add(header_28376100, "Accept", newJString(Accept))
  result = call_28376099.call(nil, nil, header_28376100, nil, nil)

var postMarkdownRaw* = Call_PostMarkdownRaw_28376094(name: "postMarkdownRaw",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/markdown/raw",
    validator: validate_PostMarkdownRaw_28376095, base: "/",
    url: url_PostMarkdownRaw_28376096, schemes: {Scheme.Https})
type
  Call_GetMeta_28376101 = ref object of OpenApiRestCall_28375350
proc url_GetMeta_28376103(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetMeta_28376102(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## This gives some information about GitHub.com, the service.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376104 = header.getOrDefault("Accept")
  valid_28376104 = validateParameter(valid_28376104, JString, required = false,
                                   default = nil)
  if valid_28376104 != nil:
    section.add "Accept", valid_28376104
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376105: Call_GetMeta_28376101; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This gives some information about GitHub.com, the service.
  ## 
  let valid = call_28376105.validator(path, query, header, formData, body)
  let scheme = call_28376105.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376105.url(scheme.get, call_28376105.host, call_28376105.base,
                           call_28376105.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376105, url, valid)

proc call*(call_28376106: Call_GetMeta_28376101; Accept: string = ""): Recallable =
  ## getMeta
  ## This gives some information about GitHub.com, the service.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_28376107 = newJObject()
  add(header_28376107, "Accept", newJString(Accept))
  result = call_28376106.call(nil, nil, header_28376107, nil, nil)

var getMeta* = Call_GetMeta_28376101(name: "getMeta", meth: HttpMethod.HttpGet,
                                  host: "api.github.com", route: "/meta",
                                  validator: validate_GetMeta_28376102, base: "/",
                                  url: url_GetMeta_28376103,
                                  schemes: {Scheme.Https})
type
  Call_GetNetworksOwnerRepoEvents_28376108 = ref object of OpenApiRestCall_28375350
proc url_GetNetworksOwnerRepoEvents_28376110(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/networks/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetNetworksOwnerRepoEvents_28376109(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List public events for a network of repositories.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of the owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376111 = path.getOrDefault("owner")
  valid_28376111 = validateParameter(valid_28376111, JString, required = true,
                                   default = nil)
  if valid_28376111 != nil:
    section.add "owner", valid_28376111
  var valid_28376112 = path.getOrDefault("repo")
  valid_28376112 = validateParameter(valid_28376112, JString, required = true,
                                   default = nil)
  if valid_28376112 != nil:
    section.add "repo", valid_28376112
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376113 = header.getOrDefault("Accept")
  valid_28376113 = validateParameter(valid_28376113, JString, required = false,
                                   default = nil)
  if valid_28376113 != nil:
    section.add "Accept", valid_28376113
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376114: Call_GetNetworksOwnerRepoEvents_28376108; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List public events for a network of repositories.
  ## 
  let valid = call_28376114.validator(path, query, header, formData, body)
  let scheme = call_28376114.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376114.url(scheme.get, call_28376114.host, call_28376114.base,
                           call_28376114.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376114, url, valid)

proc call*(call_28376115: Call_GetNetworksOwnerRepoEvents_28376108; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getNetworksOwnerRepoEvents
  ## List public events for a network of repositories.
  ##   owner: string (required)
  ##        : Name of the owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376116 = newJObject()
  var header_28376117 = newJObject()
  add(path_28376116, "owner", newJString(owner))
  add(header_28376117, "Accept", newJString(Accept))
  add(path_28376116, "repo", newJString(repo))
  result = call_28376115.call(path_28376116, nil, header_28376117, nil, nil)

var getNetworksOwnerRepoEvents* = Call_GetNetworksOwnerRepoEvents_28376108(
    name: "getNetworksOwnerRepoEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/networks/{owner}/{repo}/events",
    validator: validate_GetNetworksOwnerRepoEvents_28376109, base: "/",
    url: url_GetNetworksOwnerRepoEvents_28376110, schemes: {Scheme.Https})
type
  Call_PutNotifications_28376129 = ref object of OpenApiRestCall_28375350
proc url_PutNotifications_28376131(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PutNotifications_28376130(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Mark as read.
  ## Marking a notification as "read" removes it from the default view on GitHub.com.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376132 = header.getOrDefault("Accept")
  valid_28376132 = validateParameter(valid_28376132, JString, required = false,
                                   default = nil)
  if valid_28376132 != nil:
    section.add "Accept", valid_28376132
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28376134: Call_PutNotifications_28376129; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Mark as read.
  ## Marking a notification as "read" removes it from the default view on GitHub.com.
  ## 
  ## 
  let valid = call_28376134.validator(path, query, header, formData, body)
  let scheme = call_28376134.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376134.url(scheme.get, call_28376134.host, call_28376134.base,
                           call_28376134.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376134, url, valid)

proc call*(call_28376135: Call_PutNotifications_28376129; body: JsonNode;
          Accept: string = ""): Recallable =
  ## putNotifications
  ## Mark as read.
  ## Marking a notification as "read" removes it from the default view on GitHub.com.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_28376136 = newJObject()
  var body_28376137 = newJObject()
  add(header_28376136, "Accept", newJString(Accept))
  if body != nil:
    body_28376137 = body
  result = call_28376135.call(nil, nil, header_28376136, nil, body_28376137)

var putNotifications* = Call_PutNotifications_28376129(name: "putNotifications",
    meth: HttpMethod.HttpPut, host: "api.github.com", route: "/notifications",
    validator: validate_PutNotifications_28376130, base: "/",
    url: url_PutNotifications_28376131, schemes: {Scheme.Https})
type
  Call_GetNotifications_28376118 = ref object of OpenApiRestCall_28375350
proc url_GetNotifications_28376120(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetNotifications_28376119(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## List your notifications.
  ## List all notifications for the current user, grouped by repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   participating: JBool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  ##   all: JBool
  ##      : True to show notifications marked as read.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_28376121 = query.getOrDefault("participating")
  valid_28376121 = validateParameter(valid_28376121, JBool, required = false,
                                   default = nil)
  if valid_28376121 != nil:
    section.add "participating", valid_28376121
  var valid_28376122 = query.getOrDefault("all")
  valid_28376122 = validateParameter(valid_28376122, JBool, required = false,
                                   default = nil)
  if valid_28376122 != nil:
    section.add "all", valid_28376122
  var valid_28376123 = query.getOrDefault("since")
  valid_28376123 = validateParameter(valid_28376123, JString, required = false,
                                   default = nil)
  if valid_28376123 != nil:
    section.add "since", valid_28376123
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376124 = header.getOrDefault("Accept")
  valid_28376124 = validateParameter(valid_28376124, JString, required = false,
                                   default = nil)
  if valid_28376124 != nil:
    section.add "Accept", valid_28376124
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376125: Call_GetNotifications_28376118; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List your notifications.
  ## List all notifications for the current user, grouped by repository.
  ## 
  ## 
  let valid = call_28376125.validator(path, query, header, formData, body)
  let scheme = call_28376125.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376125.url(scheme.get, call_28376125.host, call_28376125.base,
                           call_28376125.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376125, url, valid)

proc call*(call_28376126: Call_GetNotifications_28376118;
          participating: bool = false; all: bool = false; Accept: string = "";
          since: string = ""): Recallable =
  ## getNotifications
  ## List your notifications.
  ## List all notifications for the current user, grouped by repository.
  ## 
  ##   participating: bool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  ##   all: bool
  ##      : True to show notifications marked as read.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var query_28376127 = newJObject()
  var header_28376128 = newJObject()
  add(query_28376127, "participating", newJBool(participating))
  add(query_28376127, "all", newJBool(all))
  add(header_28376128, "Accept", newJString(Accept))
  add(query_28376127, "since", newJString(since))
  result = call_28376126.call(nil, query_28376127, header_28376128, nil, nil)

var getNotifications* = Call_GetNotifications_28376118(name: "getNotifications",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/notifications",
    validator: validate_GetNotifications_28376119, base: "/",
    url: url_GetNotifications_28376120, schemes: {Scheme.Https})
type
  Call_GetNotificationsThreadsId_28376138 = ref object of OpenApiRestCall_28375350
proc url_GetNotificationsThreadsId_28376140(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetNotificationsThreadsId_28376139(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## View a single thread.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_28376141 = path.getOrDefault("id")
  valid_28376141 = validateParameter(valid_28376141, JInt, required = true,
                                   default = nil)
  if valid_28376141 != nil:
    section.add "id", valid_28376141
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376142 = header.getOrDefault("Accept")
  valid_28376142 = validateParameter(valid_28376142, JString, required = false,
                                   default = nil)
  if valid_28376142 != nil:
    section.add "Accept", valid_28376142
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376143: Call_GetNotificationsThreadsId_28376138; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## View a single thread.
  ## 
  let valid = call_28376143.validator(path, query, header, formData, body)
  let scheme = call_28376143.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376143.url(scheme.get, call_28376143.host, call_28376143.base,
                           call_28376143.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376143, url, valid)

proc call*(call_28376144: Call_GetNotificationsThreadsId_28376138; id: int;
          Accept: string = ""): Recallable =
  ## getNotificationsThreadsId
  ## View a single thread.
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_28376145 = newJObject()
  var header_28376146 = newJObject()
  add(path_28376145, "id", newJInt(id))
  add(header_28376146, "Accept", newJString(Accept))
  result = call_28376144.call(path_28376145, nil, header_28376146, nil, nil)

var getNotificationsThreadsId* = Call_GetNotificationsThreadsId_28376138(
    name: "getNotificationsThreadsId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/notifications/threads/{id}",
    validator: validate_GetNotificationsThreadsId_28376139, base: "/",
    url: url_GetNotificationsThreadsId_28376140, schemes: {Scheme.Https})
type
  Call_PatchNotificationsThreadsId_28376147 = ref object of OpenApiRestCall_28375350
proc url_PatchNotificationsThreadsId_28376149(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchNotificationsThreadsId_28376148(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Mark a thread as read
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_28376150 = path.getOrDefault("id")
  valid_28376150 = validateParameter(valid_28376150, JInt, required = true,
                                   default = nil)
  if valid_28376150 != nil:
    section.add "id", valid_28376150
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376151 = header.getOrDefault("Accept")
  valid_28376151 = validateParameter(valid_28376151, JString, required = false,
                                   default = nil)
  if valid_28376151 != nil:
    section.add "Accept", valid_28376151
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376152: Call_PatchNotificationsThreadsId_28376147;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Mark a thread as read
  ## 
  let valid = call_28376152.validator(path, query, header, formData, body)
  let scheme = call_28376152.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376152.url(scheme.get, call_28376152.host, call_28376152.base,
                           call_28376152.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376152, url, valid)

proc call*(call_28376153: Call_PatchNotificationsThreadsId_28376147; id: int;
          Accept: string = ""): Recallable =
  ## patchNotificationsThreadsId
  ## Mark a thread as read
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_28376154 = newJObject()
  var header_28376155 = newJObject()
  add(path_28376154, "id", newJInt(id))
  add(header_28376155, "Accept", newJString(Accept))
  result = call_28376153.call(path_28376154, nil, header_28376155, nil, nil)

var patchNotificationsThreadsId* = Call_PatchNotificationsThreadsId_28376147(
    name: "patchNotificationsThreadsId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/notifications/threads/{id}",
    validator: validate_PatchNotificationsThreadsId_28376148, base: "/",
    url: url_PatchNotificationsThreadsId_28376149, schemes: {Scheme.Https})
type
  Call_PutNotificationsThreadsIdSubscription_28376165 = ref object of OpenApiRestCall_28375350
proc url_PutNotificationsThreadsIdSubscription_28376167(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutNotificationsThreadsIdSubscription_28376166(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set a Thread Subscription.
  ## This lets you subscribe to a thread, or ignore it. Subscribing to a thread
  ## is unnecessary if the user is already subscribed to the repository. Ignoring
  ## a thread will mute all future notifications (until you comment or get @mentioned).
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_28376168 = path.getOrDefault("id")
  valid_28376168 = validateParameter(valid_28376168, JInt, required = true,
                                   default = nil)
  if valid_28376168 != nil:
    section.add "id", valid_28376168
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376169 = header.getOrDefault("Accept")
  valid_28376169 = validateParameter(valid_28376169, JString, required = false,
                                   default = nil)
  if valid_28376169 != nil:
    section.add "Accept", valid_28376169
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28376171: Call_PutNotificationsThreadsIdSubscription_28376165;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Set a Thread Subscription.
  ## This lets you subscribe to a thread, or ignore it. Subscribing to a thread
  ## is unnecessary if the user is already subscribed to the repository. Ignoring
  ## a thread will mute all future notifications (until you comment or get @mentioned).
  ## 
  ## 
  let valid = call_28376171.validator(path, query, header, formData, body)
  let scheme = call_28376171.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376171.url(scheme.get, call_28376171.host, call_28376171.base,
                           call_28376171.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376171, url, valid)

proc call*(call_28376172: Call_PutNotificationsThreadsIdSubscription_28376165;
          id: int; body: JsonNode; Accept: string = ""): Recallable =
  ## putNotificationsThreadsIdSubscription
  ## Set a Thread Subscription.
  ## This lets you subscribe to a thread, or ignore it. Subscribing to a thread
  ## is unnecessary if the user is already subscribed to the repository. Ignoring
  ## a thread will mute all future notifications (until you comment or get @mentioned).
  ## 
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var path_28376173 = newJObject()
  var header_28376174 = newJObject()
  var body_28376175 = newJObject()
  add(path_28376173, "id", newJInt(id))
  add(header_28376174, "Accept", newJString(Accept))
  if body != nil:
    body_28376175 = body
  result = call_28376172.call(path_28376173, nil, header_28376174, nil, body_28376175)

var putNotificationsThreadsIdSubscription* = Call_PutNotificationsThreadsIdSubscription_28376165(
    name: "putNotificationsThreadsIdSubscription", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/notifications/threads/{id}/subscription",
    validator: validate_PutNotificationsThreadsIdSubscription_28376166, base: "/",
    url: url_PutNotificationsThreadsIdSubscription_28376167,
    schemes: {Scheme.Https})
type
  Call_GetNotificationsThreadsIdSubscription_28376156 = ref object of OpenApiRestCall_28375350
proc url_GetNotificationsThreadsIdSubscription_28376158(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetNotificationsThreadsIdSubscription_28376157(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a Thread Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_28376159 = path.getOrDefault("id")
  valid_28376159 = validateParameter(valid_28376159, JInt, required = true,
                                   default = nil)
  if valid_28376159 != nil:
    section.add "id", valid_28376159
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376160 = header.getOrDefault("Accept")
  valid_28376160 = validateParameter(valid_28376160, JString, required = false,
                                   default = nil)
  if valid_28376160 != nil:
    section.add "Accept", valid_28376160
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376161: Call_GetNotificationsThreadsIdSubscription_28376156;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a Thread Subscription.
  ## 
  let valid = call_28376161.validator(path, query, header, formData, body)
  let scheme = call_28376161.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376161.url(scheme.get, call_28376161.host, call_28376161.base,
                           call_28376161.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376161, url, valid)

proc call*(call_28376162: Call_GetNotificationsThreadsIdSubscription_28376156;
          id: int; Accept: string = ""): Recallable =
  ## getNotificationsThreadsIdSubscription
  ## Get a Thread Subscription.
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_28376163 = newJObject()
  var header_28376164 = newJObject()
  add(path_28376163, "id", newJInt(id))
  add(header_28376164, "Accept", newJString(Accept))
  result = call_28376162.call(path_28376163, nil, header_28376164, nil, nil)

var getNotificationsThreadsIdSubscription* = Call_GetNotificationsThreadsIdSubscription_28376156(
    name: "getNotificationsThreadsIdSubscription", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/notifications/threads/{id}/subscription",
    validator: validate_GetNotificationsThreadsIdSubscription_28376157, base: "/",
    url: url_GetNotificationsThreadsIdSubscription_28376158,
    schemes: {Scheme.Https})
type
  Call_DeleteNotificationsThreadsIdSubscription_28376176 = ref object of OpenApiRestCall_28375350
proc url_DeleteNotificationsThreadsIdSubscription_28376178(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteNotificationsThreadsIdSubscription_28376177(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a Thread Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_28376179 = path.getOrDefault("id")
  valid_28376179 = validateParameter(valid_28376179, JInt, required = true,
                                   default = nil)
  if valid_28376179 != nil:
    section.add "id", valid_28376179
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376180 = header.getOrDefault("Accept")
  valid_28376180 = validateParameter(valid_28376180, JString, required = false,
                                   default = nil)
  if valid_28376180 != nil:
    section.add "Accept", valid_28376180
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376181: Call_DeleteNotificationsThreadsIdSubscription_28376176;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a Thread Subscription.
  ## 
  let valid = call_28376181.validator(path, query, header, formData, body)
  let scheme = call_28376181.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376181.url(scheme.get, call_28376181.host, call_28376181.base,
                           call_28376181.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376181, url, valid)

proc call*(call_28376182: Call_DeleteNotificationsThreadsIdSubscription_28376176;
          id: int; Accept: string = ""): Recallable =
  ## deleteNotificationsThreadsIdSubscription
  ## Delete a Thread Subscription.
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_28376183 = newJObject()
  var header_28376184 = newJObject()
  add(path_28376183, "id", newJInt(id))
  add(header_28376184, "Accept", newJString(Accept))
  result = call_28376182.call(path_28376183, nil, header_28376184, nil, nil)

var deleteNotificationsThreadsIdSubscription* = Call_DeleteNotificationsThreadsIdSubscription_28376176(
    name: "deleteNotificationsThreadsIdSubscription", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/notifications/threads/{id}/subscription",
    validator: validate_DeleteNotificationsThreadsIdSubscription_28376177,
    base: "/", url: url_DeleteNotificationsThreadsIdSubscription_28376178,
    schemes: {Scheme.Https})
type
  Call_GetOrgsOrg_28376185 = ref object of OpenApiRestCall_28375350
proc url_GetOrgsOrg_28376187(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrg_28376186(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Get an Organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_28376188 = path.getOrDefault("org")
  valid_28376188 = validateParameter(valid_28376188, JString, required = true,
                                   default = nil)
  if valid_28376188 != nil:
    section.add "org", valid_28376188
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376189 = header.getOrDefault("Accept")
  valid_28376189 = validateParameter(valid_28376189, JString, required = false,
                                   default = nil)
  if valid_28376189 != nil:
    section.add "Accept", valid_28376189
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376190: Call_GetOrgsOrg_28376185; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get an Organization.
  ## 
  let valid = call_28376190.validator(path, query, header, formData, body)
  let scheme = call_28376190.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376190.url(scheme.get, call_28376190.host, call_28376190.base,
                           call_28376190.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376190, url, valid)

proc call*(call_28376191: Call_GetOrgsOrg_28376185; org: string; Accept: string = ""): Recallable =
  ## getOrgsOrg
  ## Get an Organization.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_28376192 = newJObject()
  var header_28376193 = newJObject()
  add(header_28376193, "Accept", newJString(Accept))
  add(path_28376192, "org", newJString(org))
  result = call_28376191.call(path_28376192, nil, header_28376193, nil, nil)

var getOrgsOrg* = Call_GetOrgsOrg_28376185(name: "getOrgsOrg",
                                        meth: HttpMethod.HttpGet,
                                        host: "api.github.com",
                                        route: "/orgs/{org}",
                                        validator: validate_GetOrgsOrg_28376186,
                                        base: "/", url: url_GetOrgsOrg_28376187,
                                        schemes: {Scheme.Https})
type
  Call_PatchOrgsOrg_28376194 = ref object of OpenApiRestCall_28375350
proc url_PatchOrgsOrg_28376196(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchOrgsOrg_28376195(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Edit an Organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_28376197 = path.getOrDefault("org")
  valid_28376197 = validateParameter(valid_28376197, JString, required = true,
                                   default = nil)
  if valid_28376197 != nil:
    section.add "org", valid_28376197
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376198 = header.getOrDefault("Accept")
  valid_28376198 = validateParameter(valid_28376198, JString, required = false,
                                   default = nil)
  if valid_28376198 != nil:
    section.add "Accept", valid_28376198
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28376200: Call_PatchOrgsOrg_28376194; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Edit an Organization.
  ## 
  let valid = call_28376200.validator(path, query, header, formData, body)
  let scheme = call_28376200.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376200.url(scheme.get, call_28376200.host, call_28376200.base,
                           call_28376200.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376200, url, valid)

proc call*(call_28376201: Call_PatchOrgsOrg_28376194; body: JsonNode; org: string;
          Accept: string = ""): Recallable =
  ## patchOrgsOrg
  ## Edit an Organization.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   org: string (required)
  ##      : Name of organisation.
  var path_28376202 = newJObject()
  var header_28376203 = newJObject()
  var body_28376204 = newJObject()
  add(header_28376203, "Accept", newJString(Accept))
  if body != nil:
    body_28376204 = body
  add(path_28376202, "org", newJString(org))
  result = call_28376201.call(path_28376202, nil, header_28376203, nil, body_28376204)

var patchOrgsOrg* = Call_PatchOrgsOrg_28376194(name: "patchOrgsOrg",
    meth: HttpMethod.HttpPatch, host: "api.github.com", route: "/orgs/{org}",
    validator: validate_PatchOrgsOrg_28376195, base: "/", url: url_PatchOrgsOrg_28376196,
    schemes: {Scheme.Https})
type
  Call_GetOrgsOrgEvents_28376205 = ref object of OpenApiRestCall_28375350
proc url_GetOrgsOrgEvents_28376207(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgEvents_28376206(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## List public events for an organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_28376208 = path.getOrDefault("org")
  valid_28376208 = validateParameter(valid_28376208, JString, required = true,
                                   default = nil)
  if valid_28376208 != nil:
    section.add "org", valid_28376208
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376209 = header.getOrDefault("Accept")
  valid_28376209 = validateParameter(valid_28376209, JString, required = false,
                                   default = nil)
  if valid_28376209 != nil:
    section.add "Accept", valid_28376209
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376210: Call_GetOrgsOrgEvents_28376205; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List public events for an organization.
  ## 
  let valid = call_28376210.validator(path, query, header, formData, body)
  let scheme = call_28376210.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376210.url(scheme.get, call_28376210.host, call_28376210.base,
                           call_28376210.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376210, url, valid)

proc call*(call_28376211: Call_GetOrgsOrgEvents_28376205; org: string;
          Accept: string = ""): Recallable =
  ## getOrgsOrgEvents
  ## List public events for an organization.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_28376212 = newJObject()
  var header_28376213 = newJObject()
  add(header_28376213, "Accept", newJString(Accept))
  add(path_28376212, "org", newJString(org))
  result = call_28376211.call(path_28376212, nil, header_28376213, nil, nil)

var getOrgsOrgEvents* = Call_GetOrgsOrgEvents_28376205(name: "getOrgsOrgEvents",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/events",
    validator: validate_GetOrgsOrgEvents_28376206, base: "/",
    url: url_GetOrgsOrgEvents_28376207, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgIssues_28376214 = ref object of OpenApiRestCall_28375350
proc url_GetOrgsOrgIssues_28376216(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/issues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgIssues_28376215(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## List issues.
  ## List all issues for a given organization for the authenticated user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_28376217 = path.getOrDefault("org")
  valid_28376217 = validateParameter(valid_28376217, JString, required = true,
                                   default = nil)
  if valid_28376217 != nil:
    section.add "org", valid_28376217
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString (required)
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: JString (required)
  ##   direction: JString (required)
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_28376218 = query.getOrDefault("state")
  valid_28376218 = validateParameter(valid_28376218, JString, required = true,
                                   default = newJString("open"))
  if valid_28376218 != nil:
    section.add "state", valid_28376218
  var valid_28376219 = query.getOrDefault("labels")
  valid_28376219 = validateParameter(valid_28376219, JString, required = true,
                                   default = nil)
  if valid_28376219 != nil:
    section.add "labels", valid_28376219
  var valid_28376220 = query.getOrDefault("sort")
  valid_28376220 = validateParameter(valid_28376220, JString, required = true,
                                   default = newJString("created"))
  if valid_28376220 != nil:
    section.add "sort", valid_28376220
  var valid_28376221 = query.getOrDefault("direction")
  valid_28376221 = validateParameter(valid_28376221, JString, required = true,
                                   default = newJString("desc"))
  if valid_28376221 != nil:
    section.add "direction", valid_28376221
  var valid_28376222 = query.getOrDefault("filter")
  valid_28376222 = validateParameter(valid_28376222, JString, required = true,
                                   default = newJString("all"))
  if valid_28376222 != nil:
    section.add "filter", valid_28376222
  var valid_28376223 = query.getOrDefault("since")
  valid_28376223 = validateParameter(valid_28376223, JString, required = false,
                                   default = nil)
  if valid_28376223 != nil:
    section.add "since", valid_28376223
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376224 = header.getOrDefault("Accept")
  valid_28376224 = validateParameter(valid_28376224, JString, required = false,
                                   default = nil)
  if valid_28376224 != nil:
    section.add "Accept", valid_28376224
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376225: Call_GetOrgsOrgIssues_28376214; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List issues.
  ## List all issues for a given organization for the authenticated user.
  ## 
  ## 
  let valid = call_28376225.validator(path, query, header, formData, body)
  let scheme = call_28376225.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376225.url(scheme.get, call_28376225.host, call_28376225.base,
                           call_28376225.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376225, url, valid)

proc call*(call_28376226: Call_GetOrgsOrgIssues_28376214; labels: string;
          org: string; state: string = "open"; Accept: string = "";
          sort: string = "created"; direction: string = "desc"; filter: string = "all";
          since: string = ""): Recallable =
  ## getOrgsOrgIssues
  ## List issues.
  ## List all issues for a given organization for the authenticated user.
  ## 
  ##   state: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: string (required)
  ##   direction: string (required)
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   org: string (required)
  ##      : Name of organisation.
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  var path_28376227 = newJObject()
  var query_28376228 = newJObject()
  var header_28376229 = newJObject()
  add(query_28376228, "state", newJString(state))
  add(header_28376229, "Accept", newJString(Accept))
  add(query_28376228, "labels", newJString(labels))
  add(query_28376228, "sort", newJString(sort))
  add(query_28376228, "direction", newJString(direction))
  add(query_28376228, "filter", newJString(filter))
  add(path_28376227, "org", newJString(org))
  add(query_28376228, "since", newJString(since))
  result = call_28376226.call(path_28376227, query_28376228, header_28376229, nil, nil)

var getOrgsOrgIssues* = Call_GetOrgsOrgIssues_28376214(name: "getOrgsOrgIssues",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/issues",
    validator: validate_GetOrgsOrgIssues_28376215, base: "/",
    url: url_GetOrgsOrgIssues_28376216, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgMembers_28376230 = ref object of OpenApiRestCall_28375350
proc url_GetOrgsOrgMembers_28376232(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/members")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgMembers_28376231(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Members list.
  ## List all users who are members of an organization. A member is a user tha
  ## belongs to at least 1 team in the organization. If the authenticated user
  ## is also an owner of this organization then both concealed and public members
  ## will be returned. If the requester is not an owner of the organization the
  ## query will be redirected to the public members list.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_28376233 = path.getOrDefault("org")
  valid_28376233 = validateParameter(valid_28376233, JString, required = true,
                                   default = nil)
  if valid_28376233 != nil:
    section.add "org", valid_28376233
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376234 = header.getOrDefault("Accept")
  valid_28376234 = validateParameter(valid_28376234, JString, required = false,
                                   default = nil)
  if valid_28376234 != nil:
    section.add "Accept", valid_28376234
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376235: Call_GetOrgsOrgMembers_28376230; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Members list.
  ## List all users who are members of an organization. A member is a user tha
  ## belongs to at least 1 team in the organization. If the authenticated user
  ## is also an owner of this organization then both concealed and public members
  ## will be returned. If the requester is not an owner of the organization the
  ## query will be redirected to the public members list.
  ## 
  ## 
  let valid = call_28376235.validator(path, query, header, formData, body)
  let scheme = call_28376235.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376235.url(scheme.get, call_28376235.host, call_28376235.base,
                           call_28376235.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376235, url, valid)

proc call*(call_28376236: Call_GetOrgsOrgMembers_28376230; org: string;
          Accept: string = ""): Recallable =
  ## getOrgsOrgMembers
  ## Members list.
  ## List all users who are members of an organization. A member is a user tha
  ## belongs to at least 1 team in the organization. If the authenticated user
  ## is also an owner of this organization then both concealed and public members
  ## will be returned. If the requester is not an owner of the organization the
  ## query will be redirected to the public members list.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_28376237 = newJObject()
  var header_28376238 = newJObject()
  add(header_28376238, "Accept", newJString(Accept))
  add(path_28376237, "org", newJString(org))
  result = call_28376236.call(path_28376237, nil, header_28376238, nil, nil)

var getOrgsOrgMembers* = Call_GetOrgsOrgMembers_28376230(name: "getOrgsOrgMembers",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/members",
    validator: validate_GetOrgsOrgMembers_28376231, base: "/",
    url: url_GetOrgsOrgMembers_28376232, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgMembersUsername_28376239 = ref object of OpenApiRestCall_28375350
proc url_GetOrgsOrgMembersUsername_28376241(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgMembersUsername_28376240(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Check if a user is, publicly or privately, a member of the organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of the user.
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_28376242 = path.getOrDefault("username")
  valid_28376242 = validateParameter(valid_28376242, JString, required = true,
                                   default = nil)
  if valid_28376242 != nil:
    section.add "username", valid_28376242
  var valid_28376243 = path.getOrDefault("org")
  valid_28376243 = validateParameter(valid_28376243, JString, required = true,
                                   default = nil)
  if valid_28376243 != nil:
    section.add "org", valid_28376243
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376244 = header.getOrDefault("Accept")
  valid_28376244 = validateParameter(valid_28376244, JString, required = false,
                                   default = nil)
  if valid_28376244 != nil:
    section.add "Accept", valid_28376244
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376245: Call_GetOrgsOrgMembersUsername_28376239; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Check if a user is, publicly or privately, a member of the organization.
  ## 
  let valid = call_28376245.validator(path, query, header, formData, body)
  let scheme = call_28376245.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376245.url(scheme.get, call_28376245.host, call_28376245.base,
                           call_28376245.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376245, url, valid)

proc call*(call_28376246: Call_GetOrgsOrgMembersUsername_28376239;
          username: string; org: string; Accept: string = ""): Recallable =
  ## getOrgsOrgMembersUsername
  ## Check if a user is, publicly or privately, a member of the organization.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_28376247 = newJObject()
  var header_28376248 = newJObject()
  add(path_28376247, "username", newJString(username))
  add(header_28376248, "Accept", newJString(Accept))
  add(path_28376247, "org", newJString(org))
  result = call_28376246.call(path_28376247, nil, header_28376248, nil, nil)

var getOrgsOrgMembersUsername* = Call_GetOrgsOrgMembersUsername_28376239(
    name: "getOrgsOrgMembersUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/orgs/{org}/members/{username}",
    validator: validate_GetOrgsOrgMembersUsername_28376240, base: "/",
    url: url_GetOrgsOrgMembersUsername_28376241, schemes: {Scheme.Https})
type
  Call_DeleteOrgsOrgMembersUsername_28376249 = ref object of OpenApiRestCall_28375350
proc url_DeleteOrgsOrgMembersUsername_28376251(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteOrgsOrgMembersUsername_28376250(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Remove a member.
  ## Removing a user from this list will remove them from all teams and they
  ## will no longer have any access to the organization's repositories.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of the user.
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_28376252 = path.getOrDefault("username")
  valid_28376252 = validateParameter(valid_28376252, JString, required = true,
                                   default = nil)
  if valid_28376252 != nil:
    section.add "username", valid_28376252
  var valid_28376253 = path.getOrDefault("org")
  valid_28376253 = validateParameter(valid_28376253, JString, required = true,
                                   default = nil)
  if valid_28376253 != nil:
    section.add "org", valid_28376253
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376254 = header.getOrDefault("Accept")
  valid_28376254 = validateParameter(valid_28376254, JString, required = false,
                                   default = nil)
  if valid_28376254 != nil:
    section.add "Accept", valid_28376254
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376255: Call_DeleteOrgsOrgMembersUsername_28376249;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Remove a member.
  ## Removing a user from this list will remove them from all teams and they
  ## will no longer have any access to the organization's repositories.
  ## 
  ## 
  let valid = call_28376255.validator(path, query, header, formData, body)
  let scheme = call_28376255.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376255.url(scheme.get, call_28376255.host, call_28376255.base,
                           call_28376255.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376255, url, valid)

proc call*(call_28376256: Call_DeleteOrgsOrgMembersUsername_28376249;
          username: string; org: string; Accept: string = ""): Recallable =
  ## deleteOrgsOrgMembersUsername
  ## Remove a member.
  ## Removing a user from this list will remove them from all teams and they
  ## will no longer have any access to the organization's repositories.
  ## 
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_28376257 = newJObject()
  var header_28376258 = newJObject()
  add(path_28376257, "username", newJString(username))
  add(header_28376258, "Accept", newJString(Accept))
  add(path_28376257, "org", newJString(org))
  result = call_28376256.call(path_28376257, nil, header_28376258, nil, nil)

var deleteOrgsOrgMembersUsername* = Call_DeleteOrgsOrgMembersUsername_28376249(
    name: "deleteOrgsOrgMembersUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/orgs/{org}/members/{username}",
    validator: validate_DeleteOrgsOrgMembersUsername_28376250, base: "/",
    url: url_DeleteOrgsOrgMembersUsername_28376251, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgPublicMembers_28376259 = ref object of OpenApiRestCall_28375350
proc url_GetOrgsOrgPublicMembers_28376261(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/public_members")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgPublicMembers_28376260(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Public members list.
  ## Members of an organization can choose to have their membership publicized
  ## or not.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_28376262 = path.getOrDefault("org")
  valid_28376262 = validateParameter(valid_28376262, JString, required = true,
                                   default = nil)
  if valid_28376262 != nil:
    section.add "org", valid_28376262
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376263 = header.getOrDefault("Accept")
  valid_28376263 = validateParameter(valid_28376263, JString, required = false,
                                   default = nil)
  if valid_28376263 != nil:
    section.add "Accept", valid_28376263
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376264: Call_GetOrgsOrgPublicMembers_28376259; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Public members list.
  ## Members of an organization can choose to have their membership publicized
  ## or not.
  ## 
  ## 
  let valid = call_28376264.validator(path, query, header, formData, body)
  let scheme = call_28376264.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376264.url(scheme.get, call_28376264.host, call_28376264.base,
                           call_28376264.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376264, url, valid)

proc call*(call_28376265: Call_GetOrgsOrgPublicMembers_28376259; org: string;
          Accept: string = ""): Recallable =
  ## getOrgsOrgPublicMembers
  ## Public members list.
  ## Members of an organization can choose to have their membership publicized
  ## or not.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_28376266 = newJObject()
  var header_28376267 = newJObject()
  add(header_28376267, "Accept", newJString(Accept))
  add(path_28376266, "org", newJString(org))
  result = call_28376265.call(path_28376266, nil, header_28376267, nil, nil)

var getOrgsOrgPublicMembers* = Call_GetOrgsOrgPublicMembers_28376259(
    name: "getOrgsOrgPublicMembers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/orgs/{org}/public_members",
    validator: validate_GetOrgsOrgPublicMembers_28376260, base: "/",
    url: url_GetOrgsOrgPublicMembers_28376261, schemes: {Scheme.Https})
type
  Call_PutOrgsOrgPublicMembersUsername_28376278 = ref object of OpenApiRestCall_28375350
proc url_PutOrgsOrgPublicMembersUsername_28376280(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/public_members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutOrgsOrgPublicMembersUsername_28376279(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Publicize a user's membership.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of the user.
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_28376281 = path.getOrDefault("username")
  valid_28376281 = validateParameter(valid_28376281, JString, required = true,
                                   default = nil)
  if valid_28376281 != nil:
    section.add "username", valid_28376281
  var valid_28376282 = path.getOrDefault("org")
  valid_28376282 = validateParameter(valid_28376282, JString, required = true,
                                   default = nil)
  if valid_28376282 != nil:
    section.add "org", valid_28376282
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376283 = header.getOrDefault("Accept")
  valid_28376283 = validateParameter(valid_28376283, JString, required = false,
                                   default = nil)
  if valid_28376283 != nil:
    section.add "Accept", valid_28376283
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376284: Call_PutOrgsOrgPublicMembersUsername_28376278;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Publicize a user's membership.
  ## 
  let valid = call_28376284.validator(path, query, header, formData, body)
  let scheme = call_28376284.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376284.url(scheme.get, call_28376284.host, call_28376284.base,
                           call_28376284.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376284, url, valid)

proc call*(call_28376285: Call_PutOrgsOrgPublicMembersUsername_28376278;
          username: string; org: string; Accept: string = ""): Recallable =
  ## putOrgsOrgPublicMembersUsername
  ## Publicize a user's membership.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_28376286 = newJObject()
  var header_28376287 = newJObject()
  add(path_28376286, "username", newJString(username))
  add(header_28376287, "Accept", newJString(Accept))
  add(path_28376286, "org", newJString(org))
  result = call_28376285.call(path_28376286, nil, header_28376287, nil, nil)

var putOrgsOrgPublicMembersUsername* = Call_PutOrgsOrgPublicMembersUsername_28376278(
    name: "putOrgsOrgPublicMembersUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/orgs/{org}/public_members/{username}",
    validator: validate_PutOrgsOrgPublicMembersUsername_28376279, base: "/",
    url: url_PutOrgsOrgPublicMembersUsername_28376280, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgPublicMembersUsername_28376268 = ref object of OpenApiRestCall_28375350
proc url_GetOrgsOrgPublicMembersUsername_28376270(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/public_members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgPublicMembersUsername_28376269(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Check public membership.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of the user.
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_28376271 = path.getOrDefault("username")
  valid_28376271 = validateParameter(valid_28376271, JString, required = true,
                                   default = nil)
  if valid_28376271 != nil:
    section.add "username", valid_28376271
  var valid_28376272 = path.getOrDefault("org")
  valid_28376272 = validateParameter(valid_28376272, JString, required = true,
                                   default = nil)
  if valid_28376272 != nil:
    section.add "org", valid_28376272
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376273 = header.getOrDefault("Accept")
  valid_28376273 = validateParameter(valid_28376273, JString, required = false,
                                   default = nil)
  if valid_28376273 != nil:
    section.add "Accept", valid_28376273
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376274: Call_GetOrgsOrgPublicMembersUsername_28376268;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Check public membership.
  ## 
  let valid = call_28376274.validator(path, query, header, formData, body)
  let scheme = call_28376274.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376274.url(scheme.get, call_28376274.host, call_28376274.base,
                           call_28376274.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376274, url, valid)

proc call*(call_28376275: Call_GetOrgsOrgPublicMembersUsername_28376268;
          username: string; org: string; Accept: string = ""): Recallable =
  ## getOrgsOrgPublicMembersUsername
  ## Check public membership.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_28376276 = newJObject()
  var header_28376277 = newJObject()
  add(path_28376276, "username", newJString(username))
  add(header_28376277, "Accept", newJString(Accept))
  add(path_28376276, "org", newJString(org))
  result = call_28376275.call(path_28376276, nil, header_28376277, nil, nil)

var getOrgsOrgPublicMembersUsername* = Call_GetOrgsOrgPublicMembersUsername_28376268(
    name: "getOrgsOrgPublicMembersUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/orgs/{org}/public_members/{username}",
    validator: validate_GetOrgsOrgPublicMembersUsername_28376269, base: "/",
    url: url_GetOrgsOrgPublicMembersUsername_28376270, schemes: {Scheme.Https})
type
  Call_DeleteOrgsOrgPublicMembersUsername_28376288 = ref object of OpenApiRestCall_28375350
proc url_DeleteOrgsOrgPublicMembersUsername_28376290(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/public_members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteOrgsOrgPublicMembersUsername_28376289(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Conceal a user's membership.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of the user.
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_28376291 = path.getOrDefault("username")
  valid_28376291 = validateParameter(valid_28376291, JString, required = true,
                                   default = nil)
  if valid_28376291 != nil:
    section.add "username", valid_28376291
  var valid_28376292 = path.getOrDefault("org")
  valid_28376292 = validateParameter(valid_28376292, JString, required = true,
                                   default = nil)
  if valid_28376292 != nil:
    section.add "org", valid_28376292
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376293 = header.getOrDefault("Accept")
  valid_28376293 = validateParameter(valid_28376293, JString, required = false,
                                   default = nil)
  if valid_28376293 != nil:
    section.add "Accept", valid_28376293
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376294: Call_DeleteOrgsOrgPublicMembersUsername_28376288;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Conceal a user's membership.
  ## 
  let valid = call_28376294.validator(path, query, header, formData, body)
  let scheme = call_28376294.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376294.url(scheme.get, call_28376294.host, call_28376294.base,
                           call_28376294.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376294, url, valid)

proc call*(call_28376295: Call_DeleteOrgsOrgPublicMembersUsername_28376288;
          username: string; org: string; Accept: string = ""): Recallable =
  ## deleteOrgsOrgPublicMembersUsername
  ## Conceal a user's membership.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_28376296 = newJObject()
  var header_28376297 = newJObject()
  add(path_28376296, "username", newJString(username))
  add(header_28376297, "Accept", newJString(Accept))
  add(path_28376296, "org", newJString(org))
  result = call_28376295.call(path_28376296, nil, header_28376297, nil, nil)

var deleteOrgsOrgPublicMembersUsername* = Call_DeleteOrgsOrgPublicMembersUsername_28376288(
    name: "deleteOrgsOrgPublicMembersUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/orgs/{org}/public_members/{username}",
    validator: validate_DeleteOrgsOrgPublicMembersUsername_28376289, base: "/",
    url: url_DeleteOrgsOrgPublicMembersUsername_28376290, schemes: {Scheme.Https})
type
  Call_PostOrgsOrgRepos_28376309 = ref object of OpenApiRestCall_28375350
proc url_PostOrgsOrgRepos_28376311(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostOrgsOrgRepos_28376310(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_28376312 = path.getOrDefault("org")
  valid_28376312 = validateParameter(valid_28376312, JString, required = true,
                                   default = nil)
  if valid_28376312 != nil:
    section.add "org", valid_28376312
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376313 = header.getOrDefault("Accept")
  valid_28376313 = validateParameter(valid_28376313, JString, required = false,
                                   default = nil)
  if valid_28376313 != nil:
    section.add "Accept", valid_28376313
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28376315: Call_PostOrgsOrgRepos_28376309; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  let valid = call_28376315.validator(path, query, header, formData, body)
  let scheme = call_28376315.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376315.url(scheme.get, call_28376315.host, call_28376315.base,
                           call_28376315.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376315, url, valid)

proc call*(call_28376316: Call_PostOrgsOrgRepos_28376309; body: JsonNode;
          org: string; Accept: string = ""): Recallable =
  ## postOrgsOrgRepos
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   org: string (required)
  ##      : Name of organisation.
  var path_28376317 = newJObject()
  var header_28376318 = newJObject()
  var body_28376319 = newJObject()
  add(header_28376318, "Accept", newJString(Accept))
  if body != nil:
    body_28376319 = body
  add(path_28376317, "org", newJString(org))
  result = call_28376316.call(path_28376317, nil, header_28376318, nil, body_28376319)

var postOrgsOrgRepos* = Call_PostOrgsOrgRepos_28376309(name: "postOrgsOrgRepos",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/orgs/{org}/repos",
    validator: validate_PostOrgsOrgRepos_28376310, base: "/",
    url: url_PostOrgsOrgRepos_28376311, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgRepos_28376298 = ref object of OpenApiRestCall_28375350
proc url_GetOrgsOrgRepos_28376300(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgRepos_28376299(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## List repositories for the specified org.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_28376301 = path.getOrDefault("org")
  valid_28376301 = validateParameter(valid_28376301, JString, required = true,
                                   default = nil)
  if valid_28376301 != nil:
    section.add "org", valid_28376301
  result.add "path", section
  ## parameters in `query` object:
  ##   type: JString
  section = newJObject()
  var valid_28376302 = query.getOrDefault("type")
  valid_28376302 = validateParameter(valid_28376302, JString, required = false,
                                   default = newJString("all"))
  if valid_28376302 != nil:
    section.add "type", valid_28376302
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376303 = header.getOrDefault("Accept")
  valid_28376303 = validateParameter(valid_28376303, JString, required = false,
                                   default = nil)
  if valid_28376303 != nil:
    section.add "Accept", valid_28376303
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376304: Call_GetOrgsOrgRepos_28376298; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List repositories for the specified org.
  ## 
  let valid = call_28376304.validator(path, query, header, formData, body)
  let scheme = call_28376304.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376304.url(scheme.get, call_28376304.host, call_28376304.base,
                           call_28376304.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376304, url, valid)

proc call*(call_28376305: Call_GetOrgsOrgRepos_28376298; org: string;
          Accept: string = ""; `type`: string = "all"): Recallable =
  ## getOrgsOrgRepos
  ## List repositories for the specified org.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   type: string
  ##   org: string (required)
  ##      : Name of organisation.
  var path_28376306 = newJObject()
  var query_28376307 = newJObject()
  var header_28376308 = newJObject()
  add(header_28376308, "Accept", newJString(Accept))
  add(query_28376307, "type", newJString(`type`))
  add(path_28376306, "org", newJString(org))
  result = call_28376305.call(path_28376306, query_28376307, header_28376308, nil, nil)

var getOrgsOrgRepos* = Call_GetOrgsOrgRepos_28376298(name: "getOrgsOrgRepos",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/repos",
    validator: validate_GetOrgsOrgRepos_28376299, base: "/",
    url: url_GetOrgsOrgRepos_28376300, schemes: {Scheme.Https})
type
  Call_PostOrgsOrgTeams_28376329 = ref object of OpenApiRestCall_28375350
proc url_PostOrgsOrgTeams_28376331(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/teams")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostOrgsOrgTeams_28376330(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Create team.
  ## In order to create a team, the authenticated user must be an owner of organization.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_28376332 = path.getOrDefault("org")
  valid_28376332 = validateParameter(valid_28376332, JString, required = true,
                                   default = nil)
  if valid_28376332 != nil:
    section.add "org", valid_28376332
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376333 = header.getOrDefault("Accept")
  valid_28376333 = validateParameter(valid_28376333, JString, required = false,
                                   default = nil)
  if valid_28376333 != nil:
    section.add "Accept", valid_28376333
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28376335: Call_PostOrgsOrgTeams_28376329; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create team.
  ## In order to create a team, the authenticated user must be an owner of organization.
  ## 
  ## 
  let valid = call_28376335.validator(path, query, header, formData, body)
  let scheme = call_28376335.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376335.url(scheme.get, call_28376335.host, call_28376335.base,
                           call_28376335.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376335, url, valid)

proc call*(call_28376336: Call_PostOrgsOrgTeams_28376329; body: JsonNode;
          org: string; Accept: string = ""): Recallable =
  ## postOrgsOrgTeams
  ## Create team.
  ## In order to create a team, the authenticated user must be an owner of organization.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   org: string (required)
  ##      : Name of organisation.
  var path_28376337 = newJObject()
  var header_28376338 = newJObject()
  var body_28376339 = newJObject()
  add(header_28376338, "Accept", newJString(Accept))
  if body != nil:
    body_28376339 = body
  add(path_28376337, "org", newJString(org))
  result = call_28376336.call(path_28376337, nil, header_28376338, nil, body_28376339)

var postOrgsOrgTeams* = Call_PostOrgsOrgTeams_28376329(name: "postOrgsOrgTeams",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/orgs/{org}/teams",
    validator: validate_PostOrgsOrgTeams_28376330, base: "/",
    url: url_PostOrgsOrgTeams_28376331, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgTeams_28376320 = ref object of OpenApiRestCall_28375350
proc url_GetOrgsOrgTeams_28376322(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/teams")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgTeams_28376321(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## List teams.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_28376323 = path.getOrDefault("org")
  valid_28376323 = validateParameter(valid_28376323, JString, required = true,
                                   default = nil)
  if valid_28376323 != nil:
    section.add "org", valid_28376323
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376324 = header.getOrDefault("Accept")
  valid_28376324 = validateParameter(valid_28376324, JString, required = false,
                                   default = nil)
  if valid_28376324 != nil:
    section.add "Accept", valid_28376324
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376325: Call_GetOrgsOrgTeams_28376320; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List teams.
  ## 
  let valid = call_28376325.validator(path, query, header, formData, body)
  let scheme = call_28376325.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376325.url(scheme.get, call_28376325.host, call_28376325.base,
                           call_28376325.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376325, url, valid)

proc call*(call_28376326: Call_GetOrgsOrgTeams_28376320; org: string;
          Accept: string = ""): Recallable =
  ## getOrgsOrgTeams
  ## List teams.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_28376327 = newJObject()
  var header_28376328 = newJObject()
  add(header_28376328, "Accept", newJString(Accept))
  add(path_28376327, "org", newJString(org))
  result = call_28376326.call(path_28376327, nil, header_28376328, nil, nil)

var getOrgsOrgTeams* = Call_GetOrgsOrgTeams_28376320(name: "getOrgsOrgTeams",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/teams",
    validator: validate_GetOrgsOrgTeams_28376321, base: "/",
    url: url_GetOrgsOrgTeams_28376322, schemes: {Scheme.Https})
type
  Call_GetRateLimit_28376340 = ref object of OpenApiRestCall_28375350
proc url_GetRateLimit_28376342(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRateLimit_28376341(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Get your current rate limit status
  ## Note: Accessing this endpoint does not count against your rate limit.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376343 = header.getOrDefault("Accept")
  valid_28376343 = validateParameter(valid_28376343, JString, required = false,
                                   default = nil)
  if valid_28376343 != nil:
    section.add "Accept", valid_28376343
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376344: Call_GetRateLimit_28376340; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get your current rate limit status
  ## Note: Accessing this endpoint does not count against your rate limit.
  ## 
  ## 
  let valid = call_28376344.validator(path, query, header, formData, body)
  let scheme = call_28376344.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376344.url(scheme.get, call_28376344.host, call_28376344.base,
                           call_28376344.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376344, url, valid)

proc call*(call_28376345: Call_GetRateLimit_28376340; Accept: string = ""): Recallable =
  ## getRateLimit
  ## Get your current rate limit status
  ## Note: Accessing this endpoint does not count against your rate limit.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_28376346 = newJObject()
  add(header_28376346, "Accept", newJString(Accept))
  result = call_28376345.call(nil, nil, header_28376346, nil, nil)

var getRateLimit* = Call_GetRateLimit_28376340(name: "getRateLimit",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/rate_limit",
    validator: validate_GetRateLimit_28376341, base: "/", url: url_GetRateLimit_28376342,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepo_28376347 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepo_28376349(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepo_28376348(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Get repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376350 = path.getOrDefault("owner")
  valid_28376350 = validateParameter(valid_28376350, JString, required = true,
                                   default = nil)
  if valid_28376350 != nil:
    section.add "owner", valid_28376350
  var valid_28376351 = path.getOrDefault("repo")
  valid_28376351 = validateParameter(valid_28376351, JString, required = true,
                                   default = nil)
  if valid_28376351 != nil:
    section.add "repo", valid_28376351
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376352 = header.getOrDefault("Accept")
  valid_28376352 = validateParameter(valid_28376352, JString, required = false,
                                   default = nil)
  if valid_28376352 != nil:
    section.add "Accept", valid_28376352
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376353: Call_GetReposOwnerRepo_28376347; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get repository.
  ## 
  let valid = call_28376353.validator(path, query, header, formData, body)
  let scheme = call_28376353.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376353.url(scheme.get, call_28376353.host, call_28376353.base,
                           call_28376353.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376353, url, valid)

proc call*(call_28376354: Call_GetReposOwnerRepo_28376347; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepo
  ## Get repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376355 = newJObject()
  var header_28376356 = newJObject()
  add(path_28376355, "owner", newJString(owner))
  add(header_28376356, "Accept", newJString(Accept))
  add(path_28376355, "repo", newJString(repo))
  result = call_28376354.call(path_28376355, nil, header_28376356, nil, nil)

var getReposOwnerRepo* = Call_GetReposOwnerRepo_28376347(name: "getReposOwnerRepo",
    meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/repos/{owner}/{repo}", validator: validate_GetReposOwnerRepo_28376348,
    base: "/", url: url_GetReposOwnerRepo_28376349, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepo_28376367 = ref object of OpenApiRestCall_28375350
proc url_PatchReposOwnerRepo_28376369(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepo_28376368(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Edit repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376370 = path.getOrDefault("owner")
  valid_28376370 = validateParameter(valid_28376370, JString, required = true,
                                   default = nil)
  if valid_28376370 != nil:
    section.add "owner", valid_28376370
  var valid_28376371 = path.getOrDefault("repo")
  valid_28376371 = validateParameter(valid_28376371, JString, required = true,
                                   default = nil)
  if valid_28376371 != nil:
    section.add "repo", valid_28376371
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376372 = header.getOrDefault("Accept")
  valid_28376372 = validateParameter(valid_28376372, JString, required = false,
                                   default = nil)
  if valid_28376372 != nil:
    section.add "Accept", valid_28376372
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28376374: Call_PatchReposOwnerRepo_28376367; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Edit repository.
  ## 
  let valid = call_28376374.validator(path, query, header, formData, body)
  let scheme = call_28376374.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376374.url(scheme.get, call_28376374.host, call_28376374.base,
                           call_28376374.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376374, url, valid)

proc call*(call_28376375: Call_PatchReposOwnerRepo_28376367; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepo
  ## Edit repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376376 = newJObject()
  var header_28376377 = newJObject()
  var body_28376378 = newJObject()
  add(path_28376376, "owner", newJString(owner))
  add(header_28376377, "Accept", newJString(Accept))
  if body != nil:
    body_28376378 = body
  add(path_28376376, "repo", newJString(repo))
  result = call_28376375.call(path_28376376, nil, header_28376377, nil, body_28376378)

var patchReposOwnerRepo* = Call_PatchReposOwnerRepo_28376367(
    name: "patchReposOwnerRepo", meth: HttpMethod.HttpPatch, host: "api.github.com",
    route: "/repos/{owner}/{repo}", validator: validate_PatchReposOwnerRepo_28376368,
    base: "/", url: url_PatchReposOwnerRepo_28376369, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepo_28376357 = ref object of OpenApiRestCall_28375350
proc url_DeleteReposOwnerRepo_28376359(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepo_28376358(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a Repository.
  ## Deleting a repository requires admin access. If OAuth is used, the delete_repo
  ## scope is required.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376360 = path.getOrDefault("owner")
  valid_28376360 = validateParameter(valid_28376360, JString, required = true,
                                   default = nil)
  if valid_28376360 != nil:
    section.add "owner", valid_28376360
  var valid_28376361 = path.getOrDefault("repo")
  valid_28376361 = validateParameter(valid_28376361, JString, required = true,
                                   default = nil)
  if valid_28376361 != nil:
    section.add "repo", valid_28376361
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376362 = header.getOrDefault("Accept")
  valid_28376362 = validateParameter(valid_28376362, JString, required = false,
                                   default = nil)
  if valid_28376362 != nil:
    section.add "Accept", valid_28376362
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376363: Call_DeleteReposOwnerRepo_28376357; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete a Repository.
  ## Deleting a repository requires admin access. If OAuth is used, the delete_repo
  ## scope is required.
  ## 
  ## 
  let valid = call_28376363.validator(path, query, header, formData, body)
  let scheme = call_28376363.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376363.url(scheme.get, call_28376363.host, call_28376363.base,
                           call_28376363.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376363, url, valid)

proc call*(call_28376364: Call_DeleteReposOwnerRepo_28376357; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepo
  ## Delete a Repository.
  ## Deleting a repository requires admin access. If OAuth is used, the delete_repo
  ## scope is required.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376365 = newJObject()
  var header_28376366 = newJObject()
  add(path_28376365, "owner", newJString(owner))
  add(header_28376366, "Accept", newJString(Accept))
  add(path_28376365, "repo", newJString(repo))
  result = call_28376364.call(path_28376365, nil, header_28376366, nil, nil)

var deleteReposOwnerRepo* = Call_DeleteReposOwnerRepo_28376357(
    name: "deleteReposOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}",
    validator: validate_DeleteReposOwnerRepo_28376358, base: "/",
    url: url_DeleteReposOwnerRepo_28376359, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoAssignees_28376379 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoAssignees_28376381(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/assignees")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoAssignees_28376380(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List assignees.
  ## This call lists all the available assignees (owner + collaborators) to which
  ## issues may be assigned.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376382 = path.getOrDefault("owner")
  valid_28376382 = validateParameter(valid_28376382, JString, required = true,
                                   default = nil)
  if valid_28376382 != nil:
    section.add "owner", valid_28376382
  var valid_28376383 = path.getOrDefault("repo")
  valid_28376383 = validateParameter(valid_28376383, JString, required = true,
                                   default = nil)
  if valid_28376383 != nil:
    section.add "repo", valid_28376383
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376384 = header.getOrDefault("Accept")
  valid_28376384 = validateParameter(valid_28376384, JString, required = false,
                                   default = nil)
  if valid_28376384 != nil:
    section.add "Accept", valid_28376384
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376385: Call_GetReposOwnerRepoAssignees_28376379; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List assignees.
  ## This call lists all the available assignees (owner + collaborators) to which
  ## issues may be assigned.
  ## 
  ## 
  let valid = call_28376385.validator(path, query, header, formData, body)
  let scheme = call_28376385.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376385.url(scheme.get, call_28376385.host, call_28376385.base,
                           call_28376385.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376385, url, valid)

proc call*(call_28376386: Call_GetReposOwnerRepoAssignees_28376379; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoAssignees
  ## List assignees.
  ## This call lists all the available assignees (owner + collaborators) to which
  ## issues may be assigned.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376387 = newJObject()
  var header_28376388 = newJObject()
  add(path_28376387, "owner", newJString(owner))
  add(header_28376388, "Accept", newJString(Accept))
  add(path_28376387, "repo", newJString(repo))
  result = call_28376386.call(path_28376387, nil, header_28376388, nil, nil)

var getReposOwnerRepoAssignees* = Call_GetReposOwnerRepoAssignees_28376379(
    name: "getReposOwnerRepoAssignees", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/assignees",
    validator: validate_GetReposOwnerRepoAssignees_28376380, base: "/",
    url: url_GetReposOwnerRepoAssignees_28376381, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoAssigneesAssignee_28376389 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoAssigneesAssignee_28376391(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "assignee" in path, "`assignee` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/assignees/"),
               (kind: VariableSegment, value: "assignee")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoAssigneesAssignee_28376390(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Check assignee.
  ## You may also check to see if a particular user is an assignee for a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   assignee: JString (required)
  ##           : Login of the assignee.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376392 = path.getOrDefault("owner")
  valid_28376392 = validateParameter(valid_28376392, JString, required = true,
                                   default = nil)
  if valid_28376392 != nil:
    section.add "owner", valid_28376392
  var valid_28376393 = path.getOrDefault("assignee")
  valid_28376393 = validateParameter(valid_28376393, JString, required = true,
                                   default = nil)
  if valid_28376393 != nil:
    section.add "assignee", valid_28376393
  var valid_28376394 = path.getOrDefault("repo")
  valid_28376394 = validateParameter(valid_28376394, JString, required = true,
                                   default = nil)
  if valid_28376394 != nil:
    section.add "repo", valid_28376394
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376395 = header.getOrDefault("Accept")
  valid_28376395 = validateParameter(valid_28376395, JString, required = false,
                                   default = nil)
  if valid_28376395 != nil:
    section.add "Accept", valid_28376395
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376396: Call_GetReposOwnerRepoAssigneesAssignee_28376389;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Check assignee.
  ## You may also check to see if a particular user is an assignee for a repository.
  ## 
  ## 
  let valid = call_28376396.validator(path, query, header, formData, body)
  let scheme = call_28376396.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376396.url(scheme.get, call_28376396.host, call_28376396.base,
                           call_28376396.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376396, url, valid)

proc call*(call_28376397: Call_GetReposOwnerRepoAssigneesAssignee_28376389;
          owner: string; assignee: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoAssigneesAssignee
  ## Check assignee.
  ## You may also check to see if a particular user is an assignee for a repository.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   assignee: string (required)
  ##           : Login of the assignee.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376398 = newJObject()
  var header_28376399 = newJObject()
  add(path_28376398, "owner", newJString(owner))
  add(path_28376398, "assignee", newJString(assignee))
  add(header_28376399, "Accept", newJString(Accept))
  add(path_28376398, "repo", newJString(repo))
  result = call_28376397.call(path_28376398, nil, header_28376399, nil, nil)

var getReposOwnerRepoAssigneesAssignee* = Call_GetReposOwnerRepoAssigneesAssignee_28376389(
    name: "getReposOwnerRepoAssigneesAssignee", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/assignees/{assignee}",
    validator: validate_GetReposOwnerRepoAssigneesAssignee_28376390, base: "/",
    url: url_GetReposOwnerRepoAssigneesAssignee_28376391, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoBranches_28376400 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoBranches_28376402(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/branches")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoBranches_28376401(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get list of branches
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376403 = path.getOrDefault("owner")
  valid_28376403 = validateParameter(valid_28376403, JString, required = true,
                                   default = nil)
  if valid_28376403 != nil:
    section.add "owner", valid_28376403
  var valid_28376404 = path.getOrDefault("repo")
  valid_28376404 = validateParameter(valid_28376404, JString, required = true,
                                   default = nil)
  if valid_28376404 != nil:
    section.add "repo", valid_28376404
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376405 = header.getOrDefault("Accept")
  valid_28376405 = validateParameter(valid_28376405, JString, required = false,
                                   default = nil)
  if valid_28376405 != nil:
    section.add "Accept", valid_28376405
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376406: Call_GetReposOwnerRepoBranches_28376400; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get list of branches
  ## 
  let valid = call_28376406.validator(path, query, header, formData, body)
  let scheme = call_28376406.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376406.url(scheme.get, call_28376406.host, call_28376406.base,
                           call_28376406.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376406, url, valid)

proc call*(call_28376407: Call_GetReposOwnerRepoBranches_28376400; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoBranches
  ## Get list of branches
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376408 = newJObject()
  var header_28376409 = newJObject()
  add(path_28376408, "owner", newJString(owner))
  add(header_28376409, "Accept", newJString(Accept))
  add(path_28376408, "repo", newJString(repo))
  result = call_28376407.call(path_28376408, nil, header_28376409, nil, nil)

var getReposOwnerRepoBranches* = Call_GetReposOwnerRepoBranches_28376400(
    name: "getReposOwnerRepoBranches", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/branches",
    validator: validate_GetReposOwnerRepoBranches_28376401, base: "/",
    url: url_GetReposOwnerRepoBranches_28376402, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoBranchesBranch_28376410 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoBranchesBranch_28376412(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "branch" in path, "`branch` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/branches/"),
               (kind: VariableSegment, value: "branch")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoBranchesBranch_28376411(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get Branch
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   branch: JString (required)
  ##         : Name of the branch.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376413 = path.getOrDefault("owner")
  valid_28376413 = validateParameter(valid_28376413, JString, required = true,
                                   default = nil)
  if valid_28376413 != nil:
    section.add "owner", valid_28376413
  var valid_28376414 = path.getOrDefault("branch")
  valid_28376414 = validateParameter(valid_28376414, JString, required = true,
                                   default = nil)
  if valid_28376414 != nil:
    section.add "branch", valid_28376414
  var valid_28376415 = path.getOrDefault("repo")
  valid_28376415 = validateParameter(valid_28376415, JString, required = true,
                                   default = nil)
  if valid_28376415 != nil:
    section.add "repo", valid_28376415
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376416 = header.getOrDefault("Accept")
  valid_28376416 = validateParameter(valid_28376416, JString, required = false,
                                   default = nil)
  if valid_28376416 != nil:
    section.add "Accept", valid_28376416
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376417: Call_GetReposOwnerRepoBranchesBranch_28376410;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get Branch
  ## 
  let valid = call_28376417.validator(path, query, header, formData, body)
  let scheme = call_28376417.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376417.url(scheme.get, call_28376417.host, call_28376417.base,
                           call_28376417.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376417, url, valid)

proc call*(call_28376418: Call_GetReposOwnerRepoBranchesBranch_28376410;
          owner: string; branch: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoBranchesBranch
  ## Get Branch
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   branch: string (required)
  ##         : Name of the branch.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376419 = newJObject()
  var header_28376420 = newJObject()
  add(path_28376419, "owner", newJString(owner))
  add(path_28376419, "branch", newJString(branch))
  add(header_28376420, "Accept", newJString(Accept))
  add(path_28376419, "repo", newJString(repo))
  result = call_28376418.call(path_28376419, nil, header_28376420, nil, nil)

var getReposOwnerRepoBranchesBranch* = Call_GetReposOwnerRepoBranchesBranch_28376410(
    name: "getReposOwnerRepoBranchesBranch", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/branches/{branch}",
    validator: validate_GetReposOwnerRepoBranchesBranch_28376411, base: "/",
    url: url_GetReposOwnerRepoBranchesBranch_28376412, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCollaborators_28376421 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoCollaborators_28376423(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/collaborators")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCollaborators_28376422(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List.
  ## When authenticating as an organization owner of an organization-owned
  ## repository, all organization owners are included in the list of
  ## collaborators. Otherwise, only users with access to the repository are
  ## returned in the collaborators list.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376424 = path.getOrDefault("owner")
  valid_28376424 = validateParameter(valid_28376424, JString, required = true,
                                   default = nil)
  if valid_28376424 != nil:
    section.add "owner", valid_28376424
  var valid_28376425 = path.getOrDefault("repo")
  valid_28376425 = validateParameter(valid_28376425, JString, required = true,
                                   default = nil)
  if valid_28376425 != nil:
    section.add "repo", valid_28376425
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376426 = header.getOrDefault("Accept")
  valid_28376426 = validateParameter(valid_28376426, JString, required = false,
                                   default = nil)
  if valid_28376426 != nil:
    section.add "Accept", valid_28376426
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376427: Call_GetReposOwnerRepoCollaborators_28376421;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List.
  ## When authenticating as an organization owner of an organization-owned
  ## repository, all organization owners are included in the list of
  ## collaborators. Otherwise, only users with access to the repository are
  ## returned in the collaborators list.
  ## 
  ## 
  let valid = call_28376427.validator(path, query, header, formData, body)
  let scheme = call_28376427.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376427.url(scheme.get, call_28376427.host, call_28376427.base,
                           call_28376427.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376427, url, valid)

proc call*(call_28376428: Call_GetReposOwnerRepoCollaborators_28376421;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCollaborators
  ## List.
  ## When authenticating as an organization owner of an organization-owned
  ## repository, all organization owners are included in the list of
  ## collaborators. Otherwise, only users with access to the repository are
  ## returned in the collaborators list.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376429 = newJObject()
  var header_28376430 = newJObject()
  add(path_28376429, "owner", newJString(owner))
  add(header_28376430, "Accept", newJString(Accept))
  add(path_28376429, "repo", newJString(repo))
  result = call_28376428.call(path_28376429, nil, header_28376430, nil, nil)

var getReposOwnerRepoCollaborators* = Call_GetReposOwnerRepoCollaborators_28376421(
    name: "getReposOwnerRepoCollaborators", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators",
    validator: validate_GetReposOwnerRepoCollaborators_28376422, base: "/",
    url: url_GetReposOwnerRepoCollaborators_28376423, schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoCollaboratorsUser_28376442 = ref object of OpenApiRestCall_28375350
proc url_PutReposOwnerRepoCollaboratorsUser_28376444(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "user" in path, "`user` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/collaborators/"),
               (kind: VariableSegment, value: "user")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoCollaboratorsUser_28376443(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Add collaborator.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   user: JString (required)
  ##       : Login of the user.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376445 = path.getOrDefault("owner")
  valid_28376445 = validateParameter(valid_28376445, JString, required = true,
                                   default = nil)
  if valid_28376445 != nil:
    section.add "owner", valid_28376445
  var valid_28376446 = path.getOrDefault("user")
  valid_28376446 = validateParameter(valid_28376446, JString, required = true,
                                   default = nil)
  if valid_28376446 != nil:
    section.add "user", valid_28376446
  var valid_28376447 = path.getOrDefault("repo")
  valid_28376447 = validateParameter(valid_28376447, JString, required = true,
                                   default = nil)
  if valid_28376447 != nil:
    section.add "repo", valid_28376447
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376448 = header.getOrDefault("Accept")
  valid_28376448 = validateParameter(valid_28376448, JString, required = false,
                                   default = nil)
  if valid_28376448 != nil:
    section.add "Accept", valid_28376448
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376449: Call_PutReposOwnerRepoCollaboratorsUser_28376442;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Add collaborator.
  ## 
  let valid = call_28376449.validator(path, query, header, formData, body)
  let scheme = call_28376449.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376449.url(scheme.get, call_28376449.host, call_28376449.base,
                           call_28376449.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376449, url, valid)

proc call*(call_28376450: Call_PutReposOwnerRepoCollaboratorsUser_28376442;
          owner: string; user: string; repo: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoCollaboratorsUser
  ## Add collaborator.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   user: string (required)
  ##       : Login of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376451 = newJObject()
  var header_28376452 = newJObject()
  add(path_28376451, "owner", newJString(owner))
  add(path_28376451, "user", newJString(user))
  add(header_28376452, "Accept", newJString(Accept))
  add(path_28376451, "repo", newJString(repo))
  result = call_28376450.call(path_28376451, nil, header_28376452, nil, nil)

var putReposOwnerRepoCollaboratorsUser* = Call_PutReposOwnerRepoCollaboratorsUser_28376442(
    name: "putReposOwnerRepoCollaboratorsUser", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators/{user}",
    validator: validate_PutReposOwnerRepoCollaboratorsUser_28376443, base: "/",
    url: url_PutReposOwnerRepoCollaboratorsUser_28376444, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCollaboratorsUser_28376431 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoCollaboratorsUser_28376433(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "user" in path, "`user` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/collaborators/"),
               (kind: VariableSegment, value: "user")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCollaboratorsUser_28376432(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Check if user is a collaborator
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   user: JString (required)
  ##       : Login of the user.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376434 = path.getOrDefault("owner")
  valid_28376434 = validateParameter(valid_28376434, JString, required = true,
                                   default = nil)
  if valid_28376434 != nil:
    section.add "owner", valid_28376434
  var valid_28376435 = path.getOrDefault("user")
  valid_28376435 = validateParameter(valid_28376435, JString, required = true,
                                   default = nil)
  if valid_28376435 != nil:
    section.add "user", valid_28376435
  var valid_28376436 = path.getOrDefault("repo")
  valid_28376436 = validateParameter(valid_28376436, JString, required = true,
                                   default = nil)
  if valid_28376436 != nil:
    section.add "repo", valid_28376436
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376437 = header.getOrDefault("Accept")
  valid_28376437 = validateParameter(valid_28376437, JString, required = false,
                                   default = nil)
  if valid_28376437 != nil:
    section.add "Accept", valid_28376437
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376438: Call_GetReposOwnerRepoCollaboratorsUser_28376431;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Check if user is a collaborator
  ## 
  let valid = call_28376438.validator(path, query, header, formData, body)
  let scheme = call_28376438.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376438.url(scheme.get, call_28376438.host, call_28376438.base,
                           call_28376438.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376438, url, valid)

proc call*(call_28376439: Call_GetReposOwnerRepoCollaboratorsUser_28376431;
          owner: string; user: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCollaboratorsUser
  ## Check if user is a collaborator
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   user: string (required)
  ##       : Login of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376440 = newJObject()
  var header_28376441 = newJObject()
  add(path_28376440, "owner", newJString(owner))
  add(path_28376440, "user", newJString(user))
  add(header_28376441, "Accept", newJString(Accept))
  add(path_28376440, "repo", newJString(repo))
  result = call_28376439.call(path_28376440, nil, header_28376441, nil, nil)

var getReposOwnerRepoCollaboratorsUser* = Call_GetReposOwnerRepoCollaboratorsUser_28376431(
    name: "getReposOwnerRepoCollaboratorsUser", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators/{user}",
    validator: validate_GetReposOwnerRepoCollaboratorsUser_28376432, base: "/",
    url: url_GetReposOwnerRepoCollaboratorsUser_28376433, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoCollaboratorsUser_28376453 = ref object of OpenApiRestCall_28375350
proc url_DeleteReposOwnerRepoCollaboratorsUser_28376455(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "user" in path, "`user` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/collaborators/"),
               (kind: VariableSegment, value: "user")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoCollaboratorsUser_28376454(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Remove collaborator.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   user: JString (required)
  ##       : Login of the user.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376456 = path.getOrDefault("owner")
  valid_28376456 = validateParameter(valid_28376456, JString, required = true,
                                   default = nil)
  if valid_28376456 != nil:
    section.add "owner", valid_28376456
  var valid_28376457 = path.getOrDefault("user")
  valid_28376457 = validateParameter(valid_28376457, JString, required = true,
                                   default = nil)
  if valid_28376457 != nil:
    section.add "user", valid_28376457
  var valid_28376458 = path.getOrDefault("repo")
  valid_28376458 = validateParameter(valid_28376458, JString, required = true,
                                   default = nil)
  if valid_28376458 != nil:
    section.add "repo", valid_28376458
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376459 = header.getOrDefault("Accept")
  valid_28376459 = validateParameter(valid_28376459, JString, required = false,
                                   default = nil)
  if valid_28376459 != nil:
    section.add "Accept", valid_28376459
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376460: Call_DeleteReposOwnerRepoCollaboratorsUser_28376453;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Remove collaborator.
  ## 
  let valid = call_28376460.validator(path, query, header, formData, body)
  let scheme = call_28376460.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376460.url(scheme.get, call_28376460.host, call_28376460.base,
                           call_28376460.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376460, url, valid)

proc call*(call_28376461: Call_DeleteReposOwnerRepoCollaboratorsUser_28376453;
          owner: string; user: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoCollaboratorsUser
  ## Remove collaborator.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   user: string (required)
  ##       : Login of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376462 = newJObject()
  var header_28376463 = newJObject()
  add(path_28376462, "owner", newJString(owner))
  add(path_28376462, "user", newJString(user))
  add(header_28376463, "Accept", newJString(Accept))
  add(path_28376462, "repo", newJString(repo))
  result = call_28376461.call(path_28376462, nil, header_28376463, nil, nil)

var deleteReposOwnerRepoCollaboratorsUser* = Call_DeleteReposOwnerRepoCollaboratorsUser_28376453(
    name: "deleteReposOwnerRepoCollaboratorsUser", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators/{user}",
    validator: validate_DeleteReposOwnerRepoCollaboratorsUser_28376454, base: "/",
    url: url_DeleteReposOwnerRepoCollaboratorsUser_28376455,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoComments_28376464 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoComments_28376466(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoComments_28376465(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List commit comments for a repository.
  ## Comments are ordered by ascending ID.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376467 = path.getOrDefault("owner")
  valid_28376467 = validateParameter(valid_28376467, JString, required = true,
                                   default = nil)
  if valid_28376467 != nil:
    section.add "owner", valid_28376467
  var valid_28376468 = path.getOrDefault("repo")
  valid_28376468 = validateParameter(valid_28376468, JString, required = true,
                                   default = nil)
  if valid_28376468 != nil:
    section.add "repo", valid_28376468
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376469 = header.getOrDefault("Accept")
  valid_28376469 = validateParameter(valid_28376469, JString, required = false,
                                   default = nil)
  if valid_28376469 != nil:
    section.add "Accept", valid_28376469
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376470: Call_GetReposOwnerRepoComments_28376464; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List commit comments for a repository.
  ## Comments are ordered by ascending ID.
  ## 
  ## 
  let valid = call_28376470.validator(path, query, header, formData, body)
  let scheme = call_28376470.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376470.url(scheme.get, call_28376470.host, call_28376470.base,
                           call_28376470.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376470, url, valid)

proc call*(call_28376471: Call_GetReposOwnerRepoComments_28376464; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoComments
  ## List commit comments for a repository.
  ## Comments are ordered by ascending ID.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376472 = newJObject()
  var header_28376473 = newJObject()
  add(path_28376472, "owner", newJString(owner))
  add(header_28376473, "Accept", newJString(Accept))
  add(path_28376472, "repo", newJString(repo))
  result = call_28376471.call(path_28376472, nil, header_28376473, nil, nil)

var getReposOwnerRepoComments* = Call_GetReposOwnerRepoComments_28376464(
    name: "getReposOwnerRepoComments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments",
    validator: validate_GetReposOwnerRepoComments_28376465, base: "/",
    url: url_GetReposOwnerRepoComments_28376466, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommentsCommentId_28376474 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoCommentsCommentId_28376476(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommentsCommentId_28376475(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single commit comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376477 = path.getOrDefault("owner")
  valid_28376477 = validateParameter(valid_28376477, JString, required = true,
                                   default = nil)
  if valid_28376477 != nil:
    section.add "owner", valid_28376477
  var valid_28376478 = path.getOrDefault("repo")
  valid_28376478 = validateParameter(valid_28376478, JString, required = true,
                                   default = nil)
  if valid_28376478 != nil:
    section.add "repo", valid_28376478
  var valid_28376479 = path.getOrDefault("commentId")
  valid_28376479 = validateParameter(valid_28376479, JInt, required = true,
                                   default = nil)
  if valid_28376479 != nil:
    section.add "commentId", valid_28376479
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376480 = header.getOrDefault("Accept")
  valid_28376480 = validateParameter(valid_28376480, JString, required = false,
                                   default = nil)
  if valid_28376480 != nil:
    section.add "Accept", valid_28376480
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376481: Call_GetReposOwnerRepoCommentsCommentId_28376474;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single commit comment.
  ## 
  let valid = call_28376481.validator(path, query, header, formData, body)
  let scheme = call_28376481.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376481.url(scheme.get, call_28376481.host, call_28376481.base,
                           call_28376481.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376481, url, valid)

proc call*(call_28376482: Call_GetReposOwnerRepoCommentsCommentId_28376474;
          owner: string; repo: string; commentId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommentsCommentId
  ## Get a single commit comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_28376483 = newJObject()
  var header_28376484 = newJObject()
  add(path_28376483, "owner", newJString(owner))
  add(header_28376484, "Accept", newJString(Accept))
  add(path_28376483, "repo", newJString(repo))
  add(path_28376483, "commentId", newJInt(commentId))
  result = call_28376482.call(path_28376483, nil, header_28376484, nil, nil)

var getReposOwnerRepoCommentsCommentId* = Call_GetReposOwnerRepoCommentsCommentId_28376474(
    name: "getReposOwnerRepoCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments/{commentId}",
    validator: validate_GetReposOwnerRepoCommentsCommentId_28376475, base: "/",
    url: url_GetReposOwnerRepoCommentsCommentId_28376476, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoCommentsCommentId_28376496 = ref object of OpenApiRestCall_28375350
proc url_PatchReposOwnerRepoCommentsCommentId_28376498(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoCommentsCommentId_28376497(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Update a commit comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376499 = path.getOrDefault("owner")
  valid_28376499 = validateParameter(valid_28376499, JString, required = true,
                                   default = nil)
  if valid_28376499 != nil:
    section.add "owner", valid_28376499
  var valid_28376500 = path.getOrDefault("repo")
  valid_28376500 = validateParameter(valid_28376500, JString, required = true,
                                   default = nil)
  if valid_28376500 != nil:
    section.add "repo", valid_28376500
  var valid_28376501 = path.getOrDefault("commentId")
  valid_28376501 = validateParameter(valid_28376501, JInt, required = true,
                                   default = nil)
  if valid_28376501 != nil:
    section.add "commentId", valid_28376501
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376502 = header.getOrDefault("Accept")
  valid_28376502 = validateParameter(valid_28376502, JString, required = false,
                                   default = nil)
  if valid_28376502 != nil:
    section.add "Accept", valid_28376502
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28376504: Call_PatchReposOwnerRepoCommentsCommentId_28376496;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Update a commit comment.
  ## 
  let valid = call_28376504.validator(path, query, header, formData, body)
  let scheme = call_28376504.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376504.url(scheme.get, call_28376504.host, call_28376504.base,
                           call_28376504.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376504, url, valid)

proc call*(call_28376505: Call_PatchReposOwnerRepoCommentsCommentId_28376496;
          owner: string; body: JsonNode; repo: string; commentId: int;
          Accept: string = ""): Recallable =
  ## patchReposOwnerRepoCommentsCommentId
  ## Update a commit comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_28376506 = newJObject()
  var header_28376507 = newJObject()
  var body_28376508 = newJObject()
  add(path_28376506, "owner", newJString(owner))
  add(header_28376507, "Accept", newJString(Accept))
  if body != nil:
    body_28376508 = body
  add(path_28376506, "repo", newJString(repo))
  add(path_28376506, "commentId", newJInt(commentId))
  result = call_28376505.call(path_28376506, nil, header_28376507, nil, body_28376508)

var patchReposOwnerRepoCommentsCommentId* = Call_PatchReposOwnerRepoCommentsCommentId_28376496(
    name: "patchReposOwnerRepoCommentsCommentId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments/{commentId}",
    validator: validate_PatchReposOwnerRepoCommentsCommentId_28376497, base: "/",
    url: url_PatchReposOwnerRepoCommentsCommentId_28376498,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoCommentsCommentId_28376485 = ref object of OpenApiRestCall_28375350
proc url_DeleteReposOwnerRepoCommentsCommentId_28376487(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoCommentsCommentId_28376486(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a commit comment
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376488 = path.getOrDefault("owner")
  valid_28376488 = validateParameter(valid_28376488, JString, required = true,
                                   default = nil)
  if valid_28376488 != nil:
    section.add "owner", valid_28376488
  var valid_28376489 = path.getOrDefault("repo")
  valid_28376489 = validateParameter(valid_28376489, JString, required = true,
                                   default = nil)
  if valid_28376489 != nil:
    section.add "repo", valid_28376489
  var valid_28376490 = path.getOrDefault("commentId")
  valid_28376490 = validateParameter(valid_28376490, JInt, required = true,
                                   default = nil)
  if valid_28376490 != nil:
    section.add "commentId", valid_28376490
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376491 = header.getOrDefault("Accept")
  valid_28376491 = validateParameter(valid_28376491, JString, required = false,
                                   default = nil)
  if valid_28376491 != nil:
    section.add "Accept", valid_28376491
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376492: Call_DeleteReposOwnerRepoCommentsCommentId_28376485;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a commit comment
  ## 
  let valid = call_28376492.validator(path, query, header, formData, body)
  let scheme = call_28376492.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376492.url(scheme.get, call_28376492.host, call_28376492.base,
                           call_28376492.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376492, url, valid)

proc call*(call_28376493: Call_DeleteReposOwnerRepoCommentsCommentId_28376485;
          owner: string; repo: string; commentId: int; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoCommentsCommentId
  ## Delete a commit comment
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_28376494 = newJObject()
  var header_28376495 = newJObject()
  add(path_28376494, "owner", newJString(owner))
  add(header_28376495, "Accept", newJString(Accept))
  add(path_28376494, "repo", newJString(repo))
  add(path_28376494, "commentId", newJInt(commentId))
  result = call_28376493.call(path_28376494, nil, header_28376495, nil, nil)

var deleteReposOwnerRepoCommentsCommentId* = Call_DeleteReposOwnerRepoCommentsCommentId_28376485(
    name: "deleteReposOwnerRepoCommentsCommentId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments/{commentId}",
    validator: validate_DeleteReposOwnerRepoCommentsCommentId_28376486, base: "/",
    url: url_DeleteReposOwnerRepoCommentsCommentId_28376487,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommits_28376509 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoCommits_28376511(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommits_28376510(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List commits on a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376512 = path.getOrDefault("owner")
  valid_28376512 = validateParameter(valid_28376512, JString, required = true,
                                   default = nil)
  if valid_28376512 != nil:
    section.add "owner", valid_28376512
  var valid_28376513 = path.getOrDefault("repo")
  valid_28376513 = validateParameter(valid_28376513, JString, required = true,
                                   default = nil)
  if valid_28376513 != nil:
    section.add "repo", valid_28376513
  result.add "path", section
  ## parameters in `query` object:
  ##   path: JString
  ##       : Only commits containing this file path will be returned.
  ##   sha: JString
  ##      : Sha or branch to start listing commits from.
  ##   author: JString
  ##         : GitHub login, name, or email by which to filter by commit author.
  ##   until: JString
  ##        : ISO 8601 Date - Only commits before this date will be returned.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_28376514 = query.getOrDefault("path")
  valid_28376514 = validateParameter(valid_28376514, JString, required = false,
                                   default = nil)
  if valid_28376514 != nil:
    section.add "path", valid_28376514
  var valid_28376515 = query.getOrDefault("sha")
  valid_28376515 = validateParameter(valid_28376515, JString, required = false,
                                   default = nil)
  if valid_28376515 != nil:
    section.add "sha", valid_28376515
  var valid_28376516 = query.getOrDefault("author")
  valid_28376516 = validateParameter(valid_28376516, JString, required = false,
                                   default = nil)
  if valid_28376516 != nil:
    section.add "author", valid_28376516
  var valid_28376517 = query.getOrDefault("until")
  valid_28376517 = validateParameter(valid_28376517, JString, required = false,
                                   default = nil)
  if valid_28376517 != nil:
    section.add "until", valid_28376517
  var valid_28376518 = query.getOrDefault("since")
  valid_28376518 = validateParameter(valid_28376518, JString, required = false,
                                   default = nil)
  if valid_28376518 != nil:
    section.add "since", valid_28376518
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376519 = header.getOrDefault("Accept")
  valid_28376519 = validateParameter(valid_28376519, JString, required = false,
                                   default = nil)
  if valid_28376519 != nil:
    section.add "Accept", valid_28376519
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376520: Call_GetReposOwnerRepoCommits_28376509; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List commits on a repository.
  ## 
  let valid = call_28376520.validator(path, query, header, formData, body)
  let scheme = call_28376520.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376520.url(scheme.get, call_28376520.host, call_28376520.base,
                           call_28376520.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376520, url, valid)

proc call*(call_28376521: Call_GetReposOwnerRepoCommits_28376509; owner: string;
          repo: string; path: string = ""; Accept: string = ""; sha: string = "";
          author: string = ""; until: string = ""; since: string = ""): Recallable =
  ## getReposOwnerRepoCommits
  ## List commits on a repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   path: string
  ##       : Only commits containing this file path will be returned.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   sha: string
  ##      : Sha or branch to start listing commits from.
  ##   author: string
  ##         : GitHub login, name, or email by which to filter by commit author.
  ##   until: string
  ##        : ISO 8601 Date - Only commits before this date will be returned.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var path_28376522 = newJObject()
  var query_28376523 = newJObject()
  var header_28376524 = newJObject()
  add(path_28376522, "owner", newJString(owner))
  add(query_28376523, "path", newJString(path))
  add(header_28376524, "Accept", newJString(Accept))
  add(path_28376522, "repo", newJString(repo))
  add(query_28376523, "sha", newJString(sha))
  add(query_28376523, "author", newJString(author))
  add(query_28376523, "until", newJString(until))
  add(query_28376523, "since", newJString(since))
  result = call_28376521.call(path_28376522, query_28376523, header_28376524, nil, nil)

var getReposOwnerRepoCommits* = Call_GetReposOwnerRepoCommits_28376509(
    name: "getReposOwnerRepoCommits", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/commits",
    validator: validate_GetReposOwnerRepoCommits_28376510, base: "/",
    url: url_GetReposOwnerRepoCommits_28376511, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommitsRefStatus_28376525 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoCommitsRefStatus_28376527(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits/"),
               (kind: VariableSegment, value: "ref"),
               (kind: ConstantSegment, value: "/status")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommitsRefStatus_28376526(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the combined Status for a specific Ref
  ## The Combined status endpoint is currently available for developers to preview. During the preview period, the API may change without advance notice. Please see the blog post for full details.
  ## To access this endpoint during the preview period, you must provide a custom media type in the Accept header:
  ## application/vnd.github.she-hulk-preview+json
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   ref: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376528 = path.getOrDefault("owner")
  valid_28376528 = validateParameter(valid_28376528, JString, required = true,
                                   default = nil)
  if valid_28376528 != nil:
    section.add "owner", valid_28376528
  var valid_28376529 = path.getOrDefault("ref")
  valid_28376529 = validateParameter(valid_28376529, JString, required = true,
                                   default = nil)
  if valid_28376529 != nil:
    section.add "ref", valid_28376529
  var valid_28376530 = path.getOrDefault("repo")
  valid_28376530 = validateParameter(valid_28376530, JString, required = true,
                                   default = nil)
  if valid_28376530 != nil:
    section.add "repo", valid_28376530
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376531 = header.getOrDefault("Accept")
  valid_28376531 = validateParameter(valid_28376531, JString, required = false,
                                   default = nil)
  if valid_28376531 != nil:
    section.add "Accept", valid_28376531
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376532: Call_GetReposOwnerRepoCommitsRefStatus_28376525;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get the combined Status for a specific Ref
  ## The Combined status endpoint is currently available for developers to preview. During the preview period, the API may change without advance notice. Please see the blog post for full details.
  ## To access this endpoint during the preview period, you must provide a custom media type in the Accept header:
  ## application/vnd.github.she-hulk-preview+json
  ## 
  ## 
  let valid = call_28376532.validator(path, query, header, formData, body)
  let scheme = call_28376532.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376532.url(scheme.get, call_28376532.host, call_28376532.base,
                           call_28376532.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376532, url, valid)

proc call*(call_28376533: Call_GetReposOwnerRepoCommitsRefStatus_28376525;
          owner: string; `ref`: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommitsRefStatus
  ## Get the combined Status for a specific Ref
  ## The Combined status endpoint is currently available for developers to preview. During the preview period, the API may change without advance notice. Please see the blog post for full details.
  ## To access this endpoint during the preview period, you must provide a custom media type in the Accept header:
  ## application/vnd.github.she-hulk-preview+json
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   ref: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376534 = newJObject()
  var header_28376535 = newJObject()
  add(path_28376534, "owner", newJString(owner))
  add(path_28376534, "ref", newJString(`ref`))
  add(header_28376535, "Accept", newJString(Accept))
  add(path_28376534, "repo", newJString(repo))
  result = call_28376533.call(path_28376534, nil, header_28376535, nil, nil)

var getReposOwnerRepoCommitsRefStatus* = Call_GetReposOwnerRepoCommitsRefStatus_28376525(
    name: "getReposOwnerRepoCommitsRefStatus", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/commits/{ref}/status",
    validator: validate_GetReposOwnerRepoCommitsRefStatus_28376526, base: "/",
    url: url_GetReposOwnerRepoCommitsRefStatus_28376527, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommitsShaCode_28376536 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoCommitsShaCode_28376538(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommitsShaCode_28376537(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  ##          : SHA-1 code of the commit.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376539 = path.getOrDefault("owner")
  valid_28376539 = validateParameter(valid_28376539, JString, required = true,
                                   default = nil)
  if valid_28376539 != nil:
    section.add "owner", valid_28376539
  var valid_28376540 = path.getOrDefault("repo")
  valid_28376540 = validateParameter(valid_28376540, JString, required = true,
                                   default = nil)
  if valid_28376540 != nil:
    section.add "repo", valid_28376540
  var valid_28376541 = path.getOrDefault("shaCode")
  valid_28376541 = validateParameter(valid_28376541, JString, required = true,
                                   default = nil)
  if valid_28376541 != nil:
    section.add "shaCode", valid_28376541
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376542 = header.getOrDefault("Accept")
  valid_28376542 = validateParameter(valid_28376542, JString, required = false,
                                   default = nil)
  if valid_28376542 != nil:
    section.add "Accept", valid_28376542
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376543: Call_GetReposOwnerRepoCommitsShaCode_28376536;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single commit.
  ## 
  let valid = call_28376543.validator(path, query, header, formData, body)
  let scheme = call_28376543.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376543.url(scheme.get, call_28376543.host, call_28376543.base,
                           call_28376543.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376543, url, valid)

proc call*(call_28376544: Call_GetReposOwnerRepoCommitsShaCode_28376536;
          owner: string; repo: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommitsShaCode
  ## Get a single commit.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  ##          : SHA-1 code of the commit.
  var path_28376545 = newJObject()
  var header_28376546 = newJObject()
  add(path_28376545, "owner", newJString(owner))
  add(header_28376546, "Accept", newJString(Accept))
  add(path_28376545, "repo", newJString(repo))
  add(path_28376545, "shaCode", newJString(shaCode))
  result = call_28376544.call(path_28376545, nil, header_28376546, nil, nil)

var getReposOwnerRepoCommitsShaCode* = Call_GetReposOwnerRepoCommitsShaCode_28376536(
    name: "getReposOwnerRepoCommitsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/commits/{shaCode}",
    validator: validate_GetReposOwnerRepoCommitsShaCode_28376537, base: "/",
    url: url_GetReposOwnerRepoCommitsShaCode_28376538, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoCommitsShaCodeComments_28376558 = ref object of OpenApiRestCall_28375350
proc url_PostReposOwnerRepoCommitsShaCodeComments_28376560(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits/"),
               (kind: VariableSegment, value: "shaCode"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoCommitsShaCodeComments_28376559(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a commit comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  ##          : SHA-1 code of the commit.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376561 = path.getOrDefault("owner")
  valid_28376561 = validateParameter(valid_28376561, JString, required = true,
                                   default = nil)
  if valid_28376561 != nil:
    section.add "owner", valid_28376561
  var valid_28376562 = path.getOrDefault("repo")
  valid_28376562 = validateParameter(valid_28376562, JString, required = true,
                                   default = nil)
  if valid_28376562 != nil:
    section.add "repo", valid_28376562
  var valid_28376563 = path.getOrDefault("shaCode")
  valid_28376563 = validateParameter(valid_28376563, JString, required = true,
                                   default = nil)
  if valid_28376563 != nil:
    section.add "shaCode", valid_28376563
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376564 = header.getOrDefault("Accept")
  valid_28376564 = validateParameter(valid_28376564, JString, required = false,
                                   default = nil)
  if valid_28376564 != nil:
    section.add "Accept", valid_28376564
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28376566: Call_PostReposOwnerRepoCommitsShaCodeComments_28376558;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Create a commit comment.
  ## 
  let valid = call_28376566.validator(path, query, header, formData, body)
  let scheme = call_28376566.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376566.url(scheme.get, call_28376566.host, call_28376566.base,
                           call_28376566.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376566, url, valid)

proc call*(call_28376567: Call_PostReposOwnerRepoCommitsShaCodeComments_28376558;
          owner: string; body: JsonNode; repo: string; shaCode: string;
          Accept: string = ""): Recallable =
  ## postReposOwnerRepoCommitsShaCodeComments
  ## Create a commit comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  ##          : SHA-1 code of the commit.
  var path_28376568 = newJObject()
  var header_28376569 = newJObject()
  var body_28376570 = newJObject()
  add(path_28376568, "owner", newJString(owner))
  add(header_28376569, "Accept", newJString(Accept))
  if body != nil:
    body_28376570 = body
  add(path_28376568, "repo", newJString(repo))
  add(path_28376568, "shaCode", newJString(shaCode))
  result = call_28376567.call(path_28376568, nil, header_28376569, nil, body_28376570)

var postReposOwnerRepoCommitsShaCodeComments* = Call_PostReposOwnerRepoCommitsShaCodeComments_28376558(
    name: "postReposOwnerRepoCommitsShaCodeComments", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/commits/{shaCode}/comments",
    validator: validate_PostReposOwnerRepoCommitsShaCodeComments_28376559,
    base: "/", url: url_PostReposOwnerRepoCommitsShaCodeComments_28376560,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommitsShaCodeComments_28376547 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoCommitsShaCodeComments_28376549(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits/"),
               (kind: VariableSegment, value: "shaCode"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommitsShaCodeComments_28376548(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List comments for a single commitList comments for a single commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  ##          : SHA-1 code of the commit.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376550 = path.getOrDefault("owner")
  valid_28376550 = validateParameter(valid_28376550, JString, required = true,
                                   default = nil)
  if valid_28376550 != nil:
    section.add "owner", valid_28376550
  var valid_28376551 = path.getOrDefault("repo")
  valid_28376551 = validateParameter(valid_28376551, JString, required = true,
                                   default = nil)
  if valid_28376551 != nil:
    section.add "repo", valid_28376551
  var valid_28376552 = path.getOrDefault("shaCode")
  valid_28376552 = validateParameter(valid_28376552, JString, required = true,
                                   default = nil)
  if valid_28376552 != nil:
    section.add "shaCode", valid_28376552
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376553 = header.getOrDefault("Accept")
  valid_28376553 = validateParameter(valid_28376553, JString, required = false,
                                   default = nil)
  if valid_28376553 != nil:
    section.add "Accept", valid_28376553
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376554: Call_GetReposOwnerRepoCommitsShaCodeComments_28376547;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List comments for a single commitList comments for a single commit.
  ## 
  let valid = call_28376554.validator(path, query, header, formData, body)
  let scheme = call_28376554.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376554.url(scheme.get, call_28376554.host, call_28376554.base,
                           call_28376554.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376554, url, valid)

proc call*(call_28376555: Call_GetReposOwnerRepoCommitsShaCodeComments_28376547;
          owner: string; repo: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommitsShaCodeComments
  ## List comments for a single commitList comments for a single commit.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  ##          : SHA-1 code of the commit.
  var path_28376556 = newJObject()
  var header_28376557 = newJObject()
  add(path_28376556, "owner", newJString(owner))
  add(header_28376557, "Accept", newJString(Accept))
  add(path_28376556, "repo", newJString(repo))
  add(path_28376556, "shaCode", newJString(shaCode))
  result = call_28376555.call(path_28376556, nil, header_28376557, nil, nil)

var getReposOwnerRepoCommitsShaCodeComments* = Call_GetReposOwnerRepoCommitsShaCodeComments_28376547(
    name: "getReposOwnerRepoCommitsShaCodeComments", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/commits/{shaCode}/comments",
    validator: validate_GetReposOwnerRepoCommitsShaCodeComments_28376548,
    base: "/", url: url_GetReposOwnerRepoCommitsShaCodeComments_28376549,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCompareBaseIdHeadId_28376571 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoCompareBaseIdHeadId_28376573(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "baseId" in path, "`baseId` is a required path parameter"
  assert "headId" in path, "`headId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/compare/"),
               (kind: VariableSegment, value: "baseId"),
               (kind: ConstantSegment, value: "..."),
               (kind: VariableSegment, value: "headId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCompareBaseIdHeadId_28376572(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Compare two commits
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   baseId: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   headId: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376574 = path.getOrDefault("owner")
  valid_28376574 = validateParameter(valid_28376574, JString, required = true,
                                   default = nil)
  if valid_28376574 != nil:
    section.add "owner", valid_28376574
  var valid_28376575 = path.getOrDefault("baseId")
  valid_28376575 = validateParameter(valid_28376575, JString, required = true,
                                   default = nil)
  if valid_28376575 != nil:
    section.add "baseId", valid_28376575
  var valid_28376576 = path.getOrDefault("repo")
  valid_28376576 = validateParameter(valid_28376576, JString, required = true,
                                   default = nil)
  if valid_28376576 != nil:
    section.add "repo", valid_28376576
  var valid_28376577 = path.getOrDefault("headId")
  valid_28376577 = validateParameter(valid_28376577, JString, required = true,
                                   default = nil)
  if valid_28376577 != nil:
    section.add "headId", valid_28376577
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376578 = header.getOrDefault("Accept")
  valid_28376578 = validateParameter(valid_28376578, JString, required = false,
                                   default = nil)
  if valid_28376578 != nil:
    section.add "Accept", valid_28376578
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376579: Call_GetReposOwnerRepoCompareBaseIdHeadId_28376571;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Compare two commits
  ## 
  let valid = call_28376579.validator(path, query, header, formData, body)
  let scheme = call_28376579.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376579.url(scheme.get, call_28376579.host, call_28376579.base,
                           call_28376579.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376579, url, valid)

proc call*(call_28376580: Call_GetReposOwnerRepoCompareBaseIdHeadId_28376571;
          owner: string; baseId: string; repo: string; headId: string;
          Accept: string = ""): Recallable =
  ## getReposOwnerRepoCompareBaseIdHeadId
  ## Compare two commits
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   baseId: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   headId: string (required)
  var path_28376581 = newJObject()
  var header_28376582 = newJObject()
  add(path_28376581, "owner", newJString(owner))
  add(path_28376581, "baseId", newJString(baseId))
  add(header_28376582, "Accept", newJString(Accept))
  add(path_28376581, "repo", newJString(repo))
  add(path_28376581, "headId", newJString(headId))
  result = call_28376580.call(path_28376581, nil, header_28376582, nil, nil)

var getReposOwnerRepoCompareBaseIdHeadId* = Call_GetReposOwnerRepoCompareBaseIdHeadId_28376571(
    name: "getReposOwnerRepoCompareBaseIdHeadId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/compare/{baseId}...{headId}",
    validator: validate_GetReposOwnerRepoCompareBaseIdHeadId_28376572, base: "/",
    url: url_GetReposOwnerRepoCompareBaseIdHeadId_28376573,
    schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoContentsPath_28376597 = ref object of OpenApiRestCall_28375350
proc url_PutReposOwnerRepoContentsPath_28376599(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/contents/"),
               (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoContentsPath_28376598(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a file.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   path: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376600 = path.getOrDefault("owner")
  valid_28376600 = validateParameter(valid_28376600, JString, required = true,
                                   default = nil)
  if valid_28376600 != nil:
    section.add "owner", valid_28376600
  var valid_28376601 = path.getOrDefault("repo")
  valid_28376601 = validateParameter(valid_28376601, JString, required = true,
                                   default = nil)
  if valid_28376601 != nil:
    section.add "repo", valid_28376601
  var valid_28376602 = path.getOrDefault("path")
  valid_28376602 = validateParameter(valid_28376602, JString, required = true,
                                   default = nil)
  if valid_28376602 != nil:
    section.add "path", valid_28376602
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376603 = header.getOrDefault("Accept")
  valid_28376603 = validateParameter(valid_28376603, JString, required = false,
                                   default = nil)
  if valid_28376603 != nil:
    section.add "Accept", valid_28376603
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28376605: Call_PutReposOwnerRepoContentsPath_28376597;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Create a file.
  ## 
  let valid = call_28376605.validator(path, query, header, formData, body)
  let scheme = call_28376605.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376605.url(scheme.get, call_28376605.host, call_28376605.base,
                           call_28376605.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376605, url, valid)

proc call*(call_28376606: Call_PutReposOwnerRepoContentsPath_28376597;
          owner: string; body: JsonNode; repo: string; path: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoContentsPath
  ## Create a file.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   path: string (required)
  var path_28376607 = newJObject()
  var header_28376608 = newJObject()
  var body_28376609 = newJObject()
  add(path_28376607, "owner", newJString(owner))
  add(header_28376608, "Accept", newJString(Accept))
  if body != nil:
    body_28376609 = body
  add(path_28376607, "repo", newJString(repo))
  add(path_28376607, "path", newJString(path))
  result = call_28376606.call(path_28376607, nil, header_28376608, nil, body_28376609)

var putReposOwnerRepoContentsPath* = Call_PutReposOwnerRepoContentsPath_28376597(
    name: "putReposOwnerRepoContentsPath", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contents/{path}",
    validator: validate_PutReposOwnerRepoContentsPath_28376598, base: "/",
    url: url_PutReposOwnerRepoContentsPath_28376599, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoContentsPath_28376583 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoContentsPath_28376585(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/contents/"),
               (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoContentsPath_28376584(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get contents.
  ## This method returns the contents of a file or directory in a repository.
  ## Files and symlinks support a custom media type for getting the raw content.
  ## Directories and submodules do not support custom media types.
  ## Note: This API supports files up to 1 megabyte in size.
  ## Here can be many outcomes. For details see "http://developer.github.com/v3/repos/contents/"
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   path: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376586 = path.getOrDefault("owner")
  valid_28376586 = validateParameter(valid_28376586, JString, required = true,
                                   default = nil)
  if valid_28376586 != nil:
    section.add "owner", valid_28376586
  var valid_28376587 = path.getOrDefault("repo")
  valid_28376587 = validateParameter(valid_28376587, JString, required = true,
                                   default = nil)
  if valid_28376587 != nil:
    section.add "repo", valid_28376587
  var valid_28376588 = path.getOrDefault("path")
  valid_28376588 = validateParameter(valid_28376588, JString, required = true,
                                   default = nil)
  if valid_28376588 != nil:
    section.add "path", valid_28376588
  result.add "path", section
  ## parameters in `query` object:
  ##   path: JString
  ##       : The content path.
  ##   ref: JString
  ##      : The String name of the Commit/Branch/Tag. Defaults to 'master'.
  section = newJObject()
  var valid_28376589 = query.getOrDefault("path")
  valid_28376589 = validateParameter(valid_28376589, JString, required = false,
                                   default = nil)
  if valid_28376589 != nil:
    section.add "path", valid_28376589
  var valid_28376590 = query.getOrDefault("ref")
  valid_28376590 = validateParameter(valid_28376590, JString, required = false,
                                   default = nil)
  if valid_28376590 != nil:
    section.add "ref", valid_28376590
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376591 = header.getOrDefault("Accept")
  valid_28376591 = validateParameter(valid_28376591, JString, required = false,
                                   default = nil)
  if valid_28376591 != nil:
    section.add "Accept", valid_28376591
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376592: Call_GetReposOwnerRepoContentsPath_28376583;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get contents.
  ## This method returns the contents of a file or directory in a repository.
  ## Files and symlinks support a custom media type for getting the raw content.
  ## Directories and submodules do not support custom media types.
  ## Note: This API supports files up to 1 megabyte in size.
  ## Here can be many outcomes. For details see "http://developer.github.com/v3/repos/contents/"
  ## 
  ## 
  let valid = call_28376592.validator(path, query, header, formData, body)
  let scheme = call_28376592.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376592.url(scheme.get, call_28376592.host, call_28376592.base,
                           call_28376592.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376592, url, valid)

var getReposOwnerRepoContentsPath* = Call_GetReposOwnerRepoContentsPath_28376583(
    name: "getReposOwnerRepoContentsPath", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contents/{path}",
    validator: validate_GetReposOwnerRepoContentsPath_28376584, base: "/",
    url: url_GetReposOwnerRepoContentsPath_28376585, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoContentsPath_28376610 = ref object of OpenApiRestCall_28375350
proc url_DeleteReposOwnerRepoContentsPath_28376612(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/contents/"),
               (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoContentsPath_28376611(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a file.
  ## This method deletes a file in a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   path: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376613 = path.getOrDefault("owner")
  valid_28376613 = validateParameter(valid_28376613, JString, required = true,
                                   default = nil)
  if valid_28376613 != nil:
    section.add "owner", valid_28376613
  var valid_28376614 = path.getOrDefault("repo")
  valid_28376614 = validateParameter(valid_28376614, JString, required = true,
                                   default = nil)
  if valid_28376614 != nil:
    section.add "repo", valid_28376614
  var valid_28376615 = path.getOrDefault("path")
  valid_28376615 = validateParameter(valid_28376615, JString, required = true,
                                   default = nil)
  if valid_28376615 != nil:
    section.add "path", valid_28376615
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376616 = header.getOrDefault("Accept")
  valid_28376616 = validateParameter(valid_28376616, JString, required = false,
                                   default = nil)
  if valid_28376616 != nil:
    section.add "Accept", valid_28376616
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28376618: Call_DeleteReposOwnerRepoContentsPath_28376610;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a file.
  ## This method deletes a file in a repository.
  ## 
  ## 
  let valid = call_28376618.validator(path, query, header, formData, body)
  let scheme = call_28376618.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376618.url(scheme.get, call_28376618.host, call_28376618.base,
                           call_28376618.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376618, url, valid)

proc call*(call_28376619: Call_DeleteReposOwnerRepoContentsPath_28376610;
          owner: string; body: JsonNode; repo: string; path: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoContentsPath
  ## Delete a file.
  ## This method deletes a file in a repository.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   path: string (required)
  var path_28376620 = newJObject()
  var header_28376621 = newJObject()
  var body_28376622 = newJObject()
  add(path_28376620, "owner", newJString(owner))
  add(header_28376621, "Accept", newJString(Accept))
  if body != nil:
    body_28376622 = body
  add(path_28376620, "repo", newJString(repo))
  add(path_28376620, "path", newJString(path))
  result = call_28376619.call(path_28376620, nil, header_28376621, nil, body_28376622)

var deleteReposOwnerRepoContentsPath* = Call_DeleteReposOwnerRepoContentsPath_28376610(
    name: "deleteReposOwnerRepoContentsPath", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contents/{path}",
    validator: validate_DeleteReposOwnerRepoContentsPath_28376611, base: "/",
    url: url_DeleteReposOwnerRepoContentsPath_28376612, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoContributors_28376623 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoContributors_28376625(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/contributors")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoContributors_28376624(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get list of contributors.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376626 = path.getOrDefault("owner")
  valid_28376626 = validateParameter(valid_28376626, JString, required = true,
                                   default = nil)
  if valid_28376626 != nil:
    section.add "owner", valid_28376626
  var valid_28376627 = path.getOrDefault("repo")
  valid_28376627 = validateParameter(valid_28376627, JString, required = true,
                                   default = nil)
  if valid_28376627 != nil:
    section.add "repo", valid_28376627
  result.add "path", section
  ## parameters in `query` object:
  ##   anon: JString (required)
  ##       : Set to 1 or true to include anonymous contributors in results.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `anon` field"
  var valid_28376628 = query.getOrDefault("anon")
  valid_28376628 = validateParameter(valid_28376628, JString, required = true,
                                   default = nil)
  if valid_28376628 != nil:
    section.add "anon", valid_28376628
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376629 = header.getOrDefault("Accept")
  valid_28376629 = validateParameter(valid_28376629, JString, required = false,
                                   default = nil)
  if valid_28376629 != nil:
    section.add "Accept", valid_28376629
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376630: Call_GetReposOwnerRepoContributors_28376623;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get list of contributors.
  ## 
  let valid = call_28376630.validator(path, query, header, formData, body)
  let scheme = call_28376630.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376630.url(scheme.get, call_28376630.host, call_28376630.base,
                           call_28376630.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376630, url, valid)

proc call*(call_28376631: Call_GetReposOwnerRepoContributors_28376623;
          owner: string; repo: string; anon: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoContributors
  ## Get list of contributors.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   anon: string (required)
  ##       : Set to 1 or true to include anonymous contributors in results.
  var path_28376632 = newJObject()
  var query_28376633 = newJObject()
  var header_28376634 = newJObject()
  add(path_28376632, "owner", newJString(owner))
  add(header_28376634, "Accept", newJString(Accept))
  add(path_28376632, "repo", newJString(repo))
  add(query_28376633, "anon", newJString(anon))
  result = call_28376631.call(path_28376632, query_28376633, header_28376634, nil, nil)

var getReposOwnerRepoContributors* = Call_GetReposOwnerRepoContributors_28376623(
    name: "getReposOwnerRepoContributors", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contributors",
    validator: validate_GetReposOwnerRepoContributors_28376624, base: "/",
    url: url_GetReposOwnerRepoContributors_28376625, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoDeployments_28376645 = ref object of OpenApiRestCall_28375350
proc url_PostReposOwnerRepoDeployments_28376647(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/deployments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoDeployments_28376646(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Users with push access can create a deployment for a given ref
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376648 = path.getOrDefault("owner")
  valid_28376648 = validateParameter(valid_28376648, JString, required = true,
                                   default = nil)
  if valid_28376648 != nil:
    section.add "owner", valid_28376648
  var valid_28376649 = path.getOrDefault("repo")
  valid_28376649 = validateParameter(valid_28376649, JString, required = true,
                                   default = nil)
  if valid_28376649 != nil:
    section.add "repo", valid_28376649
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376650 = header.getOrDefault("Accept")
  valid_28376650 = validateParameter(valid_28376650, JString, required = false,
                                   default = nil)
  if valid_28376650 != nil:
    section.add "Accept", valid_28376650
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28376652: Call_PostReposOwnerRepoDeployments_28376645;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Users with push access can create a deployment for a given ref
  ## 
  let valid = call_28376652.validator(path, query, header, formData, body)
  let scheme = call_28376652.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376652.url(scheme.get, call_28376652.host, call_28376652.base,
                           call_28376652.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376652, url, valid)

proc call*(call_28376653: Call_PostReposOwnerRepoDeployments_28376645;
          owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoDeployments
  ## Users with push access can create a deployment for a given ref
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376654 = newJObject()
  var header_28376655 = newJObject()
  var body_28376656 = newJObject()
  add(path_28376654, "owner", newJString(owner))
  add(header_28376655, "Accept", newJString(Accept))
  if body != nil:
    body_28376656 = body
  add(path_28376654, "repo", newJString(repo))
  result = call_28376653.call(path_28376654, nil, header_28376655, nil, body_28376656)

var postReposOwnerRepoDeployments* = Call_PostReposOwnerRepoDeployments_28376645(
    name: "postReposOwnerRepoDeployments", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/deployments",
    validator: validate_PostReposOwnerRepoDeployments_28376646, base: "/",
    url: url_PostReposOwnerRepoDeployments_28376647, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDeployments_28376635 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoDeployments_28376637(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/deployments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDeployments_28376636(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Users with pull access can view deployments for a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376638 = path.getOrDefault("owner")
  valid_28376638 = validateParameter(valid_28376638, JString, required = true,
                                   default = nil)
  if valid_28376638 != nil:
    section.add "owner", valid_28376638
  var valid_28376639 = path.getOrDefault("repo")
  valid_28376639 = validateParameter(valid_28376639, JString, required = true,
                                   default = nil)
  if valid_28376639 != nil:
    section.add "repo", valid_28376639
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376640 = header.getOrDefault("Accept")
  valid_28376640 = validateParameter(valid_28376640, JString, required = false,
                                   default = nil)
  if valid_28376640 != nil:
    section.add "Accept", valid_28376640
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376641: Call_GetReposOwnerRepoDeployments_28376635;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Users with pull access can view deployments for a repository
  ## 
  let valid = call_28376641.validator(path, query, header, formData, body)
  let scheme = call_28376641.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376641.url(scheme.get, call_28376641.host, call_28376641.base,
                           call_28376641.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376641, url, valid)

proc call*(call_28376642: Call_GetReposOwnerRepoDeployments_28376635;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDeployments
  ## Users with pull access can view deployments for a repository
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376643 = newJObject()
  var header_28376644 = newJObject()
  add(path_28376643, "owner", newJString(owner))
  add(header_28376644, "Accept", newJString(Accept))
  add(path_28376643, "repo", newJString(repo))
  result = call_28376642.call(path_28376643, nil, header_28376644, nil, nil)

var getReposOwnerRepoDeployments* = Call_GetReposOwnerRepoDeployments_28376635(
    name: "getReposOwnerRepoDeployments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/deployments",
    validator: validate_GetReposOwnerRepoDeployments_28376636, base: "/",
    url: url_GetReposOwnerRepoDeployments_28376637, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoDeploymentsIdStatuses_28376668 = ref object of OpenApiRestCall_28375350
proc url_PostReposOwnerRepoDeploymentsIdStatuses_28376670(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/deployments/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/statuses")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoDeploymentsIdStatuses_28376669(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a Deployment Status
  ## Users with push access can create deployment statuses for a given deployment:
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JInt (required)
  ##     : The Deployment ID to list the statuses from.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376671 = path.getOrDefault("owner")
  valid_28376671 = validateParameter(valid_28376671, JString, required = true,
                                   default = nil)
  if valid_28376671 != nil:
    section.add "owner", valid_28376671
  var valid_28376672 = path.getOrDefault("id")
  valid_28376672 = validateParameter(valid_28376672, JInt, required = true,
                                   default = nil)
  if valid_28376672 != nil:
    section.add "id", valid_28376672
  var valid_28376673 = path.getOrDefault("repo")
  valid_28376673 = validateParameter(valid_28376673, JString, required = true,
                                   default = nil)
  if valid_28376673 != nil:
    section.add "repo", valid_28376673
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376674 = header.getOrDefault("Accept")
  valid_28376674 = validateParameter(valid_28376674, JString, required = false,
                                   default = nil)
  if valid_28376674 != nil:
    section.add "Accept", valid_28376674
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28376676: Call_PostReposOwnerRepoDeploymentsIdStatuses_28376668;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Create a Deployment Status
  ## Users with push access can create deployment statuses for a given deployment:
  ## 
  ## 
  let valid = call_28376676.validator(path, query, header, formData, body)
  let scheme = call_28376676.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376676.url(scheme.get, call_28376676.host, call_28376676.base,
                           call_28376676.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376676, url, valid)

proc call*(call_28376677: Call_PostReposOwnerRepoDeploymentsIdStatuses_28376668;
          owner: string; id: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoDeploymentsIdStatuses
  ## Create a Deployment Status
  ## Users with push access can create deployment statuses for a given deployment:
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: int (required)
  ##     : The Deployment ID to list the statuses from.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376678 = newJObject()
  var header_28376679 = newJObject()
  var body_28376680 = newJObject()
  add(path_28376678, "owner", newJString(owner))
  add(path_28376678, "id", newJInt(id))
  add(header_28376679, "Accept", newJString(Accept))
  if body != nil:
    body_28376680 = body
  add(path_28376678, "repo", newJString(repo))
  result = call_28376677.call(path_28376678, nil, header_28376679, nil, body_28376680)

var postReposOwnerRepoDeploymentsIdStatuses* = Call_PostReposOwnerRepoDeploymentsIdStatuses_28376668(
    name: "postReposOwnerRepoDeploymentsIdStatuses", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/deployments/{id}/statuses",
    validator: validate_PostReposOwnerRepoDeploymentsIdStatuses_28376669,
    base: "/", url: url_PostReposOwnerRepoDeploymentsIdStatuses_28376670,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDeploymentsIdStatuses_28376657 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoDeploymentsIdStatuses_28376659(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/deployments/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/statuses")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDeploymentsIdStatuses_28376658(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Users with pull access can view deployment statuses for a deployment
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JInt (required)
  ##     : The Deployment ID to list the statuses from.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376660 = path.getOrDefault("owner")
  valid_28376660 = validateParameter(valid_28376660, JString, required = true,
                                   default = nil)
  if valid_28376660 != nil:
    section.add "owner", valid_28376660
  var valid_28376661 = path.getOrDefault("id")
  valid_28376661 = validateParameter(valid_28376661, JInt, required = true,
                                   default = nil)
  if valid_28376661 != nil:
    section.add "id", valid_28376661
  var valid_28376662 = path.getOrDefault("repo")
  valid_28376662 = validateParameter(valid_28376662, JString, required = true,
                                   default = nil)
  if valid_28376662 != nil:
    section.add "repo", valid_28376662
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376663 = header.getOrDefault("Accept")
  valid_28376663 = validateParameter(valid_28376663, JString, required = false,
                                   default = nil)
  if valid_28376663 != nil:
    section.add "Accept", valid_28376663
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376664: Call_GetReposOwnerRepoDeploymentsIdStatuses_28376657;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Users with pull access can view deployment statuses for a deployment
  ## 
  let valid = call_28376664.validator(path, query, header, formData, body)
  let scheme = call_28376664.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376664.url(scheme.get, call_28376664.host, call_28376664.base,
                           call_28376664.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376664, url, valid)

proc call*(call_28376665: Call_GetReposOwnerRepoDeploymentsIdStatuses_28376657;
          owner: string; id: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDeploymentsIdStatuses
  ## Users with pull access can view deployment statuses for a deployment
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: int (required)
  ##     : The Deployment ID to list the statuses from.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376666 = newJObject()
  var header_28376667 = newJObject()
  add(path_28376666, "owner", newJString(owner))
  add(path_28376666, "id", newJInt(id))
  add(header_28376667, "Accept", newJString(Accept))
  add(path_28376666, "repo", newJString(repo))
  result = call_28376665.call(path_28376666, nil, header_28376667, nil, nil)

var getReposOwnerRepoDeploymentsIdStatuses* = Call_GetReposOwnerRepoDeploymentsIdStatuses_28376657(
    name: "getReposOwnerRepoDeploymentsIdStatuses", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/deployments/{id}/statuses",
    validator: validate_GetReposOwnerRepoDeploymentsIdStatuses_28376658,
    base: "/", url: url_GetReposOwnerRepoDeploymentsIdStatuses_28376659,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDownloads_28376681 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoDownloads_28376683(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/downloads")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDownloads_28376682(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deprecated. List downloads for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376684 = path.getOrDefault("owner")
  valid_28376684 = validateParameter(valid_28376684, JString, required = true,
                                   default = nil)
  if valid_28376684 != nil:
    section.add "owner", valid_28376684
  var valid_28376685 = path.getOrDefault("repo")
  valid_28376685 = validateParameter(valid_28376685, JString, required = true,
                                   default = nil)
  if valid_28376685 != nil:
    section.add "repo", valid_28376685
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376686 = header.getOrDefault("Accept")
  valid_28376686 = validateParameter(valid_28376686, JString, required = false,
                                   default = nil)
  if valid_28376686 != nil:
    section.add "Accept", valid_28376686
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376687: Call_GetReposOwnerRepoDownloads_28376681; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deprecated. List downloads for a repository.
  ## 
  let valid = call_28376687.validator(path, query, header, formData, body)
  let scheme = call_28376687.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376687.url(scheme.get, call_28376687.host, call_28376687.base,
                           call_28376687.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376687, url, valid)

proc call*(call_28376688: Call_GetReposOwnerRepoDownloads_28376681; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDownloads
  ## Deprecated. List downloads for a repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376689 = newJObject()
  var header_28376690 = newJObject()
  add(path_28376689, "owner", newJString(owner))
  add(header_28376690, "Accept", newJString(Accept))
  add(path_28376689, "repo", newJString(repo))
  result = call_28376688.call(path_28376689, nil, header_28376690, nil, nil)

var getReposOwnerRepoDownloads* = Call_GetReposOwnerRepoDownloads_28376681(
    name: "getReposOwnerRepoDownloads", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/downloads",
    validator: validate_GetReposOwnerRepoDownloads_28376682, base: "/",
    url: url_GetReposOwnerRepoDownloads_28376683, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDownloadsDownloadId_28376691 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoDownloadsDownloadId_28376693(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "downloadId" in path, "`downloadId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/downloads/"),
               (kind: VariableSegment, value: "downloadId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDownloadsDownloadId_28376692(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deprecated. Get a single download.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   downloadId: JInt (required)
  ##             : Id of download.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376694 = path.getOrDefault("owner")
  valid_28376694 = validateParameter(valid_28376694, JString, required = true,
                                   default = nil)
  if valid_28376694 != nil:
    section.add "owner", valid_28376694
  var valid_28376695 = path.getOrDefault("repo")
  valid_28376695 = validateParameter(valid_28376695, JString, required = true,
                                   default = nil)
  if valid_28376695 != nil:
    section.add "repo", valid_28376695
  var valid_28376696 = path.getOrDefault("downloadId")
  valid_28376696 = validateParameter(valid_28376696, JInt, required = true,
                                   default = nil)
  if valid_28376696 != nil:
    section.add "downloadId", valid_28376696
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376697 = header.getOrDefault("Accept")
  valid_28376697 = validateParameter(valid_28376697, JString, required = false,
                                   default = nil)
  if valid_28376697 != nil:
    section.add "Accept", valid_28376697
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376698: Call_GetReposOwnerRepoDownloadsDownloadId_28376691;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deprecated. Get a single download.
  ## 
  let valid = call_28376698.validator(path, query, header, formData, body)
  let scheme = call_28376698.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376698.url(scheme.get, call_28376698.host, call_28376698.base,
                           call_28376698.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376698, url, valid)

proc call*(call_28376699: Call_GetReposOwnerRepoDownloadsDownloadId_28376691;
          owner: string; repo: string; downloadId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDownloadsDownloadId
  ## Deprecated. Get a single download.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   downloadId: int (required)
  ##             : Id of download.
  var path_28376700 = newJObject()
  var header_28376701 = newJObject()
  add(path_28376700, "owner", newJString(owner))
  add(header_28376701, "Accept", newJString(Accept))
  add(path_28376700, "repo", newJString(repo))
  add(path_28376700, "downloadId", newJInt(downloadId))
  result = call_28376699.call(path_28376700, nil, header_28376701, nil, nil)

var getReposOwnerRepoDownloadsDownloadId* = Call_GetReposOwnerRepoDownloadsDownloadId_28376691(
    name: "getReposOwnerRepoDownloadsDownloadId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/downloads/{downloadId}",
    validator: validate_GetReposOwnerRepoDownloadsDownloadId_28376692, base: "/",
    url: url_GetReposOwnerRepoDownloadsDownloadId_28376693,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoDownloadsDownloadId_28376702 = ref object of OpenApiRestCall_28375350
proc url_DeleteReposOwnerRepoDownloadsDownloadId_28376704(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "downloadId" in path, "`downloadId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/downloads/"),
               (kind: VariableSegment, value: "downloadId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoDownloadsDownloadId_28376703(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deprecated. Delete a download.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   downloadId: JInt (required)
  ##             : Id of download.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376705 = path.getOrDefault("owner")
  valid_28376705 = validateParameter(valid_28376705, JString, required = true,
                                   default = nil)
  if valid_28376705 != nil:
    section.add "owner", valid_28376705
  var valid_28376706 = path.getOrDefault("repo")
  valid_28376706 = validateParameter(valid_28376706, JString, required = true,
                                   default = nil)
  if valid_28376706 != nil:
    section.add "repo", valid_28376706
  var valid_28376707 = path.getOrDefault("downloadId")
  valid_28376707 = validateParameter(valid_28376707, JInt, required = true,
                                   default = nil)
  if valid_28376707 != nil:
    section.add "downloadId", valid_28376707
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376708 = header.getOrDefault("Accept")
  valid_28376708 = validateParameter(valid_28376708, JString, required = false,
                                   default = nil)
  if valid_28376708 != nil:
    section.add "Accept", valid_28376708
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376709: Call_DeleteReposOwnerRepoDownloadsDownloadId_28376702;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deprecated. Delete a download.
  ## 
  let valid = call_28376709.validator(path, query, header, formData, body)
  let scheme = call_28376709.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376709.url(scheme.get, call_28376709.host, call_28376709.base,
                           call_28376709.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376709, url, valid)

proc call*(call_28376710: Call_DeleteReposOwnerRepoDownloadsDownloadId_28376702;
          owner: string; repo: string; downloadId: int; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoDownloadsDownloadId
  ## Deprecated. Delete a download.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   downloadId: int (required)
  ##             : Id of download.
  var path_28376711 = newJObject()
  var header_28376712 = newJObject()
  add(path_28376711, "owner", newJString(owner))
  add(header_28376712, "Accept", newJString(Accept))
  add(path_28376711, "repo", newJString(repo))
  add(path_28376711, "downloadId", newJInt(downloadId))
  result = call_28376710.call(path_28376711, nil, header_28376712, nil, nil)

var deleteReposOwnerRepoDownloadsDownloadId* = Call_DeleteReposOwnerRepoDownloadsDownloadId_28376702(
    name: "deleteReposOwnerRepoDownloadsDownloadId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/downloads/{downloadId}",
    validator: validate_DeleteReposOwnerRepoDownloadsDownloadId_28376703,
    base: "/", url: url_DeleteReposOwnerRepoDownloadsDownloadId_28376704,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoEvents_28376713 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoEvents_28376715(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoEvents_28376714(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get list of repository events.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376716 = path.getOrDefault("owner")
  valid_28376716 = validateParameter(valid_28376716, JString, required = true,
                                   default = nil)
  if valid_28376716 != nil:
    section.add "owner", valid_28376716
  var valid_28376717 = path.getOrDefault("repo")
  valid_28376717 = validateParameter(valid_28376717, JString, required = true,
                                   default = nil)
  if valid_28376717 != nil:
    section.add "repo", valid_28376717
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376718 = header.getOrDefault("Accept")
  valid_28376718 = validateParameter(valid_28376718, JString, required = false,
                                   default = nil)
  if valid_28376718 != nil:
    section.add "Accept", valid_28376718
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376719: Call_GetReposOwnerRepoEvents_28376713; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get list of repository events.
  ## 
  let valid = call_28376719.validator(path, query, header, formData, body)
  let scheme = call_28376719.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376719.url(scheme.get, call_28376719.host, call_28376719.base,
                           call_28376719.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376719, url, valid)

proc call*(call_28376720: Call_GetReposOwnerRepoEvents_28376713; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoEvents
  ## Get list of repository events.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376721 = newJObject()
  var header_28376722 = newJObject()
  add(path_28376721, "owner", newJString(owner))
  add(header_28376722, "Accept", newJString(Accept))
  add(path_28376721, "repo", newJString(repo))
  result = call_28376720.call(path_28376721, nil, header_28376722, nil, nil)

var getReposOwnerRepoEvents* = Call_GetReposOwnerRepoEvents_28376713(
    name: "getReposOwnerRepoEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/events",
    validator: validate_GetReposOwnerRepoEvents_28376714, base: "/",
    url: url_GetReposOwnerRepoEvents_28376715, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoForks_28376735 = ref object of OpenApiRestCall_28375350
proc url_PostReposOwnerRepoForks_28376737(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/forks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoForks_28376736(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a fork.
  ## Forking a Repository happens asynchronously. Therefore, you may have to wai
  ## a short period before accessing the git objects. If this takes longer than 5
  ## minutes, be sure to contact Support.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376738 = path.getOrDefault("owner")
  valid_28376738 = validateParameter(valid_28376738, JString, required = true,
                                   default = nil)
  if valid_28376738 != nil:
    section.add "owner", valid_28376738
  var valid_28376739 = path.getOrDefault("repo")
  valid_28376739 = validateParameter(valid_28376739, JString, required = true,
                                   default = nil)
  if valid_28376739 != nil:
    section.add "repo", valid_28376739
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376740 = header.getOrDefault("Accept")
  valid_28376740 = validateParameter(valid_28376740, JString, required = false,
                                   default = nil)
  if valid_28376740 != nil:
    section.add "Accept", valid_28376740
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28376742: Call_PostReposOwnerRepoForks_28376735; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a fork.
  ## Forking a Repository happens asynchronously. Therefore, you may have to wai
  ## a short period before accessing the git objects. If this takes longer than 5
  ## minutes, be sure to contact Support.
  ## 
  ## 
  let valid = call_28376742.validator(path, query, header, formData, body)
  let scheme = call_28376742.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376742.url(scheme.get, call_28376742.host, call_28376742.base,
                           call_28376742.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376742, url, valid)

proc call*(call_28376743: Call_PostReposOwnerRepoForks_28376735; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoForks
  ## Create a fork.
  ## Forking a Repository happens asynchronously. Therefore, you may have to wai
  ## a short period before accessing the git objects. If this takes longer than 5
  ## minutes, be sure to contact Support.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376744 = newJObject()
  var header_28376745 = newJObject()
  var body_28376746 = newJObject()
  add(path_28376744, "owner", newJString(owner))
  add(header_28376745, "Accept", newJString(Accept))
  if body != nil:
    body_28376746 = body
  add(path_28376744, "repo", newJString(repo))
  result = call_28376743.call(path_28376744, nil, header_28376745, nil, body_28376746)

var postReposOwnerRepoForks* = Call_PostReposOwnerRepoForks_28376735(
    name: "postReposOwnerRepoForks", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/forks",
    validator: validate_PostReposOwnerRepoForks_28376736, base: "/",
    url: url_PostReposOwnerRepoForks_28376737, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoForks_28376723 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoForks_28376725(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/forks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoForks_28376724(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List forks.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376726 = path.getOrDefault("owner")
  valid_28376726 = validateParameter(valid_28376726, JString, required = true,
                                   default = nil)
  if valid_28376726 != nil:
    section.add "owner", valid_28376726
  var valid_28376727 = path.getOrDefault("repo")
  valid_28376727 = validateParameter(valid_28376727, JString, required = true,
                                   default = nil)
  if valid_28376727 != nil:
    section.add "repo", valid_28376727
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  section = newJObject()
  var valid_28376728 = query.getOrDefault("sort")
  valid_28376728 = validateParameter(valid_28376728, JString, required = false,
                                   default = newJString("newes"))
  if valid_28376728 != nil:
    section.add "sort", valid_28376728
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376729 = header.getOrDefault("Accept")
  valid_28376729 = validateParameter(valid_28376729, JString, required = false,
                                   default = nil)
  if valid_28376729 != nil:
    section.add "Accept", valid_28376729
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376730: Call_GetReposOwnerRepoForks_28376723; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List forks.
  ## 
  let valid = call_28376730.validator(path, query, header, formData, body)
  let scheme = call_28376730.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376730.url(scheme.get, call_28376730.host, call_28376730.base,
                           call_28376730.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376730, url, valid)

proc call*(call_28376731: Call_GetReposOwnerRepoForks_28376723; owner: string;
          repo: string; Accept: string = ""; sort: string = "newes"): Recallable =
  ## getReposOwnerRepoForks
  ## List forks.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   sort: string
  var path_28376732 = newJObject()
  var query_28376733 = newJObject()
  var header_28376734 = newJObject()
  add(path_28376732, "owner", newJString(owner))
  add(header_28376734, "Accept", newJString(Accept))
  add(path_28376732, "repo", newJString(repo))
  add(query_28376733, "sort", newJString(sort))
  result = call_28376731.call(path_28376732, query_28376733, header_28376734, nil, nil)

var getReposOwnerRepoForks* = Call_GetReposOwnerRepoForks_28376723(
    name: "getReposOwnerRepoForks", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/forks",
    validator: validate_GetReposOwnerRepoForks_28376724, base: "/",
    url: url_GetReposOwnerRepoForks_28376725, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitBlobs_28376747 = ref object of OpenApiRestCall_28375350
proc url_PostReposOwnerRepoGitBlobs_28376749(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/blobs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitBlobs_28376748(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a Blob.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376750 = path.getOrDefault("owner")
  valid_28376750 = validateParameter(valid_28376750, JString, required = true,
                                   default = nil)
  if valid_28376750 != nil:
    section.add "owner", valid_28376750
  var valid_28376751 = path.getOrDefault("repo")
  valid_28376751 = validateParameter(valid_28376751, JString, required = true,
                                   default = nil)
  if valid_28376751 != nil:
    section.add "repo", valid_28376751
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376752 = header.getOrDefault("Accept")
  valid_28376752 = validateParameter(valid_28376752, JString, required = false,
                                   default = nil)
  if valid_28376752 != nil:
    section.add "Accept", valid_28376752
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28376754: Call_PostReposOwnerRepoGitBlobs_28376747; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a Blob.
  ## 
  let valid = call_28376754.validator(path, query, header, formData, body)
  let scheme = call_28376754.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376754.url(scheme.get, call_28376754.host, call_28376754.base,
                           call_28376754.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376754, url, valid)

proc call*(call_28376755: Call_PostReposOwnerRepoGitBlobs_28376747; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitBlobs
  ## Create a Blob.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376756 = newJObject()
  var header_28376757 = newJObject()
  var body_28376758 = newJObject()
  add(path_28376756, "owner", newJString(owner))
  add(header_28376757, "Accept", newJString(Accept))
  if body != nil:
    body_28376758 = body
  add(path_28376756, "repo", newJString(repo))
  result = call_28376755.call(path_28376756, nil, header_28376757, nil, body_28376758)

var postReposOwnerRepoGitBlobs* = Call_PostReposOwnerRepoGitBlobs_28376747(
    name: "postReposOwnerRepoGitBlobs", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/blobs",
    validator: validate_PostReposOwnerRepoGitBlobs_28376748, base: "/",
    url: url_PostReposOwnerRepoGitBlobs_28376749, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitBlobsShaCode_28376759 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoGitBlobsShaCode_28376761(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/blobs/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitBlobsShaCode_28376760(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a Blob.
  ## Since blobs can be any arbitrary binary data, the input and responses for
  ## the blob API takes an encoding parameter that can be either utf-8 or
  ## base64. If your data cannot be losslessly sent as a UTF-8 string, you can
  ## base64 encode it.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  ##          : SHA-1 code.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376762 = path.getOrDefault("owner")
  valid_28376762 = validateParameter(valid_28376762, JString, required = true,
                                   default = nil)
  if valid_28376762 != nil:
    section.add "owner", valid_28376762
  var valid_28376763 = path.getOrDefault("repo")
  valid_28376763 = validateParameter(valid_28376763, JString, required = true,
                                   default = nil)
  if valid_28376763 != nil:
    section.add "repo", valid_28376763
  var valid_28376764 = path.getOrDefault("shaCode")
  valid_28376764 = validateParameter(valid_28376764, JString, required = true,
                                   default = nil)
  if valid_28376764 != nil:
    section.add "shaCode", valid_28376764
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376765 = header.getOrDefault("Accept")
  valid_28376765 = validateParameter(valid_28376765, JString, required = false,
                                   default = nil)
  if valid_28376765 != nil:
    section.add "Accept", valid_28376765
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376766: Call_GetReposOwnerRepoGitBlobsShaCode_28376759;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a Blob.
  ## Since blobs can be any arbitrary binary data, the input and responses for
  ## the blob API takes an encoding parameter that can be either utf-8 or
  ## base64. If your data cannot be losslessly sent as a UTF-8 string, you can
  ## base64 encode it.
  ## 
  ## 
  let valid = call_28376766.validator(path, query, header, formData, body)
  let scheme = call_28376766.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376766.url(scheme.get, call_28376766.host, call_28376766.base,
                           call_28376766.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376766, url, valid)

proc call*(call_28376767: Call_GetReposOwnerRepoGitBlobsShaCode_28376759;
          owner: string; repo: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitBlobsShaCode
  ## Get a Blob.
  ## Since blobs can be any arbitrary binary data, the input and responses for
  ## the blob API takes an encoding parameter that can be either utf-8 or
  ## base64. If your data cannot be losslessly sent as a UTF-8 string, you can
  ## base64 encode it.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  ##          : SHA-1 code.
  var path_28376768 = newJObject()
  var header_28376769 = newJObject()
  add(path_28376768, "owner", newJString(owner))
  add(header_28376769, "Accept", newJString(Accept))
  add(path_28376768, "repo", newJString(repo))
  add(path_28376768, "shaCode", newJString(shaCode))
  result = call_28376767.call(path_28376768, nil, header_28376769, nil, nil)

var getReposOwnerRepoGitBlobsShaCode* = Call_GetReposOwnerRepoGitBlobsShaCode_28376759(
    name: "getReposOwnerRepoGitBlobsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/blobs/{shaCode}",
    validator: validate_GetReposOwnerRepoGitBlobsShaCode_28376760, base: "/",
    url: url_GetReposOwnerRepoGitBlobsShaCode_28376761, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitCommits_28376770 = ref object of OpenApiRestCall_28375350
proc url_PostReposOwnerRepoGitCommits_28376772(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/commits")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitCommits_28376771(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a Commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376773 = path.getOrDefault("owner")
  valid_28376773 = validateParameter(valid_28376773, JString, required = true,
                                   default = nil)
  if valid_28376773 != nil:
    section.add "owner", valid_28376773
  var valid_28376774 = path.getOrDefault("repo")
  valid_28376774 = validateParameter(valid_28376774, JString, required = true,
                                   default = nil)
  if valid_28376774 != nil:
    section.add "repo", valid_28376774
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376775 = header.getOrDefault("Accept")
  valid_28376775 = validateParameter(valid_28376775, JString, required = false,
                                   default = nil)
  if valid_28376775 != nil:
    section.add "Accept", valid_28376775
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28376777: Call_PostReposOwnerRepoGitCommits_28376770;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Create a Commit.
  ## 
  let valid = call_28376777.validator(path, query, header, formData, body)
  let scheme = call_28376777.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376777.url(scheme.get, call_28376777.host, call_28376777.base,
                           call_28376777.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376777, url, valid)

proc call*(call_28376778: Call_PostReposOwnerRepoGitCommits_28376770;
          owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitCommits
  ## Create a Commit.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376779 = newJObject()
  var header_28376780 = newJObject()
  var body_28376781 = newJObject()
  add(path_28376779, "owner", newJString(owner))
  add(header_28376780, "Accept", newJString(Accept))
  if body != nil:
    body_28376781 = body
  add(path_28376779, "repo", newJString(repo))
  result = call_28376778.call(path_28376779, nil, header_28376780, nil, body_28376781)

var postReposOwnerRepoGitCommits* = Call_PostReposOwnerRepoGitCommits_28376770(
    name: "postReposOwnerRepoGitCommits", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/commits",
    validator: validate_PostReposOwnerRepoGitCommits_28376771, base: "/",
    url: url_PostReposOwnerRepoGitCommits_28376772, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitCommitsShaCode_28376782 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoGitCommitsShaCode_28376784(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/commits/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitCommitsShaCode_28376783(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a Commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  ##          : SHA-1 code.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376785 = path.getOrDefault("owner")
  valid_28376785 = validateParameter(valid_28376785, JString, required = true,
                                   default = nil)
  if valid_28376785 != nil:
    section.add "owner", valid_28376785
  var valid_28376786 = path.getOrDefault("repo")
  valid_28376786 = validateParameter(valid_28376786, JString, required = true,
                                   default = nil)
  if valid_28376786 != nil:
    section.add "repo", valid_28376786
  var valid_28376787 = path.getOrDefault("shaCode")
  valid_28376787 = validateParameter(valid_28376787, JString, required = true,
                                   default = nil)
  if valid_28376787 != nil:
    section.add "shaCode", valid_28376787
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376788 = header.getOrDefault("Accept")
  valid_28376788 = validateParameter(valid_28376788, JString, required = false,
                                   default = nil)
  if valid_28376788 != nil:
    section.add "Accept", valid_28376788
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376789: Call_GetReposOwnerRepoGitCommitsShaCode_28376782;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a Commit.
  ## 
  let valid = call_28376789.validator(path, query, header, formData, body)
  let scheme = call_28376789.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376789.url(scheme.get, call_28376789.host, call_28376789.base,
                           call_28376789.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376789, url, valid)

proc call*(call_28376790: Call_GetReposOwnerRepoGitCommitsShaCode_28376782;
          owner: string; repo: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitCommitsShaCode
  ## Get a Commit.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  ##          : SHA-1 code.
  var path_28376791 = newJObject()
  var header_28376792 = newJObject()
  add(path_28376791, "owner", newJString(owner))
  add(header_28376792, "Accept", newJString(Accept))
  add(path_28376791, "repo", newJString(repo))
  add(path_28376791, "shaCode", newJString(shaCode))
  result = call_28376790.call(path_28376791, nil, header_28376792, nil, nil)

var getReposOwnerRepoGitCommitsShaCode* = Call_GetReposOwnerRepoGitCommitsShaCode_28376782(
    name: "getReposOwnerRepoGitCommitsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/commits/{shaCode}",
    validator: validate_GetReposOwnerRepoGitCommitsShaCode_28376783, base: "/",
    url: url_GetReposOwnerRepoGitCommitsShaCode_28376784, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitRefs_28376803 = ref object of OpenApiRestCall_28375350
proc url_PostReposOwnerRepoGitRefs_28376805(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitRefs_28376804(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a Reference
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376806 = path.getOrDefault("owner")
  valid_28376806 = validateParameter(valid_28376806, JString, required = true,
                                   default = nil)
  if valid_28376806 != nil:
    section.add "owner", valid_28376806
  var valid_28376807 = path.getOrDefault("repo")
  valid_28376807 = validateParameter(valid_28376807, JString, required = true,
                                   default = nil)
  if valid_28376807 != nil:
    section.add "repo", valid_28376807
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376808 = header.getOrDefault("Accept")
  valid_28376808 = validateParameter(valid_28376808, JString, required = false,
                                   default = nil)
  if valid_28376808 != nil:
    section.add "Accept", valid_28376808
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28376810: Call_PostReposOwnerRepoGitRefs_28376803; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a Reference
  ## 
  let valid = call_28376810.validator(path, query, header, formData, body)
  let scheme = call_28376810.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376810.url(scheme.get, call_28376810.host, call_28376810.base,
                           call_28376810.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376810, url, valid)

proc call*(call_28376811: Call_PostReposOwnerRepoGitRefs_28376803; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitRefs
  ## Create a Reference
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376812 = newJObject()
  var header_28376813 = newJObject()
  var body_28376814 = newJObject()
  add(path_28376812, "owner", newJString(owner))
  add(header_28376813, "Accept", newJString(Accept))
  if body != nil:
    body_28376814 = body
  add(path_28376812, "repo", newJString(repo))
  result = call_28376811.call(path_28376812, nil, header_28376813, nil, body_28376814)

var postReposOwnerRepoGitRefs* = Call_PostReposOwnerRepoGitRefs_28376803(
    name: "postReposOwnerRepoGitRefs", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs",
    validator: validate_PostReposOwnerRepoGitRefs_28376804, base: "/",
    url: url_PostReposOwnerRepoGitRefs_28376805, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitRefs_28376793 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoGitRefs_28376795(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitRefs_28376794(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get all References
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376796 = path.getOrDefault("owner")
  valid_28376796 = validateParameter(valid_28376796, JString, required = true,
                                   default = nil)
  if valid_28376796 != nil:
    section.add "owner", valid_28376796
  var valid_28376797 = path.getOrDefault("repo")
  valid_28376797 = validateParameter(valid_28376797, JString, required = true,
                                   default = nil)
  if valid_28376797 != nil:
    section.add "repo", valid_28376797
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376798 = header.getOrDefault("Accept")
  valid_28376798 = validateParameter(valid_28376798, JString, required = false,
                                   default = nil)
  if valid_28376798 != nil:
    section.add "Accept", valid_28376798
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376799: Call_GetReposOwnerRepoGitRefs_28376793; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get all References
  ## 
  let valid = call_28376799.validator(path, query, header, formData, body)
  let scheme = call_28376799.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376799.url(scheme.get, call_28376799.host, call_28376799.base,
                           call_28376799.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376799, url, valid)

proc call*(call_28376800: Call_GetReposOwnerRepoGitRefs_28376793; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitRefs
  ## Get all References
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376801 = newJObject()
  var header_28376802 = newJObject()
  add(path_28376801, "owner", newJString(owner))
  add(header_28376802, "Accept", newJString(Accept))
  add(path_28376801, "repo", newJString(repo))
  result = call_28376800.call(path_28376801, nil, header_28376802, nil, nil)

var getReposOwnerRepoGitRefs* = Call_GetReposOwnerRepoGitRefs_28376793(
    name: "getReposOwnerRepoGitRefs", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs",
    validator: validate_GetReposOwnerRepoGitRefs_28376794, base: "/",
    url: url_GetReposOwnerRepoGitRefs_28376795, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitRefsRef_28376815 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoGitRefsRef_28376817(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitRefsRef_28376816(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a Reference
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   ref: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376818 = path.getOrDefault("owner")
  valid_28376818 = validateParameter(valid_28376818, JString, required = true,
                                   default = nil)
  if valid_28376818 != nil:
    section.add "owner", valid_28376818
  var valid_28376819 = path.getOrDefault("ref")
  valid_28376819 = validateParameter(valid_28376819, JString, required = true,
                                   default = nil)
  if valid_28376819 != nil:
    section.add "ref", valid_28376819
  var valid_28376820 = path.getOrDefault("repo")
  valid_28376820 = validateParameter(valid_28376820, JString, required = true,
                                   default = nil)
  if valid_28376820 != nil:
    section.add "repo", valid_28376820
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376821 = header.getOrDefault("Accept")
  valid_28376821 = validateParameter(valid_28376821, JString, required = false,
                                   default = nil)
  if valid_28376821 != nil:
    section.add "Accept", valid_28376821
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376822: Call_GetReposOwnerRepoGitRefsRef_28376815;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a Reference
  ## 
  let valid = call_28376822.validator(path, query, header, formData, body)
  let scheme = call_28376822.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376822.url(scheme.get, call_28376822.host, call_28376822.base,
                           call_28376822.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376822, url, valid)

proc call*(call_28376823: Call_GetReposOwnerRepoGitRefsRef_28376815; owner: string;
          `ref`: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitRefsRef
  ## Get a Reference
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   ref: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376824 = newJObject()
  var header_28376825 = newJObject()
  add(path_28376824, "owner", newJString(owner))
  add(path_28376824, "ref", newJString(`ref`))
  add(header_28376825, "Accept", newJString(Accept))
  add(path_28376824, "repo", newJString(repo))
  result = call_28376823.call(path_28376824, nil, header_28376825, nil, nil)

var getReposOwnerRepoGitRefsRef* = Call_GetReposOwnerRepoGitRefsRef_28376815(
    name: "getReposOwnerRepoGitRefsRef", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs/{ref}",
    validator: validate_GetReposOwnerRepoGitRefsRef_28376816, base: "/",
    url: url_GetReposOwnerRepoGitRefsRef_28376817, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoGitRefsRef_28376837 = ref object of OpenApiRestCall_28375350
proc url_PatchReposOwnerRepoGitRefsRef_28376839(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoGitRefsRef_28376838(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Update a Reference
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   ref: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376840 = path.getOrDefault("owner")
  valid_28376840 = validateParameter(valid_28376840, JString, required = true,
                                   default = nil)
  if valid_28376840 != nil:
    section.add "owner", valid_28376840
  var valid_28376841 = path.getOrDefault("ref")
  valid_28376841 = validateParameter(valid_28376841, JString, required = true,
                                   default = nil)
  if valid_28376841 != nil:
    section.add "ref", valid_28376841
  var valid_28376842 = path.getOrDefault("repo")
  valid_28376842 = validateParameter(valid_28376842, JString, required = true,
                                   default = nil)
  if valid_28376842 != nil:
    section.add "repo", valid_28376842
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376843 = header.getOrDefault("Accept")
  valid_28376843 = validateParameter(valid_28376843, JString, required = false,
                                   default = nil)
  if valid_28376843 != nil:
    section.add "Accept", valid_28376843
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28376845: Call_PatchReposOwnerRepoGitRefsRef_28376837;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Update a Reference
  ## 
  let valid = call_28376845.validator(path, query, header, formData, body)
  let scheme = call_28376845.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376845.url(scheme.get, call_28376845.host, call_28376845.base,
                           call_28376845.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376845, url, valid)

proc call*(call_28376846: Call_PatchReposOwnerRepoGitRefsRef_28376837;
          owner: string; `ref`: string; body: JsonNode; repo: string;
          Accept: string = ""): Recallable =
  ## patchReposOwnerRepoGitRefsRef
  ## Update a Reference
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   ref: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376847 = newJObject()
  var header_28376848 = newJObject()
  var body_28376849 = newJObject()
  add(path_28376847, "owner", newJString(owner))
  add(path_28376847, "ref", newJString(`ref`))
  add(header_28376848, "Accept", newJString(Accept))
  if body != nil:
    body_28376849 = body
  add(path_28376847, "repo", newJString(repo))
  result = call_28376846.call(path_28376847, nil, header_28376848, nil, body_28376849)

var patchReposOwnerRepoGitRefsRef* = Call_PatchReposOwnerRepoGitRefsRef_28376837(
    name: "patchReposOwnerRepoGitRefsRef", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs/{ref}",
    validator: validate_PatchReposOwnerRepoGitRefsRef_28376838, base: "/",
    url: url_PatchReposOwnerRepoGitRefsRef_28376839, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoGitRefsRef_28376826 = ref object of OpenApiRestCall_28375350
proc url_DeleteReposOwnerRepoGitRefsRef_28376828(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoGitRefsRef_28376827(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a Reference
  ## Example: Deleting a branch: DELETE /repos/octocat/Hello-World/git/refs/heads/feature-a
  ## Example: Deleting a tag:        DELETE /repos/octocat/Hello-World/git/refs/tags/v1.0
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   ref: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376829 = path.getOrDefault("owner")
  valid_28376829 = validateParameter(valid_28376829, JString, required = true,
                                   default = nil)
  if valid_28376829 != nil:
    section.add "owner", valid_28376829
  var valid_28376830 = path.getOrDefault("ref")
  valid_28376830 = validateParameter(valid_28376830, JString, required = true,
                                   default = nil)
  if valid_28376830 != nil:
    section.add "ref", valid_28376830
  var valid_28376831 = path.getOrDefault("repo")
  valid_28376831 = validateParameter(valid_28376831, JString, required = true,
                                   default = nil)
  if valid_28376831 != nil:
    section.add "repo", valid_28376831
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376832 = header.getOrDefault("Accept")
  valid_28376832 = validateParameter(valid_28376832, JString, required = false,
                                   default = nil)
  if valid_28376832 != nil:
    section.add "Accept", valid_28376832
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376833: Call_DeleteReposOwnerRepoGitRefsRef_28376826;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a Reference
  ## Example: Deleting a branch: DELETE /repos/octocat/Hello-World/git/refs/heads/feature-a
  ## Example: Deleting a tag:        DELETE /repos/octocat/Hello-World/git/refs/tags/v1.0
  ## 
  ## 
  let valid = call_28376833.validator(path, query, header, formData, body)
  let scheme = call_28376833.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376833.url(scheme.get, call_28376833.host, call_28376833.base,
                           call_28376833.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376833, url, valid)

proc call*(call_28376834: Call_DeleteReposOwnerRepoGitRefsRef_28376826;
          owner: string; `ref`: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoGitRefsRef
  ## Delete a Reference
  ## Example: Deleting a branch: DELETE /repos/octocat/Hello-World/git/refs/heads/feature-a
  ## Example: Deleting a tag:        DELETE /repos/octocat/Hello-World/git/refs/tags/v1.0
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   ref: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376835 = newJObject()
  var header_28376836 = newJObject()
  add(path_28376835, "owner", newJString(owner))
  add(path_28376835, "ref", newJString(`ref`))
  add(header_28376836, "Accept", newJString(Accept))
  add(path_28376835, "repo", newJString(repo))
  result = call_28376834.call(path_28376835, nil, header_28376836, nil, nil)

var deleteReposOwnerRepoGitRefsRef* = Call_DeleteReposOwnerRepoGitRefsRef_28376826(
    name: "deleteReposOwnerRepoGitRefsRef", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs/{ref}",
    validator: validate_DeleteReposOwnerRepoGitRefsRef_28376827, base: "/",
    url: url_DeleteReposOwnerRepoGitRefsRef_28376828, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitTags_28376850 = ref object of OpenApiRestCall_28375350
proc url_PostReposOwnerRepoGitTags_28376852(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/tags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitTags_28376851(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a Tag Object.
  ## Note that creating a tag object does not create the reference that makes a
  ## tag in Git. If you want to create an annotated tag in Git, you have to do
  ## this call to create the tag object, and then create the refs/tags/[tag]
  ## reference. If you want to create a lightweight tag, you only have to create
  ## the tag reference - this call would be unnecessary.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376853 = path.getOrDefault("owner")
  valid_28376853 = validateParameter(valid_28376853, JString, required = true,
                                   default = nil)
  if valid_28376853 != nil:
    section.add "owner", valid_28376853
  var valid_28376854 = path.getOrDefault("repo")
  valid_28376854 = validateParameter(valid_28376854, JString, required = true,
                                   default = nil)
  if valid_28376854 != nil:
    section.add "repo", valid_28376854
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376855 = header.getOrDefault("Accept")
  valid_28376855 = validateParameter(valid_28376855, JString, required = false,
                                   default = nil)
  if valid_28376855 != nil:
    section.add "Accept", valid_28376855
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28376857: Call_PostReposOwnerRepoGitTags_28376850; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a Tag Object.
  ## Note that creating a tag object does not create the reference that makes a
  ## tag in Git. If you want to create an annotated tag in Git, you have to do
  ## this call to create the tag object, and then create the refs/tags/[tag]
  ## reference. If you want to create a lightweight tag, you only have to create
  ## the tag reference - this call would be unnecessary.
  ## 
  ## 
  let valid = call_28376857.validator(path, query, header, formData, body)
  let scheme = call_28376857.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376857.url(scheme.get, call_28376857.host, call_28376857.base,
                           call_28376857.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376857, url, valid)

proc call*(call_28376858: Call_PostReposOwnerRepoGitTags_28376850; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitTags
  ## Create a Tag Object.
  ## Note that creating a tag object does not create the reference that makes a
  ## tag in Git. If you want to create an annotated tag in Git, you have to do
  ## this call to create the tag object, and then create the refs/tags/[tag]
  ## reference. If you want to create a lightweight tag, you only have to create
  ## the tag reference - this call would be unnecessary.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376859 = newJObject()
  var header_28376860 = newJObject()
  var body_28376861 = newJObject()
  add(path_28376859, "owner", newJString(owner))
  add(header_28376860, "Accept", newJString(Accept))
  if body != nil:
    body_28376861 = body
  add(path_28376859, "repo", newJString(repo))
  result = call_28376858.call(path_28376859, nil, header_28376860, nil, body_28376861)

var postReposOwnerRepoGitTags* = Call_PostReposOwnerRepoGitTags_28376850(
    name: "postReposOwnerRepoGitTags", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/tags",
    validator: validate_PostReposOwnerRepoGitTags_28376851, base: "/",
    url: url_PostReposOwnerRepoGitTags_28376852, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitTagsShaCode_28376862 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoGitTagsShaCode_28376864(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/tags/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitTagsShaCode_28376863(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a Tag.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376865 = path.getOrDefault("owner")
  valid_28376865 = validateParameter(valid_28376865, JString, required = true,
                                   default = nil)
  if valid_28376865 != nil:
    section.add "owner", valid_28376865
  var valid_28376866 = path.getOrDefault("repo")
  valid_28376866 = validateParameter(valid_28376866, JString, required = true,
                                   default = nil)
  if valid_28376866 != nil:
    section.add "repo", valid_28376866
  var valid_28376867 = path.getOrDefault("shaCode")
  valid_28376867 = validateParameter(valid_28376867, JString, required = true,
                                   default = nil)
  if valid_28376867 != nil:
    section.add "shaCode", valid_28376867
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376868 = header.getOrDefault("Accept")
  valid_28376868 = validateParameter(valid_28376868, JString, required = false,
                                   default = nil)
  if valid_28376868 != nil:
    section.add "Accept", valid_28376868
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376869: Call_GetReposOwnerRepoGitTagsShaCode_28376862;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a Tag.
  ## 
  let valid = call_28376869.validator(path, query, header, formData, body)
  let scheme = call_28376869.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376869.url(scheme.get, call_28376869.host, call_28376869.base,
                           call_28376869.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376869, url, valid)

proc call*(call_28376870: Call_GetReposOwnerRepoGitTagsShaCode_28376862;
          owner: string; repo: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitTagsShaCode
  ## Get a Tag.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  var path_28376871 = newJObject()
  var header_28376872 = newJObject()
  add(path_28376871, "owner", newJString(owner))
  add(header_28376872, "Accept", newJString(Accept))
  add(path_28376871, "repo", newJString(repo))
  add(path_28376871, "shaCode", newJString(shaCode))
  result = call_28376870.call(path_28376871, nil, header_28376872, nil, nil)

var getReposOwnerRepoGitTagsShaCode* = Call_GetReposOwnerRepoGitTagsShaCode_28376862(
    name: "getReposOwnerRepoGitTagsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/tags/{shaCode}",
    validator: validate_GetReposOwnerRepoGitTagsShaCode_28376863, base: "/",
    url: url_GetReposOwnerRepoGitTagsShaCode_28376864, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitTrees_28376873 = ref object of OpenApiRestCall_28375350
proc url_PostReposOwnerRepoGitTrees_28376875(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/trees")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitTrees_28376874(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a Tree.
  ## The tree creation API will take nested entries as well. If both a tree and
  ## a nested path modifying that tree are specified, it will overwrite the
  ## contents of that tree with the new path contents and write a new tree out.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376876 = path.getOrDefault("owner")
  valid_28376876 = validateParameter(valid_28376876, JString, required = true,
                                   default = nil)
  if valid_28376876 != nil:
    section.add "owner", valid_28376876
  var valid_28376877 = path.getOrDefault("repo")
  valid_28376877 = validateParameter(valid_28376877, JString, required = true,
                                   default = nil)
  if valid_28376877 != nil:
    section.add "repo", valid_28376877
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376878 = header.getOrDefault("Accept")
  valid_28376878 = validateParameter(valid_28376878, JString, required = false,
                                   default = nil)
  if valid_28376878 != nil:
    section.add "Accept", valid_28376878
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28376880: Call_PostReposOwnerRepoGitTrees_28376873; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a Tree.
  ## The tree creation API will take nested entries as well. If both a tree and
  ## a nested path modifying that tree are specified, it will overwrite the
  ## contents of that tree with the new path contents and write a new tree out.
  ## 
  ## 
  let valid = call_28376880.validator(path, query, header, formData, body)
  let scheme = call_28376880.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376880.url(scheme.get, call_28376880.host, call_28376880.base,
                           call_28376880.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376880, url, valid)

proc call*(call_28376881: Call_PostReposOwnerRepoGitTrees_28376873; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitTrees
  ## Create a Tree.
  ## The tree creation API will take nested entries as well. If both a tree and
  ## a nested path modifying that tree are specified, it will overwrite the
  ## contents of that tree with the new path contents and write a new tree out.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376882 = newJObject()
  var header_28376883 = newJObject()
  var body_28376884 = newJObject()
  add(path_28376882, "owner", newJString(owner))
  add(header_28376883, "Accept", newJString(Accept))
  if body != nil:
    body_28376884 = body
  add(path_28376882, "repo", newJString(repo))
  result = call_28376881.call(path_28376882, nil, header_28376883, nil, body_28376884)

var postReposOwnerRepoGitTrees* = Call_PostReposOwnerRepoGitTrees_28376873(
    name: "postReposOwnerRepoGitTrees", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/trees",
    validator: validate_PostReposOwnerRepoGitTrees_28376874, base: "/",
    url: url_PostReposOwnerRepoGitTrees_28376875, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitTreesShaCode_28376885 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoGitTreesShaCode_28376887(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/trees/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitTreesShaCode_28376886(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a Tree.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  ##          : Tree SHA.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376888 = path.getOrDefault("owner")
  valid_28376888 = validateParameter(valid_28376888, JString, required = true,
                                   default = nil)
  if valid_28376888 != nil:
    section.add "owner", valid_28376888
  var valid_28376889 = path.getOrDefault("repo")
  valid_28376889 = validateParameter(valid_28376889, JString, required = true,
                                   default = nil)
  if valid_28376889 != nil:
    section.add "repo", valid_28376889
  var valid_28376890 = path.getOrDefault("shaCode")
  valid_28376890 = validateParameter(valid_28376890, JString, required = true,
                                   default = nil)
  if valid_28376890 != nil:
    section.add "shaCode", valid_28376890
  result.add "path", section
  ## parameters in `query` object:
  ##   recursive: JInt
  ##            : Get a Tree Recursively. (0 or 1)
  section = newJObject()
  var valid_28376891 = query.getOrDefault("recursive")
  valid_28376891 = validateParameter(valid_28376891, JInt, required = false,
                                   default = nil)
  if valid_28376891 != nil:
    section.add "recursive", valid_28376891
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376892 = header.getOrDefault("Accept")
  valid_28376892 = validateParameter(valid_28376892, JString, required = false,
                                   default = nil)
  if valid_28376892 != nil:
    section.add "Accept", valid_28376892
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376893: Call_GetReposOwnerRepoGitTreesShaCode_28376885;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a Tree.
  ## 
  let valid = call_28376893.validator(path, query, header, formData, body)
  let scheme = call_28376893.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376893.url(scheme.get, call_28376893.host, call_28376893.base,
                           call_28376893.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376893, url, valid)

proc call*(call_28376894: Call_GetReposOwnerRepoGitTreesShaCode_28376885;
          owner: string; repo: string; shaCode: string; recursive: int = 0;
          Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitTreesShaCode
  ## Get a Tree.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   recursive: int
  ##            : Get a Tree Recursively. (0 or 1)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  ##          : Tree SHA.
  var path_28376895 = newJObject()
  var query_28376896 = newJObject()
  var header_28376897 = newJObject()
  add(path_28376895, "owner", newJString(owner))
  add(query_28376896, "recursive", newJInt(recursive))
  add(header_28376897, "Accept", newJString(Accept))
  add(path_28376895, "repo", newJString(repo))
  add(path_28376895, "shaCode", newJString(shaCode))
  result = call_28376894.call(path_28376895, query_28376896, header_28376897, nil, nil)

var getReposOwnerRepoGitTreesShaCode* = Call_GetReposOwnerRepoGitTreesShaCode_28376885(
    name: "getReposOwnerRepoGitTreesShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/trees/{shaCode}",
    validator: validate_GetReposOwnerRepoGitTreesShaCode_28376886, base: "/",
    url: url_GetReposOwnerRepoGitTreesShaCode_28376887, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoHooks_28376908 = ref object of OpenApiRestCall_28375350
proc url_PostReposOwnerRepoHooks_28376910(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoHooks_28376909(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376911 = path.getOrDefault("owner")
  valid_28376911 = validateParameter(valid_28376911, JString, required = true,
                                   default = nil)
  if valid_28376911 != nil:
    section.add "owner", valid_28376911
  var valid_28376912 = path.getOrDefault("repo")
  valid_28376912 = validateParameter(valid_28376912, JString, required = true,
                                   default = nil)
  if valid_28376912 != nil:
    section.add "repo", valid_28376912
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376913 = header.getOrDefault("Accept")
  valid_28376913 = validateParameter(valid_28376913, JString, required = false,
                                   default = nil)
  if valid_28376913 != nil:
    section.add "Accept", valid_28376913
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28376915: Call_PostReposOwnerRepoHooks_28376908; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a hook.
  ## 
  let valid = call_28376915.validator(path, query, header, formData, body)
  let scheme = call_28376915.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376915.url(scheme.get, call_28376915.host, call_28376915.base,
                           call_28376915.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376915, url, valid)

proc call*(call_28376916: Call_PostReposOwnerRepoHooks_28376908; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoHooks
  ## Create a hook.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376917 = newJObject()
  var header_28376918 = newJObject()
  var body_28376919 = newJObject()
  add(path_28376917, "owner", newJString(owner))
  add(header_28376918, "Accept", newJString(Accept))
  if body != nil:
    body_28376919 = body
  add(path_28376917, "repo", newJString(repo))
  result = call_28376916.call(path_28376917, nil, header_28376918, nil, body_28376919)

var postReposOwnerRepoHooks* = Call_PostReposOwnerRepoHooks_28376908(
    name: "postReposOwnerRepoHooks", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks",
    validator: validate_PostReposOwnerRepoHooks_28376909, base: "/",
    url: url_PostReposOwnerRepoHooks_28376910, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoHooks_28376898 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoHooks_28376900(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoHooks_28376899(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get list of hooks.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376901 = path.getOrDefault("owner")
  valid_28376901 = validateParameter(valid_28376901, JString, required = true,
                                   default = nil)
  if valid_28376901 != nil:
    section.add "owner", valid_28376901
  var valid_28376902 = path.getOrDefault("repo")
  valid_28376902 = validateParameter(valid_28376902, JString, required = true,
                                   default = nil)
  if valid_28376902 != nil:
    section.add "repo", valid_28376902
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376903 = header.getOrDefault("Accept")
  valid_28376903 = validateParameter(valid_28376903, JString, required = false,
                                   default = nil)
  if valid_28376903 != nil:
    section.add "Accept", valid_28376903
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376904: Call_GetReposOwnerRepoHooks_28376898; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get list of hooks.
  ## 
  let valid = call_28376904.validator(path, query, header, formData, body)
  let scheme = call_28376904.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376904.url(scheme.get, call_28376904.host, call_28376904.base,
                           call_28376904.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376904, url, valid)

proc call*(call_28376905: Call_GetReposOwnerRepoHooks_28376898; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoHooks
  ## Get list of hooks.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376906 = newJObject()
  var header_28376907 = newJObject()
  add(path_28376906, "owner", newJString(owner))
  add(header_28376907, "Accept", newJString(Accept))
  add(path_28376906, "repo", newJString(repo))
  result = call_28376905.call(path_28376906, nil, header_28376907, nil, nil)

var getReposOwnerRepoHooks* = Call_GetReposOwnerRepoHooks_28376898(
    name: "getReposOwnerRepoHooks", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks",
    validator: validate_GetReposOwnerRepoHooks_28376899, base: "/",
    url: url_GetReposOwnerRepoHooks_28376900, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoHooksHookId_28376920 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoHooksHookId_28376922(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hookId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoHooksHookId_28376921(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get single hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   hookId: JInt (required)
  ##         : Id of hook.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376923 = path.getOrDefault("owner")
  valid_28376923 = validateParameter(valid_28376923, JString, required = true,
                                   default = nil)
  if valid_28376923 != nil:
    section.add "owner", valid_28376923
  var valid_28376924 = path.getOrDefault("repo")
  valid_28376924 = validateParameter(valid_28376924, JString, required = true,
                                   default = nil)
  if valid_28376924 != nil:
    section.add "repo", valid_28376924
  var valid_28376925 = path.getOrDefault("hookId")
  valid_28376925 = validateParameter(valid_28376925, JInt, required = true,
                                   default = nil)
  if valid_28376925 != nil:
    section.add "hookId", valid_28376925
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376926 = header.getOrDefault("Accept")
  valid_28376926 = validateParameter(valid_28376926, JString, required = false,
                                   default = nil)
  if valid_28376926 != nil:
    section.add "Accept", valid_28376926
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376927: Call_GetReposOwnerRepoHooksHookId_28376920;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get single hook.
  ## 
  let valid = call_28376927.validator(path, query, header, formData, body)
  let scheme = call_28376927.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376927.url(scheme.get, call_28376927.host, call_28376927.base,
                           call_28376927.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376927, url, valid)

proc call*(call_28376928: Call_GetReposOwnerRepoHooksHookId_28376920;
          owner: string; repo: string; hookId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoHooksHookId
  ## Get single hook.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   hookId: int (required)
  ##         : Id of hook.
  var path_28376929 = newJObject()
  var header_28376930 = newJObject()
  add(path_28376929, "owner", newJString(owner))
  add(header_28376930, "Accept", newJString(Accept))
  add(path_28376929, "repo", newJString(repo))
  add(path_28376929, "hookId", newJInt(hookId))
  result = call_28376928.call(path_28376929, nil, header_28376930, nil, nil)

var getReposOwnerRepoHooksHookId* = Call_GetReposOwnerRepoHooksHookId_28376920(
    name: "getReposOwnerRepoHooksHookId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}",
    validator: validate_GetReposOwnerRepoHooksHookId_28376921, base: "/",
    url: url_GetReposOwnerRepoHooksHookId_28376922, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoHooksHookId_28376942 = ref object of OpenApiRestCall_28375350
proc url_PatchReposOwnerRepoHooksHookId_28376944(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hookId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoHooksHookId_28376943(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Edit a hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   hookId: JInt (required)
  ##         : Id of hook.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376945 = path.getOrDefault("owner")
  valid_28376945 = validateParameter(valid_28376945, JString, required = true,
                                   default = nil)
  if valid_28376945 != nil:
    section.add "owner", valid_28376945
  var valid_28376946 = path.getOrDefault("repo")
  valid_28376946 = validateParameter(valid_28376946, JString, required = true,
                                   default = nil)
  if valid_28376946 != nil:
    section.add "repo", valid_28376946
  var valid_28376947 = path.getOrDefault("hookId")
  valid_28376947 = validateParameter(valid_28376947, JInt, required = true,
                                   default = nil)
  if valid_28376947 != nil:
    section.add "hookId", valid_28376947
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376948 = header.getOrDefault("Accept")
  valid_28376948 = validateParameter(valid_28376948, JString, required = false,
                                   default = nil)
  if valid_28376948 != nil:
    section.add "Accept", valid_28376948
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28376950: Call_PatchReposOwnerRepoHooksHookId_28376942;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Edit a hook.
  ## 
  let valid = call_28376950.validator(path, query, header, formData, body)
  let scheme = call_28376950.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376950.url(scheme.get, call_28376950.host, call_28376950.base,
                           call_28376950.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376950, url, valid)

proc call*(call_28376951: Call_PatchReposOwnerRepoHooksHookId_28376942;
          owner: string; body: JsonNode; repo: string; hookId: int; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoHooksHookId
  ## Edit a hook.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   hookId: int (required)
  ##         : Id of hook.
  var path_28376952 = newJObject()
  var header_28376953 = newJObject()
  var body_28376954 = newJObject()
  add(path_28376952, "owner", newJString(owner))
  add(header_28376953, "Accept", newJString(Accept))
  if body != nil:
    body_28376954 = body
  add(path_28376952, "repo", newJString(repo))
  add(path_28376952, "hookId", newJInt(hookId))
  result = call_28376951.call(path_28376952, nil, header_28376953, nil, body_28376954)

var patchReposOwnerRepoHooksHookId* = Call_PatchReposOwnerRepoHooksHookId_28376942(
    name: "patchReposOwnerRepoHooksHookId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}",
    validator: validate_PatchReposOwnerRepoHooksHookId_28376943, base: "/",
    url: url_PatchReposOwnerRepoHooksHookId_28376944, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoHooksHookId_28376931 = ref object of OpenApiRestCall_28375350
proc url_DeleteReposOwnerRepoHooksHookId_28376933(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hookId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoHooksHookId_28376932(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   hookId: JInt (required)
  ##         : Id of hook.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376934 = path.getOrDefault("owner")
  valid_28376934 = validateParameter(valid_28376934, JString, required = true,
                                   default = nil)
  if valid_28376934 != nil:
    section.add "owner", valid_28376934
  var valid_28376935 = path.getOrDefault("repo")
  valid_28376935 = validateParameter(valid_28376935, JString, required = true,
                                   default = nil)
  if valid_28376935 != nil:
    section.add "repo", valid_28376935
  var valid_28376936 = path.getOrDefault("hookId")
  valid_28376936 = validateParameter(valid_28376936, JInt, required = true,
                                   default = nil)
  if valid_28376936 != nil:
    section.add "hookId", valid_28376936
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376937 = header.getOrDefault("Accept")
  valid_28376937 = validateParameter(valid_28376937, JString, required = false,
                                   default = nil)
  if valid_28376937 != nil:
    section.add "Accept", valid_28376937
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376938: Call_DeleteReposOwnerRepoHooksHookId_28376931;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a hook.
  ## 
  let valid = call_28376938.validator(path, query, header, formData, body)
  let scheme = call_28376938.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376938.url(scheme.get, call_28376938.host, call_28376938.base,
                           call_28376938.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376938, url, valid)

proc call*(call_28376939: Call_DeleteReposOwnerRepoHooksHookId_28376931;
          owner: string; repo: string; hookId: int; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoHooksHookId
  ## Delete a hook.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   hookId: int (required)
  ##         : Id of hook.
  var path_28376940 = newJObject()
  var header_28376941 = newJObject()
  add(path_28376940, "owner", newJString(owner))
  add(header_28376941, "Accept", newJString(Accept))
  add(path_28376940, "repo", newJString(repo))
  add(path_28376940, "hookId", newJInt(hookId))
  result = call_28376939.call(path_28376940, nil, header_28376941, nil, nil)

var deleteReposOwnerRepoHooksHookId* = Call_DeleteReposOwnerRepoHooksHookId_28376931(
    name: "deleteReposOwnerRepoHooksHookId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}",
    validator: validate_DeleteReposOwnerRepoHooksHookId_28376932, base: "/",
    url: url_DeleteReposOwnerRepoHooksHookId_28376933, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoHooksHookIdTests_28376955 = ref object of OpenApiRestCall_28375350
proc url_PostReposOwnerRepoHooksHookIdTests_28376957(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hookId"),
               (kind: ConstantSegment, value: "/tests")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoHooksHookIdTests_28376956(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Test a push hook.
  ## This will trigger the hook with the latest push to the current repository
  ## if the hook is subscribed to push events. If the hook is not subscribed
  ## to push events, the server will respond with 204 but no test POST will
  ## be generated.
  ## Note: Previously /repos/:owner/:repo/hooks/:id/tes
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   hookId: JInt (required)
  ##         : Id of hook.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376958 = path.getOrDefault("owner")
  valid_28376958 = validateParameter(valid_28376958, JString, required = true,
                                   default = nil)
  if valid_28376958 != nil:
    section.add "owner", valid_28376958
  var valid_28376959 = path.getOrDefault("repo")
  valid_28376959 = validateParameter(valid_28376959, JString, required = true,
                                   default = nil)
  if valid_28376959 != nil:
    section.add "repo", valid_28376959
  var valid_28376960 = path.getOrDefault("hookId")
  valid_28376960 = validateParameter(valid_28376960, JInt, required = true,
                                   default = nil)
  if valid_28376960 != nil:
    section.add "hookId", valid_28376960
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376961 = header.getOrDefault("Accept")
  valid_28376961 = validateParameter(valid_28376961, JString, required = false,
                                   default = nil)
  if valid_28376961 != nil:
    section.add "Accept", valid_28376961
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376962: Call_PostReposOwnerRepoHooksHookIdTests_28376955;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Test a push hook.
  ## This will trigger the hook with the latest push to the current repository
  ## if the hook is subscribed to push events. If the hook is not subscribed
  ## to push events, the server will respond with 204 but no test POST will
  ## be generated.
  ## Note: Previously /repos/:owner/:repo/hooks/:id/tes
  ## 
  ## 
  let valid = call_28376962.validator(path, query, header, formData, body)
  let scheme = call_28376962.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376962.url(scheme.get, call_28376962.host, call_28376962.base,
                           call_28376962.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376962, url, valid)

proc call*(call_28376963: Call_PostReposOwnerRepoHooksHookIdTests_28376955;
          owner: string; repo: string; hookId: int; Accept: string = ""): Recallable =
  ## postReposOwnerRepoHooksHookIdTests
  ## Test a push hook.
  ## This will trigger the hook with the latest push to the current repository
  ## if the hook is subscribed to push events. If the hook is not subscribed
  ## to push events, the server will respond with 204 but no test POST will
  ## be generated.
  ## Note: Previously /repos/:owner/:repo/hooks/:id/tes
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   hookId: int (required)
  ##         : Id of hook.
  var path_28376964 = newJObject()
  var header_28376965 = newJObject()
  add(path_28376964, "owner", newJString(owner))
  add(header_28376965, "Accept", newJString(Accept))
  add(path_28376964, "repo", newJString(repo))
  add(path_28376964, "hookId", newJInt(hookId))
  result = call_28376963.call(path_28376964, nil, header_28376965, nil, nil)

var postReposOwnerRepoHooksHookIdTests* = Call_PostReposOwnerRepoHooksHookIdTests_28376955(
    name: "postReposOwnerRepoHooksHookIdTests", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}/tests",
    validator: validate_PostReposOwnerRepoHooksHookIdTests_28376956, base: "/",
    url: url_PostReposOwnerRepoHooksHookIdTests_28376957, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoIssues_28376983 = ref object of OpenApiRestCall_28375350
proc url_PostReposOwnerRepoIssues_28376985(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoIssues_28376984(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create an issue.
  ## Any user with pull access to a repository can create an issue.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376986 = path.getOrDefault("owner")
  valid_28376986 = validateParameter(valid_28376986, JString, required = true,
                                   default = nil)
  if valid_28376986 != nil:
    section.add "owner", valid_28376986
  var valid_28376987 = path.getOrDefault("repo")
  valid_28376987 = validateParameter(valid_28376987, JString, required = true,
                                   default = nil)
  if valid_28376987 != nil:
    section.add "repo", valid_28376987
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376988 = header.getOrDefault("Accept")
  valid_28376988 = validateParameter(valid_28376988, JString, required = false,
                                   default = nil)
  if valid_28376988 != nil:
    section.add "Accept", valid_28376988
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28376990: Call_PostReposOwnerRepoIssues_28376983; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create an issue.
  ## Any user with pull access to a repository can create an issue.
  ## 
  ## 
  let valid = call_28376990.validator(path, query, header, formData, body)
  let scheme = call_28376990.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376990.url(scheme.get, call_28376990.host, call_28376990.base,
                           call_28376990.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376990, url, valid)

proc call*(call_28376991: Call_PostReposOwnerRepoIssues_28376983; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoIssues
  ## Create an issue.
  ## Any user with pull access to a repository can create an issue.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28376992 = newJObject()
  var header_28376993 = newJObject()
  var body_28376994 = newJObject()
  add(path_28376992, "owner", newJString(owner))
  add(header_28376993, "Accept", newJString(Accept))
  if body != nil:
    body_28376994 = body
  add(path_28376992, "repo", newJString(repo))
  result = call_28376991.call(path_28376992, nil, header_28376993, nil, body_28376994)

var postReposOwnerRepoIssues* = Call_PostReposOwnerRepoIssues_28376983(
    name: "postReposOwnerRepoIssues", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues",
    validator: validate_PostReposOwnerRepoIssues_28376984, base: "/",
    url: url_PostReposOwnerRepoIssues_28376985, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssues_28376966 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoIssues_28376968(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssues_28376967(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List issues for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376969 = path.getOrDefault("owner")
  valid_28376969 = validateParameter(valid_28376969, JString, required = true,
                                   default = nil)
  if valid_28376969 != nil:
    section.add "owner", valid_28376969
  var valid_28376970 = path.getOrDefault("repo")
  valid_28376970 = validateParameter(valid_28376970, JString, required = true,
                                   default = nil)
  if valid_28376970 != nil:
    section.add "repo", valid_28376970
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString (required)
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: JString (required)
  ##   direction: JString (required)
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_28376971 = query.getOrDefault("state")
  valid_28376971 = validateParameter(valid_28376971, JString, required = true,
                                   default = newJString("open"))
  if valid_28376971 != nil:
    section.add "state", valid_28376971
  var valid_28376972 = query.getOrDefault("labels")
  valid_28376972 = validateParameter(valid_28376972, JString, required = true,
                                   default = nil)
  if valid_28376972 != nil:
    section.add "labels", valid_28376972
  var valid_28376973 = query.getOrDefault("sort")
  valid_28376973 = validateParameter(valid_28376973, JString, required = true,
                                   default = newJString("created"))
  if valid_28376973 != nil:
    section.add "sort", valid_28376973
  var valid_28376974 = query.getOrDefault("direction")
  valid_28376974 = validateParameter(valid_28376974, JString, required = true,
                                   default = newJString("desc"))
  if valid_28376974 != nil:
    section.add "direction", valid_28376974
  var valid_28376975 = query.getOrDefault("filter")
  valid_28376975 = validateParameter(valid_28376975, JString, required = true,
                                   default = newJString("all"))
  if valid_28376975 != nil:
    section.add "filter", valid_28376975
  var valid_28376976 = query.getOrDefault("since")
  valid_28376976 = validateParameter(valid_28376976, JString, required = false,
                                   default = nil)
  if valid_28376976 != nil:
    section.add "since", valid_28376976
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28376977 = header.getOrDefault("Accept")
  valid_28376977 = validateParameter(valid_28376977, JString, required = false,
                                   default = nil)
  if valid_28376977 != nil:
    section.add "Accept", valid_28376977
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28376978: Call_GetReposOwnerRepoIssues_28376966; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List issues for a repository.
  ## 
  let valid = call_28376978.validator(path, query, header, formData, body)
  let scheme = call_28376978.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28376978.url(scheme.get, call_28376978.host, call_28376978.base,
                           call_28376978.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28376978, url, valid)

proc call*(call_28376979: Call_GetReposOwnerRepoIssues_28376966; owner: string;
          repo: string; labels: string; state: string = "open"; Accept: string = "";
          sort: string = "created"; direction: string = "desc"; filter: string = "all";
          since: string = ""): Recallable =
  ## getReposOwnerRepoIssues
  ## List issues for a repository.
  ##   state: string (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: string (required)
  ##   direction: string (required)
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  var path_28376980 = newJObject()
  var query_28376981 = newJObject()
  var header_28376982 = newJObject()
  add(query_28376981, "state", newJString(state))
  add(path_28376980, "owner", newJString(owner))
  add(header_28376982, "Accept", newJString(Accept))
  add(path_28376980, "repo", newJString(repo))
  add(query_28376981, "labels", newJString(labels))
  add(query_28376981, "sort", newJString(sort))
  add(query_28376981, "direction", newJString(direction))
  add(query_28376981, "filter", newJString(filter))
  add(query_28376981, "since", newJString(since))
  result = call_28376979.call(path_28376980, query_28376981, header_28376982, nil, nil)

var getReposOwnerRepoIssues* = Call_GetReposOwnerRepoIssues_28376966(
    name: "getReposOwnerRepoIssues", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues",
    validator: validate_GetReposOwnerRepoIssues_28376967, base: "/",
    url: url_GetReposOwnerRepoIssues_28376968, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesComments_28376995 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoIssuesComments_28376997(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesComments_28376996(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List comments in a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28376998 = path.getOrDefault("owner")
  valid_28376998 = validateParameter(valid_28376998, JString, required = true,
                                   default = nil)
  if valid_28376998 != nil:
    section.add "owner", valid_28376998
  var valid_28376999 = path.getOrDefault("repo")
  valid_28376999 = validateParameter(valid_28376999, JString, required = true,
                                   default = nil)
  if valid_28376999 != nil:
    section.add "repo", valid_28376999
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_28377000 = query.getOrDefault("sort")
  valid_28377000 = validateParameter(valid_28377000, JString, required = false,
                                   default = newJString("created"))
  if valid_28377000 != nil:
    section.add "sort", valid_28377000
  var valid_28377001 = query.getOrDefault("direction")
  valid_28377001 = validateParameter(valid_28377001, JString, required = false,
                                   default = nil)
  if valid_28377001 != nil:
    section.add "direction", valid_28377001
  var valid_28377002 = query.getOrDefault("since")
  valid_28377002 = validateParameter(valid_28377002, JString, required = false,
                                   default = nil)
  if valid_28377002 != nil:
    section.add "since", valid_28377002
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377003 = header.getOrDefault("Accept")
  valid_28377003 = validateParameter(valid_28377003, JString, required = false,
                                   default = nil)
  if valid_28377003 != nil:
    section.add "Accept", valid_28377003
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377004: Call_GetReposOwnerRepoIssuesComments_28376995;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List comments in a repository.
  ## 
  let valid = call_28377004.validator(path, query, header, formData, body)
  let scheme = call_28377004.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377004.url(scheme.get, call_28377004.host, call_28377004.base,
                           call_28377004.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377004, url, valid)

proc call*(call_28377005: Call_GetReposOwnerRepoIssuesComments_28376995;
          owner: string; repo: string; Accept: string = ""; sort: string = "created";
          direction: string = ""; since: string = ""): Recallable =
  ## getReposOwnerRepoIssuesComments
  ## List comments in a repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   sort: string
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var path_28377006 = newJObject()
  var query_28377007 = newJObject()
  var header_28377008 = newJObject()
  add(path_28377006, "owner", newJString(owner))
  add(header_28377008, "Accept", newJString(Accept))
  add(path_28377006, "repo", newJString(repo))
  add(query_28377007, "sort", newJString(sort))
  add(query_28377007, "direction", newJString(direction))
  add(query_28377007, "since", newJString(since))
  result = call_28377005.call(path_28377006, query_28377007, header_28377008, nil, nil)

var getReposOwnerRepoIssuesComments* = Call_GetReposOwnerRepoIssuesComments_28376995(
    name: "getReposOwnerRepoIssuesComments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/comments",
    validator: validate_GetReposOwnerRepoIssuesComments_28376996, base: "/",
    url: url_GetReposOwnerRepoIssuesComments_28376997, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesCommentsCommentId_28377009 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoIssuesCommentsCommentId_28377011(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesCommentsCommentId_28377010(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : ID of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377012 = path.getOrDefault("owner")
  valid_28377012 = validateParameter(valid_28377012, JString, required = true,
                                   default = nil)
  if valid_28377012 != nil:
    section.add "owner", valid_28377012
  var valid_28377013 = path.getOrDefault("repo")
  valid_28377013 = validateParameter(valid_28377013, JString, required = true,
                                   default = nil)
  if valid_28377013 != nil:
    section.add "repo", valid_28377013
  var valid_28377014 = path.getOrDefault("commentId")
  valid_28377014 = validateParameter(valid_28377014, JInt, required = true,
                                   default = nil)
  if valid_28377014 != nil:
    section.add "commentId", valid_28377014
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377015 = header.getOrDefault("Accept")
  valid_28377015 = validateParameter(valid_28377015, JString, required = false,
                                   default = nil)
  if valid_28377015 != nil:
    section.add "Accept", valid_28377015
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377016: Call_GetReposOwnerRepoIssuesCommentsCommentId_28377009;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single comment.
  ## 
  let valid = call_28377016.validator(path, query, header, formData, body)
  let scheme = call_28377016.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377016.url(scheme.get, call_28377016.host, call_28377016.base,
                           call_28377016.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377016, url, valid)

proc call*(call_28377017: Call_GetReposOwnerRepoIssuesCommentsCommentId_28377009;
          owner: string; repo: string; commentId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesCommentsCommentId
  ## Get a single comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : ID of comment.
  var path_28377018 = newJObject()
  var header_28377019 = newJObject()
  add(path_28377018, "owner", newJString(owner))
  add(header_28377019, "Accept", newJString(Accept))
  add(path_28377018, "repo", newJString(repo))
  add(path_28377018, "commentId", newJInt(commentId))
  result = call_28377017.call(path_28377018, nil, header_28377019, nil, nil)

var getReposOwnerRepoIssuesCommentsCommentId* = Call_GetReposOwnerRepoIssuesCommentsCommentId_28377009(
    name: "getReposOwnerRepoIssuesCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/comments/{commentId}",
    validator: validate_GetReposOwnerRepoIssuesCommentsCommentId_28377010,
    base: "/", url: url_GetReposOwnerRepoIssuesCommentsCommentId_28377011,
    schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoIssuesCommentsCommentId_28377031 = ref object of OpenApiRestCall_28375350
proc url_PatchReposOwnerRepoIssuesCommentsCommentId_28377033(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoIssuesCommentsCommentId_28377032(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Edit a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : ID of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377034 = path.getOrDefault("owner")
  valid_28377034 = validateParameter(valid_28377034, JString, required = true,
                                   default = nil)
  if valid_28377034 != nil:
    section.add "owner", valid_28377034
  var valid_28377035 = path.getOrDefault("repo")
  valid_28377035 = validateParameter(valid_28377035, JString, required = true,
                                   default = nil)
  if valid_28377035 != nil:
    section.add "repo", valid_28377035
  var valid_28377036 = path.getOrDefault("commentId")
  valid_28377036 = validateParameter(valid_28377036, JInt, required = true,
                                   default = nil)
  if valid_28377036 != nil:
    section.add "commentId", valid_28377036
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377037 = header.getOrDefault("Accept")
  valid_28377037 = validateParameter(valid_28377037, JString, required = false,
                                   default = nil)
  if valid_28377037 != nil:
    section.add "Accept", valid_28377037
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28377039: Call_PatchReposOwnerRepoIssuesCommentsCommentId_28377031;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Edit a comment.
  ## 
  let valid = call_28377039.validator(path, query, header, formData, body)
  let scheme = call_28377039.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377039.url(scheme.get, call_28377039.host, call_28377039.base,
                           call_28377039.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377039, url, valid)

proc call*(call_28377040: Call_PatchReposOwnerRepoIssuesCommentsCommentId_28377031;
          owner: string; body: JsonNode; repo: string; commentId: int;
          Accept: string = ""): Recallable =
  ## patchReposOwnerRepoIssuesCommentsCommentId
  ## Edit a comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : ID of comment.
  var path_28377041 = newJObject()
  var header_28377042 = newJObject()
  var body_28377043 = newJObject()
  add(path_28377041, "owner", newJString(owner))
  add(header_28377042, "Accept", newJString(Accept))
  if body != nil:
    body_28377043 = body
  add(path_28377041, "repo", newJString(repo))
  add(path_28377041, "commentId", newJInt(commentId))
  result = call_28377040.call(path_28377041, nil, header_28377042, nil, body_28377043)

var patchReposOwnerRepoIssuesCommentsCommentId* = Call_PatchReposOwnerRepoIssuesCommentsCommentId_28377031(
    name: "patchReposOwnerRepoIssuesCommentsCommentId",
    meth: HttpMethod.HttpPatch, host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/comments/{commentId}",
    validator: validate_PatchReposOwnerRepoIssuesCommentsCommentId_28377032,
    base: "/", url: url_PatchReposOwnerRepoIssuesCommentsCommentId_28377033,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoIssuesCommentsCommentId_28377020 = ref object of OpenApiRestCall_28375350
proc url_DeleteReposOwnerRepoIssuesCommentsCommentId_28377022(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoIssuesCommentsCommentId_28377021(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Delete a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : ID of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377023 = path.getOrDefault("owner")
  valid_28377023 = validateParameter(valid_28377023, JString, required = true,
                                   default = nil)
  if valid_28377023 != nil:
    section.add "owner", valid_28377023
  var valid_28377024 = path.getOrDefault("repo")
  valid_28377024 = validateParameter(valid_28377024, JString, required = true,
                                   default = nil)
  if valid_28377024 != nil:
    section.add "repo", valid_28377024
  var valid_28377025 = path.getOrDefault("commentId")
  valid_28377025 = validateParameter(valid_28377025, JInt, required = true,
                                   default = nil)
  if valid_28377025 != nil:
    section.add "commentId", valid_28377025
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377026 = header.getOrDefault("Accept")
  valid_28377026 = validateParameter(valid_28377026, JString, required = false,
                                   default = nil)
  if valid_28377026 != nil:
    section.add "Accept", valid_28377026
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377027: Call_DeleteReposOwnerRepoIssuesCommentsCommentId_28377020;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a comment.
  ## 
  let valid = call_28377027.validator(path, query, header, formData, body)
  let scheme = call_28377027.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377027.url(scheme.get, call_28377027.host, call_28377027.base,
                           call_28377027.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377027, url, valid)

proc call*(call_28377028: Call_DeleteReposOwnerRepoIssuesCommentsCommentId_28377020;
          owner: string; repo: string; commentId: int; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoIssuesCommentsCommentId
  ## Delete a comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : ID of comment.
  var path_28377029 = newJObject()
  var header_28377030 = newJObject()
  add(path_28377029, "owner", newJString(owner))
  add(header_28377030, "Accept", newJString(Accept))
  add(path_28377029, "repo", newJString(repo))
  add(path_28377029, "commentId", newJInt(commentId))
  result = call_28377028.call(path_28377029, nil, header_28377030, nil, nil)

var deleteReposOwnerRepoIssuesCommentsCommentId* = Call_DeleteReposOwnerRepoIssuesCommentsCommentId_28377020(
    name: "deleteReposOwnerRepoIssuesCommentsCommentId",
    meth: HttpMethod.HttpDelete, host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/comments/{commentId}",
    validator: validate_DeleteReposOwnerRepoIssuesCommentsCommentId_28377021,
    base: "/", url: url_DeleteReposOwnerRepoIssuesCommentsCommentId_28377022,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesEvents_28377044 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoIssuesEvents_28377046(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesEvents_28377045(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List issue events for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377047 = path.getOrDefault("owner")
  valid_28377047 = validateParameter(valid_28377047, JString, required = true,
                                   default = nil)
  if valid_28377047 != nil:
    section.add "owner", valid_28377047
  var valid_28377048 = path.getOrDefault("repo")
  valid_28377048 = validateParameter(valid_28377048, JString, required = true,
                                   default = nil)
  if valid_28377048 != nil:
    section.add "repo", valid_28377048
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377049 = header.getOrDefault("Accept")
  valid_28377049 = validateParameter(valid_28377049, JString, required = false,
                                   default = nil)
  if valid_28377049 != nil:
    section.add "Accept", valid_28377049
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377050: Call_GetReposOwnerRepoIssuesEvents_28377044;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List issue events for a repository.
  ## 
  let valid = call_28377050.validator(path, query, header, formData, body)
  let scheme = call_28377050.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377050.url(scheme.get, call_28377050.host, call_28377050.base,
                           call_28377050.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377050, url, valid)

proc call*(call_28377051: Call_GetReposOwnerRepoIssuesEvents_28377044;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesEvents
  ## List issue events for a repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377052 = newJObject()
  var header_28377053 = newJObject()
  add(path_28377052, "owner", newJString(owner))
  add(header_28377053, "Accept", newJString(Accept))
  add(path_28377052, "repo", newJString(repo))
  result = call_28377051.call(path_28377052, nil, header_28377053, nil, nil)

var getReposOwnerRepoIssuesEvents* = Call_GetReposOwnerRepoIssuesEvents_28377044(
    name: "getReposOwnerRepoIssuesEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/events",
    validator: validate_GetReposOwnerRepoIssuesEvents_28377045, base: "/",
    url: url_GetReposOwnerRepoIssuesEvents_28377046, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesEventsEventId_28377054 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoIssuesEventsEventId_28377056(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "eventId" in path, "`eventId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/events/"),
               (kind: VariableSegment, value: "eventId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesEventsEventId_28377055(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single event.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   eventId: JInt (required)
  ##          : Id of the event.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377057 = path.getOrDefault("owner")
  valid_28377057 = validateParameter(valid_28377057, JString, required = true,
                                   default = nil)
  if valid_28377057 != nil:
    section.add "owner", valid_28377057
  var valid_28377058 = path.getOrDefault("repo")
  valid_28377058 = validateParameter(valid_28377058, JString, required = true,
                                   default = nil)
  if valid_28377058 != nil:
    section.add "repo", valid_28377058
  var valid_28377059 = path.getOrDefault("eventId")
  valid_28377059 = validateParameter(valid_28377059, JInt, required = true,
                                   default = nil)
  if valid_28377059 != nil:
    section.add "eventId", valid_28377059
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377060 = header.getOrDefault("Accept")
  valid_28377060 = validateParameter(valid_28377060, JString, required = false,
                                   default = nil)
  if valid_28377060 != nil:
    section.add "Accept", valid_28377060
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377061: Call_GetReposOwnerRepoIssuesEventsEventId_28377054;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single event.
  ## 
  let valid = call_28377061.validator(path, query, header, formData, body)
  let scheme = call_28377061.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377061.url(scheme.get, call_28377061.host, call_28377061.base,
                           call_28377061.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377061, url, valid)

proc call*(call_28377062: Call_GetReposOwnerRepoIssuesEventsEventId_28377054;
          owner: string; repo: string; eventId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesEventsEventId
  ## Get a single event.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   eventId: int (required)
  ##          : Id of the event.
  var path_28377063 = newJObject()
  var header_28377064 = newJObject()
  add(path_28377063, "owner", newJString(owner))
  add(header_28377064, "Accept", newJString(Accept))
  add(path_28377063, "repo", newJString(repo))
  add(path_28377063, "eventId", newJInt(eventId))
  result = call_28377062.call(path_28377063, nil, header_28377064, nil, nil)

var getReposOwnerRepoIssuesEventsEventId* = Call_GetReposOwnerRepoIssuesEventsEventId_28377054(
    name: "getReposOwnerRepoIssuesEventsEventId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/events/{eventId}",
    validator: validate_GetReposOwnerRepoIssuesEventsEventId_28377055, base: "/",
    url: url_GetReposOwnerRepoIssuesEventsEventId_28377056,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumber_28377065 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoIssuesNumber_28377067(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumber_28377066(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single issue
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377068 = path.getOrDefault("owner")
  valid_28377068 = validateParameter(valid_28377068, JString, required = true,
                                   default = nil)
  if valid_28377068 != nil:
    section.add "owner", valid_28377068
  var valid_28377069 = path.getOrDefault("number")
  valid_28377069 = validateParameter(valid_28377069, JInt, required = true,
                                   default = nil)
  if valid_28377069 != nil:
    section.add "number", valid_28377069
  var valid_28377070 = path.getOrDefault("repo")
  valid_28377070 = validateParameter(valid_28377070, JString, required = true,
                                   default = nil)
  if valid_28377070 != nil:
    section.add "repo", valid_28377070
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377071 = header.getOrDefault("Accept")
  valid_28377071 = validateParameter(valid_28377071, JString, required = false,
                                   default = nil)
  if valid_28377071 != nil:
    section.add "Accept", valid_28377071
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377072: Call_GetReposOwnerRepoIssuesNumber_28377065;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single issue
  ## 
  let valid = call_28377072.validator(path, query, header, formData, body)
  let scheme = call_28377072.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377072.url(scheme.get, call_28377072.host, call_28377072.base,
                           call_28377072.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377072, url, valid)

proc call*(call_28377073: Call_GetReposOwnerRepoIssuesNumber_28377065;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumber
  ## Get a single issue
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377074 = newJObject()
  var header_28377075 = newJObject()
  add(path_28377074, "owner", newJString(owner))
  add(path_28377074, "number", newJInt(number))
  add(header_28377075, "Accept", newJString(Accept))
  add(path_28377074, "repo", newJString(repo))
  result = call_28377073.call(path_28377074, nil, header_28377075, nil, nil)

var getReposOwnerRepoIssuesNumber* = Call_GetReposOwnerRepoIssuesNumber_28377065(
    name: "getReposOwnerRepoIssuesNumber", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}",
    validator: validate_GetReposOwnerRepoIssuesNumber_28377066, base: "/",
    url: url_GetReposOwnerRepoIssuesNumber_28377067, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoIssuesNumber_28377076 = ref object of OpenApiRestCall_28375350
proc url_PatchReposOwnerRepoIssuesNumber_28377078(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoIssuesNumber_28377077(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Edit an issue.
  ## Issue owners and users with push access can edit an issue.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377079 = path.getOrDefault("owner")
  valid_28377079 = validateParameter(valid_28377079, JString, required = true,
                                   default = nil)
  if valid_28377079 != nil:
    section.add "owner", valid_28377079
  var valid_28377080 = path.getOrDefault("number")
  valid_28377080 = validateParameter(valid_28377080, JInt, required = true,
                                   default = nil)
  if valid_28377080 != nil:
    section.add "number", valid_28377080
  var valid_28377081 = path.getOrDefault("repo")
  valid_28377081 = validateParameter(valid_28377081, JString, required = true,
                                   default = nil)
  if valid_28377081 != nil:
    section.add "repo", valid_28377081
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377082 = header.getOrDefault("Accept")
  valid_28377082 = validateParameter(valid_28377082, JString, required = false,
                                   default = nil)
  if valid_28377082 != nil:
    section.add "Accept", valid_28377082
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28377084: Call_PatchReposOwnerRepoIssuesNumber_28377076;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Edit an issue.
  ## Issue owners and users with push access can edit an issue.
  ## 
  ## 
  let valid = call_28377084.validator(path, query, header, formData, body)
  let scheme = call_28377084.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377084.url(scheme.get, call_28377084.host, call_28377084.base,
                           call_28377084.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377084, url, valid)

proc call*(call_28377085: Call_PatchReposOwnerRepoIssuesNumber_28377076;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoIssuesNumber
  ## Edit an issue.
  ## Issue owners and users with push access can edit an issue.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377086 = newJObject()
  var header_28377087 = newJObject()
  var body_28377088 = newJObject()
  add(path_28377086, "owner", newJString(owner))
  add(path_28377086, "number", newJInt(number))
  add(header_28377087, "Accept", newJString(Accept))
  if body != nil:
    body_28377088 = body
  add(path_28377086, "repo", newJString(repo))
  result = call_28377085.call(path_28377086, nil, header_28377087, nil, body_28377088)

var patchReposOwnerRepoIssuesNumber* = Call_PatchReposOwnerRepoIssuesNumber_28377076(
    name: "patchReposOwnerRepoIssuesNumber", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}",
    validator: validate_PatchReposOwnerRepoIssuesNumber_28377077, base: "/",
    url: url_PatchReposOwnerRepoIssuesNumber_28377078, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoIssuesNumberComments_28377100 = ref object of OpenApiRestCall_28375350
proc url_PostReposOwnerRepoIssuesNumberComments_28377102(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoIssuesNumberComments_28377101(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377103 = path.getOrDefault("owner")
  valid_28377103 = validateParameter(valid_28377103, JString, required = true,
                                   default = nil)
  if valid_28377103 != nil:
    section.add "owner", valid_28377103
  var valid_28377104 = path.getOrDefault("number")
  valid_28377104 = validateParameter(valid_28377104, JInt, required = true,
                                   default = nil)
  if valid_28377104 != nil:
    section.add "number", valid_28377104
  var valid_28377105 = path.getOrDefault("repo")
  valid_28377105 = validateParameter(valid_28377105, JString, required = true,
                                   default = nil)
  if valid_28377105 != nil:
    section.add "repo", valid_28377105
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377106 = header.getOrDefault("Accept")
  valid_28377106 = validateParameter(valid_28377106, JString, required = false,
                                   default = nil)
  if valid_28377106 != nil:
    section.add "Accept", valid_28377106
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28377108: Call_PostReposOwnerRepoIssuesNumberComments_28377100;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Create a comment.
  ## 
  let valid = call_28377108.validator(path, query, header, formData, body)
  let scheme = call_28377108.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377108.url(scheme.get, call_28377108.host, call_28377108.base,
                           call_28377108.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377108, url, valid)

proc call*(call_28377109: Call_PostReposOwnerRepoIssuesNumberComments_28377100;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoIssuesNumberComments
  ## Create a comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377110 = newJObject()
  var header_28377111 = newJObject()
  var body_28377112 = newJObject()
  add(path_28377110, "owner", newJString(owner))
  add(path_28377110, "number", newJInt(number))
  add(header_28377111, "Accept", newJString(Accept))
  if body != nil:
    body_28377112 = body
  add(path_28377110, "repo", newJString(repo))
  result = call_28377109.call(path_28377110, nil, header_28377111, nil, body_28377112)

var postReposOwnerRepoIssuesNumberComments* = Call_PostReposOwnerRepoIssuesNumberComments_28377100(
    name: "postReposOwnerRepoIssuesNumberComments", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/{number}/comments",
    validator: validate_PostReposOwnerRepoIssuesNumberComments_28377101,
    base: "/", url: url_PostReposOwnerRepoIssuesNumberComments_28377102,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumberComments_28377089 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoIssuesNumberComments_28377091(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumberComments_28377090(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List comments on an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377092 = path.getOrDefault("owner")
  valid_28377092 = validateParameter(valid_28377092, JString, required = true,
                                   default = nil)
  if valid_28377092 != nil:
    section.add "owner", valid_28377092
  var valid_28377093 = path.getOrDefault("number")
  valid_28377093 = validateParameter(valid_28377093, JInt, required = true,
                                   default = nil)
  if valid_28377093 != nil:
    section.add "number", valid_28377093
  var valid_28377094 = path.getOrDefault("repo")
  valid_28377094 = validateParameter(valid_28377094, JString, required = true,
                                   default = nil)
  if valid_28377094 != nil:
    section.add "repo", valid_28377094
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377095 = header.getOrDefault("Accept")
  valid_28377095 = validateParameter(valid_28377095, JString, required = false,
                                   default = nil)
  if valid_28377095 != nil:
    section.add "Accept", valid_28377095
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377096: Call_GetReposOwnerRepoIssuesNumberComments_28377089;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List comments on an issue.
  ## 
  let valid = call_28377096.validator(path, query, header, formData, body)
  let scheme = call_28377096.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377096.url(scheme.get, call_28377096.host, call_28377096.base,
                           call_28377096.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377096, url, valid)

proc call*(call_28377097: Call_GetReposOwnerRepoIssuesNumberComments_28377089;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumberComments
  ## List comments on an issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377098 = newJObject()
  var header_28377099 = newJObject()
  add(path_28377098, "owner", newJString(owner))
  add(path_28377098, "number", newJInt(number))
  add(header_28377099, "Accept", newJString(Accept))
  add(path_28377098, "repo", newJString(repo))
  result = call_28377097.call(path_28377098, nil, header_28377099, nil, nil)

var getReposOwnerRepoIssuesNumberComments* = Call_GetReposOwnerRepoIssuesNumberComments_28377089(
    name: "getReposOwnerRepoIssuesNumberComments", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/{number}/comments",
    validator: validate_GetReposOwnerRepoIssuesNumberComments_28377090, base: "/",
    url: url_GetReposOwnerRepoIssuesNumberComments_28377091,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumberEvents_28377113 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoIssuesNumberEvents_28377115(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumberEvents_28377114(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List events for an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377116 = path.getOrDefault("owner")
  valid_28377116 = validateParameter(valid_28377116, JString, required = true,
                                   default = nil)
  if valid_28377116 != nil:
    section.add "owner", valid_28377116
  var valid_28377117 = path.getOrDefault("number")
  valid_28377117 = validateParameter(valid_28377117, JInt, required = true,
                                   default = nil)
  if valid_28377117 != nil:
    section.add "number", valid_28377117
  var valid_28377118 = path.getOrDefault("repo")
  valid_28377118 = validateParameter(valid_28377118, JString, required = true,
                                   default = nil)
  if valid_28377118 != nil:
    section.add "repo", valid_28377118
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377119 = header.getOrDefault("Accept")
  valid_28377119 = validateParameter(valid_28377119, JString, required = false,
                                   default = nil)
  if valid_28377119 != nil:
    section.add "Accept", valid_28377119
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377120: Call_GetReposOwnerRepoIssuesNumberEvents_28377113;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List events for an issue.
  ## 
  let valid = call_28377120.validator(path, query, header, formData, body)
  let scheme = call_28377120.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377120.url(scheme.get, call_28377120.host, call_28377120.base,
                           call_28377120.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377120, url, valid)

proc call*(call_28377121: Call_GetReposOwnerRepoIssuesNumberEvents_28377113;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumberEvents
  ## List events for an issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377122 = newJObject()
  var header_28377123 = newJObject()
  add(path_28377122, "owner", newJString(owner))
  add(path_28377122, "number", newJInt(number))
  add(header_28377123, "Accept", newJString(Accept))
  add(path_28377122, "repo", newJString(repo))
  result = call_28377121.call(path_28377122, nil, header_28377123, nil, nil)

var getReposOwnerRepoIssuesNumberEvents* = Call_GetReposOwnerRepoIssuesNumberEvents_28377113(
    name: "getReposOwnerRepoIssuesNumberEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/events",
    validator: validate_GetReposOwnerRepoIssuesNumberEvents_28377114, base: "/",
    url: url_GetReposOwnerRepoIssuesNumberEvents_28377115, schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoIssuesNumberLabels_28377135 = ref object of OpenApiRestCall_28375350
proc url_PutReposOwnerRepoIssuesNumberLabels_28377137(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoIssuesNumberLabels_28377136(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Replace all labels for an issue.
  ## Sending an empty array ([]) will remove all Labels from the Issue.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377138 = path.getOrDefault("owner")
  valid_28377138 = validateParameter(valid_28377138, JString, required = true,
                                   default = nil)
  if valid_28377138 != nil:
    section.add "owner", valid_28377138
  var valid_28377139 = path.getOrDefault("number")
  valid_28377139 = validateParameter(valid_28377139, JInt, required = true,
                                   default = nil)
  if valid_28377139 != nil:
    section.add "number", valid_28377139
  var valid_28377140 = path.getOrDefault("repo")
  valid_28377140 = validateParameter(valid_28377140, JString, required = true,
                                   default = nil)
  if valid_28377140 != nil:
    section.add "repo", valid_28377140
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377141 = header.getOrDefault("Accept")
  valid_28377141 = validateParameter(valid_28377141, JString, required = false,
                                   default = nil)
  if valid_28377141 != nil:
    section.add "Accept", valid_28377141
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28377143: Call_PutReposOwnerRepoIssuesNumberLabels_28377135;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Replace all labels for an issue.
  ## Sending an empty array ([]) will remove all Labels from the Issue.
  ## 
  ## 
  let valid = call_28377143.validator(path, query, header, formData, body)
  let scheme = call_28377143.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377143.url(scheme.get, call_28377143.host, call_28377143.base,
                           call_28377143.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377143, url, valid)

proc call*(call_28377144: Call_PutReposOwnerRepoIssuesNumberLabels_28377135;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoIssuesNumberLabels
  ## Replace all labels for an issue.
  ## Sending an empty array ([]) will remove all Labels from the Issue.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377145 = newJObject()
  var header_28377146 = newJObject()
  var body_28377147 = newJObject()
  add(path_28377145, "owner", newJString(owner))
  add(path_28377145, "number", newJInt(number))
  add(header_28377146, "Accept", newJString(Accept))
  if body != nil:
    body_28377147 = body
  add(path_28377145, "repo", newJString(repo))
  result = call_28377144.call(path_28377145, nil, header_28377146, nil, body_28377147)

var putReposOwnerRepoIssuesNumberLabels* = Call_PutReposOwnerRepoIssuesNumberLabels_28377135(
    name: "putReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_PutReposOwnerRepoIssuesNumberLabels_28377136, base: "/",
    url: url_PutReposOwnerRepoIssuesNumberLabels_28377137, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoIssuesNumberLabels_28377148 = ref object of OpenApiRestCall_28375350
proc url_PostReposOwnerRepoIssuesNumberLabels_28377150(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoIssuesNumberLabels_28377149(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Add labels to an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377151 = path.getOrDefault("owner")
  valid_28377151 = validateParameter(valid_28377151, JString, required = true,
                                   default = nil)
  if valid_28377151 != nil:
    section.add "owner", valid_28377151
  var valid_28377152 = path.getOrDefault("number")
  valid_28377152 = validateParameter(valid_28377152, JInt, required = true,
                                   default = nil)
  if valid_28377152 != nil:
    section.add "number", valid_28377152
  var valid_28377153 = path.getOrDefault("repo")
  valid_28377153 = validateParameter(valid_28377153, JString, required = true,
                                   default = nil)
  if valid_28377153 != nil:
    section.add "repo", valid_28377153
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377154 = header.getOrDefault("Accept")
  valid_28377154 = validateParameter(valid_28377154, JString, required = false,
                                   default = nil)
  if valid_28377154 != nil:
    section.add "Accept", valid_28377154
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28377156: Call_PostReposOwnerRepoIssuesNumberLabels_28377148;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Add labels to an issue.
  ## 
  let valid = call_28377156.validator(path, query, header, formData, body)
  let scheme = call_28377156.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377156.url(scheme.get, call_28377156.host, call_28377156.base,
                           call_28377156.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377156, url, valid)

proc call*(call_28377157: Call_PostReposOwnerRepoIssuesNumberLabels_28377148;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoIssuesNumberLabels
  ## Add labels to an issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377158 = newJObject()
  var header_28377159 = newJObject()
  var body_28377160 = newJObject()
  add(path_28377158, "owner", newJString(owner))
  add(path_28377158, "number", newJInt(number))
  add(header_28377159, "Accept", newJString(Accept))
  if body != nil:
    body_28377160 = body
  add(path_28377158, "repo", newJString(repo))
  result = call_28377157.call(path_28377158, nil, header_28377159, nil, body_28377160)

var postReposOwnerRepoIssuesNumberLabels* = Call_PostReposOwnerRepoIssuesNumberLabels_28377148(
    name: "postReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_PostReposOwnerRepoIssuesNumberLabels_28377149, base: "/",
    url: url_PostReposOwnerRepoIssuesNumberLabels_28377150,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumberLabels_28377124 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoIssuesNumberLabels_28377126(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumberLabels_28377125(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List labels on an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377127 = path.getOrDefault("owner")
  valid_28377127 = validateParameter(valid_28377127, JString, required = true,
                                   default = nil)
  if valid_28377127 != nil:
    section.add "owner", valid_28377127
  var valid_28377128 = path.getOrDefault("number")
  valid_28377128 = validateParameter(valid_28377128, JInt, required = true,
                                   default = nil)
  if valid_28377128 != nil:
    section.add "number", valid_28377128
  var valid_28377129 = path.getOrDefault("repo")
  valid_28377129 = validateParameter(valid_28377129, JString, required = true,
                                   default = nil)
  if valid_28377129 != nil:
    section.add "repo", valid_28377129
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377130 = header.getOrDefault("Accept")
  valid_28377130 = validateParameter(valid_28377130, JString, required = false,
                                   default = nil)
  if valid_28377130 != nil:
    section.add "Accept", valid_28377130
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377131: Call_GetReposOwnerRepoIssuesNumberLabels_28377124;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List labels on an issue.
  ## 
  let valid = call_28377131.validator(path, query, header, formData, body)
  let scheme = call_28377131.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377131.url(scheme.get, call_28377131.host, call_28377131.base,
                           call_28377131.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377131, url, valid)

proc call*(call_28377132: Call_GetReposOwnerRepoIssuesNumberLabels_28377124;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumberLabels
  ## List labels on an issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377133 = newJObject()
  var header_28377134 = newJObject()
  add(path_28377133, "owner", newJString(owner))
  add(path_28377133, "number", newJInt(number))
  add(header_28377134, "Accept", newJString(Accept))
  add(path_28377133, "repo", newJString(repo))
  result = call_28377132.call(path_28377133, nil, header_28377134, nil, nil)

var getReposOwnerRepoIssuesNumberLabels* = Call_GetReposOwnerRepoIssuesNumberLabels_28377124(
    name: "getReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_GetReposOwnerRepoIssuesNumberLabels_28377125, base: "/",
    url: url_GetReposOwnerRepoIssuesNumberLabels_28377126, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoIssuesNumberLabels_28377161 = ref object of OpenApiRestCall_28375350
proc url_DeleteReposOwnerRepoIssuesNumberLabels_28377163(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoIssuesNumberLabels_28377162(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Remove all labels from an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377164 = path.getOrDefault("owner")
  valid_28377164 = validateParameter(valid_28377164, JString, required = true,
                                   default = nil)
  if valid_28377164 != nil:
    section.add "owner", valid_28377164
  var valid_28377165 = path.getOrDefault("number")
  valid_28377165 = validateParameter(valid_28377165, JInt, required = true,
                                   default = nil)
  if valid_28377165 != nil:
    section.add "number", valid_28377165
  var valid_28377166 = path.getOrDefault("repo")
  valid_28377166 = validateParameter(valid_28377166, JString, required = true,
                                   default = nil)
  if valid_28377166 != nil:
    section.add "repo", valid_28377166
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377167 = header.getOrDefault("Accept")
  valid_28377167 = validateParameter(valid_28377167, JString, required = false,
                                   default = nil)
  if valid_28377167 != nil:
    section.add "Accept", valid_28377167
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377168: Call_DeleteReposOwnerRepoIssuesNumberLabels_28377161;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Remove all labels from an issue.
  ## 
  let valid = call_28377168.validator(path, query, header, formData, body)
  let scheme = call_28377168.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377168.url(scheme.get, call_28377168.host, call_28377168.base,
                           call_28377168.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377168, url, valid)

proc call*(call_28377169: Call_DeleteReposOwnerRepoIssuesNumberLabels_28377161;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoIssuesNumberLabels
  ## Remove all labels from an issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377170 = newJObject()
  var header_28377171 = newJObject()
  add(path_28377170, "owner", newJString(owner))
  add(path_28377170, "number", newJInt(number))
  add(header_28377171, "Accept", newJString(Accept))
  add(path_28377170, "repo", newJString(repo))
  result = call_28377169.call(path_28377170, nil, header_28377171, nil, nil)

var deleteReposOwnerRepoIssuesNumberLabels* = Call_DeleteReposOwnerRepoIssuesNumberLabels_28377161(
    name: "deleteReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_DeleteReposOwnerRepoIssuesNumberLabels_28377162,
    base: "/", url: url_DeleteReposOwnerRepoIssuesNumberLabels_28377163,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoIssuesNumberLabelsName_28377172 = ref object of OpenApiRestCall_28375350
proc url_DeleteReposOwnerRepoIssuesNumberLabelsName_28377174(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoIssuesNumberLabelsName_28377173(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Remove a label from an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   name: JString (required)
  ##       : Name of the label.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377175 = path.getOrDefault("owner")
  valid_28377175 = validateParameter(valid_28377175, JString, required = true,
                                   default = nil)
  if valid_28377175 != nil:
    section.add "owner", valid_28377175
  var valid_28377176 = path.getOrDefault("number")
  valid_28377176 = validateParameter(valid_28377176, JInt, required = true,
                                   default = nil)
  if valid_28377176 != nil:
    section.add "number", valid_28377176
  var valid_28377177 = path.getOrDefault("name")
  valid_28377177 = validateParameter(valid_28377177, JString, required = true,
                                   default = nil)
  if valid_28377177 != nil:
    section.add "name", valid_28377177
  var valid_28377178 = path.getOrDefault("repo")
  valid_28377178 = validateParameter(valid_28377178, JString, required = true,
                                   default = nil)
  if valid_28377178 != nil:
    section.add "repo", valid_28377178
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377179 = header.getOrDefault("Accept")
  valid_28377179 = validateParameter(valid_28377179, JString, required = false,
                                   default = nil)
  if valid_28377179 != nil:
    section.add "Accept", valid_28377179
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377180: Call_DeleteReposOwnerRepoIssuesNumberLabelsName_28377172;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Remove a label from an issue.
  ## 
  let valid = call_28377180.validator(path, query, header, formData, body)
  let scheme = call_28377180.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377180.url(scheme.get, call_28377180.host, call_28377180.base,
                           call_28377180.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377180, url, valid)

proc call*(call_28377181: Call_DeleteReposOwnerRepoIssuesNumberLabelsName_28377172;
          owner: string; number: int; name: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoIssuesNumberLabelsName
  ## Remove a label from an issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   name: string (required)
  ##       : Name of the label.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377182 = newJObject()
  var header_28377183 = newJObject()
  add(path_28377182, "owner", newJString(owner))
  add(path_28377182, "number", newJInt(number))
  add(path_28377182, "name", newJString(name))
  add(header_28377183, "Accept", newJString(Accept))
  add(path_28377182, "repo", newJString(repo))
  result = call_28377181.call(path_28377182, nil, header_28377183, nil, nil)

var deleteReposOwnerRepoIssuesNumberLabelsName* = Call_DeleteReposOwnerRepoIssuesNumberLabelsName_28377172(
    name: "deleteReposOwnerRepoIssuesNumberLabelsName",
    meth: HttpMethod.HttpDelete, host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/{number}/labels/{name}",
    validator: validate_DeleteReposOwnerRepoIssuesNumberLabelsName_28377173,
    base: "/", url: url_DeleteReposOwnerRepoIssuesNumberLabelsName_28377174,
    schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoKeys_28377194 = ref object of OpenApiRestCall_28375350
proc url_PostReposOwnerRepoKeys_28377196(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/keys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoKeys_28377195(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a key.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377197 = path.getOrDefault("owner")
  valid_28377197 = validateParameter(valid_28377197, JString, required = true,
                                   default = nil)
  if valid_28377197 != nil:
    section.add "owner", valid_28377197
  var valid_28377198 = path.getOrDefault("repo")
  valid_28377198 = validateParameter(valid_28377198, JString, required = true,
                                   default = nil)
  if valid_28377198 != nil:
    section.add "repo", valid_28377198
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377199 = header.getOrDefault("Accept")
  valid_28377199 = validateParameter(valid_28377199, JString, required = false,
                                   default = nil)
  if valid_28377199 != nil:
    section.add "Accept", valid_28377199
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28377201: Call_PostReposOwnerRepoKeys_28377194; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a key.
  ## 
  let valid = call_28377201.validator(path, query, header, formData, body)
  let scheme = call_28377201.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377201.url(scheme.get, call_28377201.host, call_28377201.base,
                           call_28377201.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377201, url, valid)

proc call*(call_28377202: Call_PostReposOwnerRepoKeys_28377194; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoKeys
  ## Create a key.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377203 = newJObject()
  var header_28377204 = newJObject()
  var body_28377205 = newJObject()
  add(path_28377203, "owner", newJString(owner))
  add(header_28377204, "Accept", newJString(Accept))
  if body != nil:
    body_28377205 = body
  add(path_28377203, "repo", newJString(repo))
  result = call_28377202.call(path_28377203, nil, header_28377204, nil, body_28377205)

var postReposOwnerRepoKeys* = Call_PostReposOwnerRepoKeys_28377194(
    name: "postReposOwnerRepoKeys", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/keys",
    validator: validate_PostReposOwnerRepoKeys_28377195, base: "/",
    url: url_PostReposOwnerRepoKeys_28377196, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoKeys_28377184 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoKeys_28377186(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/keys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoKeys_28377185(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get list of keys.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377187 = path.getOrDefault("owner")
  valid_28377187 = validateParameter(valid_28377187, JString, required = true,
                                   default = nil)
  if valid_28377187 != nil:
    section.add "owner", valid_28377187
  var valid_28377188 = path.getOrDefault("repo")
  valid_28377188 = validateParameter(valid_28377188, JString, required = true,
                                   default = nil)
  if valid_28377188 != nil:
    section.add "repo", valid_28377188
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377189 = header.getOrDefault("Accept")
  valid_28377189 = validateParameter(valid_28377189, JString, required = false,
                                   default = nil)
  if valid_28377189 != nil:
    section.add "Accept", valid_28377189
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377190: Call_GetReposOwnerRepoKeys_28377184; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get list of keys.
  ## 
  let valid = call_28377190.validator(path, query, header, formData, body)
  let scheme = call_28377190.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377190.url(scheme.get, call_28377190.host, call_28377190.base,
                           call_28377190.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377190, url, valid)

proc call*(call_28377191: Call_GetReposOwnerRepoKeys_28377184; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoKeys
  ## Get list of keys.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377192 = newJObject()
  var header_28377193 = newJObject()
  add(path_28377192, "owner", newJString(owner))
  add(header_28377193, "Accept", newJString(Accept))
  add(path_28377192, "repo", newJString(repo))
  result = call_28377191.call(path_28377192, nil, header_28377193, nil, nil)

var getReposOwnerRepoKeys* = Call_GetReposOwnerRepoKeys_28377184(
    name: "getReposOwnerRepoKeys", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/repos/{owner}/{repo}/keys",
    validator: validate_GetReposOwnerRepoKeys_28377185, base: "/",
    url: url_GetReposOwnerRepoKeys_28377186, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoKeysKeyId_28377206 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoKeysKeyId_28377208(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/keys/"),
               (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoKeysKeyId_28377207(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a key
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   keyId: JInt (required)
  ##        : Id of key.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377209 = path.getOrDefault("owner")
  valid_28377209 = validateParameter(valid_28377209, JString, required = true,
                                   default = nil)
  if valid_28377209 != nil:
    section.add "owner", valid_28377209
  var valid_28377210 = path.getOrDefault("keyId")
  valid_28377210 = validateParameter(valid_28377210, JInt, required = true,
                                   default = nil)
  if valid_28377210 != nil:
    section.add "keyId", valid_28377210
  var valid_28377211 = path.getOrDefault("repo")
  valid_28377211 = validateParameter(valid_28377211, JString, required = true,
                                   default = nil)
  if valid_28377211 != nil:
    section.add "repo", valid_28377211
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377212 = header.getOrDefault("Accept")
  valid_28377212 = validateParameter(valid_28377212, JString, required = false,
                                   default = nil)
  if valid_28377212 != nil:
    section.add "Accept", valid_28377212
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377213: Call_GetReposOwnerRepoKeysKeyId_28377206; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a key
  ## 
  let valid = call_28377213.validator(path, query, header, formData, body)
  let scheme = call_28377213.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377213.url(scheme.get, call_28377213.host, call_28377213.base,
                           call_28377213.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377213, url, valid)

proc call*(call_28377214: Call_GetReposOwnerRepoKeysKeyId_28377206; owner: string;
          keyId: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoKeysKeyId
  ## Get a key
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   keyId: int (required)
  ##        : Id of key.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377215 = newJObject()
  var header_28377216 = newJObject()
  add(path_28377215, "owner", newJString(owner))
  add(header_28377216, "Accept", newJString(Accept))
  add(path_28377215, "keyId", newJInt(keyId))
  add(path_28377215, "repo", newJString(repo))
  result = call_28377214.call(path_28377215, nil, header_28377216, nil, nil)

var getReposOwnerRepoKeysKeyId* = Call_GetReposOwnerRepoKeysKeyId_28377206(
    name: "getReposOwnerRepoKeysKeyId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/keys/{keyId}",
    validator: validate_GetReposOwnerRepoKeysKeyId_28377207, base: "/",
    url: url_GetReposOwnerRepoKeysKeyId_28377208, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoKeysKeyId_28377217 = ref object of OpenApiRestCall_28375350
proc url_DeleteReposOwnerRepoKeysKeyId_28377219(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/keys/"),
               (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoKeysKeyId_28377218(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a key.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   keyId: JInt (required)
  ##        : Id of key.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377220 = path.getOrDefault("owner")
  valid_28377220 = validateParameter(valid_28377220, JString, required = true,
                                   default = nil)
  if valid_28377220 != nil:
    section.add "owner", valid_28377220
  var valid_28377221 = path.getOrDefault("keyId")
  valid_28377221 = validateParameter(valid_28377221, JInt, required = true,
                                   default = nil)
  if valid_28377221 != nil:
    section.add "keyId", valid_28377221
  var valid_28377222 = path.getOrDefault("repo")
  valid_28377222 = validateParameter(valid_28377222, JString, required = true,
                                   default = nil)
  if valid_28377222 != nil:
    section.add "repo", valid_28377222
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377223 = header.getOrDefault("Accept")
  valid_28377223 = validateParameter(valid_28377223, JString, required = false,
                                   default = nil)
  if valid_28377223 != nil:
    section.add "Accept", valid_28377223
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377224: Call_DeleteReposOwnerRepoKeysKeyId_28377217;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a key.
  ## 
  let valid = call_28377224.validator(path, query, header, formData, body)
  let scheme = call_28377224.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377224.url(scheme.get, call_28377224.host, call_28377224.base,
                           call_28377224.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377224, url, valid)

proc call*(call_28377225: Call_DeleteReposOwnerRepoKeysKeyId_28377217;
          owner: string; keyId: int; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoKeysKeyId
  ## Delete a key.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   keyId: int (required)
  ##        : Id of key.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377226 = newJObject()
  var header_28377227 = newJObject()
  add(path_28377226, "owner", newJString(owner))
  add(header_28377227, "Accept", newJString(Accept))
  add(path_28377226, "keyId", newJInt(keyId))
  add(path_28377226, "repo", newJString(repo))
  result = call_28377225.call(path_28377226, nil, header_28377227, nil, nil)

var deleteReposOwnerRepoKeysKeyId* = Call_DeleteReposOwnerRepoKeysKeyId_28377217(
    name: "deleteReposOwnerRepoKeysKeyId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/keys/{keyId}",
    validator: validate_DeleteReposOwnerRepoKeysKeyId_28377218, base: "/",
    url: url_DeleteReposOwnerRepoKeysKeyId_28377219, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoLabels_28377238 = ref object of OpenApiRestCall_28375350
proc url_PostReposOwnerRepoLabels_28377240(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoLabels_28377239(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377241 = path.getOrDefault("owner")
  valid_28377241 = validateParameter(valid_28377241, JString, required = true,
                                   default = nil)
  if valid_28377241 != nil:
    section.add "owner", valid_28377241
  var valid_28377242 = path.getOrDefault("repo")
  valid_28377242 = validateParameter(valid_28377242, JString, required = true,
                                   default = nil)
  if valid_28377242 != nil:
    section.add "repo", valid_28377242
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377243 = header.getOrDefault("Accept")
  valid_28377243 = validateParameter(valid_28377243, JString, required = false,
                                   default = nil)
  if valid_28377243 != nil:
    section.add "Accept", valid_28377243
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28377245: Call_PostReposOwnerRepoLabels_28377238; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a label.
  ## 
  let valid = call_28377245.validator(path, query, header, formData, body)
  let scheme = call_28377245.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377245.url(scheme.get, call_28377245.host, call_28377245.base,
                           call_28377245.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377245, url, valid)

proc call*(call_28377246: Call_PostReposOwnerRepoLabels_28377238; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoLabels
  ## Create a label.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377247 = newJObject()
  var header_28377248 = newJObject()
  var body_28377249 = newJObject()
  add(path_28377247, "owner", newJString(owner))
  add(header_28377248, "Accept", newJString(Accept))
  if body != nil:
    body_28377249 = body
  add(path_28377247, "repo", newJString(repo))
  result = call_28377246.call(path_28377247, nil, header_28377248, nil, body_28377249)

var postReposOwnerRepoLabels* = Call_PostReposOwnerRepoLabels_28377238(
    name: "postReposOwnerRepoLabels", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels",
    validator: validate_PostReposOwnerRepoLabels_28377239, base: "/",
    url: url_PostReposOwnerRepoLabels_28377240, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoLabels_28377228 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoLabels_28377230(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoLabels_28377229(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List all labels for this repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377231 = path.getOrDefault("owner")
  valid_28377231 = validateParameter(valid_28377231, JString, required = true,
                                   default = nil)
  if valid_28377231 != nil:
    section.add "owner", valid_28377231
  var valid_28377232 = path.getOrDefault("repo")
  valid_28377232 = validateParameter(valid_28377232, JString, required = true,
                                   default = nil)
  if valid_28377232 != nil:
    section.add "repo", valid_28377232
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377233 = header.getOrDefault("Accept")
  valid_28377233 = validateParameter(valid_28377233, JString, required = false,
                                   default = nil)
  if valid_28377233 != nil:
    section.add "Accept", valid_28377233
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377234: Call_GetReposOwnerRepoLabels_28377228; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List all labels for this repository.
  ## 
  let valid = call_28377234.validator(path, query, header, formData, body)
  let scheme = call_28377234.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377234.url(scheme.get, call_28377234.host, call_28377234.base,
                           call_28377234.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377234, url, valid)

proc call*(call_28377235: Call_GetReposOwnerRepoLabels_28377228; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoLabels
  ## List all labels for this repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377236 = newJObject()
  var header_28377237 = newJObject()
  add(path_28377236, "owner", newJString(owner))
  add(header_28377237, "Accept", newJString(Accept))
  add(path_28377236, "repo", newJString(repo))
  result = call_28377235.call(path_28377236, nil, header_28377237, nil, nil)

var getReposOwnerRepoLabels* = Call_GetReposOwnerRepoLabels_28377228(
    name: "getReposOwnerRepoLabels", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels",
    validator: validate_GetReposOwnerRepoLabels_28377229, base: "/",
    url: url_GetReposOwnerRepoLabels_28377230, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoLabelsName_28377250 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoLabelsName_28377252(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoLabelsName_28377251(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   name: JString (required)
  ##       : Name of the label.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377253 = path.getOrDefault("owner")
  valid_28377253 = validateParameter(valid_28377253, JString, required = true,
                                   default = nil)
  if valid_28377253 != nil:
    section.add "owner", valid_28377253
  var valid_28377254 = path.getOrDefault("name")
  valid_28377254 = validateParameter(valid_28377254, JString, required = true,
                                   default = nil)
  if valid_28377254 != nil:
    section.add "name", valid_28377254
  var valid_28377255 = path.getOrDefault("repo")
  valid_28377255 = validateParameter(valid_28377255, JString, required = true,
                                   default = nil)
  if valid_28377255 != nil:
    section.add "repo", valid_28377255
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377256 = header.getOrDefault("Accept")
  valid_28377256 = validateParameter(valid_28377256, JString, required = false,
                                   default = nil)
  if valid_28377256 != nil:
    section.add "Accept", valid_28377256
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377257: Call_GetReposOwnerRepoLabelsName_28377250;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single label.
  ## 
  let valid = call_28377257.validator(path, query, header, formData, body)
  let scheme = call_28377257.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377257.url(scheme.get, call_28377257.host, call_28377257.base,
                           call_28377257.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377257, url, valid)

proc call*(call_28377258: Call_GetReposOwnerRepoLabelsName_28377250; owner: string;
          name: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoLabelsName
  ## Get a single label.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   name: string (required)
  ##       : Name of the label.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377259 = newJObject()
  var header_28377260 = newJObject()
  add(path_28377259, "owner", newJString(owner))
  add(path_28377259, "name", newJString(name))
  add(header_28377260, "Accept", newJString(Accept))
  add(path_28377259, "repo", newJString(repo))
  result = call_28377258.call(path_28377259, nil, header_28377260, nil, nil)

var getReposOwnerRepoLabelsName* = Call_GetReposOwnerRepoLabelsName_28377250(
    name: "getReposOwnerRepoLabelsName", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels/{name}",
    validator: validate_GetReposOwnerRepoLabelsName_28377251, base: "/",
    url: url_GetReposOwnerRepoLabelsName_28377252, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoLabelsName_28377272 = ref object of OpenApiRestCall_28375350
proc url_PatchReposOwnerRepoLabelsName_28377274(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoLabelsName_28377273(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Update a label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   name: JString (required)
  ##       : Name of the label.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377275 = path.getOrDefault("owner")
  valid_28377275 = validateParameter(valid_28377275, JString, required = true,
                                   default = nil)
  if valid_28377275 != nil:
    section.add "owner", valid_28377275
  var valid_28377276 = path.getOrDefault("name")
  valid_28377276 = validateParameter(valid_28377276, JString, required = true,
                                   default = nil)
  if valid_28377276 != nil:
    section.add "name", valid_28377276
  var valid_28377277 = path.getOrDefault("repo")
  valid_28377277 = validateParameter(valid_28377277, JString, required = true,
                                   default = nil)
  if valid_28377277 != nil:
    section.add "repo", valid_28377277
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377278 = header.getOrDefault("Accept")
  valid_28377278 = validateParameter(valid_28377278, JString, required = false,
                                   default = nil)
  if valid_28377278 != nil:
    section.add "Accept", valid_28377278
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28377280: Call_PatchReposOwnerRepoLabelsName_28377272;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Update a label.
  ## 
  let valid = call_28377280.validator(path, query, header, formData, body)
  let scheme = call_28377280.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377280.url(scheme.get, call_28377280.host, call_28377280.base,
                           call_28377280.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377280, url, valid)

proc call*(call_28377281: Call_PatchReposOwnerRepoLabelsName_28377272;
          owner: string; name: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoLabelsName
  ## Update a label.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   name: string (required)
  ##       : Name of the label.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377282 = newJObject()
  var header_28377283 = newJObject()
  var body_28377284 = newJObject()
  add(path_28377282, "owner", newJString(owner))
  add(path_28377282, "name", newJString(name))
  add(header_28377283, "Accept", newJString(Accept))
  if body != nil:
    body_28377284 = body
  add(path_28377282, "repo", newJString(repo))
  result = call_28377281.call(path_28377282, nil, header_28377283, nil, body_28377284)

var patchReposOwnerRepoLabelsName* = Call_PatchReposOwnerRepoLabelsName_28377272(
    name: "patchReposOwnerRepoLabelsName", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels/{name}",
    validator: validate_PatchReposOwnerRepoLabelsName_28377273, base: "/",
    url: url_PatchReposOwnerRepoLabelsName_28377274, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoLabelsName_28377261 = ref object of OpenApiRestCall_28375350
proc url_DeleteReposOwnerRepoLabelsName_28377263(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoLabelsName_28377262(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   name: JString (required)
  ##       : Name of the label.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377264 = path.getOrDefault("owner")
  valid_28377264 = validateParameter(valid_28377264, JString, required = true,
                                   default = nil)
  if valid_28377264 != nil:
    section.add "owner", valid_28377264
  var valid_28377265 = path.getOrDefault("name")
  valid_28377265 = validateParameter(valid_28377265, JString, required = true,
                                   default = nil)
  if valid_28377265 != nil:
    section.add "name", valid_28377265
  var valid_28377266 = path.getOrDefault("repo")
  valid_28377266 = validateParameter(valid_28377266, JString, required = true,
                                   default = nil)
  if valid_28377266 != nil:
    section.add "repo", valid_28377266
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377267 = header.getOrDefault("Accept")
  valid_28377267 = validateParameter(valid_28377267, JString, required = false,
                                   default = nil)
  if valid_28377267 != nil:
    section.add "Accept", valid_28377267
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377268: Call_DeleteReposOwnerRepoLabelsName_28377261;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a label.
  ## 
  let valid = call_28377268.validator(path, query, header, formData, body)
  let scheme = call_28377268.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377268.url(scheme.get, call_28377268.host, call_28377268.base,
                           call_28377268.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377268, url, valid)

proc call*(call_28377269: Call_DeleteReposOwnerRepoLabelsName_28377261;
          owner: string; name: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoLabelsName
  ## Delete a label.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   name: string (required)
  ##       : Name of the label.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377270 = newJObject()
  var header_28377271 = newJObject()
  add(path_28377270, "owner", newJString(owner))
  add(path_28377270, "name", newJString(name))
  add(header_28377271, "Accept", newJString(Accept))
  add(path_28377270, "repo", newJString(repo))
  result = call_28377269.call(path_28377270, nil, header_28377271, nil, nil)

var deleteReposOwnerRepoLabelsName* = Call_DeleteReposOwnerRepoLabelsName_28377261(
    name: "deleteReposOwnerRepoLabelsName", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels/{name}",
    validator: validate_DeleteReposOwnerRepoLabelsName_28377262, base: "/",
    url: url_DeleteReposOwnerRepoLabelsName_28377263, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoLanguages_28377285 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoLanguages_28377287(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/languages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoLanguages_28377286(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List languages.
  ## List languages for the specified repository. The value on the right of a
  ## language is the number of bytes of code written in that language.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377288 = path.getOrDefault("owner")
  valid_28377288 = validateParameter(valid_28377288, JString, required = true,
                                   default = nil)
  if valid_28377288 != nil:
    section.add "owner", valid_28377288
  var valid_28377289 = path.getOrDefault("repo")
  valid_28377289 = validateParameter(valid_28377289, JString, required = true,
                                   default = nil)
  if valid_28377289 != nil:
    section.add "repo", valid_28377289
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377290 = header.getOrDefault("Accept")
  valid_28377290 = validateParameter(valid_28377290, JString, required = false,
                                   default = nil)
  if valid_28377290 != nil:
    section.add "Accept", valid_28377290
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377291: Call_GetReposOwnerRepoLanguages_28377285; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List languages.
  ## List languages for the specified repository. The value on the right of a
  ## language is the number of bytes of code written in that language.
  ## 
  ## 
  let valid = call_28377291.validator(path, query, header, formData, body)
  let scheme = call_28377291.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377291.url(scheme.get, call_28377291.host, call_28377291.base,
                           call_28377291.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377291, url, valid)

proc call*(call_28377292: Call_GetReposOwnerRepoLanguages_28377285; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoLanguages
  ## List languages.
  ## List languages for the specified repository. The value on the right of a
  ## language is the number of bytes of code written in that language.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377293 = newJObject()
  var header_28377294 = newJObject()
  add(path_28377293, "owner", newJString(owner))
  add(header_28377294, "Accept", newJString(Accept))
  add(path_28377293, "repo", newJString(repo))
  result = call_28377292.call(path_28377293, nil, header_28377294, nil, nil)

var getReposOwnerRepoLanguages* = Call_GetReposOwnerRepoLanguages_28377285(
    name: "getReposOwnerRepoLanguages", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/languages",
    validator: validate_GetReposOwnerRepoLanguages_28377286, base: "/",
    url: url_GetReposOwnerRepoLanguages_28377287, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoMerges_28377295 = ref object of OpenApiRestCall_28375350
proc url_PostReposOwnerRepoMerges_28377297(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/merges")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoMerges_28377296(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Perform a merge.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377298 = path.getOrDefault("owner")
  valid_28377298 = validateParameter(valid_28377298, JString, required = true,
                                   default = nil)
  if valid_28377298 != nil:
    section.add "owner", valid_28377298
  var valid_28377299 = path.getOrDefault("repo")
  valid_28377299 = validateParameter(valid_28377299, JString, required = true,
                                   default = nil)
  if valid_28377299 != nil:
    section.add "repo", valid_28377299
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377300 = header.getOrDefault("Accept")
  valid_28377300 = validateParameter(valid_28377300, JString, required = false,
                                   default = nil)
  if valid_28377300 != nil:
    section.add "Accept", valid_28377300
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28377302: Call_PostReposOwnerRepoMerges_28377295; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Perform a merge.
  ## 
  let valid = call_28377302.validator(path, query, header, formData, body)
  let scheme = call_28377302.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377302.url(scheme.get, call_28377302.host, call_28377302.base,
                           call_28377302.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377302, url, valid)

proc call*(call_28377303: Call_PostReposOwnerRepoMerges_28377295; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoMerges
  ## Perform a merge.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377304 = newJObject()
  var header_28377305 = newJObject()
  var body_28377306 = newJObject()
  add(path_28377304, "owner", newJString(owner))
  add(header_28377305, "Accept", newJString(Accept))
  if body != nil:
    body_28377306 = body
  add(path_28377304, "repo", newJString(repo))
  result = call_28377303.call(path_28377304, nil, header_28377305, nil, body_28377306)

var postReposOwnerRepoMerges* = Call_PostReposOwnerRepoMerges_28377295(
    name: "postReposOwnerRepoMerges", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/merges",
    validator: validate_PostReposOwnerRepoMerges_28377296, base: "/",
    url: url_PostReposOwnerRepoMerges_28377297, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoMilestones_28377321 = ref object of OpenApiRestCall_28375350
proc url_PostReposOwnerRepoMilestones_28377323(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoMilestones_28377322(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377324 = path.getOrDefault("owner")
  valid_28377324 = validateParameter(valid_28377324, JString, required = true,
                                   default = nil)
  if valid_28377324 != nil:
    section.add "owner", valid_28377324
  var valid_28377325 = path.getOrDefault("repo")
  valid_28377325 = validateParameter(valid_28377325, JString, required = true,
                                   default = nil)
  if valid_28377325 != nil:
    section.add "repo", valid_28377325
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377326 = header.getOrDefault("Accept")
  valid_28377326 = validateParameter(valid_28377326, JString, required = false,
                                   default = nil)
  if valid_28377326 != nil:
    section.add "Accept", valid_28377326
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28377328: Call_PostReposOwnerRepoMilestones_28377321;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Create a milestone.
  ## 
  let valid = call_28377328.validator(path, query, header, formData, body)
  let scheme = call_28377328.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377328.url(scheme.get, call_28377328.host, call_28377328.base,
                           call_28377328.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377328, url, valid)

proc call*(call_28377329: Call_PostReposOwnerRepoMilestones_28377321;
          owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoMilestones
  ## Create a milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377330 = newJObject()
  var header_28377331 = newJObject()
  var body_28377332 = newJObject()
  add(path_28377330, "owner", newJString(owner))
  add(header_28377331, "Accept", newJString(Accept))
  if body != nil:
    body_28377332 = body
  add(path_28377330, "repo", newJString(repo))
  result = call_28377329.call(path_28377330, nil, header_28377331, nil, body_28377332)

var postReposOwnerRepoMilestones* = Call_PostReposOwnerRepoMilestones_28377321(
    name: "postReposOwnerRepoMilestones", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones",
    validator: validate_PostReposOwnerRepoMilestones_28377322, base: "/",
    url: url_PostReposOwnerRepoMilestones_28377323, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoMilestones_28377307 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoMilestones_28377309(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoMilestones_28377308(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List milestones for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377310 = path.getOrDefault("owner")
  valid_28377310 = validateParameter(valid_28377310, JString, required = true,
                                   default = nil)
  if valid_28377310 != nil:
    section.add "owner", valid_28377310
  var valid_28377311 = path.getOrDefault("repo")
  valid_28377311 = validateParameter(valid_28377311, JString, required = true,
                                   default = nil)
  if valid_28377311 != nil:
    section.add "repo", valid_28377311
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString
  ##        : String to filter by state.
  ##   sort: JString
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  section = newJObject()
  var valid_28377312 = query.getOrDefault("state")
  valid_28377312 = validateParameter(valid_28377312, JString, required = false,
                                   default = newJString("open"))
  if valid_28377312 != nil:
    section.add "state", valid_28377312
  var valid_28377313 = query.getOrDefault("sort")
  valid_28377313 = validateParameter(valid_28377313, JString, required = false,
                                   default = newJString("due_date"))
  if valid_28377313 != nil:
    section.add "sort", valid_28377313
  var valid_28377314 = query.getOrDefault("direction")
  valid_28377314 = validateParameter(valid_28377314, JString, required = false,
                                   default = nil)
  if valid_28377314 != nil:
    section.add "direction", valid_28377314
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377315 = header.getOrDefault("Accept")
  valid_28377315 = validateParameter(valid_28377315, JString, required = false,
                                   default = nil)
  if valid_28377315 != nil:
    section.add "Accept", valid_28377315
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377316: Call_GetReposOwnerRepoMilestones_28377307;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List milestones for a repository.
  ## 
  let valid = call_28377316.validator(path, query, header, formData, body)
  let scheme = call_28377316.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377316.url(scheme.get, call_28377316.host, call_28377316.base,
                           call_28377316.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377316, url, valid)

proc call*(call_28377317: Call_GetReposOwnerRepoMilestones_28377307; owner: string;
          repo: string; state: string = "open"; Accept: string = "";
          sort: string = "due_date"; direction: string = ""): Recallable =
  ## getReposOwnerRepoMilestones
  ## List milestones for a repository.
  ##   state: string
  ##        : String to filter by state.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   sort: string
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  var path_28377318 = newJObject()
  var query_28377319 = newJObject()
  var header_28377320 = newJObject()
  add(query_28377319, "state", newJString(state))
  add(path_28377318, "owner", newJString(owner))
  add(header_28377320, "Accept", newJString(Accept))
  add(path_28377318, "repo", newJString(repo))
  add(query_28377319, "sort", newJString(sort))
  add(query_28377319, "direction", newJString(direction))
  result = call_28377317.call(path_28377318, query_28377319, header_28377320, nil, nil)

var getReposOwnerRepoMilestones* = Call_GetReposOwnerRepoMilestones_28377307(
    name: "getReposOwnerRepoMilestones", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones",
    validator: validate_GetReposOwnerRepoMilestones_28377308, base: "/",
    url: url_GetReposOwnerRepoMilestones_28377309, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoMilestonesNumber_28377333 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoMilestonesNumber_28377335(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoMilestonesNumber_28377334(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377336 = path.getOrDefault("owner")
  valid_28377336 = validateParameter(valid_28377336, JString, required = true,
                                   default = nil)
  if valid_28377336 != nil:
    section.add "owner", valid_28377336
  var valid_28377337 = path.getOrDefault("number")
  valid_28377337 = validateParameter(valid_28377337, JInt, required = true,
                                   default = nil)
  if valid_28377337 != nil:
    section.add "number", valid_28377337
  var valid_28377338 = path.getOrDefault("repo")
  valid_28377338 = validateParameter(valid_28377338, JString, required = true,
                                   default = nil)
  if valid_28377338 != nil:
    section.add "repo", valid_28377338
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377339 = header.getOrDefault("Accept")
  valid_28377339 = validateParameter(valid_28377339, JString, required = false,
                                   default = nil)
  if valid_28377339 != nil:
    section.add "Accept", valid_28377339
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377340: Call_GetReposOwnerRepoMilestonesNumber_28377333;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single milestone.
  ## 
  let valid = call_28377340.validator(path, query, header, formData, body)
  let scheme = call_28377340.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377340.url(scheme.get, call_28377340.host, call_28377340.base,
                           call_28377340.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377340, url, valid)

proc call*(call_28377341: Call_GetReposOwnerRepoMilestonesNumber_28377333;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoMilestonesNumber
  ## Get a single milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377342 = newJObject()
  var header_28377343 = newJObject()
  add(path_28377342, "owner", newJString(owner))
  add(path_28377342, "number", newJInt(number))
  add(header_28377343, "Accept", newJString(Accept))
  add(path_28377342, "repo", newJString(repo))
  result = call_28377341.call(path_28377342, nil, header_28377343, nil, nil)

var getReposOwnerRepoMilestonesNumber* = Call_GetReposOwnerRepoMilestonesNumber_28377333(
    name: "getReposOwnerRepoMilestonesNumber", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones/{number}",
    validator: validate_GetReposOwnerRepoMilestonesNumber_28377334, base: "/",
    url: url_GetReposOwnerRepoMilestonesNumber_28377335, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoMilestonesNumber_28377355 = ref object of OpenApiRestCall_28375350
proc url_PatchReposOwnerRepoMilestonesNumber_28377357(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoMilestonesNumber_28377356(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Update a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377358 = path.getOrDefault("owner")
  valid_28377358 = validateParameter(valid_28377358, JString, required = true,
                                   default = nil)
  if valid_28377358 != nil:
    section.add "owner", valid_28377358
  var valid_28377359 = path.getOrDefault("number")
  valid_28377359 = validateParameter(valid_28377359, JInt, required = true,
                                   default = nil)
  if valid_28377359 != nil:
    section.add "number", valid_28377359
  var valid_28377360 = path.getOrDefault("repo")
  valid_28377360 = validateParameter(valid_28377360, JString, required = true,
                                   default = nil)
  if valid_28377360 != nil:
    section.add "repo", valid_28377360
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377361 = header.getOrDefault("Accept")
  valid_28377361 = validateParameter(valid_28377361, JString, required = false,
                                   default = nil)
  if valid_28377361 != nil:
    section.add "Accept", valid_28377361
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28377363: Call_PatchReposOwnerRepoMilestonesNumber_28377355;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Update a milestone.
  ## 
  let valid = call_28377363.validator(path, query, header, formData, body)
  let scheme = call_28377363.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377363.url(scheme.get, call_28377363.host, call_28377363.base,
                           call_28377363.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377363, url, valid)

proc call*(call_28377364: Call_PatchReposOwnerRepoMilestonesNumber_28377355;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoMilestonesNumber
  ## Update a milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377365 = newJObject()
  var header_28377366 = newJObject()
  var body_28377367 = newJObject()
  add(path_28377365, "owner", newJString(owner))
  add(path_28377365, "number", newJInt(number))
  add(header_28377366, "Accept", newJString(Accept))
  if body != nil:
    body_28377367 = body
  add(path_28377365, "repo", newJString(repo))
  result = call_28377364.call(path_28377365, nil, header_28377366, nil, body_28377367)

var patchReposOwnerRepoMilestonesNumber* = Call_PatchReposOwnerRepoMilestonesNumber_28377355(
    name: "patchReposOwnerRepoMilestonesNumber", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones/{number}",
    validator: validate_PatchReposOwnerRepoMilestonesNumber_28377356, base: "/",
    url: url_PatchReposOwnerRepoMilestonesNumber_28377357, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoMilestonesNumber_28377344 = ref object of OpenApiRestCall_28375350
proc url_DeleteReposOwnerRepoMilestonesNumber_28377346(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoMilestonesNumber_28377345(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377347 = path.getOrDefault("owner")
  valid_28377347 = validateParameter(valid_28377347, JString, required = true,
                                   default = nil)
  if valid_28377347 != nil:
    section.add "owner", valid_28377347
  var valid_28377348 = path.getOrDefault("number")
  valid_28377348 = validateParameter(valid_28377348, JInt, required = true,
                                   default = nil)
  if valid_28377348 != nil:
    section.add "number", valid_28377348
  var valid_28377349 = path.getOrDefault("repo")
  valid_28377349 = validateParameter(valid_28377349, JString, required = true,
                                   default = nil)
  if valid_28377349 != nil:
    section.add "repo", valid_28377349
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377350 = header.getOrDefault("Accept")
  valid_28377350 = validateParameter(valid_28377350, JString, required = false,
                                   default = nil)
  if valid_28377350 != nil:
    section.add "Accept", valid_28377350
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377351: Call_DeleteReposOwnerRepoMilestonesNumber_28377344;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a milestone.
  ## 
  let valid = call_28377351.validator(path, query, header, formData, body)
  let scheme = call_28377351.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377351.url(scheme.get, call_28377351.host, call_28377351.base,
                           call_28377351.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377351, url, valid)

proc call*(call_28377352: Call_DeleteReposOwnerRepoMilestonesNumber_28377344;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoMilestonesNumber
  ## Delete a milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377353 = newJObject()
  var header_28377354 = newJObject()
  add(path_28377353, "owner", newJString(owner))
  add(path_28377353, "number", newJInt(number))
  add(header_28377354, "Accept", newJString(Accept))
  add(path_28377353, "repo", newJString(repo))
  result = call_28377352.call(path_28377353, nil, header_28377354, nil, nil)

var deleteReposOwnerRepoMilestonesNumber* = Call_DeleteReposOwnerRepoMilestonesNumber_28377344(
    name: "deleteReposOwnerRepoMilestonesNumber", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones/{number}",
    validator: validate_DeleteReposOwnerRepoMilestonesNumber_28377345, base: "/",
    url: url_DeleteReposOwnerRepoMilestonesNumber_28377346,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoMilestonesNumberLabels_28377368 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoMilestonesNumberLabels_28377370(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoMilestonesNumberLabels_28377369(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get labels for every issue in a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377371 = path.getOrDefault("owner")
  valid_28377371 = validateParameter(valid_28377371, JString, required = true,
                                   default = nil)
  if valid_28377371 != nil:
    section.add "owner", valid_28377371
  var valid_28377372 = path.getOrDefault("number")
  valid_28377372 = validateParameter(valid_28377372, JInt, required = true,
                                   default = nil)
  if valid_28377372 != nil:
    section.add "number", valid_28377372
  var valid_28377373 = path.getOrDefault("repo")
  valid_28377373 = validateParameter(valid_28377373, JString, required = true,
                                   default = nil)
  if valid_28377373 != nil:
    section.add "repo", valid_28377373
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377374 = header.getOrDefault("Accept")
  valid_28377374 = validateParameter(valid_28377374, JString, required = false,
                                   default = nil)
  if valid_28377374 != nil:
    section.add "Accept", valid_28377374
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377375: Call_GetReposOwnerRepoMilestonesNumberLabels_28377368;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get labels for every issue in a milestone.
  ## 
  let valid = call_28377375.validator(path, query, header, formData, body)
  let scheme = call_28377375.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377375.url(scheme.get, call_28377375.host, call_28377375.base,
                           call_28377375.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377375, url, valid)

proc call*(call_28377376: Call_GetReposOwnerRepoMilestonesNumberLabels_28377368;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoMilestonesNumberLabels
  ## Get labels for every issue in a milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377377 = newJObject()
  var header_28377378 = newJObject()
  add(path_28377377, "owner", newJString(owner))
  add(path_28377377, "number", newJInt(number))
  add(header_28377378, "Accept", newJString(Accept))
  add(path_28377377, "repo", newJString(repo))
  result = call_28377376.call(path_28377377, nil, header_28377378, nil, nil)

var getReposOwnerRepoMilestonesNumberLabels* = Call_GetReposOwnerRepoMilestonesNumberLabels_28377368(
    name: "getReposOwnerRepoMilestonesNumberLabels", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/milestones/{number}/labels",
    validator: validate_GetReposOwnerRepoMilestonesNumberLabels_28377369,
    base: "/", url: url_GetReposOwnerRepoMilestonesNumberLabels_28377370,
    schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoNotifications_28377393 = ref object of OpenApiRestCall_28375350
proc url_PutReposOwnerRepoNotifications_28377395(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/notifications")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoNotifications_28377394(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Mark notifications as read in a repository.
  ## Marking all notifications in a repository as "read" removes them from the
  ## default view on GitHub.com.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377396 = path.getOrDefault("owner")
  valid_28377396 = validateParameter(valid_28377396, JString, required = true,
                                   default = nil)
  if valid_28377396 != nil:
    section.add "owner", valid_28377396
  var valid_28377397 = path.getOrDefault("repo")
  valid_28377397 = validateParameter(valid_28377397, JString, required = true,
                                   default = nil)
  if valid_28377397 != nil:
    section.add "repo", valid_28377397
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377398 = header.getOrDefault("Accept")
  valid_28377398 = validateParameter(valid_28377398, JString, required = false,
                                   default = nil)
  if valid_28377398 != nil:
    section.add "Accept", valid_28377398
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28377400: Call_PutReposOwnerRepoNotifications_28377393;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Mark notifications as read in a repository.
  ## Marking all notifications in a repository as "read" removes them from the
  ## default view on GitHub.com.
  ## 
  ## 
  let valid = call_28377400.validator(path, query, header, formData, body)
  let scheme = call_28377400.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377400.url(scheme.get, call_28377400.host, call_28377400.base,
                           call_28377400.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377400, url, valid)

proc call*(call_28377401: Call_PutReposOwnerRepoNotifications_28377393;
          owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoNotifications
  ## Mark notifications as read in a repository.
  ## Marking all notifications in a repository as "read" removes them from the
  ## default view on GitHub.com.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377402 = newJObject()
  var header_28377403 = newJObject()
  var body_28377404 = newJObject()
  add(path_28377402, "owner", newJString(owner))
  add(header_28377403, "Accept", newJString(Accept))
  if body != nil:
    body_28377404 = body
  add(path_28377402, "repo", newJString(repo))
  result = call_28377401.call(path_28377402, nil, header_28377403, nil, body_28377404)

var putReposOwnerRepoNotifications* = Call_PutReposOwnerRepoNotifications_28377393(
    name: "putReposOwnerRepoNotifications", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/notifications",
    validator: validate_PutReposOwnerRepoNotifications_28377394, base: "/",
    url: url_PutReposOwnerRepoNotifications_28377395, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoNotifications_28377379 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoNotifications_28377381(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/notifications")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoNotifications_28377380(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List your notifications in a repository
  ## List all notifications for the current user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377382 = path.getOrDefault("owner")
  valid_28377382 = validateParameter(valid_28377382, JString, required = true,
                                   default = nil)
  if valid_28377382 != nil:
    section.add "owner", valid_28377382
  var valid_28377383 = path.getOrDefault("repo")
  valid_28377383 = validateParameter(valid_28377383, JString, required = true,
                                   default = nil)
  if valid_28377383 != nil:
    section.add "repo", valid_28377383
  result.add "path", section
  ## parameters in `query` object:
  ##   participating: JBool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  ##   all: JBool
  ##      : True to show notifications marked as read.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_28377384 = query.getOrDefault("participating")
  valid_28377384 = validateParameter(valid_28377384, JBool, required = false,
                                   default = nil)
  if valid_28377384 != nil:
    section.add "participating", valid_28377384
  var valid_28377385 = query.getOrDefault("all")
  valid_28377385 = validateParameter(valid_28377385, JBool, required = false,
                                   default = nil)
  if valid_28377385 != nil:
    section.add "all", valid_28377385
  var valid_28377386 = query.getOrDefault("since")
  valid_28377386 = validateParameter(valid_28377386, JString, required = false,
                                   default = nil)
  if valid_28377386 != nil:
    section.add "since", valid_28377386
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377387 = header.getOrDefault("Accept")
  valid_28377387 = validateParameter(valid_28377387, JString, required = false,
                                   default = nil)
  if valid_28377387 != nil:
    section.add "Accept", valid_28377387
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377388: Call_GetReposOwnerRepoNotifications_28377379;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List your notifications in a repository
  ## List all notifications for the current user.
  ## 
  ## 
  let valid = call_28377388.validator(path, query, header, formData, body)
  let scheme = call_28377388.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377388.url(scheme.get, call_28377388.host, call_28377388.base,
                           call_28377388.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377388, url, valid)

proc call*(call_28377389: Call_GetReposOwnerRepoNotifications_28377379;
          owner: string; repo: string; participating: bool = false; all: bool = false;
          Accept: string = ""; since: string = ""): Recallable =
  ## getReposOwnerRepoNotifications
  ## List your notifications in a repository
  ## List all notifications for the current user.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   participating: bool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  ##   all: bool
  ##      : True to show notifications marked as read.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var path_28377390 = newJObject()
  var query_28377391 = newJObject()
  var header_28377392 = newJObject()
  add(path_28377390, "owner", newJString(owner))
  add(query_28377391, "participating", newJBool(participating))
  add(query_28377391, "all", newJBool(all))
  add(header_28377392, "Accept", newJString(Accept))
  add(path_28377390, "repo", newJString(repo))
  add(query_28377391, "since", newJString(since))
  result = call_28377389.call(path_28377390, query_28377391, header_28377392, nil, nil)

var getReposOwnerRepoNotifications* = Call_GetReposOwnerRepoNotifications_28377379(
    name: "getReposOwnerRepoNotifications", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/notifications",
    validator: validate_GetReposOwnerRepoNotifications_28377380, base: "/",
    url: url_GetReposOwnerRepoNotifications_28377381, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoPulls_28377419 = ref object of OpenApiRestCall_28375350
proc url_PostReposOwnerRepoPulls_28377421(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoPulls_28377420(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377422 = path.getOrDefault("owner")
  valid_28377422 = validateParameter(valid_28377422, JString, required = true,
                                   default = nil)
  if valid_28377422 != nil:
    section.add "owner", valid_28377422
  var valid_28377423 = path.getOrDefault("repo")
  valid_28377423 = validateParameter(valid_28377423, JString, required = true,
                                   default = nil)
  if valid_28377423 != nil:
    section.add "repo", valid_28377423
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377424 = header.getOrDefault("Accept")
  valid_28377424 = validateParameter(valid_28377424, JString, required = false,
                                   default = nil)
  if valid_28377424 != nil:
    section.add "Accept", valid_28377424
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28377426: Call_PostReposOwnerRepoPulls_28377419; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a pull request.
  ## 
  let valid = call_28377426.validator(path, query, header, formData, body)
  let scheme = call_28377426.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377426.url(scheme.get, call_28377426.host, call_28377426.base,
                           call_28377426.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377426, url, valid)

proc call*(call_28377427: Call_PostReposOwnerRepoPulls_28377419; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoPulls
  ## Create a pull request.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377428 = newJObject()
  var header_28377429 = newJObject()
  var body_28377430 = newJObject()
  add(path_28377428, "owner", newJString(owner))
  add(header_28377429, "Accept", newJString(Accept))
  if body != nil:
    body_28377430 = body
  add(path_28377428, "repo", newJString(repo))
  result = call_28377427.call(path_28377428, nil, header_28377429, nil, body_28377430)

var postReposOwnerRepoPulls* = Call_PostReposOwnerRepoPulls_28377419(
    name: "postReposOwnerRepoPulls", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls",
    validator: validate_PostReposOwnerRepoPulls_28377420, base: "/",
    url: url_PostReposOwnerRepoPulls_28377421, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPulls_28377405 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoPulls_28377407(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPulls_28377406(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List pull requests.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377408 = path.getOrDefault("owner")
  valid_28377408 = validateParameter(valid_28377408, JString, required = true,
                                   default = nil)
  if valid_28377408 != nil:
    section.add "owner", valid_28377408
  var valid_28377409 = path.getOrDefault("repo")
  valid_28377409 = validateParameter(valid_28377409, JString, required = true,
                                   default = nil)
  if valid_28377409 != nil:
    section.add "repo", valid_28377409
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString
  ##        : String to filter by state.
  ##   head: JString
  ##       : Filter pulls by head user and branch name in the format of 'user:ref-name'.
  ## Example: github:new-script-format.
  ## 
  ##   base: JString
  ##       : Filter pulls by base branch name. Example - gh-pages.
  section = newJObject()
  var valid_28377410 = query.getOrDefault("state")
  valid_28377410 = validateParameter(valid_28377410, JString, required = false,
                                   default = newJString("open"))
  if valid_28377410 != nil:
    section.add "state", valid_28377410
  var valid_28377411 = query.getOrDefault("head")
  valid_28377411 = validateParameter(valid_28377411, JString, required = false,
                                   default = nil)
  if valid_28377411 != nil:
    section.add "head", valid_28377411
  var valid_28377412 = query.getOrDefault("base")
  valid_28377412 = validateParameter(valid_28377412, JString, required = false,
                                   default = nil)
  if valid_28377412 != nil:
    section.add "base", valid_28377412
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377413 = header.getOrDefault("Accept")
  valid_28377413 = validateParameter(valid_28377413, JString, required = false,
                                   default = nil)
  if valid_28377413 != nil:
    section.add "Accept", valid_28377413
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377414: Call_GetReposOwnerRepoPulls_28377405; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List pull requests.
  ## 
  let valid = call_28377414.validator(path, query, header, formData, body)
  let scheme = call_28377414.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377414.url(scheme.get, call_28377414.host, call_28377414.base,
                           call_28377414.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377414, url, valid)

proc call*(call_28377415: Call_GetReposOwnerRepoPulls_28377405; owner: string;
          repo: string; state: string = "open"; head: string = ""; base: string = "";
          Accept: string = ""): Recallable =
  ## getReposOwnerRepoPulls
  ## List pull requests.
  ##   state: string
  ##        : String to filter by state.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   head: string
  ##       : Filter pulls by head user and branch name in the format of 'user:ref-name'.
  ## Example: github:new-script-format.
  ## 
  ##   base: string
  ##       : Filter pulls by base branch name. Example - gh-pages.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377416 = newJObject()
  var query_28377417 = newJObject()
  var header_28377418 = newJObject()
  add(query_28377417, "state", newJString(state))
  add(path_28377416, "owner", newJString(owner))
  add(query_28377417, "head", newJString(head))
  add(query_28377417, "base", newJString(base))
  add(header_28377418, "Accept", newJString(Accept))
  add(path_28377416, "repo", newJString(repo))
  result = call_28377415.call(path_28377416, query_28377417, header_28377418, nil, nil)

var getReposOwnerRepoPulls* = Call_GetReposOwnerRepoPulls_28377405(
    name: "getReposOwnerRepoPulls", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls",
    validator: validate_GetReposOwnerRepoPulls_28377406, base: "/",
    url: url_GetReposOwnerRepoPulls_28377407, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsComments_28377431 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoPullsComments_28377433(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsComments_28377432(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List comments in a repository.
  ## By default, Review Comments are ordered by ascending ID.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377434 = path.getOrDefault("owner")
  valid_28377434 = validateParameter(valid_28377434, JString, required = true,
                                   default = nil)
  if valid_28377434 != nil:
    section.add "owner", valid_28377434
  var valid_28377435 = path.getOrDefault("repo")
  valid_28377435 = validateParameter(valid_28377435, JString, required = true,
                                   default = nil)
  if valid_28377435 != nil:
    section.add "repo", valid_28377435
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_28377436 = query.getOrDefault("sort")
  valid_28377436 = validateParameter(valid_28377436, JString, required = false,
                                   default = newJString("created"))
  if valid_28377436 != nil:
    section.add "sort", valid_28377436
  var valid_28377437 = query.getOrDefault("direction")
  valid_28377437 = validateParameter(valid_28377437, JString, required = false,
                                   default = nil)
  if valid_28377437 != nil:
    section.add "direction", valid_28377437
  var valid_28377438 = query.getOrDefault("since")
  valid_28377438 = validateParameter(valid_28377438, JString, required = false,
                                   default = nil)
  if valid_28377438 != nil:
    section.add "since", valid_28377438
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377439 = header.getOrDefault("Accept")
  valid_28377439 = validateParameter(valid_28377439, JString, required = false,
                                   default = nil)
  if valid_28377439 != nil:
    section.add "Accept", valid_28377439
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377440: Call_GetReposOwnerRepoPullsComments_28377431;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List comments in a repository.
  ## By default, Review Comments are ordered by ascending ID.
  ## 
  ## 
  let valid = call_28377440.validator(path, query, header, formData, body)
  let scheme = call_28377440.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377440.url(scheme.get, call_28377440.host, call_28377440.base,
                           call_28377440.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377440, url, valid)

proc call*(call_28377441: Call_GetReposOwnerRepoPullsComments_28377431;
          owner: string; repo: string; Accept: string = ""; sort: string = "created";
          direction: string = ""; since: string = ""): Recallable =
  ## getReposOwnerRepoPullsComments
  ## List comments in a repository.
  ## By default, Review Comments are ordered by ascending ID.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   sort: string
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var path_28377442 = newJObject()
  var query_28377443 = newJObject()
  var header_28377444 = newJObject()
  add(path_28377442, "owner", newJString(owner))
  add(header_28377444, "Accept", newJString(Accept))
  add(path_28377442, "repo", newJString(repo))
  add(query_28377443, "sort", newJString(sort))
  add(query_28377443, "direction", newJString(direction))
  add(query_28377443, "since", newJString(since))
  result = call_28377441.call(path_28377442, query_28377443, header_28377444, nil, nil)

var getReposOwnerRepoPullsComments* = Call_GetReposOwnerRepoPullsComments_28377431(
    name: "getReposOwnerRepoPullsComments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/comments",
    validator: validate_GetReposOwnerRepoPullsComments_28377432, base: "/",
    url: url_GetReposOwnerRepoPullsComments_28377433, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsCommentsCommentId_28377445 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoPullsCommentsCommentId_28377447(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsCommentsCommentId_28377446(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377448 = path.getOrDefault("owner")
  valid_28377448 = validateParameter(valid_28377448, JString, required = true,
                                   default = nil)
  if valid_28377448 != nil:
    section.add "owner", valid_28377448
  var valid_28377449 = path.getOrDefault("repo")
  valid_28377449 = validateParameter(valid_28377449, JString, required = true,
                                   default = nil)
  if valid_28377449 != nil:
    section.add "repo", valid_28377449
  var valid_28377450 = path.getOrDefault("commentId")
  valid_28377450 = validateParameter(valid_28377450, JInt, required = true,
                                   default = nil)
  if valid_28377450 != nil:
    section.add "commentId", valid_28377450
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377451 = header.getOrDefault("Accept")
  valid_28377451 = validateParameter(valid_28377451, JString, required = false,
                                   default = nil)
  if valid_28377451 != nil:
    section.add "Accept", valid_28377451
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377452: Call_GetReposOwnerRepoPullsCommentsCommentId_28377445;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single comment.
  ## 
  let valid = call_28377452.validator(path, query, header, formData, body)
  let scheme = call_28377452.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377452.url(scheme.get, call_28377452.host, call_28377452.base,
                           call_28377452.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377452, url, valid)

proc call*(call_28377453: Call_GetReposOwnerRepoPullsCommentsCommentId_28377445;
          owner: string; repo: string; commentId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsCommentsCommentId
  ## Get a single comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_28377454 = newJObject()
  var header_28377455 = newJObject()
  add(path_28377454, "owner", newJString(owner))
  add(header_28377455, "Accept", newJString(Accept))
  add(path_28377454, "repo", newJString(repo))
  add(path_28377454, "commentId", newJInt(commentId))
  result = call_28377453.call(path_28377454, nil, header_28377455, nil, nil)

var getReposOwnerRepoPullsCommentsCommentId* = Call_GetReposOwnerRepoPullsCommentsCommentId_28377445(
    name: "getReposOwnerRepoPullsCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/comments/{commentId}",
    validator: validate_GetReposOwnerRepoPullsCommentsCommentId_28377446,
    base: "/", url: url_GetReposOwnerRepoPullsCommentsCommentId_28377447,
    schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoPullsCommentsCommentId_28377467 = ref object of OpenApiRestCall_28375350
proc url_PatchReposOwnerRepoPullsCommentsCommentId_28377469(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoPullsCommentsCommentId_28377468(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Edit a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377470 = path.getOrDefault("owner")
  valid_28377470 = validateParameter(valid_28377470, JString, required = true,
                                   default = nil)
  if valid_28377470 != nil:
    section.add "owner", valid_28377470
  var valid_28377471 = path.getOrDefault("repo")
  valid_28377471 = validateParameter(valid_28377471, JString, required = true,
                                   default = nil)
  if valid_28377471 != nil:
    section.add "repo", valid_28377471
  var valid_28377472 = path.getOrDefault("commentId")
  valid_28377472 = validateParameter(valid_28377472, JInt, required = true,
                                   default = nil)
  if valid_28377472 != nil:
    section.add "commentId", valid_28377472
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377473 = header.getOrDefault("Accept")
  valid_28377473 = validateParameter(valid_28377473, JString, required = false,
                                   default = nil)
  if valid_28377473 != nil:
    section.add "Accept", valid_28377473
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28377475: Call_PatchReposOwnerRepoPullsCommentsCommentId_28377467;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Edit a comment.
  ## 
  let valid = call_28377475.validator(path, query, header, formData, body)
  let scheme = call_28377475.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377475.url(scheme.get, call_28377475.host, call_28377475.base,
                           call_28377475.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377475, url, valid)

proc call*(call_28377476: Call_PatchReposOwnerRepoPullsCommentsCommentId_28377467;
          owner: string; body: JsonNode; repo: string; commentId: int;
          Accept: string = ""): Recallable =
  ## patchReposOwnerRepoPullsCommentsCommentId
  ## Edit a comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_28377477 = newJObject()
  var header_28377478 = newJObject()
  var body_28377479 = newJObject()
  add(path_28377477, "owner", newJString(owner))
  add(header_28377478, "Accept", newJString(Accept))
  if body != nil:
    body_28377479 = body
  add(path_28377477, "repo", newJString(repo))
  add(path_28377477, "commentId", newJInt(commentId))
  result = call_28377476.call(path_28377477, nil, header_28377478, nil, body_28377479)

var patchReposOwnerRepoPullsCommentsCommentId* = Call_PatchReposOwnerRepoPullsCommentsCommentId_28377467(
    name: "patchReposOwnerRepoPullsCommentsCommentId", meth: HttpMethod.HttpPatch,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/comments/{commentId}",
    validator: validate_PatchReposOwnerRepoPullsCommentsCommentId_28377468,
    base: "/", url: url_PatchReposOwnerRepoPullsCommentsCommentId_28377469,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoPullsCommentsCommentId_28377456 = ref object of OpenApiRestCall_28375350
proc url_DeleteReposOwnerRepoPullsCommentsCommentId_28377458(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoPullsCommentsCommentId_28377457(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377459 = path.getOrDefault("owner")
  valid_28377459 = validateParameter(valid_28377459, JString, required = true,
                                   default = nil)
  if valid_28377459 != nil:
    section.add "owner", valid_28377459
  var valid_28377460 = path.getOrDefault("repo")
  valid_28377460 = validateParameter(valid_28377460, JString, required = true,
                                   default = nil)
  if valid_28377460 != nil:
    section.add "repo", valid_28377460
  var valid_28377461 = path.getOrDefault("commentId")
  valid_28377461 = validateParameter(valid_28377461, JInt, required = true,
                                   default = nil)
  if valid_28377461 != nil:
    section.add "commentId", valid_28377461
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377462 = header.getOrDefault("Accept")
  valid_28377462 = validateParameter(valid_28377462, JString, required = false,
                                   default = nil)
  if valid_28377462 != nil:
    section.add "Accept", valid_28377462
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377463: Call_DeleteReposOwnerRepoPullsCommentsCommentId_28377456;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a comment.
  ## 
  let valid = call_28377463.validator(path, query, header, formData, body)
  let scheme = call_28377463.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377463.url(scheme.get, call_28377463.host, call_28377463.base,
                           call_28377463.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377463, url, valid)

proc call*(call_28377464: Call_DeleteReposOwnerRepoPullsCommentsCommentId_28377456;
          owner: string; repo: string; commentId: int; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoPullsCommentsCommentId
  ## Delete a comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_28377465 = newJObject()
  var header_28377466 = newJObject()
  add(path_28377465, "owner", newJString(owner))
  add(header_28377466, "Accept", newJString(Accept))
  add(path_28377465, "repo", newJString(repo))
  add(path_28377465, "commentId", newJInt(commentId))
  result = call_28377464.call(path_28377465, nil, header_28377466, nil, nil)

var deleteReposOwnerRepoPullsCommentsCommentId* = Call_DeleteReposOwnerRepoPullsCommentsCommentId_28377456(
    name: "deleteReposOwnerRepoPullsCommentsCommentId",
    meth: HttpMethod.HttpDelete, host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/comments/{commentId}",
    validator: validate_DeleteReposOwnerRepoPullsCommentsCommentId_28377457,
    base: "/", url: url_DeleteReposOwnerRepoPullsCommentsCommentId_28377458,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumber_28377480 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoPullsNumber_28377482(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumber_28377481(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377483 = path.getOrDefault("owner")
  valid_28377483 = validateParameter(valid_28377483, JString, required = true,
                                   default = nil)
  if valid_28377483 != nil:
    section.add "owner", valid_28377483
  var valid_28377484 = path.getOrDefault("number")
  valid_28377484 = validateParameter(valid_28377484, JInt, required = true,
                                   default = nil)
  if valid_28377484 != nil:
    section.add "number", valid_28377484
  var valid_28377485 = path.getOrDefault("repo")
  valid_28377485 = validateParameter(valid_28377485, JString, required = true,
                                   default = nil)
  if valid_28377485 != nil:
    section.add "repo", valid_28377485
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377486 = header.getOrDefault("Accept")
  valid_28377486 = validateParameter(valid_28377486, JString, required = false,
                                   default = nil)
  if valid_28377486 != nil:
    section.add "Accept", valid_28377486
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377487: Call_GetReposOwnerRepoPullsNumber_28377480;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single pull request.
  ## 
  let valid = call_28377487.validator(path, query, header, formData, body)
  let scheme = call_28377487.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377487.url(scheme.get, call_28377487.host, call_28377487.base,
                           call_28377487.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377487, url, valid)

proc call*(call_28377488: Call_GetReposOwnerRepoPullsNumber_28377480;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumber
  ## Get a single pull request.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377489 = newJObject()
  var header_28377490 = newJObject()
  add(path_28377489, "owner", newJString(owner))
  add(path_28377489, "number", newJInt(number))
  add(header_28377490, "Accept", newJString(Accept))
  add(path_28377489, "repo", newJString(repo))
  result = call_28377488.call(path_28377489, nil, header_28377490, nil, nil)

var getReposOwnerRepoPullsNumber* = Call_GetReposOwnerRepoPullsNumber_28377480(
    name: "getReposOwnerRepoPullsNumber", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}",
    validator: validate_GetReposOwnerRepoPullsNumber_28377481, base: "/",
    url: url_GetReposOwnerRepoPullsNumber_28377482, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoPullsNumber_28377491 = ref object of OpenApiRestCall_28375350
proc url_PatchReposOwnerRepoPullsNumber_28377493(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoPullsNumber_28377492(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Update a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377494 = path.getOrDefault("owner")
  valid_28377494 = validateParameter(valid_28377494, JString, required = true,
                                   default = nil)
  if valid_28377494 != nil:
    section.add "owner", valid_28377494
  var valid_28377495 = path.getOrDefault("number")
  valid_28377495 = validateParameter(valid_28377495, JInt, required = true,
                                   default = nil)
  if valid_28377495 != nil:
    section.add "number", valid_28377495
  var valid_28377496 = path.getOrDefault("repo")
  valid_28377496 = validateParameter(valid_28377496, JString, required = true,
                                   default = nil)
  if valid_28377496 != nil:
    section.add "repo", valid_28377496
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377497 = header.getOrDefault("Accept")
  valid_28377497 = validateParameter(valid_28377497, JString, required = false,
                                   default = nil)
  if valid_28377497 != nil:
    section.add "Accept", valid_28377497
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28377499: Call_PatchReposOwnerRepoPullsNumber_28377491;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Update a pull request.
  ## 
  let valid = call_28377499.validator(path, query, header, formData, body)
  let scheme = call_28377499.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377499.url(scheme.get, call_28377499.host, call_28377499.base,
                           call_28377499.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377499, url, valid)

proc call*(call_28377500: Call_PatchReposOwnerRepoPullsNumber_28377491;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoPullsNumber
  ## Update a pull request.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377501 = newJObject()
  var header_28377502 = newJObject()
  var body_28377503 = newJObject()
  add(path_28377501, "owner", newJString(owner))
  add(path_28377501, "number", newJInt(number))
  add(header_28377502, "Accept", newJString(Accept))
  if body != nil:
    body_28377503 = body
  add(path_28377501, "repo", newJString(repo))
  result = call_28377500.call(path_28377501, nil, header_28377502, nil, body_28377503)

var patchReposOwnerRepoPullsNumber* = Call_PatchReposOwnerRepoPullsNumber_28377491(
    name: "patchReposOwnerRepoPullsNumber", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}",
    validator: validate_PatchReposOwnerRepoPullsNumber_28377492, base: "/",
    url: url_PatchReposOwnerRepoPullsNumber_28377493, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoPullsNumberComments_28377515 = ref object of OpenApiRestCall_28375350
proc url_PostReposOwnerRepoPullsNumberComments_28377517(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoPullsNumberComments_28377516(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a comment.
  ##   #TODO Alternative input ( http://developer.github.com/v3/pulls/comments/ )
  ##   description: |
  ##     Alternative Input.
  ##     Instead of passing commit_id, path, and position you can reply to an
  ##     existing Pull Request Comment like this:
  ## 
  ##         body
  ##            Required string
  ##         in_reply_to
  ##            Required number - Comment id to reply to.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377518 = path.getOrDefault("owner")
  valid_28377518 = validateParameter(valid_28377518, JString, required = true,
                                   default = nil)
  if valid_28377518 != nil:
    section.add "owner", valid_28377518
  var valid_28377519 = path.getOrDefault("number")
  valid_28377519 = validateParameter(valid_28377519, JInt, required = true,
                                   default = nil)
  if valid_28377519 != nil:
    section.add "number", valid_28377519
  var valid_28377520 = path.getOrDefault("repo")
  valid_28377520 = validateParameter(valid_28377520, JString, required = true,
                                   default = nil)
  if valid_28377520 != nil:
    section.add "repo", valid_28377520
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377521 = header.getOrDefault("Accept")
  valid_28377521 = validateParameter(valid_28377521, JString, required = false,
                                   default = nil)
  if valid_28377521 != nil:
    section.add "Accept", valid_28377521
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28377523: Call_PostReposOwnerRepoPullsNumberComments_28377515;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Create a comment.
  ##   #TODO Alternative input ( http://developer.github.com/v3/pulls/comments/ )
  ##   description: |
  ##     Alternative Input.
  ##     Instead of passing commit_id, path, and position you can reply to an
  ##     existing Pull Request Comment like this:
  ## 
  ##         body
  ##            Required string
  ##         in_reply_to
  ##            Required number - Comment id to reply to.
  ## 
  ## 
  let valid = call_28377523.validator(path, query, header, formData, body)
  let scheme = call_28377523.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377523.url(scheme.get, call_28377523.host, call_28377523.base,
                           call_28377523.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377523, url, valid)

proc call*(call_28377524: Call_PostReposOwnerRepoPullsNumberComments_28377515;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoPullsNumberComments
  ## Create a comment.
  ##   #TODO Alternative input ( http://developer.github.com/v3/pulls/comments/ )
  ##   description: |
  ##     Alternative Input.
  ##     Instead of passing commit_id, path, and position you can reply to an
  ##     existing Pull Request Comment like this:
  ## 
  ##         body
  ##            Required string
  ##         in_reply_to
  ##            Required number - Comment id to reply to.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377525 = newJObject()
  var header_28377526 = newJObject()
  var body_28377527 = newJObject()
  add(path_28377525, "owner", newJString(owner))
  add(path_28377525, "number", newJInt(number))
  add(header_28377526, "Accept", newJString(Accept))
  if body != nil:
    body_28377527 = body
  add(path_28377525, "repo", newJString(repo))
  result = call_28377524.call(path_28377525, nil, header_28377526, nil, body_28377527)

var postReposOwnerRepoPullsNumberComments* = Call_PostReposOwnerRepoPullsNumberComments_28377515(
    name: "postReposOwnerRepoPullsNumberComments", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/{number}/comments",
    validator: validate_PostReposOwnerRepoPullsNumberComments_28377516, base: "/",
    url: url_PostReposOwnerRepoPullsNumberComments_28377517,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberComments_28377504 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoPullsNumberComments_28377506(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberComments_28377505(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List comments on a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377507 = path.getOrDefault("owner")
  valid_28377507 = validateParameter(valid_28377507, JString, required = true,
                                   default = nil)
  if valid_28377507 != nil:
    section.add "owner", valid_28377507
  var valid_28377508 = path.getOrDefault("number")
  valid_28377508 = validateParameter(valid_28377508, JInt, required = true,
                                   default = nil)
  if valid_28377508 != nil:
    section.add "number", valid_28377508
  var valid_28377509 = path.getOrDefault("repo")
  valid_28377509 = validateParameter(valid_28377509, JString, required = true,
                                   default = nil)
  if valid_28377509 != nil:
    section.add "repo", valid_28377509
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377510 = header.getOrDefault("Accept")
  valid_28377510 = validateParameter(valid_28377510, JString, required = false,
                                   default = nil)
  if valid_28377510 != nil:
    section.add "Accept", valid_28377510
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377511: Call_GetReposOwnerRepoPullsNumberComments_28377504;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List comments on a pull request.
  ## 
  let valid = call_28377511.validator(path, query, header, formData, body)
  let scheme = call_28377511.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377511.url(scheme.get, call_28377511.host, call_28377511.base,
                           call_28377511.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377511, url, valid)

proc call*(call_28377512: Call_GetReposOwnerRepoPullsNumberComments_28377504;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberComments
  ## List comments on a pull request.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377513 = newJObject()
  var header_28377514 = newJObject()
  add(path_28377513, "owner", newJString(owner))
  add(path_28377513, "number", newJInt(number))
  add(header_28377514, "Accept", newJString(Accept))
  add(path_28377513, "repo", newJString(repo))
  result = call_28377512.call(path_28377513, nil, header_28377514, nil, nil)

var getReposOwnerRepoPullsNumberComments* = Call_GetReposOwnerRepoPullsNumberComments_28377504(
    name: "getReposOwnerRepoPullsNumberComments", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/{number}/comments",
    validator: validate_GetReposOwnerRepoPullsNumberComments_28377505, base: "/",
    url: url_GetReposOwnerRepoPullsNumberComments_28377506,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberCommits_28377528 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoPullsNumberCommits_28377530(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/commits")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberCommits_28377529(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List commits on a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377531 = path.getOrDefault("owner")
  valid_28377531 = validateParameter(valid_28377531, JString, required = true,
                                   default = nil)
  if valid_28377531 != nil:
    section.add "owner", valid_28377531
  var valid_28377532 = path.getOrDefault("number")
  valid_28377532 = validateParameter(valid_28377532, JInt, required = true,
                                   default = nil)
  if valid_28377532 != nil:
    section.add "number", valid_28377532
  var valid_28377533 = path.getOrDefault("repo")
  valid_28377533 = validateParameter(valid_28377533, JString, required = true,
                                   default = nil)
  if valid_28377533 != nil:
    section.add "repo", valid_28377533
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377534 = header.getOrDefault("Accept")
  valid_28377534 = validateParameter(valid_28377534, JString, required = false,
                                   default = nil)
  if valid_28377534 != nil:
    section.add "Accept", valid_28377534
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377535: Call_GetReposOwnerRepoPullsNumberCommits_28377528;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List commits on a pull request.
  ## 
  let valid = call_28377535.validator(path, query, header, formData, body)
  let scheme = call_28377535.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377535.url(scheme.get, call_28377535.host, call_28377535.base,
                           call_28377535.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377535, url, valid)

proc call*(call_28377536: Call_GetReposOwnerRepoPullsNumberCommits_28377528;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberCommits
  ## List commits on a pull request.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377537 = newJObject()
  var header_28377538 = newJObject()
  add(path_28377537, "owner", newJString(owner))
  add(path_28377537, "number", newJInt(number))
  add(header_28377538, "Accept", newJString(Accept))
  add(path_28377537, "repo", newJString(repo))
  result = call_28377536.call(path_28377537, nil, header_28377538, nil, nil)

var getReposOwnerRepoPullsNumberCommits* = Call_GetReposOwnerRepoPullsNumberCommits_28377528(
    name: "getReposOwnerRepoPullsNumberCommits", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/commits",
    validator: validate_GetReposOwnerRepoPullsNumberCommits_28377529, base: "/",
    url: url_GetReposOwnerRepoPullsNumberCommits_28377530, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberFiles_28377539 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoPullsNumberFiles_28377541(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/files")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberFiles_28377540(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List pull requests files.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377542 = path.getOrDefault("owner")
  valid_28377542 = validateParameter(valid_28377542, JString, required = true,
                                   default = nil)
  if valid_28377542 != nil:
    section.add "owner", valid_28377542
  var valid_28377543 = path.getOrDefault("number")
  valid_28377543 = validateParameter(valid_28377543, JInt, required = true,
                                   default = nil)
  if valid_28377543 != nil:
    section.add "number", valid_28377543
  var valid_28377544 = path.getOrDefault("repo")
  valid_28377544 = validateParameter(valid_28377544, JString, required = true,
                                   default = nil)
  if valid_28377544 != nil:
    section.add "repo", valid_28377544
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377545 = header.getOrDefault("Accept")
  valid_28377545 = validateParameter(valid_28377545, JString, required = false,
                                   default = nil)
  if valid_28377545 != nil:
    section.add "Accept", valid_28377545
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377546: Call_GetReposOwnerRepoPullsNumberFiles_28377539;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List pull requests files.
  ## 
  let valid = call_28377546.validator(path, query, header, formData, body)
  let scheme = call_28377546.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377546.url(scheme.get, call_28377546.host, call_28377546.base,
                           call_28377546.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377546, url, valid)

proc call*(call_28377547: Call_GetReposOwnerRepoPullsNumberFiles_28377539;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberFiles
  ## List pull requests files.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377548 = newJObject()
  var header_28377549 = newJObject()
  add(path_28377548, "owner", newJString(owner))
  add(path_28377548, "number", newJInt(number))
  add(header_28377549, "Accept", newJString(Accept))
  add(path_28377548, "repo", newJString(repo))
  result = call_28377547.call(path_28377548, nil, header_28377549, nil, nil)

var getReposOwnerRepoPullsNumberFiles* = Call_GetReposOwnerRepoPullsNumberFiles_28377539(
    name: "getReposOwnerRepoPullsNumberFiles", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/files",
    validator: validate_GetReposOwnerRepoPullsNumberFiles_28377540, base: "/",
    url: url_GetReposOwnerRepoPullsNumberFiles_28377541, schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoPullsNumberMerge_28377561 = ref object of OpenApiRestCall_28375350
proc url_PutReposOwnerRepoPullsNumberMerge_28377563(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/merge")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoPullsNumberMerge_28377562(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Merge a pull request (Merge Button's)
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377564 = path.getOrDefault("owner")
  valid_28377564 = validateParameter(valid_28377564, JString, required = true,
                                   default = nil)
  if valid_28377564 != nil:
    section.add "owner", valid_28377564
  var valid_28377565 = path.getOrDefault("number")
  valid_28377565 = validateParameter(valid_28377565, JInt, required = true,
                                   default = nil)
  if valid_28377565 != nil:
    section.add "number", valid_28377565
  var valid_28377566 = path.getOrDefault("repo")
  valid_28377566 = validateParameter(valid_28377566, JString, required = true,
                                   default = nil)
  if valid_28377566 != nil:
    section.add "repo", valid_28377566
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377567 = header.getOrDefault("Accept")
  valid_28377567 = validateParameter(valid_28377567, JString, required = false,
                                   default = nil)
  if valid_28377567 != nil:
    section.add "Accept", valid_28377567
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28377569: Call_PutReposOwnerRepoPullsNumberMerge_28377561;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Merge a pull request (Merge Button's)
  ## 
  let valid = call_28377569.validator(path, query, header, formData, body)
  let scheme = call_28377569.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377569.url(scheme.get, call_28377569.host, call_28377569.base,
                           call_28377569.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377569, url, valid)

proc call*(call_28377570: Call_PutReposOwnerRepoPullsNumberMerge_28377561;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoPullsNumberMerge
  ## Merge a pull request (Merge Button's)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377571 = newJObject()
  var header_28377572 = newJObject()
  var body_28377573 = newJObject()
  add(path_28377571, "owner", newJString(owner))
  add(path_28377571, "number", newJInt(number))
  add(header_28377572, "Accept", newJString(Accept))
  if body != nil:
    body_28377573 = body
  add(path_28377571, "repo", newJString(repo))
  result = call_28377570.call(path_28377571, nil, header_28377572, nil, body_28377573)

var putReposOwnerRepoPullsNumberMerge* = Call_PutReposOwnerRepoPullsNumberMerge_28377561(
    name: "putReposOwnerRepoPullsNumberMerge", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/merge",
    validator: validate_PutReposOwnerRepoPullsNumberMerge_28377562, base: "/",
    url: url_PutReposOwnerRepoPullsNumberMerge_28377563, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberMerge_28377550 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoPullsNumberMerge_28377552(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/merge")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberMerge_28377551(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get if a pull request has been merged.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377553 = path.getOrDefault("owner")
  valid_28377553 = validateParameter(valid_28377553, JString, required = true,
                                   default = nil)
  if valid_28377553 != nil:
    section.add "owner", valid_28377553
  var valid_28377554 = path.getOrDefault("number")
  valid_28377554 = validateParameter(valid_28377554, JInt, required = true,
                                   default = nil)
  if valid_28377554 != nil:
    section.add "number", valid_28377554
  var valid_28377555 = path.getOrDefault("repo")
  valid_28377555 = validateParameter(valid_28377555, JString, required = true,
                                   default = nil)
  if valid_28377555 != nil:
    section.add "repo", valid_28377555
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377556 = header.getOrDefault("Accept")
  valid_28377556 = validateParameter(valid_28377556, JString, required = false,
                                   default = nil)
  if valid_28377556 != nil:
    section.add "Accept", valid_28377556
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377557: Call_GetReposOwnerRepoPullsNumberMerge_28377550;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get if a pull request has been merged.
  ## 
  let valid = call_28377557.validator(path, query, header, formData, body)
  let scheme = call_28377557.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377557.url(scheme.get, call_28377557.host, call_28377557.base,
                           call_28377557.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377557, url, valid)

proc call*(call_28377558: Call_GetReposOwnerRepoPullsNumberMerge_28377550;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberMerge
  ## Get if a pull request has been merged.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377559 = newJObject()
  var header_28377560 = newJObject()
  add(path_28377559, "owner", newJString(owner))
  add(path_28377559, "number", newJInt(number))
  add(header_28377560, "Accept", newJString(Accept))
  add(path_28377559, "repo", newJString(repo))
  result = call_28377558.call(path_28377559, nil, header_28377560, nil, nil)

var getReposOwnerRepoPullsNumberMerge* = Call_GetReposOwnerRepoPullsNumberMerge_28377550(
    name: "getReposOwnerRepoPullsNumberMerge", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/merge",
    validator: validate_GetReposOwnerRepoPullsNumberMerge_28377551, base: "/",
    url: url_GetReposOwnerRepoPullsNumberMerge_28377552, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReadme_28377574 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoReadme_28377576(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/readme")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReadme_28377575(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the README.
  ## This method returns the preferred README for a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377577 = path.getOrDefault("owner")
  valid_28377577 = validateParameter(valid_28377577, JString, required = true,
                                   default = nil)
  if valid_28377577 != nil:
    section.add "owner", valid_28377577
  var valid_28377578 = path.getOrDefault("repo")
  valid_28377578 = validateParameter(valid_28377578, JString, required = true,
                                   default = nil)
  if valid_28377578 != nil:
    section.add "repo", valid_28377578
  result.add "path", section
  ## parameters in `query` object:
  ##   ref: JString
  ##      : The String name of the Commit/Branch/Tag. Defaults to master.
  section = newJObject()
  var valid_28377579 = query.getOrDefault("ref")
  valid_28377579 = validateParameter(valid_28377579, JString, required = false,
                                   default = nil)
  if valid_28377579 != nil:
    section.add "ref", valid_28377579
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377580 = header.getOrDefault("Accept")
  valid_28377580 = validateParameter(valid_28377580, JString, required = false,
                                   default = nil)
  if valid_28377580 != nil:
    section.add "Accept", valid_28377580
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377581: Call_GetReposOwnerRepoReadme_28377574; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get the README.
  ## This method returns the preferred README for a repository.
  ## 
  ## 
  let valid = call_28377581.validator(path, query, header, formData, body)
  let scheme = call_28377581.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377581.url(scheme.get, call_28377581.host, call_28377581.base,
                           call_28377581.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377581, url, valid)

proc call*(call_28377582: Call_GetReposOwnerRepoReadme_28377574; owner: string;
          repo: string; Accept: string = ""; `ref`: string = ""): Recallable =
  ## getReposOwnerRepoReadme
  ## Get the README.
  ## This method returns the preferred README for a repository.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   ref: string
  ##      : The String name of the Commit/Branch/Tag. Defaults to master.
  var path_28377583 = newJObject()
  var query_28377584 = newJObject()
  var header_28377585 = newJObject()
  add(path_28377583, "owner", newJString(owner))
  add(header_28377585, "Accept", newJString(Accept))
  add(path_28377583, "repo", newJString(repo))
  add(query_28377584, "ref", newJString(`ref`))
  result = call_28377582.call(path_28377583, query_28377584, header_28377585, nil, nil)

var getReposOwnerRepoReadme* = Call_GetReposOwnerRepoReadme_28377574(
    name: "getReposOwnerRepoReadme", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/readme",
    validator: validate_GetReposOwnerRepoReadme_28377575, base: "/",
    url: url_GetReposOwnerRepoReadme_28377576, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoReleases_28377596 = ref object of OpenApiRestCall_28375350
proc url_PostReposOwnerRepoReleases_28377598(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoReleases_28377597(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a release
  ## Users with push access to the repository can create a release.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377599 = path.getOrDefault("owner")
  valid_28377599 = validateParameter(valid_28377599, JString, required = true,
                                   default = nil)
  if valid_28377599 != nil:
    section.add "owner", valid_28377599
  var valid_28377600 = path.getOrDefault("repo")
  valid_28377600 = validateParameter(valid_28377600, JString, required = true,
                                   default = nil)
  if valid_28377600 != nil:
    section.add "repo", valid_28377600
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377601 = header.getOrDefault("Accept")
  valid_28377601 = validateParameter(valid_28377601, JString, required = false,
                                   default = nil)
  if valid_28377601 != nil:
    section.add "Accept", valid_28377601
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28377603: Call_PostReposOwnerRepoReleases_28377596; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a release
  ## Users with push access to the repository can create a release.
  ## 
  ## 
  let valid = call_28377603.validator(path, query, header, formData, body)
  let scheme = call_28377603.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377603.url(scheme.get, call_28377603.host, call_28377603.base,
                           call_28377603.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377603, url, valid)

proc call*(call_28377604: Call_PostReposOwnerRepoReleases_28377596; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoReleases
  ## Create a release
  ## Users with push access to the repository can create a release.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377605 = newJObject()
  var header_28377606 = newJObject()
  var body_28377607 = newJObject()
  add(path_28377605, "owner", newJString(owner))
  add(header_28377606, "Accept", newJString(Accept))
  if body != nil:
    body_28377607 = body
  add(path_28377605, "repo", newJString(repo))
  result = call_28377604.call(path_28377605, nil, header_28377606, nil, body_28377607)

var postReposOwnerRepoReleases* = Call_PostReposOwnerRepoReleases_28377596(
    name: "postReposOwnerRepoReleases", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases",
    validator: validate_PostReposOwnerRepoReleases_28377597, base: "/",
    url: url_PostReposOwnerRepoReleases_28377598, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleases_28377586 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoReleases_28377588(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleases_28377587(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Users with push access to the repository will receive all releases (i.e., published releases and draft releases). Users with pull access will receive published releases only
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377589 = path.getOrDefault("owner")
  valid_28377589 = validateParameter(valid_28377589, JString, required = true,
                                   default = nil)
  if valid_28377589 != nil:
    section.add "owner", valid_28377589
  var valid_28377590 = path.getOrDefault("repo")
  valid_28377590 = validateParameter(valid_28377590, JString, required = true,
                                   default = nil)
  if valid_28377590 != nil:
    section.add "repo", valid_28377590
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377591 = header.getOrDefault("Accept")
  valid_28377591 = validateParameter(valid_28377591, JString, required = false,
                                   default = nil)
  if valid_28377591 != nil:
    section.add "Accept", valid_28377591
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377592: Call_GetReposOwnerRepoReleases_28377586; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Users with push access to the repository will receive all releases (i.e., published releases and draft releases). Users with pull access will receive published releases only
  ## 
  let valid = call_28377592.validator(path, query, header, formData, body)
  let scheme = call_28377592.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377592.url(scheme.get, call_28377592.host, call_28377592.base,
                           call_28377592.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377592, url, valid)

proc call*(call_28377593: Call_GetReposOwnerRepoReleases_28377586; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleases
  ## Users with push access to the repository will receive all releases (i.e., published releases and draft releases). Users with pull access will receive published releases only
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377594 = newJObject()
  var header_28377595 = newJObject()
  add(path_28377594, "owner", newJString(owner))
  add(header_28377595, "Accept", newJString(Accept))
  add(path_28377594, "repo", newJString(repo))
  result = call_28377593.call(path_28377594, nil, header_28377595, nil, nil)

var getReposOwnerRepoReleases* = Call_GetReposOwnerRepoReleases_28377586(
    name: "getReposOwnerRepoReleases", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases",
    validator: validate_GetReposOwnerRepoReleases_28377587, base: "/",
    url: url_GetReposOwnerRepoReleases_28377588, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleasesAssetsId_28377608 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoReleasesAssetsId_28377610(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/assets/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleasesAssetsId_28377609(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single release asset
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377611 = path.getOrDefault("owner")
  valid_28377611 = validateParameter(valid_28377611, JString, required = true,
                                   default = nil)
  if valid_28377611 != nil:
    section.add "owner", valid_28377611
  var valid_28377612 = path.getOrDefault("id")
  valid_28377612 = validateParameter(valid_28377612, JString, required = true,
                                   default = nil)
  if valid_28377612 != nil:
    section.add "id", valid_28377612
  var valid_28377613 = path.getOrDefault("repo")
  valid_28377613 = validateParameter(valid_28377613, JString, required = true,
                                   default = nil)
  if valid_28377613 != nil:
    section.add "repo", valid_28377613
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377614 = header.getOrDefault("Accept")
  valid_28377614 = validateParameter(valid_28377614, JString, required = false,
                                   default = nil)
  if valid_28377614 != nil:
    section.add "Accept", valid_28377614
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377615: Call_GetReposOwnerRepoReleasesAssetsId_28377608;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single release asset
  ## 
  let valid = call_28377615.validator(path, query, header, formData, body)
  let scheme = call_28377615.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377615.url(scheme.get, call_28377615.host, call_28377615.base,
                           call_28377615.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377615, url, valid)

proc call*(call_28377616: Call_GetReposOwnerRepoReleasesAssetsId_28377608;
          owner: string; id: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleasesAssetsId
  ## Get a single release asset
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377617 = newJObject()
  var header_28377618 = newJObject()
  add(path_28377617, "owner", newJString(owner))
  add(path_28377617, "id", newJString(id))
  add(header_28377618, "Accept", newJString(Accept))
  add(path_28377617, "repo", newJString(repo))
  result = call_28377616.call(path_28377617, nil, header_28377618, nil, nil)

var getReposOwnerRepoReleasesAssetsId* = Call_GetReposOwnerRepoReleasesAssetsId_28377608(
    name: "getReposOwnerRepoReleasesAssetsId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/assets/{id}",
    validator: validate_GetReposOwnerRepoReleasesAssetsId_28377609, base: "/",
    url: url_GetReposOwnerRepoReleasesAssetsId_28377610, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoReleasesAssetsId_28377630 = ref object of OpenApiRestCall_28375350
proc url_PatchReposOwnerRepoReleasesAssetsId_28377632(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/assets/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoReleasesAssetsId_28377631(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Edit a release asset
  ## Users with push access to the repository can edit a release asset.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377633 = path.getOrDefault("owner")
  valid_28377633 = validateParameter(valid_28377633, JString, required = true,
                                   default = nil)
  if valid_28377633 != nil:
    section.add "owner", valid_28377633
  var valid_28377634 = path.getOrDefault("id")
  valid_28377634 = validateParameter(valid_28377634, JString, required = true,
                                   default = nil)
  if valid_28377634 != nil:
    section.add "id", valid_28377634
  var valid_28377635 = path.getOrDefault("repo")
  valid_28377635 = validateParameter(valid_28377635, JString, required = true,
                                   default = nil)
  if valid_28377635 != nil:
    section.add "repo", valid_28377635
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377636 = header.getOrDefault("Accept")
  valid_28377636 = validateParameter(valid_28377636, JString, required = false,
                                   default = nil)
  if valid_28377636 != nil:
    section.add "Accept", valid_28377636
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28377638: Call_PatchReposOwnerRepoReleasesAssetsId_28377630;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Edit a release asset
  ## Users with push access to the repository can edit a release asset.
  ## 
  ## 
  let valid = call_28377638.validator(path, query, header, formData, body)
  let scheme = call_28377638.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377638.url(scheme.get, call_28377638.host, call_28377638.base,
                           call_28377638.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377638, url, valid)

proc call*(call_28377639: Call_PatchReposOwnerRepoReleasesAssetsId_28377630;
          owner: string; id: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoReleasesAssetsId
  ## Edit a release asset
  ## Users with push access to the repository can edit a release asset.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377640 = newJObject()
  var header_28377641 = newJObject()
  var body_28377642 = newJObject()
  add(path_28377640, "owner", newJString(owner))
  add(path_28377640, "id", newJString(id))
  add(header_28377641, "Accept", newJString(Accept))
  if body != nil:
    body_28377642 = body
  add(path_28377640, "repo", newJString(repo))
  result = call_28377639.call(path_28377640, nil, header_28377641, nil, body_28377642)

var patchReposOwnerRepoReleasesAssetsId* = Call_PatchReposOwnerRepoReleasesAssetsId_28377630(
    name: "patchReposOwnerRepoReleasesAssetsId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/assets/{id}",
    validator: validate_PatchReposOwnerRepoReleasesAssetsId_28377631, base: "/",
    url: url_PatchReposOwnerRepoReleasesAssetsId_28377632, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoReleasesAssetsId_28377619 = ref object of OpenApiRestCall_28375350
proc url_DeleteReposOwnerRepoReleasesAssetsId_28377621(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/assets/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoReleasesAssetsId_28377620(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a release asset
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377622 = path.getOrDefault("owner")
  valid_28377622 = validateParameter(valid_28377622, JString, required = true,
                                   default = nil)
  if valid_28377622 != nil:
    section.add "owner", valid_28377622
  var valid_28377623 = path.getOrDefault("id")
  valid_28377623 = validateParameter(valid_28377623, JString, required = true,
                                   default = nil)
  if valid_28377623 != nil:
    section.add "id", valid_28377623
  var valid_28377624 = path.getOrDefault("repo")
  valid_28377624 = validateParameter(valid_28377624, JString, required = true,
                                   default = nil)
  if valid_28377624 != nil:
    section.add "repo", valid_28377624
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377625 = header.getOrDefault("Accept")
  valid_28377625 = validateParameter(valid_28377625, JString, required = false,
                                   default = nil)
  if valid_28377625 != nil:
    section.add "Accept", valid_28377625
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377626: Call_DeleteReposOwnerRepoReleasesAssetsId_28377619;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a release asset
  ## 
  let valid = call_28377626.validator(path, query, header, formData, body)
  let scheme = call_28377626.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377626.url(scheme.get, call_28377626.host, call_28377626.base,
                           call_28377626.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377626, url, valid)

proc call*(call_28377627: Call_DeleteReposOwnerRepoReleasesAssetsId_28377619;
          owner: string; id: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoReleasesAssetsId
  ## Delete a release asset
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377628 = newJObject()
  var header_28377629 = newJObject()
  add(path_28377628, "owner", newJString(owner))
  add(path_28377628, "id", newJString(id))
  add(header_28377629, "Accept", newJString(Accept))
  add(path_28377628, "repo", newJString(repo))
  result = call_28377627.call(path_28377628, nil, header_28377629, nil, nil)

var deleteReposOwnerRepoReleasesAssetsId* = Call_DeleteReposOwnerRepoReleasesAssetsId_28377619(
    name: "deleteReposOwnerRepoReleasesAssetsId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/assets/{id}",
    validator: validate_DeleteReposOwnerRepoReleasesAssetsId_28377620, base: "/",
    url: url_DeleteReposOwnerRepoReleasesAssetsId_28377621,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleasesId_28377643 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoReleasesId_28377645(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleasesId_28377644(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single release
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377646 = path.getOrDefault("owner")
  valid_28377646 = validateParameter(valid_28377646, JString, required = true,
                                   default = nil)
  if valid_28377646 != nil:
    section.add "owner", valid_28377646
  var valid_28377647 = path.getOrDefault("id")
  valid_28377647 = validateParameter(valid_28377647, JString, required = true,
                                   default = nil)
  if valid_28377647 != nil:
    section.add "id", valid_28377647
  var valid_28377648 = path.getOrDefault("repo")
  valid_28377648 = validateParameter(valid_28377648, JString, required = true,
                                   default = nil)
  if valid_28377648 != nil:
    section.add "repo", valid_28377648
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377649 = header.getOrDefault("Accept")
  valid_28377649 = validateParameter(valid_28377649, JString, required = false,
                                   default = nil)
  if valid_28377649 != nil:
    section.add "Accept", valid_28377649
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377650: Call_GetReposOwnerRepoReleasesId_28377643;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single release
  ## 
  let valid = call_28377650.validator(path, query, header, formData, body)
  let scheme = call_28377650.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377650.url(scheme.get, call_28377650.host, call_28377650.base,
                           call_28377650.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377650, url, valid)

proc call*(call_28377651: Call_GetReposOwnerRepoReleasesId_28377643; owner: string;
          id: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleasesId
  ## Get a single release
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377652 = newJObject()
  var header_28377653 = newJObject()
  add(path_28377652, "owner", newJString(owner))
  add(path_28377652, "id", newJString(id))
  add(header_28377653, "Accept", newJString(Accept))
  add(path_28377652, "repo", newJString(repo))
  result = call_28377651.call(path_28377652, nil, header_28377653, nil, nil)

var getReposOwnerRepoReleasesId* = Call_GetReposOwnerRepoReleasesId_28377643(
    name: "getReposOwnerRepoReleasesId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}",
    validator: validate_GetReposOwnerRepoReleasesId_28377644, base: "/",
    url: url_GetReposOwnerRepoReleasesId_28377645, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoReleasesId_28377665 = ref object of OpenApiRestCall_28375350
proc url_PatchReposOwnerRepoReleasesId_28377667(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoReleasesId_28377666(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Users with push access to the repository can edit a release
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377668 = path.getOrDefault("owner")
  valid_28377668 = validateParameter(valid_28377668, JString, required = true,
                                   default = nil)
  if valid_28377668 != nil:
    section.add "owner", valid_28377668
  var valid_28377669 = path.getOrDefault("id")
  valid_28377669 = validateParameter(valid_28377669, JString, required = true,
                                   default = nil)
  if valid_28377669 != nil:
    section.add "id", valid_28377669
  var valid_28377670 = path.getOrDefault("repo")
  valid_28377670 = validateParameter(valid_28377670, JString, required = true,
                                   default = nil)
  if valid_28377670 != nil:
    section.add "repo", valid_28377670
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377671 = header.getOrDefault("Accept")
  valid_28377671 = validateParameter(valid_28377671, JString, required = false,
                                   default = nil)
  if valid_28377671 != nil:
    section.add "Accept", valid_28377671
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28377673: Call_PatchReposOwnerRepoReleasesId_28377665;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Users with push access to the repository can edit a release
  ## 
  let valid = call_28377673.validator(path, query, header, formData, body)
  let scheme = call_28377673.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377673.url(scheme.get, call_28377673.host, call_28377673.base,
                           call_28377673.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377673, url, valid)

proc call*(call_28377674: Call_PatchReposOwnerRepoReleasesId_28377665;
          owner: string; id: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoReleasesId
  ## Users with push access to the repository can edit a release
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377675 = newJObject()
  var header_28377676 = newJObject()
  var body_28377677 = newJObject()
  add(path_28377675, "owner", newJString(owner))
  add(path_28377675, "id", newJString(id))
  add(header_28377676, "Accept", newJString(Accept))
  if body != nil:
    body_28377677 = body
  add(path_28377675, "repo", newJString(repo))
  result = call_28377674.call(path_28377675, nil, header_28377676, nil, body_28377677)

var patchReposOwnerRepoReleasesId* = Call_PatchReposOwnerRepoReleasesId_28377665(
    name: "patchReposOwnerRepoReleasesId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}",
    validator: validate_PatchReposOwnerRepoReleasesId_28377666, base: "/",
    url: url_PatchReposOwnerRepoReleasesId_28377667, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoReleasesId_28377654 = ref object of OpenApiRestCall_28375350
proc url_DeleteReposOwnerRepoReleasesId_28377656(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoReleasesId_28377655(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Users with push access to the repository can delete a release.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377657 = path.getOrDefault("owner")
  valid_28377657 = validateParameter(valid_28377657, JString, required = true,
                                   default = nil)
  if valid_28377657 != nil:
    section.add "owner", valid_28377657
  var valid_28377658 = path.getOrDefault("id")
  valid_28377658 = validateParameter(valid_28377658, JString, required = true,
                                   default = nil)
  if valid_28377658 != nil:
    section.add "id", valid_28377658
  var valid_28377659 = path.getOrDefault("repo")
  valid_28377659 = validateParameter(valid_28377659, JString, required = true,
                                   default = nil)
  if valid_28377659 != nil:
    section.add "repo", valid_28377659
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377660 = header.getOrDefault("Accept")
  valid_28377660 = validateParameter(valid_28377660, JString, required = false,
                                   default = nil)
  if valid_28377660 != nil:
    section.add "Accept", valid_28377660
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377661: Call_DeleteReposOwnerRepoReleasesId_28377654;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Users with push access to the repository can delete a release.
  ## 
  let valid = call_28377661.validator(path, query, header, formData, body)
  let scheme = call_28377661.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377661.url(scheme.get, call_28377661.host, call_28377661.base,
                           call_28377661.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377661, url, valid)

proc call*(call_28377662: Call_DeleteReposOwnerRepoReleasesId_28377654;
          owner: string; id: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoReleasesId
  ## Users with push access to the repository can delete a release.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377663 = newJObject()
  var header_28377664 = newJObject()
  add(path_28377663, "owner", newJString(owner))
  add(path_28377663, "id", newJString(id))
  add(header_28377664, "Accept", newJString(Accept))
  add(path_28377663, "repo", newJString(repo))
  result = call_28377662.call(path_28377663, nil, header_28377664, nil, nil)

var deleteReposOwnerRepoReleasesId* = Call_DeleteReposOwnerRepoReleasesId_28377654(
    name: "deleteReposOwnerRepoReleasesId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}",
    validator: validate_DeleteReposOwnerRepoReleasesId_28377655, base: "/",
    url: url_DeleteReposOwnerRepoReleasesId_28377656, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleasesIdAssets_28377678 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoReleasesIdAssets_28377680(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/assets")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleasesIdAssets_28377679(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List assets for a release
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377681 = path.getOrDefault("owner")
  valid_28377681 = validateParameter(valid_28377681, JString, required = true,
                                   default = nil)
  if valid_28377681 != nil:
    section.add "owner", valid_28377681
  var valid_28377682 = path.getOrDefault("id")
  valid_28377682 = validateParameter(valid_28377682, JString, required = true,
                                   default = nil)
  if valid_28377682 != nil:
    section.add "id", valid_28377682
  var valid_28377683 = path.getOrDefault("repo")
  valid_28377683 = validateParameter(valid_28377683, JString, required = true,
                                   default = nil)
  if valid_28377683 != nil:
    section.add "repo", valid_28377683
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377684 = header.getOrDefault("Accept")
  valid_28377684 = validateParameter(valid_28377684, JString, required = false,
                                   default = nil)
  if valid_28377684 != nil:
    section.add "Accept", valid_28377684
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377685: Call_GetReposOwnerRepoReleasesIdAssets_28377678;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List assets for a release
  ## 
  let valid = call_28377685.validator(path, query, header, formData, body)
  let scheme = call_28377685.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377685.url(scheme.get, call_28377685.host, call_28377685.base,
                           call_28377685.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377685, url, valid)

proc call*(call_28377686: Call_GetReposOwnerRepoReleasesIdAssets_28377678;
          owner: string; id: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleasesIdAssets
  ## List assets for a release
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377687 = newJObject()
  var header_28377688 = newJObject()
  add(path_28377687, "owner", newJString(owner))
  add(path_28377687, "id", newJString(id))
  add(header_28377688, "Accept", newJString(Accept))
  add(path_28377687, "repo", newJString(repo))
  result = call_28377686.call(path_28377687, nil, header_28377688, nil, nil)

var getReposOwnerRepoReleasesIdAssets* = Call_GetReposOwnerRepoReleasesIdAssets_28377678(
    name: "getReposOwnerRepoReleasesIdAssets", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}/assets",
    validator: validate_GetReposOwnerRepoReleasesIdAssets_28377679, base: "/",
    url: url_GetReposOwnerRepoReleasesIdAssets_28377680, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStargazers_28377689 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoStargazers_28377691(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stargazers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStargazers_28377690(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List Stargazers.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377692 = path.getOrDefault("owner")
  valid_28377692 = validateParameter(valid_28377692, JString, required = true,
                                   default = nil)
  if valid_28377692 != nil:
    section.add "owner", valid_28377692
  var valid_28377693 = path.getOrDefault("repo")
  valid_28377693 = validateParameter(valid_28377693, JString, required = true,
                                   default = nil)
  if valid_28377693 != nil:
    section.add "repo", valid_28377693
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377694 = header.getOrDefault("Accept")
  valid_28377694 = validateParameter(valid_28377694, JString, required = false,
                                   default = nil)
  if valid_28377694 != nil:
    section.add "Accept", valid_28377694
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377695: Call_GetReposOwnerRepoStargazers_28377689;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List Stargazers.
  ## 
  let valid = call_28377695.validator(path, query, header, formData, body)
  let scheme = call_28377695.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377695.url(scheme.get, call_28377695.host, call_28377695.base,
                           call_28377695.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377695, url, valid)

proc call*(call_28377696: Call_GetReposOwnerRepoStargazers_28377689; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStargazers
  ## List Stargazers.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377697 = newJObject()
  var header_28377698 = newJObject()
  add(path_28377697, "owner", newJString(owner))
  add(header_28377698, "Accept", newJString(Accept))
  add(path_28377697, "repo", newJString(repo))
  result = call_28377696.call(path_28377697, nil, header_28377698, nil, nil)

var getReposOwnerRepoStargazers* = Call_GetReposOwnerRepoStargazers_28377689(
    name: "getReposOwnerRepoStargazers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stargazers",
    validator: validate_GetReposOwnerRepoStargazers_28377690, base: "/",
    url: url_GetReposOwnerRepoStargazers_28377691, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsCodeFrequency_28377699 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoStatsCodeFrequency_28377701(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/code_frequency")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsCodeFrequency_28377700(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the number of additions and deletions per week.
  ## Returns a weekly aggregate of the number of additions and deletions pushed
  ## to a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377702 = path.getOrDefault("owner")
  valid_28377702 = validateParameter(valid_28377702, JString, required = true,
                                   default = nil)
  if valid_28377702 != nil:
    section.add "owner", valid_28377702
  var valid_28377703 = path.getOrDefault("repo")
  valid_28377703 = validateParameter(valid_28377703, JString, required = true,
                                   default = nil)
  if valid_28377703 != nil:
    section.add "repo", valid_28377703
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377704 = header.getOrDefault("Accept")
  valid_28377704 = validateParameter(valid_28377704, JString, required = false,
                                   default = nil)
  if valid_28377704 != nil:
    section.add "Accept", valid_28377704
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377705: Call_GetReposOwnerRepoStatsCodeFrequency_28377699;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get the number of additions and deletions per week.
  ## Returns a weekly aggregate of the number of additions and deletions pushed
  ## to a repository.
  ## 
  ## 
  let valid = call_28377705.validator(path, query, header, formData, body)
  let scheme = call_28377705.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377705.url(scheme.get, call_28377705.host, call_28377705.base,
                           call_28377705.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377705, url, valid)

proc call*(call_28377706: Call_GetReposOwnerRepoStatsCodeFrequency_28377699;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsCodeFrequency
  ## Get the number of additions and deletions per week.
  ## Returns a weekly aggregate of the number of additions and deletions pushed
  ## to a repository.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377707 = newJObject()
  var header_28377708 = newJObject()
  add(path_28377707, "owner", newJString(owner))
  add(header_28377708, "Accept", newJString(Accept))
  add(path_28377707, "repo", newJString(repo))
  result = call_28377706.call(path_28377707, nil, header_28377708, nil, nil)

var getReposOwnerRepoStatsCodeFrequency* = Call_GetReposOwnerRepoStatsCodeFrequency_28377699(
    name: "getReposOwnerRepoStatsCodeFrequency", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/code_frequency",
    validator: validate_GetReposOwnerRepoStatsCodeFrequency_28377700, base: "/",
    url: url_GetReposOwnerRepoStatsCodeFrequency_28377701, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsCommitActivity_28377709 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoStatsCommitActivity_28377711(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/commit_activity")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsCommitActivity_28377710(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the last year of commit activity data.
  ## Returns the last year of commit activity grouped by week. The days array
  ## is a group of commits per day, starting on Sunday.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377712 = path.getOrDefault("owner")
  valid_28377712 = validateParameter(valid_28377712, JString, required = true,
                                   default = nil)
  if valid_28377712 != nil:
    section.add "owner", valid_28377712
  var valid_28377713 = path.getOrDefault("repo")
  valid_28377713 = validateParameter(valid_28377713, JString, required = true,
                                   default = nil)
  if valid_28377713 != nil:
    section.add "repo", valid_28377713
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377714 = header.getOrDefault("Accept")
  valid_28377714 = validateParameter(valid_28377714, JString, required = false,
                                   default = nil)
  if valid_28377714 != nil:
    section.add "Accept", valid_28377714
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377715: Call_GetReposOwnerRepoStatsCommitActivity_28377709;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get the last year of commit activity data.
  ## Returns the last year of commit activity grouped by week. The days array
  ## is a group of commits per day, starting on Sunday.
  ## 
  ## 
  let valid = call_28377715.validator(path, query, header, formData, body)
  let scheme = call_28377715.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377715.url(scheme.get, call_28377715.host, call_28377715.base,
                           call_28377715.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377715, url, valid)

proc call*(call_28377716: Call_GetReposOwnerRepoStatsCommitActivity_28377709;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsCommitActivity
  ## Get the last year of commit activity data.
  ## Returns the last year of commit activity grouped by week. The days array
  ## is a group of commits per day, starting on Sunday.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377717 = newJObject()
  var header_28377718 = newJObject()
  add(path_28377717, "owner", newJString(owner))
  add(header_28377718, "Accept", newJString(Accept))
  add(path_28377717, "repo", newJString(repo))
  result = call_28377716.call(path_28377717, nil, header_28377718, nil, nil)

var getReposOwnerRepoStatsCommitActivity* = Call_GetReposOwnerRepoStatsCommitActivity_28377709(
    name: "getReposOwnerRepoStatsCommitActivity", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/commit_activity",
    validator: validate_GetReposOwnerRepoStatsCommitActivity_28377710, base: "/",
    url: url_GetReposOwnerRepoStatsCommitActivity_28377711,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsContributors_28377719 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoStatsContributors_28377721(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/contributors")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsContributors_28377720(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get contributors list with additions, deletions, and commit counts.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377722 = path.getOrDefault("owner")
  valid_28377722 = validateParameter(valid_28377722, JString, required = true,
                                   default = nil)
  if valid_28377722 != nil:
    section.add "owner", valid_28377722
  var valid_28377723 = path.getOrDefault("repo")
  valid_28377723 = validateParameter(valid_28377723, JString, required = true,
                                   default = nil)
  if valid_28377723 != nil:
    section.add "repo", valid_28377723
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377724 = header.getOrDefault("Accept")
  valid_28377724 = validateParameter(valid_28377724, JString, required = false,
                                   default = nil)
  if valid_28377724 != nil:
    section.add "Accept", valid_28377724
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377725: Call_GetReposOwnerRepoStatsContributors_28377719;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get contributors list with additions, deletions, and commit counts.
  ## 
  let valid = call_28377725.validator(path, query, header, formData, body)
  let scheme = call_28377725.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377725.url(scheme.get, call_28377725.host, call_28377725.base,
                           call_28377725.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377725, url, valid)

proc call*(call_28377726: Call_GetReposOwnerRepoStatsContributors_28377719;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsContributors
  ## Get contributors list with additions, deletions, and commit counts.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377727 = newJObject()
  var header_28377728 = newJObject()
  add(path_28377727, "owner", newJString(owner))
  add(header_28377728, "Accept", newJString(Accept))
  add(path_28377727, "repo", newJString(repo))
  result = call_28377726.call(path_28377727, nil, header_28377728, nil, nil)

var getReposOwnerRepoStatsContributors* = Call_GetReposOwnerRepoStatsContributors_28377719(
    name: "getReposOwnerRepoStatsContributors", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/contributors",
    validator: validate_GetReposOwnerRepoStatsContributors_28377720, base: "/",
    url: url_GetReposOwnerRepoStatsContributors_28377721, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsParticipation_28377729 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoStatsParticipation_28377731(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/participation")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsParticipation_28377730(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the weekly commit count for the repo owner and everyone else.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377732 = path.getOrDefault("owner")
  valid_28377732 = validateParameter(valid_28377732, JString, required = true,
                                   default = nil)
  if valid_28377732 != nil:
    section.add "owner", valid_28377732
  var valid_28377733 = path.getOrDefault("repo")
  valid_28377733 = validateParameter(valid_28377733, JString, required = true,
                                   default = nil)
  if valid_28377733 != nil:
    section.add "repo", valid_28377733
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377734 = header.getOrDefault("Accept")
  valid_28377734 = validateParameter(valid_28377734, JString, required = false,
                                   default = nil)
  if valid_28377734 != nil:
    section.add "Accept", valid_28377734
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377735: Call_GetReposOwnerRepoStatsParticipation_28377729;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get the weekly commit count for the repo owner and everyone else.
  ## 
  let valid = call_28377735.validator(path, query, header, formData, body)
  let scheme = call_28377735.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377735.url(scheme.get, call_28377735.host, call_28377735.base,
                           call_28377735.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377735, url, valid)

proc call*(call_28377736: Call_GetReposOwnerRepoStatsParticipation_28377729;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsParticipation
  ## Get the weekly commit count for the repo owner and everyone else.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377737 = newJObject()
  var header_28377738 = newJObject()
  add(path_28377737, "owner", newJString(owner))
  add(header_28377738, "Accept", newJString(Accept))
  add(path_28377737, "repo", newJString(repo))
  result = call_28377736.call(path_28377737, nil, header_28377738, nil, nil)

var getReposOwnerRepoStatsParticipation* = Call_GetReposOwnerRepoStatsParticipation_28377729(
    name: "getReposOwnerRepoStatsParticipation", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/participation",
    validator: validate_GetReposOwnerRepoStatsParticipation_28377730, base: "/",
    url: url_GetReposOwnerRepoStatsParticipation_28377731, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsPunchCard_28377739 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoStatsPunchCard_28377741(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/punch_card")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsPunchCard_28377740(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the number of commits per hour in each day.
  ## Each array contains the day number, hour number, and number of commits
  ## 0-6 Sunday - Saturday
  ## 0-23 Hour of day
  ## Number of commits
  ## 
  ## For example, [2, 14, 25] indicates that there were 25 total commits, during
  ## the 2.00pm hour on Tuesdays. All times are based on the time zone of
  ## individual commits.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377742 = path.getOrDefault("owner")
  valid_28377742 = validateParameter(valid_28377742, JString, required = true,
                                   default = nil)
  if valid_28377742 != nil:
    section.add "owner", valid_28377742
  var valid_28377743 = path.getOrDefault("repo")
  valid_28377743 = validateParameter(valid_28377743, JString, required = true,
                                   default = nil)
  if valid_28377743 != nil:
    section.add "repo", valid_28377743
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377744 = header.getOrDefault("Accept")
  valid_28377744 = validateParameter(valid_28377744, JString, required = false,
                                   default = nil)
  if valid_28377744 != nil:
    section.add "Accept", valid_28377744
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377745: Call_GetReposOwnerRepoStatsPunchCard_28377739;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get the number of commits per hour in each day.
  ## Each array contains the day number, hour number, and number of commits
  ## 0-6 Sunday - Saturday
  ## 0-23 Hour of day
  ## Number of commits
  ## 
  ## For example, [2, 14, 25] indicates that there were 25 total commits, during
  ## the 2.00pm hour on Tuesdays. All times are based on the time zone of
  ## individual commits.
  ## 
  ## 
  let valid = call_28377745.validator(path, query, header, formData, body)
  let scheme = call_28377745.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377745.url(scheme.get, call_28377745.host, call_28377745.base,
                           call_28377745.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377745, url, valid)

proc call*(call_28377746: Call_GetReposOwnerRepoStatsPunchCard_28377739;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsPunchCard
  ## Get the number of commits per hour in each day.
  ## Each array contains the day number, hour number, and number of commits
  ## 0-6 Sunday - Saturday
  ## 0-23 Hour of day
  ## Number of commits
  ## 
  ## For example, [2, 14, 25] indicates that there were 25 total commits, during
  ## the 2.00pm hour on Tuesdays. All times are based on the time zone of
  ## individual commits.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377747 = newJObject()
  var header_28377748 = newJObject()
  add(path_28377747, "owner", newJString(owner))
  add(header_28377748, "Accept", newJString(Accept))
  add(path_28377747, "repo", newJString(repo))
  result = call_28377746.call(path_28377747, nil, header_28377748, nil, nil)

var getReposOwnerRepoStatsPunchCard* = Call_GetReposOwnerRepoStatsPunchCard_28377739(
    name: "getReposOwnerRepoStatsPunchCard", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/punch_card",
    validator: validate_GetReposOwnerRepoStatsPunchCard_28377740, base: "/",
    url: url_GetReposOwnerRepoStatsPunchCard_28377741, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoStatusesRef_28377760 = ref object of OpenApiRestCall_28375350
proc url_PostReposOwnerRepoStatusesRef_28377762(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/statuses/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoStatusesRef_28377761(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a Status.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   ref: JString (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377763 = path.getOrDefault("owner")
  valid_28377763 = validateParameter(valid_28377763, JString, required = true,
                                   default = nil)
  if valid_28377763 != nil:
    section.add "owner", valid_28377763
  var valid_28377764 = path.getOrDefault("ref")
  valid_28377764 = validateParameter(valid_28377764, JString, required = true,
                                   default = nil)
  if valid_28377764 != nil:
    section.add "ref", valid_28377764
  var valid_28377765 = path.getOrDefault("repo")
  valid_28377765 = validateParameter(valid_28377765, JString, required = true,
                                   default = nil)
  if valid_28377765 != nil:
    section.add "repo", valid_28377765
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377766 = header.getOrDefault("Accept")
  valid_28377766 = validateParameter(valid_28377766, JString, required = false,
                                   default = nil)
  if valid_28377766 != nil:
    section.add "Accept", valid_28377766
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28377768: Call_PostReposOwnerRepoStatusesRef_28377760;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Create a Status.
  ## 
  let valid = call_28377768.validator(path, query, header, formData, body)
  let scheme = call_28377768.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377768.url(scheme.get, call_28377768.host, call_28377768.base,
                           call_28377768.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377768, url, valid)

proc call*(call_28377769: Call_PostReposOwnerRepoStatusesRef_28377760;
          owner: string; `ref`: string; body: JsonNode; repo: string;
          Accept: string = ""): Recallable =
  ## postReposOwnerRepoStatusesRef
  ## Create a Status.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   ref: string (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377770 = newJObject()
  var header_28377771 = newJObject()
  var body_28377772 = newJObject()
  add(path_28377770, "owner", newJString(owner))
  add(path_28377770, "ref", newJString(`ref`))
  add(header_28377771, "Accept", newJString(Accept))
  if body != nil:
    body_28377772 = body
  add(path_28377770, "repo", newJString(repo))
  result = call_28377769.call(path_28377770, nil, header_28377771, nil, body_28377772)

var postReposOwnerRepoStatusesRef* = Call_PostReposOwnerRepoStatusesRef_28377760(
    name: "postReposOwnerRepoStatusesRef", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/statuses/{ref}",
    validator: validate_PostReposOwnerRepoStatusesRef_28377761, base: "/",
    url: url_PostReposOwnerRepoStatusesRef_28377762, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatusesRef_28377749 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoStatusesRef_28377751(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/statuses/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatusesRef_28377750(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List Statuses for a specific Ref.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   ref: JString (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377752 = path.getOrDefault("owner")
  valid_28377752 = validateParameter(valid_28377752, JString, required = true,
                                   default = nil)
  if valid_28377752 != nil:
    section.add "owner", valid_28377752
  var valid_28377753 = path.getOrDefault("ref")
  valid_28377753 = validateParameter(valid_28377753, JString, required = true,
                                   default = nil)
  if valid_28377753 != nil:
    section.add "ref", valid_28377753
  var valid_28377754 = path.getOrDefault("repo")
  valid_28377754 = validateParameter(valid_28377754, JString, required = true,
                                   default = nil)
  if valid_28377754 != nil:
    section.add "repo", valid_28377754
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377755 = header.getOrDefault("Accept")
  valid_28377755 = validateParameter(valid_28377755, JString, required = false,
                                   default = nil)
  if valid_28377755 != nil:
    section.add "Accept", valid_28377755
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377756: Call_GetReposOwnerRepoStatusesRef_28377749;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List Statuses for a specific Ref.
  ## 
  let valid = call_28377756.validator(path, query, header, formData, body)
  let scheme = call_28377756.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377756.url(scheme.get, call_28377756.host, call_28377756.base,
                           call_28377756.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377756, url, valid)

proc call*(call_28377757: Call_GetReposOwnerRepoStatusesRef_28377749;
          owner: string; `ref`: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatusesRef
  ## List Statuses for a specific Ref.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   ref: string (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377758 = newJObject()
  var header_28377759 = newJObject()
  add(path_28377758, "owner", newJString(owner))
  add(path_28377758, "ref", newJString(`ref`))
  add(header_28377759, "Accept", newJString(Accept))
  add(path_28377758, "repo", newJString(repo))
  result = call_28377757.call(path_28377758, nil, header_28377759, nil, nil)

var getReposOwnerRepoStatusesRef* = Call_GetReposOwnerRepoStatusesRef_28377749(
    name: "getReposOwnerRepoStatusesRef", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/statuses/{ref}",
    validator: validate_GetReposOwnerRepoStatusesRef_28377750, base: "/",
    url: url_GetReposOwnerRepoStatusesRef_28377751, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoSubscribers_28377773 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoSubscribers_28377775(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/subscribers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoSubscribers_28377774(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List watchers.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377776 = path.getOrDefault("owner")
  valid_28377776 = validateParameter(valid_28377776, JString, required = true,
                                   default = nil)
  if valid_28377776 != nil:
    section.add "owner", valid_28377776
  var valid_28377777 = path.getOrDefault("repo")
  valid_28377777 = validateParameter(valid_28377777, JString, required = true,
                                   default = nil)
  if valid_28377777 != nil:
    section.add "repo", valid_28377777
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377778 = header.getOrDefault("Accept")
  valid_28377778 = validateParameter(valid_28377778, JString, required = false,
                                   default = nil)
  if valid_28377778 != nil:
    section.add "Accept", valid_28377778
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377779: Call_GetReposOwnerRepoSubscribers_28377773;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List watchers.
  ## 
  let valid = call_28377779.validator(path, query, header, formData, body)
  let scheme = call_28377779.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377779.url(scheme.get, call_28377779.host, call_28377779.base,
                           call_28377779.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377779, url, valid)

proc call*(call_28377780: Call_GetReposOwnerRepoSubscribers_28377773;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoSubscribers
  ## List watchers.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377781 = newJObject()
  var header_28377782 = newJObject()
  add(path_28377781, "owner", newJString(owner))
  add(header_28377782, "Accept", newJString(Accept))
  add(path_28377781, "repo", newJString(repo))
  result = call_28377780.call(path_28377781, nil, header_28377782, nil, nil)

var getReposOwnerRepoSubscribers* = Call_GetReposOwnerRepoSubscribers_28377773(
    name: "getReposOwnerRepoSubscribers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscribers",
    validator: validate_GetReposOwnerRepoSubscribers_28377774, base: "/",
    url: url_GetReposOwnerRepoSubscribers_28377775, schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoSubscription_28377793 = ref object of OpenApiRestCall_28375350
proc url_PutReposOwnerRepoSubscription_28377795(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoSubscription_28377794(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set a Repository Subscription
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377796 = path.getOrDefault("owner")
  valid_28377796 = validateParameter(valid_28377796, JString, required = true,
                                   default = nil)
  if valid_28377796 != nil:
    section.add "owner", valid_28377796
  var valid_28377797 = path.getOrDefault("repo")
  valid_28377797 = validateParameter(valid_28377797, JString, required = true,
                                   default = nil)
  if valid_28377797 != nil:
    section.add "repo", valid_28377797
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377798 = header.getOrDefault("Accept")
  valid_28377798 = validateParameter(valid_28377798, JString, required = false,
                                   default = nil)
  if valid_28377798 != nil:
    section.add "Accept", valid_28377798
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28377800: Call_PutReposOwnerRepoSubscription_28377793;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Set a Repository Subscription
  ## 
  let valid = call_28377800.validator(path, query, header, formData, body)
  let scheme = call_28377800.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377800.url(scheme.get, call_28377800.host, call_28377800.base,
                           call_28377800.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377800, url, valid)

proc call*(call_28377801: Call_PutReposOwnerRepoSubscription_28377793;
          owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoSubscription
  ## Set a Repository Subscription
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377802 = newJObject()
  var header_28377803 = newJObject()
  var body_28377804 = newJObject()
  add(path_28377802, "owner", newJString(owner))
  add(header_28377803, "Accept", newJString(Accept))
  if body != nil:
    body_28377804 = body
  add(path_28377802, "repo", newJString(repo))
  result = call_28377801.call(path_28377802, nil, header_28377803, nil, body_28377804)

var putReposOwnerRepoSubscription* = Call_PutReposOwnerRepoSubscription_28377793(
    name: "putReposOwnerRepoSubscription", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscription",
    validator: validate_PutReposOwnerRepoSubscription_28377794, base: "/",
    url: url_PutReposOwnerRepoSubscription_28377795, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoSubscription_28377783 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoSubscription_28377785(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoSubscription_28377784(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a Repository Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377786 = path.getOrDefault("owner")
  valid_28377786 = validateParameter(valid_28377786, JString, required = true,
                                   default = nil)
  if valid_28377786 != nil:
    section.add "owner", valid_28377786
  var valid_28377787 = path.getOrDefault("repo")
  valid_28377787 = validateParameter(valid_28377787, JString, required = true,
                                   default = nil)
  if valid_28377787 != nil:
    section.add "repo", valid_28377787
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377788 = header.getOrDefault("Accept")
  valid_28377788 = validateParameter(valid_28377788, JString, required = false,
                                   default = nil)
  if valid_28377788 != nil:
    section.add "Accept", valid_28377788
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377789: Call_GetReposOwnerRepoSubscription_28377783;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a Repository Subscription.
  ## 
  let valid = call_28377789.validator(path, query, header, formData, body)
  let scheme = call_28377789.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377789.url(scheme.get, call_28377789.host, call_28377789.base,
                           call_28377789.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377789, url, valid)

proc call*(call_28377790: Call_GetReposOwnerRepoSubscription_28377783;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoSubscription
  ## Get a Repository Subscription.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377791 = newJObject()
  var header_28377792 = newJObject()
  add(path_28377791, "owner", newJString(owner))
  add(header_28377792, "Accept", newJString(Accept))
  add(path_28377791, "repo", newJString(repo))
  result = call_28377790.call(path_28377791, nil, header_28377792, nil, nil)

var getReposOwnerRepoSubscription* = Call_GetReposOwnerRepoSubscription_28377783(
    name: "getReposOwnerRepoSubscription", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscription",
    validator: validate_GetReposOwnerRepoSubscription_28377784, base: "/",
    url: url_GetReposOwnerRepoSubscription_28377785, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoSubscription_28377805 = ref object of OpenApiRestCall_28375350
proc url_DeleteReposOwnerRepoSubscription_28377807(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoSubscription_28377806(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a Repository Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377808 = path.getOrDefault("owner")
  valid_28377808 = validateParameter(valid_28377808, JString, required = true,
                                   default = nil)
  if valid_28377808 != nil:
    section.add "owner", valid_28377808
  var valid_28377809 = path.getOrDefault("repo")
  valid_28377809 = validateParameter(valid_28377809, JString, required = true,
                                   default = nil)
  if valid_28377809 != nil:
    section.add "repo", valid_28377809
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377810 = header.getOrDefault("Accept")
  valid_28377810 = validateParameter(valid_28377810, JString, required = false,
                                   default = nil)
  if valid_28377810 != nil:
    section.add "Accept", valid_28377810
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377811: Call_DeleteReposOwnerRepoSubscription_28377805;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a Repository Subscription.
  ## 
  let valid = call_28377811.validator(path, query, header, formData, body)
  let scheme = call_28377811.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377811.url(scheme.get, call_28377811.host, call_28377811.base,
                           call_28377811.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377811, url, valid)

proc call*(call_28377812: Call_DeleteReposOwnerRepoSubscription_28377805;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoSubscription
  ## Delete a Repository Subscription.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377813 = newJObject()
  var header_28377814 = newJObject()
  add(path_28377813, "owner", newJString(owner))
  add(header_28377814, "Accept", newJString(Accept))
  add(path_28377813, "repo", newJString(repo))
  result = call_28377812.call(path_28377813, nil, header_28377814, nil, nil)

var deleteReposOwnerRepoSubscription* = Call_DeleteReposOwnerRepoSubscription_28377805(
    name: "deleteReposOwnerRepoSubscription", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscription",
    validator: validate_DeleteReposOwnerRepoSubscription_28377806, base: "/",
    url: url_DeleteReposOwnerRepoSubscription_28377807, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoTags_28377815 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoTags_28377817(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/tags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoTags_28377816(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get list of tags.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377818 = path.getOrDefault("owner")
  valid_28377818 = validateParameter(valid_28377818, JString, required = true,
                                   default = nil)
  if valid_28377818 != nil:
    section.add "owner", valid_28377818
  var valid_28377819 = path.getOrDefault("repo")
  valid_28377819 = validateParameter(valid_28377819, JString, required = true,
                                   default = nil)
  if valid_28377819 != nil:
    section.add "repo", valid_28377819
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377820 = header.getOrDefault("Accept")
  valid_28377820 = validateParameter(valid_28377820, JString, required = false,
                                   default = nil)
  if valid_28377820 != nil:
    section.add "Accept", valid_28377820
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377821: Call_GetReposOwnerRepoTags_28377815; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get list of tags.
  ## 
  let valid = call_28377821.validator(path, query, header, formData, body)
  let scheme = call_28377821.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377821.url(scheme.get, call_28377821.host, call_28377821.base,
                           call_28377821.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377821, url, valid)

proc call*(call_28377822: Call_GetReposOwnerRepoTags_28377815; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoTags
  ## Get list of tags.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377823 = newJObject()
  var header_28377824 = newJObject()
  add(path_28377823, "owner", newJString(owner))
  add(header_28377824, "Accept", newJString(Accept))
  add(path_28377823, "repo", newJString(repo))
  result = call_28377822.call(path_28377823, nil, header_28377824, nil, nil)

var getReposOwnerRepoTags* = Call_GetReposOwnerRepoTags_28377815(
    name: "getReposOwnerRepoTags", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/repos/{owner}/{repo}/tags",
    validator: validate_GetReposOwnerRepoTags_28377816, base: "/",
    url: url_GetReposOwnerRepoTags_28377817, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoTeams_28377825 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoTeams_28377827(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/teams")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoTeams_28377826(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get list of teams
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377828 = path.getOrDefault("owner")
  valid_28377828 = validateParameter(valid_28377828, JString, required = true,
                                   default = nil)
  if valid_28377828 != nil:
    section.add "owner", valid_28377828
  var valid_28377829 = path.getOrDefault("repo")
  valid_28377829 = validateParameter(valid_28377829, JString, required = true,
                                   default = nil)
  if valid_28377829 != nil:
    section.add "repo", valid_28377829
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377830 = header.getOrDefault("Accept")
  valid_28377830 = validateParameter(valid_28377830, JString, required = false,
                                   default = nil)
  if valid_28377830 != nil:
    section.add "Accept", valid_28377830
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377831: Call_GetReposOwnerRepoTeams_28377825; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get list of teams
  ## 
  let valid = call_28377831.validator(path, query, header, formData, body)
  let scheme = call_28377831.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377831.url(scheme.get, call_28377831.host, call_28377831.base,
                           call_28377831.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377831, url, valid)

proc call*(call_28377832: Call_GetReposOwnerRepoTeams_28377825; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoTeams
  ## Get list of teams
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377833 = newJObject()
  var header_28377834 = newJObject()
  add(path_28377833, "owner", newJString(owner))
  add(header_28377834, "Accept", newJString(Accept))
  add(path_28377833, "repo", newJString(repo))
  result = call_28377832.call(path_28377833, nil, header_28377834, nil, nil)

var getReposOwnerRepoTeams* = Call_GetReposOwnerRepoTeams_28377825(
    name: "getReposOwnerRepoTeams", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/teams",
    validator: validate_GetReposOwnerRepoTeams_28377826, base: "/",
    url: url_GetReposOwnerRepoTeams_28377827, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoWatchers_28377835 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoWatchers_28377837(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/watchers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoWatchers_28377836(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List Stargazers. New implementation.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377838 = path.getOrDefault("owner")
  valid_28377838 = validateParameter(valid_28377838, JString, required = true,
                                   default = nil)
  if valid_28377838 != nil:
    section.add "owner", valid_28377838
  var valid_28377839 = path.getOrDefault("repo")
  valid_28377839 = validateParameter(valid_28377839, JString, required = true,
                                   default = nil)
  if valid_28377839 != nil:
    section.add "repo", valid_28377839
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377840 = header.getOrDefault("Accept")
  valid_28377840 = validateParameter(valid_28377840, JString, required = false,
                                   default = nil)
  if valid_28377840 != nil:
    section.add "Accept", valid_28377840
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377841: Call_GetReposOwnerRepoWatchers_28377835; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List Stargazers. New implementation.
  ## 
  let valid = call_28377841.validator(path, query, header, formData, body)
  let scheme = call_28377841.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377841.url(scheme.get, call_28377841.host, call_28377841.base,
                           call_28377841.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377841, url, valid)

proc call*(call_28377842: Call_GetReposOwnerRepoWatchers_28377835; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoWatchers
  ## List Stargazers. New implementation.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28377843 = newJObject()
  var header_28377844 = newJObject()
  add(path_28377843, "owner", newJString(owner))
  add(header_28377844, "Accept", newJString(Accept))
  add(path_28377843, "repo", newJString(repo))
  result = call_28377842.call(path_28377843, nil, header_28377844, nil, nil)

var getReposOwnerRepoWatchers* = Call_GetReposOwnerRepoWatchers_28377835(
    name: "getReposOwnerRepoWatchers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/watchers",
    validator: validate_GetReposOwnerRepoWatchers_28377836, base: "/",
    url: url_GetReposOwnerRepoWatchers_28377837, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoArchiveFormatPath_28377845 = ref object of OpenApiRestCall_28375350
proc url_GetReposOwnerRepoArchiveFormatPath_28377847(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "archive_format" in path, "`archive_format` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "archive_format"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoArchiveFormatPath_28377846(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get archive link.
  ## This method will return a 302 to a URL to download a tarball or zipball
  ## archive for a repository. Please make sure your HTTP framework is
  ## configured to follow redirects or you will need to use the Location header
  ## to make a second GET request.
  ## Note: For private repositories, these links are temporary and expire quickly.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   archive_format: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   path: JString (required)
  ##       : Valid Git reference, defaults to 'master'.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28377848 = path.getOrDefault("owner")
  valid_28377848 = validateParameter(valid_28377848, JString, required = true,
                                   default = nil)
  if valid_28377848 != nil:
    section.add "owner", valid_28377848
  var valid_28377849 = path.getOrDefault("archive_format")
  valid_28377849 = validateParameter(valid_28377849, JString, required = true,
                                   default = newJString("tarball"))
  if valid_28377849 != nil:
    section.add "archive_format", valid_28377849
  var valid_28377850 = path.getOrDefault("repo")
  valid_28377850 = validateParameter(valid_28377850, JString, required = true,
                                   default = nil)
  if valid_28377850 != nil:
    section.add "repo", valid_28377850
  var valid_28377851 = path.getOrDefault("path")
  valid_28377851 = validateParameter(valid_28377851, JString, required = true,
                                   default = nil)
  if valid_28377851 != nil:
    section.add "path", valid_28377851
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377852 = header.getOrDefault("Accept")
  valid_28377852 = validateParameter(valid_28377852, JString, required = false,
                                   default = nil)
  if valid_28377852 != nil:
    section.add "Accept", valid_28377852
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377853: Call_GetReposOwnerRepoArchiveFormatPath_28377845;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get archive link.
  ## This method will return a 302 to a URL to download a tarball or zipball
  ## archive for a repository. Please make sure your HTTP framework is
  ## configured to follow redirects or you will need to use the Location header
  ## to make a second GET request.
  ## Note: For private repositories, these links are temporary and expire quickly.
  ## 
  ## 
  let valid = call_28377853.validator(path, query, header, formData, body)
  let scheme = call_28377853.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377853.url(scheme.get, call_28377853.host, call_28377853.base,
                           call_28377853.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377853, url, valid)

proc call*(call_28377854: Call_GetReposOwnerRepoArchiveFormatPath_28377845;
          owner: string; repo: string; path: string;
          archiveFormat: string = "tarball"; Accept: string = ""): Recallable =
  ## getReposOwnerRepoArchiveFormatPath
  ## Get archive link.
  ## This method will return a 302 to a URL to download a tarball or zipball
  ## archive for a repository. Please make sure your HTTP framework is
  ## configured to follow redirects or you will need to use the Location header
  ## to make a second GET request.
  ## Note: For private repositories, these links are temporary and expire quickly.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   archiveFormat: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   path: string (required)
  ##       : Valid Git reference, defaults to 'master'.
  var path_28377855 = newJObject()
  var header_28377856 = newJObject()
  add(path_28377855, "owner", newJString(owner))
  add(path_28377855, "archive_format", newJString(archiveFormat))
  add(header_28377856, "Accept", newJString(Accept))
  add(path_28377855, "repo", newJString(repo))
  add(path_28377855, "path", newJString(path))
  result = call_28377854.call(path_28377855, nil, header_28377856, nil, nil)

var getReposOwnerRepoArchiveFormatPath* = Call_GetReposOwnerRepoArchiveFormatPath_28377845(
    name: "getReposOwnerRepoArchiveFormatPath", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/{archive_format}/{path}",
    validator: validate_GetReposOwnerRepoArchiveFormatPath_28377846, base: "/",
    url: url_GetReposOwnerRepoArchiveFormatPath_28377847, schemes: {Scheme.Https})
type
  Call_GetRepositories_28377857 = ref object of OpenApiRestCall_28375350
proc url_GetRepositories_28377859(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRepositories_28377858(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## List all public repositories.
  ## This provides a dump of every public repository, in the order that they
  ## were created.
  ## Note: Pagination is powered exclusively by the since parameter. is the
  ## Link header to get the URL for the next page of repositories.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_28377860 = query.getOrDefault("since")
  valid_28377860 = validateParameter(valid_28377860, JString, required = false,
                                   default = nil)
  if valid_28377860 != nil:
    section.add "since", valid_28377860
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377861 = header.getOrDefault("Accept")
  valid_28377861 = validateParameter(valid_28377861, JString, required = false,
                                   default = nil)
  if valid_28377861 != nil:
    section.add "Accept", valid_28377861
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377862: Call_GetRepositories_28377857; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List all public repositories.
  ## This provides a dump of every public repository, in the order that they
  ## were created.
  ## Note: Pagination is powered exclusively by the since parameter. is the
  ## Link header to get the URL for the next page of repositories.
  ## 
  ## 
  let valid = call_28377862.validator(path, query, header, formData, body)
  let scheme = call_28377862.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377862.url(scheme.get, call_28377862.host, call_28377862.base,
                           call_28377862.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377862, url, valid)

proc call*(call_28377863: Call_GetRepositories_28377857; Accept: string = "";
          since: string = ""): Recallable =
  ## getRepositories
  ## List all public repositories.
  ## This provides a dump of every public repository, in the order that they
  ## were created.
  ## Note: Pagination is powered exclusively by the since parameter. is the
  ## Link header to get the URL for the next page of repositories.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var query_28377864 = newJObject()
  var header_28377865 = newJObject()
  add(header_28377865, "Accept", newJString(Accept))
  add(query_28377864, "since", newJString(since))
  result = call_28377863.call(nil, query_28377864, header_28377865, nil, nil)

var getRepositories* = Call_GetRepositories_28377857(name: "getRepositories",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/repositories",
    validator: validate_GetRepositories_28377858, base: "/",
    url: url_GetRepositories_28377859, schemes: {Scheme.Https})
type
  Call_GetSearchCode_28377866 = ref object of OpenApiRestCall_28375350
proc url_GetSearchCode_28377868(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchCode_28377867(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Search code.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   sort: JString
  ##       : Can only be 'indexed', which indicates how recently a file has been indexed
  ## by the GitHub search infrastructure. If not provided, results are sorted
  ## by best match.
  ## 
  ##   q: JString (required)
  ##    : The search terms. This can be any combination of the supported code
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier
  ## you can restrict the search to just the file contents, the file path,
  ## or both.
  ## 'Languages' Searches code based on the language it's written in.
  ## 'Forks' Filters repositories based on the number of forks, and/or
  ## whether code from forked repositories should be included in the results
  ## at all.
  ## 'Size' Finds files that match a certain size (in bytes).
  ## 'Path' Specifies the path that the resulting file must be at.
  ## 'Extension' Matches files with a certain extension.
  ## 'Users' or 'Repositories' Limits searches to a specific user or repository.
  ## 
  section = newJObject()
  var valid_28377869 = query.getOrDefault("order")
  valid_28377869 = validateParameter(valid_28377869, JString, required = false,
                                   default = newJString("desc"))
  if valid_28377869 != nil:
    section.add "order", valid_28377869
  var valid_28377870 = query.getOrDefault("sort")
  valid_28377870 = validateParameter(valid_28377870, JString, required = false,
                                   default = newJString("indexed"))
  if valid_28377870 != nil:
    section.add "sort", valid_28377870
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_28377871 = query.getOrDefault("q")
  valid_28377871 = validateParameter(valid_28377871, JString, required = true,
                                   default = nil)
  if valid_28377871 != nil:
    section.add "q", valid_28377871
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377872 = header.getOrDefault("Accept")
  valid_28377872 = validateParameter(valid_28377872, JString, required = false,
                                   default = nil)
  if valid_28377872 != nil:
    section.add "Accept", valid_28377872
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377873: Call_GetSearchCode_28377866; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Search code.
  ## 
  let valid = call_28377873.validator(path, query, header, formData, body)
  let scheme = call_28377873.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377873.url(scheme.get, call_28377873.host, call_28377873.base,
                           call_28377873.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377873, url, valid)

proc call*(call_28377874: Call_GetSearchCode_28377866; q: string;
          order: string = "desc"; Accept: string = ""; sort: string = "indexed"): Recallable =
  ## getSearchCode
  ## Search code.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##       : Can only be 'indexed', which indicates how recently a file has been indexed
  ## by the GitHub search infrastructure. If not provided, results are sorted
  ## by best match.
  ## 
  ##   q: string (required)
  ##    : The search terms. This can be any combination of the supported code
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier
  ## you can restrict the search to just the file contents, the file path,
  ## or both.
  ## 'Languages' Searches code based on the language it's written in.
  ## 'Forks' Filters repositories based on the number of forks, and/or
  ## whether code from forked repositories should be included in the results
  ## at all.
  ## 'Size' Finds files that match a certain size (in bytes).
  ## 'Path' Specifies the path that the resulting file must be at.
  ## 'Extension' Matches files with a certain extension.
  ## 'Users' or 'Repositories' Limits searches to a specific user or repository.
  ## 
  var query_28377875 = newJObject()
  var header_28377876 = newJObject()
  add(query_28377875, "order", newJString(order))
  add(header_28377876, "Accept", newJString(Accept))
  add(query_28377875, "sort", newJString(sort))
  add(query_28377875, "q", newJString(q))
  result = call_28377874.call(nil, query_28377875, header_28377876, nil, nil)

var getSearchCode* = Call_GetSearchCode_28377866(name: "getSearchCode",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/search/code",
    validator: validate_GetSearchCode_28377867, base: "/", url: url_GetSearchCode_28377868,
    schemes: {Scheme.Https})
type
  Call_GetSearchIssues_28377877 = ref object of OpenApiRestCall_28375350
proc url_GetSearchIssues_28377879(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchIssues_28377878(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Find issues by state and keyword. (This method returns up to 100 results per page.)
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   sort: JString
  ##       : The sort field. Can be comments, created, or updated. Default: results are sorted by best match.
  ##   q: JString (required)
  ##    : The q search term can also contain any combination of the supported issue search qualifiers:
  section = newJObject()
  var valid_28377880 = query.getOrDefault("order")
  valid_28377880 = validateParameter(valid_28377880, JString, required = false,
                                   default = newJString("desc"))
  if valid_28377880 != nil:
    section.add "order", valid_28377880
  var valid_28377881 = query.getOrDefault("sort")
  valid_28377881 = validateParameter(valid_28377881, JString, required = false,
                                   default = newJString("updated"))
  if valid_28377881 != nil:
    section.add "sort", valid_28377881
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_28377882 = query.getOrDefault("q")
  valid_28377882 = validateParameter(valid_28377882, JString, required = true,
                                   default = nil)
  if valid_28377882 != nil:
    section.add "q", valid_28377882
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377883 = header.getOrDefault("Accept")
  valid_28377883 = validateParameter(valid_28377883, JString, required = false,
                                   default = nil)
  if valid_28377883 != nil:
    section.add "Accept", valid_28377883
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377884: Call_GetSearchIssues_28377877; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Find issues by state and keyword. (This method returns up to 100 results per page.)
  ## 
  let valid = call_28377884.validator(path, query, header, formData, body)
  let scheme = call_28377884.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377884.url(scheme.get, call_28377884.host, call_28377884.base,
                           call_28377884.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377884, url, valid)

proc call*(call_28377885: Call_GetSearchIssues_28377877; q: string;
          order: string = "desc"; Accept: string = ""; sort: string = "updated"): Recallable =
  ## getSearchIssues
  ## Find issues by state and keyword. (This method returns up to 100 results per page.)
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##       : The sort field. Can be comments, created, or updated. Default: results are sorted by best match.
  ##   q: string (required)
  ##    : The q search term can also contain any combination of the supported issue search qualifiers:
  var query_28377886 = newJObject()
  var header_28377887 = newJObject()
  add(query_28377886, "order", newJString(order))
  add(header_28377887, "Accept", newJString(Accept))
  add(query_28377886, "sort", newJString(sort))
  add(query_28377886, "q", newJString(q))
  result = call_28377885.call(nil, query_28377886, header_28377887, nil, nil)

var getSearchIssues* = Call_GetSearchIssues_28377877(name: "getSearchIssues",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/search/issues",
    validator: validate_GetSearchIssues_28377878, base: "/",
    url: url_GetSearchIssues_28377879, schemes: {Scheme.Https})
type
  Call_GetSearchRepositories_28377888 = ref object of OpenApiRestCall_28375350
proc url_GetSearchRepositories_28377890(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchRepositories_28377889(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Search repositories.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   sort: JString
  ##       : If not provided, results are sorted by best match.
  ##   q: JString (required)
  ##    : The search terms. This can be any combination of the supported repository
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the repository name, description, readme,
  ## or any combination of these.
  ## 'Size' Finds repositories that match a certain size (in kilobytes).
  ## 'Forks' Filters repositories based on the number of forks, and/or whether
  ## forked repositories should be included in the results at all.
  ## 'Created' and 'Last Updated' Filters repositories based on times of
  ## creation, or when they were last updated.
  ## 'Users or Repositories' Limits searches to a specific user or repository.
  ## 'Languages' Searches repositories based on the language they are written in.
  ## 'Stars' Searches repositories based on the number of stars.
  ## 
  section = newJObject()
  var valid_28377891 = query.getOrDefault("order")
  valid_28377891 = validateParameter(valid_28377891, JString, required = false,
                                   default = newJString("desc"))
  if valid_28377891 != nil:
    section.add "order", valid_28377891
  var valid_28377892 = query.getOrDefault("sort")
  valid_28377892 = validateParameter(valid_28377892, JString, required = false,
                                   default = newJString("stars"))
  if valid_28377892 != nil:
    section.add "sort", valid_28377892
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_28377893 = query.getOrDefault("q")
  valid_28377893 = validateParameter(valid_28377893, JString, required = true,
                                   default = nil)
  if valid_28377893 != nil:
    section.add "q", valid_28377893
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377894 = header.getOrDefault("Accept")
  valid_28377894 = validateParameter(valid_28377894, JString, required = false,
                                   default = nil)
  if valid_28377894 != nil:
    section.add "Accept", valid_28377894
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377895: Call_GetSearchRepositories_28377888; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Search repositories.
  ## 
  let valid = call_28377895.validator(path, query, header, formData, body)
  let scheme = call_28377895.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377895.url(scheme.get, call_28377895.host, call_28377895.base,
                           call_28377895.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377895, url, valid)

proc call*(call_28377896: Call_GetSearchRepositories_28377888; q: string;
          order: string = "desc"; Accept: string = ""; sort: string = "stars"): Recallable =
  ## getSearchRepositories
  ## Search repositories.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##       : If not provided, results are sorted by best match.
  ##   q: string (required)
  ##    : The search terms. This can be any combination of the supported repository
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the repository name, description, readme,
  ## or any combination of these.
  ## 'Size' Finds repositories that match a certain size (in kilobytes).
  ## 'Forks' Filters repositories based on the number of forks, and/or whether
  ## forked repositories should be included in the results at all.
  ## 'Created' and 'Last Updated' Filters repositories based on times of
  ## creation, or when they were last updated.
  ## 'Users or Repositories' Limits searches to a specific user or repository.
  ## 'Languages' Searches repositories based on the language they are written in.
  ## 'Stars' Searches repositories based on the number of stars.
  ## 
  var query_28377897 = newJObject()
  var header_28377898 = newJObject()
  add(query_28377897, "order", newJString(order))
  add(header_28377898, "Accept", newJString(Accept))
  add(query_28377897, "sort", newJString(sort))
  add(query_28377897, "q", newJString(q))
  result = call_28377896.call(nil, query_28377897, header_28377898, nil, nil)

var getSearchRepositories* = Call_GetSearchRepositories_28377888(
    name: "getSearchRepositories", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/search/repositories", validator: validate_GetSearchRepositories_28377889,
    base: "/", url: url_GetSearchRepositories_28377890, schemes: {Scheme.Https})
type
  Call_GetSearchUsers_28377899 = ref object of OpenApiRestCall_28375350
proc url_GetSearchUsers_28377901(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchUsers_28377900(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Search users.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   sort: JString
  ##       : If not provided, results are sorted by best match.
  ##   q: JString (required)
  ##    : The search terms. This can be any combination of the supported user
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the username, public email, full name,
  ## location, or any combination of these.
  ## 'Repository count' Filters users based on the number of repositories they
  ## have.
  ## 'Location' Filter users by the location indicated in their profile.
  ## 'Language' Search for users that have repositories that match a certain
  ## language.
  ## 'Created' Filter users based on when they joined.
  ## 'Followers' Filter users based on the number of followers they have.
  ## 
  section = newJObject()
  var valid_28377902 = query.getOrDefault("order")
  valid_28377902 = validateParameter(valid_28377902, JString, required = false,
                                   default = newJString("desc"))
  if valid_28377902 != nil:
    section.add "order", valid_28377902
  var valid_28377903 = query.getOrDefault("sort")
  valid_28377903 = validateParameter(valid_28377903, JString, required = false,
                                   default = newJString("followers"))
  if valid_28377903 != nil:
    section.add "sort", valid_28377903
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_28377904 = query.getOrDefault("q")
  valid_28377904 = validateParameter(valid_28377904, JString, required = true,
                                   default = nil)
  if valid_28377904 != nil:
    section.add "q", valid_28377904
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377905 = header.getOrDefault("Accept")
  valid_28377905 = validateParameter(valid_28377905, JString, required = false,
                                   default = nil)
  if valid_28377905 != nil:
    section.add "Accept", valid_28377905
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377906: Call_GetSearchUsers_28377899; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Search users.
  ## 
  let valid = call_28377906.validator(path, query, header, formData, body)
  let scheme = call_28377906.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377906.url(scheme.get, call_28377906.host, call_28377906.base,
                           call_28377906.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377906, url, valid)

proc call*(call_28377907: Call_GetSearchUsers_28377899; q: string;
          order: string = "desc"; Accept: string = ""; sort: string = "followers"): Recallable =
  ## getSearchUsers
  ## Search users.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##       : If not provided, results are sorted by best match.
  ##   q: string (required)
  ##    : The search terms. This can be any combination of the supported user
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the username, public email, full name,
  ## location, or any combination of these.
  ## 'Repository count' Filters users based on the number of repositories they
  ## have.
  ## 'Location' Filter users by the location indicated in their profile.
  ## 'Language' Search for users that have repositories that match a certain
  ## language.
  ## 'Created' Filter users based on when they joined.
  ## 'Followers' Filter users based on the number of followers they have.
  ## 
  var query_28377908 = newJObject()
  var header_28377909 = newJObject()
  add(query_28377908, "order", newJString(order))
  add(header_28377909, "Accept", newJString(Accept))
  add(query_28377908, "sort", newJString(sort))
  add(query_28377908, "q", newJString(q))
  result = call_28377907.call(nil, query_28377908, header_28377909, nil, nil)

var getSearchUsers* = Call_GetSearchUsers_28377899(name: "getSearchUsers",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/search/users",
    validator: validate_GetSearchUsers_28377900, base: "/", url: url_GetSearchUsers_28377901,
    schemes: {Scheme.Https})
type
  Call_GetTeamsTeamId_28377910 = ref object of OpenApiRestCall_28375350
proc url_GetTeamsTeamId_28377912(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamId_28377911(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Get team.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_28377913 = path.getOrDefault("teamId")
  valid_28377913 = validateParameter(valid_28377913, JInt, required = true,
                                   default = nil)
  if valid_28377913 != nil:
    section.add "teamId", valid_28377913
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377914 = header.getOrDefault("Accept")
  valid_28377914 = validateParameter(valid_28377914, JString, required = false,
                                   default = nil)
  if valid_28377914 != nil:
    section.add "Accept", valid_28377914
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377915: Call_GetTeamsTeamId_28377910; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get team.
  ## 
  let valid = call_28377915.validator(path, query, header, formData, body)
  let scheme = call_28377915.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377915.url(scheme.get, call_28377915.host, call_28377915.base,
                           call_28377915.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377915, url, valid)

proc call*(call_28377916: Call_GetTeamsTeamId_28377910; teamId: int;
          Accept: string = ""): Recallable =
  ## getTeamsTeamId
  ## Get team.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_28377917 = newJObject()
  var header_28377918 = newJObject()
  add(header_28377918, "Accept", newJString(Accept))
  add(path_28377917, "teamId", newJInt(teamId))
  result = call_28377916.call(path_28377917, nil, header_28377918, nil, nil)

var getTeamsTeamId* = Call_GetTeamsTeamId_28377910(name: "getTeamsTeamId",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/teams/{teamId}",
    validator: validate_GetTeamsTeamId_28377911, base: "/", url: url_GetTeamsTeamId_28377912,
    schemes: {Scheme.Https})
type
  Call_PatchTeamsTeamId_28377928 = ref object of OpenApiRestCall_28375350
proc url_PatchTeamsTeamId_28377930(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchTeamsTeamId_28377929(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Edit team.
  ## In order to edit a team, the authenticated user must be an owner of the org
  ## that the team is associated with.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_28377931 = path.getOrDefault("teamId")
  valid_28377931 = validateParameter(valid_28377931, JInt, required = true,
                                   default = nil)
  if valid_28377931 != nil:
    section.add "teamId", valid_28377931
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377932 = header.getOrDefault("Accept")
  valid_28377932 = validateParameter(valid_28377932, JString, required = false,
                                   default = nil)
  if valid_28377932 != nil:
    section.add "Accept", valid_28377932
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28377934: Call_PatchTeamsTeamId_28377928; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Edit team.
  ## In order to edit a team, the authenticated user must be an owner of the org
  ## that the team is associated with.
  ## 
  ## 
  let valid = call_28377934.validator(path, query, header, formData, body)
  let scheme = call_28377934.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377934.url(scheme.get, call_28377934.host, call_28377934.base,
                           call_28377934.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377934, url, valid)

proc call*(call_28377935: Call_PatchTeamsTeamId_28377928; body: JsonNode;
          teamId: int; Accept: string = ""): Recallable =
  ## patchTeamsTeamId
  ## Edit team.
  ## In order to edit a team, the authenticated user must be an owner of the org
  ## that the team is associated with.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   teamId: int (required)
  ##         : Id of team.
  var path_28377936 = newJObject()
  var header_28377937 = newJObject()
  var body_28377938 = newJObject()
  add(header_28377937, "Accept", newJString(Accept))
  if body != nil:
    body_28377938 = body
  add(path_28377936, "teamId", newJInt(teamId))
  result = call_28377935.call(path_28377936, nil, header_28377937, nil, body_28377938)

var patchTeamsTeamId* = Call_PatchTeamsTeamId_28377928(name: "patchTeamsTeamId",
    meth: HttpMethod.HttpPatch, host: "api.github.com", route: "/teams/{teamId}",
    validator: validate_PatchTeamsTeamId_28377929, base: "/",
    url: url_PatchTeamsTeamId_28377930, schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamId_28377919 = ref object of OpenApiRestCall_28375350
proc url_DeleteTeamsTeamId_28377921(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamId_28377920(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Delete team.
  ## In order to delete a team, the authenticated user must be an owner of the
  ## org that the team is associated with.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_28377922 = path.getOrDefault("teamId")
  valid_28377922 = validateParameter(valid_28377922, JInt, required = true,
                                   default = nil)
  if valid_28377922 != nil:
    section.add "teamId", valid_28377922
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377923 = header.getOrDefault("Accept")
  valid_28377923 = validateParameter(valid_28377923, JString, required = false,
                                   default = nil)
  if valid_28377923 != nil:
    section.add "Accept", valid_28377923
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377924: Call_DeleteTeamsTeamId_28377919; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete team.
  ## In order to delete a team, the authenticated user must be an owner of the
  ## org that the team is associated with.
  ## 
  ## 
  let valid = call_28377924.validator(path, query, header, formData, body)
  let scheme = call_28377924.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377924.url(scheme.get, call_28377924.host, call_28377924.base,
                           call_28377924.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377924, url, valid)

proc call*(call_28377925: Call_DeleteTeamsTeamId_28377919; teamId: int;
          Accept: string = ""): Recallable =
  ## deleteTeamsTeamId
  ## Delete team.
  ## In order to delete a team, the authenticated user must be an owner of the
  ## org that the team is associated with.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_28377926 = newJObject()
  var header_28377927 = newJObject()
  add(header_28377927, "Accept", newJString(Accept))
  add(path_28377926, "teamId", newJInt(teamId))
  result = call_28377925.call(path_28377926, nil, header_28377927, nil, nil)

var deleteTeamsTeamId* = Call_DeleteTeamsTeamId_28377919(name: "deleteTeamsTeamId",
    meth: HttpMethod.HttpDelete, host: "api.github.com", route: "/teams/{teamId}",
    validator: validate_DeleteTeamsTeamId_28377920, base: "/",
    url: url_DeleteTeamsTeamId_28377921, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdMembers_28377939 = ref object of OpenApiRestCall_28375350
proc url_GetTeamsTeamIdMembers_28377941(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/members")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdMembers_28377940(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List team members.
  ## In order to list members in a team, the authenticated user must be a member
  ## of the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_28377942 = path.getOrDefault("teamId")
  valid_28377942 = validateParameter(valid_28377942, JInt, required = true,
                                   default = nil)
  if valid_28377942 != nil:
    section.add "teamId", valid_28377942
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377943 = header.getOrDefault("Accept")
  valid_28377943 = validateParameter(valid_28377943, JString, required = false,
                                   default = nil)
  if valid_28377943 != nil:
    section.add "Accept", valid_28377943
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377944: Call_GetTeamsTeamIdMembers_28377939; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List team members.
  ## In order to list members in a team, the authenticated user must be a member
  ## of the team.
  ## 
  ## 
  let valid = call_28377944.validator(path, query, header, formData, body)
  let scheme = call_28377944.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377944.url(scheme.get, call_28377944.host, call_28377944.base,
                           call_28377944.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377944, url, valid)

proc call*(call_28377945: Call_GetTeamsTeamIdMembers_28377939; teamId: int;
          Accept: string = ""): Recallable =
  ## getTeamsTeamIdMembers
  ## List team members.
  ## In order to list members in a team, the authenticated user must be a member
  ## of the team.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_28377946 = newJObject()
  var header_28377947 = newJObject()
  add(header_28377947, "Accept", newJString(Accept))
  add(path_28377946, "teamId", newJInt(teamId))
  result = call_28377945.call(path_28377946, nil, header_28377947, nil, nil)

var getTeamsTeamIdMembers* = Call_GetTeamsTeamIdMembers_28377939(
    name: "getTeamsTeamIdMembers", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/teams/{teamId}/members", validator: validate_GetTeamsTeamIdMembers_28377940,
    base: "/", url: url_GetTeamsTeamIdMembers_28377941, schemes: {Scheme.Https})
type
  Call_PutTeamsTeamIdMembersUsername_28377958 = ref object of OpenApiRestCall_28375350
proc url_PutTeamsTeamIdMembersUsername_28377960(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutTeamsTeamIdMembersUsername_28377959(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## The API (described below) is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Add team membership API instead. It allows you to invite new organization members to your teams.
  ## 
  ## Add team member.
  ## In order to add a user to a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_28377961 = path.getOrDefault("username")
  valid_28377961 = validateParameter(valid_28377961, JString, required = true,
                                   default = nil)
  if valid_28377961 != nil:
    section.add "username", valid_28377961
  var valid_28377962 = path.getOrDefault("teamId")
  valid_28377962 = validateParameter(valid_28377962, JInt, required = true,
                                   default = nil)
  if valid_28377962 != nil:
    section.add "teamId", valid_28377962
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377963 = header.getOrDefault("Accept")
  valid_28377963 = validateParameter(valid_28377963, JString, required = false,
                                   default = nil)
  if valid_28377963 != nil:
    section.add "Accept", valid_28377963
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377964: Call_PutTeamsTeamIdMembersUsername_28377958;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## The API (described below) is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Add team membership API instead. It allows you to invite new organization members to your teams.
  ## 
  ## Add team member.
  ## In order to add a user to a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## 
  ## 
  let valid = call_28377964.validator(path, query, header, formData, body)
  let scheme = call_28377964.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377964.url(scheme.get, call_28377964.host, call_28377964.base,
                           call_28377964.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377964, url, valid)

proc call*(call_28377965: Call_PutTeamsTeamIdMembersUsername_28377958;
          username: string; teamId: int; Accept: string = ""): Recallable =
  ## putTeamsTeamIdMembersUsername
  ## The API (described below) is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Add team membership API instead. It allows you to invite new organization members to your teams.
  ## 
  ## Add team member.
  ## In order to add a user to a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_28377966 = newJObject()
  var header_28377967 = newJObject()
  add(path_28377966, "username", newJString(username))
  add(header_28377967, "Accept", newJString(Accept))
  add(path_28377966, "teamId", newJInt(teamId))
  result = call_28377965.call(path_28377966, nil, header_28377967, nil, nil)

var putTeamsTeamIdMembersUsername* = Call_PutTeamsTeamIdMembersUsername_28377958(
    name: "putTeamsTeamIdMembersUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/teams/{teamId}/members/{username}",
    validator: validate_PutTeamsTeamIdMembersUsername_28377959, base: "/",
    url: url_PutTeamsTeamIdMembersUsername_28377960, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdMembersUsername_28377948 = ref object of OpenApiRestCall_28375350
proc url_GetTeamsTeamIdMembersUsername_28377950(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdMembersUsername_28377949(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## The "Get team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Get team membership API instead. It allows you to get both active and pending memberships.
  ## 
  ## Get team member.
  ## In order to get if a user is a member of a team, the authenticated user mus
  ## be a member of the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_28377951 = path.getOrDefault("username")
  valid_28377951 = validateParameter(valid_28377951, JString, required = true,
                                   default = nil)
  if valid_28377951 != nil:
    section.add "username", valid_28377951
  var valid_28377952 = path.getOrDefault("teamId")
  valid_28377952 = validateParameter(valid_28377952, JInt, required = true,
                                   default = nil)
  if valid_28377952 != nil:
    section.add "teamId", valid_28377952
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377953 = header.getOrDefault("Accept")
  valid_28377953 = validateParameter(valid_28377953, JString, required = false,
                                   default = nil)
  if valid_28377953 != nil:
    section.add "Accept", valid_28377953
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377954: Call_GetTeamsTeamIdMembersUsername_28377948;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## The "Get team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Get team membership API instead. It allows you to get both active and pending memberships.
  ## 
  ## Get team member.
  ## In order to get if a user is a member of a team, the authenticated user mus
  ## be a member of the team.
  ## 
  ## 
  let valid = call_28377954.validator(path, query, header, formData, body)
  let scheme = call_28377954.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377954.url(scheme.get, call_28377954.host, call_28377954.base,
                           call_28377954.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377954, url, valid)

proc call*(call_28377955: Call_GetTeamsTeamIdMembersUsername_28377948;
          username: string; teamId: int; Accept: string = ""): Recallable =
  ## getTeamsTeamIdMembersUsername
  ## The "Get team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Get team membership API instead. It allows you to get both active and pending memberships.
  ## 
  ## Get team member.
  ## In order to get if a user is a member of a team, the authenticated user mus
  ## be a member of the team.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_28377956 = newJObject()
  var header_28377957 = newJObject()
  add(path_28377956, "username", newJString(username))
  add(header_28377957, "Accept", newJString(Accept))
  add(path_28377956, "teamId", newJInt(teamId))
  result = call_28377955.call(path_28377956, nil, header_28377957, nil, nil)

var getTeamsTeamIdMembersUsername* = Call_GetTeamsTeamIdMembersUsername_28377948(
    name: "getTeamsTeamIdMembersUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/teams/{teamId}/members/{username}",
    validator: validate_GetTeamsTeamIdMembersUsername_28377949, base: "/",
    url: url_GetTeamsTeamIdMembersUsername_28377950, schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamIdMembersUsername_28377968 = ref object of OpenApiRestCall_28375350
proc url_DeleteTeamsTeamIdMembersUsername_28377970(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamIdMembersUsername_28377969(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## The "Remove team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Remove team membership API instead. It allows you to remove both active and pending memberships.
  ## 
  ## Remove team member.
  ## In order to remove a user from a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## NOTE This does not delete the user, it just remove them from the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_28377971 = path.getOrDefault("username")
  valid_28377971 = validateParameter(valid_28377971, JString, required = true,
                                   default = nil)
  if valid_28377971 != nil:
    section.add "username", valid_28377971
  var valid_28377972 = path.getOrDefault("teamId")
  valid_28377972 = validateParameter(valid_28377972, JInt, required = true,
                                   default = nil)
  if valid_28377972 != nil:
    section.add "teamId", valid_28377972
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377973 = header.getOrDefault("Accept")
  valid_28377973 = validateParameter(valid_28377973, JString, required = false,
                                   default = nil)
  if valid_28377973 != nil:
    section.add "Accept", valid_28377973
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377974: Call_DeleteTeamsTeamIdMembersUsername_28377968;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## The "Remove team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Remove team membership API instead. It allows you to remove both active and pending memberships.
  ## 
  ## Remove team member.
  ## In order to remove a user from a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## NOTE This does not delete the user, it just remove them from the team.
  ## 
  ## 
  let valid = call_28377974.validator(path, query, header, formData, body)
  let scheme = call_28377974.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377974.url(scheme.get, call_28377974.host, call_28377974.base,
                           call_28377974.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377974, url, valid)

proc call*(call_28377975: Call_DeleteTeamsTeamIdMembersUsername_28377968;
          username: string; teamId: int; Accept: string = ""): Recallable =
  ## deleteTeamsTeamIdMembersUsername
  ## The "Remove team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Remove team membership API instead. It allows you to remove both active and pending memberships.
  ## 
  ## Remove team member.
  ## In order to remove a user from a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## NOTE This does not delete the user, it just remove them from the team.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_28377976 = newJObject()
  var header_28377977 = newJObject()
  add(path_28377976, "username", newJString(username))
  add(header_28377977, "Accept", newJString(Accept))
  add(path_28377976, "teamId", newJInt(teamId))
  result = call_28377975.call(path_28377976, nil, header_28377977, nil, nil)

var deleteTeamsTeamIdMembersUsername* = Call_DeleteTeamsTeamIdMembersUsername_28377968(
    name: "deleteTeamsTeamIdMembersUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/teams/{teamId}/members/{username}",
    validator: validate_DeleteTeamsTeamIdMembersUsername_28377969, base: "/",
    url: url_DeleteTeamsTeamIdMembersUsername_28377970, schemes: {Scheme.Https})
type
  Call_PutTeamsTeamIdMembershipsUsername_28377988 = ref object of OpenApiRestCall_28375350
proc url_PutTeamsTeamIdMembershipsUsername_28377990(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/memberships/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutTeamsTeamIdMembershipsUsername_28377989(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Add team membership.
  ## In order to add a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with.
  ## 
  ## If the user is already a part of the team's organization (meaning they're on at least one other team in the organization), this endpoint will add the user to the team.
  ## 
  ## If the user is completely unaffiliated with the team's organization (meaning they're on none of the organization's teams), this endpoint will send an invitation to the user via email. This newly-created membership will be in the 'pending' state until the user accepts the invitation, at which point the membership will transition to the 'active' state and the user will be added as a member of the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_28377991 = path.getOrDefault("username")
  valid_28377991 = validateParameter(valid_28377991, JString, required = true,
                                   default = nil)
  if valid_28377991 != nil:
    section.add "username", valid_28377991
  var valid_28377992 = path.getOrDefault("teamId")
  valid_28377992 = validateParameter(valid_28377992, JInt, required = true,
                                   default = nil)
  if valid_28377992 != nil:
    section.add "teamId", valid_28377992
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377993 = header.getOrDefault("Accept")
  valid_28377993 = validateParameter(valid_28377993, JString, required = false,
                                   default = nil)
  if valid_28377993 != nil:
    section.add "Accept", valid_28377993
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377994: Call_PutTeamsTeamIdMembershipsUsername_28377988;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Add team membership.
  ## In order to add a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with.
  ## 
  ## If the user is already a part of the team's organization (meaning they're on at least one other team in the organization), this endpoint will add the user to the team.
  ## 
  ## If the user is completely unaffiliated with the team's organization (meaning they're on none of the organization's teams), this endpoint will send an invitation to the user via email. This newly-created membership will be in the 'pending' state until the user accepts the invitation, at which point the membership will transition to the 'active' state and the user will be added as a member of the team.
  ## 
  ## 
  let valid = call_28377994.validator(path, query, header, formData, body)
  let scheme = call_28377994.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377994.url(scheme.get, call_28377994.host, call_28377994.base,
                           call_28377994.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377994, url, valid)

proc call*(call_28377995: Call_PutTeamsTeamIdMembershipsUsername_28377988;
          username: string; teamId: int; Accept: string = ""): Recallable =
  ## putTeamsTeamIdMembershipsUsername
  ## Add team membership.
  ## In order to add a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with.
  ## 
  ## If the user is already a part of the team's organization (meaning they're on at least one other team in the organization), this endpoint will add the user to the team.
  ## 
  ## If the user is completely unaffiliated with the team's organization (meaning they're on none of the organization's teams), this endpoint will send an invitation to the user via email. This newly-created membership will be in the 'pending' state until the user accepts the invitation, at which point the membership will transition to the 'active' state and the user will be added as a member of the team.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_28377996 = newJObject()
  var header_28377997 = newJObject()
  add(path_28377996, "username", newJString(username))
  add(header_28377997, "Accept", newJString(Accept))
  add(path_28377996, "teamId", newJInt(teamId))
  result = call_28377995.call(path_28377996, nil, header_28377997, nil, nil)

var putTeamsTeamIdMembershipsUsername* = Call_PutTeamsTeamIdMembershipsUsername_28377988(
    name: "putTeamsTeamIdMembershipsUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/teams/{teamId}/memberships/{username}",
    validator: validate_PutTeamsTeamIdMembershipsUsername_28377989, base: "/",
    url: url_PutTeamsTeamIdMembershipsUsername_28377990, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdMembershipsUsername_28377978 = ref object of OpenApiRestCall_28375350
proc url_GetTeamsTeamIdMembershipsUsername_28377980(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/memberships/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdMembershipsUsername_28377979(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get team membership.
  ## In order to get a user's membership with a team, the authenticated user must be a member of the team or an owner of the team's organization.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_28377981 = path.getOrDefault("username")
  valid_28377981 = validateParameter(valid_28377981, JString, required = true,
                                   default = nil)
  if valid_28377981 != nil:
    section.add "username", valid_28377981
  var valid_28377982 = path.getOrDefault("teamId")
  valid_28377982 = validateParameter(valid_28377982, JInt, required = true,
                                   default = nil)
  if valid_28377982 != nil:
    section.add "teamId", valid_28377982
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28377983 = header.getOrDefault("Accept")
  valid_28377983 = validateParameter(valid_28377983, JString, required = false,
                                   default = nil)
  if valid_28377983 != nil:
    section.add "Accept", valid_28377983
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28377984: Call_GetTeamsTeamIdMembershipsUsername_28377978;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get team membership.
  ## In order to get a user's membership with a team, the authenticated user must be a member of the team or an owner of the team's organization.
  ## 
  ## 
  let valid = call_28377984.validator(path, query, header, formData, body)
  let scheme = call_28377984.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28377984.url(scheme.get, call_28377984.host, call_28377984.base,
                           call_28377984.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28377984, url, valid)

proc call*(call_28377985: Call_GetTeamsTeamIdMembershipsUsername_28377978;
          username: string; teamId: int; Accept: string = ""): Recallable =
  ## getTeamsTeamIdMembershipsUsername
  ## Get team membership.
  ## In order to get a user's membership with a team, the authenticated user must be a member of the team or an owner of the team's organization.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_28377986 = newJObject()
  var header_28377987 = newJObject()
  add(path_28377986, "username", newJString(username))
  add(header_28377987, "Accept", newJString(Accept))
  add(path_28377986, "teamId", newJInt(teamId))
  result = call_28377985.call(path_28377986, nil, header_28377987, nil, nil)

var getTeamsTeamIdMembershipsUsername* = Call_GetTeamsTeamIdMembershipsUsername_28377978(
    name: "getTeamsTeamIdMembershipsUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/teams/{teamId}/memberships/{username}",
    validator: validate_GetTeamsTeamIdMembershipsUsername_28377979, base: "/",
    url: url_GetTeamsTeamIdMembershipsUsername_28377980, schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamIdMembershipsUsername_28377998 = ref object of OpenApiRestCall_28375350
proc url_DeleteTeamsTeamIdMembershipsUsername_28378000(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/memberships/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamIdMembershipsUsername_28377999(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Remove team membership.
  ## In order to remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. NOTE: This does not delete the user, it just removes their membership from the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_28378001 = path.getOrDefault("username")
  valid_28378001 = validateParameter(valid_28378001, JString, required = true,
                                   default = nil)
  if valid_28378001 != nil:
    section.add "username", valid_28378001
  var valid_28378002 = path.getOrDefault("teamId")
  valid_28378002 = validateParameter(valid_28378002, JInt, required = true,
                                   default = nil)
  if valid_28378002 != nil:
    section.add "teamId", valid_28378002
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378003 = header.getOrDefault("Accept")
  valid_28378003 = validateParameter(valid_28378003, JString, required = false,
                                   default = nil)
  if valid_28378003 != nil:
    section.add "Accept", valid_28378003
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378004: Call_DeleteTeamsTeamIdMembershipsUsername_28377998;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Remove team membership.
  ## In order to remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. NOTE: This does not delete the user, it just removes their membership from the team.
  ## 
  ## 
  let valid = call_28378004.validator(path, query, header, formData, body)
  let scheme = call_28378004.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378004.url(scheme.get, call_28378004.host, call_28378004.base,
                           call_28378004.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378004, url, valid)

proc call*(call_28378005: Call_DeleteTeamsTeamIdMembershipsUsername_28377998;
          username: string; teamId: int; Accept: string = ""): Recallable =
  ## deleteTeamsTeamIdMembershipsUsername
  ## Remove team membership.
  ## In order to remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. NOTE: This does not delete the user, it just removes their membership from the team.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_28378006 = newJObject()
  var header_28378007 = newJObject()
  add(path_28378006, "username", newJString(username))
  add(header_28378007, "Accept", newJString(Accept))
  add(path_28378006, "teamId", newJInt(teamId))
  result = call_28378005.call(path_28378006, nil, header_28378007, nil, nil)

var deleteTeamsTeamIdMembershipsUsername* = Call_DeleteTeamsTeamIdMembershipsUsername_28377998(
    name: "deleteTeamsTeamIdMembershipsUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/teams/{teamId}/memberships/{username}",
    validator: validate_DeleteTeamsTeamIdMembershipsUsername_28377999, base: "/",
    url: url_DeleteTeamsTeamIdMembershipsUsername_28378000,
    schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdRepos_28378008 = ref object of OpenApiRestCall_28375350
proc url_GetTeamsTeamIdRepos_28378010(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdRepos_28378009(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List team repos
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_28378011 = path.getOrDefault("teamId")
  valid_28378011 = validateParameter(valid_28378011, JInt, required = true,
                                   default = nil)
  if valid_28378011 != nil:
    section.add "teamId", valid_28378011
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378012 = header.getOrDefault("Accept")
  valid_28378012 = validateParameter(valid_28378012, JString, required = false,
                                   default = nil)
  if valid_28378012 != nil:
    section.add "Accept", valid_28378012
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378013: Call_GetTeamsTeamIdRepos_28378008; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List team repos
  ## 
  let valid = call_28378013.validator(path, query, header, formData, body)
  let scheme = call_28378013.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378013.url(scheme.get, call_28378013.host, call_28378013.base,
                           call_28378013.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378013, url, valid)

proc call*(call_28378014: Call_GetTeamsTeamIdRepos_28378008; teamId: int;
          Accept: string = ""): Recallable =
  ## getTeamsTeamIdRepos
  ## List team repos
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_28378015 = newJObject()
  var header_28378016 = newJObject()
  add(header_28378016, "Accept", newJString(Accept))
  add(path_28378015, "teamId", newJInt(teamId))
  result = call_28378014.call(path_28378015, nil, header_28378016, nil, nil)

var getTeamsTeamIdRepos* = Call_GetTeamsTeamIdRepos_28378008(
    name: "getTeamsTeamIdRepos", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/teams/{teamId}/repos", validator: validate_GetTeamsTeamIdRepos_28378009,
    base: "/", url: url_GetTeamsTeamIdRepos_28378010, schemes: {Scheme.Https})
type
  Call_PutTeamsTeamIdReposOwnerRepo_28378028 = ref object of OpenApiRestCall_28375350
proc url_PutTeamsTeamIdReposOwnerRepo_28378030(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutTeamsTeamIdReposOwnerRepo_28378029(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## In order to add a repository to a team, the authenticated user must be an owner of the org that the team is associated with. Also, the repository must be owned by the organization, or a direct fork of a repository owned by the organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of a organization.
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28378031 = path.getOrDefault("owner")
  valid_28378031 = validateParameter(valid_28378031, JString, required = true,
                                   default = nil)
  if valid_28378031 != nil:
    section.add "owner", valid_28378031
  var valid_28378032 = path.getOrDefault("repo")
  valid_28378032 = validateParameter(valid_28378032, JString, required = true,
                                   default = nil)
  if valid_28378032 != nil:
    section.add "repo", valid_28378032
  var valid_28378033 = path.getOrDefault("teamId")
  valid_28378033 = validateParameter(valid_28378033, JInt, required = true,
                                   default = nil)
  if valid_28378033 != nil:
    section.add "teamId", valid_28378033
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378034 = header.getOrDefault("Accept")
  valid_28378034 = validateParameter(valid_28378034, JString, required = false,
                                   default = nil)
  if valid_28378034 != nil:
    section.add "Accept", valid_28378034
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378035: Call_PutTeamsTeamIdReposOwnerRepo_28378028;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## In order to add a repository to a team, the authenticated user must be an owner of the org that the team is associated with. Also, the repository must be owned by the organization, or a direct fork of a repository owned by the organization.
  ## 
  let valid = call_28378035.validator(path, query, header, formData, body)
  let scheme = call_28378035.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378035.url(scheme.get, call_28378035.host, call_28378035.base,
                           call_28378035.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378035, url, valid)

proc call*(call_28378036: Call_PutTeamsTeamIdReposOwnerRepo_28378028;
          owner: string; repo: string; teamId: int; Accept: string = ""): Recallable =
  ## putTeamsTeamIdReposOwnerRepo
  ## In order to add a repository to a team, the authenticated user must be an owner of the org that the team is associated with. Also, the repository must be owned by the organization, or a direct fork of a repository owned by the organization.
  ##   owner: string (required)
  ##        : Name of a organization.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_28378037 = newJObject()
  var header_28378038 = newJObject()
  add(path_28378037, "owner", newJString(owner))
  add(header_28378038, "Accept", newJString(Accept))
  add(path_28378037, "repo", newJString(repo))
  add(path_28378037, "teamId", newJInt(teamId))
  result = call_28378036.call(path_28378037, nil, header_28378038, nil, nil)

var putTeamsTeamIdReposOwnerRepo* = Call_PutTeamsTeamIdReposOwnerRepo_28378028(
    name: "putTeamsTeamIdReposOwnerRepo", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/teams/{teamId}/repos/{owner}/{repo}",
    validator: validate_PutTeamsTeamIdReposOwnerRepo_28378029, base: "/",
    url: url_PutTeamsTeamIdReposOwnerRepo_28378030, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdReposOwnerRepo_28378017 = ref object of OpenApiRestCall_28375350
proc url_GetTeamsTeamIdReposOwnerRepo_28378019(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdReposOwnerRepo_28378018(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Check if a team manages a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28378020 = path.getOrDefault("owner")
  valid_28378020 = validateParameter(valid_28378020, JString, required = true,
                                   default = nil)
  if valid_28378020 != nil:
    section.add "owner", valid_28378020
  var valid_28378021 = path.getOrDefault("repo")
  valid_28378021 = validateParameter(valid_28378021, JString, required = true,
                                   default = nil)
  if valid_28378021 != nil:
    section.add "repo", valid_28378021
  var valid_28378022 = path.getOrDefault("teamId")
  valid_28378022 = validateParameter(valid_28378022, JInt, required = true,
                                   default = nil)
  if valid_28378022 != nil:
    section.add "teamId", valid_28378022
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378023 = header.getOrDefault("Accept")
  valid_28378023 = validateParameter(valid_28378023, JString, required = false,
                                   default = nil)
  if valid_28378023 != nil:
    section.add "Accept", valid_28378023
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378024: Call_GetTeamsTeamIdReposOwnerRepo_28378017;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Check if a team manages a repository
  ## 
  let valid = call_28378024.validator(path, query, header, formData, body)
  let scheme = call_28378024.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378024.url(scheme.get, call_28378024.host, call_28378024.base,
                           call_28378024.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378024, url, valid)

proc call*(call_28378025: Call_GetTeamsTeamIdReposOwnerRepo_28378017;
          owner: string; repo: string; teamId: int; Accept: string = ""): Recallable =
  ## getTeamsTeamIdReposOwnerRepo
  ## Check if a team manages a repository
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_28378026 = newJObject()
  var header_28378027 = newJObject()
  add(path_28378026, "owner", newJString(owner))
  add(header_28378027, "Accept", newJString(Accept))
  add(path_28378026, "repo", newJString(repo))
  add(path_28378026, "teamId", newJInt(teamId))
  result = call_28378025.call(path_28378026, nil, header_28378027, nil, nil)

var getTeamsTeamIdReposOwnerRepo* = Call_GetTeamsTeamIdReposOwnerRepo_28378017(
    name: "getTeamsTeamIdReposOwnerRepo", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/teams/{teamId}/repos/{owner}/{repo}",
    validator: validate_GetTeamsTeamIdReposOwnerRepo_28378018, base: "/",
    url: url_GetTeamsTeamIdReposOwnerRepo_28378019, schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamIdReposOwnerRepo_28378039 = ref object of OpenApiRestCall_28375350
proc url_DeleteTeamsTeamIdReposOwnerRepo_28378041(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamIdReposOwnerRepo_28378040(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## In order to remove a repository from a team, the authenticated user must be an owner of the org that the team is associated with. NOTE: This does not delete the repository, it just removes it from the team.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28378042 = path.getOrDefault("owner")
  valid_28378042 = validateParameter(valid_28378042, JString, required = true,
                                   default = nil)
  if valid_28378042 != nil:
    section.add "owner", valid_28378042
  var valid_28378043 = path.getOrDefault("repo")
  valid_28378043 = validateParameter(valid_28378043, JString, required = true,
                                   default = nil)
  if valid_28378043 != nil:
    section.add "repo", valid_28378043
  var valid_28378044 = path.getOrDefault("teamId")
  valid_28378044 = validateParameter(valid_28378044, JInt, required = true,
                                   default = nil)
  if valid_28378044 != nil:
    section.add "teamId", valid_28378044
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378045 = header.getOrDefault("Accept")
  valid_28378045 = validateParameter(valid_28378045, JString, required = false,
                                   default = nil)
  if valid_28378045 != nil:
    section.add "Accept", valid_28378045
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378046: Call_DeleteTeamsTeamIdReposOwnerRepo_28378039;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## In order to remove a repository from a team, the authenticated user must be an owner of the org that the team is associated with. NOTE: This does not delete the repository, it just removes it from the team.
  ## 
  let valid = call_28378046.validator(path, query, header, formData, body)
  let scheme = call_28378046.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378046.url(scheme.get, call_28378046.host, call_28378046.base,
                           call_28378046.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378046, url, valid)

proc call*(call_28378047: Call_DeleteTeamsTeamIdReposOwnerRepo_28378039;
          owner: string; repo: string; teamId: int; Accept: string = ""): Recallable =
  ## deleteTeamsTeamIdReposOwnerRepo
  ## In order to remove a repository from a team, the authenticated user must be an owner of the org that the team is associated with. NOTE: This does not delete the repository, it just removes it from the team.
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_28378048 = newJObject()
  var header_28378049 = newJObject()
  add(path_28378048, "owner", newJString(owner))
  add(header_28378049, "Accept", newJString(Accept))
  add(path_28378048, "repo", newJString(repo))
  add(path_28378048, "teamId", newJInt(teamId))
  result = call_28378047.call(path_28378048, nil, header_28378049, nil, nil)

var deleteTeamsTeamIdReposOwnerRepo* = Call_DeleteTeamsTeamIdReposOwnerRepo_28378039(
    name: "deleteTeamsTeamIdReposOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/teams/{teamId}/repos/{owner}/{repo}",
    validator: validate_DeleteTeamsTeamIdReposOwnerRepo_28378040, base: "/",
    url: url_DeleteTeamsTeamIdReposOwnerRepo_28378041, schemes: {Scheme.Https})
type
  Call_GetUser_28378050 = ref object of OpenApiRestCall_28375350
proc url_GetUser_28378052(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUser_28378051(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378053 = header.getOrDefault("Accept")
  valid_28378053 = validateParameter(valid_28378053, JString, required = false,
                                   default = nil)
  if valid_28378053 != nil:
    section.add "Accept", valid_28378053
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378054: Call_GetUser_28378050; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get the authenticated user.
  ## 
  let valid = call_28378054.validator(path, query, header, formData, body)
  let scheme = call_28378054.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378054.url(scheme.get, call_28378054.host, call_28378054.base,
                           call_28378054.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378054, url, valid)

proc call*(call_28378055: Call_GetUser_28378050; Accept: string = ""): Recallable =
  ## getUser
  ## Get the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_28378056 = newJObject()
  add(header_28378056, "Accept", newJString(Accept))
  result = call_28378055.call(nil, nil, header_28378056, nil, nil)

var getUser* = Call_GetUser_28378050(name: "getUser", meth: HttpMethod.HttpGet,
                                  host: "api.github.com", route: "/user",
                                  validator: validate_GetUser_28378051, base: "/",
                                  url: url_GetUser_28378052,
                                  schemes: {Scheme.Https})
type
  Call_PatchUser_28378057 = ref object of OpenApiRestCall_28375350
proc url_PatchUser_28378059(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PatchUser_28378058(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## Update the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378060 = header.getOrDefault("Accept")
  valid_28378060 = validateParameter(valid_28378060, JString, required = false,
                                   default = nil)
  if valid_28378060 != nil:
    section.add "Accept", valid_28378060
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28378062: Call_PatchUser_28378057; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Update the authenticated user.
  ## 
  let valid = call_28378062.validator(path, query, header, formData, body)
  let scheme = call_28378062.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378062.url(scheme.get, call_28378062.host, call_28378062.base,
                           call_28378062.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378062, url, valid)

proc call*(call_28378063: Call_PatchUser_28378057; body: JsonNode;
          Accept: string = ""): Recallable =
  ## patchUser
  ## Update the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_28378064 = newJObject()
  var body_28378065 = newJObject()
  add(header_28378064, "Accept", newJString(Accept))
  if body != nil:
    body_28378065 = body
  result = call_28378063.call(nil, nil, header_28378064, nil, body_28378065)

var patchUser* = Call_PatchUser_28378057(name: "patchUser",
                                      meth: HttpMethod.HttpPatch,
                                      host: "api.github.com", route: "/user",
                                      validator: validate_PatchUser_28378058,
                                      base: "/", url: url_PatchUser_28378059,
                                      schemes: {Scheme.Https})
type
  Call_PostUserEmails_28378073 = ref object of OpenApiRestCall_28375350
proc url_PostUserEmails_28378075(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostUserEmails_28378074(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Add email address(es).
  ## You can post a single email address or an array of addresses.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378076 = header.getOrDefault("Accept")
  valid_28378076 = validateParameter(valid_28378076, JString, required = false,
                                   default = nil)
  if valid_28378076 != nil:
    section.add "Accept", valid_28378076
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28378078: Call_PostUserEmails_28378073; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Add email address(es).
  ## You can post a single email address or an array of addresses.
  ## 
  ## 
  let valid = call_28378078.validator(path, query, header, formData, body)
  let scheme = call_28378078.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378078.url(scheme.get, call_28378078.host, call_28378078.base,
                           call_28378078.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378078, url, valid)

proc call*(call_28378079: Call_PostUserEmails_28378073; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postUserEmails
  ## Add email address(es).
  ## You can post a single email address or an array of addresses.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  var header_28378080 = newJObject()
  var body_28378081 = newJObject()
  add(header_28378080, "Accept", newJString(Accept))
  if body != nil:
    body_28378081 = body
  result = call_28378079.call(nil, nil, header_28378080, nil, body_28378081)

var postUserEmails* = Call_PostUserEmails_28378073(name: "postUserEmails",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/user/emails",
    validator: validate_PostUserEmails_28378074, base: "/", url: url_PostUserEmails_28378075,
    schemes: {Scheme.Https})
type
  Call_GetUserEmails_28378066 = ref object of OpenApiRestCall_28375350
proc url_GetUserEmails_28378068(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserEmails_28378067(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## List email addresses for a user.
  ## In the final version of the API, this method will return an array of hashes
  ## with extended information for each email address indicating if the address
  ## has been verified and if it's primary email address for GitHub.
  ## Until API v3 is finalized, use the application/vnd.github.v3 media type to
  ## get other response format.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378069 = header.getOrDefault("Accept")
  valid_28378069 = validateParameter(valid_28378069, JString, required = false,
                                   default = nil)
  if valid_28378069 != nil:
    section.add "Accept", valid_28378069
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378070: Call_GetUserEmails_28378066; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List email addresses for a user.
  ## In the final version of the API, this method will return an array of hashes
  ## with extended information for each email address indicating if the address
  ## has been verified and if it's primary email address for GitHub.
  ## Until API v3 is finalized, use the application/vnd.github.v3 media type to
  ## get other response format.
  ## 
  ## 
  let valid = call_28378070.validator(path, query, header, formData, body)
  let scheme = call_28378070.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378070.url(scheme.get, call_28378070.host, call_28378070.base,
                           call_28378070.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378070, url, valid)

proc call*(call_28378071: Call_GetUserEmails_28378066; Accept: string = ""): Recallable =
  ## getUserEmails
  ## List email addresses for a user.
  ## In the final version of the API, this method will return an array of hashes
  ## with extended information for each email address indicating if the address
  ## has been verified and if it's primary email address for GitHub.
  ## Until API v3 is finalized, use the application/vnd.github.v3 media type to
  ## get other response format.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_28378072 = newJObject()
  add(header_28378072, "Accept", newJString(Accept))
  result = call_28378071.call(nil, nil, header_28378072, nil, nil)

var getUserEmails* = Call_GetUserEmails_28378066(name: "getUserEmails",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/emails",
    validator: validate_GetUserEmails_28378067, base: "/", url: url_GetUserEmails_28378068,
    schemes: {Scheme.Https})
type
  Call_DeleteUserEmails_28378082 = ref object of OpenApiRestCall_28375350
proc url_DeleteUserEmails_28378084(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DeleteUserEmails_28378083(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Delete email address(es).
  ## You can include a single email address or an array of addresses.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378085 = header.getOrDefault("Accept")
  valid_28378085 = validateParameter(valid_28378085, JString, required = false,
                                   default = nil)
  if valid_28378085 != nil:
    section.add "Accept", valid_28378085
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28378087: Call_DeleteUserEmails_28378082; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete email address(es).
  ## You can include a single email address or an array of addresses.
  ## 
  ## 
  let valid = call_28378087.validator(path, query, header, formData, body)
  let scheme = call_28378087.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378087.url(scheme.get, call_28378087.host, call_28378087.base,
                           call_28378087.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378087, url, valid)

proc call*(call_28378088: Call_DeleteUserEmails_28378082; body: JsonNode;
          Accept: string = ""): Recallable =
  ## deleteUserEmails
  ## Delete email address(es).
  ## You can include a single email address or an array of addresses.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  var header_28378089 = newJObject()
  var body_28378090 = newJObject()
  add(header_28378089, "Accept", newJString(Accept))
  if body != nil:
    body_28378090 = body
  result = call_28378088.call(nil, nil, header_28378089, nil, body_28378090)

var deleteUserEmails* = Call_DeleteUserEmails_28378082(name: "deleteUserEmails",
    meth: HttpMethod.HttpDelete, host: "api.github.com", route: "/user/emails",
    validator: validate_DeleteUserEmails_28378083, base: "/",
    url: url_DeleteUserEmails_28378084, schemes: {Scheme.Https})
type
  Call_GetUserFollowers_28378091 = ref object of OpenApiRestCall_28375350
proc url_GetUserFollowers_28378093(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserFollowers_28378092(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## List the authenticated user's followers
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378094 = header.getOrDefault("Accept")
  valid_28378094 = validateParameter(valid_28378094, JString, required = false,
                                   default = nil)
  if valid_28378094 != nil:
    section.add "Accept", valid_28378094
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378095: Call_GetUserFollowers_28378091; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the authenticated user's followers
  ## 
  let valid = call_28378095.validator(path, query, header, formData, body)
  let scheme = call_28378095.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378095.url(scheme.get, call_28378095.host, call_28378095.base,
                           call_28378095.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378095, url, valid)

proc call*(call_28378096: Call_GetUserFollowers_28378091; Accept: string = ""): Recallable =
  ## getUserFollowers
  ## List the authenticated user's followers
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_28378097 = newJObject()
  add(header_28378097, "Accept", newJString(Accept))
  result = call_28378096.call(nil, nil, header_28378097, nil, nil)

var getUserFollowers* = Call_GetUserFollowers_28378091(name: "getUserFollowers",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/followers",
    validator: validate_GetUserFollowers_28378092, base: "/",
    url: url_GetUserFollowers_28378093, schemes: {Scheme.Https})
type
  Call_GetUserFollowing_28378098 = ref object of OpenApiRestCall_28375350
proc url_GetUserFollowing_28378100(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserFollowing_28378099(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## List who the authenticated user is following.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378101 = header.getOrDefault("Accept")
  valid_28378101 = validateParameter(valid_28378101, JString, required = false,
                                   default = nil)
  if valid_28378101 != nil:
    section.add "Accept", valid_28378101
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378102: Call_GetUserFollowing_28378098; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List who the authenticated user is following.
  ## 
  let valid = call_28378102.validator(path, query, header, formData, body)
  let scheme = call_28378102.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378102.url(scheme.get, call_28378102.host, call_28378102.base,
                           call_28378102.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378102, url, valid)

proc call*(call_28378103: Call_GetUserFollowing_28378098; Accept: string = ""): Recallable =
  ## getUserFollowing
  ## List who the authenticated user is following.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_28378104 = newJObject()
  add(header_28378104, "Accept", newJString(Accept))
  result = call_28378103.call(nil, nil, header_28378104, nil, nil)

var getUserFollowing* = Call_GetUserFollowing_28378098(name: "getUserFollowing",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/following",
    validator: validate_GetUserFollowing_28378099, base: "/",
    url: url_GetUserFollowing_28378100, schemes: {Scheme.Https})
type
  Call_PutUserFollowingUsername_28378114 = ref object of OpenApiRestCall_28375350
proc url_PutUserFollowingUsername_28378116(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/following/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutUserFollowingUsername_28378115(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Follow a user.
  ## Following a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_28378117 = path.getOrDefault("username")
  valid_28378117 = validateParameter(valid_28378117, JString, required = true,
                                   default = nil)
  if valid_28378117 != nil:
    section.add "username", valid_28378117
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378118 = header.getOrDefault("Accept")
  valid_28378118 = validateParameter(valid_28378118, JString, required = false,
                                   default = nil)
  if valid_28378118 != nil:
    section.add "Accept", valid_28378118
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378119: Call_PutUserFollowingUsername_28378114; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Follow a user.
  ## Following a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  let valid = call_28378119.validator(path, query, header, formData, body)
  let scheme = call_28378119.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378119.url(scheme.get, call_28378119.host, call_28378119.base,
                           call_28378119.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378119, url, valid)

proc call*(call_28378120: Call_PutUserFollowingUsername_28378114; username: string;
          Accept: string = ""): Recallable =
  ## putUserFollowingUsername
  ## Follow a user.
  ## Following a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_28378121 = newJObject()
  var header_28378122 = newJObject()
  add(path_28378121, "username", newJString(username))
  add(header_28378122, "Accept", newJString(Accept))
  result = call_28378120.call(path_28378121, nil, header_28378122, nil, nil)

var putUserFollowingUsername* = Call_PutUserFollowingUsername_28378114(
    name: "putUserFollowingUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/user/following/{username}",
    validator: validate_PutUserFollowingUsername_28378115, base: "/",
    url: url_PutUserFollowingUsername_28378116, schemes: {Scheme.Https})
type
  Call_GetUserFollowingUsername_28378105 = ref object of OpenApiRestCall_28375350
proc url_GetUserFollowingUsername_28378107(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/following/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserFollowingUsername_28378106(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Check if you are following a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_28378108 = path.getOrDefault("username")
  valid_28378108 = validateParameter(valid_28378108, JString, required = true,
                                   default = nil)
  if valid_28378108 != nil:
    section.add "username", valid_28378108
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378109 = header.getOrDefault("Accept")
  valid_28378109 = validateParameter(valid_28378109, JString, required = false,
                                   default = nil)
  if valid_28378109 != nil:
    section.add "Accept", valid_28378109
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378110: Call_GetUserFollowingUsername_28378105; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Check if you are following a user.
  ## 
  let valid = call_28378110.validator(path, query, header, formData, body)
  let scheme = call_28378110.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378110.url(scheme.get, call_28378110.host, call_28378110.base,
                           call_28378110.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378110, url, valid)

proc call*(call_28378111: Call_GetUserFollowingUsername_28378105; username: string;
          Accept: string = ""): Recallable =
  ## getUserFollowingUsername
  ## Check if you are following a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_28378112 = newJObject()
  var header_28378113 = newJObject()
  add(path_28378112, "username", newJString(username))
  add(header_28378113, "Accept", newJString(Accept))
  result = call_28378111.call(path_28378112, nil, header_28378113, nil, nil)

var getUserFollowingUsername* = Call_GetUserFollowingUsername_28378105(
    name: "getUserFollowingUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/user/following/{username}",
    validator: validate_GetUserFollowingUsername_28378106, base: "/",
    url: url_GetUserFollowingUsername_28378107, schemes: {Scheme.Https})
type
  Call_DeleteUserFollowingUsername_28378123 = ref object of OpenApiRestCall_28375350
proc url_DeleteUserFollowingUsername_28378125(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/following/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserFollowingUsername_28378124(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Unfollow a user.
  ## Unfollowing a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_28378126 = path.getOrDefault("username")
  valid_28378126 = validateParameter(valid_28378126, JString, required = true,
                                   default = nil)
  if valid_28378126 != nil:
    section.add "username", valid_28378126
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378127 = header.getOrDefault("Accept")
  valid_28378127 = validateParameter(valid_28378127, JString, required = false,
                                   default = nil)
  if valid_28378127 != nil:
    section.add "Accept", valid_28378127
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378128: Call_DeleteUserFollowingUsername_28378123;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Unfollow a user.
  ## Unfollowing a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  let valid = call_28378128.validator(path, query, header, formData, body)
  let scheme = call_28378128.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378128.url(scheme.get, call_28378128.host, call_28378128.base,
                           call_28378128.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378128, url, valid)

proc call*(call_28378129: Call_DeleteUserFollowingUsername_28378123;
          username: string; Accept: string = ""): Recallable =
  ## deleteUserFollowingUsername
  ## Unfollow a user.
  ## Unfollowing a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_28378130 = newJObject()
  var header_28378131 = newJObject()
  add(path_28378130, "username", newJString(username))
  add(header_28378131, "Accept", newJString(Accept))
  result = call_28378129.call(path_28378130, nil, header_28378131, nil, nil)

var deleteUserFollowingUsername* = Call_DeleteUserFollowingUsername_28378123(
    name: "deleteUserFollowingUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/following/{username}",
    validator: validate_DeleteUserFollowingUsername_28378124, base: "/",
    url: url_DeleteUserFollowingUsername_28378125, schemes: {Scheme.Https})
type
  Call_GetUserIssues_28378132 = ref object of OpenApiRestCall_28375350
proc url_GetUserIssues_28378134(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserIssues_28378133(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## List issues.
  ## List all issues across owned and member repositories for the authenticated
  ## user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString (required)
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: JString (required)
  ##   direction: JString (required)
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_28378135 = query.getOrDefault("state")
  valid_28378135 = validateParameter(valid_28378135, JString, required = true,
                                   default = newJString("open"))
  if valid_28378135 != nil:
    section.add "state", valid_28378135
  var valid_28378136 = query.getOrDefault("labels")
  valid_28378136 = validateParameter(valid_28378136, JString, required = true,
                                   default = nil)
  if valid_28378136 != nil:
    section.add "labels", valid_28378136
  var valid_28378137 = query.getOrDefault("sort")
  valid_28378137 = validateParameter(valid_28378137, JString, required = true,
                                   default = newJString("created"))
  if valid_28378137 != nil:
    section.add "sort", valid_28378137
  var valid_28378138 = query.getOrDefault("direction")
  valid_28378138 = validateParameter(valid_28378138, JString, required = true,
                                   default = newJString("desc"))
  if valid_28378138 != nil:
    section.add "direction", valid_28378138
  var valid_28378139 = query.getOrDefault("filter")
  valid_28378139 = validateParameter(valid_28378139, JString, required = true,
                                   default = newJString("all"))
  if valid_28378139 != nil:
    section.add "filter", valid_28378139
  var valid_28378140 = query.getOrDefault("since")
  valid_28378140 = validateParameter(valid_28378140, JString, required = false,
                                   default = nil)
  if valid_28378140 != nil:
    section.add "since", valid_28378140
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378141 = header.getOrDefault("Accept")
  valid_28378141 = validateParameter(valid_28378141, JString, required = false,
                                   default = nil)
  if valid_28378141 != nil:
    section.add "Accept", valid_28378141
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378142: Call_GetUserIssues_28378132; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List issues.
  ## List all issues across owned and member repositories for the authenticated
  ## user.
  ## 
  ## 
  let valid = call_28378142.validator(path, query, header, formData, body)
  let scheme = call_28378142.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378142.url(scheme.get, call_28378142.host, call_28378142.base,
                           call_28378142.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378142, url, valid)

proc call*(call_28378143: Call_GetUserIssues_28378132; labels: string;
          state: string = "open"; Accept: string = ""; sort: string = "created";
          direction: string = "desc"; filter: string = "all"; since: string = ""): Recallable =
  ## getUserIssues
  ## List issues.
  ## List all issues across owned and member repositories for the authenticated
  ## user.
  ## 
  ##   state: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: string (required)
  ##   direction: string (required)
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  var query_28378144 = newJObject()
  var header_28378145 = newJObject()
  add(query_28378144, "state", newJString(state))
  add(header_28378145, "Accept", newJString(Accept))
  add(query_28378144, "labels", newJString(labels))
  add(query_28378144, "sort", newJString(sort))
  add(query_28378144, "direction", newJString(direction))
  add(query_28378144, "filter", newJString(filter))
  add(query_28378144, "since", newJString(since))
  result = call_28378143.call(nil, query_28378144, header_28378145, nil, nil)

var getUserIssues* = Call_GetUserIssues_28378132(name: "getUserIssues",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/issues",
    validator: validate_GetUserIssues_28378133, base: "/", url: url_GetUserIssues_28378134,
    schemes: {Scheme.Https})
type
  Call_PostUserKeys_28378153 = ref object of OpenApiRestCall_28375350
proc url_PostUserKeys_28378155(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostUserKeys_28378154(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Create a public key.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378156 = header.getOrDefault("Accept")
  valid_28378156 = validateParameter(valid_28378156, JString, required = false,
                                   default = nil)
  if valid_28378156 != nil:
    section.add "Accept", valid_28378156
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28378158: Call_PostUserKeys_28378153; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a public key.
  ## 
  let valid = call_28378158.validator(path, query, header, formData, body)
  let scheme = call_28378158.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378158.url(scheme.get, call_28378158.host, call_28378158.base,
                           call_28378158.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378158, url, valid)

proc call*(call_28378159: Call_PostUserKeys_28378153; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postUserKeys
  ## Create a public key.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_28378160 = newJObject()
  var body_28378161 = newJObject()
  add(header_28378160, "Accept", newJString(Accept))
  if body != nil:
    body_28378161 = body
  result = call_28378159.call(nil, nil, header_28378160, nil, body_28378161)

var postUserKeys* = Call_PostUserKeys_28378153(name: "postUserKeys",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/user/keys",
    validator: validate_PostUserKeys_28378154, base: "/", url: url_PostUserKeys_28378155,
    schemes: {Scheme.Https})
type
  Call_GetUserKeys_28378146 = ref object of OpenApiRestCall_28375350
proc url_GetUserKeys_28378148(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserKeys_28378147(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## List your public keys.
  ## Lists the current user's keys. Management of public keys via the API requires
  ## that you are authenticated through basic auth, or OAuth with the 'user', 'write:public_key' scopes.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378149 = header.getOrDefault("Accept")
  valid_28378149 = validateParameter(valid_28378149, JString, required = false,
                                   default = nil)
  if valid_28378149 != nil:
    section.add "Accept", valid_28378149
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378150: Call_GetUserKeys_28378146; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List your public keys.
  ## Lists the current user's keys. Management of public keys via the API requires
  ## that you are authenticated through basic auth, or OAuth with the 'user', 'write:public_key' scopes.
  ## 
  ## 
  let valid = call_28378150.validator(path, query, header, formData, body)
  let scheme = call_28378150.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378150.url(scheme.get, call_28378150.host, call_28378150.base,
                           call_28378150.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378150, url, valid)

proc call*(call_28378151: Call_GetUserKeys_28378146; Accept: string = ""): Recallable =
  ## getUserKeys
  ## List your public keys.
  ## Lists the current user's keys. Management of public keys via the API requires
  ## that you are authenticated through basic auth, or OAuth with the 'user', 'write:public_key' scopes.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_28378152 = newJObject()
  add(header_28378152, "Accept", newJString(Accept))
  result = call_28378151.call(nil, nil, header_28378152, nil, nil)

var getUserKeys* = Call_GetUserKeys_28378146(name: "getUserKeys",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/keys",
    validator: validate_GetUserKeys_28378147, base: "/", url: url_GetUserKeys_28378148,
    schemes: {Scheme.Https})
type
  Call_GetUserKeysKeyId_28378162 = ref object of OpenApiRestCall_28375350
proc url_GetUserKeysKeyId_28378164(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/keys/"),
               (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserKeysKeyId_28378163(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Get a single public key.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyId: JInt (required)
  ##        : ID of key.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyId` field"
  var valid_28378165 = path.getOrDefault("keyId")
  valid_28378165 = validateParameter(valid_28378165, JInt, required = true,
                                   default = nil)
  if valid_28378165 != nil:
    section.add "keyId", valid_28378165
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378166 = header.getOrDefault("Accept")
  valid_28378166 = validateParameter(valid_28378166, JString, required = false,
                                   default = nil)
  if valid_28378166 != nil:
    section.add "Accept", valid_28378166
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378167: Call_GetUserKeysKeyId_28378162; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a single public key.
  ## 
  let valid = call_28378167.validator(path, query, header, formData, body)
  let scheme = call_28378167.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378167.url(scheme.get, call_28378167.host, call_28378167.base,
                           call_28378167.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378167, url, valid)

proc call*(call_28378168: Call_GetUserKeysKeyId_28378162; keyId: int;
          Accept: string = ""): Recallable =
  ## getUserKeysKeyId
  ## Get a single public key.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   keyId: int (required)
  ##        : ID of key.
  var path_28378169 = newJObject()
  var header_28378170 = newJObject()
  add(header_28378170, "Accept", newJString(Accept))
  add(path_28378169, "keyId", newJInt(keyId))
  result = call_28378168.call(path_28378169, nil, header_28378170, nil, nil)

var getUserKeysKeyId* = Call_GetUserKeysKeyId_28378162(name: "getUserKeysKeyId",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/keys/{keyId}",
    validator: validate_GetUserKeysKeyId_28378163, base: "/",
    url: url_GetUserKeysKeyId_28378164, schemes: {Scheme.Https})
type
  Call_DeleteUserKeysKeyId_28378171 = ref object of OpenApiRestCall_28375350
proc url_DeleteUserKeysKeyId_28378173(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/keys/"),
               (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserKeysKeyId_28378172(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a public key. Removes a public key. Requires that you are authenticated via Basic Auth or via OAuth with at least admin:public_key scope.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyId: JInt (required)
  ##        : ID of key.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyId` field"
  var valid_28378174 = path.getOrDefault("keyId")
  valid_28378174 = validateParameter(valid_28378174, JInt, required = true,
                                   default = nil)
  if valid_28378174 != nil:
    section.add "keyId", valid_28378174
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378175 = header.getOrDefault("Accept")
  valid_28378175 = validateParameter(valid_28378175, JString, required = false,
                                   default = nil)
  if valid_28378175 != nil:
    section.add "Accept", valid_28378175
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378176: Call_DeleteUserKeysKeyId_28378171; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete a public key. Removes a public key. Requires that you are authenticated via Basic Auth or via OAuth with at least admin:public_key scope.
  ## 
  let valid = call_28378176.validator(path, query, header, formData, body)
  let scheme = call_28378176.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378176.url(scheme.get, call_28378176.host, call_28378176.base,
                           call_28378176.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378176, url, valid)

proc call*(call_28378177: Call_DeleteUserKeysKeyId_28378171; keyId: int;
          Accept: string = ""): Recallable =
  ## deleteUserKeysKeyId
  ## Delete a public key. Removes a public key. Requires that you are authenticated via Basic Auth or via OAuth with at least admin:public_key scope.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   keyId: int (required)
  ##        : ID of key.
  var path_28378178 = newJObject()
  var header_28378179 = newJObject()
  add(header_28378179, "Accept", newJString(Accept))
  add(path_28378178, "keyId", newJInt(keyId))
  result = call_28378177.call(path_28378178, nil, header_28378179, nil, nil)

var deleteUserKeysKeyId* = Call_DeleteUserKeysKeyId_28378171(
    name: "deleteUserKeysKeyId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/keys/{keyId}",
    validator: validate_DeleteUserKeysKeyId_28378172, base: "/",
    url: url_DeleteUserKeysKeyId_28378173, schemes: {Scheme.Https})
type
  Call_GetUserOrgs_28378180 = ref object of OpenApiRestCall_28375350
proc url_GetUserOrgs_28378182(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserOrgs_28378181(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## List public and private organizations for the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378183 = header.getOrDefault("Accept")
  valid_28378183 = validateParameter(valid_28378183, JString, required = false,
                                   default = nil)
  if valid_28378183 != nil:
    section.add "Accept", valid_28378183
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378184: Call_GetUserOrgs_28378180; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List public and private organizations for the authenticated user.
  ## 
  let valid = call_28378184.validator(path, query, header, formData, body)
  let scheme = call_28378184.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378184.url(scheme.get, call_28378184.host, call_28378184.base,
                           call_28378184.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378184, url, valid)

proc call*(call_28378185: Call_GetUserOrgs_28378180; Accept: string = ""): Recallable =
  ## getUserOrgs
  ## List public and private organizations for the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_28378186 = newJObject()
  add(header_28378186, "Accept", newJString(Accept))
  result = call_28378185.call(nil, nil, header_28378186, nil, nil)

var getUserOrgs* = Call_GetUserOrgs_28378180(name: "getUserOrgs",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/orgs",
    validator: validate_GetUserOrgs_28378181, base: "/", url: url_GetUserOrgs_28378182,
    schemes: {Scheme.Https})
type
  Call_PostUserRepos_28378196 = ref object of OpenApiRestCall_28375350
proc url_PostUserRepos_28378198(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostUserRepos_28378197(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378199 = header.getOrDefault("Accept")
  valid_28378199 = validateParameter(valid_28378199, JString, required = false,
                                   default = nil)
  if valid_28378199 != nil:
    section.add "Accept", valid_28378199
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_28378201: Call_PostUserRepos_28378196; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  let valid = call_28378201.validator(path, query, header, formData, body)
  let scheme = call_28378201.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378201.url(scheme.get, call_28378201.host, call_28378201.base,
                           call_28378201.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378201, url, valid)

proc call*(call_28378202: Call_PostUserRepos_28378196; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postUserRepos
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_28378203 = newJObject()
  var body_28378204 = newJObject()
  add(header_28378203, "Accept", newJString(Accept))
  if body != nil:
    body_28378204 = body
  result = call_28378202.call(nil, nil, header_28378203, nil, body_28378204)

var postUserRepos* = Call_PostUserRepos_28378196(name: "postUserRepos",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/user/repos",
    validator: validate_PostUserRepos_28378197, base: "/", url: url_PostUserRepos_28378198,
    schemes: {Scheme.Https})
type
  Call_GetUserRepos_28378187 = ref object of OpenApiRestCall_28375350
proc url_GetUserRepos_28378189(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserRepos_28378188(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## List repositories for the authenticated user. Note that this does not include
  ## repositories owned by organizations which the user can access. You can lis
  ## user organizations and list organization repositories separately.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   type: JString
  section = newJObject()
  var valid_28378190 = query.getOrDefault("type")
  valid_28378190 = validateParameter(valid_28378190, JString, required = false,
                                   default = newJString("all"))
  if valid_28378190 != nil:
    section.add "type", valid_28378190
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378191 = header.getOrDefault("Accept")
  valid_28378191 = validateParameter(valid_28378191, JString, required = false,
                                   default = nil)
  if valid_28378191 != nil:
    section.add "Accept", valid_28378191
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378192: Call_GetUserRepos_28378187; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List repositories for the authenticated user. Note that this does not include
  ## repositories owned by organizations which the user can access. You can lis
  ## user organizations and list organization repositories separately.
  ## 
  ## 
  let valid = call_28378192.validator(path, query, header, formData, body)
  let scheme = call_28378192.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378192.url(scheme.get, call_28378192.host, call_28378192.base,
                           call_28378192.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378192, url, valid)

proc call*(call_28378193: Call_GetUserRepos_28378187; Accept: string = "";
          `type`: string = "all"): Recallable =
  ## getUserRepos
  ## List repositories for the authenticated user. Note that this does not include
  ## repositories owned by organizations which the user can access. You can lis
  ## user organizations and list organization repositories separately.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   type: string
  var query_28378194 = newJObject()
  var header_28378195 = newJObject()
  add(header_28378195, "Accept", newJString(Accept))
  add(query_28378194, "type", newJString(`type`))
  result = call_28378193.call(nil, query_28378194, header_28378195, nil, nil)

var getUserRepos* = Call_GetUserRepos_28378187(name: "getUserRepos",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/repos",
    validator: validate_GetUserRepos_28378188, base: "/", url: url_GetUserRepos_28378189,
    schemes: {Scheme.Https})
type
  Call_GetUserStarred_28378205 = ref object of OpenApiRestCall_28375350
proc url_GetUserStarred_28378207(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserStarred_28378206(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## List repositories being starred by the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  section = newJObject()
  var valid_28378208 = query.getOrDefault("sort")
  valid_28378208 = validateParameter(valid_28378208, JString, required = false,
                                   default = newJString("created"))
  if valid_28378208 != nil:
    section.add "sort", valid_28378208
  var valid_28378209 = query.getOrDefault("direction")
  valid_28378209 = validateParameter(valid_28378209, JString, required = false,
                                   default = nil)
  if valid_28378209 != nil:
    section.add "direction", valid_28378209
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378210 = header.getOrDefault("Accept")
  valid_28378210 = validateParameter(valid_28378210, JString, required = false,
                                   default = nil)
  if valid_28378210 != nil:
    section.add "Accept", valid_28378210
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378211: Call_GetUserStarred_28378205; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List repositories being starred by the authenticated user.
  ## 
  let valid = call_28378211.validator(path, query, header, formData, body)
  let scheme = call_28378211.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378211.url(scheme.get, call_28378211.host, call_28378211.base,
                           call_28378211.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378211, url, valid)

proc call*(call_28378212: Call_GetUserStarred_28378205; Accept: string = "";
          sort: string = "created"; direction: string = ""): Recallable =
  ## getUserStarred
  ## List repositories being starred by the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  var query_28378213 = newJObject()
  var header_28378214 = newJObject()
  add(header_28378214, "Accept", newJString(Accept))
  add(query_28378213, "sort", newJString(sort))
  add(query_28378213, "direction", newJString(direction))
  result = call_28378212.call(nil, query_28378213, header_28378214, nil, nil)

var getUserStarred* = Call_GetUserStarred_28378205(name: "getUserStarred",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/starred",
    validator: validate_GetUserStarred_28378206, base: "/", url: url_GetUserStarred_28378207,
    schemes: {Scheme.Https})
type
  Call_PutUserStarredOwnerRepo_28378225 = ref object of OpenApiRestCall_28375350
proc url_PutUserStarredOwnerRepo_28378227(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/starred/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutUserStarredOwnerRepo_28378226(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Star a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  ##   repo: JString (required)
  ##       : Name of a repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28378228 = path.getOrDefault("owner")
  valid_28378228 = validateParameter(valid_28378228, JString, required = true,
                                   default = nil)
  if valid_28378228 != nil:
    section.add "owner", valid_28378228
  var valid_28378229 = path.getOrDefault("repo")
  valid_28378229 = validateParameter(valid_28378229, JString, required = true,
                                   default = nil)
  if valid_28378229 != nil:
    section.add "repo", valid_28378229
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378230 = header.getOrDefault("Accept")
  valid_28378230 = validateParameter(valid_28378230, JString, required = false,
                                   default = nil)
  if valid_28378230 != nil:
    section.add "Accept", valid_28378230
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378231: Call_PutUserStarredOwnerRepo_28378225; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Star a repository.
  ## 
  let valid = call_28378231.validator(path, query, header, formData, body)
  let scheme = call_28378231.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378231.url(scheme.get, call_28378231.host, call_28378231.base,
                           call_28378231.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378231, url, valid)

proc call*(call_28378232: Call_PutUserStarredOwnerRepo_28378225; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## putUserStarredOwnerRepo
  ## Star a repository.
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  var path_28378233 = newJObject()
  var header_28378234 = newJObject()
  add(path_28378233, "owner", newJString(owner))
  add(header_28378234, "Accept", newJString(Accept))
  add(path_28378233, "repo", newJString(repo))
  result = call_28378232.call(path_28378233, nil, header_28378234, nil, nil)

var putUserStarredOwnerRepo* = Call_PutUserStarredOwnerRepo_28378225(
    name: "putUserStarredOwnerRepo", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/user/starred/{owner}/{repo}",
    validator: validate_PutUserStarredOwnerRepo_28378226, base: "/",
    url: url_PutUserStarredOwnerRepo_28378227, schemes: {Scheme.Https})
type
  Call_GetUserStarredOwnerRepo_28378215 = ref object of OpenApiRestCall_28375350
proc url_GetUserStarredOwnerRepo_28378217(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/starred/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserStarredOwnerRepo_28378216(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Check if you are starring a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  ##   repo: JString (required)
  ##       : Name of a repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28378218 = path.getOrDefault("owner")
  valid_28378218 = validateParameter(valid_28378218, JString, required = true,
                                   default = nil)
  if valid_28378218 != nil:
    section.add "owner", valid_28378218
  var valid_28378219 = path.getOrDefault("repo")
  valid_28378219 = validateParameter(valid_28378219, JString, required = true,
                                   default = nil)
  if valid_28378219 != nil:
    section.add "repo", valid_28378219
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378220 = header.getOrDefault("Accept")
  valid_28378220 = validateParameter(valid_28378220, JString, required = false,
                                   default = nil)
  if valid_28378220 != nil:
    section.add "Accept", valid_28378220
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378221: Call_GetUserStarredOwnerRepo_28378215; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Check if you are starring a repository.
  ## 
  let valid = call_28378221.validator(path, query, header, formData, body)
  let scheme = call_28378221.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378221.url(scheme.get, call_28378221.host, call_28378221.base,
                           call_28378221.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378221, url, valid)

proc call*(call_28378222: Call_GetUserStarredOwnerRepo_28378215; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getUserStarredOwnerRepo
  ## Check if you are starring a repository.
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  var path_28378223 = newJObject()
  var header_28378224 = newJObject()
  add(path_28378223, "owner", newJString(owner))
  add(header_28378224, "Accept", newJString(Accept))
  add(path_28378223, "repo", newJString(repo))
  result = call_28378222.call(path_28378223, nil, header_28378224, nil, nil)

var getUserStarredOwnerRepo* = Call_GetUserStarredOwnerRepo_28378215(
    name: "getUserStarredOwnerRepo", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/user/starred/{owner}/{repo}",
    validator: validate_GetUserStarredOwnerRepo_28378216, base: "/",
    url: url_GetUserStarredOwnerRepo_28378217, schemes: {Scheme.Https})
type
  Call_DeleteUserStarredOwnerRepo_28378235 = ref object of OpenApiRestCall_28375350
proc url_DeleteUserStarredOwnerRepo_28378237(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/starred/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserStarredOwnerRepo_28378236(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Unstar a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  ##   repo: JString (required)
  ##       : Name of a repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28378238 = path.getOrDefault("owner")
  valid_28378238 = validateParameter(valid_28378238, JString, required = true,
                                   default = nil)
  if valid_28378238 != nil:
    section.add "owner", valid_28378238
  var valid_28378239 = path.getOrDefault("repo")
  valid_28378239 = validateParameter(valid_28378239, JString, required = true,
                                   default = nil)
  if valid_28378239 != nil:
    section.add "repo", valid_28378239
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378240 = header.getOrDefault("Accept")
  valid_28378240 = validateParameter(valid_28378240, JString, required = false,
                                   default = nil)
  if valid_28378240 != nil:
    section.add "Accept", valid_28378240
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378241: Call_DeleteUserStarredOwnerRepo_28378235; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Unstar a repository
  ## 
  let valid = call_28378241.validator(path, query, header, formData, body)
  let scheme = call_28378241.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378241.url(scheme.get, call_28378241.host, call_28378241.base,
                           call_28378241.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378241, url, valid)

proc call*(call_28378242: Call_DeleteUserStarredOwnerRepo_28378235; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## deleteUserStarredOwnerRepo
  ## Unstar a repository
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  var path_28378243 = newJObject()
  var header_28378244 = newJObject()
  add(path_28378243, "owner", newJString(owner))
  add(header_28378244, "Accept", newJString(Accept))
  add(path_28378243, "repo", newJString(repo))
  result = call_28378242.call(path_28378243, nil, header_28378244, nil, nil)

var deleteUserStarredOwnerRepo* = Call_DeleteUserStarredOwnerRepo_28378235(
    name: "deleteUserStarredOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/starred/{owner}/{repo}",
    validator: validate_DeleteUserStarredOwnerRepo_28378236, base: "/",
    url: url_DeleteUserStarredOwnerRepo_28378237, schemes: {Scheme.Https})
type
  Call_GetUserSubscriptions_28378245 = ref object of OpenApiRestCall_28375350
proc url_GetUserSubscriptions_28378247(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserSubscriptions_28378246(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List repositories being watched by the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378248 = header.getOrDefault("Accept")
  valid_28378248 = validateParameter(valid_28378248, JString, required = false,
                                   default = nil)
  if valid_28378248 != nil:
    section.add "Accept", valid_28378248
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378249: Call_GetUserSubscriptions_28378245; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List repositories being watched by the authenticated user.
  ## 
  let valid = call_28378249.validator(path, query, header, formData, body)
  let scheme = call_28378249.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378249.url(scheme.get, call_28378249.host, call_28378249.base,
                           call_28378249.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378249, url, valid)

proc call*(call_28378250: Call_GetUserSubscriptions_28378245; Accept: string = ""): Recallable =
  ## getUserSubscriptions
  ## List repositories being watched by the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_28378251 = newJObject()
  add(header_28378251, "Accept", newJString(Accept))
  result = call_28378250.call(nil, nil, header_28378251, nil, nil)

var getUserSubscriptions* = Call_GetUserSubscriptions_28378245(
    name: "getUserSubscriptions", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/user/subscriptions", validator: validate_GetUserSubscriptions_28378246,
    base: "/", url: url_GetUserSubscriptions_28378247, schemes: {Scheme.Https})
type
  Call_PutUserSubscriptionsOwnerRepo_28378262 = ref object of OpenApiRestCall_28375350
proc url_PutUserSubscriptionsOwnerRepo_28378264(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/subscriptions/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutUserSubscriptionsOwnerRepo_28378263(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Watch a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of the owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28378265 = path.getOrDefault("owner")
  valid_28378265 = validateParameter(valid_28378265, JString, required = true,
                                   default = nil)
  if valid_28378265 != nil:
    section.add "owner", valid_28378265
  var valid_28378266 = path.getOrDefault("repo")
  valid_28378266 = validateParameter(valid_28378266, JString, required = true,
                                   default = nil)
  if valid_28378266 != nil:
    section.add "repo", valid_28378266
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378267 = header.getOrDefault("Accept")
  valid_28378267 = validateParameter(valid_28378267, JString, required = false,
                                   default = nil)
  if valid_28378267 != nil:
    section.add "Accept", valid_28378267
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378268: Call_PutUserSubscriptionsOwnerRepo_28378262;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Watch a repository.
  ## 
  let valid = call_28378268.validator(path, query, header, formData, body)
  let scheme = call_28378268.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378268.url(scheme.get, call_28378268.host, call_28378268.base,
                           call_28378268.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378268, url, valid)

proc call*(call_28378269: Call_PutUserSubscriptionsOwnerRepo_28378262;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## putUserSubscriptionsOwnerRepo
  ## Watch a repository.
  ##   owner: string (required)
  ##        : Name of the owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28378270 = newJObject()
  var header_28378271 = newJObject()
  add(path_28378270, "owner", newJString(owner))
  add(header_28378271, "Accept", newJString(Accept))
  add(path_28378270, "repo", newJString(repo))
  result = call_28378269.call(path_28378270, nil, header_28378271, nil, nil)

var putUserSubscriptionsOwnerRepo* = Call_PutUserSubscriptionsOwnerRepo_28378262(
    name: "putUserSubscriptionsOwnerRepo", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/user/subscriptions/{owner}/{repo}",
    validator: validate_PutUserSubscriptionsOwnerRepo_28378263, base: "/",
    url: url_PutUserSubscriptionsOwnerRepo_28378264, schemes: {Scheme.Https})
type
  Call_GetUserSubscriptionsOwnerRepo_28378252 = ref object of OpenApiRestCall_28375350
proc url_GetUserSubscriptionsOwnerRepo_28378254(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/subscriptions/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserSubscriptionsOwnerRepo_28378253(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Check if you are watching a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of the owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28378255 = path.getOrDefault("owner")
  valid_28378255 = validateParameter(valid_28378255, JString, required = true,
                                   default = nil)
  if valid_28378255 != nil:
    section.add "owner", valid_28378255
  var valid_28378256 = path.getOrDefault("repo")
  valid_28378256 = validateParameter(valid_28378256, JString, required = true,
                                   default = nil)
  if valid_28378256 != nil:
    section.add "repo", valid_28378256
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378257 = header.getOrDefault("Accept")
  valid_28378257 = validateParameter(valid_28378257, JString, required = false,
                                   default = nil)
  if valid_28378257 != nil:
    section.add "Accept", valid_28378257
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378258: Call_GetUserSubscriptionsOwnerRepo_28378252;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Check if you are watching a repository.
  ## 
  let valid = call_28378258.validator(path, query, header, formData, body)
  let scheme = call_28378258.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378258.url(scheme.get, call_28378258.host, call_28378258.base,
                           call_28378258.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378258, url, valid)

proc call*(call_28378259: Call_GetUserSubscriptionsOwnerRepo_28378252;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getUserSubscriptionsOwnerRepo
  ## Check if you are watching a repository.
  ##   owner: string (required)
  ##        : Name of the owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28378260 = newJObject()
  var header_28378261 = newJObject()
  add(path_28378260, "owner", newJString(owner))
  add(header_28378261, "Accept", newJString(Accept))
  add(path_28378260, "repo", newJString(repo))
  result = call_28378259.call(path_28378260, nil, header_28378261, nil, nil)

var getUserSubscriptionsOwnerRepo* = Call_GetUserSubscriptionsOwnerRepo_28378252(
    name: "getUserSubscriptionsOwnerRepo", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/user/subscriptions/{owner}/{repo}",
    validator: validate_GetUserSubscriptionsOwnerRepo_28378253, base: "/",
    url: url_GetUserSubscriptionsOwnerRepo_28378254, schemes: {Scheme.Https})
type
  Call_DeleteUserSubscriptionsOwnerRepo_28378272 = ref object of OpenApiRestCall_28375350
proc url_DeleteUserSubscriptionsOwnerRepo_28378274(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/subscriptions/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserSubscriptionsOwnerRepo_28378273(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Stop watching a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of the owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_28378275 = path.getOrDefault("owner")
  valid_28378275 = validateParameter(valid_28378275, JString, required = true,
                                   default = nil)
  if valid_28378275 != nil:
    section.add "owner", valid_28378275
  var valid_28378276 = path.getOrDefault("repo")
  valid_28378276 = validateParameter(valid_28378276, JString, required = true,
                                   default = nil)
  if valid_28378276 != nil:
    section.add "repo", valid_28378276
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378277 = header.getOrDefault("Accept")
  valid_28378277 = validateParameter(valid_28378277, JString, required = false,
                                   default = nil)
  if valid_28378277 != nil:
    section.add "Accept", valid_28378277
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378278: Call_DeleteUserSubscriptionsOwnerRepo_28378272;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Stop watching a repository
  ## 
  let valid = call_28378278.validator(path, query, header, formData, body)
  let scheme = call_28378278.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378278.url(scheme.get, call_28378278.host, call_28378278.base,
                           call_28378278.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378278, url, valid)

proc call*(call_28378279: Call_DeleteUserSubscriptionsOwnerRepo_28378272;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## deleteUserSubscriptionsOwnerRepo
  ## Stop watching a repository
  ##   owner: string (required)
  ##        : Name of the owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_28378280 = newJObject()
  var header_28378281 = newJObject()
  add(path_28378280, "owner", newJString(owner))
  add(header_28378281, "Accept", newJString(Accept))
  add(path_28378280, "repo", newJString(repo))
  result = call_28378279.call(path_28378280, nil, header_28378281, nil, nil)

var deleteUserSubscriptionsOwnerRepo* = Call_DeleteUserSubscriptionsOwnerRepo_28378272(
    name: "deleteUserSubscriptionsOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/subscriptions/{owner}/{repo}",
    validator: validate_DeleteUserSubscriptionsOwnerRepo_28378273, base: "/",
    url: url_DeleteUserSubscriptionsOwnerRepo_28378274, schemes: {Scheme.Https})
type
  Call_GetUserTeams_28378282 = ref object of OpenApiRestCall_28375350
proc url_GetUserTeams_28378284(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserTeams_28378283(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## List all of the teams across all of the organizations to which the authenticated user belongs. This method requires user or repo scope when authenticating via OAuth.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378285 = header.getOrDefault("Accept")
  valid_28378285 = validateParameter(valid_28378285, JString, required = false,
                                   default = nil)
  if valid_28378285 != nil:
    section.add "Accept", valid_28378285
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378286: Call_GetUserTeams_28378282; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List all of the teams across all of the organizations to which the authenticated user belongs. This method requires user or repo scope when authenticating via OAuth.
  ## 
  let valid = call_28378286.validator(path, query, header, formData, body)
  let scheme = call_28378286.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378286.url(scheme.get, call_28378286.host, call_28378286.base,
                           call_28378286.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378286, url, valid)

proc call*(call_28378287: Call_GetUserTeams_28378282; Accept: string = ""): Recallable =
  ## getUserTeams
  ## List all of the teams across all of the organizations to which the authenticated user belongs. This method requires user or repo scope when authenticating via OAuth.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_28378288 = newJObject()
  add(header_28378288, "Accept", newJString(Accept))
  result = call_28378287.call(nil, nil, header_28378288, nil, nil)

var getUserTeams* = Call_GetUserTeams_28378282(name: "getUserTeams",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/teams",
    validator: validate_GetUserTeams_28378283, base: "/", url: url_GetUserTeams_28378284,
    schemes: {Scheme.Https})
type
  Call_GetUsers_28378289 = ref object of OpenApiRestCall_28375350
proc url_GetUsers_28378291(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUsers_28378290(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## Get all users.
  ## This provides a dump of every user, in the order that they signed up for GitHub.
  ## Note: Pagination is powered exclusively by the since parameter. Use the Link
  ## header to get the URL for the next page of users.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JInt
  ##        : The integer ID of the last user that you've seen.
  section = newJObject()
  var valid_28378292 = query.getOrDefault("since")
  valid_28378292 = validateParameter(valid_28378292, JInt, required = false,
                                   default = nil)
  if valid_28378292 != nil:
    section.add "since", valid_28378292
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378293 = header.getOrDefault("Accept")
  valid_28378293 = validateParameter(valid_28378293, JString, required = false,
                                   default = nil)
  if valid_28378293 != nil:
    section.add "Accept", valid_28378293
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378294: Call_GetUsers_28378289; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get all users.
  ## This provides a dump of every user, in the order that they signed up for GitHub.
  ## Note: Pagination is powered exclusively by the since parameter. Use the Link
  ## header to get the URL for the next page of users.
  ## 
  ## 
  let valid = call_28378294.validator(path, query, header, formData, body)
  let scheme = call_28378294.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378294.url(scheme.get, call_28378294.host, call_28378294.base,
                           call_28378294.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378294, url, valid)

proc call*(call_28378295: Call_GetUsers_28378289; Accept: string = ""; since: int = 0): Recallable =
  ## getUsers
  ## Get all users.
  ## This provides a dump of every user, in the order that they signed up for GitHub.
  ## Note: Pagination is powered exclusively by the since parameter. Use the Link
  ## header to get the URL for the next page of users.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: int
  ##        : The integer ID of the last user that you've seen.
  var query_28378296 = newJObject()
  var header_28378297 = newJObject()
  add(header_28378297, "Accept", newJString(Accept))
  add(query_28378296, "since", newJInt(since))
  result = call_28378295.call(nil, query_28378296, header_28378297, nil, nil)

var getUsers* = Call_GetUsers_28378289(name: "getUsers", meth: HttpMethod.HttpGet,
                                    host: "api.github.com", route: "/users",
                                    validator: validate_GetUsers_28378290,
                                    base: "/", url: url_GetUsers_28378291,
                                    schemes: {Scheme.Https})
type
  Call_GetUsersUsername_28378298 = ref object of OpenApiRestCall_28375350
proc url_GetUsersUsername_28378300(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsername_28378299(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Get a single user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_28378301 = path.getOrDefault("username")
  valid_28378301 = validateParameter(valid_28378301, JString, required = true,
                                   default = nil)
  if valid_28378301 != nil:
    section.add "username", valid_28378301
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378302 = header.getOrDefault("Accept")
  valid_28378302 = validateParameter(valid_28378302, JString, required = false,
                                   default = nil)
  if valid_28378302 != nil:
    section.add "Accept", valid_28378302
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378303: Call_GetUsersUsername_28378298; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a single user.
  ## 
  let valid = call_28378303.validator(path, query, header, formData, body)
  let scheme = call_28378303.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378303.url(scheme.get, call_28378303.host, call_28378303.base,
                           call_28378303.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378303, url, valid)

proc call*(call_28378304: Call_GetUsersUsername_28378298; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsername
  ## Get a single user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_28378305 = newJObject()
  var header_28378306 = newJObject()
  add(path_28378305, "username", newJString(username))
  add(header_28378306, "Accept", newJString(Accept))
  result = call_28378304.call(path_28378305, nil, header_28378306, nil, nil)

var getUsersUsername* = Call_GetUsersUsername_28378298(name: "getUsersUsername",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/users/{username}",
    validator: validate_GetUsersUsername_28378299, base: "/",
    url: url_GetUsersUsername_28378300, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameEvents_28378307 = ref object of OpenApiRestCall_28375350
proc url_GetUsersUsernameEvents_28378309(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameEvents_28378308(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_28378310 = path.getOrDefault("username")
  valid_28378310 = validateParameter(valid_28378310, JString, required = true,
                                   default = nil)
  if valid_28378310 != nil:
    section.add "username", valid_28378310
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378311 = header.getOrDefault("Accept")
  valid_28378311 = validateParameter(valid_28378311, JString, required = false,
                                   default = nil)
  if valid_28378311 != nil:
    section.add "Accept", valid_28378311
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378312: Call_GetUsersUsernameEvents_28378307; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
  ## 
  let valid = call_28378312.validator(path, query, header, formData, body)
  let scheme = call_28378312.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378312.url(scheme.get, call_28378312.host, call_28378312.base,
                           call_28378312.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378312, url, valid)

proc call*(call_28378313: Call_GetUsersUsernameEvents_28378307; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameEvents
  ## If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_28378314 = newJObject()
  var header_28378315 = newJObject()
  add(path_28378314, "username", newJString(username))
  add(header_28378315, "Accept", newJString(Accept))
  result = call_28378313.call(path_28378314, nil, header_28378315, nil, nil)

var getUsersUsernameEvents* = Call_GetUsersUsernameEvents_28378307(
    name: "getUsersUsernameEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/events",
    validator: validate_GetUsersUsernameEvents_28378308, base: "/",
    url: url_GetUsersUsernameEvents_28378309, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameEventsOrgsOrg_28378316 = ref object of OpenApiRestCall_28375350
proc url_GetUsersUsernameEventsOrgsOrg_28378318(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/events/orgs/"),
               (kind: VariableSegment, value: "org")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameEventsOrgsOrg_28378317(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This is the user's organization dashboard. You must be authenticated as the user to view this.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  ##   org: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_28378319 = path.getOrDefault("username")
  valid_28378319 = validateParameter(valid_28378319, JString, required = true,
                                   default = nil)
  if valid_28378319 != nil:
    section.add "username", valid_28378319
  var valid_28378320 = path.getOrDefault("org")
  valid_28378320 = validateParameter(valid_28378320, JString, required = true,
                                   default = nil)
  if valid_28378320 != nil:
    section.add "org", valid_28378320
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378321 = header.getOrDefault("Accept")
  valid_28378321 = validateParameter(valid_28378321, JString, required = false,
                                   default = nil)
  if valid_28378321 != nil:
    section.add "Accept", valid_28378321
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378322: Call_GetUsersUsernameEventsOrgsOrg_28378316;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## This is the user's organization dashboard. You must be authenticated as the user to view this.
  ## 
  let valid = call_28378322.validator(path, query, header, formData, body)
  let scheme = call_28378322.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378322.url(scheme.get, call_28378322.host, call_28378322.base,
                           call_28378322.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378322, url, valid)

proc call*(call_28378323: Call_GetUsersUsernameEventsOrgsOrg_28378316;
          username: string; org: string; Accept: string = ""): Recallable =
  ## getUsersUsernameEventsOrgsOrg
  ## This is the user's organization dashboard. You must be authenticated as the user to view this.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  var path_28378324 = newJObject()
  var header_28378325 = newJObject()
  add(path_28378324, "username", newJString(username))
  add(header_28378325, "Accept", newJString(Accept))
  add(path_28378324, "org", newJString(org))
  result = call_28378323.call(path_28378324, nil, header_28378325, nil, nil)

var getUsersUsernameEventsOrgsOrg* = Call_GetUsersUsernameEventsOrgsOrg_28378316(
    name: "getUsersUsernameEventsOrgsOrg", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/events/orgs/{org}",
    validator: validate_GetUsersUsernameEventsOrgsOrg_28378317, base: "/",
    url: url_GetUsersUsernameEventsOrgsOrg_28378318, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameFollowers_28378326 = ref object of OpenApiRestCall_28375350
proc url_GetUsersUsernameFollowers_28378328(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/followers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameFollowers_28378327(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List a user's followers
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_28378329 = path.getOrDefault("username")
  valid_28378329 = validateParameter(valid_28378329, JString, required = true,
                                   default = nil)
  if valid_28378329 != nil:
    section.add "username", valid_28378329
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378330 = header.getOrDefault("Accept")
  valid_28378330 = validateParameter(valid_28378330, JString, required = false,
                                   default = nil)
  if valid_28378330 != nil:
    section.add "Accept", valid_28378330
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378331: Call_GetUsersUsernameFollowers_28378326; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List a user's followers
  ## 
  let valid = call_28378331.validator(path, query, header, formData, body)
  let scheme = call_28378331.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378331.url(scheme.get, call_28378331.host, call_28378331.base,
                           call_28378331.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378331, url, valid)

proc call*(call_28378332: Call_GetUsersUsernameFollowers_28378326;
          username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameFollowers
  ## List a user's followers
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_28378333 = newJObject()
  var header_28378334 = newJObject()
  add(path_28378333, "username", newJString(username))
  add(header_28378334, "Accept", newJString(Accept))
  result = call_28378332.call(path_28378333, nil, header_28378334, nil, nil)

var getUsersUsernameFollowers* = Call_GetUsersUsernameFollowers_28378326(
    name: "getUsersUsernameFollowers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/followers",
    validator: validate_GetUsersUsernameFollowers_28378327, base: "/",
    url: url_GetUsersUsernameFollowers_28378328, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameFollowingTargetUser_28378335 = ref object of OpenApiRestCall_28375350
proc url_GetUsersUsernameFollowingTargetUser_28378337(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  assert "targetUser" in path, "`targetUser` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/following/"),
               (kind: VariableSegment, value: "targetUser")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameFollowingTargetUser_28378336(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Check if one user follows another.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  ##   targetUser: JString (required)
  ##             : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_28378338 = path.getOrDefault("username")
  valid_28378338 = validateParameter(valid_28378338, JString, required = true,
                                   default = nil)
  if valid_28378338 != nil:
    section.add "username", valid_28378338
  var valid_28378339 = path.getOrDefault("targetUser")
  valid_28378339 = validateParameter(valid_28378339, JString, required = true,
                                   default = nil)
  if valid_28378339 != nil:
    section.add "targetUser", valid_28378339
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378340 = header.getOrDefault("Accept")
  valid_28378340 = validateParameter(valid_28378340, JString, required = false,
                                   default = nil)
  if valid_28378340 != nil:
    section.add "Accept", valid_28378340
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378341: Call_GetUsersUsernameFollowingTargetUser_28378335;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Check if one user follows another.
  ## 
  let valid = call_28378341.validator(path, query, header, formData, body)
  let scheme = call_28378341.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378341.url(scheme.get, call_28378341.host, call_28378341.base,
                           call_28378341.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378341, url, valid)

proc call*(call_28378342: Call_GetUsersUsernameFollowingTargetUser_28378335;
          username: string; targetUser: string; Accept: string = ""): Recallable =
  ## getUsersUsernameFollowingTargetUser
  ## Check if one user follows another.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   targetUser: string (required)
  ##             : Name of user.
  var path_28378343 = newJObject()
  var header_28378344 = newJObject()
  add(path_28378343, "username", newJString(username))
  add(header_28378344, "Accept", newJString(Accept))
  add(path_28378343, "targetUser", newJString(targetUser))
  result = call_28378342.call(path_28378343, nil, header_28378344, nil, nil)

var getUsersUsernameFollowingTargetUser* = Call_GetUsersUsernameFollowingTargetUser_28378335(
    name: "getUsersUsernameFollowingTargetUser", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/following/{targetUser}",
    validator: validate_GetUsersUsernameFollowingTargetUser_28378336, base: "/",
    url: url_GetUsersUsernameFollowingTargetUser_28378337, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameGists_28378345 = ref object of OpenApiRestCall_28375350
proc url_GetUsersUsernameGists_28378347(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/gists")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameGists_28378346(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List a users gists.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_28378348 = path.getOrDefault("username")
  valid_28378348 = validateParameter(valid_28378348, JString, required = true,
                                   default = nil)
  if valid_28378348 != nil:
    section.add "username", valid_28378348
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_28378349 = query.getOrDefault("since")
  valid_28378349 = validateParameter(valid_28378349, JString, required = false,
                                   default = nil)
  if valid_28378349 != nil:
    section.add "since", valid_28378349
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378350 = header.getOrDefault("Accept")
  valid_28378350 = validateParameter(valid_28378350, JString, required = false,
                                   default = nil)
  if valid_28378350 != nil:
    section.add "Accept", valid_28378350
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378351: Call_GetUsersUsernameGists_28378345; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List a users gists.
  ## 
  let valid = call_28378351.validator(path, query, header, formData, body)
  let scheme = call_28378351.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378351.url(scheme.get, call_28378351.host, call_28378351.base,
                           call_28378351.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378351, url, valid)

proc call*(call_28378352: Call_GetUsersUsernameGists_28378345; username: string;
          Accept: string = ""; since: string = ""): Recallable =
  ## getUsersUsernameGists
  ## List a users gists.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var path_28378353 = newJObject()
  var query_28378354 = newJObject()
  var header_28378355 = newJObject()
  add(path_28378353, "username", newJString(username))
  add(header_28378355, "Accept", newJString(Accept))
  add(query_28378354, "since", newJString(since))
  result = call_28378352.call(path_28378353, query_28378354, header_28378355, nil, nil)

var getUsersUsernameGists* = Call_GetUsersUsernameGists_28378345(
    name: "getUsersUsernameGists", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/users/{username}/gists", validator: validate_GetUsersUsernameGists_28378346,
    base: "/", url: url_GetUsersUsernameGists_28378347, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameKeys_28378356 = ref object of OpenApiRestCall_28375350
proc url_GetUsersUsernameKeys_28378358(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/keys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameKeys_28378357(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List public keys for a user.
  ## Lists the verified public keys for a user. This is accessible by anyone.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_28378359 = path.getOrDefault("username")
  valid_28378359 = validateParameter(valid_28378359, JString, required = true,
                                   default = nil)
  if valid_28378359 != nil:
    section.add "username", valid_28378359
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378360 = header.getOrDefault("Accept")
  valid_28378360 = validateParameter(valid_28378360, JString, required = false,
                                   default = nil)
  if valid_28378360 != nil:
    section.add "Accept", valid_28378360
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378361: Call_GetUsersUsernameKeys_28378356; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List public keys for a user.
  ## Lists the verified public keys for a user. This is accessible by anyone.
  ## 
  ## 
  let valid = call_28378361.validator(path, query, header, formData, body)
  let scheme = call_28378361.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378361.url(scheme.get, call_28378361.host, call_28378361.base,
                           call_28378361.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378361, url, valid)

proc call*(call_28378362: Call_GetUsersUsernameKeys_28378356; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameKeys
  ## List public keys for a user.
  ## Lists the verified public keys for a user. This is accessible by anyone.
  ## 
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_28378363 = newJObject()
  var header_28378364 = newJObject()
  add(path_28378363, "username", newJString(username))
  add(header_28378364, "Accept", newJString(Accept))
  result = call_28378362.call(path_28378363, nil, header_28378364, nil, nil)

var getUsersUsernameKeys* = Call_GetUsersUsernameKeys_28378356(
    name: "getUsersUsernameKeys", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/users/{username}/keys", validator: validate_GetUsersUsernameKeys_28378357,
    base: "/", url: url_GetUsersUsernameKeys_28378358, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameOrgs_28378365 = ref object of OpenApiRestCall_28375350
proc url_GetUsersUsernameOrgs_28378367(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/orgs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameOrgs_28378366(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List all public organizations for a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_28378368 = path.getOrDefault("username")
  valid_28378368 = validateParameter(valid_28378368, JString, required = true,
                                   default = nil)
  if valid_28378368 != nil:
    section.add "username", valid_28378368
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378369 = header.getOrDefault("Accept")
  valid_28378369 = validateParameter(valid_28378369, JString, required = false,
                                   default = nil)
  if valid_28378369 != nil:
    section.add "Accept", valid_28378369
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378370: Call_GetUsersUsernameOrgs_28378365; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List all public organizations for a user.
  ## 
  let valid = call_28378370.validator(path, query, header, formData, body)
  let scheme = call_28378370.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378370.url(scheme.get, call_28378370.host, call_28378370.base,
                           call_28378370.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378370, url, valid)

proc call*(call_28378371: Call_GetUsersUsernameOrgs_28378365; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameOrgs
  ## List all public organizations for a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_28378372 = newJObject()
  var header_28378373 = newJObject()
  add(path_28378372, "username", newJString(username))
  add(header_28378373, "Accept", newJString(Accept))
  result = call_28378371.call(path_28378372, nil, header_28378373, nil, nil)

var getUsersUsernameOrgs* = Call_GetUsersUsernameOrgs_28378365(
    name: "getUsersUsernameOrgs", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/users/{username}/orgs", validator: validate_GetUsersUsernameOrgs_28378366,
    base: "/", url: url_GetUsersUsernameOrgs_28378367, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameReceivedEvents_28378374 = ref object of OpenApiRestCall_28375350
proc url_GetUsersUsernameReceivedEvents_28378376(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/received_events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameReceivedEvents_28378375(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## These are events that you'll only see public events.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_28378377 = path.getOrDefault("username")
  valid_28378377 = validateParameter(valid_28378377, JString, required = true,
                                   default = nil)
  if valid_28378377 != nil:
    section.add "username", valid_28378377
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378378 = header.getOrDefault("Accept")
  valid_28378378 = validateParameter(valid_28378378, JString, required = false,
                                   default = nil)
  if valid_28378378 != nil:
    section.add "Accept", valid_28378378
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378379: Call_GetUsersUsernameReceivedEvents_28378374;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## These are events that you'll only see public events.
  ## 
  let valid = call_28378379.validator(path, query, header, formData, body)
  let scheme = call_28378379.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378379.url(scheme.get, call_28378379.host, call_28378379.base,
                           call_28378379.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378379, url, valid)

proc call*(call_28378380: Call_GetUsersUsernameReceivedEvents_28378374;
          username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameReceivedEvents
  ## These are events that you'll only see public events.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_28378381 = newJObject()
  var header_28378382 = newJObject()
  add(path_28378381, "username", newJString(username))
  add(header_28378382, "Accept", newJString(Accept))
  result = call_28378380.call(path_28378381, nil, header_28378382, nil, nil)

var getUsersUsernameReceivedEvents* = Call_GetUsersUsernameReceivedEvents_28378374(
    name: "getUsersUsernameReceivedEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/received_events",
    validator: validate_GetUsersUsernameReceivedEvents_28378375, base: "/",
    url: url_GetUsersUsernameReceivedEvents_28378376, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameReceivedEventsPublic_28378383 = ref object of OpenApiRestCall_28375350
proc url_GetUsersUsernameReceivedEventsPublic_28378385(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/received_events/public")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameReceivedEventsPublic_28378384(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List public events that a user has received
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_28378386 = path.getOrDefault("username")
  valid_28378386 = validateParameter(valid_28378386, JString, required = true,
                                   default = nil)
  if valid_28378386 != nil:
    section.add "username", valid_28378386
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378387 = header.getOrDefault("Accept")
  valid_28378387 = validateParameter(valid_28378387, JString, required = false,
                                   default = nil)
  if valid_28378387 != nil:
    section.add "Accept", valid_28378387
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378388: Call_GetUsersUsernameReceivedEventsPublic_28378383;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List public events that a user has received
  ## 
  let valid = call_28378388.validator(path, query, header, formData, body)
  let scheme = call_28378388.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378388.url(scheme.get, call_28378388.host, call_28378388.base,
                           call_28378388.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378388, url, valid)

proc call*(call_28378389: Call_GetUsersUsernameReceivedEventsPublic_28378383;
          username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameReceivedEventsPublic
  ## List public events that a user has received
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_28378390 = newJObject()
  var header_28378391 = newJObject()
  add(path_28378390, "username", newJString(username))
  add(header_28378391, "Accept", newJString(Accept))
  result = call_28378389.call(path_28378390, nil, header_28378391, nil, nil)

var getUsersUsernameReceivedEventsPublic* = Call_GetUsersUsernameReceivedEventsPublic_28378383(
    name: "getUsersUsernameReceivedEventsPublic", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/received_events/public",
    validator: validate_GetUsersUsernameReceivedEventsPublic_28378384, base: "/",
    url: url_GetUsersUsernameReceivedEventsPublic_28378385,
    schemes: {Scheme.Https})
type
  Call_GetUsersUsernameRepos_28378392 = ref object of OpenApiRestCall_28375350
proc url_GetUsersUsernameRepos_28378394(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameRepos_28378393(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List public repositories for the specified user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_28378395 = path.getOrDefault("username")
  valid_28378395 = validateParameter(valid_28378395, JString, required = true,
                                   default = nil)
  if valid_28378395 != nil:
    section.add "username", valid_28378395
  result.add "path", section
  ## parameters in `query` object:
  ##   type: JString
  section = newJObject()
  var valid_28378396 = query.getOrDefault("type")
  valid_28378396 = validateParameter(valid_28378396, JString, required = false,
                                   default = newJString("all"))
  if valid_28378396 != nil:
    section.add "type", valid_28378396
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378397 = header.getOrDefault("Accept")
  valid_28378397 = validateParameter(valid_28378397, JString, required = false,
                                   default = nil)
  if valid_28378397 != nil:
    section.add "Accept", valid_28378397
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378398: Call_GetUsersUsernameRepos_28378392; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List public repositories for the specified user.
  ## 
  let valid = call_28378398.validator(path, query, header, formData, body)
  let scheme = call_28378398.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378398.url(scheme.get, call_28378398.host, call_28378398.base,
                           call_28378398.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378398, url, valid)

proc call*(call_28378399: Call_GetUsersUsernameRepos_28378392; username: string;
          Accept: string = ""; `type`: string = "all"): Recallable =
  ## getUsersUsernameRepos
  ## List public repositories for the specified user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   type: string
  var path_28378400 = newJObject()
  var query_28378401 = newJObject()
  var header_28378402 = newJObject()
  add(path_28378400, "username", newJString(username))
  add(header_28378402, "Accept", newJString(Accept))
  add(query_28378401, "type", newJString(`type`))
  result = call_28378399.call(path_28378400, query_28378401, header_28378402, nil, nil)

var getUsersUsernameRepos* = Call_GetUsersUsernameRepos_28378392(
    name: "getUsersUsernameRepos", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/users/{username}/repos", validator: validate_GetUsersUsernameRepos_28378393,
    base: "/", url: url_GetUsersUsernameRepos_28378394, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameStarred_28378403 = ref object of OpenApiRestCall_28375350
proc url_GetUsersUsernameStarred_28378405(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/starred")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameStarred_28378404(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List repositories being starred by a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_28378406 = path.getOrDefault("username")
  valid_28378406 = validateParameter(valid_28378406, JString, required = true,
                                   default = nil)
  if valid_28378406 != nil:
    section.add "username", valid_28378406
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378407 = header.getOrDefault("Accept")
  valid_28378407 = validateParameter(valid_28378407, JString, required = false,
                                   default = nil)
  if valid_28378407 != nil:
    section.add "Accept", valid_28378407
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378408: Call_GetUsersUsernameStarred_28378403; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List repositories being starred by a user.
  ## 
  let valid = call_28378408.validator(path, query, header, formData, body)
  let scheme = call_28378408.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378408.url(scheme.get, call_28378408.host, call_28378408.base,
                           call_28378408.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378408, url, valid)

proc call*(call_28378409: Call_GetUsersUsernameStarred_28378403; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameStarred
  ## List repositories being starred by a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_28378410 = newJObject()
  var header_28378411 = newJObject()
  add(path_28378410, "username", newJString(username))
  add(header_28378411, "Accept", newJString(Accept))
  result = call_28378409.call(path_28378410, nil, header_28378411, nil, nil)

var getUsersUsernameStarred* = Call_GetUsersUsernameStarred_28378403(
    name: "getUsersUsernameStarred", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/starred",
    validator: validate_GetUsersUsernameStarred_28378404, base: "/",
    url: url_GetUsersUsernameStarred_28378405, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameSubscriptions_28378412 = ref object of OpenApiRestCall_28375350
proc url_GetUsersUsernameSubscriptions_28378414(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/subscriptions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameSubscriptions_28378413(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List repositories being watched by a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_28378415 = path.getOrDefault("username")
  valid_28378415 = validateParameter(valid_28378415, JString, required = true,
                                   default = nil)
  if valid_28378415 != nil:
    section.add "username", valid_28378415
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_28378416 = header.getOrDefault("Accept")
  valid_28378416 = validateParameter(valid_28378416, JString, required = false,
                                   default = nil)
  if valid_28378416 != nil:
    section.add "Accept", valid_28378416
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_28378417: Call_GetUsersUsernameSubscriptions_28378412;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List repositories being watched by a user.
  ## 
  let valid = call_28378417.validator(path, query, header, formData, body)
  let scheme = call_28378417.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_28378417.url(scheme.get, call_28378417.host, call_28378417.base,
                           call_28378417.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_28378417, url, valid)

proc call*(call_28378418: Call_GetUsersUsernameSubscriptions_28378412;
          username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameSubscriptions
  ## List repositories being watched by a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_28378419 = newJObject()
  var header_28378420 = newJObject()
  add(path_28378419, "username", newJString(username))
  add(header_28378420, "Accept", newJString(Accept))
  result = call_28378418.call(path_28378419, nil, header_28378420, nil, nil)

var getUsersUsernameSubscriptions* = Call_GetUsersUsernameSubscriptions_28378412(
    name: "getUsersUsernameSubscriptions", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/subscriptions",
    validator: validate_GetUsersUsernameSubscriptions_28378413, base: "/",
    url: url_GetUsersUsernameSubscriptions_28378414, schemes: {Scheme.Https})
export
  rest

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.} =
  var headers = massageHeaders(input.getOrDefault("header")).newHttpHeaders
  let token = os.getEnv("GITHUB_TOKEN", "")
  if not headers.hasKey("Authorization") and token.len > 0:
    headers.add "Authorization", "token " & token
  if headers.hasKey "Accept":
    headers.del "Accept"
  headers.add "Accept", "application/vnd.github.v3+json"
  result = newRecallable(call, url, headers, input.getOrDefault("body").getStr)
