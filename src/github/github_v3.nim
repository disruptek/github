
import
  json, options, hashes, uri, strutils, rest, os, uri, httpcore

## auto-generated via openapi macro
## title: GitHub
## version: v3
## termsOfService: https://help.github.com/articles/github-terms-of-service/#b-api-terms
## license: (not provided)
## 
## Powerful collaboration, code review, and code management for open source and private projects.
## 
## 
## https://developer.github.com/v3/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (query: JsonNode = nil; body: JsonNode = nil;
                          header: JsonNode = nil; path: JsonNode = nil;
                          formData: JsonNode = nil): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_777573 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_777573](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_777573): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low .. Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js == nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result == nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind == kind, $kind & " expected; received " & $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string {.used.} =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] {.used.} =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    case js.kind
    of JInt, JFloat, JNull, JBool:
      head = $js
    of JString:
      head = js.getStr
    else:
      return
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.}
type
  Call_GetEmojis_777777 = ref object of OpenApiRestCall_777573
proc url_GetEmojis_777779(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEmojis_777778(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists all the emojis available to use on GitHub.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_777927 = header.getOrDefault("Accept")
  valid_777927 = validateParameter(valid_777927, JString, required = false,
                                 default = nil)
  if valid_777927 != nil:
    section.add "Accept", valid_777927
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_777950: Call_GetEmojis_777777; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists all the emojis available to use on GitHub.
  ## 
  let valid = call_777950.validator(path, query, header, formData, body)
  let scheme = call_777950.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_777950.url(scheme.get, call_777950.host, call_777950.base,
                         call_777950.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_777950, url, valid)

proc call*(call_778021: Call_GetEmojis_777777; Accept: string = ""): Recallable =
  ## getEmojis
  ## Lists all the emojis available to use on GitHub.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_778022 = newJObject()
  add(header_778022, "Accept", newJString(Accept))
  result = call_778021.call(nil, nil, header_778022, nil, nil)

var getEmojis* = Call_GetEmojis_777777(name: "getEmojis", meth: HttpMethod.HttpGet,
                                    host: "api.github.com", route: "/emojis",
                                    validator: validate_GetEmojis_777778,
                                    base: "/", url: url_GetEmojis_777779,
                                    schemes: {Scheme.Https})
type
  Call_GetEvents_778062 = ref object of OpenApiRestCall_777573
proc url_GetEvents_778064(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEvents_778063(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## List public events.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778065 = header.getOrDefault("Accept")
  valid_778065 = validateParameter(valid_778065, JString, required = false,
                                 default = nil)
  if valid_778065 != nil:
    section.add "Accept", valid_778065
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778066: Call_GetEvents_778062; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List public events.
  ## 
  let valid = call_778066.validator(path, query, header, formData, body)
  let scheme = call_778066.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778066.url(scheme.get, call_778066.host, call_778066.base,
                         call_778066.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778066, url, valid)

proc call*(call_778067: Call_GetEvents_778062; Accept: string = ""): Recallable =
  ## getEvents
  ## List public events.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_778068 = newJObject()
  add(header_778068, "Accept", newJString(Accept))
  result = call_778067.call(nil, nil, header_778068, nil, nil)

var getEvents* = Call_GetEvents_778062(name: "getEvents", meth: HttpMethod.HttpGet,
                                    host: "api.github.com", route: "/events",
                                    validator: validate_GetEvents_778063,
                                    base: "/", url: url_GetEvents_778064,
                                    schemes: {Scheme.Https})
type
  Call_GetFeeds_778069 = ref object of OpenApiRestCall_777573
proc url_GetFeeds_778071(protocol: Scheme; host: string; base: string; route: string;
                        path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetFeeds_778070(path: JsonNode; query: JsonNode; header: JsonNode;
                             formData: JsonNode; body: JsonNode): JsonNode =
  ## List Feeds.
  ## GitHub provides several timeline resources in Atom format. The Feeds API
  ##  lists all the feeds available to the authenticating user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778072 = header.getOrDefault("Accept")
  valid_778072 = validateParameter(valid_778072, JString, required = false,
                                 default = nil)
  if valid_778072 != nil:
    section.add "Accept", valid_778072
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778073: Call_GetFeeds_778069; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List Feeds.
  ## GitHub provides several timeline resources in Atom format. The Feeds API
  ##  lists all the feeds available to the authenticating user.
  ## 
  ## 
  let valid = call_778073.validator(path, query, header, formData, body)
  let scheme = call_778073.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778073.url(scheme.get, call_778073.host, call_778073.base,
                         call_778073.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778073, url, valid)

proc call*(call_778074: Call_GetFeeds_778069; Accept: string = ""): Recallable =
  ## getFeeds
  ## List Feeds.
  ## GitHub provides several timeline resources in Atom format. The Feeds API
  ##  lists all the feeds available to the authenticating user.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_778075 = newJObject()
  add(header_778075, "Accept", newJString(Accept))
  result = call_778074.call(nil, nil, header_778075, nil, nil)

var getFeeds* = Call_GetFeeds_778069(name: "getFeeds", meth: HttpMethod.HttpGet,
                                  host: "api.github.com", route: "/feeds",
                                  validator: validate_GetFeeds_778070, base: "/",
                                  url: url_GetFeeds_778071,
                                  schemes: {Scheme.Https})
type
  Call_PostGists_778085 = ref object of OpenApiRestCall_777573
proc url_PostGists_778087(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostGists_778086(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778097 = header.getOrDefault("Accept")
  valid_778097 = validateParameter(valid_778097, JString, required = false,
                                 default = nil)
  if valid_778097 != nil:
    section.add "Accept", valid_778097
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_778099: Call_PostGists_778085; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a gist.
  ## 
  let valid = call_778099.validator(path, query, header, formData, body)
  let scheme = call_778099.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778099.url(scheme.get, call_778099.host, call_778099.base,
                         call_778099.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778099, url, valid)

proc call*(call_778100: Call_PostGists_778085; body: JsonNode; Accept: string = ""): Recallable =
  ## postGists
  ## Create a gist.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_778101 = newJObject()
  var body_778102 = newJObject()
  if body != nil:
    body_778102 = body
  add(header_778101, "Accept", newJString(Accept))
  result = call_778100.call(nil, nil, header_778101, nil, body_778102)

var postGists* = Call_PostGists_778085(name: "postGists", meth: HttpMethod.HttpPost,
                                    host: "api.github.com", route: "/gists",
                                    validator: validate_PostGists_778086,
                                    base: "/", url: url_PostGists_778087,
                                    schemes: {Scheme.Https})
type
  Call_GetGists_778076 = ref object of OpenApiRestCall_777573
proc url_GetGists_778078(protocol: Scheme; host: string; base: string; route: string;
                        path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGists_778077(path: JsonNode; query: JsonNode; header: JsonNode;
                             formData: JsonNode; body: JsonNode): JsonNode =
  ## List the authenticated user's gists or if called anonymously, this will
  ## return all public gists.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_778079 = query.getOrDefault("since")
  valid_778079 = validateParameter(valid_778079, JString, required = false,
                                 default = nil)
  if valid_778079 != nil:
    section.add "since", valid_778079
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778080 = header.getOrDefault("Accept")
  valid_778080 = validateParameter(valid_778080, JString, required = false,
                                 default = nil)
  if valid_778080 != nil:
    section.add "Accept", valid_778080
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778081: Call_GetGists_778076; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the authenticated user's gists or if called anonymously, this will
  ## return all public gists.
  ## 
  ## 
  let valid = call_778081.validator(path, query, header, formData, body)
  let scheme = call_778081.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778081.url(scheme.get, call_778081.host, call_778081.base,
                         call_778081.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778081, url, valid)

proc call*(call_778082: Call_GetGists_778076; since: string = ""; Accept: string = ""): Recallable =
  ## getGists
  ## List the authenticated user's gists or if called anonymously, this will
  ## return all public gists.
  ## 
  ##   since: string
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var query_778083 = newJObject()
  var header_778084 = newJObject()
  add(query_778083, "since", newJString(since))
  add(header_778084, "Accept", newJString(Accept))
  result = call_778082.call(nil, query_778083, header_778084, nil, nil)

var getGists* = Call_GetGists_778076(name: "getGists", meth: HttpMethod.HttpGet,
                                  host: "api.github.com", route: "/gists",
                                  validator: validate_GetGists_778077, base: "/",
                                  url: url_GetGists_778078,
                                  schemes: {Scheme.Https})
type
  Call_GetGistsPublic_778103 = ref object of OpenApiRestCall_777573
proc url_GetGistsPublic_778105(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGistsPublic_778104(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## List all public gists.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_778106 = query.getOrDefault("since")
  valid_778106 = validateParameter(valid_778106, JString, required = false,
                                 default = nil)
  if valid_778106 != nil:
    section.add "since", valid_778106
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778107 = header.getOrDefault("Accept")
  valid_778107 = validateParameter(valid_778107, JString, required = false,
                                 default = nil)
  if valid_778107 != nil:
    section.add "Accept", valid_778107
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778108: Call_GetGistsPublic_778103; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List all public gists.
  ## 
  let valid = call_778108.validator(path, query, header, formData, body)
  let scheme = call_778108.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778108.url(scheme.get, call_778108.host, call_778108.base,
                         call_778108.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778108, url, valid)

proc call*(call_778109: Call_GetGistsPublic_778103; since: string = "";
          Accept: string = ""): Recallable =
  ## getGistsPublic
  ## List all public gists.
  ##   since: string
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var query_778110 = newJObject()
  var header_778111 = newJObject()
  add(query_778110, "since", newJString(since))
  add(header_778111, "Accept", newJString(Accept))
  result = call_778109.call(nil, query_778110, header_778111, nil, nil)

var getGistsPublic* = Call_GetGistsPublic_778103(name: "getGistsPublic",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/gists/public",
    validator: validate_GetGistsPublic_778104, base: "/", url: url_GetGistsPublic_778105,
    schemes: {Scheme.Https})
type
  Call_GetGistsStarred_778112 = ref object of OpenApiRestCall_777573
proc url_GetGistsStarred_778114(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGistsStarred_778113(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## List the authenticated user's starred gists.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_778115 = query.getOrDefault("since")
  valid_778115 = validateParameter(valid_778115, JString, required = false,
                                 default = nil)
  if valid_778115 != nil:
    section.add "since", valid_778115
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778116 = header.getOrDefault("Accept")
  valid_778116 = validateParameter(valid_778116, JString, required = false,
                                 default = nil)
  if valid_778116 != nil:
    section.add "Accept", valid_778116
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778117: Call_GetGistsStarred_778112; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the authenticated user's starred gists.
  ## 
  let valid = call_778117.validator(path, query, header, formData, body)
  let scheme = call_778117.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778117.url(scheme.get, call_778117.host, call_778117.base,
                         call_778117.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778117, url, valid)

proc call*(call_778118: Call_GetGistsStarred_778112; since: string = "";
          Accept: string = ""): Recallable =
  ## getGistsStarred
  ## List the authenticated user's starred gists.
  ##   since: string
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var query_778119 = newJObject()
  var header_778120 = newJObject()
  add(query_778119, "since", newJString(since))
  add(header_778120, "Accept", newJString(Accept))
  result = call_778118.call(nil, query_778119, header_778120, nil, nil)

var getGistsStarred* = Call_GetGistsStarred_778112(name: "getGistsStarred",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/gists/starred",
    validator: validate_GetGistsStarred_778113, base: "/", url: url_GetGistsStarred_778114,
    schemes: {Scheme.Https})
type
  Call_GetGistsId_778121 = ref object of OpenApiRestCall_777573
proc url_GetGistsId_778123(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsId_778122(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_778138 = path.getOrDefault("id")
  valid_778138 = validateParameter(valid_778138, JInt, required = true, default = nil)
  if valid_778138 != nil:
    section.add "id", valid_778138
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778139 = header.getOrDefault("Accept")
  valid_778139 = validateParameter(valid_778139, JString, required = false,
                                 default = nil)
  if valid_778139 != nil:
    section.add "Accept", valid_778139
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778140: Call_GetGistsId_778121; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a single gist.
  ## 
  let valid = call_778140.validator(path, query, header, formData, body)
  let scheme = call_778140.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778140.url(scheme.get, call_778140.host, call_778140.base,
                         call_778140.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778140, url, valid)

proc call*(call_778141: Call_GetGistsId_778121; id: int; Accept: string = ""): Recallable =
  ## getGistsId
  ## Get a single gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778142 = newJObject()
  var header_778143 = newJObject()
  add(path_778142, "id", newJInt(id))
  add(header_778143, "Accept", newJString(Accept))
  result = call_778141.call(path_778142, nil, header_778143, nil, nil)

var getGistsId* = Call_GetGistsId_778121(name: "getGistsId",
                                      meth: HttpMethod.HttpGet,
                                      host: "api.github.com",
                                      route: "/gists/{id}",
                                      validator: validate_GetGistsId_778122,
                                      base: "/", url: url_GetGistsId_778123,
                                      schemes: {Scheme.Https})
type
  Call_PatchGistsId_778153 = ref object of OpenApiRestCall_777573
proc url_PatchGistsId_778155(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchGistsId_778154(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Edit a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_778156 = path.getOrDefault("id")
  valid_778156 = validateParameter(valid_778156, JInt, required = true, default = nil)
  if valid_778156 != nil:
    section.add "id", valid_778156
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778157 = header.getOrDefault("Accept")
  valid_778157 = validateParameter(valid_778157, JString, required = false,
                                 default = nil)
  if valid_778157 != nil:
    section.add "Accept", valid_778157
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_778159: Call_PatchGistsId_778153; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Edit a gist.
  ## 
  let valid = call_778159.validator(path, query, header, formData, body)
  let scheme = call_778159.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778159.url(scheme.get, call_778159.host, call_778159.base,
                         call_778159.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778159, url, valid)

proc call*(call_778160: Call_PatchGistsId_778153; id: int; body: JsonNode;
          Accept: string = ""): Recallable =
  ## patchGistsId
  ## Edit a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778161 = newJObject()
  var header_778162 = newJObject()
  var body_778163 = newJObject()
  add(path_778161, "id", newJInt(id))
  if body != nil:
    body_778163 = body
  add(header_778162, "Accept", newJString(Accept))
  result = call_778160.call(path_778161, nil, header_778162, nil, body_778163)

var patchGistsId* = Call_PatchGistsId_778153(name: "patchGistsId",
    meth: HttpMethod.HttpPatch, host: "api.github.com", route: "/gists/{id}",
    validator: validate_PatchGistsId_778154, base: "/", url: url_PatchGistsId_778155,
    schemes: {Scheme.Https})
type
  Call_DeleteGistsId_778144 = ref object of OpenApiRestCall_777573
proc url_DeleteGistsId_778146(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteGistsId_778145(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_778147 = path.getOrDefault("id")
  valid_778147 = validateParameter(valid_778147, JInt, required = true, default = nil)
  if valid_778147 != nil:
    section.add "id", valid_778147
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778148 = header.getOrDefault("Accept")
  valid_778148 = validateParameter(valid_778148, JString, required = false,
                                 default = nil)
  if valid_778148 != nil:
    section.add "Accept", valid_778148
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778149: Call_DeleteGistsId_778144; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete a gist.
  ## 
  let valid = call_778149.validator(path, query, header, formData, body)
  let scheme = call_778149.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778149.url(scheme.get, call_778149.host, call_778149.base,
                         call_778149.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778149, url, valid)

proc call*(call_778150: Call_DeleteGistsId_778144; id: int; Accept: string = ""): Recallable =
  ## deleteGistsId
  ## Delete a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778151 = newJObject()
  var header_778152 = newJObject()
  add(path_778151, "id", newJInt(id))
  add(header_778152, "Accept", newJString(Accept))
  result = call_778150.call(path_778151, nil, header_778152, nil, nil)

var deleteGistsId* = Call_DeleteGistsId_778144(name: "deleteGistsId",
    meth: HttpMethod.HttpDelete, host: "api.github.com", route: "/gists/{id}",
    validator: validate_DeleteGistsId_778145, base: "/", url: url_DeleteGistsId_778146,
    schemes: {Scheme.Https})
type
  Call_PostGistsIdComments_778173 = ref object of OpenApiRestCall_777573
proc url_PostGistsIdComments_778175(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostGistsIdComments_778174(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Create a commen
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_778176 = path.getOrDefault("id")
  valid_778176 = validateParameter(valid_778176, JInt, required = true, default = nil)
  if valid_778176 != nil:
    section.add "id", valid_778176
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778177 = header.getOrDefault("Accept")
  valid_778177 = validateParameter(valid_778177, JString, required = false,
                                 default = nil)
  if valid_778177 != nil:
    section.add "Accept", valid_778177
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_778179: Call_PostGistsIdComments_778173; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a commen
  ## 
  let valid = call_778179.validator(path, query, header, formData, body)
  let scheme = call_778179.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778179.url(scheme.get, call_778179.host, call_778179.base,
                         call_778179.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778179, url, valid)

proc call*(call_778180: Call_PostGistsIdComments_778173; id: int; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postGistsIdComments
  ## Create a commen
  ##   id: int (required)
  ##     : Id of gist.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778181 = newJObject()
  var header_778182 = newJObject()
  var body_778183 = newJObject()
  add(path_778181, "id", newJInt(id))
  if body != nil:
    body_778183 = body
  add(header_778182, "Accept", newJString(Accept))
  result = call_778180.call(path_778181, nil, header_778182, nil, body_778183)

var postGistsIdComments* = Call_PostGistsIdComments_778173(
    name: "postGistsIdComments", meth: HttpMethod.HttpPost, host: "api.github.com",
    route: "/gists/{id}/comments", validator: validate_PostGistsIdComments_778174,
    base: "/", url: url_PostGistsIdComments_778175, schemes: {Scheme.Https})
type
  Call_GetGistsIdComments_778164 = ref object of OpenApiRestCall_777573
proc url_GetGistsIdComments_778166(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsIdComments_778165(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## List comments on a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_778167 = path.getOrDefault("id")
  valid_778167 = validateParameter(valid_778167, JInt, required = true, default = nil)
  if valid_778167 != nil:
    section.add "id", valid_778167
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778168 = header.getOrDefault("Accept")
  valid_778168 = validateParameter(valid_778168, JString, required = false,
                                 default = nil)
  if valid_778168 != nil:
    section.add "Accept", valid_778168
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778169: Call_GetGistsIdComments_778164; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List comments on a gist.
  ## 
  let valid = call_778169.validator(path, query, header, formData, body)
  let scheme = call_778169.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778169.url(scheme.get, call_778169.host, call_778169.base,
                         call_778169.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778169, url, valid)

proc call*(call_778170: Call_GetGistsIdComments_778164; id: int; Accept: string = ""): Recallable =
  ## getGistsIdComments
  ## List comments on a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778171 = newJObject()
  var header_778172 = newJObject()
  add(path_778171, "id", newJInt(id))
  add(header_778172, "Accept", newJString(Accept))
  result = call_778170.call(path_778171, nil, header_778172, nil, nil)

var getGistsIdComments* = Call_GetGistsIdComments_778164(
    name: "getGistsIdComments", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/gists/{id}/comments", validator: validate_GetGistsIdComments_778165,
    base: "/", url: url_GetGistsIdComments_778166, schemes: {Scheme.Https})
type
  Call_GetGistsIdCommentsCommentId_778184 = ref object of OpenApiRestCall_777573
proc url_GetGistsIdCommentsCommentId_778186(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsIdCommentsCommentId_778185(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_778187 = path.getOrDefault("id")
  valid_778187 = validateParameter(valid_778187, JInt, required = true, default = nil)
  if valid_778187 != nil:
    section.add "id", valid_778187
  var valid_778188 = path.getOrDefault("commentId")
  valid_778188 = validateParameter(valid_778188, JInt, required = true, default = nil)
  if valid_778188 != nil:
    section.add "commentId", valid_778188
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778189 = header.getOrDefault("Accept")
  valid_778189 = validateParameter(valid_778189, JString, required = false,
                                 default = nil)
  if valid_778189 != nil:
    section.add "Accept", valid_778189
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778190: Call_GetGistsIdCommentsCommentId_778184; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a single comment.
  ## 
  let valid = call_778190.validator(path, query, header, formData, body)
  let scheme = call_778190.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778190.url(scheme.get, call_778190.host, call_778190.base,
                         call_778190.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778190, url, valid)

proc call*(call_778191: Call_GetGistsIdCommentsCommentId_778184; id: int;
          commentId: int; Accept: string = ""): Recallable =
  ## getGistsIdCommentsCommentId
  ## Get a single comment.
  ##   id: int (required)
  ##     : Id of gist.
  ##   commentId: int (required)
  ##            : Id of comment.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778192 = newJObject()
  var header_778193 = newJObject()
  add(path_778192, "id", newJInt(id))
  add(path_778192, "commentId", newJInt(commentId))
  add(header_778193, "Accept", newJString(Accept))
  result = call_778191.call(path_778192, nil, header_778193, nil, nil)

var getGistsIdCommentsCommentId* = Call_GetGistsIdCommentsCommentId_778184(
    name: "getGistsIdCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/gists/{id}/comments/{commentId}",
    validator: validate_GetGistsIdCommentsCommentId_778185, base: "/",
    url: url_GetGistsIdCommentsCommentId_778186, schemes: {Scheme.Https})
type
  Call_PatchGistsIdCommentsCommentId_778204 = ref object of OpenApiRestCall_777573
proc url_PatchGistsIdCommentsCommentId_778206(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchGistsIdCommentsCommentId_778205(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Edit a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_778207 = path.getOrDefault("id")
  valid_778207 = validateParameter(valid_778207, JInt, required = true, default = nil)
  if valid_778207 != nil:
    section.add "id", valid_778207
  var valid_778208 = path.getOrDefault("commentId")
  valid_778208 = validateParameter(valid_778208, JInt, required = true, default = nil)
  if valid_778208 != nil:
    section.add "commentId", valid_778208
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778209 = header.getOrDefault("Accept")
  valid_778209 = validateParameter(valid_778209, JString, required = false,
                                 default = nil)
  if valid_778209 != nil:
    section.add "Accept", valid_778209
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_778211: Call_PatchGistsIdCommentsCommentId_778204; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Edit a comment.
  ## 
  let valid = call_778211.validator(path, query, header, formData, body)
  let scheme = call_778211.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778211.url(scheme.get, call_778211.host, call_778211.base,
                         call_778211.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778211, url, valid)

proc call*(call_778212: Call_PatchGistsIdCommentsCommentId_778204; id: int;
          commentId: int; body: JsonNode; Accept: string = ""): Recallable =
  ## patchGistsIdCommentsCommentId
  ## Edit a comment.
  ##   id: int (required)
  ##     : Id of gist.
  ##   commentId: int (required)
  ##            : Id of comment.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778213 = newJObject()
  var header_778214 = newJObject()
  var body_778215 = newJObject()
  add(path_778213, "id", newJInt(id))
  add(path_778213, "commentId", newJInt(commentId))
  if body != nil:
    body_778215 = body
  add(header_778214, "Accept", newJString(Accept))
  result = call_778212.call(path_778213, nil, header_778214, nil, body_778215)

var patchGistsIdCommentsCommentId* = Call_PatchGistsIdCommentsCommentId_778204(
    name: "patchGistsIdCommentsCommentId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/gists/{id}/comments/{commentId}",
    validator: validate_PatchGistsIdCommentsCommentId_778205, base: "/",
    url: url_PatchGistsIdCommentsCommentId_778206, schemes: {Scheme.Https})
type
  Call_DeleteGistsIdCommentsCommentId_778194 = ref object of OpenApiRestCall_777573
proc url_DeleteGistsIdCommentsCommentId_778196(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteGistsIdCommentsCommentId_778195(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_778197 = path.getOrDefault("id")
  valid_778197 = validateParameter(valid_778197, JInt, required = true, default = nil)
  if valid_778197 != nil:
    section.add "id", valid_778197
  var valid_778198 = path.getOrDefault("commentId")
  valid_778198 = validateParameter(valid_778198, JInt, required = true, default = nil)
  if valid_778198 != nil:
    section.add "commentId", valid_778198
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778199 = header.getOrDefault("Accept")
  valid_778199 = validateParameter(valid_778199, JString, required = false,
                                 default = nil)
  if valid_778199 != nil:
    section.add "Accept", valid_778199
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778200: Call_DeleteGistsIdCommentsCommentId_778194; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete a comment.
  ## 
  let valid = call_778200.validator(path, query, header, formData, body)
  let scheme = call_778200.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778200.url(scheme.get, call_778200.host, call_778200.base,
                         call_778200.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778200, url, valid)

proc call*(call_778201: Call_DeleteGistsIdCommentsCommentId_778194; id: int;
          commentId: int; Accept: string = ""): Recallable =
  ## deleteGistsIdCommentsCommentId
  ## Delete a comment.
  ##   id: int (required)
  ##     : Id of gist.
  ##   commentId: int (required)
  ##            : Id of comment.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778202 = newJObject()
  var header_778203 = newJObject()
  add(path_778202, "id", newJInt(id))
  add(path_778202, "commentId", newJInt(commentId))
  add(header_778203, "Accept", newJString(Accept))
  result = call_778201.call(path_778202, nil, header_778203, nil, nil)

var deleteGistsIdCommentsCommentId* = Call_DeleteGistsIdCommentsCommentId_778194(
    name: "deleteGistsIdCommentsCommentId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/gists/{id}/comments/{commentId}",
    validator: validate_DeleteGistsIdCommentsCommentId_778195, base: "/",
    url: url_DeleteGistsIdCommentsCommentId_778196, schemes: {Scheme.Https})
type
  Call_PostGistsIdForks_778216 = ref object of OpenApiRestCall_777573
proc url_PostGistsIdForks_778218(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/forks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostGistsIdForks_778217(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Fork a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_778219 = path.getOrDefault("id")
  valid_778219 = validateParameter(valid_778219, JInt, required = true, default = nil)
  if valid_778219 != nil:
    section.add "id", valid_778219
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778220 = header.getOrDefault("Accept")
  valid_778220 = validateParameter(valid_778220, JString, required = false,
                                 default = nil)
  if valid_778220 != nil:
    section.add "Accept", valid_778220
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778221: Call_PostGistsIdForks_778216; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Fork a gist.
  ## 
  let valid = call_778221.validator(path, query, header, formData, body)
  let scheme = call_778221.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778221.url(scheme.get, call_778221.host, call_778221.base,
                         call_778221.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778221, url, valid)

proc call*(call_778222: Call_PostGistsIdForks_778216; id: int; Accept: string = ""): Recallable =
  ## postGistsIdForks
  ## Fork a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778223 = newJObject()
  var header_778224 = newJObject()
  add(path_778223, "id", newJInt(id))
  add(header_778224, "Accept", newJString(Accept))
  result = call_778222.call(path_778223, nil, header_778224, nil, nil)

var postGistsIdForks* = Call_PostGistsIdForks_778216(name: "postGistsIdForks",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/gists/{id}/forks",
    validator: validate_PostGistsIdForks_778217, base: "/",
    url: url_PostGistsIdForks_778218, schemes: {Scheme.Https})
type
  Call_PutGistsIdStar_778234 = ref object of OpenApiRestCall_777573
proc url_PutGistsIdStar_778236(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/star")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutGistsIdStar_778235(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Star a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_778237 = path.getOrDefault("id")
  valid_778237 = validateParameter(valid_778237, JInt, required = true, default = nil)
  if valid_778237 != nil:
    section.add "id", valid_778237
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778238 = header.getOrDefault("Accept")
  valid_778238 = validateParameter(valid_778238, JString, required = false,
                                 default = nil)
  if valid_778238 != nil:
    section.add "Accept", valid_778238
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778239: Call_PutGistsIdStar_778234; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Star a gist.
  ## 
  let valid = call_778239.validator(path, query, header, formData, body)
  let scheme = call_778239.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778239.url(scheme.get, call_778239.host, call_778239.base,
                         call_778239.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778239, url, valid)

proc call*(call_778240: Call_PutGistsIdStar_778234; id: int; Accept: string = ""): Recallable =
  ## putGistsIdStar
  ## Star a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778241 = newJObject()
  var header_778242 = newJObject()
  add(path_778241, "id", newJInt(id))
  add(header_778242, "Accept", newJString(Accept))
  result = call_778240.call(path_778241, nil, header_778242, nil, nil)

var putGistsIdStar* = Call_PutGistsIdStar_778234(name: "putGistsIdStar",
    meth: HttpMethod.HttpPut, host: "api.github.com", route: "/gists/{id}/star",
    validator: validate_PutGistsIdStar_778235, base: "/", url: url_PutGistsIdStar_778236,
    schemes: {Scheme.Https})
type
  Call_GetGistsIdStar_778225 = ref object of OpenApiRestCall_777573
proc url_GetGistsIdStar_778227(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/star")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsIdStar_778226(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Check if a gist is starred.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_778228 = path.getOrDefault("id")
  valid_778228 = validateParameter(valid_778228, JInt, required = true, default = nil)
  if valid_778228 != nil:
    section.add "id", valid_778228
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778229 = header.getOrDefault("Accept")
  valid_778229 = validateParameter(valid_778229, JString, required = false,
                                 default = nil)
  if valid_778229 != nil:
    section.add "Accept", valid_778229
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778230: Call_GetGistsIdStar_778225; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Check if a gist is starred.
  ## 
  let valid = call_778230.validator(path, query, header, formData, body)
  let scheme = call_778230.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778230.url(scheme.get, call_778230.host, call_778230.base,
                         call_778230.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778230, url, valid)

proc call*(call_778231: Call_GetGistsIdStar_778225; id: int; Accept: string = ""): Recallable =
  ## getGistsIdStar
  ## Check if a gist is starred.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778232 = newJObject()
  var header_778233 = newJObject()
  add(path_778232, "id", newJInt(id))
  add(header_778233, "Accept", newJString(Accept))
  result = call_778231.call(path_778232, nil, header_778233, nil, nil)

var getGistsIdStar* = Call_GetGistsIdStar_778225(name: "getGistsIdStar",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/gists/{id}/star",
    validator: validate_GetGistsIdStar_778226, base: "/", url: url_GetGistsIdStar_778227,
    schemes: {Scheme.Https})
type
  Call_DeleteGistsIdStar_778243 = ref object of OpenApiRestCall_777573
proc url_DeleteGistsIdStar_778245(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/star")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteGistsIdStar_778244(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Unstar a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_778246 = path.getOrDefault("id")
  valid_778246 = validateParameter(valid_778246, JInt, required = true, default = nil)
  if valid_778246 != nil:
    section.add "id", valid_778246
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778247 = header.getOrDefault("Accept")
  valid_778247 = validateParameter(valid_778247, JString, required = false,
                                 default = nil)
  if valid_778247 != nil:
    section.add "Accept", valid_778247
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778248: Call_DeleteGistsIdStar_778243; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Unstar a gist.
  ## 
  let valid = call_778248.validator(path, query, header, formData, body)
  let scheme = call_778248.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778248.url(scheme.get, call_778248.host, call_778248.base,
                         call_778248.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778248, url, valid)

proc call*(call_778249: Call_DeleteGistsIdStar_778243; id: int; Accept: string = ""): Recallable =
  ## deleteGistsIdStar
  ## Unstar a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778250 = newJObject()
  var header_778251 = newJObject()
  add(path_778250, "id", newJInt(id))
  add(header_778251, "Accept", newJString(Accept))
  result = call_778249.call(path_778250, nil, header_778251, nil, nil)

var deleteGistsIdStar* = Call_DeleteGistsIdStar_778243(name: "deleteGistsIdStar",
    meth: HttpMethod.HttpDelete, host: "api.github.com", route: "/gists/{id}/star",
    validator: validate_DeleteGistsIdStar_778244, base: "/",
    url: url_DeleteGistsIdStar_778245, schemes: {Scheme.Https})
type
  Call_GetGitignoreTemplates_778252 = ref object of OpenApiRestCall_777573
proc url_GetGitignoreTemplates_778254(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGitignoreTemplates_778253(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Listing available templates.
  ## List all templates available to pass as an option when creating a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778255 = header.getOrDefault("Accept")
  valid_778255 = validateParameter(valid_778255, JString, required = false,
                                 default = nil)
  if valid_778255 != nil:
    section.add "Accept", valid_778255
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778256: Call_GetGitignoreTemplates_778252; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Listing available templates.
  ## List all templates available to pass as an option when creating a repository.
  ## 
  ## 
  let valid = call_778256.validator(path, query, header, formData, body)
  let scheme = call_778256.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778256.url(scheme.get, call_778256.host, call_778256.base,
                         call_778256.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778256, url, valid)

proc call*(call_778257: Call_GetGitignoreTemplates_778252; Accept: string = ""): Recallable =
  ## getGitignoreTemplates
  ## Listing available templates.
  ## List all templates available to pass as an option when creating a repository.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_778258 = newJObject()
  add(header_778258, "Accept", newJString(Accept))
  result = call_778257.call(nil, nil, header_778258, nil, nil)

var getGitignoreTemplates* = Call_GetGitignoreTemplates_778252(
    name: "getGitignoreTemplates", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/gitignore/templates", validator: validate_GetGitignoreTemplates_778253,
    base: "/", url: url_GetGitignoreTemplates_778254, schemes: {Scheme.Https})
type
  Call_GetGitignoreTemplatesLanguage_778259 = ref object of OpenApiRestCall_777573
proc url_GetGitignoreTemplatesLanguage_778261(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "language" in path, "`language` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gitignore/templates/"),
               (kind: VariableSegment, value: "language")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGitignoreTemplatesLanguage_778260(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   language: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `language` field"
  var valid_778262 = path.getOrDefault("language")
  valid_778262 = validateParameter(valid_778262, JString, required = true,
                                 default = nil)
  if valid_778262 != nil:
    section.add "language", valid_778262
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778263 = header.getOrDefault("Accept")
  valid_778263 = validateParameter(valid_778263, JString, required = false,
                                 default = nil)
  if valid_778263 != nil:
    section.add "Accept", valid_778263
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778264: Call_GetGitignoreTemplatesLanguage_778259; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a single template.
  ## 
  let valid = call_778264.validator(path, query, header, formData, body)
  let scheme = call_778264.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778264.url(scheme.get, call_778264.host, call_778264.base,
                         call_778264.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778264, url, valid)

proc call*(call_778265: Call_GetGitignoreTemplatesLanguage_778259;
          language: string; Accept: string = ""): Recallable =
  ## getGitignoreTemplatesLanguage
  ## Get a single template.
  ##   language: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778266 = newJObject()
  var header_778267 = newJObject()
  add(path_778266, "language", newJString(language))
  add(header_778267, "Accept", newJString(Accept))
  result = call_778265.call(path_778266, nil, header_778267, nil, nil)

var getGitignoreTemplatesLanguage* = Call_GetGitignoreTemplatesLanguage_778259(
    name: "getGitignoreTemplatesLanguage", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/gitignore/templates/{language}",
    validator: validate_GetGitignoreTemplatesLanguage_778260, base: "/",
    url: url_GetGitignoreTemplatesLanguage_778261, schemes: {Scheme.Https})
type
  Call_GetIssues_778268 = ref object of OpenApiRestCall_777573
proc url_GetIssues_778270(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetIssues_778269(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## List issues.
  ## List all issues across all the authenticated user's visible repositories.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   direction: JString (required)
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  ##   state: JString (required)
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   sort: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `labels` field"
  var valid_778271 = query.getOrDefault("labels")
  valid_778271 = validateParameter(valid_778271, JString, required = true,
                                 default = nil)
  if valid_778271 != nil:
    section.add "labels", valid_778271
  var valid_778285 = query.getOrDefault("direction")
  valid_778285 = validateParameter(valid_778285, JString, required = true,
                                 default = newJString("desc"))
  if valid_778285 != nil:
    section.add "direction", valid_778285
  var valid_778286 = query.getOrDefault("since")
  valid_778286 = validateParameter(valid_778286, JString, required = false,
                                 default = nil)
  if valid_778286 != nil:
    section.add "since", valid_778286
  var valid_778287 = query.getOrDefault("state")
  valid_778287 = validateParameter(valid_778287, JString, required = true,
                                 default = newJString("open"))
  if valid_778287 != nil:
    section.add "state", valid_778287
  var valid_778288 = query.getOrDefault("filter")
  valid_778288 = validateParameter(valid_778288, JString, required = true,
                                 default = newJString("all"))
  if valid_778288 != nil:
    section.add "filter", valid_778288
  var valid_778289 = query.getOrDefault("sort")
  valid_778289 = validateParameter(valid_778289, JString, required = true,
                                 default = newJString("created"))
  if valid_778289 != nil:
    section.add "sort", valid_778289
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778290 = header.getOrDefault("Accept")
  valid_778290 = validateParameter(valid_778290, JString, required = false,
                                 default = nil)
  if valid_778290 != nil:
    section.add "Accept", valid_778290
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778291: Call_GetIssues_778268; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List issues.
  ## List all issues across all the authenticated user's visible repositories.
  ## 
  ## 
  let valid = call_778291.validator(path, query, header, formData, body)
  let scheme = call_778291.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778291.url(scheme.get, call_778291.host, call_778291.base,
                         call_778291.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778291, url, valid)

proc call*(call_778292: Call_GetIssues_778268; labels: string;
          direction: string = "desc"; since: string = ""; state: string = "open";
          filter: string = "all"; Accept: string = ""; sort: string = "created"): Recallable =
  ## getIssues
  ## List issues.
  ## List all issues across all the authenticated user's visible repositories.
  ## 
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   direction: string (required)
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  ##   state: string (required)
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string (required)
  var query_778293 = newJObject()
  var header_778294 = newJObject()
  add(query_778293, "labels", newJString(labels))
  add(query_778293, "direction", newJString(direction))
  add(query_778293, "since", newJString(since))
  add(query_778293, "state", newJString(state))
  add(query_778293, "filter", newJString(filter))
  add(header_778294, "Accept", newJString(Accept))
  add(query_778293, "sort", newJString(sort))
  result = call_778292.call(nil, query_778293, header_778294, nil, nil)

var getIssues* = Call_GetIssues_778268(name: "getIssues", meth: HttpMethod.HttpGet,
                                    host: "api.github.com", route: "/issues",
                                    validator: validate_GetIssues_778269,
                                    base: "/", url: url_GetIssues_778270,
                                    schemes: {Scheme.Https})
type
  Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_778295 = ref object of OpenApiRestCall_777573
proc url_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_778297(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repository" in path, "`repository` is a required path parameter"
  assert "state" in path, "`state` is a required path parameter"
  assert "keyword" in path, "`keyword` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/issues/search/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repository"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "state"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "keyword")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_778296(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode): JsonNode =
  ## Find issues by state and keyword.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repository: JString (required)
  ##   state: JString (required)
  ##        : Indicates the state of the issues to return. Can be either open or closed.
  ##   owner: JString (required)
  ##   keyword: JString (required)
  ##          : The search term.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `repository` field"
  var valid_778298 = path.getOrDefault("repository")
  valid_778298 = validateParameter(valid_778298, JString, required = true,
                                 default = nil)
  if valid_778298 != nil:
    section.add "repository", valid_778298
  var valid_778299 = path.getOrDefault("state")
  valid_778299 = validateParameter(valid_778299, JString, required = true,
                                 default = newJString("open"))
  if valid_778299 != nil:
    section.add "state", valid_778299
  var valid_778300 = path.getOrDefault("owner")
  valid_778300 = validateParameter(valid_778300, JString, required = true,
                                 default = nil)
  if valid_778300 != nil:
    section.add "owner", valid_778300
  var valid_778301 = path.getOrDefault("keyword")
  valid_778301 = validateParameter(valid_778301, JString, required = true,
                                 default = nil)
  if valid_778301 != nil:
    section.add "keyword", valid_778301
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778302 = header.getOrDefault("Accept")
  valid_778302 = validateParameter(valid_778302, JString, required = false,
                                 default = nil)
  if valid_778302 != nil:
    section.add "Accept", valid_778302
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778303: Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_778295;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Find issues by state and keyword.
  ## 
  let valid = call_778303.validator(path, query, header, formData, body)
  let scheme = call_778303.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778303.url(scheme.get, call_778303.host, call_778303.base,
                         call_778303.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778303, url, valid)

proc call*(call_778304: Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_778295;
          repository: string; owner: string; keyword: string; state: string = "open";
          Accept: string = ""): Recallable =
  ## getLegacyIssuesSearchOwnerRepositoryStateKeyword
  ## Find issues by state and keyword.
  ##   repository: string (required)
  ##   state: string (required)
  ##        : Indicates the state of the issues to return. Can be either open or closed.
  ##   owner: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   keyword: string (required)
  ##          : The search term.
  var path_778305 = newJObject()
  var header_778306 = newJObject()
  add(path_778305, "repository", newJString(repository))
  add(path_778305, "state", newJString(state))
  add(path_778305, "owner", newJString(owner))
  add(header_778306, "Accept", newJString(Accept))
  add(path_778305, "keyword", newJString(keyword))
  result = call_778304.call(path_778305, nil, header_778306, nil, nil)

var getLegacyIssuesSearchOwnerRepositoryStateKeyword* = Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_778295(
    name: "getLegacyIssuesSearchOwnerRepositoryStateKeyword",
    meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/legacy/issues/search/{owner}/{repository}/{state}/{keyword}",
    validator: validate_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_778296,
    base: "/", url: url_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_778297,
    schemes: {Scheme.Https})
type
  Call_GetLegacyReposSearchKeyword_778307 = ref object of OpenApiRestCall_777573
proc url_GetLegacyReposSearchKeyword_778309(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyword" in path, "`keyword` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/repos/search/"),
               (kind: VariableSegment, value: "keyword")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyReposSearchKeyword_778308(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Find repositories by keyword. Note, this legacy method does not follow the v3 pagination pattern. This method returns up to 100 results per page and pages can be fetched using the start_page parameter.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyword: JString (required)
  ##          : The search term
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyword` field"
  var valid_778310 = path.getOrDefault("keyword")
  valid_778310 = validateParameter(valid_778310, JString, required = true,
                                 default = nil)
  if valid_778310 != nil:
    section.add "keyword", valid_778310
  result.add "path", section
  ## parameters in `query` object:
  ##   start_page: JString
  ##             : The page number to fetch
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   language: JString
  ##           : Filter results by language
  ##   sort: JString
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  section = newJObject()
  var valid_778311 = query.getOrDefault("start_page")
  valid_778311 = validateParameter(valid_778311, JString, required = false,
                                 default = nil)
  if valid_778311 != nil:
    section.add "start_page", valid_778311
  var valid_778312 = query.getOrDefault("order")
  valid_778312 = validateParameter(valid_778312, JString, required = false,
                                 default = newJString("desc"))
  if valid_778312 != nil:
    section.add "order", valid_778312
  var valid_778313 = query.getOrDefault("language")
  valid_778313 = validateParameter(valid_778313, JString, required = false,
                                 default = nil)
  if valid_778313 != nil:
    section.add "language", valid_778313
  var valid_778314 = query.getOrDefault("sort")
  valid_778314 = validateParameter(valid_778314, JString, required = false,
                                 default = newJString("updated"))
  if valid_778314 != nil:
    section.add "sort", valid_778314
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778315 = header.getOrDefault("Accept")
  valid_778315 = validateParameter(valid_778315, JString, required = false,
                                 default = nil)
  if valid_778315 != nil:
    section.add "Accept", valid_778315
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778316: Call_GetLegacyReposSearchKeyword_778307; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Find repositories by keyword. Note, this legacy method does not follow the v3 pagination pattern. This method returns up to 100 results per page and pages can be fetched using the start_page parameter.
  ## 
  let valid = call_778316.validator(path, query, header, formData, body)
  let scheme = call_778316.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778316.url(scheme.get, call_778316.host, call_778316.base,
                         call_778316.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778316, url, valid)

proc call*(call_778317: Call_GetLegacyReposSearchKeyword_778307; keyword: string;
          startPage: string = ""; order: string = "desc"; Accept: string = "";
          language: string = ""; sort: string = "updated"): Recallable =
  ## getLegacyReposSearchKeyword
  ## Find repositories by keyword. Note, this legacy method does not follow the v3 pagination pattern. This method returns up to 100 results per page and pages can be fetched using the start_page parameter.
  ##   startPage: string
  ##            : The page number to fetch
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   keyword: string (required)
  ##          : The search term
  ##   language: string
  ##           : Filter results by language
  ##   sort: string
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  var path_778318 = newJObject()
  var query_778319 = newJObject()
  var header_778320 = newJObject()
  add(query_778319, "start_page", newJString(startPage))
  add(query_778319, "order", newJString(order))
  add(header_778320, "Accept", newJString(Accept))
  add(path_778318, "keyword", newJString(keyword))
  add(query_778319, "language", newJString(language))
  add(query_778319, "sort", newJString(sort))
  result = call_778317.call(path_778318, query_778319, header_778320, nil, nil)

var getLegacyReposSearchKeyword* = Call_GetLegacyReposSearchKeyword_778307(
    name: "getLegacyReposSearchKeyword", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/legacy/repos/search/{keyword}",
    validator: validate_GetLegacyReposSearchKeyword_778308, base: "/",
    url: url_GetLegacyReposSearchKeyword_778309, schemes: {Scheme.Https})
type
  Call_GetLegacyUserEmailEmail_778321 = ref object of OpenApiRestCall_777573
proc url_GetLegacyUserEmailEmail_778323(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "email" in path, "`email` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/user/email/"),
               (kind: VariableSegment, value: "email")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyUserEmailEmail_778322(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This API call is added for compatibility reasons only.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   email: JString (required)
  ##        : The email address
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `email` field"
  var valid_778324 = path.getOrDefault("email")
  valid_778324 = validateParameter(valid_778324, JString, required = true,
                                 default = nil)
  if valid_778324 != nil:
    section.add "email", valid_778324
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778325 = header.getOrDefault("Accept")
  valid_778325 = validateParameter(valid_778325, JString, required = false,
                                 default = nil)
  if valid_778325 != nil:
    section.add "Accept", valid_778325
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778326: Call_GetLegacyUserEmailEmail_778321; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This API call is added for compatibility reasons only.
  ## 
  let valid = call_778326.validator(path, query, header, formData, body)
  let scheme = call_778326.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778326.url(scheme.get, call_778326.host, call_778326.base,
                         call_778326.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778326, url, valid)

proc call*(call_778327: Call_GetLegacyUserEmailEmail_778321; email: string;
          Accept: string = ""): Recallable =
  ## getLegacyUserEmailEmail
  ## This API call is added for compatibility reasons only.
  ##   email: string (required)
  ##        : The email address
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778328 = newJObject()
  var header_778329 = newJObject()
  add(path_778328, "email", newJString(email))
  add(header_778329, "Accept", newJString(Accept))
  result = call_778327.call(path_778328, nil, header_778329, nil, nil)

var getLegacyUserEmailEmail* = Call_GetLegacyUserEmailEmail_778321(
    name: "getLegacyUserEmailEmail", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/legacy/user/email/{email}",
    validator: validate_GetLegacyUserEmailEmail_778322, base: "/",
    url: url_GetLegacyUserEmailEmail_778323, schemes: {Scheme.Https})
type
  Call_GetLegacyUserSearchKeyword_778330 = ref object of OpenApiRestCall_777573
proc url_GetLegacyUserSearchKeyword_778332(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyword" in path, "`keyword` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/user/search/"),
               (kind: VariableSegment, value: "keyword")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyUserSearchKeyword_778331(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Find users by keyword.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyword: JString (required)
  ##          : The search term
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyword` field"
  var valid_778333 = path.getOrDefault("keyword")
  valid_778333 = validateParameter(valid_778333, JString, required = true,
                                 default = nil)
  if valid_778333 != nil:
    section.add "keyword", valid_778333
  result.add "path", section
  ## parameters in `query` object:
  ##   start_page: JString
  ##             : The page number to fetch
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   sort: JString
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  section = newJObject()
  var valid_778334 = query.getOrDefault("start_page")
  valid_778334 = validateParameter(valid_778334, JString, required = false,
                                 default = nil)
  if valid_778334 != nil:
    section.add "start_page", valid_778334
  var valid_778335 = query.getOrDefault("order")
  valid_778335 = validateParameter(valid_778335, JString, required = false,
                                 default = newJString("desc"))
  if valid_778335 != nil:
    section.add "order", valid_778335
  var valid_778336 = query.getOrDefault("sort")
  valid_778336 = validateParameter(valid_778336, JString, required = false,
                                 default = newJString("updated"))
  if valid_778336 != nil:
    section.add "sort", valid_778336
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778337 = header.getOrDefault("Accept")
  valid_778337 = validateParameter(valid_778337, JString, required = false,
                                 default = nil)
  if valid_778337 != nil:
    section.add "Accept", valid_778337
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778338: Call_GetLegacyUserSearchKeyword_778330; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Find users by keyword.
  ## 
  let valid = call_778338.validator(path, query, header, formData, body)
  let scheme = call_778338.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778338.url(scheme.get, call_778338.host, call_778338.base,
                         call_778338.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778338, url, valid)

proc call*(call_778339: Call_GetLegacyUserSearchKeyword_778330; keyword: string;
          startPage: string = ""; order: string = "desc"; Accept: string = "";
          sort: string = "updated"): Recallable =
  ## getLegacyUserSearchKeyword
  ## Find users by keyword.
  ##   startPage: string
  ##            : The page number to fetch
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   keyword: string (required)
  ##          : The search term
  ##   sort: string
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  var path_778340 = newJObject()
  var query_778341 = newJObject()
  var header_778342 = newJObject()
  add(query_778341, "start_page", newJString(startPage))
  add(query_778341, "order", newJString(order))
  add(header_778342, "Accept", newJString(Accept))
  add(path_778340, "keyword", newJString(keyword))
  add(query_778341, "sort", newJString(sort))
  result = call_778339.call(path_778340, query_778341, header_778342, nil, nil)

var getLegacyUserSearchKeyword* = Call_GetLegacyUserSearchKeyword_778330(
    name: "getLegacyUserSearchKeyword", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/legacy/user/search/{keyword}",
    validator: validate_GetLegacyUserSearchKeyword_778331, base: "/",
    url: url_GetLegacyUserSearchKeyword_778332, schemes: {Scheme.Https})
type
  Call_PostMarkdown_778343 = ref object of OpenApiRestCall_777573
proc url_PostMarkdown_778345(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostMarkdown_778344(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Render an arbitrary Markdown document
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778346 = header.getOrDefault("Accept")
  valid_778346 = validateParameter(valid_778346, JString, required = false,
                                 default = nil)
  if valid_778346 != nil:
    section.add "Accept", valid_778346
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_778348: Call_PostMarkdown_778343; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Render an arbitrary Markdown document
  ## 
  let valid = call_778348.validator(path, query, header, formData, body)
  let scheme = call_778348.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778348.url(scheme.get, call_778348.host, call_778348.base,
                         call_778348.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778348, url, valid)

proc call*(call_778349: Call_PostMarkdown_778343; body: JsonNode; Accept: string = ""): Recallable =
  ## postMarkdown
  ## Render an arbitrary Markdown document
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_778350 = newJObject()
  var body_778351 = newJObject()
  if body != nil:
    body_778351 = body
  add(header_778350, "Accept", newJString(Accept))
  result = call_778349.call(nil, nil, header_778350, nil, body_778351)

var postMarkdown* = Call_PostMarkdown_778343(name: "postMarkdown",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/markdown",
    validator: validate_PostMarkdown_778344, base: "/", url: url_PostMarkdown_778345,
    schemes: {Scheme.Https})
type
  Call_PostMarkdownRaw_778352 = ref object of OpenApiRestCall_777573
proc url_PostMarkdownRaw_778354(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostMarkdownRaw_778353(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Render a Markdown document in raw mode
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778355 = header.getOrDefault("Accept")
  valid_778355 = validateParameter(valid_778355, JString, required = false,
                                 default = nil)
  if valid_778355 != nil:
    section.add "Accept", valid_778355
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778356: Call_PostMarkdownRaw_778352; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Render a Markdown document in raw mode
  ## 
  let valid = call_778356.validator(path, query, header, formData, body)
  let scheme = call_778356.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778356.url(scheme.get, call_778356.host, call_778356.base,
                         call_778356.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778356, url, valid)

proc call*(call_778357: Call_PostMarkdownRaw_778352; Accept: string = ""): Recallable =
  ## postMarkdownRaw
  ## Render a Markdown document in raw mode
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_778358 = newJObject()
  add(header_778358, "Accept", newJString(Accept))
  result = call_778357.call(nil, nil, header_778358, nil, nil)

var postMarkdownRaw* = Call_PostMarkdownRaw_778352(name: "postMarkdownRaw",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/markdown/raw",
    validator: validate_PostMarkdownRaw_778353, base: "/", url: url_PostMarkdownRaw_778354,
    schemes: {Scheme.Https})
type
  Call_GetMeta_778359 = ref object of OpenApiRestCall_777573
proc url_GetMeta_778361(protocol: Scheme; host: string; base: string; route: string;
                       path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetMeta_778360(path: JsonNode; query: JsonNode; header: JsonNode;
                            formData: JsonNode; body: JsonNode): JsonNode =
  ## This gives some information about GitHub.com, the service.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778362 = header.getOrDefault("Accept")
  valid_778362 = validateParameter(valid_778362, JString, required = false,
                                 default = nil)
  if valid_778362 != nil:
    section.add "Accept", valid_778362
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778363: Call_GetMeta_778359; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This gives some information about GitHub.com, the service.
  ## 
  let valid = call_778363.validator(path, query, header, formData, body)
  let scheme = call_778363.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778363.url(scheme.get, call_778363.host, call_778363.base,
                         call_778363.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778363, url, valid)

proc call*(call_778364: Call_GetMeta_778359; Accept: string = ""): Recallable =
  ## getMeta
  ## This gives some information about GitHub.com, the service.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_778365 = newJObject()
  add(header_778365, "Accept", newJString(Accept))
  result = call_778364.call(nil, nil, header_778365, nil, nil)

var getMeta* = Call_GetMeta_778359(name: "getMeta", meth: HttpMethod.HttpGet,
                                host: "api.github.com", route: "/meta",
                                validator: validate_GetMeta_778360, base: "/",
                                url: url_GetMeta_778361, schemes: {Scheme.Https})
type
  Call_GetNetworksOwnerRepoEvents_778366 = ref object of OpenApiRestCall_777573
proc url_GetNetworksOwnerRepoEvents_778368(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/networks/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetNetworksOwnerRepoEvents_778367(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List public events for a network of repositories.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of the owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778369 = path.getOrDefault("repo")
  valid_778369 = validateParameter(valid_778369, JString, required = true,
                                 default = nil)
  if valid_778369 != nil:
    section.add "repo", valid_778369
  var valid_778370 = path.getOrDefault("owner")
  valid_778370 = validateParameter(valid_778370, JString, required = true,
                                 default = nil)
  if valid_778370 != nil:
    section.add "owner", valid_778370
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778371 = header.getOrDefault("Accept")
  valid_778371 = validateParameter(valid_778371, JString, required = false,
                                 default = nil)
  if valid_778371 != nil:
    section.add "Accept", valid_778371
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778372: Call_GetNetworksOwnerRepoEvents_778366; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List public events for a network of repositories.
  ## 
  let valid = call_778372.validator(path, query, header, formData, body)
  let scheme = call_778372.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778372.url(scheme.get, call_778372.host, call_778372.base,
                         call_778372.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778372, url, valid)

proc call*(call_778373: Call_GetNetworksOwnerRepoEvents_778366; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getNetworksOwnerRepoEvents
  ## List public events for a network of repositories.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of the owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778374 = newJObject()
  var header_778375 = newJObject()
  add(path_778374, "repo", newJString(repo))
  add(path_778374, "owner", newJString(owner))
  add(header_778375, "Accept", newJString(Accept))
  result = call_778373.call(path_778374, nil, header_778375, nil, nil)

var getNetworksOwnerRepoEvents* = Call_GetNetworksOwnerRepoEvents_778366(
    name: "getNetworksOwnerRepoEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/networks/{owner}/{repo}/events",
    validator: validate_GetNetworksOwnerRepoEvents_778367, base: "/",
    url: url_GetNetworksOwnerRepoEvents_778368, schemes: {Scheme.Https})
type
  Call_PutNotifications_778387 = ref object of OpenApiRestCall_777573
proc url_PutNotifications_778389(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PutNotifications_778388(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Mark as read.
  ## Marking a notification as "read" removes it from the default view on GitHub.com.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778390 = header.getOrDefault("Accept")
  valid_778390 = validateParameter(valid_778390, JString, required = false,
                                 default = nil)
  if valid_778390 != nil:
    section.add "Accept", valid_778390
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_778392: Call_PutNotifications_778387; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Mark as read.
  ## Marking a notification as "read" removes it from the default view on GitHub.com.
  ## 
  ## 
  let valid = call_778392.validator(path, query, header, formData, body)
  let scheme = call_778392.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778392.url(scheme.get, call_778392.host, call_778392.base,
                         call_778392.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778392, url, valid)

proc call*(call_778393: Call_PutNotifications_778387; body: JsonNode;
          Accept: string = ""): Recallable =
  ## putNotifications
  ## Mark as read.
  ## Marking a notification as "read" removes it from the default view on GitHub.com.
  ## 
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_778394 = newJObject()
  var body_778395 = newJObject()
  if body != nil:
    body_778395 = body
  add(header_778394, "Accept", newJString(Accept))
  result = call_778393.call(nil, nil, header_778394, nil, body_778395)

var putNotifications* = Call_PutNotifications_778387(name: "putNotifications",
    meth: HttpMethod.HttpPut, host: "api.github.com", route: "/notifications",
    validator: validate_PutNotifications_778388, base: "/",
    url: url_PutNotifications_778389, schemes: {Scheme.Https})
type
  Call_GetNotifications_778376 = ref object of OpenApiRestCall_777573
proc url_GetNotifications_778378(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetNotifications_778377(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## List your notifications.
  ## List all notifications for the current user, grouped by repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   all: JBool
  ##      : True to show notifications marked as read.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   participating: JBool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  section = newJObject()
  var valid_778379 = query.getOrDefault("all")
  valid_778379 = validateParameter(valid_778379, JBool, required = false, default = nil)
  if valid_778379 != nil:
    section.add "all", valid_778379
  var valid_778380 = query.getOrDefault("since")
  valid_778380 = validateParameter(valid_778380, JString, required = false,
                                 default = nil)
  if valid_778380 != nil:
    section.add "since", valid_778380
  var valid_778381 = query.getOrDefault("participating")
  valid_778381 = validateParameter(valid_778381, JBool, required = false, default = nil)
  if valid_778381 != nil:
    section.add "participating", valid_778381
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778382 = header.getOrDefault("Accept")
  valid_778382 = validateParameter(valid_778382, JString, required = false,
                                 default = nil)
  if valid_778382 != nil:
    section.add "Accept", valid_778382
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778383: Call_GetNotifications_778376; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List your notifications.
  ## List all notifications for the current user, grouped by repository.
  ## 
  ## 
  let valid = call_778383.validator(path, query, header, formData, body)
  let scheme = call_778383.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778383.url(scheme.get, call_778383.host, call_778383.base,
                         call_778383.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778383, url, valid)

proc call*(call_778384: Call_GetNotifications_778376; all: bool = false;
          since: string = ""; participating: bool = false; Accept: string = ""): Recallable =
  ## getNotifications
  ## List your notifications.
  ## List all notifications for the current user, grouped by repository.
  ## 
  ##   all: bool
  ##      : True to show notifications marked as read.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   participating: bool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var query_778385 = newJObject()
  var header_778386 = newJObject()
  add(query_778385, "all", newJBool(all))
  add(query_778385, "since", newJString(since))
  add(query_778385, "participating", newJBool(participating))
  add(header_778386, "Accept", newJString(Accept))
  result = call_778384.call(nil, query_778385, header_778386, nil, nil)

var getNotifications* = Call_GetNotifications_778376(name: "getNotifications",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/notifications",
    validator: validate_GetNotifications_778377, base: "/",
    url: url_GetNotifications_778378, schemes: {Scheme.Https})
type
  Call_GetNotificationsThreadsId_778396 = ref object of OpenApiRestCall_777573
proc url_GetNotificationsThreadsId_778398(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetNotificationsThreadsId_778397(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## View a single thread.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_778399 = path.getOrDefault("id")
  valid_778399 = validateParameter(valid_778399, JInt, required = true, default = nil)
  if valid_778399 != nil:
    section.add "id", valid_778399
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778400 = header.getOrDefault("Accept")
  valid_778400 = validateParameter(valid_778400, JString, required = false,
                                 default = nil)
  if valid_778400 != nil:
    section.add "Accept", valid_778400
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778401: Call_GetNotificationsThreadsId_778396; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## View a single thread.
  ## 
  let valid = call_778401.validator(path, query, header, formData, body)
  let scheme = call_778401.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778401.url(scheme.get, call_778401.host, call_778401.base,
                         call_778401.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778401, url, valid)

proc call*(call_778402: Call_GetNotificationsThreadsId_778396; id: int;
          Accept: string = ""): Recallable =
  ## getNotificationsThreadsId
  ## View a single thread.
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778403 = newJObject()
  var header_778404 = newJObject()
  add(path_778403, "id", newJInt(id))
  add(header_778404, "Accept", newJString(Accept))
  result = call_778402.call(path_778403, nil, header_778404, nil, nil)

var getNotificationsThreadsId* = Call_GetNotificationsThreadsId_778396(
    name: "getNotificationsThreadsId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/notifications/threads/{id}",
    validator: validate_GetNotificationsThreadsId_778397, base: "/",
    url: url_GetNotificationsThreadsId_778398, schemes: {Scheme.Https})
type
  Call_PatchNotificationsThreadsId_778405 = ref object of OpenApiRestCall_777573
proc url_PatchNotificationsThreadsId_778407(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchNotificationsThreadsId_778406(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Mark a thread as read
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_778408 = path.getOrDefault("id")
  valid_778408 = validateParameter(valid_778408, JInt, required = true, default = nil)
  if valid_778408 != nil:
    section.add "id", valid_778408
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778409 = header.getOrDefault("Accept")
  valid_778409 = validateParameter(valid_778409, JString, required = false,
                                 default = nil)
  if valid_778409 != nil:
    section.add "Accept", valid_778409
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778410: Call_PatchNotificationsThreadsId_778405; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Mark a thread as read
  ## 
  let valid = call_778410.validator(path, query, header, formData, body)
  let scheme = call_778410.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778410.url(scheme.get, call_778410.host, call_778410.base,
                         call_778410.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778410, url, valid)

proc call*(call_778411: Call_PatchNotificationsThreadsId_778405; id: int;
          Accept: string = ""): Recallable =
  ## patchNotificationsThreadsId
  ## Mark a thread as read
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778412 = newJObject()
  var header_778413 = newJObject()
  add(path_778412, "id", newJInt(id))
  add(header_778413, "Accept", newJString(Accept))
  result = call_778411.call(path_778412, nil, header_778413, nil, nil)

var patchNotificationsThreadsId* = Call_PatchNotificationsThreadsId_778405(
    name: "patchNotificationsThreadsId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/notifications/threads/{id}",
    validator: validate_PatchNotificationsThreadsId_778406, base: "/",
    url: url_PatchNotificationsThreadsId_778407, schemes: {Scheme.Https})
type
  Call_PutNotificationsThreadsIdSubscription_778423 = ref object of OpenApiRestCall_777573
proc url_PutNotificationsThreadsIdSubscription_778425(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutNotificationsThreadsIdSubscription_778424(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set a Thread Subscription.
  ## This lets you subscribe to a thread, or ignore it. Subscribing to a thread
  ## is unnecessary if the user is already subscribed to the repository. Ignoring
  ## a thread will mute all future notifications (until you comment or get @mentioned).
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_778426 = path.getOrDefault("id")
  valid_778426 = validateParameter(valid_778426, JInt, required = true, default = nil)
  if valid_778426 != nil:
    section.add "id", valid_778426
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778427 = header.getOrDefault("Accept")
  valid_778427 = validateParameter(valid_778427, JString, required = false,
                                 default = nil)
  if valid_778427 != nil:
    section.add "Accept", valid_778427
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_778429: Call_PutNotificationsThreadsIdSubscription_778423;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Set a Thread Subscription.
  ## This lets you subscribe to a thread, or ignore it. Subscribing to a thread
  ## is unnecessary if the user is already subscribed to the repository. Ignoring
  ## a thread will mute all future notifications (until you comment or get @mentioned).
  ## 
  ## 
  let valid = call_778429.validator(path, query, header, formData, body)
  let scheme = call_778429.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778429.url(scheme.get, call_778429.host, call_778429.base,
                         call_778429.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778429, url, valid)

proc call*(call_778430: Call_PutNotificationsThreadsIdSubscription_778423; id: int;
          body: JsonNode; Accept: string = ""): Recallable =
  ## putNotificationsThreadsIdSubscription
  ## Set a Thread Subscription.
  ## This lets you subscribe to a thread, or ignore it. Subscribing to a thread
  ## is unnecessary if the user is already subscribed to the repository. Ignoring
  ## a thread will mute all future notifications (until you comment or get @mentioned).
  ## 
  ##   id: int (required)
  ##     : Id of thread.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778431 = newJObject()
  var header_778432 = newJObject()
  var body_778433 = newJObject()
  add(path_778431, "id", newJInt(id))
  if body != nil:
    body_778433 = body
  add(header_778432, "Accept", newJString(Accept))
  result = call_778430.call(path_778431, nil, header_778432, nil, body_778433)

var putNotificationsThreadsIdSubscription* = Call_PutNotificationsThreadsIdSubscription_778423(
    name: "putNotificationsThreadsIdSubscription", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/notifications/threads/{id}/subscription",
    validator: validate_PutNotificationsThreadsIdSubscription_778424, base: "/",
    url: url_PutNotificationsThreadsIdSubscription_778425, schemes: {Scheme.Https})
type
  Call_GetNotificationsThreadsIdSubscription_778414 = ref object of OpenApiRestCall_777573
proc url_GetNotificationsThreadsIdSubscription_778416(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetNotificationsThreadsIdSubscription_778415(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a Thread Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_778417 = path.getOrDefault("id")
  valid_778417 = validateParameter(valid_778417, JInt, required = true, default = nil)
  if valid_778417 != nil:
    section.add "id", valid_778417
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778418 = header.getOrDefault("Accept")
  valid_778418 = validateParameter(valid_778418, JString, required = false,
                                 default = nil)
  if valid_778418 != nil:
    section.add "Accept", valid_778418
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778419: Call_GetNotificationsThreadsIdSubscription_778414;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a Thread Subscription.
  ## 
  let valid = call_778419.validator(path, query, header, formData, body)
  let scheme = call_778419.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778419.url(scheme.get, call_778419.host, call_778419.base,
                         call_778419.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778419, url, valid)

proc call*(call_778420: Call_GetNotificationsThreadsIdSubscription_778414; id: int;
          Accept: string = ""): Recallable =
  ## getNotificationsThreadsIdSubscription
  ## Get a Thread Subscription.
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778421 = newJObject()
  var header_778422 = newJObject()
  add(path_778421, "id", newJInt(id))
  add(header_778422, "Accept", newJString(Accept))
  result = call_778420.call(path_778421, nil, header_778422, nil, nil)

var getNotificationsThreadsIdSubscription* = Call_GetNotificationsThreadsIdSubscription_778414(
    name: "getNotificationsThreadsIdSubscription", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/notifications/threads/{id}/subscription",
    validator: validate_GetNotificationsThreadsIdSubscription_778415, base: "/",
    url: url_GetNotificationsThreadsIdSubscription_778416, schemes: {Scheme.Https})
type
  Call_DeleteNotificationsThreadsIdSubscription_778434 = ref object of OpenApiRestCall_777573
proc url_DeleteNotificationsThreadsIdSubscription_778436(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteNotificationsThreadsIdSubscription_778435(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a Thread Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_778437 = path.getOrDefault("id")
  valid_778437 = validateParameter(valid_778437, JInt, required = true, default = nil)
  if valid_778437 != nil:
    section.add "id", valid_778437
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778438 = header.getOrDefault("Accept")
  valid_778438 = validateParameter(valid_778438, JString, required = false,
                                 default = nil)
  if valid_778438 != nil:
    section.add "Accept", valid_778438
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778439: Call_DeleteNotificationsThreadsIdSubscription_778434;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a Thread Subscription.
  ## 
  let valid = call_778439.validator(path, query, header, formData, body)
  let scheme = call_778439.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778439.url(scheme.get, call_778439.host, call_778439.base,
                         call_778439.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778439, url, valid)

proc call*(call_778440: Call_DeleteNotificationsThreadsIdSubscription_778434;
          id: int; Accept: string = ""): Recallable =
  ## deleteNotificationsThreadsIdSubscription
  ## Delete a Thread Subscription.
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778441 = newJObject()
  var header_778442 = newJObject()
  add(path_778441, "id", newJInt(id))
  add(header_778442, "Accept", newJString(Accept))
  result = call_778440.call(path_778441, nil, header_778442, nil, nil)

var deleteNotificationsThreadsIdSubscription* = Call_DeleteNotificationsThreadsIdSubscription_778434(
    name: "deleteNotificationsThreadsIdSubscription", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/notifications/threads/{id}/subscription",
    validator: validate_DeleteNotificationsThreadsIdSubscription_778435,
    base: "/", url: url_DeleteNotificationsThreadsIdSubscription_778436,
    schemes: {Scheme.Https})
type
  Call_GetOrgsOrg_778443 = ref object of OpenApiRestCall_777573
proc url_GetOrgsOrg_778445(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrg_778444(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode): JsonNode =
  ## Get an Organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_778446 = path.getOrDefault("org")
  valid_778446 = validateParameter(valid_778446, JString, required = true,
                                 default = nil)
  if valid_778446 != nil:
    section.add "org", valid_778446
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778447 = header.getOrDefault("Accept")
  valid_778447 = validateParameter(valid_778447, JString, required = false,
                                 default = nil)
  if valid_778447 != nil:
    section.add "Accept", valid_778447
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778448: Call_GetOrgsOrg_778443; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get an Organization.
  ## 
  let valid = call_778448.validator(path, query, header, formData, body)
  let scheme = call_778448.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778448.url(scheme.get, call_778448.host, call_778448.base,
                         call_778448.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778448, url, valid)

proc call*(call_778449: Call_GetOrgsOrg_778443; org: string; Accept: string = ""): Recallable =
  ## getOrgsOrg
  ## Get an Organization.
  ##   org: string (required)
  ##      : Name of organisation.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778450 = newJObject()
  var header_778451 = newJObject()
  add(path_778450, "org", newJString(org))
  add(header_778451, "Accept", newJString(Accept))
  result = call_778449.call(path_778450, nil, header_778451, nil, nil)

var getOrgsOrg* = Call_GetOrgsOrg_778443(name: "getOrgsOrg",
                                      meth: HttpMethod.HttpGet,
                                      host: "api.github.com",
                                      route: "/orgs/{org}",
                                      validator: validate_GetOrgsOrg_778444,
                                      base: "/", url: url_GetOrgsOrg_778445,
                                      schemes: {Scheme.Https})
type
  Call_PatchOrgsOrg_778452 = ref object of OpenApiRestCall_777573
proc url_PatchOrgsOrg_778454(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchOrgsOrg_778453(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Edit an Organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_778455 = path.getOrDefault("org")
  valid_778455 = validateParameter(valid_778455, JString, required = true,
                                 default = nil)
  if valid_778455 != nil:
    section.add "org", valid_778455
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778456 = header.getOrDefault("Accept")
  valid_778456 = validateParameter(valid_778456, JString, required = false,
                                 default = nil)
  if valid_778456 != nil:
    section.add "Accept", valid_778456
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_778458: Call_PatchOrgsOrg_778452; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Edit an Organization.
  ## 
  let valid = call_778458.validator(path, query, header, formData, body)
  let scheme = call_778458.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778458.url(scheme.get, call_778458.host, call_778458.base,
                         call_778458.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778458, url, valid)

proc call*(call_778459: Call_PatchOrgsOrg_778452; org: string; body: JsonNode;
          Accept: string = ""): Recallable =
  ## patchOrgsOrg
  ## Edit an Organization.
  ##   org: string (required)
  ##      : Name of organisation.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778460 = newJObject()
  var header_778461 = newJObject()
  var body_778462 = newJObject()
  add(path_778460, "org", newJString(org))
  if body != nil:
    body_778462 = body
  add(header_778461, "Accept", newJString(Accept))
  result = call_778459.call(path_778460, nil, header_778461, nil, body_778462)

var patchOrgsOrg* = Call_PatchOrgsOrg_778452(name: "patchOrgsOrg",
    meth: HttpMethod.HttpPatch, host: "api.github.com", route: "/orgs/{org}",
    validator: validate_PatchOrgsOrg_778453, base: "/", url: url_PatchOrgsOrg_778454,
    schemes: {Scheme.Https})
type
  Call_GetOrgsOrgEvents_778463 = ref object of OpenApiRestCall_777573
proc url_GetOrgsOrgEvents_778465(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgEvents_778464(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## List public events for an organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_778466 = path.getOrDefault("org")
  valid_778466 = validateParameter(valid_778466, JString, required = true,
                                 default = nil)
  if valid_778466 != nil:
    section.add "org", valid_778466
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778467 = header.getOrDefault("Accept")
  valid_778467 = validateParameter(valid_778467, JString, required = false,
                                 default = nil)
  if valid_778467 != nil:
    section.add "Accept", valid_778467
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778468: Call_GetOrgsOrgEvents_778463; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List public events for an organization.
  ## 
  let valid = call_778468.validator(path, query, header, formData, body)
  let scheme = call_778468.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778468.url(scheme.get, call_778468.host, call_778468.base,
                         call_778468.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778468, url, valid)

proc call*(call_778469: Call_GetOrgsOrgEvents_778463; org: string;
          Accept: string = ""): Recallable =
  ## getOrgsOrgEvents
  ## List public events for an organization.
  ##   org: string (required)
  ##      : Name of organisation.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778470 = newJObject()
  var header_778471 = newJObject()
  add(path_778470, "org", newJString(org))
  add(header_778471, "Accept", newJString(Accept))
  result = call_778469.call(path_778470, nil, header_778471, nil, nil)

var getOrgsOrgEvents* = Call_GetOrgsOrgEvents_778463(name: "getOrgsOrgEvents",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/events",
    validator: validate_GetOrgsOrgEvents_778464, base: "/",
    url: url_GetOrgsOrgEvents_778465, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgIssues_778472 = ref object of OpenApiRestCall_777573
proc url_GetOrgsOrgIssues_778474(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/issues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgIssues_778473(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## List issues.
  ## List all issues for a given organization for the authenticated user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_778475 = path.getOrDefault("org")
  valid_778475 = validateParameter(valid_778475, JString, required = true,
                                 default = nil)
  if valid_778475 != nil:
    section.add "org", valid_778475
  result.add "path", section
  ## parameters in `query` object:
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   direction: JString (required)
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  ##   state: JString (required)
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   sort: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `labels` field"
  var valid_778476 = query.getOrDefault("labels")
  valid_778476 = validateParameter(valid_778476, JString, required = true,
                                 default = nil)
  if valid_778476 != nil:
    section.add "labels", valid_778476
  var valid_778477 = query.getOrDefault("direction")
  valid_778477 = validateParameter(valid_778477, JString, required = true,
                                 default = newJString("desc"))
  if valid_778477 != nil:
    section.add "direction", valid_778477
  var valid_778478 = query.getOrDefault("since")
  valid_778478 = validateParameter(valid_778478, JString, required = false,
                                 default = nil)
  if valid_778478 != nil:
    section.add "since", valid_778478
  var valid_778479 = query.getOrDefault("state")
  valid_778479 = validateParameter(valid_778479, JString, required = true,
                                 default = newJString("open"))
  if valid_778479 != nil:
    section.add "state", valid_778479
  var valid_778480 = query.getOrDefault("filter")
  valid_778480 = validateParameter(valid_778480, JString, required = true,
                                 default = newJString("all"))
  if valid_778480 != nil:
    section.add "filter", valid_778480
  var valid_778481 = query.getOrDefault("sort")
  valid_778481 = validateParameter(valid_778481, JString, required = true,
                                 default = newJString("created"))
  if valid_778481 != nil:
    section.add "sort", valid_778481
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778482 = header.getOrDefault("Accept")
  valid_778482 = validateParameter(valid_778482, JString, required = false,
                                 default = nil)
  if valid_778482 != nil:
    section.add "Accept", valid_778482
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778483: Call_GetOrgsOrgIssues_778472; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List issues.
  ## List all issues for a given organization for the authenticated user.
  ## 
  ## 
  let valid = call_778483.validator(path, query, header, formData, body)
  let scheme = call_778483.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778483.url(scheme.get, call_778483.host, call_778483.base,
                         call_778483.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778483, url, valid)

proc call*(call_778484: Call_GetOrgsOrgIssues_778472; labels: string; org: string;
          direction: string = "desc"; since: string = ""; state: string = "open";
          filter: string = "all"; Accept: string = ""; sort: string = "created"): Recallable =
  ## getOrgsOrgIssues
  ## List issues.
  ## List all issues for a given organization for the authenticated user.
  ## 
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   direction: string (required)
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  ##   state: string (required)
  ##   org: string (required)
  ##      : Name of organisation.
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string (required)
  var path_778485 = newJObject()
  var query_778486 = newJObject()
  var header_778487 = newJObject()
  add(query_778486, "labels", newJString(labels))
  add(query_778486, "direction", newJString(direction))
  add(query_778486, "since", newJString(since))
  add(query_778486, "state", newJString(state))
  add(path_778485, "org", newJString(org))
  add(query_778486, "filter", newJString(filter))
  add(header_778487, "Accept", newJString(Accept))
  add(query_778486, "sort", newJString(sort))
  result = call_778484.call(path_778485, query_778486, header_778487, nil, nil)

var getOrgsOrgIssues* = Call_GetOrgsOrgIssues_778472(name: "getOrgsOrgIssues",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/issues",
    validator: validate_GetOrgsOrgIssues_778473, base: "/",
    url: url_GetOrgsOrgIssues_778474, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgMembers_778488 = ref object of OpenApiRestCall_777573
proc url_GetOrgsOrgMembers_778490(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/members")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgMembers_778489(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Members list.
  ## List all users who are members of an organization. A member is a user tha
  ## belongs to at least 1 team in the organization. If the authenticated user
  ## is also an owner of this organization then both concealed and public members
  ## will be returned. If the requester is not an owner of the organization the
  ## query will be redirected to the public members list.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_778491 = path.getOrDefault("org")
  valid_778491 = validateParameter(valid_778491, JString, required = true,
                                 default = nil)
  if valid_778491 != nil:
    section.add "org", valid_778491
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778492 = header.getOrDefault("Accept")
  valid_778492 = validateParameter(valid_778492, JString, required = false,
                                 default = nil)
  if valid_778492 != nil:
    section.add "Accept", valid_778492
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778493: Call_GetOrgsOrgMembers_778488; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Members list.
  ## List all users who are members of an organization. A member is a user tha
  ## belongs to at least 1 team in the organization. If the authenticated user
  ## is also an owner of this organization then both concealed and public members
  ## will be returned. If the requester is not an owner of the organization the
  ## query will be redirected to the public members list.
  ## 
  ## 
  let valid = call_778493.validator(path, query, header, formData, body)
  let scheme = call_778493.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778493.url(scheme.get, call_778493.host, call_778493.base,
                         call_778493.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778493, url, valid)

proc call*(call_778494: Call_GetOrgsOrgMembers_778488; org: string;
          Accept: string = ""): Recallable =
  ## getOrgsOrgMembers
  ## Members list.
  ## List all users who are members of an organization. A member is a user tha
  ## belongs to at least 1 team in the organization. If the authenticated user
  ## is also an owner of this organization then both concealed and public members
  ## will be returned. If the requester is not an owner of the organization the
  ## query will be redirected to the public members list.
  ## 
  ##   org: string (required)
  ##      : Name of organisation.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778495 = newJObject()
  var header_778496 = newJObject()
  add(path_778495, "org", newJString(org))
  add(header_778496, "Accept", newJString(Accept))
  result = call_778494.call(path_778495, nil, header_778496, nil, nil)

var getOrgsOrgMembers* = Call_GetOrgsOrgMembers_778488(name: "getOrgsOrgMembers",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/members",
    validator: validate_GetOrgsOrgMembers_778489, base: "/",
    url: url_GetOrgsOrgMembers_778490, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgMembersUsername_778497 = ref object of OpenApiRestCall_777573
proc url_GetOrgsOrgMembersUsername_778499(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgMembersUsername_778498(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Check if a user is, publicly or privately, a member of the organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  ##   username: JString (required)
  ##           : Name of the user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_778500 = path.getOrDefault("org")
  valid_778500 = validateParameter(valid_778500, JString, required = true,
                                 default = nil)
  if valid_778500 != nil:
    section.add "org", valid_778500
  var valid_778501 = path.getOrDefault("username")
  valid_778501 = validateParameter(valid_778501, JString, required = true,
                                 default = nil)
  if valid_778501 != nil:
    section.add "username", valid_778501
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778502 = header.getOrDefault("Accept")
  valid_778502 = validateParameter(valid_778502, JString, required = false,
                                 default = nil)
  if valid_778502 != nil:
    section.add "Accept", valid_778502
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778503: Call_GetOrgsOrgMembersUsername_778497; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Check if a user is, publicly or privately, a member of the organization.
  ## 
  let valid = call_778503.validator(path, query, header, formData, body)
  let scheme = call_778503.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778503.url(scheme.get, call_778503.host, call_778503.base,
                         call_778503.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778503, url, valid)

proc call*(call_778504: Call_GetOrgsOrgMembersUsername_778497; org: string;
          username: string; Accept: string = ""): Recallable =
  ## getOrgsOrgMembersUsername
  ## Check if a user is, publicly or privately, a member of the organization.
  ##   org: string (required)
  ##      : Name of organisation.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778505 = newJObject()
  var header_778506 = newJObject()
  add(path_778505, "org", newJString(org))
  add(path_778505, "username", newJString(username))
  add(header_778506, "Accept", newJString(Accept))
  result = call_778504.call(path_778505, nil, header_778506, nil, nil)

var getOrgsOrgMembersUsername* = Call_GetOrgsOrgMembersUsername_778497(
    name: "getOrgsOrgMembersUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/orgs/{org}/members/{username}",
    validator: validate_GetOrgsOrgMembersUsername_778498, base: "/",
    url: url_GetOrgsOrgMembersUsername_778499, schemes: {Scheme.Https})
type
  Call_DeleteOrgsOrgMembersUsername_778507 = ref object of OpenApiRestCall_777573
proc url_DeleteOrgsOrgMembersUsername_778509(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteOrgsOrgMembersUsername_778508(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Remove a member.
  ## Removing a user from this list will remove them from all teams and they
  ## will no longer have any access to the organization's repositories.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  ##   username: JString (required)
  ##           : Name of the user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_778510 = path.getOrDefault("org")
  valid_778510 = validateParameter(valid_778510, JString, required = true,
                                 default = nil)
  if valid_778510 != nil:
    section.add "org", valid_778510
  var valid_778511 = path.getOrDefault("username")
  valid_778511 = validateParameter(valid_778511, JString, required = true,
                                 default = nil)
  if valid_778511 != nil:
    section.add "username", valid_778511
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778512 = header.getOrDefault("Accept")
  valid_778512 = validateParameter(valid_778512, JString, required = false,
                                 default = nil)
  if valid_778512 != nil:
    section.add "Accept", valid_778512
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778513: Call_DeleteOrgsOrgMembersUsername_778507; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Remove a member.
  ## Removing a user from this list will remove them from all teams and they
  ## will no longer have any access to the organization's repositories.
  ## 
  ## 
  let valid = call_778513.validator(path, query, header, formData, body)
  let scheme = call_778513.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778513.url(scheme.get, call_778513.host, call_778513.base,
                         call_778513.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778513, url, valid)

proc call*(call_778514: Call_DeleteOrgsOrgMembersUsername_778507; org: string;
          username: string; Accept: string = ""): Recallable =
  ## deleteOrgsOrgMembersUsername
  ## Remove a member.
  ## Removing a user from this list will remove them from all teams and they
  ## will no longer have any access to the organization's repositories.
  ## 
  ##   org: string (required)
  ##      : Name of organisation.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778515 = newJObject()
  var header_778516 = newJObject()
  add(path_778515, "org", newJString(org))
  add(path_778515, "username", newJString(username))
  add(header_778516, "Accept", newJString(Accept))
  result = call_778514.call(path_778515, nil, header_778516, nil, nil)

var deleteOrgsOrgMembersUsername* = Call_DeleteOrgsOrgMembersUsername_778507(
    name: "deleteOrgsOrgMembersUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/orgs/{org}/members/{username}",
    validator: validate_DeleteOrgsOrgMembersUsername_778508, base: "/",
    url: url_DeleteOrgsOrgMembersUsername_778509, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgPublicMembers_778517 = ref object of OpenApiRestCall_777573
proc url_GetOrgsOrgPublicMembers_778519(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/public_members")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgPublicMembers_778518(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Public members list.
  ## Members of an organization can choose to have their membership publicized
  ## or not.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_778520 = path.getOrDefault("org")
  valid_778520 = validateParameter(valid_778520, JString, required = true,
                                 default = nil)
  if valid_778520 != nil:
    section.add "org", valid_778520
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778521 = header.getOrDefault("Accept")
  valid_778521 = validateParameter(valid_778521, JString, required = false,
                                 default = nil)
  if valid_778521 != nil:
    section.add "Accept", valid_778521
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778522: Call_GetOrgsOrgPublicMembers_778517; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Public members list.
  ## Members of an organization can choose to have their membership publicized
  ## or not.
  ## 
  ## 
  let valid = call_778522.validator(path, query, header, formData, body)
  let scheme = call_778522.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778522.url(scheme.get, call_778522.host, call_778522.base,
                         call_778522.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778522, url, valid)

proc call*(call_778523: Call_GetOrgsOrgPublicMembers_778517; org: string;
          Accept: string = ""): Recallable =
  ## getOrgsOrgPublicMembers
  ## Public members list.
  ## Members of an organization can choose to have their membership publicized
  ## or not.
  ## 
  ##   org: string (required)
  ##      : Name of organisation.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778524 = newJObject()
  var header_778525 = newJObject()
  add(path_778524, "org", newJString(org))
  add(header_778525, "Accept", newJString(Accept))
  result = call_778523.call(path_778524, nil, header_778525, nil, nil)

var getOrgsOrgPublicMembers* = Call_GetOrgsOrgPublicMembers_778517(
    name: "getOrgsOrgPublicMembers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/orgs/{org}/public_members",
    validator: validate_GetOrgsOrgPublicMembers_778518, base: "/",
    url: url_GetOrgsOrgPublicMembers_778519, schemes: {Scheme.Https})
type
  Call_PutOrgsOrgPublicMembersUsername_778536 = ref object of OpenApiRestCall_777573
proc url_PutOrgsOrgPublicMembersUsername_778538(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/public_members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutOrgsOrgPublicMembersUsername_778537(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Publicize a user's membership.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  ##   username: JString (required)
  ##           : Name of the user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_778539 = path.getOrDefault("org")
  valid_778539 = validateParameter(valid_778539, JString, required = true,
                                 default = nil)
  if valid_778539 != nil:
    section.add "org", valid_778539
  var valid_778540 = path.getOrDefault("username")
  valid_778540 = validateParameter(valid_778540, JString, required = true,
                                 default = nil)
  if valid_778540 != nil:
    section.add "username", valid_778540
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778541 = header.getOrDefault("Accept")
  valid_778541 = validateParameter(valid_778541, JString, required = false,
                                 default = nil)
  if valid_778541 != nil:
    section.add "Accept", valid_778541
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778542: Call_PutOrgsOrgPublicMembersUsername_778536;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Publicize a user's membership.
  ## 
  let valid = call_778542.validator(path, query, header, formData, body)
  let scheme = call_778542.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778542.url(scheme.get, call_778542.host, call_778542.base,
                         call_778542.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778542, url, valid)

proc call*(call_778543: Call_PutOrgsOrgPublicMembersUsername_778536; org: string;
          username: string; Accept: string = ""): Recallable =
  ## putOrgsOrgPublicMembersUsername
  ## Publicize a user's membership.
  ##   org: string (required)
  ##      : Name of organisation.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778544 = newJObject()
  var header_778545 = newJObject()
  add(path_778544, "org", newJString(org))
  add(path_778544, "username", newJString(username))
  add(header_778545, "Accept", newJString(Accept))
  result = call_778543.call(path_778544, nil, header_778545, nil, nil)

var putOrgsOrgPublicMembersUsername* = Call_PutOrgsOrgPublicMembersUsername_778536(
    name: "putOrgsOrgPublicMembersUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/orgs/{org}/public_members/{username}",
    validator: validate_PutOrgsOrgPublicMembersUsername_778537, base: "/",
    url: url_PutOrgsOrgPublicMembersUsername_778538, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgPublicMembersUsername_778526 = ref object of OpenApiRestCall_777573
proc url_GetOrgsOrgPublicMembersUsername_778528(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/public_members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgPublicMembersUsername_778527(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Check public membership.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  ##   username: JString (required)
  ##           : Name of the user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_778529 = path.getOrDefault("org")
  valid_778529 = validateParameter(valid_778529, JString, required = true,
                                 default = nil)
  if valid_778529 != nil:
    section.add "org", valid_778529
  var valid_778530 = path.getOrDefault("username")
  valid_778530 = validateParameter(valid_778530, JString, required = true,
                                 default = nil)
  if valid_778530 != nil:
    section.add "username", valid_778530
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778531 = header.getOrDefault("Accept")
  valid_778531 = validateParameter(valid_778531, JString, required = false,
                                 default = nil)
  if valid_778531 != nil:
    section.add "Accept", valid_778531
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778532: Call_GetOrgsOrgPublicMembersUsername_778526;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Check public membership.
  ## 
  let valid = call_778532.validator(path, query, header, formData, body)
  let scheme = call_778532.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778532.url(scheme.get, call_778532.host, call_778532.base,
                         call_778532.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778532, url, valid)

proc call*(call_778533: Call_GetOrgsOrgPublicMembersUsername_778526; org: string;
          username: string; Accept: string = ""): Recallable =
  ## getOrgsOrgPublicMembersUsername
  ## Check public membership.
  ##   org: string (required)
  ##      : Name of organisation.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778534 = newJObject()
  var header_778535 = newJObject()
  add(path_778534, "org", newJString(org))
  add(path_778534, "username", newJString(username))
  add(header_778535, "Accept", newJString(Accept))
  result = call_778533.call(path_778534, nil, header_778535, nil, nil)

var getOrgsOrgPublicMembersUsername* = Call_GetOrgsOrgPublicMembersUsername_778526(
    name: "getOrgsOrgPublicMembersUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/orgs/{org}/public_members/{username}",
    validator: validate_GetOrgsOrgPublicMembersUsername_778527, base: "/",
    url: url_GetOrgsOrgPublicMembersUsername_778528, schemes: {Scheme.Https})
type
  Call_DeleteOrgsOrgPublicMembersUsername_778546 = ref object of OpenApiRestCall_777573
proc url_DeleteOrgsOrgPublicMembersUsername_778548(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/public_members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteOrgsOrgPublicMembersUsername_778547(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Conceal a user's membership.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  ##   username: JString (required)
  ##           : Name of the user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_778549 = path.getOrDefault("org")
  valid_778549 = validateParameter(valid_778549, JString, required = true,
                                 default = nil)
  if valid_778549 != nil:
    section.add "org", valid_778549
  var valid_778550 = path.getOrDefault("username")
  valid_778550 = validateParameter(valid_778550, JString, required = true,
                                 default = nil)
  if valid_778550 != nil:
    section.add "username", valid_778550
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778551 = header.getOrDefault("Accept")
  valid_778551 = validateParameter(valid_778551, JString, required = false,
                                 default = nil)
  if valid_778551 != nil:
    section.add "Accept", valid_778551
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778552: Call_DeleteOrgsOrgPublicMembersUsername_778546;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Conceal a user's membership.
  ## 
  let valid = call_778552.validator(path, query, header, formData, body)
  let scheme = call_778552.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778552.url(scheme.get, call_778552.host, call_778552.base,
                         call_778552.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778552, url, valid)

proc call*(call_778553: Call_DeleteOrgsOrgPublicMembersUsername_778546;
          org: string; username: string; Accept: string = ""): Recallable =
  ## deleteOrgsOrgPublicMembersUsername
  ## Conceal a user's membership.
  ##   org: string (required)
  ##      : Name of organisation.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778554 = newJObject()
  var header_778555 = newJObject()
  add(path_778554, "org", newJString(org))
  add(path_778554, "username", newJString(username))
  add(header_778555, "Accept", newJString(Accept))
  result = call_778553.call(path_778554, nil, header_778555, nil, nil)

var deleteOrgsOrgPublicMembersUsername* = Call_DeleteOrgsOrgPublicMembersUsername_778546(
    name: "deleteOrgsOrgPublicMembersUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/orgs/{org}/public_members/{username}",
    validator: validate_DeleteOrgsOrgPublicMembersUsername_778547, base: "/",
    url: url_DeleteOrgsOrgPublicMembersUsername_778548, schemes: {Scheme.Https})
type
  Call_PostOrgsOrgRepos_778567 = ref object of OpenApiRestCall_777573
proc url_PostOrgsOrgRepos_778569(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostOrgsOrgRepos_778568(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_778570 = path.getOrDefault("org")
  valid_778570 = validateParameter(valid_778570, JString, required = true,
                                 default = nil)
  if valid_778570 != nil:
    section.add "org", valid_778570
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778571 = header.getOrDefault("Accept")
  valid_778571 = validateParameter(valid_778571, JString, required = false,
                                 default = nil)
  if valid_778571 != nil:
    section.add "Accept", valid_778571
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_778573: Call_PostOrgsOrgRepos_778567; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  let valid = call_778573.validator(path, query, header, formData, body)
  let scheme = call_778573.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778573.url(scheme.get, call_778573.host, call_778573.base,
                         call_778573.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778573, url, valid)

proc call*(call_778574: Call_PostOrgsOrgRepos_778567; org: string; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postOrgsOrgRepos
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ##   org: string (required)
  ##      : Name of organisation.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778575 = newJObject()
  var header_778576 = newJObject()
  var body_778577 = newJObject()
  add(path_778575, "org", newJString(org))
  if body != nil:
    body_778577 = body
  add(header_778576, "Accept", newJString(Accept))
  result = call_778574.call(path_778575, nil, header_778576, nil, body_778577)

var postOrgsOrgRepos* = Call_PostOrgsOrgRepos_778567(name: "postOrgsOrgRepos",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/orgs/{org}/repos",
    validator: validate_PostOrgsOrgRepos_778568, base: "/",
    url: url_PostOrgsOrgRepos_778569, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgRepos_778556 = ref object of OpenApiRestCall_777573
proc url_GetOrgsOrgRepos_778558(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgRepos_778557(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## List repositories for the specified org.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_778559 = path.getOrDefault("org")
  valid_778559 = validateParameter(valid_778559, JString, required = true,
                                 default = nil)
  if valid_778559 != nil:
    section.add "org", valid_778559
  result.add "path", section
  ## parameters in `query` object:
  ##   type: JString
  section = newJObject()
  var valid_778560 = query.getOrDefault("type")
  valid_778560 = validateParameter(valid_778560, JString, required = false,
                                 default = newJString("all"))
  if valid_778560 != nil:
    section.add "type", valid_778560
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778561 = header.getOrDefault("Accept")
  valid_778561 = validateParameter(valid_778561, JString, required = false,
                                 default = nil)
  if valid_778561 != nil:
    section.add "Accept", valid_778561
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778562: Call_GetOrgsOrgRepos_778556; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List repositories for the specified org.
  ## 
  let valid = call_778562.validator(path, query, header, formData, body)
  let scheme = call_778562.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778562.url(scheme.get, call_778562.host, call_778562.base,
                         call_778562.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778562, url, valid)

proc call*(call_778563: Call_GetOrgsOrgRepos_778556; org: string;
          `type`: string = "all"; Accept: string = ""): Recallable =
  ## getOrgsOrgRepos
  ## List repositories for the specified org.
  ##   org: string (required)
  ##      : Name of organisation.
  ##   type: string
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778564 = newJObject()
  var query_778565 = newJObject()
  var header_778566 = newJObject()
  add(path_778564, "org", newJString(org))
  add(query_778565, "type", newJString(`type`))
  add(header_778566, "Accept", newJString(Accept))
  result = call_778563.call(path_778564, query_778565, header_778566, nil, nil)

var getOrgsOrgRepos* = Call_GetOrgsOrgRepos_778556(name: "getOrgsOrgRepos",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/repos",
    validator: validate_GetOrgsOrgRepos_778557, base: "/", url: url_GetOrgsOrgRepos_778558,
    schemes: {Scheme.Https})
type
  Call_PostOrgsOrgTeams_778587 = ref object of OpenApiRestCall_777573
proc url_PostOrgsOrgTeams_778589(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/teams")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostOrgsOrgTeams_778588(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Create team.
  ## In order to create a team, the authenticated user must be an owner of organization.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_778590 = path.getOrDefault("org")
  valid_778590 = validateParameter(valid_778590, JString, required = true,
                                 default = nil)
  if valid_778590 != nil:
    section.add "org", valid_778590
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778591 = header.getOrDefault("Accept")
  valid_778591 = validateParameter(valid_778591, JString, required = false,
                                 default = nil)
  if valid_778591 != nil:
    section.add "Accept", valid_778591
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_778593: Call_PostOrgsOrgTeams_778587; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create team.
  ## In order to create a team, the authenticated user must be an owner of organization.
  ## 
  ## 
  let valid = call_778593.validator(path, query, header, formData, body)
  let scheme = call_778593.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778593.url(scheme.get, call_778593.host, call_778593.base,
                         call_778593.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778593, url, valid)

proc call*(call_778594: Call_PostOrgsOrgTeams_778587; org: string; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postOrgsOrgTeams
  ## Create team.
  ## In order to create a team, the authenticated user must be an owner of organization.
  ## 
  ##   org: string (required)
  ##      : Name of organisation.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778595 = newJObject()
  var header_778596 = newJObject()
  var body_778597 = newJObject()
  add(path_778595, "org", newJString(org))
  if body != nil:
    body_778597 = body
  add(header_778596, "Accept", newJString(Accept))
  result = call_778594.call(path_778595, nil, header_778596, nil, body_778597)

var postOrgsOrgTeams* = Call_PostOrgsOrgTeams_778587(name: "postOrgsOrgTeams",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/orgs/{org}/teams",
    validator: validate_PostOrgsOrgTeams_778588, base: "/",
    url: url_PostOrgsOrgTeams_778589, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgTeams_778578 = ref object of OpenApiRestCall_777573
proc url_GetOrgsOrgTeams_778580(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/teams")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgTeams_778579(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## List teams.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_778581 = path.getOrDefault("org")
  valid_778581 = validateParameter(valid_778581, JString, required = true,
                                 default = nil)
  if valid_778581 != nil:
    section.add "org", valid_778581
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778582 = header.getOrDefault("Accept")
  valid_778582 = validateParameter(valid_778582, JString, required = false,
                                 default = nil)
  if valid_778582 != nil:
    section.add "Accept", valid_778582
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778583: Call_GetOrgsOrgTeams_778578; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List teams.
  ## 
  let valid = call_778583.validator(path, query, header, formData, body)
  let scheme = call_778583.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778583.url(scheme.get, call_778583.host, call_778583.base,
                         call_778583.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778583, url, valid)

proc call*(call_778584: Call_GetOrgsOrgTeams_778578; org: string; Accept: string = ""): Recallable =
  ## getOrgsOrgTeams
  ## List teams.
  ##   org: string (required)
  ##      : Name of organisation.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778585 = newJObject()
  var header_778586 = newJObject()
  add(path_778585, "org", newJString(org))
  add(header_778586, "Accept", newJString(Accept))
  result = call_778584.call(path_778585, nil, header_778586, nil, nil)

var getOrgsOrgTeams* = Call_GetOrgsOrgTeams_778578(name: "getOrgsOrgTeams",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/teams",
    validator: validate_GetOrgsOrgTeams_778579, base: "/", url: url_GetOrgsOrgTeams_778580,
    schemes: {Scheme.Https})
type
  Call_GetRateLimit_778598 = ref object of OpenApiRestCall_777573
proc url_GetRateLimit_778600(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRateLimit_778599(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Get your current rate limit status
  ## Note: Accessing this endpoint does not count against your rate limit.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778601 = header.getOrDefault("Accept")
  valid_778601 = validateParameter(valid_778601, JString, required = false,
                                 default = nil)
  if valid_778601 != nil:
    section.add "Accept", valid_778601
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778602: Call_GetRateLimit_778598; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get your current rate limit status
  ## Note: Accessing this endpoint does not count against your rate limit.
  ## 
  ## 
  let valid = call_778602.validator(path, query, header, formData, body)
  let scheme = call_778602.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778602.url(scheme.get, call_778602.host, call_778602.base,
                         call_778602.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778602, url, valid)

proc call*(call_778603: Call_GetRateLimit_778598; Accept: string = ""): Recallable =
  ## getRateLimit
  ## Get your current rate limit status
  ## Note: Accessing this endpoint does not count against your rate limit.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_778604 = newJObject()
  add(header_778604, "Accept", newJString(Accept))
  result = call_778603.call(nil, nil, header_778604, nil, nil)

var getRateLimit* = Call_GetRateLimit_778598(name: "getRateLimit",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/rate_limit",
    validator: validate_GetRateLimit_778599, base: "/", url: url_GetRateLimit_778600,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepo_778605 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepo_778607(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepo_778606(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Get repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778608 = path.getOrDefault("repo")
  valid_778608 = validateParameter(valid_778608, JString, required = true,
                                 default = nil)
  if valid_778608 != nil:
    section.add "repo", valid_778608
  var valid_778609 = path.getOrDefault("owner")
  valid_778609 = validateParameter(valid_778609, JString, required = true,
                                 default = nil)
  if valid_778609 != nil:
    section.add "owner", valid_778609
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778610 = header.getOrDefault("Accept")
  valid_778610 = validateParameter(valid_778610, JString, required = false,
                                 default = nil)
  if valid_778610 != nil:
    section.add "Accept", valid_778610
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778611: Call_GetReposOwnerRepo_778605; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get repository.
  ## 
  let valid = call_778611.validator(path, query, header, formData, body)
  let scheme = call_778611.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778611.url(scheme.get, call_778611.host, call_778611.base,
                         call_778611.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778611, url, valid)

proc call*(call_778612: Call_GetReposOwnerRepo_778605; repo: string; owner: string;
          Accept: string = ""): Recallable =
  ## getReposOwnerRepo
  ## Get repository.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778613 = newJObject()
  var header_778614 = newJObject()
  add(path_778613, "repo", newJString(repo))
  add(path_778613, "owner", newJString(owner))
  add(header_778614, "Accept", newJString(Accept))
  result = call_778612.call(path_778613, nil, header_778614, nil, nil)

var getReposOwnerRepo* = Call_GetReposOwnerRepo_778605(name: "getReposOwnerRepo",
    meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/repos/{owner}/{repo}", validator: validate_GetReposOwnerRepo_778606,
    base: "/", url: url_GetReposOwnerRepo_778607, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepo_778625 = ref object of OpenApiRestCall_777573
proc url_PatchReposOwnerRepo_778627(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepo_778626(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Edit repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778628 = path.getOrDefault("repo")
  valid_778628 = validateParameter(valid_778628, JString, required = true,
                                 default = nil)
  if valid_778628 != nil:
    section.add "repo", valid_778628
  var valid_778629 = path.getOrDefault("owner")
  valid_778629 = validateParameter(valid_778629, JString, required = true,
                                 default = nil)
  if valid_778629 != nil:
    section.add "owner", valid_778629
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778630 = header.getOrDefault("Accept")
  valid_778630 = validateParameter(valid_778630, JString, required = false,
                                 default = nil)
  if valid_778630 != nil:
    section.add "Accept", valid_778630
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_778632: Call_PatchReposOwnerRepo_778625; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Edit repository.
  ## 
  let valid = call_778632.validator(path, query, header, formData, body)
  let scheme = call_778632.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778632.url(scheme.get, call_778632.host, call_778632.base,
                         call_778632.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778632, url, valid)

proc call*(call_778633: Call_PatchReposOwnerRepo_778625; repo: string; owner: string;
          body: JsonNode; Accept: string = ""): Recallable =
  ## patchReposOwnerRepo
  ## Edit repository.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778634 = newJObject()
  var header_778635 = newJObject()
  var body_778636 = newJObject()
  add(path_778634, "repo", newJString(repo))
  add(path_778634, "owner", newJString(owner))
  if body != nil:
    body_778636 = body
  add(header_778635, "Accept", newJString(Accept))
  result = call_778633.call(path_778634, nil, header_778635, nil, body_778636)

var patchReposOwnerRepo* = Call_PatchReposOwnerRepo_778625(
    name: "patchReposOwnerRepo", meth: HttpMethod.HttpPatch, host: "api.github.com",
    route: "/repos/{owner}/{repo}", validator: validate_PatchReposOwnerRepo_778626,
    base: "/", url: url_PatchReposOwnerRepo_778627, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepo_778615 = ref object of OpenApiRestCall_777573
proc url_DeleteReposOwnerRepo_778617(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepo_778616(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a Repository.
  ## Deleting a repository requires admin access. If OAuth is used, the delete_repo
  ## scope is required.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778618 = path.getOrDefault("repo")
  valid_778618 = validateParameter(valid_778618, JString, required = true,
                                 default = nil)
  if valid_778618 != nil:
    section.add "repo", valid_778618
  var valid_778619 = path.getOrDefault("owner")
  valid_778619 = validateParameter(valid_778619, JString, required = true,
                                 default = nil)
  if valid_778619 != nil:
    section.add "owner", valid_778619
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778620 = header.getOrDefault("Accept")
  valid_778620 = validateParameter(valid_778620, JString, required = false,
                                 default = nil)
  if valid_778620 != nil:
    section.add "Accept", valid_778620
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778621: Call_DeleteReposOwnerRepo_778615; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete a Repository.
  ## Deleting a repository requires admin access. If OAuth is used, the delete_repo
  ## scope is required.
  ## 
  ## 
  let valid = call_778621.validator(path, query, header, formData, body)
  let scheme = call_778621.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778621.url(scheme.get, call_778621.host, call_778621.base,
                         call_778621.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778621, url, valid)

proc call*(call_778622: Call_DeleteReposOwnerRepo_778615; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepo
  ## Delete a Repository.
  ## Deleting a repository requires admin access. If OAuth is used, the delete_repo
  ## scope is required.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778623 = newJObject()
  var header_778624 = newJObject()
  add(path_778623, "repo", newJString(repo))
  add(path_778623, "owner", newJString(owner))
  add(header_778624, "Accept", newJString(Accept))
  result = call_778622.call(path_778623, nil, header_778624, nil, nil)

var deleteReposOwnerRepo* = Call_DeleteReposOwnerRepo_778615(
    name: "deleteReposOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}",
    validator: validate_DeleteReposOwnerRepo_778616, base: "/",
    url: url_DeleteReposOwnerRepo_778617, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoAssignees_778637 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoAssignees_778639(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/assignees")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoAssignees_778638(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List assignees.
  ## This call lists all the available assignees (owner + collaborators) to which
  ## issues may be assigned.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778640 = path.getOrDefault("repo")
  valid_778640 = validateParameter(valid_778640, JString, required = true,
                                 default = nil)
  if valid_778640 != nil:
    section.add "repo", valid_778640
  var valid_778641 = path.getOrDefault("owner")
  valid_778641 = validateParameter(valid_778641, JString, required = true,
                                 default = nil)
  if valid_778641 != nil:
    section.add "owner", valid_778641
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778642 = header.getOrDefault("Accept")
  valid_778642 = validateParameter(valid_778642, JString, required = false,
                                 default = nil)
  if valid_778642 != nil:
    section.add "Accept", valid_778642
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778643: Call_GetReposOwnerRepoAssignees_778637; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List assignees.
  ## This call lists all the available assignees (owner + collaborators) to which
  ## issues may be assigned.
  ## 
  ## 
  let valid = call_778643.validator(path, query, header, formData, body)
  let scheme = call_778643.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778643.url(scheme.get, call_778643.host, call_778643.base,
                         call_778643.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778643, url, valid)

proc call*(call_778644: Call_GetReposOwnerRepoAssignees_778637; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoAssignees
  ## List assignees.
  ## This call lists all the available assignees (owner + collaborators) to which
  ## issues may be assigned.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778645 = newJObject()
  var header_778646 = newJObject()
  add(path_778645, "repo", newJString(repo))
  add(path_778645, "owner", newJString(owner))
  add(header_778646, "Accept", newJString(Accept))
  result = call_778644.call(path_778645, nil, header_778646, nil, nil)

var getReposOwnerRepoAssignees* = Call_GetReposOwnerRepoAssignees_778637(
    name: "getReposOwnerRepoAssignees", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/assignees",
    validator: validate_GetReposOwnerRepoAssignees_778638, base: "/",
    url: url_GetReposOwnerRepoAssignees_778639, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoAssigneesAssignee_778647 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoAssigneesAssignee_778649(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "assignee" in path, "`assignee` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/assignees/"),
               (kind: VariableSegment, value: "assignee")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoAssigneesAssignee_778648(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Check assignee.
  ## You may also check to see if a particular user is an assignee for a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   assignee: JString (required)
  ##           : Login of the assignee.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778650 = path.getOrDefault("repo")
  valid_778650 = validateParameter(valid_778650, JString, required = true,
                                 default = nil)
  if valid_778650 != nil:
    section.add "repo", valid_778650
  var valid_778651 = path.getOrDefault("owner")
  valid_778651 = validateParameter(valid_778651, JString, required = true,
                                 default = nil)
  if valid_778651 != nil:
    section.add "owner", valid_778651
  var valid_778652 = path.getOrDefault("assignee")
  valid_778652 = validateParameter(valid_778652, JString, required = true,
                                 default = nil)
  if valid_778652 != nil:
    section.add "assignee", valid_778652
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778653 = header.getOrDefault("Accept")
  valid_778653 = validateParameter(valid_778653, JString, required = false,
                                 default = nil)
  if valid_778653 != nil:
    section.add "Accept", valid_778653
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778654: Call_GetReposOwnerRepoAssigneesAssignee_778647;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Check assignee.
  ## You may also check to see if a particular user is an assignee for a repository.
  ## 
  ## 
  let valid = call_778654.validator(path, query, header, formData, body)
  let scheme = call_778654.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778654.url(scheme.get, call_778654.host, call_778654.base,
                         call_778654.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778654, url, valid)

proc call*(call_778655: Call_GetReposOwnerRepoAssigneesAssignee_778647;
          repo: string; owner: string; assignee: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoAssigneesAssignee
  ## Check assignee.
  ## You may also check to see if a particular user is an assignee for a repository.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   assignee: string (required)
  ##           : Login of the assignee.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778656 = newJObject()
  var header_778657 = newJObject()
  add(path_778656, "repo", newJString(repo))
  add(path_778656, "owner", newJString(owner))
  add(path_778656, "assignee", newJString(assignee))
  add(header_778657, "Accept", newJString(Accept))
  result = call_778655.call(path_778656, nil, header_778657, nil, nil)

var getReposOwnerRepoAssigneesAssignee* = Call_GetReposOwnerRepoAssigneesAssignee_778647(
    name: "getReposOwnerRepoAssigneesAssignee", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/assignees/{assignee}",
    validator: validate_GetReposOwnerRepoAssigneesAssignee_778648, base: "/",
    url: url_GetReposOwnerRepoAssigneesAssignee_778649, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoBranches_778658 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoBranches_778660(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/branches")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoBranches_778659(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get list of branches
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778661 = path.getOrDefault("repo")
  valid_778661 = validateParameter(valid_778661, JString, required = true,
                                 default = nil)
  if valid_778661 != nil:
    section.add "repo", valid_778661
  var valid_778662 = path.getOrDefault("owner")
  valid_778662 = validateParameter(valid_778662, JString, required = true,
                                 default = nil)
  if valid_778662 != nil:
    section.add "owner", valid_778662
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778663 = header.getOrDefault("Accept")
  valid_778663 = validateParameter(valid_778663, JString, required = false,
                                 default = nil)
  if valid_778663 != nil:
    section.add "Accept", valid_778663
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778664: Call_GetReposOwnerRepoBranches_778658; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get list of branches
  ## 
  let valid = call_778664.validator(path, query, header, formData, body)
  let scheme = call_778664.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778664.url(scheme.get, call_778664.host, call_778664.base,
                         call_778664.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778664, url, valid)

proc call*(call_778665: Call_GetReposOwnerRepoBranches_778658; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoBranches
  ## Get list of branches
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778666 = newJObject()
  var header_778667 = newJObject()
  add(path_778666, "repo", newJString(repo))
  add(path_778666, "owner", newJString(owner))
  add(header_778667, "Accept", newJString(Accept))
  result = call_778665.call(path_778666, nil, header_778667, nil, nil)

var getReposOwnerRepoBranches* = Call_GetReposOwnerRepoBranches_778658(
    name: "getReposOwnerRepoBranches", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/branches",
    validator: validate_GetReposOwnerRepoBranches_778659, base: "/",
    url: url_GetReposOwnerRepoBranches_778660, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoBranchesBranch_778668 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoBranchesBranch_778670(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "branch" in path, "`branch` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/branches/"),
               (kind: VariableSegment, value: "branch")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoBranchesBranch_778669(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get Branch
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   branch: JString (required)
  ##         : Name of the branch.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778671 = path.getOrDefault("repo")
  valid_778671 = validateParameter(valid_778671, JString, required = true,
                                 default = nil)
  if valid_778671 != nil:
    section.add "repo", valid_778671
  var valid_778672 = path.getOrDefault("owner")
  valid_778672 = validateParameter(valid_778672, JString, required = true,
                                 default = nil)
  if valid_778672 != nil:
    section.add "owner", valid_778672
  var valid_778673 = path.getOrDefault("branch")
  valid_778673 = validateParameter(valid_778673, JString, required = true,
                                 default = nil)
  if valid_778673 != nil:
    section.add "branch", valid_778673
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778674 = header.getOrDefault("Accept")
  valid_778674 = validateParameter(valid_778674, JString, required = false,
                                 default = nil)
  if valid_778674 != nil:
    section.add "Accept", valid_778674
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778675: Call_GetReposOwnerRepoBranchesBranch_778668;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get Branch
  ## 
  let valid = call_778675.validator(path, query, header, formData, body)
  let scheme = call_778675.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778675.url(scheme.get, call_778675.host, call_778675.base,
                         call_778675.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778675, url, valid)

proc call*(call_778676: Call_GetReposOwnerRepoBranchesBranch_778668; repo: string;
          owner: string; branch: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoBranchesBranch
  ## Get Branch
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   branch: string (required)
  ##         : Name of the branch.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778677 = newJObject()
  var header_778678 = newJObject()
  add(path_778677, "repo", newJString(repo))
  add(path_778677, "owner", newJString(owner))
  add(path_778677, "branch", newJString(branch))
  add(header_778678, "Accept", newJString(Accept))
  result = call_778676.call(path_778677, nil, header_778678, nil, nil)

var getReposOwnerRepoBranchesBranch* = Call_GetReposOwnerRepoBranchesBranch_778668(
    name: "getReposOwnerRepoBranchesBranch", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/branches/{branch}",
    validator: validate_GetReposOwnerRepoBranchesBranch_778669, base: "/",
    url: url_GetReposOwnerRepoBranchesBranch_778670, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCollaborators_778679 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoCollaborators_778681(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/collaborators")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCollaborators_778680(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List.
  ## When authenticating as an organization owner of an organization-owned
  ## repository, all organization owners are included in the list of
  ## collaborators. Otherwise, only users with access to the repository are
  ## returned in the collaborators list.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778682 = path.getOrDefault("repo")
  valid_778682 = validateParameter(valid_778682, JString, required = true,
                                 default = nil)
  if valid_778682 != nil:
    section.add "repo", valid_778682
  var valid_778683 = path.getOrDefault("owner")
  valid_778683 = validateParameter(valid_778683, JString, required = true,
                                 default = nil)
  if valid_778683 != nil:
    section.add "owner", valid_778683
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778684 = header.getOrDefault("Accept")
  valid_778684 = validateParameter(valid_778684, JString, required = false,
                                 default = nil)
  if valid_778684 != nil:
    section.add "Accept", valid_778684
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778685: Call_GetReposOwnerRepoCollaborators_778679; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List.
  ## When authenticating as an organization owner of an organization-owned
  ## repository, all organization owners are included in the list of
  ## collaborators. Otherwise, only users with access to the repository are
  ## returned in the collaborators list.
  ## 
  ## 
  let valid = call_778685.validator(path, query, header, formData, body)
  let scheme = call_778685.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778685.url(scheme.get, call_778685.host, call_778685.base,
                         call_778685.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778685, url, valid)

proc call*(call_778686: Call_GetReposOwnerRepoCollaborators_778679; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCollaborators
  ## List.
  ## When authenticating as an organization owner of an organization-owned
  ## repository, all organization owners are included in the list of
  ## collaborators. Otherwise, only users with access to the repository are
  ## returned in the collaborators list.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778687 = newJObject()
  var header_778688 = newJObject()
  add(path_778687, "repo", newJString(repo))
  add(path_778687, "owner", newJString(owner))
  add(header_778688, "Accept", newJString(Accept))
  result = call_778686.call(path_778687, nil, header_778688, nil, nil)

var getReposOwnerRepoCollaborators* = Call_GetReposOwnerRepoCollaborators_778679(
    name: "getReposOwnerRepoCollaborators", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators",
    validator: validate_GetReposOwnerRepoCollaborators_778680, base: "/",
    url: url_GetReposOwnerRepoCollaborators_778681, schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoCollaboratorsUser_778700 = ref object of OpenApiRestCall_777573
proc url_PutReposOwnerRepoCollaboratorsUser_778702(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "user" in path, "`user` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/collaborators/"),
               (kind: VariableSegment, value: "user")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoCollaboratorsUser_778701(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Add collaborator.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   user: JString (required)
  ##       : Login of the user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778703 = path.getOrDefault("repo")
  valid_778703 = validateParameter(valid_778703, JString, required = true,
                                 default = nil)
  if valid_778703 != nil:
    section.add "repo", valid_778703
  var valid_778704 = path.getOrDefault("owner")
  valid_778704 = validateParameter(valid_778704, JString, required = true,
                                 default = nil)
  if valid_778704 != nil:
    section.add "owner", valid_778704
  var valid_778705 = path.getOrDefault("user")
  valid_778705 = validateParameter(valid_778705, JString, required = true,
                                 default = nil)
  if valid_778705 != nil:
    section.add "user", valid_778705
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778706 = header.getOrDefault("Accept")
  valid_778706 = validateParameter(valid_778706, JString, required = false,
                                 default = nil)
  if valid_778706 != nil:
    section.add "Accept", valid_778706
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778707: Call_PutReposOwnerRepoCollaboratorsUser_778700;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Add collaborator.
  ## 
  let valid = call_778707.validator(path, query, header, formData, body)
  let scheme = call_778707.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778707.url(scheme.get, call_778707.host, call_778707.base,
                         call_778707.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778707, url, valid)

proc call*(call_778708: Call_PutReposOwnerRepoCollaboratorsUser_778700;
          repo: string; owner: string; user: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoCollaboratorsUser
  ## Add collaborator.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   user: string (required)
  ##       : Login of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778709 = newJObject()
  var header_778710 = newJObject()
  add(path_778709, "repo", newJString(repo))
  add(path_778709, "owner", newJString(owner))
  add(path_778709, "user", newJString(user))
  add(header_778710, "Accept", newJString(Accept))
  result = call_778708.call(path_778709, nil, header_778710, nil, nil)

var putReposOwnerRepoCollaboratorsUser* = Call_PutReposOwnerRepoCollaboratorsUser_778700(
    name: "putReposOwnerRepoCollaboratorsUser", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators/{user}",
    validator: validate_PutReposOwnerRepoCollaboratorsUser_778701, base: "/",
    url: url_PutReposOwnerRepoCollaboratorsUser_778702, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCollaboratorsUser_778689 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoCollaboratorsUser_778691(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "user" in path, "`user` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/collaborators/"),
               (kind: VariableSegment, value: "user")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCollaboratorsUser_778690(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Check if user is a collaborator
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   user: JString (required)
  ##       : Login of the user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778692 = path.getOrDefault("repo")
  valid_778692 = validateParameter(valid_778692, JString, required = true,
                                 default = nil)
  if valid_778692 != nil:
    section.add "repo", valid_778692
  var valid_778693 = path.getOrDefault("owner")
  valid_778693 = validateParameter(valid_778693, JString, required = true,
                                 default = nil)
  if valid_778693 != nil:
    section.add "owner", valid_778693
  var valid_778694 = path.getOrDefault("user")
  valid_778694 = validateParameter(valid_778694, JString, required = true,
                                 default = nil)
  if valid_778694 != nil:
    section.add "user", valid_778694
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778695 = header.getOrDefault("Accept")
  valid_778695 = validateParameter(valid_778695, JString, required = false,
                                 default = nil)
  if valid_778695 != nil:
    section.add "Accept", valid_778695
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778696: Call_GetReposOwnerRepoCollaboratorsUser_778689;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Check if user is a collaborator
  ## 
  let valid = call_778696.validator(path, query, header, formData, body)
  let scheme = call_778696.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778696.url(scheme.get, call_778696.host, call_778696.base,
                         call_778696.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778696, url, valid)

proc call*(call_778697: Call_GetReposOwnerRepoCollaboratorsUser_778689;
          repo: string; owner: string; user: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCollaboratorsUser
  ## Check if user is a collaborator
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   user: string (required)
  ##       : Login of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778698 = newJObject()
  var header_778699 = newJObject()
  add(path_778698, "repo", newJString(repo))
  add(path_778698, "owner", newJString(owner))
  add(path_778698, "user", newJString(user))
  add(header_778699, "Accept", newJString(Accept))
  result = call_778697.call(path_778698, nil, header_778699, nil, nil)

var getReposOwnerRepoCollaboratorsUser* = Call_GetReposOwnerRepoCollaboratorsUser_778689(
    name: "getReposOwnerRepoCollaboratorsUser", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators/{user}",
    validator: validate_GetReposOwnerRepoCollaboratorsUser_778690, base: "/",
    url: url_GetReposOwnerRepoCollaboratorsUser_778691, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoCollaboratorsUser_778711 = ref object of OpenApiRestCall_777573
proc url_DeleteReposOwnerRepoCollaboratorsUser_778713(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "user" in path, "`user` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/collaborators/"),
               (kind: VariableSegment, value: "user")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoCollaboratorsUser_778712(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Remove collaborator.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   user: JString (required)
  ##       : Login of the user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778714 = path.getOrDefault("repo")
  valid_778714 = validateParameter(valid_778714, JString, required = true,
                                 default = nil)
  if valid_778714 != nil:
    section.add "repo", valid_778714
  var valid_778715 = path.getOrDefault("owner")
  valid_778715 = validateParameter(valid_778715, JString, required = true,
                                 default = nil)
  if valid_778715 != nil:
    section.add "owner", valid_778715
  var valid_778716 = path.getOrDefault("user")
  valid_778716 = validateParameter(valid_778716, JString, required = true,
                                 default = nil)
  if valid_778716 != nil:
    section.add "user", valid_778716
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778717 = header.getOrDefault("Accept")
  valid_778717 = validateParameter(valid_778717, JString, required = false,
                                 default = nil)
  if valid_778717 != nil:
    section.add "Accept", valid_778717
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778718: Call_DeleteReposOwnerRepoCollaboratorsUser_778711;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Remove collaborator.
  ## 
  let valid = call_778718.validator(path, query, header, formData, body)
  let scheme = call_778718.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778718.url(scheme.get, call_778718.host, call_778718.base,
                         call_778718.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778718, url, valid)

proc call*(call_778719: Call_DeleteReposOwnerRepoCollaboratorsUser_778711;
          repo: string; owner: string; user: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoCollaboratorsUser
  ## Remove collaborator.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   user: string (required)
  ##       : Login of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778720 = newJObject()
  var header_778721 = newJObject()
  add(path_778720, "repo", newJString(repo))
  add(path_778720, "owner", newJString(owner))
  add(path_778720, "user", newJString(user))
  add(header_778721, "Accept", newJString(Accept))
  result = call_778719.call(path_778720, nil, header_778721, nil, nil)

var deleteReposOwnerRepoCollaboratorsUser* = Call_DeleteReposOwnerRepoCollaboratorsUser_778711(
    name: "deleteReposOwnerRepoCollaboratorsUser", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators/{user}",
    validator: validate_DeleteReposOwnerRepoCollaboratorsUser_778712, base: "/",
    url: url_DeleteReposOwnerRepoCollaboratorsUser_778713, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoComments_778722 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoComments_778724(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoComments_778723(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List commit comments for a repository.
  ## Comments are ordered by ascending ID.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778725 = path.getOrDefault("repo")
  valid_778725 = validateParameter(valid_778725, JString, required = true,
                                 default = nil)
  if valid_778725 != nil:
    section.add "repo", valid_778725
  var valid_778726 = path.getOrDefault("owner")
  valid_778726 = validateParameter(valid_778726, JString, required = true,
                                 default = nil)
  if valid_778726 != nil:
    section.add "owner", valid_778726
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778727 = header.getOrDefault("Accept")
  valid_778727 = validateParameter(valid_778727, JString, required = false,
                                 default = nil)
  if valid_778727 != nil:
    section.add "Accept", valid_778727
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778728: Call_GetReposOwnerRepoComments_778722; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List commit comments for a repository.
  ## Comments are ordered by ascending ID.
  ## 
  ## 
  let valid = call_778728.validator(path, query, header, formData, body)
  let scheme = call_778728.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778728.url(scheme.get, call_778728.host, call_778728.base,
                         call_778728.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778728, url, valid)

proc call*(call_778729: Call_GetReposOwnerRepoComments_778722; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoComments
  ## List commit comments for a repository.
  ## Comments are ordered by ascending ID.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778730 = newJObject()
  var header_778731 = newJObject()
  add(path_778730, "repo", newJString(repo))
  add(path_778730, "owner", newJString(owner))
  add(header_778731, "Accept", newJString(Accept))
  result = call_778729.call(path_778730, nil, header_778731, nil, nil)

var getReposOwnerRepoComments* = Call_GetReposOwnerRepoComments_778722(
    name: "getReposOwnerRepoComments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments",
    validator: validate_GetReposOwnerRepoComments_778723, base: "/",
    url: url_GetReposOwnerRepoComments_778724, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommentsCommentId_778732 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoCommentsCommentId_778734(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommentsCommentId_778733(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single commit comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778735 = path.getOrDefault("repo")
  valid_778735 = validateParameter(valid_778735, JString, required = true,
                                 default = nil)
  if valid_778735 != nil:
    section.add "repo", valid_778735
  var valid_778736 = path.getOrDefault("commentId")
  valid_778736 = validateParameter(valid_778736, JInt, required = true, default = nil)
  if valid_778736 != nil:
    section.add "commentId", valid_778736
  var valid_778737 = path.getOrDefault("owner")
  valid_778737 = validateParameter(valid_778737, JString, required = true,
                                 default = nil)
  if valid_778737 != nil:
    section.add "owner", valid_778737
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778738 = header.getOrDefault("Accept")
  valid_778738 = validateParameter(valid_778738, JString, required = false,
                                 default = nil)
  if valid_778738 != nil:
    section.add "Accept", valid_778738
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778739: Call_GetReposOwnerRepoCommentsCommentId_778732;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single commit comment.
  ## 
  let valid = call_778739.validator(path, query, header, formData, body)
  let scheme = call_778739.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778739.url(scheme.get, call_778739.host, call_778739.base,
                         call_778739.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778739, url, valid)

proc call*(call_778740: Call_GetReposOwnerRepoCommentsCommentId_778732;
          repo: string; commentId: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommentsCommentId
  ## Get a single commit comment.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778741 = newJObject()
  var header_778742 = newJObject()
  add(path_778741, "repo", newJString(repo))
  add(path_778741, "commentId", newJInt(commentId))
  add(path_778741, "owner", newJString(owner))
  add(header_778742, "Accept", newJString(Accept))
  result = call_778740.call(path_778741, nil, header_778742, nil, nil)

var getReposOwnerRepoCommentsCommentId* = Call_GetReposOwnerRepoCommentsCommentId_778732(
    name: "getReposOwnerRepoCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments/{commentId}",
    validator: validate_GetReposOwnerRepoCommentsCommentId_778733, base: "/",
    url: url_GetReposOwnerRepoCommentsCommentId_778734, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoCommentsCommentId_778754 = ref object of OpenApiRestCall_777573
proc url_PatchReposOwnerRepoCommentsCommentId_778756(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoCommentsCommentId_778755(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Update a commit comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778757 = path.getOrDefault("repo")
  valid_778757 = validateParameter(valid_778757, JString, required = true,
                                 default = nil)
  if valid_778757 != nil:
    section.add "repo", valid_778757
  var valid_778758 = path.getOrDefault("commentId")
  valid_778758 = validateParameter(valid_778758, JInt, required = true, default = nil)
  if valid_778758 != nil:
    section.add "commentId", valid_778758
  var valid_778759 = path.getOrDefault("owner")
  valid_778759 = validateParameter(valid_778759, JString, required = true,
                                 default = nil)
  if valid_778759 != nil:
    section.add "owner", valid_778759
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778760 = header.getOrDefault("Accept")
  valid_778760 = validateParameter(valid_778760, JString, required = false,
                                 default = nil)
  if valid_778760 != nil:
    section.add "Accept", valid_778760
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_778762: Call_PatchReposOwnerRepoCommentsCommentId_778754;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Update a commit comment.
  ## 
  let valid = call_778762.validator(path, query, header, formData, body)
  let scheme = call_778762.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778762.url(scheme.get, call_778762.host, call_778762.base,
                         call_778762.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778762, url, valid)

proc call*(call_778763: Call_PatchReposOwnerRepoCommentsCommentId_778754;
          repo: string; commentId: int; owner: string; body: JsonNode;
          Accept: string = ""): Recallable =
  ## patchReposOwnerRepoCommentsCommentId
  ## Update a commit comment.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778764 = newJObject()
  var header_778765 = newJObject()
  var body_778766 = newJObject()
  add(path_778764, "repo", newJString(repo))
  add(path_778764, "commentId", newJInt(commentId))
  add(path_778764, "owner", newJString(owner))
  if body != nil:
    body_778766 = body
  add(header_778765, "Accept", newJString(Accept))
  result = call_778763.call(path_778764, nil, header_778765, nil, body_778766)

var patchReposOwnerRepoCommentsCommentId* = Call_PatchReposOwnerRepoCommentsCommentId_778754(
    name: "patchReposOwnerRepoCommentsCommentId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments/{commentId}",
    validator: validate_PatchReposOwnerRepoCommentsCommentId_778755, base: "/",
    url: url_PatchReposOwnerRepoCommentsCommentId_778756, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoCommentsCommentId_778743 = ref object of OpenApiRestCall_777573
proc url_DeleteReposOwnerRepoCommentsCommentId_778745(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoCommentsCommentId_778744(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a commit comment
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778746 = path.getOrDefault("repo")
  valid_778746 = validateParameter(valid_778746, JString, required = true,
                                 default = nil)
  if valid_778746 != nil:
    section.add "repo", valid_778746
  var valid_778747 = path.getOrDefault("commentId")
  valid_778747 = validateParameter(valid_778747, JInt, required = true, default = nil)
  if valid_778747 != nil:
    section.add "commentId", valid_778747
  var valid_778748 = path.getOrDefault("owner")
  valid_778748 = validateParameter(valid_778748, JString, required = true,
                                 default = nil)
  if valid_778748 != nil:
    section.add "owner", valid_778748
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778749 = header.getOrDefault("Accept")
  valid_778749 = validateParameter(valid_778749, JString, required = false,
                                 default = nil)
  if valid_778749 != nil:
    section.add "Accept", valid_778749
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778750: Call_DeleteReposOwnerRepoCommentsCommentId_778743;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a commit comment
  ## 
  let valid = call_778750.validator(path, query, header, formData, body)
  let scheme = call_778750.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778750.url(scheme.get, call_778750.host, call_778750.base,
                         call_778750.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778750, url, valid)

proc call*(call_778751: Call_DeleteReposOwnerRepoCommentsCommentId_778743;
          repo: string; commentId: int; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoCommentsCommentId
  ## Delete a commit comment
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778752 = newJObject()
  var header_778753 = newJObject()
  add(path_778752, "repo", newJString(repo))
  add(path_778752, "commentId", newJInt(commentId))
  add(path_778752, "owner", newJString(owner))
  add(header_778753, "Accept", newJString(Accept))
  result = call_778751.call(path_778752, nil, header_778753, nil, nil)

var deleteReposOwnerRepoCommentsCommentId* = Call_DeleteReposOwnerRepoCommentsCommentId_778743(
    name: "deleteReposOwnerRepoCommentsCommentId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments/{commentId}",
    validator: validate_DeleteReposOwnerRepoCommentsCommentId_778744, base: "/",
    url: url_DeleteReposOwnerRepoCommentsCommentId_778745, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommits_778767 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoCommits_778769(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommits_778768(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List commits on a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778770 = path.getOrDefault("repo")
  valid_778770 = validateParameter(valid_778770, JString, required = true,
                                 default = nil)
  if valid_778770 != nil:
    section.add "repo", valid_778770
  var valid_778771 = path.getOrDefault("owner")
  valid_778771 = validateParameter(valid_778771, JString, required = true,
                                 default = nil)
  if valid_778771 != nil:
    section.add "owner", valid_778771
  result.add "path", section
  ## parameters in `query` object:
  ##   author: JString
  ##         : GitHub login, name, or email by which to filter by commit author.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   sha: JString
  ##      : Sha or branch to start listing commits from.
  ##   path: JString
  ##       : Only commits containing this file path will be returned.
  ##   until: JString
  ##        : ISO 8601 Date - Only commits before this date will be returned.
  section = newJObject()
  var valid_778772 = query.getOrDefault("author")
  valid_778772 = validateParameter(valid_778772, JString, required = false,
                                 default = nil)
  if valid_778772 != nil:
    section.add "author", valid_778772
  var valid_778773 = query.getOrDefault("since")
  valid_778773 = validateParameter(valid_778773, JString, required = false,
                                 default = nil)
  if valid_778773 != nil:
    section.add "since", valid_778773
  var valid_778774 = query.getOrDefault("sha")
  valid_778774 = validateParameter(valid_778774, JString, required = false,
                                 default = nil)
  if valid_778774 != nil:
    section.add "sha", valid_778774
  var valid_778775 = query.getOrDefault("path")
  valid_778775 = validateParameter(valid_778775, JString, required = false,
                                 default = nil)
  if valid_778775 != nil:
    section.add "path", valid_778775
  var valid_778776 = query.getOrDefault("until")
  valid_778776 = validateParameter(valid_778776, JString, required = false,
                                 default = nil)
  if valid_778776 != nil:
    section.add "until", valid_778776
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778777 = header.getOrDefault("Accept")
  valid_778777 = validateParameter(valid_778777, JString, required = false,
                                 default = nil)
  if valid_778777 != nil:
    section.add "Accept", valid_778777
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778778: Call_GetReposOwnerRepoCommits_778767; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List commits on a repository.
  ## 
  let valid = call_778778.validator(path, query, header, formData, body)
  let scheme = call_778778.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778778.url(scheme.get, call_778778.host, call_778778.base,
                         call_778778.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778778, url, valid)

proc call*(call_778779: Call_GetReposOwnerRepoCommits_778767; repo: string;
          owner: string; author: string = ""; since: string = ""; sha: string = "";
          path: string = ""; until: string = ""; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommits
  ## List commits on a repository.
  ##   author: string
  ##         : GitHub login, name, or email by which to filter by commit author.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   sha: string
  ##      : Sha or branch to start listing commits from.
  ##   path: string
  ##       : Only commits containing this file path will be returned.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   until: string
  ##        : ISO 8601 Date - Only commits before this date will be returned.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778780 = newJObject()
  var query_778781 = newJObject()
  var header_778782 = newJObject()
  add(query_778781, "author", newJString(author))
  add(path_778780, "repo", newJString(repo))
  add(query_778781, "since", newJString(since))
  add(query_778781, "sha", newJString(sha))
  add(query_778781, "path", newJString(path))
  add(path_778780, "owner", newJString(owner))
  add(query_778781, "until", newJString(until))
  add(header_778782, "Accept", newJString(Accept))
  result = call_778779.call(path_778780, query_778781, header_778782, nil, nil)

var getReposOwnerRepoCommits* = Call_GetReposOwnerRepoCommits_778767(
    name: "getReposOwnerRepoCommits", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/commits",
    validator: validate_GetReposOwnerRepoCommits_778768, base: "/",
    url: url_GetReposOwnerRepoCommits_778769, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommitsRefStatus_778783 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoCommitsRefStatus_778785(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits/"),
               (kind: VariableSegment, value: "ref"),
               (kind: ConstantSegment, value: "/status")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommitsRefStatus_778784(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the combined Status for a specific Ref
  ## The Combined status endpoint is currently available for developers to preview. During the preview period, the API may change without advance notice. Please see the blog post for full details.
  ## To access this endpoint during the preview period, you must provide a custom media type in the Accept header:
  ## application/vnd.github.she-hulk-preview+json
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   ref: JString (required)
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778786 = path.getOrDefault("repo")
  valid_778786 = validateParameter(valid_778786, JString, required = true,
                                 default = nil)
  if valid_778786 != nil:
    section.add "repo", valid_778786
  var valid_778787 = path.getOrDefault("ref")
  valid_778787 = validateParameter(valid_778787, JString, required = true,
                                 default = nil)
  if valid_778787 != nil:
    section.add "ref", valid_778787
  var valid_778788 = path.getOrDefault("owner")
  valid_778788 = validateParameter(valid_778788, JString, required = true,
                                 default = nil)
  if valid_778788 != nil:
    section.add "owner", valid_778788
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778789 = header.getOrDefault("Accept")
  valid_778789 = validateParameter(valid_778789, JString, required = false,
                                 default = nil)
  if valid_778789 != nil:
    section.add "Accept", valid_778789
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778790: Call_GetReposOwnerRepoCommitsRefStatus_778783;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get the combined Status for a specific Ref
  ## The Combined status endpoint is currently available for developers to preview. During the preview period, the API may change without advance notice. Please see the blog post for full details.
  ## To access this endpoint during the preview period, you must provide a custom media type in the Accept header:
  ## application/vnd.github.she-hulk-preview+json
  ## 
  ## 
  let valid = call_778790.validator(path, query, header, formData, body)
  let scheme = call_778790.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778790.url(scheme.get, call_778790.host, call_778790.base,
                         call_778790.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778790, url, valid)

proc call*(call_778791: Call_GetReposOwnerRepoCommitsRefStatus_778783;
          repo: string; `ref`: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommitsRefStatus
  ## Get the combined Status for a specific Ref
  ## The Combined status endpoint is currently available for developers to preview. During the preview period, the API may change without advance notice. Please see the blog post for full details.
  ## To access this endpoint during the preview period, you must provide a custom media type in the Accept header:
  ## application/vnd.github.she-hulk-preview+json
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   ref: string (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778792 = newJObject()
  var header_778793 = newJObject()
  add(path_778792, "repo", newJString(repo))
  add(path_778792, "ref", newJString(`ref`))
  add(path_778792, "owner", newJString(owner))
  add(header_778793, "Accept", newJString(Accept))
  result = call_778791.call(path_778792, nil, header_778793, nil, nil)

var getReposOwnerRepoCommitsRefStatus* = Call_GetReposOwnerRepoCommitsRefStatus_778783(
    name: "getReposOwnerRepoCommitsRefStatus", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/commits/{ref}/status",
    validator: validate_GetReposOwnerRepoCommitsRefStatus_778784, base: "/",
    url: url_GetReposOwnerRepoCommitsRefStatus_778785, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommitsShaCode_778794 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoCommitsShaCode_778796(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommitsShaCode_778795(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   shaCode: JString (required)
  ##          : SHA-1 code of the commit.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778797 = path.getOrDefault("repo")
  valid_778797 = validateParameter(valid_778797, JString, required = true,
                                 default = nil)
  if valid_778797 != nil:
    section.add "repo", valid_778797
  var valid_778798 = path.getOrDefault("owner")
  valid_778798 = validateParameter(valid_778798, JString, required = true,
                                 default = nil)
  if valid_778798 != nil:
    section.add "owner", valid_778798
  var valid_778799 = path.getOrDefault("shaCode")
  valid_778799 = validateParameter(valid_778799, JString, required = true,
                                 default = nil)
  if valid_778799 != nil:
    section.add "shaCode", valid_778799
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778800 = header.getOrDefault("Accept")
  valid_778800 = validateParameter(valid_778800, JString, required = false,
                                 default = nil)
  if valid_778800 != nil:
    section.add "Accept", valid_778800
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778801: Call_GetReposOwnerRepoCommitsShaCode_778794;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single commit.
  ## 
  let valid = call_778801.validator(path, query, header, formData, body)
  let scheme = call_778801.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778801.url(scheme.get, call_778801.host, call_778801.base,
                         call_778801.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778801, url, valid)

proc call*(call_778802: Call_GetReposOwnerRepoCommitsShaCode_778794; repo: string;
          owner: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommitsShaCode
  ## Get a single commit.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   shaCode: string (required)
  ##          : SHA-1 code of the commit.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778803 = newJObject()
  var header_778804 = newJObject()
  add(path_778803, "repo", newJString(repo))
  add(path_778803, "owner", newJString(owner))
  add(path_778803, "shaCode", newJString(shaCode))
  add(header_778804, "Accept", newJString(Accept))
  result = call_778802.call(path_778803, nil, header_778804, nil, nil)

var getReposOwnerRepoCommitsShaCode* = Call_GetReposOwnerRepoCommitsShaCode_778794(
    name: "getReposOwnerRepoCommitsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/commits/{shaCode}",
    validator: validate_GetReposOwnerRepoCommitsShaCode_778795, base: "/",
    url: url_GetReposOwnerRepoCommitsShaCode_778796, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoCommitsShaCodeComments_778816 = ref object of OpenApiRestCall_777573
proc url_PostReposOwnerRepoCommitsShaCodeComments_778818(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits/"),
               (kind: VariableSegment, value: "shaCode"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoCommitsShaCodeComments_778817(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a commit comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   shaCode: JString (required)
  ##          : SHA-1 code of the commit.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778819 = path.getOrDefault("repo")
  valid_778819 = validateParameter(valid_778819, JString, required = true,
                                 default = nil)
  if valid_778819 != nil:
    section.add "repo", valid_778819
  var valid_778820 = path.getOrDefault("owner")
  valid_778820 = validateParameter(valid_778820, JString, required = true,
                                 default = nil)
  if valid_778820 != nil:
    section.add "owner", valid_778820
  var valid_778821 = path.getOrDefault("shaCode")
  valid_778821 = validateParameter(valid_778821, JString, required = true,
                                 default = nil)
  if valid_778821 != nil:
    section.add "shaCode", valid_778821
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778822 = header.getOrDefault("Accept")
  valid_778822 = validateParameter(valid_778822, JString, required = false,
                                 default = nil)
  if valid_778822 != nil:
    section.add "Accept", valid_778822
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_778824: Call_PostReposOwnerRepoCommitsShaCodeComments_778816;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Create a commit comment.
  ## 
  let valid = call_778824.validator(path, query, header, formData, body)
  let scheme = call_778824.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778824.url(scheme.get, call_778824.host, call_778824.base,
                         call_778824.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778824, url, valid)

proc call*(call_778825: Call_PostReposOwnerRepoCommitsShaCodeComments_778816;
          repo: string; owner: string; body: JsonNode; shaCode: string;
          Accept: string = ""): Recallable =
  ## postReposOwnerRepoCommitsShaCodeComments
  ## Create a commit comment.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   shaCode: string (required)
  ##          : SHA-1 code of the commit.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778826 = newJObject()
  var header_778827 = newJObject()
  var body_778828 = newJObject()
  add(path_778826, "repo", newJString(repo))
  add(path_778826, "owner", newJString(owner))
  if body != nil:
    body_778828 = body
  add(path_778826, "shaCode", newJString(shaCode))
  add(header_778827, "Accept", newJString(Accept))
  result = call_778825.call(path_778826, nil, header_778827, nil, body_778828)

var postReposOwnerRepoCommitsShaCodeComments* = Call_PostReposOwnerRepoCommitsShaCodeComments_778816(
    name: "postReposOwnerRepoCommitsShaCodeComments", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/commits/{shaCode}/comments",
    validator: validate_PostReposOwnerRepoCommitsShaCodeComments_778817,
    base: "/", url: url_PostReposOwnerRepoCommitsShaCodeComments_778818,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommitsShaCodeComments_778805 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoCommitsShaCodeComments_778807(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits/"),
               (kind: VariableSegment, value: "shaCode"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommitsShaCodeComments_778806(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List comments for a single commitList comments for a single commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   shaCode: JString (required)
  ##          : SHA-1 code of the commit.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778808 = path.getOrDefault("repo")
  valid_778808 = validateParameter(valid_778808, JString, required = true,
                                 default = nil)
  if valid_778808 != nil:
    section.add "repo", valid_778808
  var valid_778809 = path.getOrDefault("owner")
  valid_778809 = validateParameter(valid_778809, JString, required = true,
                                 default = nil)
  if valid_778809 != nil:
    section.add "owner", valid_778809
  var valid_778810 = path.getOrDefault("shaCode")
  valid_778810 = validateParameter(valid_778810, JString, required = true,
                                 default = nil)
  if valid_778810 != nil:
    section.add "shaCode", valid_778810
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778811 = header.getOrDefault("Accept")
  valid_778811 = validateParameter(valid_778811, JString, required = false,
                                 default = nil)
  if valid_778811 != nil:
    section.add "Accept", valid_778811
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778812: Call_GetReposOwnerRepoCommitsShaCodeComments_778805;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List comments for a single commitList comments for a single commit.
  ## 
  let valid = call_778812.validator(path, query, header, formData, body)
  let scheme = call_778812.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778812.url(scheme.get, call_778812.host, call_778812.base,
                         call_778812.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778812, url, valid)

proc call*(call_778813: Call_GetReposOwnerRepoCommitsShaCodeComments_778805;
          repo: string; owner: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommitsShaCodeComments
  ## List comments for a single commitList comments for a single commit.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   shaCode: string (required)
  ##          : SHA-1 code of the commit.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778814 = newJObject()
  var header_778815 = newJObject()
  add(path_778814, "repo", newJString(repo))
  add(path_778814, "owner", newJString(owner))
  add(path_778814, "shaCode", newJString(shaCode))
  add(header_778815, "Accept", newJString(Accept))
  result = call_778813.call(path_778814, nil, header_778815, nil, nil)

var getReposOwnerRepoCommitsShaCodeComments* = Call_GetReposOwnerRepoCommitsShaCodeComments_778805(
    name: "getReposOwnerRepoCommitsShaCodeComments", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/commits/{shaCode}/comments",
    validator: validate_GetReposOwnerRepoCommitsShaCodeComments_778806, base: "/",
    url: url_GetReposOwnerRepoCommitsShaCodeComments_778807,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCompareBaseIdHeadId_778829 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoCompareBaseIdHeadId_778831(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "baseId" in path, "`baseId` is a required path parameter"
  assert "headId" in path, "`headId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/compare/"),
               (kind: VariableSegment, value: "baseId"),
               (kind: ConstantSegment, value: "..."),
               (kind: VariableSegment, value: "headId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCompareBaseIdHeadId_778830(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Compare two commits
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   baseId: JString (required)
  ##   headId: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778832 = path.getOrDefault("repo")
  valid_778832 = validateParameter(valid_778832, JString, required = true,
                                 default = nil)
  if valid_778832 != nil:
    section.add "repo", valid_778832
  var valid_778833 = path.getOrDefault("owner")
  valid_778833 = validateParameter(valid_778833, JString, required = true,
                                 default = nil)
  if valid_778833 != nil:
    section.add "owner", valid_778833
  var valid_778834 = path.getOrDefault("baseId")
  valid_778834 = validateParameter(valid_778834, JString, required = true,
                                 default = nil)
  if valid_778834 != nil:
    section.add "baseId", valid_778834
  var valid_778835 = path.getOrDefault("headId")
  valid_778835 = validateParameter(valid_778835, JString, required = true,
                                 default = nil)
  if valid_778835 != nil:
    section.add "headId", valid_778835
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778836 = header.getOrDefault("Accept")
  valid_778836 = validateParameter(valid_778836, JString, required = false,
                                 default = nil)
  if valid_778836 != nil:
    section.add "Accept", valid_778836
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778837: Call_GetReposOwnerRepoCompareBaseIdHeadId_778829;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Compare two commits
  ## 
  let valid = call_778837.validator(path, query, header, formData, body)
  let scheme = call_778837.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778837.url(scheme.get, call_778837.host, call_778837.base,
                         call_778837.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778837, url, valid)

proc call*(call_778838: Call_GetReposOwnerRepoCompareBaseIdHeadId_778829;
          repo: string; owner: string; baseId: string; headId: string;
          Accept: string = ""): Recallable =
  ## getReposOwnerRepoCompareBaseIdHeadId
  ## Compare two commits
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   baseId: string (required)
  ##   headId: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778839 = newJObject()
  var header_778840 = newJObject()
  add(path_778839, "repo", newJString(repo))
  add(path_778839, "owner", newJString(owner))
  add(path_778839, "baseId", newJString(baseId))
  add(path_778839, "headId", newJString(headId))
  add(header_778840, "Accept", newJString(Accept))
  result = call_778838.call(path_778839, nil, header_778840, nil, nil)

var getReposOwnerRepoCompareBaseIdHeadId* = Call_GetReposOwnerRepoCompareBaseIdHeadId_778829(
    name: "getReposOwnerRepoCompareBaseIdHeadId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/compare/{baseId}...{headId}",
    validator: validate_GetReposOwnerRepoCompareBaseIdHeadId_778830, base: "/",
    url: url_GetReposOwnerRepoCompareBaseIdHeadId_778831, schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoContentsPath_778855 = ref object of OpenApiRestCall_777573
proc url_PutReposOwnerRepoContentsPath_778857(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/contents/"),
               (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoContentsPath_778856(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a file.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   path: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778858 = path.getOrDefault("repo")
  valid_778858 = validateParameter(valid_778858, JString, required = true,
                                 default = nil)
  if valid_778858 != nil:
    section.add "repo", valid_778858
  var valid_778859 = path.getOrDefault("owner")
  valid_778859 = validateParameter(valid_778859, JString, required = true,
                                 default = nil)
  if valid_778859 != nil:
    section.add "owner", valid_778859
  var valid_778860 = path.getOrDefault("path")
  valid_778860 = validateParameter(valid_778860, JString, required = true,
                                 default = nil)
  if valid_778860 != nil:
    section.add "path", valid_778860
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778861 = header.getOrDefault("Accept")
  valid_778861 = validateParameter(valid_778861, JString, required = false,
                                 default = nil)
  if valid_778861 != nil:
    section.add "Accept", valid_778861
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_778863: Call_PutReposOwnerRepoContentsPath_778855; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a file.
  ## 
  let valid = call_778863.validator(path, query, header, formData, body)
  let scheme = call_778863.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778863.url(scheme.get, call_778863.host, call_778863.base,
                         call_778863.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778863, url, valid)

proc call*(call_778864: Call_PutReposOwnerRepoContentsPath_778855; repo: string;
          owner: string; body: JsonNode; path: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoContentsPath
  ## Create a file.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   path: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778865 = newJObject()
  var header_778866 = newJObject()
  var body_778867 = newJObject()
  add(path_778865, "repo", newJString(repo))
  add(path_778865, "owner", newJString(owner))
  if body != nil:
    body_778867 = body
  add(path_778865, "path", newJString(path))
  add(header_778866, "Accept", newJString(Accept))
  result = call_778864.call(path_778865, nil, header_778866, nil, body_778867)

var putReposOwnerRepoContentsPath* = Call_PutReposOwnerRepoContentsPath_778855(
    name: "putReposOwnerRepoContentsPath", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contents/{path}",
    validator: validate_PutReposOwnerRepoContentsPath_778856, base: "/",
    url: url_PutReposOwnerRepoContentsPath_778857, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoContentsPath_778841 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoContentsPath_778843(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/contents/"),
               (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoContentsPath_778842(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get contents.
  ## This method returns the contents of a file or directory in a repository.
  ## Files and symlinks support a custom media type for getting the raw content.
  ## Directories and submodules do not support custom media types.
  ## Note: This API supports files up to 1 megabyte in size.
  ## Here can be many outcomes. For details see "http://developer.github.com/v3/repos/contents/"
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   path: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778844 = path.getOrDefault("repo")
  valid_778844 = validateParameter(valid_778844, JString, required = true,
                                 default = nil)
  if valid_778844 != nil:
    section.add "repo", valid_778844
  var valid_778845 = path.getOrDefault("owner")
  valid_778845 = validateParameter(valid_778845, JString, required = true,
                                 default = nil)
  if valid_778845 != nil:
    section.add "owner", valid_778845
  var valid_778846 = path.getOrDefault("path")
  valid_778846 = validateParameter(valid_778846, JString, required = true,
                                 default = nil)
  if valid_778846 != nil:
    section.add "path", valid_778846
  result.add "path", section
  ## parameters in `query` object:
  ##   path: JString
  ##       : The content path.
  ##   ref: JString
  ##      : The String name of the Commit/Branch/Tag. Defaults to 'master'.
  section = newJObject()
  var valid_778847 = query.getOrDefault("path")
  valid_778847 = validateParameter(valid_778847, JString, required = false,
                                 default = nil)
  if valid_778847 != nil:
    section.add "path", valid_778847
  var valid_778848 = query.getOrDefault("ref")
  valid_778848 = validateParameter(valid_778848, JString, required = false,
                                 default = nil)
  if valid_778848 != nil:
    section.add "ref", valid_778848
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778849 = header.getOrDefault("Accept")
  valid_778849 = validateParameter(valid_778849, JString, required = false,
                                 default = nil)
  if valid_778849 != nil:
    section.add "Accept", valid_778849
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778850: Call_GetReposOwnerRepoContentsPath_778841; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get contents.
  ## This method returns the contents of a file or directory in a repository.
  ## Files and symlinks support a custom media type for getting the raw content.
  ## Directories and submodules do not support custom media types.
  ## Note: This API supports files up to 1 megabyte in size.
  ## Here can be many outcomes. For details see "http://developer.github.com/v3/repos/contents/"
  ## 
  ## 
  let valid = call_778850.validator(path, query, header, formData, body)
  let scheme = call_778850.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778850.url(scheme.get, call_778850.host, call_778850.base,
                         call_778850.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778850, url, valid)

var getReposOwnerRepoContentsPath* = Call_GetReposOwnerRepoContentsPath_778841(
    name: "getReposOwnerRepoContentsPath", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contents/{path}",
    validator: validate_GetReposOwnerRepoContentsPath_778842, base: "/",
    url: url_GetReposOwnerRepoContentsPath_778843, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoContentsPath_778868 = ref object of OpenApiRestCall_777573
proc url_DeleteReposOwnerRepoContentsPath_778870(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/contents/"),
               (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoContentsPath_778869(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a file.
  ## This method deletes a file in a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   path: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778871 = path.getOrDefault("repo")
  valid_778871 = validateParameter(valid_778871, JString, required = true,
                                 default = nil)
  if valid_778871 != nil:
    section.add "repo", valid_778871
  var valid_778872 = path.getOrDefault("owner")
  valid_778872 = validateParameter(valid_778872, JString, required = true,
                                 default = nil)
  if valid_778872 != nil:
    section.add "owner", valid_778872
  var valid_778873 = path.getOrDefault("path")
  valid_778873 = validateParameter(valid_778873, JString, required = true,
                                 default = nil)
  if valid_778873 != nil:
    section.add "path", valid_778873
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778874 = header.getOrDefault("Accept")
  valid_778874 = validateParameter(valid_778874, JString, required = false,
                                 default = nil)
  if valid_778874 != nil:
    section.add "Accept", valid_778874
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_778876: Call_DeleteReposOwnerRepoContentsPath_778868;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a file.
  ## This method deletes a file in a repository.
  ## 
  ## 
  let valid = call_778876.validator(path, query, header, formData, body)
  let scheme = call_778876.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778876.url(scheme.get, call_778876.host, call_778876.base,
                         call_778876.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778876, url, valid)

proc call*(call_778877: Call_DeleteReposOwnerRepoContentsPath_778868; repo: string;
          owner: string; body: JsonNode; path: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoContentsPath
  ## Delete a file.
  ## This method deletes a file in a repository.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   path: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778878 = newJObject()
  var header_778879 = newJObject()
  var body_778880 = newJObject()
  add(path_778878, "repo", newJString(repo))
  add(path_778878, "owner", newJString(owner))
  if body != nil:
    body_778880 = body
  add(path_778878, "path", newJString(path))
  add(header_778879, "Accept", newJString(Accept))
  result = call_778877.call(path_778878, nil, header_778879, nil, body_778880)

var deleteReposOwnerRepoContentsPath* = Call_DeleteReposOwnerRepoContentsPath_778868(
    name: "deleteReposOwnerRepoContentsPath", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contents/{path}",
    validator: validate_DeleteReposOwnerRepoContentsPath_778869, base: "/",
    url: url_DeleteReposOwnerRepoContentsPath_778870, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoContributors_778881 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoContributors_778883(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/contributors")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoContributors_778882(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get list of contributors.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778884 = path.getOrDefault("repo")
  valid_778884 = validateParameter(valid_778884, JString, required = true,
                                 default = nil)
  if valid_778884 != nil:
    section.add "repo", valid_778884
  var valid_778885 = path.getOrDefault("owner")
  valid_778885 = validateParameter(valid_778885, JString, required = true,
                                 default = nil)
  if valid_778885 != nil:
    section.add "owner", valid_778885
  result.add "path", section
  ## parameters in `query` object:
  ##   anon: JString (required)
  ##       : Set to 1 or true to include anonymous contributors in results.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `anon` field"
  var valid_778886 = query.getOrDefault("anon")
  valid_778886 = validateParameter(valid_778886, JString, required = true,
                                 default = nil)
  if valid_778886 != nil:
    section.add "anon", valid_778886
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778887 = header.getOrDefault("Accept")
  valid_778887 = validateParameter(valid_778887, JString, required = false,
                                 default = nil)
  if valid_778887 != nil:
    section.add "Accept", valid_778887
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778888: Call_GetReposOwnerRepoContributors_778881; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get list of contributors.
  ## 
  let valid = call_778888.validator(path, query, header, formData, body)
  let scheme = call_778888.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778888.url(scheme.get, call_778888.host, call_778888.base,
                         call_778888.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778888, url, valid)

proc call*(call_778889: Call_GetReposOwnerRepoContributors_778881; repo: string;
          owner: string; anon: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoContributors
  ## Get list of contributors.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   anon: string (required)
  ##       : Set to 1 or true to include anonymous contributors in results.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778890 = newJObject()
  var query_778891 = newJObject()
  var header_778892 = newJObject()
  add(path_778890, "repo", newJString(repo))
  add(path_778890, "owner", newJString(owner))
  add(query_778891, "anon", newJString(anon))
  add(header_778892, "Accept", newJString(Accept))
  result = call_778889.call(path_778890, query_778891, header_778892, nil, nil)

var getReposOwnerRepoContributors* = Call_GetReposOwnerRepoContributors_778881(
    name: "getReposOwnerRepoContributors", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contributors",
    validator: validate_GetReposOwnerRepoContributors_778882, base: "/",
    url: url_GetReposOwnerRepoContributors_778883, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoDeployments_778903 = ref object of OpenApiRestCall_777573
proc url_PostReposOwnerRepoDeployments_778905(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/deployments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoDeployments_778904(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Users with push access can create a deployment for a given ref
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778906 = path.getOrDefault("repo")
  valid_778906 = validateParameter(valid_778906, JString, required = true,
                                 default = nil)
  if valid_778906 != nil:
    section.add "repo", valid_778906
  var valid_778907 = path.getOrDefault("owner")
  valid_778907 = validateParameter(valid_778907, JString, required = true,
                                 default = nil)
  if valid_778907 != nil:
    section.add "owner", valid_778907
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778908 = header.getOrDefault("Accept")
  valid_778908 = validateParameter(valid_778908, JString, required = false,
                                 default = nil)
  if valid_778908 != nil:
    section.add "Accept", valid_778908
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_778910: Call_PostReposOwnerRepoDeployments_778903; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Users with push access can create a deployment for a given ref
  ## 
  let valid = call_778910.validator(path, query, header, formData, body)
  let scheme = call_778910.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778910.url(scheme.get, call_778910.host, call_778910.base,
                         call_778910.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778910, url, valid)

proc call*(call_778911: Call_PostReposOwnerRepoDeployments_778903; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoDeployments
  ## Users with push access can create a deployment for a given ref
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778912 = newJObject()
  var header_778913 = newJObject()
  var body_778914 = newJObject()
  add(path_778912, "repo", newJString(repo))
  add(path_778912, "owner", newJString(owner))
  if body != nil:
    body_778914 = body
  add(header_778913, "Accept", newJString(Accept))
  result = call_778911.call(path_778912, nil, header_778913, nil, body_778914)

var postReposOwnerRepoDeployments* = Call_PostReposOwnerRepoDeployments_778903(
    name: "postReposOwnerRepoDeployments", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/deployments",
    validator: validate_PostReposOwnerRepoDeployments_778904, base: "/",
    url: url_PostReposOwnerRepoDeployments_778905, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDeployments_778893 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoDeployments_778895(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/deployments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDeployments_778894(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Users with pull access can view deployments for a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778896 = path.getOrDefault("repo")
  valid_778896 = validateParameter(valid_778896, JString, required = true,
                                 default = nil)
  if valid_778896 != nil:
    section.add "repo", valid_778896
  var valid_778897 = path.getOrDefault("owner")
  valid_778897 = validateParameter(valid_778897, JString, required = true,
                                 default = nil)
  if valid_778897 != nil:
    section.add "owner", valid_778897
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778898 = header.getOrDefault("Accept")
  valid_778898 = validateParameter(valid_778898, JString, required = false,
                                 default = nil)
  if valid_778898 != nil:
    section.add "Accept", valid_778898
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778899: Call_GetReposOwnerRepoDeployments_778893; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Users with pull access can view deployments for a repository
  ## 
  let valid = call_778899.validator(path, query, header, formData, body)
  let scheme = call_778899.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778899.url(scheme.get, call_778899.host, call_778899.base,
                         call_778899.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778899, url, valid)

proc call*(call_778900: Call_GetReposOwnerRepoDeployments_778893; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDeployments
  ## Users with pull access can view deployments for a repository
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778901 = newJObject()
  var header_778902 = newJObject()
  add(path_778901, "repo", newJString(repo))
  add(path_778901, "owner", newJString(owner))
  add(header_778902, "Accept", newJString(Accept))
  result = call_778900.call(path_778901, nil, header_778902, nil, nil)

var getReposOwnerRepoDeployments* = Call_GetReposOwnerRepoDeployments_778893(
    name: "getReposOwnerRepoDeployments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/deployments",
    validator: validate_GetReposOwnerRepoDeployments_778894, base: "/",
    url: url_GetReposOwnerRepoDeployments_778895, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoDeploymentsIdStatuses_778926 = ref object of OpenApiRestCall_777573
proc url_PostReposOwnerRepoDeploymentsIdStatuses_778928(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/deployments/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/statuses")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoDeploymentsIdStatuses_778927(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a Deployment Status
  ## Users with push access can create deployment statuses for a given deployment:
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   id: JInt (required)
  ##     : The Deployment ID to list the statuses from.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778929 = path.getOrDefault("repo")
  valid_778929 = validateParameter(valid_778929, JString, required = true,
                                 default = nil)
  if valid_778929 != nil:
    section.add "repo", valid_778929
  var valid_778930 = path.getOrDefault("id")
  valid_778930 = validateParameter(valid_778930, JInt, required = true, default = nil)
  if valid_778930 != nil:
    section.add "id", valid_778930
  var valid_778931 = path.getOrDefault("owner")
  valid_778931 = validateParameter(valid_778931, JString, required = true,
                                 default = nil)
  if valid_778931 != nil:
    section.add "owner", valid_778931
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778932 = header.getOrDefault("Accept")
  valid_778932 = validateParameter(valid_778932, JString, required = false,
                                 default = nil)
  if valid_778932 != nil:
    section.add "Accept", valid_778932
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_778934: Call_PostReposOwnerRepoDeploymentsIdStatuses_778926;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Create a Deployment Status
  ## Users with push access can create deployment statuses for a given deployment:
  ## 
  ## 
  let valid = call_778934.validator(path, query, header, formData, body)
  let scheme = call_778934.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778934.url(scheme.get, call_778934.host, call_778934.base,
                         call_778934.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778934, url, valid)

proc call*(call_778935: Call_PostReposOwnerRepoDeploymentsIdStatuses_778926;
          repo: string; id: int; owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoDeploymentsIdStatuses
  ## Create a Deployment Status
  ## Users with push access can create deployment statuses for a given deployment:
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   id: int (required)
  ##     : The Deployment ID to list the statuses from.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778936 = newJObject()
  var header_778937 = newJObject()
  var body_778938 = newJObject()
  add(path_778936, "repo", newJString(repo))
  add(path_778936, "id", newJInt(id))
  add(path_778936, "owner", newJString(owner))
  if body != nil:
    body_778938 = body
  add(header_778937, "Accept", newJString(Accept))
  result = call_778935.call(path_778936, nil, header_778937, nil, body_778938)

var postReposOwnerRepoDeploymentsIdStatuses* = Call_PostReposOwnerRepoDeploymentsIdStatuses_778926(
    name: "postReposOwnerRepoDeploymentsIdStatuses", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/deployments/{id}/statuses",
    validator: validate_PostReposOwnerRepoDeploymentsIdStatuses_778927, base: "/",
    url: url_PostReposOwnerRepoDeploymentsIdStatuses_778928,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDeploymentsIdStatuses_778915 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoDeploymentsIdStatuses_778917(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/deployments/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/statuses")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDeploymentsIdStatuses_778916(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Users with pull access can view deployment statuses for a deployment
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   id: JInt (required)
  ##     : The Deployment ID to list the statuses from.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778918 = path.getOrDefault("repo")
  valid_778918 = validateParameter(valid_778918, JString, required = true,
                                 default = nil)
  if valid_778918 != nil:
    section.add "repo", valid_778918
  var valid_778919 = path.getOrDefault("id")
  valid_778919 = validateParameter(valid_778919, JInt, required = true, default = nil)
  if valid_778919 != nil:
    section.add "id", valid_778919
  var valid_778920 = path.getOrDefault("owner")
  valid_778920 = validateParameter(valid_778920, JString, required = true,
                                 default = nil)
  if valid_778920 != nil:
    section.add "owner", valid_778920
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778921 = header.getOrDefault("Accept")
  valid_778921 = validateParameter(valid_778921, JString, required = false,
                                 default = nil)
  if valid_778921 != nil:
    section.add "Accept", valid_778921
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778922: Call_GetReposOwnerRepoDeploymentsIdStatuses_778915;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Users with pull access can view deployment statuses for a deployment
  ## 
  let valid = call_778922.validator(path, query, header, formData, body)
  let scheme = call_778922.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778922.url(scheme.get, call_778922.host, call_778922.base,
                         call_778922.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778922, url, valid)

proc call*(call_778923: Call_GetReposOwnerRepoDeploymentsIdStatuses_778915;
          repo: string; id: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDeploymentsIdStatuses
  ## Users with pull access can view deployment statuses for a deployment
  ##   repo: string (required)
  ##       : Name of repository.
  ##   id: int (required)
  ##     : The Deployment ID to list the statuses from.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778924 = newJObject()
  var header_778925 = newJObject()
  add(path_778924, "repo", newJString(repo))
  add(path_778924, "id", newJInt(id))
  add(path_778924, "owner", newJString(owner))
  add(header_778925, "Accept", newJString(Accept))
  result = call_778923.call(path_778924, nil, header_778925, nil, nil)

var getReposOwnerRepoDeploymentsIdStatuses* = Call_GetReposOwnerRepoDeploymentsIdStatuses_778915(
    name: "getReposOwnerRepoDeploymentsIdStatuses", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/deployments/{id}/statuses",
    validator: validate_GetReposOwnerRepoDeploymentsIdStatuses_778916, base: "/",
    url: url_GetReposOwnerRepoDeploymentsIdStatuses_778917,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDownloads_778939 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoDownloads_778941(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/downloads")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDownloads_778940(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deprecated. List downloads for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778942 = path.getOrDefault("repo")
  valid_778942 = validateParameter(valid_778942, JString, required = true,
                                 default = nil)
  if valid_778942 != nil:
    section.add "repo", valid_778942
  var valid_778943 = path.getOrDefault("owner")
  valid_778943 = validateParameter(valid_778943, JString, required = true,
                                 default = nil)
  if valid_778943 != nil:
    section.add "owner", valid_778943
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778944 = header.getOrDefault("Accept")
  valid_778944 = validateParameter(valid_778944, JString, required = false,
                                 default = nil)
  if valid_778944 != nil:
    section.add "Accept", valid_778944
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778945: Call_GetReposOwnerRepoDownloads_778939; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deprecated. List downloads for a repository.
  ## 
  let valid = call_778945.validator(path, query, header, formData, body)
  let scheme = call_778945.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778945.url(scheme.get, call_778945.host, call_778945.base,
                         call_778945.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778945, url, valid)

proc call*(call_778946: Call_GetReposOwnerRepoDownloads_778939; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDownloads
  ## Deprecated. List downloads for a repository.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778947 = newJObject()
  var header_778948 = newJObject()
  add(path_778947, "repo", newJString(repo))
  add(path_778947, "owner", newJString(owner))
  add(header_778948, "Accept", newJString(Accept))
  result = call_778946.call(path_778947, nil, header_778948, nil, nil)

var getReposOwnerRepoDownloads* = Call_GetReposOwnerRepoDownloads_778939(
    name: "getReposOwnerRepoDownloads", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/downloads",
    validator: validate_GetReposOwnerRepoDownloads_778940, base: "/",
    url: url_GetReposOwnerRepoDownloads_778941, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDownloadsDownloadId_778949 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoDownloadsDownloadId_778951(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "downloadId" in path, "`downloadId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/downloads/"),
               (kind: VariableSegment, value: "downloadId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDownloadsDownloadId_778950(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deprecated. Get a single download.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   downloadId: JInt (required)
  ##             : Id of download.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778952 = path.getOrDefault("repo")
  valid_778952 = validateParameter(valid_778952, JString, required = true,
                                 default = nil)
  if valid_778952 != nil:
    section.add "repo", valid_778952
  var valid_778953 = path.getOrDefault("downloadId")
  valid_778953 = validateParameter(valid_778953, JInt, required = true, default = nil)
  if valid_778953 != nil:
    section.add "downloadId", valid_778953
  var valid_778954 = path.getOrDefault("owner")
  valid_778954 = validateParameter(valid_778954, JString, required = true,
                                 default = nil)
  if valid_778954 != nil:
    section.add "owner", valid_778954
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778955 = header.getOrDefault("Accept")
  valid_778955 = validateParameter(valid_778955, JString, required = false,
                                 default = nil)
  if valid_778955 != nil:
    section.add "Accept", valid_778955
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778956: Call_GetReposOwnerRepoDownloadsDownloadId_778949;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deprecated. Get a single download.
  ## 
  let valid = call_778956.validator(path, query, header, formData, body)
  let scheme = call_778956.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778956.url(scheme.get, call_778956.host, call_778956.base,
                         call_778956.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778956, url, valid)

proc call*(call_778957: Call_GetReposOwnerRepoDownloadsDownloadId_778949;
          repo: string; downloadId: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDownloadsDownloadId
  ## Deprecated. Get a single download.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   downloadId: int (required)
  ##             : Id of download.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778958 = newJObject()
  var header_778959 = newJObject()
  add(path_778958, "repo", newJString(repo))
  add(path_778958, "downloadId", newJInt(downloadId))
  add(path_778958, "owner", newJString(owner))
  add(header_778959, "Accept", newJString(Accept))
  result = call_778957.call(path_778958, nil, header_778959, nil, nil)

var getReposOwnerRepoDownloadsDownloadId* = Call_GetReposOwnerRepoDownloadsDownloadId_778949(
    name: "getReposOwnerRepoDownloadsDownloadId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/downloads/{downloadId}",
    validator: validate_GetReposOwnerRepoDownloadsDownloadId_778950, base: "/",
    url: url_GetReposOwnerRepoDownloadsDownloadId_778951, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoDownloadsDownloadId_778960 = ref object of OpenApiRestCall_777573
proc url_DeleteReposOwnerRepoDownloadsDownloadId_778962(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "downloadId" in path, "`downloadId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/downloads/"),
               (kind: VariableSegment, value: "downloadId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoDownloadsDownloadId_778961(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deprecated. Delete a download.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   downloadId: JInt (required)
  ##             : Id of download.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778963 = path.getOrDefault("repo")
  valid_778963 = validateParameter(valid_778963, JString, required = true,
                                 default = nil)
  if valid_778963 != nil:
    section.add "repo", valid_778963
  var valid_778964 = path.getOrDefault("downloadId")
  valid_778964 = validateParameter(valid_778964, JInt, required = true, default = nil)
  if valid_778964 != nil:
    section.add "downloadId", valid_778964
  var valid_778965 = path.getOrDefault("owner")
  valid_778965 = validateParameter(valid_778965, JString, required = true,
                                 default = nil)
  if valid_778965 != nil:
    section.add "owner", valid_778965
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778966 = header.getOrDefault("Accept")
  valid_778966 = validateParameter(valid_778966, JString, required = false,
                                 default = nil)
  if valid_778966 != nil:
    section.add "Accept", valid_778966
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778967: Call_DeleteReposOwnerRepoDownloadsDownloadId_778960;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deprecated. Delete a download.
  ## 
  let valid = call_778967.validator(path, query, header, formData, body)
  let scheme = call_778967.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778967.url(scheme.get, call_778967.host, call_778967.base,
                         call_778967.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778967, url, valid)

proc call*(call_778968: Call_DeleteReposOwnerRepoDownloadsDownloadId_778960;
          repo: string; downloadId: int; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoDownloadsDownloadId
  ## Deprecated. Delete a download.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   downloadId: int (required)
  ##             : Id of download.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778969 = newJObject()
  var header_778970 = newJObject()
  add(path_778969, "repo", newJString(repo))
  add(path_778969, "downloadId", newJInt(downloadId))
  add(path_778969, "owner", newJString(owner))
  add(header_778970, "Accept", newJString(Accept))
  result = call_778968.call(path_778969, nil, header_778970, nil, nil)

var deleteReposOwnerRepoDownloadsDownloadId* = Call_DeleteReposOwnerRepoDownloadsDownloadId_778960(
    name: "deleteReposOwnerRepoDownloadsDownloadId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/downloads/{downloadId}",
    validator: validate_DeleteReposOwnerRepoDownloadsDownloadId_778961, base: "/",
    url: url_DeleteReposOwnerRepoDownloadsDownloadId_778962,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoEvents_778971 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoEvents_778973(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoEvents_778972(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get list of repository events.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778974 = path.getOrDefault("repo")
  valid_778974 = validateParameter(valid_778974, JString, required = true,
                                 default = nil)
  if valid_778974 != nil:
    section.add "repo", valid_778974
  var valid_778975 = path.getOrDefault("owner")
  valid_778975 = validateParameter(valid_778975, JString, required = true,
                                 default = nil)
  if valid_778975 != nil:
    section.add "owner", valid_778975
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778976 = header.getOrDefault("Accept")
  valid_778976 = validateParameter(valid_778976, JString, required = false,
                                 default = nil)
  if valid_778976 != nil:
    section.add "Accept", valid_778976
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778977: Call_GetReposOwnerRepoEvents_778971; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get list of repository events.
  ## 
  let valid = call_778977.validator(path, query, header, formData, body)
  let scheme = call_778977.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778977.url(scheme.get, call_778977.host, call_778977.base,
                         call_778977.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778977, url, valid)

proc call*(call_778978: Call_GetReposOwnerRepoEvents_778971; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoEvents
  ## Get list of repository events.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_778979 = newJObject()
  var header_778980 = newJObject()
  add(path_778979, "repo", newJString(repo))
  add(path_778979, "owner", newJString(owner))
  add(header_778980, "Accept", newJString(Accept))
  result = call_778978.call(path_778979, nil, header_778980, nil, nil)

var getReposOwnerRepoEvents* = Call_GetReposOwnerRepoEvents_778971(
    name: "getReposOwnerRepoEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/events",
    validator: validate_GetReposOwnerRepoEvents_778972, base: "/",
    url: url_GetReposOwnerRepoEvents_778973, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoForks_778993 = ref object of OpenApiRestCall_777573
proc url_PostReposOwnerRepoForks_778995(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/forks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoForks_778994(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a fork.
  ## Forking a Repository happens asynchronously. Therefore, you may have to wai
  ## a short period before accessing the git objects. If this takes longer than 5
  ## minutes, be sure to contact Support.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778996 = path.getOrDefault("repo")
  valid_778996 = validateParameter(valid_778996, JString, required = true,
                                 default = nil)
  if valid_778996 != nil:
    section.add "repo", valid_778996
  var valid_778997 = path.getOrDefault("owner")
  valid_778997 = validateParameter(valid_778997, JString, required = true,
                                 default = nil)
  if valid_778997 != nil:
    section.add "owner", valid_778997
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778998 = header.getOrDefault("Accept")
  valid_778998 = validateParameter(valid_778998, JString, required = false,
                                 default = nil)
  if valid_778998 != nil:
    section.add "Accept", valid_778998
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_779000: Call_PostReposOwnerRepoForks_778993; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a fork.
  ## Forking a Repository happens asynchronously. Therefore, you may have to wai
  ## a short period before accessing the git objects. If this takes longer than 5
  ## minutes, be sure to contact Support.
  ## 
  ## 
  let valid = call_779000.validator(path, query, header, formData, body)
  let scheme = call_779000.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779000.url(scheme.get, call_779000.host, call_779000.base,
                         call_779000.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779000, url, valid)

proc call*(call_779001: Call_PostReposOwnerRepoForks_778993; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoForks
  ## Create a fork.
  ## Forking a Repository happens asynchronously. Therefore, you may have to wai
  ## a short period before accessing the git objects. If this takes longer than 5
  ## minutes, be sure to contact Support.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779002 = newJObject()
  var header_779003 = newJObject()
  var body_779004 = newJObject()
  add(path_779002, "repo", newJString(repo))
  add(path_779002, "owner", newJString(owner))
  if body != nil:
    body_779004 = body
  add(header_779003, "Accept", newJString(Accept))
  result = call_779001.call(path_779002, nil, header_779003, nil, body_779004)

var postReposOwnerRepoForks* = Call_PostReposOwnerRepoForks_778993(
    name: "postReposOwnerRepoForks", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/forks",
    validator: validate_PostReposOwnerRepoForks_778994, base: "/",
    url: url_PostReposOwnerRepoForks_778995, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoForks_778981 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoForks_778983(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/forks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoForks_778982(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List forks.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_778984 = path.getOrDefault("repo")
  valid_778984 = validateParameter(valid_778984, JString, required = true,
                                 default = nil)
  if valid_778984 != nil:
    section.add "repo", valid_778984
  var valid_778985 = path.getOrDefault("owner")
  valid_778985 = validateParameter(valid_778985, JString, required = true,
                                 default = nil)
  if valid_778985 != nil:
    section.add "owner", valid_778985
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  section = newJObject()
  var valid_778986 = query.getOrDefault("sort")
  valid_778986 = validateParameter(valid_778986, JString, required = false,
                                 default = newJString("newes"))
  if valid_778986 != nil:
    section.add "sort", valid_778986
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_778987 = header.getOrDefault("Accept")
  valid_778987 = validateParameter(valid_778987, JString, required = false,
                                 default = nil)
  if valid_778987 != nil:
    section.add "Accept", valid_778987
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_778988: Call_GetReposOwnerRepoForks_778981; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List forks.
  ## 
  let valid = call_778988.validator(path, query, header, formData, body)
  let scheme = call_778988.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_778988.url(scheme.get, call_778988.host, call_778988.base,
                         call_778988.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_778988, url, valid)

proc call*(call_778989: Call_GetReposOwnerRepoForks_778981; repo: string;
          owner: string; Accept: string = ""; sort: string = "newes"): Recallable =
  ## getReposOwnerRepoForks
  ## List forks.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  var path_778990 = newJObject()
  var query_778991 = newJObject()
  var header_778992 = newJObject()
  add(path_778990, "repo", newJString(repo))
  add(path_778990, "owner", newJString(owner))
  add(header_778992, "Accept", newJString(Accept))
  add(query_778991, "sort", newJString(sort))
  result = call_778989.call(path_778990, query_778991, header_778992, nil, nil)

var getReposOwnerRepoForks* = Call_GetReposOwnerRepoForks_778981(
    name: "getReposOwnerRepoForks", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/forks",
    validator: validate_GetReposOwnerRepoForks_778982, base: "/",
    url: url_GetReposOwnerRepoForks_778983, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitBlobs_779005 = ref object of OpenApiRestCall_777573
proc url_PostReposOwnerRepoGitBlobs_779007(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/blobs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitBlobs_779006(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a Blob.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779008 = path.getOrDefault("repo")
  valid_779008 = validateParameter(valid_779008, JString, required = true,
                                 default = nil)
  if valid_779008 != nil:
    section.add "repo", valid_779008
  var valid_779009 = path.getOrDefault("owner")
  valid_779009 = validateParameter(valid_779009, JString, required = true,
                                 default = nil)
  if valid_779009 != nil:
    section.add "owner", valid_779009
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779010 = header.getOrDefault("Accept")
  valid_779010 = validateParameter(valid_779010, JString, required = false,
                                 default = nil)
  if valid_779010 != nil:
    section.add "Accept", valid_779010
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_779012: Call_PostReposOwnerRepoGitBlobs_779005; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a Blob.
  ## 
  let valid = call_779012.validator(path, query, header, formData, body)
  let scheme = call_779012.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779012.url(scheme.get, call_779012.host, call_779012.base,
                         call_779012.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779012, url, valid)

proc call*(call_779013: Call_PostReposOwnerRepoGitBlobs_779005; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitBlobs
  ## Create a Blob.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779014 = newJObject()
  var header_779015 = newJObject()
  var body_779016 = newJObject()
  add(path_779014, "repo", newJString(repo))
  add(path_779014, "owner", newJString(owner))
  if body != nil:
    body_779016 = body
  add(header_779015, "Accept", newJString(Accept))
  result = call_779013.call(path_779014, nil, header_779015, nil, body_779016)

var postReposOwnerRepoGitBlobs* = Call_PostReposOwnerRepoGitBlobs_779005(
    name: "postReposOwnerRepoGitBlobs", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/blobs",
    validator: validate_PostReposOwnerRepoGitBlobs_779006, base: "/",
    url: url_PostReposOwnerRepoGitBlobs_779007, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitBlobsShaCode_779017 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoGitBlobsShaCode_779019(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/blobs/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitBlobsShaCode_779018(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a Blob.
  ## Since blobs can be any arbitrary binary data, the input and responses for
  ## the blob API takes an encoding parameter that can be either utf-8 or
  ## base64. If your data cannot be losslessly sent as a UTF-8 string, you can
  ## base64 encode it.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   shaCode: JString (required)
  ##          : SHA-1 code.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779020 = path.getOrDefault("repo")
  valid_779020 = validateParameter(valid_779020, JString, required = true,
                                 default = nil)
  if valid_779020 != nil:
    section.add "repo", valid_779020
  var valid_779021 = path.getOrDefault("owner")
  valid_779021 = validateParameter(valid_779021, JString, required = true,
                                 default = nil)
  if valid_779021 != nil:
    section.add "owner", valid_779021
  var valid_779022 = path.getOrDefault("shaCode")
  valid_779022 = validateParameter(valid_779022, JString, required = true,
                                 default = nil)
  if valid_779022 != nil:
    section.add "shaCode", valid_779022
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779023 = header.getOrDefault("Accept")
  valid_779023 = validateParameter(valid_779023, JString, required = false,
                                 default = nil)
  if valid_779023 != nil:
    section.add "Accept", valid_779023
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779024: Call_GetReposOwnerRepoGitBlobsShaCode_779017;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a Blob.
  ## Since blobs can be any arbitrary binary data, the input and responses for
  ## the blob API takes an encoding parameter that can be either utf-8 or
  ## base64. If your data cannot be losslessly sent as a UTF-8 string, you can
  ## base64 encode it.
  ## 
  ## 
  let valid = call_779024.validator(path, query, header, formData, body)
  let scheme = call_779024.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779024.url(scheme.get, call_779024.host, call_779024.base,
                         call_779024.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779024, url, valid)

proc call*(call_779025: Call_GetReposOwnerRepoGitBlobsShaCode_779017; repo: string;
          owner: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitBlobsShaCode
  ## Get a Blob.
  ## Since blobs can be any arbitrary binary data, the input and responses for
  ## the blob API takes an encoding parameter that can be either utf-8 or
  ## base64. If your data cannot be losslessly sent as a UTF-8 string, you can
  ## base64 encode it.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   shaCode: string (required)
  ##          : SHA-1 code.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779026 = newJObject()
  var header_779027 = newJObject()
  add(path_779026, "repo", newJString(repo))
  add(path_779026, "owner", newJString(owner))
  add(path_779026, "shaCode", newJString(shaCode))
  add(header_779027, "Accept", newJString(Accept))
  result = call_779025.call(path_779026, nil, header_779027, nil, nil)

var getReposOwnerRepoGitBlobsShaCode* = Call_GetReposOwnerRepoGitBlobsShaCode_779017(
    name: "getReposOwnerRepoGitBlobsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/blobs/{shaCode}",
    validator: validate_GetReposOwnerRepoGitBlobsShaCode_779018, base: "/",
    url: url_GetReposOwnerRepoGitBlobsShaCode_779019, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitCommits_779028 = ref object of OpenApiRestCall_777573
proc url_PostReposOwnerRepoGitCommits_779030(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/commits")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitCommits_779029(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a Commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779031 = path.getOrDefault("repo")
  valid_779031 = validateParameter(valid_779031, JString, required = true,
                                 default = nil)
  if valid_779031 != nil:
    section.add "repo", valid_779031
  var valid_779032 = path.getOrDefault("owner")
  valid_779032 = validateParameter(valid_779032, JString, required = true,
                                 default = nil)
  if valid_779032 != nil:
    section.add "owner", valid_779032
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779033 = header.getOrDefault("Accept")
  valid_779033 = validateParameter(valid_779033, JString, required = false,
                                 default = nil)
  if valid_779033 != nil:
    section.add "Accept", valid_779033
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_779035: Call_PostReposOwnerRepoGitCommits_779028; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a Commit.
  ## 
  let valid = call_779035.validator(path, query, header, formData, body)
  let scheme = call_779035.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779035.url(scheme.get, call_779035.host, call_779035.base,
                         call_779035.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779035, url, valid)

proc call*(call_779036: Call_PostReposOwnerRepoGitCommits_779028; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitCommits
  ## Create a Commit.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779037 = newJObject()
  var header_779038 = newJObject()
  var body_779039 = newJObject()
  add(path_779037, "repo", newJString(repo))
  add(path_779037, "owner", newJString(owner))
  if body != nil:
    body_779039 = body
  add(header_779038, "Accept", newJString(Accept))
  result = call_779036.call(path_779037, nil, header_779038, nil, body_779039)

var postReposOwnerRepoGitCommits* = Call_PostReposOwnerRepoGitCommits_779028(
    name: "postReposOwnerRepoGitCommits", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/commits",
    validator: validate_PostReposOwnerRepoGitCommits_779029, base: "/",
    url: url_PostReposOwnerRepoGitCommits_779030, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitCommitsShaCode_779040 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoGitCommitsShaCode_779042(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/commits/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitCommitsShaCode_779041(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a Commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   shaCode: JString (required)
  ##          : SHA-1 code.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779043 = path.getOrDefault("repo")
  valid_779043 = validateParameter(valid_779043, JString, required = true,
                                 default = nil)
  if valid_779043 != nil:
    section.add "repo", valid_779043
  var valid_779044 = path.getOrDefault("owner")
  valid_779044 = validateParameter(valid_779044, JString, required = true,
                                 default = nil)
  if valid_779044 != nil:
    section.add "owner", valid_779044
  var valid_779045 = path.getOrDefault("shaCode")
  valid_779045 = validateParameter(valid_779045, JString, required = true,
                                 default = nil)
  if valid_779045 != nil:
    section.add "shaCode", valid_779045
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779046 = header.getOrDefault("Accept")
  valid_779046 = validateParameter(valid_779046, JString, required = false,
                                 default = nil)
  if valid_779046 != nil:
    section.add "Accept", valid_779046
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779047: Call_GetReposOwnerRepoGitCommitsShaCode_779040;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a Commit.
  ## 
  let valid = call_779047.validator(path, query, header, formData, body)
  let scheme = call_779047.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779047.url(scheme.get, call_779047.host, call_779047.base,
                         call_779047.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779047, url, valid)

proc call*(call_779048: Call_GetReposOwnerRepoGitCommitsShaCode_779040;
          repo: string; owner: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitCommitsShaCode
  ## Get a Commit.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   shaCode: string (required)
  ##          : SHA-1 code.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779049 = newJObject()
  var header_779050 = newJObject()
  add(path_779049, "repo", newJString(repo))
  add(path_779049, "owner", newJString(owner))
  add(path_779049, "shaCode", newJString(shaCode))
  add(header_779050, "Accept", newJString(Accept))
  result = call_779048.call(path_779049, nil, header_779050, nil, nil)

var getReposOwnerRepoGitCommitsShaCode* = Call_GetReposOwnerRepoGitCommitsShaCode_779040(
    name: "getReposOwnerRepoGitCommitsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/commits/{shaCode}",
    validator: validate_GetReposOwnerRepoGitCommitsShaCode_779041, base: "/",
    url: url_GetReposOwnerRepoGitCommitsShaCode_779042, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitRefs_779061 = ref object of OpenApiRestCall_777573
proc url_PostReposOwnerRepoGitRefs_779063(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitRefs_779062(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a Reference
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779064 = path.getOrDefault("repo")
  valid_779064 = validateParameter(valid_779064, JString, required = true,
                                 default = nil)
  if valid_779064 != nil:
    section.add "repo", valid_779064
  var valid_779065 = path.getOrDefault("owner")
  valid_779065 = validateParameter(valid_779065, JString, required = true,
                                 default = nil)
  if valid_779065 != nil:
    section.add "owner", valid_779065
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779066 = header.getOrDefault("Accept")
  valid_779066 = validateParameter(valid_779066, JString, required = false,
                                 default = nil)
  if valid_779066 != nil:
    section.add "Accept", valid_779066
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_779068: Call_PostReposOwnerRepoGitRefs_779061; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a Reference
  ## 
  let valid = call_779068.validator(path, query, header, formData, body)
  let scheme = call_779068.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779068.url(scheme.get, call_779068.host, call_779068.base,
                         call_779068.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779068, url, valid)

proc call*(call_779069: Call_PostReposOwnerRepoGitRefs_779061; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitRefs
  ## Create a Reference
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779070 = newJObject()
  var header_779071 = newJObject()
  var body_779072 = newJObject()
  add(path_779070, "repo", newJString(repo))
  add(path_779070, "owner", newJString(owner))
  if body != nil:
    body_779072 = body
  add(header_779071, "Accept", newJString(Accept))
  result = call_779069.call(path_779070, nil, header_779071, nil, body_779072)

var postReposOwnerRepoGitRefs* = Call_PostReposOwnerRepoGitRefs_779061(
    name: "postReposOwnerRepoGitRefs", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs",
    validator: validate_PostReposOwnerRepoGitRefs_779062, base: "/",
    url: url_PostReposOwnerRepoGitRefs_779063, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitRefs_779051 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoGitRefs_779053(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitRefs_779052(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get all References
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779054 = path.getOrDefault("repo")
  valid_779054 = validateParameter(valid_779054, JString, required = true,
                                 default = nil)
  if valid_779054 != nil:
    section.add "repo", valid_779054
  var valid_779055 = path.getOrDefault("owner")
  valid_779055 = validateParameter(valid_779055, JString, required = true,
                                 default = nil)
  if valid_779055 != nil:
    section.add "owner", valid_779055
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779056 = header.getOrDefault("Accept")
  valid_779056 = validateParameter(valid_779056, JString, required = false,
                                 default = nil)
  if valid_779056 != nil:
    section.add "Accept", valid_779056
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779057: Call_GetReposOwnerRepoGitRefs_779051; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get all References
  ## 
  let valid = call_779057.validator(path, query, header, formData, body)
  let scheme = call_779057.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779057.url(scheme.get, call_779057.host, call_779057.base,
                         call_779057.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779057, url, valid)

proc call*(call_779058: Call_GetReposOwnerRepoGitRefs_779051; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitRefs
  ## Get all References
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779059 = newJObject()
  var header_779060 = newJObject()
  add(path_779059, "repo", newJString(repo))
  add(path_779059, "owner", newJString(owner))
  add(header_779060, "Accept", newJString(Accept))
  result = call_779058.call(path_779059, nil, header_779060, nil, nil)

var getReposOwnerRepoGitRefs* = Call_GetReposOwnerRepoGitRefs_779051(
    name: "getReposOwnerRepoGitRefs", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs",
    validator: validate_GetReposOwnerRepoGitRefs_779052, base: "/",
    url: url_GetReposOwnerRepoGitRefs_779053, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitRefsRef_779073 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoGitRefsRef_779075(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitRefsRef_779074(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a Reference
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   ref: JString (required)
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779076 = path.getOrDefault("repo")
  valid_779076 = validateParameter(valid_779076, JString, required = true,
                                 default = nil)
  if valid_779076 != nil:
    section.add "repo", valid_779076
  var valid_779077 = path.getOrDefault("ref")
  valid_779077 = validateParameter(valid_779077, JString, required = true,
                                 default = nil)
  if valid_779077 != nil:
    section.add "ref", valid_779077
  var valid_779078 = path.getOrDefault("owner")
  valid_779078 = validateParameter(valid_779078, JString, required = true,
                                 default = nil)
  if valid_779078 != nil:
    section.add "owner", valid_779078
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779079 = header.getOrDefault("Accept")
  valid_779079 = validateParameter(valid_779079, JString, required = false,
                                 default = nil)
  if valid_779079 != nil:
    section.add "Accept", valid_779079
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779080: Call_GetReposOwnerRepoGitRefsRef_779073; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a Reference
  ## 
  let valid = call_779080.validator(path, query, header, formData, body)
  let scheme = call_779080.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779080.url(scheme.get, call_779080.host, call_779080.base,
                         call_779080.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779080, url, valid)

proc call*(call_779081: Call_GetReposOwnerRepoGitRefsRef_779073; repo: string;
          `ref`: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitRefsRef
  ## Get a Reference
  ##   repo: string (required)
  ##       : Name of repository.
  ##   ref: string (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779082 = newJObject()
  var header_779083 = newJObject()
  add(path_779082, "repo", newJString(repo))
  add(path_779082, "ref", newJString(`ref`))
  add(path_779082, "owner", newJString(owner))
  add(header_779083, "Accept", newJString(Accept))
  result = call_779081.call(path_779082, nil, header_779083, nil, nil)

var getReposOwnerRepoGitRefsRef* = Call_GetReposOwnerRepoGitRefsRef_779073(
    name: "getReposOwnerRepoGitRefsRef", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs/{ref}",
    validator: validate_GetReposOwnerRepoGitRefsRef_779074, base: "/",
    url: url_GetReposOwnerRepoGitRefsRef_779075, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoGitRefsRef_779095 = ref object of OpenApiRestCall_777573
proc url_PatchReposOwnerRepoGitRefsRef_779097(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoGitRefsRef_779096(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Update a Reference
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   ref: JString (required)
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779098 = path.getOrDefault("repo")
  valid_779098 = validateParameter(valid_779098, JString, required = true,
                                 default = nil)
  if valid_779098 != nil:
    section.add "repo", valid_779098
  var valid_779099 = path.getOrDefault("ref")
  valid_779099 = validateParameter(valid_779099, JString, required = true,
                                 default = nil)
  if valid_779099 != nil:
    section.add "ref", valid_779099
  var valid_779100 = path.getOrDefault("owner")
  valid_779100 = validateParameter(valid_779100, JString, required = true,
                                 default = nil)
  if valid_779100 != nil:
    section.add "owner", valid_779100
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779101 = header.getOrDefault("Accept")
  valid_779101 = validateParameter(valid_779101, JString, required = false,
                                 default = nil)
  if valid_779101 != nil:
    section.add "Accept", valid_779101
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_779103: Call_PatchReposOwnerRepoGitRefsRef_779095; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Update a Reference
  ## 
  let valid = call_779103.validator(path, query, header, formData, body)
  let scheme = call_779103.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779103.url(scheme.get, call_779103.host, call_779103.base,
                         call_779103.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779103, url, valid)

proc call*(call_779104: Call_PatchReposOwnerRepoGitRefsRef_779095; repo: string;
          `ref`: string; owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoGitRefsRef
  ## Update a Reference
  ##   repo: string (required)
  ##       : Name of repository.
  ##   ref: string (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779105 = newJObject()
  var header_779106 = newJObject()
  var body_779107 = newJObject()
  add(path_779105, "repo", newJString(repo))
  add(path_779105, "ref", newJString(`ref`))
  add(path_779105, "owner", newJString(owner))
  if body != nil:
    body_779107 = body
  add(header_779106, "Accept", newJString(Accept))
  result = call_779104.call(path_779105, nil, header_779106, nil, body_779107)

var patchReposOwnerRepoGitRefsRef* = Call_PatchReposOwnerRepoGitRefsRef_779095(
    name: "patchReposOwnerRepoGitRefsRef", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs/{ref}",
    validator: validate_PatchReposOwnerRepoGitRefsRef_779096, base: "/",
    url: url_PatchReposOwnerRepoGitRefsRef_779097, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoGitRefsRef_779084 = ref object of OpenApiRestCall_777573
proc url_DeleteReposOwnerRepoGitRefsRef_779086(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoGitRefsRef_779085(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a Reference
  ## Example: Deleting a branch: DELETE /repos/octocat/Hello-World/git/refs/heads/feature-a 
  ## Example: Deleting a tag:        DELETE /repos/octocat/Hello-World/git/refs/tags/v1.0
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   ref: JString (required)
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779087 = path.getOrDefault("repo")
  valid_779087 = validateParameter(valid_779087, JString, required = true,
                                 default = nil)
  if valid_779087 != nil:
    section.add "repo", valid_779087
  var valid_779088 = path.getOrDefault("ref")
  valid_779088 = validateParameter(valid_779088, JString, required = true,
                                 default = nil)
  if valid_779088 != nil:
    section.add "ref", valid_779088
  var valid_779089 = path.getOrDefault("owner")
  valid_779089 = validateParameter(valid_779089, JString, required = true,
                                 default = nil)
  if valid_779089 != nil:
    section.add "owner", valid_779089
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779090 = header.getOrDefault("Accept")
  valid_779090 = validateParameter(valid_779090, JString, required = false,
                                 default = nil)
  if valid_779090 != nil:
    section.add "Accept", valid_779090
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779091: Call_DeleteReposOwnerRepoGitRefsRef_779084; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete a Reference
  ## Example: Deleting a branch: DELETE /repos/octocat/Hello-World/git/refs/heads/feature-a 
  ## Example: Deleting a tag:        DELETE /repos/octocat/Hello-World/git/refs/tags/v1.0
  ## 
  ## 
  let valid = call_779091.validator(path, query, header, formData, body)
  let scheme = call_779091.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779091.url(scheme.get, call_779091.host, call_779091.base,
                         call_779091.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779091, url, valid)

proc call*(call_779092: Call_DeleteReposOwnerRepoGitRefsRef_779084; repo: string;
          `ref`: string; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoGitRefsRef
  ## Delete a Reference
  ## Example: Deleting a branch: DELETE /repos/octocat/Hello-World/git/refs/heads/feature-a 
  ## Example: Deleting a tag:        DELETE /repos/octocat/Hello-World/git/refs/tags/v1.0
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   ref: string (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779093 = newJObject()
  var header_779094 = newJObject()
  add(path_779093, "repo", newJString(repo))
  add(path_779093, "ref", newJString(`ref`))
  add(path_779093, "owner", newJString(owner))
  add(header_779094, "Accept", newJString(Accept))
  result = call_779092.call(path_779093, nil, header_779094, nil, nil)

var deleteReposOwnerRepoGitRefsRef* = Call_DeleteReposOwnerRepoGitRefsRef_779084(
    name: "deleteReposOwnerRepoGitRefsRef", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs/{ref}",
    validator: validate_DeleteReposOwnerRepoGitRefsRef_779085, base: "/",
    url: url_DeleteReposOwnerRepoGitRefsRef_779086, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitTags_779108 = ref object of OpenApiRestCall_777573
proc url_PostReposOwnerRepoGitTags_779110(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/tags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitTags_779109(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a Tag Object.
  ## Note that creating a tag object does not create the reference that makes a
  ## tag in Git. If you want to create an annotated tag in Git, you have to do
  ## this call to create the tag object, and then create the refs/tags/[tag]
  ## reference. If you want to create a lightweight tag, you only have to create
  ## the tag reference - this call would be unnecessary.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779111 = path.getOrDefault("repo")
  valid_779111 = validateParameter(valid_779111, JString, required = true,
                                 default = nil)
  if valid_779111 != nil:
    section.add "repo", valid_779111
  var valid_779112 = path.getOrDefault("owner")
  valid_779112 = validateParameter(valid_779112, JString, required = true,
                                 default = nil)
  if valid_779112 != nil:
    section.add "owner", valid_779112
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779113 = header.getOrDefault("Accept")
  valid_779113 = validateParameter(valid_779113, JString, required = false,
                                 default = nil)
  if valid_779113 != nil:
    section.add "Accept", valid_779113
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_779115: Call_PostReposOwnerRepoGitTags_779108; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a Tag Object.
  ## Note that creating a tag object does not create the reference that makes a
  ## tag in Git. If you want to create an annotated tag in Git, you have to do
  ## this call to create the tag object, and then create the refs/tags/[tag]
  ## reference. If you want to create a lightweight tag, you only have to create
  ## the tag reference - this call would be unnecessary.
  ## 
  ## 
  let valid = call_779115.validator(path, query, header, formData, body)
  let scheme = call_779115.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779115.url(scheme.get, call_779115.host, call_779115.base,
                         call_779115.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779115, url, valid)

proc call*(call_779116: Call_PostReposOwnerRepoGitTags_779108; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitTags
  ## Create a Tag Object.
  ## Note that creating a tag object does not create the reference that makes a
  ## tag in Git. If you want to create an annotated tag in Git, you have to do
  ## this call to create the tag object, and then create the refs/tags/[tag]
  ## reference. If you want to create a lightweight tag, you only have to create
  ## the tag reference - this call would be unnecessary.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779117 = newJObject()
  var header_779118 = newJObject()
  var body_779119 = newJObject()
  add(path_779117, "repo", newJString(repo))
  add(path_779117, "owner", newJString(owner))
  if body != nil:
    body_779119 = body
  add(header_779118, "Accept", newJString(Accept))
  result = call_779116.call(path_779117, nil, header_779118, nil, body_779119)

var postReposOwnerRepoGitTags* = Call_PostReposOwnerRepoGitTags_779108(
    name: "postReposOwnerRepoGitTags", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/tags",
    validator: validate_PostReposOwnerRepoGitTags_779109, base: "/",
    url: url_PostReposOwnerRepoGitTags_779110, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitTagsShaCode_779120 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoGitTagsShaCode_779122(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/tags/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitTagsShaCode_779121(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a Tag.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   shaCode: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779123 = path.getOrDefault("repo")
  valid_779123 = validateParameter(valid_779123, JString, required = true,
                                 default = nil)
  if valid_779123 != nil:
    section.add "repo", valid_779123
  var valid_779124 = path.getOrDefault("owner")
  valid_779124 = validateParameter(valid_779124, JString, required = true,
                                 default = nil)
  if valid_779124 != nil:
    section.add "owner", valid_779124
  var valid_779125 = path.getOrDefault("shaCode")
  valid_779125 = validateParameter(valid_779125, JString, required = true,
                                 default = nil)
  if valid_779125 != nil:
    section.add "shaCode", valid_779125
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779126 = header.getOrDefault("Accept")
  valid_779126 = validateParameter(valid_779126, JString, required = false,
                                 default = nil)
  if valid_779126 != nil:
    section.add "Accept", valid_779126
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779127: Call_GetReposOwnerRepoGitTagsShaCode_779120;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a Tag.
  ## 
  let valid = call_779127.validator(path, query, header, formData, body)
  let scheme = call_779127.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779127.url(scheme.get, call_779127.host, call_779127.base,
                         call_779127.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779127, url, valid)

proc call*(call_779128: Call_GetReposOwnerRepoGitTagsShaCode_779120; repo: string;
          owner: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitTagsShaCode
  ## Get a Tag.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   shaCode: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779129 = newJObject()
  var header_779130 = newJObject()
  add(path_779129, "repo", newJString(repo))
  add(path_779129, "owner", newJString(owner))
  add(path_779129, "shaCode", newJString(shaCode))
  add(header_779130, "Accept", newJString(Accept))
  result = call_779128.call(path_779129, nil, header_779130, nil, nil)

var getReposOwnerRepoGitTagsShaCode* = Call_GetReposOwnerRepoGitTagsShaCode_779120(
    name: "getReposOwnerRepoGitTagsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/tags/{shaCode}",
    validator: validate_GetReposOwnerRepoGitTagsShaCode_779121, base: "/",
    url: url_GetReposOwnerRepoGitTagsShaCode_779122, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitTrees_779131 = ref object of OpenApiRestCall_777573
proc url_PostReposOwnerRepoGitTrees_779133(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/trees")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitTrees_779132(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a Tree.
  ## The tree creation API will take nested entries as well. If both a tree and
  ## a nested path modifying that tree are specified, it will overwrite the
  ## contents of that tree with the new path contents and write a new tree out.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779134 = path.getOrDefault("repo")
  valid_779134 = validateParameter(valid_779134, JString, required = true,
                                 default = nil)
  if valid_779134 != nil:
    section.add "repo", valid_779134
  var valid_779135 = path.getOrDefault("owner")
  valid_779135 = validateParameter(valid_779135, JString, required = true,
                                 default = nil)
  if valid_779135 != nil:
    section.add "owner", valid_779135
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779136 = header.getOrDefault("Accept")
  valid_779136 = validateParameter(valid_779136, JString, required = false,
                                 default = nil)
  if valid_779136 != nil:
    section.add "Accept", valid_779136
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_779138: Call_PostReposOwnerRepoGitTrees_779131; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a Tree.
  ## The tree creation API will take nested entries as well. If both a tree and
  ## a nested path modifying that tree are specified, it will overwrite the
  ## contents of that tree with the new path contents and write a new tree out.
  ## 
  ## 
  let valid = call_779138.validator(path, query, header, formData, body)
  let scheme = call_779138.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779138.url(scheme.get, call_779138.host, call_779138.base,
                         call_779138.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779138, url, valid)

proc call*(call_779139: Call_PostReposOwnerRepoGitTrees_779131; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitTrees
  ## Create a Tree.
  ## The tree creation API will take nested entries as well. If both a tree and
  ## a nested path modifying that tree are specified, it will overwrite the
  ## contents of that tree with the new path contents and write a new tree out.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779140 = newJObject()
  var header_779141 = newJObject()
  var body_779142 = newJObject()
  add(path_779140, "repo", newJString(repo))
  add(path_779140, "owner", newJString(owner))
  if body != nil:
    body_779142 = body
  add(header_779141, "Accept", newJString(Accept))
  result = call_779139.call(path_779140, nil, header_779141, nil, body_779142)

var postReposOwnerRepoGitTrees* = Call_PostReposOwnerRepoGitTrees_779131(
    name: "postReposOwnerRepoGitTrees", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/trees",
    validator: validate_PostReposOwnerRepoGitTrees_779132, base: "/",
    url: url_PostReposOwnerRepoGitTrees_779133, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitTreesShaCode_779143 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoGitTreesShaCode_779145(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/trees/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitTreesShaCode_779144(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a Tree.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   shaCode: JString (required)
  ##          : Tree SHA.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779146 = path.getOrDefault("repo")
  valid_779146 = validateParameter(valid_779146, JString, required = true,
                                 default = nil)
  if valid_779146 != nil:
    section.add "repo", valid_779146
  var valid_779147 = path.getOrDefault("owner")
  valid_779147 = validateParameter(valid_779147, JString, required = true,
                                 default = nil)
  if valid_779147 != nil:
    section.add "owner", valid_779147
  var valid_779148 = path.getOrDefault("shaCode")
  valid_779148 = validateParameter(valid_779148, JString, required = true,
                                 default = nil)
  if valid_779148 != nil:
    section.add "shaCode", valid_779148
  result.add "path", section
  ## parameters in `query` object:
  ##   recursive: JInt
  ##            : Get a Tree Recursively. (0 or 1)
  section = newJObject()
  var valid_779149 = query.getOrDefault("recursive")
  valid_779149 = validateParameter(valid_779149, JInt, required = false, default = nil)
  if valid_779149 != nil:
    section.add "recursive", valid_779149
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779150 = header.getOrDefault("Accept")
  valid_779150 = validateParameter(valid_779150, JString, required = false,
                                 default = nil)
  if valid_779150 != nil:
    section.add "Accept", valid_779150
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779151: Call_GetReposOwnerRepoGitTreesShaCode_779143;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a Tree.
  ## 
  let valid = call_779151.validator(path, query, header, formData, body)
  let scheme = call_779151.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779151.url(scheme.get, call_779151.host, call_779151.base,
                         call_779151.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779151, url, valid)

proc call*(call_779152: Call_GetReposOwnerRepoGitTreesShaCode_779143; repo: string;
          owner: string; shaCode: string; recursive: int = 0; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitTreesShaCode
  ## Get a Tree.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   recursive: int
  ##            : Get a Tree Recursively. (0 or 1)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   shaCode: string (required)
  ##          : Tree SHA.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779153 = newJObject()
  var query_779154 = newJObject()
  var header_779155 = newJObject()
  add(path_779153, "repo", newJString(repo))
  add(query_779154, "recursive", newJInt(recursive))
  add(path_779153, "owner", newJString(owner))
  add(path_779153, "shaCode", newJString(shaCode))
  add(header_779155, "Accept", newJString(Accept))
  result = call_779152.call(path_779153, query_779154, header_779155, nil, nil)

var getReposOwnerRepoGitTreesShaCode* = Call_GetReposOwnerRepoGitTreesShaCode_779143(
    name: "getReposOwnerRepoGitTreesShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/trees/{shaCode}",
    validator: validate_GetReposOwnerRepoGitTreesShaCode_779144, base: "/",
    url: url_GetReposOwnerRepoGitTreesShaCode_779145, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoHooks_779166 = ref object of OpenApiRestCall_777573
proc url_PostReposOwnerRepoHooks_779168(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoHooks_779167(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779169 = path.getOrDefault("repo")
  valid_779169 = validateParameter(valid_779169, JString, required = true,
                                 default = nil)
  if valid_779169 != nil:
    section.add "repo", valid_779169
  var valid_779170 = path.getOrDefault("owner")
  valid_779170 = validateParameter(valid_779170, JString, required = true,
                                 default = nil)
  if valid_779170 != nil:
    section.add "owner", valid_779170
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779171 = header.getOrDefault("Accept")
  valid_779171 = validateParameter(valid_779171, JString, required = false,
                                 default = nil)
  if valid_779171 != nil:
    section.add "Accept", valid_779171
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_779173: Call_PostReposOwnerRepoHooks_779166; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a hook.
  ## 
  let valid = call_779173.validator(path, query, header, formData, body)
  let scheme = call_779173.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779173.url(scheme.get, call_779173.host, call_779173.base,
                         call_779173.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779173, url, valid)

proc call*(call_779174: Call_PostReposOwnerRepoHooks_779166; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoHooks
  ## Create a hook.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779175 = newJObject()
  var header_779176 = newJObject()
  var body_779177 = newJObject()
  add(path_779175, "repo", newJString(repo))
  add(path_779175, "owner", newJString(owner))
  if body != nil:
    body_779177 = body
  add(header_779176, "Accept", newJString(Accept))
  result = call_779174.call(path_779175, nil, header_779176, nil, body_779177)

var postReposOwnerRepoHooks* = Call_PostReposOwnerRepoHooks_779166(
    name: "postReposOwnerRepoHooks", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks",
    validator: validate_PostReposOwnerRepoHooks_779167, base: "/",
    url: url_PostReposOwnerRepoHooks_779168, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoHooks_779156 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoHooks_779158(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoHooks_779157(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get list of hooks.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779159 = path.getOrDefault("repo")
  valid_779159 = validateParameter(valid_779159, JString, required = true,
                                 default = nil)
  if valid_779159 != nil:
    section.add "repo", valid_779159
  var valid_779160 = path.getOrDefault("owner")
  valid_779160 = validateParameter(valid_779160, JString, required = true,
                                 default = nil)
  if valid_779160 != nil:
    section.add "owner", valid_779160
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779161 = header.getOrDefault("Accept")
  valid_779161 = validateParameter(valid_779161, JString, required = false,
                                 default = nil)
  if valid_779161 != nil:
    section.add "Accept", valid_779161
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779162: Call_GetReposOwnerRepoHooks_779156; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get list of hooks.
  ## 
  let valid = call_779162.validator(path, query, header, formData, body)
  let scheme = call_779162.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779162.url(scheme.get, call_779162.host, call_779162.base,
                         call_779162.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779162, url, valid)

proc call*(call_779163: Call_GetReposOwnerRepoHooks_779156; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoHooks
  ## Get list of hooks.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779164 = newJObject()
  var header_779165 = newJObject()
  add(path_779164, "repo", newJString(repo))
  add(path_779164, "owner", newJString(owner))
  add(header_779165, "Accept", newJString(Accept))
  result = call_779163.call(path_779164, nil, header_779165, nil, nil)

var getReposOwnerRepoHooks* = Call_GetReposOwnerRepoHooks_779156(
    name: "getReposOwnerRepoHooks", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks",
    validator: validate_GetReposOwnerRepoHooks_779157, base: "/",
    url: url_GetReposOwnerRepoHooks_779158, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoHooksHookId_779178 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoHooksHookId_779180(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hookId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoHooksHookId_779179(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get single hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   hookId: JInt (required)
  ##         : Id of hook.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779181 = path.getOrDefault("repo")
  valid_779181 = validateParameter(valid_779181, JString, required = true,
                                 default = nil)
  if valid_779181 != nil:
    section.add "repo", valid_779181
  var valid_779182 = path.getOrDefault("owner")
  valid_779182 = validateParameter(valid_779182, JString, required = true,
                                 default = nil)
  if valid_779182 != nil:
    section.add "owner", valid_779182
  var valid_779183 = path.getOrDefault("hookId")
  valid_779183 = validateParameter(valid_779183, JInt, required = true, default = nil)
  if valid_779183 != nil:
    section.add "hookId", valid_779183
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779184 = header.getOrDefault("Accept")
  valid_779184 = validateParameter(valid_779184, JString, required = false,
                                 default = nil)
  if valid_779184 != nil:
    section.add "Accept", valid_779184
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779185: Call_GetReposOwnerRepoHooksHookId_779178; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get single hook.
  ## 
  let valid = call_779185.validator(path, query, header, formData, body)
  let scheme = call_779185.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779185.url(scheme.get, call_779185.host, call_779185.base,
                         call_779185.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779185, url, valid)

proc call*(call_779186: Call_GetReposOwnerRepoHooksHookId_779178; repo: string;
          owner: string; hookId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoHooksHookId
  ## Get single hook.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   hookId: int (required)
  ##         : Id of hook.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779187 = newJObject()
  var header_779188 = newJObject()
  add(path_779187, "repo", newJString(repo))
  add(path_779187, "owner", newJString(owner))
  add(path_779187, "hookId", newJInt(hookId))
  add(header_779188, "Accept", newJString(Accept))
  result = call_779186.call(path_779187, nil, header_779188, nil, nil)

var getReposOwnerRepoHooksHookId* = Call_GetReposOwnerRepoHooksHookId_779178(
    name: "getReposOwnerRepoHooksHookId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}",
    validator: validate_GetReposOwnerRepoHooksHookId_779179, base: "/",
    url: url_GetReposOwnerRepoHooksHookId_779180, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoHooksHookId_779200 = ref object of OpenApiRestCall_777573
proc url_PatchReposOwnerRepoHooksHookId_779202(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hookId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoHooksHookId_779201(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Edit a hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   hookId: JInt (required)
  ##         : Id of hook.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779203 = path.getOrDefault("repo")
  valid_779203 = validateParameter(valid_779203, JString, required = true,
                                 default = nil)
  if valid_779203 != nil:
    section.add "repo", valid_779203
  var valid_779204 = path.getOrDefault("owner")
  valid_779204 = validateParameter(valid_779204, JString, required = true,
                                 default = nil)
  if valid_779204 != nil:
    section.add "owner", valid_779204
  var valid_779205 = path.getOrDefault("hookId")
  valid_779205 = validateParameter(valid_779205, JInt, required = true, default = nil)
  if valid_779205 != nil:
    section.add "hookId", valid_779205
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779206 = header.getOrDefault("Accept")
  valid_779206 = validateParameter(valid_779206, JString, required = false,
                                 default = nil)
  if valid_779206 != nil:
    section.add "Accept", valid_779206
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_779208: Call_PatchReposOwnerRepoHooksHookId_779200; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Edit a hook.
  ## 
  let valid = call_779208.validator(path, query, header, formData, body)
  let scheme = call_779208.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779208.url(scheme.get, call_779208.host, call_779208.base,
                         call_779208.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779208, url, valid)

proc call*(call_779209: Call_PatchReposOwnerRepoHooksHookId_779200; repo: string;
          owner: string; body: JsonNode; hookId: int; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoHooksHookId
  ## Edit a hook.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   hookId: int (required)
  ##         : Id of hook.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779210 = newJObject()
  var header_779211 = newJObject()
  var body_779212 = newJObject()
  add(path_779210, "repo", newJString(repo))
  add(path_779210, "owner", newJString(owner))
  if body != nil:
    body_779212 = body
  add(path_779210, "hookId", newJInt(hookId))
  add(header_779211, "Accept", newJString(Accept))
  result = call_779209.call(path_779210, nil, header_779211, nil, body_779212)

var patchReposOwnerRepoHooksHookId* = Call_PatchReposOwnerRepoHooksHookId_779200(
    name: "patchReposOwnerRepoHooksHookId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}",
    validator: validate_PatchReposOwnerRepoHooksHookId_779201, base: "/",
    url: url_PatchReposOwnerRepoHooksHookId_779202, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoHooksHookId_779189 = ref object of OpenApiRestCall_777573
proc url_DeleteReposOwnerRepoHooksHookId_779191(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hookId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoHooksHookId_779190(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   hookId: JInt (required)
  ##         : Id of hook.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779192 = path.getOrDefault("repo")
  valid_779192 = validateParameter(valid_779192, JString, required = true,
                                 default = nil)
  if valid_779192 != nil:
    section.add "repo", valid_779192
  var valid_779193 = path.getOrDefault("owner")
  valid_779193 = validateParameter(valid_779193, JString, required = true,
                                 default = nil)
  if valid_779193 != nil:
    section.add "owner", valid_779193
  var valid_779194 = path.getOrDefault("hookId")
  valid_779194 = validateParameter(valid_779194, JInt, required = true, default = nil)
  if valid_779194 != nil:
    section.add "hookId", valid_779194
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779195 = header.getOrDefault("Accept")
  valid_779195 = validateParameter(valid_779195, JString, required = false,
                                 default = nil)
  if valid_779195 != nil:
    section.add "Accept", valid_779195
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779196: Call_DeleteReposOwnerRepoHooksHookId_779189;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a hook.
  ## 
  let valid = call_779196.validator(path, query, header, formData, body)
  let scheme = call_779196.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779196.url(scheme.get, call_779196.host, call_779196.base,
                         call_779196.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779196, url, valid)

proc call*(call_779197: Call_DeleteReposOwnerRepoHooksHookId_779189; repo: string;
          owner: string; hookId: int; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoHooksHookId
  ## Delete a hook.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   hookId: int (required)
  ##         : Id of hook.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779198 = newJObject()
  var header_779199 = newJObject()
  add(path_779198, "repo", newJString(repo))
  add(path_779198, "owner", newJString(owner))
  add(path_779198, "hookId", newJInt(hookId))
  add(header_779199, "Accept", newJString(Accept))
  result = call_779197.call(path_779198, nil, header_779199, nil, nil)

var deleteReposOwnerRepoHooksHookId* = Call_DeleteReposOwnerRepoHooksHookId_779189(
    name: "deleteReposOwnerRepoHooksHookId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}",
    validator: validate_DeleteReposOwnerRepoHooksHookId_779190, base: "/",
    url: url_DeleteReposOwnerRepoHooksHookId_779191, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoHooksHookIdTests_779213 = ref object of OpenApiRestCall_777573
proc url_PostReposOwnerRepoHooksHookIdTests_779215(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hookId"),
               (kind: ConstantSegment, value: "/tests")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoHooksHookIdTests_779214(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Test a push hook.
  ## This will trigger the hook with the latest push to the current repository
  ## if the hook is subscribed to push events. If the hook is not subscribed
  ## to push events, the server will respond with 204 but no test POST will
  ## be generated.
  ## Note: Previously /repos/:owner/:repo/hooks/:id/tes
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   hookId: JInt (required)
  ##         : Id of hook.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779216 = path.getOrDefault("repo")
  valid_779216 = validateParameter(valid_779216, JString, required = true,
                                 default = nil)
  if valid_779216 != nil:
    section.add "repo", valid_779216
  var valid_779217 = path.getOrDefault("owner")
  valid_779217 = validateParameter(valid_779217, JString, required = true,
                                 default = nil)
  if valid_779217 != nil:
    section.add "owner", valid_779217
  var valid_779218 = path.getOrDefault("hookId")
  valid_779218 = validateParameter(valid_779218, JInt, required = true, default = nil)
  if valid_779218 != nil:
    section.add "hookId", valid_779218
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779219 = header.getOrDefault("Accept")
  valid_779219 = validateParameter(valid_779219, JString, required = false,
                                 default = nil)
  if valid_779219 != nil:
    section.add "Accept", valid_779219
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779220: Call_PostReposOwnerRepoHooksHookIdTests_779213;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Test a push hook.
  ## This will trigger the hook with the latest push to the current repository
  ## if the hook is subscribed to push events. If the hook is not subscribed
  ## to push events, the server will respond with 204 but no test POST will
  ## be generated.
  ## Note: Previously /repos/:owner/:repo/hooks/:id/tes
  ## 
  ## 
  let valid = call_779220.validator(path, query, header, formData, body)
  let scheme = call_779220.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779220.url(scheme.get, call_779220.host, call_779220.base,
                         call_779220.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779220, url, valid)

proc call*(call_779221: Call_PostReposOwnerRepoHooksHookIdTests_779213;
          repo: string; owner: string; hookId: int; Accept: string = ""): Recallable =
  ## postReposOwnerRepoHooksHookIdTests
  ## Test a push hook.
  ## This will trigger the hook with the latest push to the current repository
  ## if the hook is subscribed to push events. If the hook is not subscribed
  ## to push events, the server will respond with 204 but no test POST will
  ## be generated.
  ## Note: Previously /repos/:owner/:repo/hooks/:id/tes
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   hookId: int (required)
  ##         : Id of hook.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779222 = newJObject()
  var header_779223 = newJObject()
  add(path_779222, "repo", newJString(repo))
  add(path_779222, "owner", newJString(owner))
  add(path_779222, "hookId", newJInt(hookId))
  add(header_779223, "Accept", newJString(Accept))
  result = call_779221.call(path_779222, nil, header_779223, nil, nil)

var postReposOwnerRepoHooksHookIdTests* = Call_PostReposOwnerRepoHooksHookIdTests_779213(
    name: "postReposOwnerRepoHooksHookIdTests", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}/tests",
    validator: validate_PostReposOwnerRepoHooksHookIdTests_779214, base: "/",
    url: url_PostReposOwnerRepoHooksHookIdTests_779215, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoIssues_779241 = ref object of OpenApiRestCall_777573
proc url_PostReposOwnerRepoIssues_779243(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoIssues_779242(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create an issue.
  ## Any user with pull access to a repository can create an issue.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779244 = path.getOrDefault("repo")
  valid_779244 = validateParameter(valid_779244, JString, required = true,
                                 default = nil)
  if valid_779244 != nil:
    section.add "repo", valid_779244
  var valid_779245 = path.getOrDefault("owner")
  valid_779245 = validateParameter(valid_779245, JString, required = true,
                                 default = nil)
  if valid_779245 != nil:
    section.add "owner", valid_779245
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779246 = header.getOrDefault("Accept")
  valid_779246 = validateParameter(valid_779246, JString, required = false,
                                 default = nil)
  if valid_779246 != nil:
    section.add "Accept", valid_779246
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_779248: Call_PostReposOwnerRepoIssues_779241; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create an issue.
  ## Any user with pull access to a repository can create an issue.
  ## 
  ## 
  let valid = call_779248.validator(path, query, header, formData, body)
  let scheme = call_779248.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779248.url(scheme.get, call_779248.host, call_779248.base,
                         call_779248.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779248, url, valid)

proc call*(call_779249: Call_PostReposOwnerRepoIssues_779241; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoIssues
  ## Create an issue.
  ## Any user with pull access to a repository can create an issue.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779250 = newJObject()
  var header_779251 = newJObject()
  var body_779252 = newJObject()
  add(path_779250, "repo", newJString(repo))
  add(path_779250, "owner", newJString(owner))
  if body != nil:
    body_779252 = body
  add(header_779251, "Accept", newJString(Accept))
  result = call_779249.call(path_779250, nil, header_779251, nil, body_779252)

var postReposOwnerRepoIssues* = Call_PostReposOwnerRepoIssues_779241(
    name: "postReposOwnerRepoIssues", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues",
    validator: validate_PostReposOwnerRepoIssues_779242, base: "/",
    url: url_PostReposOwnerRepoIssues_779243, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssues_779224 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoIssues_779226(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssues_779225(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List issues for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779227 = path.getOrDefault("repo")
  valid_779227 = validateParameter(valid_779227, JString, required = true,
                                 default = nil)
  if valid_779227 != nil:
    section.add "repo", valid_779227
  var valid_779228 = path.getOrDefault("owner")
  valid_779228 = validateParameter(valid_779228, JString, required = true,
                                 default = nil)
  if valid_779228 != nil:
    section.add "owner", valid_779228
  result.add "path", section
  ## parameters in `query` object:
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   direction: JString (required)
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  ##   state: JString (required)
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   sort: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `labels` field"
  var valid_779229 = query.getOrDefault("labels")
  valid_779229 = validateParameter(valid_779229, JString, required = true,
                                 default = nil)
  if valid_779229 != nil:
    section.add "labels", valid_779229
  var valid_779230 = query.getOrDefault("direction")
  valid_779230 = validateParameter(valid_779230, JString, required = true,
                                 default = newJString("desc"))
  if valid_779230 != nil:
    section.add "direction", valid_779230
  var valid_779231 = query.getOrDefault("since")
  valid_779231 = validateParameter(valid_779231, JString, required = false,
                                 default = nil)
  if valid_779231 != nil:
    section.add "since", valid_779231
  var valid_779232 = query.getOrDefault("state")
  valid_779232 = validateParameter(valid_779232, JString, required = true,
                                 default = newJString("open"))
  if valid_779232 != nil:
    section.add "state", valid_779232
  var valid_779233 = query.getOrDefault("filter")
  valid_779233 = validateParameter(valid_779233, JString, required = true,
                                 default = newJString("all"))
  if valid_779233 != nil:
    section.add "filter", valid_779233
  var valid_779234 = query.getOrDefault("sort")
  valid_779234 = validateParameter(valid_779234, JString, required = true,
                                 default = newJString("created"))
  if valid_779234 != nil:
    section.add "sort", valid_779234
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779235 = header.getOrDefault("Accept")
  valid_779235 = validateParameter(valid_779235, JString, required = false,
                                 default = nil)
  if valid_779235 != nil:
    section.add "Accept", valid_779235
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779236: Call_GetReposOwnerRepoIssues_779224; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List issues for a repository.
  ## 
  let valid = call_779236.validator(path, query, header, formData, body)
  let scheme = call_779236.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779236.url(scheme.get, call_779236.host, call_779236.base,
                         call_779236.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779236, url, valid)

proc call*(call_779237: Call_GetReposOwnerRepoIssues_779224; labels: string;
          repo: string; owner: string; direction: string = "desc"; since: string = "";
          state: string = "open"; filter: string = "all"; Accept: string = "";
          sort: string = "created"): Recallable =
  ## getReposOwnerRepoIssues
  ## List issues for a repository.
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   direction: string (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  ##   state: string (required)
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string (required)
  var path_779238 = newJObject()
  var query_779239 = newJObject()
  var header_779240 = newJObject()
  add(query_779239, "labels", newJString(labels))
  add(query_779239, "direction", newJString(direction))
  add(path_779238, "repo", newJString(repo))
  add(query_779239, "since", newJString(since))
  add(query_779239, "state", newJString(state))
  add(query_779239, "filter", newJString(filter))
  add(path_779238, "owner", newJString(owner))
  add(header_779240, "Accept", newJString(Accept))
  add(query_779239, "sort", newJString(sort))
  result = call_779237.call(path_779238, query_779239, header_779240, nil, nil)

var getReposOwnerRepoIssues* = Call_GetReposOwnerRepoIssues_779224(
    name: "getReposOwnerRepoIssues", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues",
    validator: validate_GetReposOwnerRepoIssues_779225, base: "/",
    url: url_GetReposOwnerRepoIssues_779226, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesComments_779253 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoIssuesComments_779255(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesComments_779254(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List comments in a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779256 = path.getOrDefault("repo")
  valid_779256 = validateParameter(valid_779256, JString, required = true,
                                 default = nil)
  if valid_779256 != nil:
    section.add "repo", valid_779256
  var valid_779257 = path.getOrDefault("owner")
  valid_779257 = validateParameter(valid_779257, JString, required = true,
                                 default = nil)
  if valid_779257 != nil:
    section.add "owner", valid_779257
  result.add "path", section
  ## parameters in `query` object:
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   sort: JString
  section = newJObject()
  var valid_779258 = query.getOrDefault("direction")
  valid_779258 = validateParameter(valid_779258, JString, required = false,
                                 default = nil)
  if valid_779258 != nil:
    section.add "direction", valid_779258
  var valid_779259 = query.getOrDefault("since")
  valid_779259 = validateParameter(valid_779259, JString, required = false,
                                 default = nil)
  if valid_779259 != nil:
    section.add "since", valid_779259
  var valid_779260 = query.getOrDefault("sort")
  valid_779260 = validateParameter(valid_779260, JString, required = false,
                                 default = newJString("created"))
  if valid_779260 != nil:
    section.add "sort", valid_779260
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779261 = header.getOrDefault("Accept")
  valid_779261 = validateParameter(valid_779261, JString, required = false,
                                 default = nil)
  if valid_779261 != nil:
    section.add "Accept", valid_779261
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779262: Call_GetReposOwnerRepoIssuesComments_779253;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List comments in a repository.
  ## 
  let valid = call_779262.validator(path, query, header, formData, body)
  let scheme = call_779262.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779262.url(scheme.get, call_779262.host, call_779262.base,
                         call_779262.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779262, url, valid)

proc call*(call_779263: Call_GetReposOwnerRepoIssuesComments_779253; repo: string;
          owner: string; direction: string = ""; since: string = ""; Accept: string = "";
          sort: string = "created"): Recallable =
  ## getReposOwnerRepoIssuesComments
  ## List comments in a repository.
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  var path_779264 = newJObject()
  var query_779265 = newJObject()
  var header_779266 = newJObject()
  add(query_779265, "direction", newJString(direction))
  add(path_779264, "repo", newJString(repo))
  add(query_779265, "since", newJString(since))
  add(path_779264, "owner", newJString(owner))
  add(header_779266, "Accept", newJString(Accept))
  add(query_779265, "sort", newJString(sort))
  result = call_779263.call(path_779264, query_779265, header_779266, nil, nil)

var getReposOwnerRepoIssuesComments* = Call_GetReposOwnerRepoIssuesComments_779253(
    name: "getReposOwnerRepoIssuesComments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/comments",
    validator: validate_GetReposOwnerRepoIssuesComments_779254, base: "/",
    url: url_GetReposOwnerRepoIssuesComments_779255, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesCommentsCommentId_779267 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoIssuesCommentsCommentId_779269(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesCommentsCommentId_779268(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : ID of comment.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779270 = path.getOrDefault("repo")
  valid_779270 = validateParameter(valid_779270, JString, required = true,
                                 default = nil)
  if valid_779270 != nil:
    section.add "repo", valid_779270
  var valid_779271 = path.getOrDefault("commentId")
  valid_779271 = validateParameter(valid_779271, JInt, required = true, default = nil)
  if valid_779271 != nil:
    section.add "commentId", valid_779271
  var valid_779272 = path.getOrDefault("owner")
  valid_779272 = validateParameter(valid_779272, JString, required = true,
                                 default = nil)
  if valid_779272 != nil:
    section.add "owner", valid_779272
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779273 = header.getOrDefault("Accept")
  valid_779273 = validateParameter(valid_779273, JString, required = false,
                                 default = nil)
  if valid_779273 != nil:
    section.add "Accept", valid_779273
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779274: Call_GetReposOwnerRepoIssuesCommentsCommentId_779267;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single comment.
  ## 
  let valid = call_779274.validator(path, query, header, formData, body)
  let scheme = call_779274.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779274.url(scheme.get, call_779274.host, call_779274.base,
                         call_779274.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779274, url, valid)

proc call*(call_779275: Call_GetReposOwnerRepoIssuesCommentsCommentId_779267;
          repo: string; commentId: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesCommentsCommentId
  ## Get a single comment.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : ID of comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779276 = newJObject()
  var header_779277 = newJObject()
  add(path_779276, "repo", newJString(repo))
  add(path_779276, "commentId", newJInt(commentId))
  add(path_779276, "owner", newJString(owner))
  add(header_779277, "Accept", newJString(Accept))
  result = call_779275.call(path_779276, nil, header_779277, nil, nil)

var getReposOwnerRepoIssuesCommentsCommentId* = Call_GetReposOwnerRepoIssuesCommentsCommentId_779267(
    name: "getReposOwnerRepoIssuesCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/comments/{commentId}",
    validator: validate_GetReposOwnerRepoIssuesCommentsCommentId_779268,
    base: "/", url: url_GetReposOwnerRepoIssuesCommentsCommentId_779269,
    schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoIssuesCommentsCommentId_779289 = ref object of OpenApiRestCall_777573
proc url_PatchReposOwnerRepoIssuesCommentsCommentId_779291(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoIssuesCommentsCommentId_779290(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Edit a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : ID of comment.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779292 = path.getOrDefault("repo")
  valid_779292 = validateParameter(valid_779292, JString, required = true,
                                 default = nil)
  if valid_779292 != nil:
    section.add "repo", valid_779292
  var valid_779293 = path.getOrDefault("commentId")
  valid_779293 = validateParameter(valid_779293, JInt, required = true, default = nil)
  if valid_779293 != nil:
    section.add "commentId", valid_779293
  var valid_779294 = path.getOrDefault("owner")
  valid_779294 = validateParameter(valid_779294, JString, required = true,
                                 default = nil)
  if valid_779294 != nil:
    section.add "owner", valid_779294
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779295 = header.getOrDefault("Accept")
  valid_779295 = validateParameter(valid_779295, JString, required = false,
                                 default = nil)
  if valid_779295 != nil:
    section.add "Accept", valid_779295
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_779297: Call_PatchReposOwnerRepoIssuesCommentsCommentId_779289;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Edit a comment.
  ## 
  let valid = call_779297.validator(path, query, header, formData, body)
  let scheme = call_779297.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779297.url(scheme.get, call_779297.host, call_779297.base,
                         call_779297.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779297, url, valid)

proc call*(call_779298: Call_PatchReposOwnerRepoIssuesCommentsCommentId_779289;
          repo: string; commentId: int; owner: string; body: JsonNode;
          Accept: string = ""): Recallable =
  ## patchReposOwnerRepoIssuesCommentsCommentId
  ## Edit a comment.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : ID of comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779299 = newJObject()
  var header_779300 = newJObject()
  var body_779301 = newJObject()
  add(path_779299, "repo", newJString(repo))
  add(path_779299, "commentId", newJInt(commentId))
  add(path_779299, "owner", newJString(owner))
  if body != nil:
    body_779301 = body
  add(header_779300, "Accept", newJString(Accept))
  result = call_779298.call(path_779299, nil, header_779300, nil, body_779301)

var patchReposOwnerRepoIssuesCommentsCommentId* = Call_PatchReposOwnerRepoIssuesCommentsCommentId_779289(
    name: "patchReposOwnerRepoIssuesCommentsCommentId",
    meth: HttpMethod.HttpPatch, host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/comments/{commentId}",
    validator: validate_PatchReposOwnerRepoIssuesCommentsCommentId_779290,
    base: "/", url: url_PatchReposOwnerRepoIssuesCommentsCommentId_779291,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoIssuesCommentsCommentId_779278 = ref object of OpenApiRestCall_777573
proc url_DeleteReposOwnerRepoIssuesCommentsCommentId_779280(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoIssuesCommentsCommentId_779279(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : ID of comment.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779281 = path.getOrDefault("repo")
  valid_779281 = validateParameter(valid_779281, JString, required = true,
                                 default = nil)
  if valid_779281 != nil:
    section.add "repo", valid_779281
  var valid_779282 = path.getOrDefault("commentId")
  valid_779282 = validateParameter(valid_779282, JInt, required = true, default = nil)
  if valid_779282 != nil:
    section.add "commentId", valid_779282
  var valid_779283 = path.getOrDefault("owner")
  valid_779283 = validateParameter(valid_779283, JString, required = true,
                                 default = nil)
  if valid_779283 != nil:
    section.add "owner", valid_779283
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779284 = header.getOrDefault("Accept")
  valid_779284 = validateParameter(valid_779284, JString, required = false,
                                 default = nil)
  if valid_779284 != nil:
    section.add "Accept", valid_779284
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779285: Call_DeleteReposOwnerRepoIssuesCommentsCommentId_779278;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a comment.
  ## 
  let valid = call_779285.validator(path, query, header, formData, body)
  let scheme = call_779285.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779285.url(scheme.get, call_779285.host, call_779285.base,
                         call_779285.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779285, url, valid)

proc call*(call_779286: Call_DeleteReposOwnerRepoIssuesCommentsCommentId_779278;
          repo: string; commentId: int; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoIssuesCommentsCommentId
  ## Delete a comment.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : ID of comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779287 = newJObject()
  var header_779288 = newJObject()
  add(path_779287, "repo", newJString(repo))
  add(path_779287, "commentId", newJInt(commentId))
  add(path_779287, "owner", newJString(owner))
  add(header_779288, "Accept", newJString(Accept))
  result = call_779286.call(path_779287, nil, header_779288, nil, nil)

var deleteReposOwnerRepoIssuesCommentsCommentId* = Call_DeleteReposOwnerRepoIssuesCommentsCommentId_779278(
    name: "deleteReposOwnerRepoIssuesCommentsCommentId",
    meth: HttpMethod.HttpDelete, host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/comments/{commentId}",
    validator: validate_DeleteReposOwnerRepoIssuesCommentsCommentId_779279,
    base: "/", url: url_DeleteReposOwnerRepoIssuesCommentsCommentId_779280,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesEvents_779302 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoIssuesEvents_779304(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesEvents_779303(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List issue events for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779305 = path.getOrDefault("repo")
  valid_779305 = validateParameter(valid_779305, JString, required = true,
                                 default = nil)
  if valid_779305 != nil:
    section.add "repo", valid_779305
  var valid_779306 = path.getOrDefault("owner")
  valid_779306 = validateParameter(valid_779306, JString, required = true,
                                 default = nil)
  if valid_779306 != nil:
    section.add "owner", valid_779306
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779307 = header.getOrDefault("Accept")
  valid_779307 = validateParameter(valid_779307, JString, required = false,
                                 default = nil)
  if valid_779307 != nil:
    section.add "Accept", valid_779307
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779308: Call_GetReposOwnerRepoIssuesEvents_779302; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List issue events for a repository.
  ## 
  let valid = call_779308.validator(path, query, header, formData, body)
  let scheme = call_779308.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779308.url(scheme.get, call_779308.host, call_779308.base,
                         call_779308.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779308, url, valid)

proc call*(call_779309: Call_GetReposOwnerRepoIssuesEvents_779302; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesEvents
  ## List issue events for a repository.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779310 = newJObject()
  var header_779311 = newJObject()
  add(path_779310, "repo", newJString(repo))
  add(path_779310, "owner", newJString(owner))
  add(header_779311, "Accept", newJString(Accept))
  result = call_779309.call(path_779310, nil, header_779311, nil, nil)

var getReposOwnerRepoIssuesEvents* = Call_GetReposOwnerRepoIssuesEvents_779302(
    name: "getReposOwnerRepoIssuesEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/events",
    validator: validate_GetReposOwnerRepoIssuesEvents_779303, base: "/",
    url: url_GetReposOwnerRepoIssuesEvents_779304, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesEventsEventId_779312 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoIssuesEventsEventId_779314(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "eventId" in path, "`eventId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/events/"),
               (kind: VariableSegment, value: "eventId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesEventsEventId_779313(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single event.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   eventId: JInt (required)
  ##          : Id of the event.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779315 = path.getOrDefault("repo")
  valid_779315 = validateParameter(valid_779315, JString, required = true,
                                 default = nil)
  if valid_779315 != nil:
    section.add "repo", valid_779315
  var valid_779316 = path.getOrDefault("eventId")
  valid_779316 = validateParameter(valid_779316, JInt, required = true, default = nil)
  if valid_779316 != nil:
    section.add "eventId", valid_779316
  var valid_779317 = path.getOrDefault("owner")
  valid_779317 = validateParameter(valid_779317, JString, required = true,
                                 default = nil)
  if valid_779317 != nil:
    section.add "owner", valid_779317
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779318 = header.getOrDefault("Accept")
  valid_779318 = validateParameter(valid_779318, JString, required = false,
                                 default = nil)
  if valid_779318 != nil:
    section.add "Accept", valid_779318
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779319: Call_GetReposOwnerRepoIssuesEventsEventId_779312;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single event.
  ## 
  let valid = call_779319.validator(path, query, header, formData, body)
  let scheme = call_779319.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779319.url(scheme.get, call_779319.host, call_779319.base,
                         call_779319.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779319, url, valid)

proc call*(call_779320: Call_GetReposOwnerRepoIssuesEventsEventId_779312;
          repo: string; eventId: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesEventsEventId
  ## Get a single event.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   eventId: int (required)
  ##          : Id of the event.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779321 = newJObject()
  var header_779322 = newJObject()
  add(path_779321, "repo", newJString(repo))
  add(path_779321, "eventId", newJInt(eventId))
  add(path_779321, "owner", newJString(owner))
  add(header_779322, "Accept", newJString(Accept))
  result = call_779320.call(path_779321, nil, header_779322, nil, nil)

var getReposOwnerRepoIssuesEventsEventId* = Call_GetReposOwnerRepoIssuesEventsEventId_779312(
    name: "getReposOwnerRepoIssuesEventsEventId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/events/{eventId}",
    validator: validate_GetReposOwnerRepoIssuesEventsEventId_779313, base: "/",
    url: url_GetReposOwnerRepoIssuesEventsEventId_779314, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumber_779323 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoIssuesNumber_779325(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumber_779324(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single issue
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779326 = path.getOrDefault("repo")
  valid_779326 = validateParameter(valid_779326, JString, required = true,
                                 default = nil)
  if valid_779326 != nil:
    section.add "repo", valid_779326
  var valid_779327 = path.getOrDefault("number")
  valid_779327 = validateParameter(valid_779327, JInt, required = true, default = nil)
  if valid_779327 != nil:
    section.add "number", valid_779327
  var valid_779328 = path.getOrDefault("owner")
  valid_779328 = validateParameter(valid_779328, JString, required = true,
                                 default = nil)
  if valid_779328 != nil:
    section.add "owner", valid_779328
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779329 = header.getOrDefault("Accept")
  valid_779329 = validateParameter(valid_779329, JString, required = false,
                                 default = nil)
  if valid_779329 != nil:
    section.add "Accept", valid_779329
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779330: Call_GetReposOwnerRepoIssuesNumber_779323; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a single issue
  ## 
  let valid = call_779330.validator(path, query, header, formData, body)
  let scheme = call_779330.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779330.url(scheme.get, call_779330.host, call_779330.base,
                         call_779330.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779330, url, valid)

proc call*(call_779331: Call_GetReposOwnerRepoIssuesNumber_779323; repo: string;
          number: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumber
  ## Get a single issue
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Number of issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779332 = newJObject()
  var header_779333 = newJObject()
  add(path_779332, "repo", newJString(repo))
  add(path_779332, "number", newJInt(number))
  add(path_779332, "owner", newJString(owner))
  add(header_779333, "Accept", newJString(Accept))
  result = call_779331.call(path_779332, nil, header_779333, nil, nil)

var getReposOwnerRepoIssuesNumber* = Call_GetReposOwnerRepoIssuesNumber_779323(
    name: "getReposOwnerRepoIssuesNumber", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}",
    validator: validate_GetReposOwnerRepoIssuesNumber_779324, base: "/",
    url: url_GetReposOwnerRepoIssuesNumber_779325, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoIssuesNumber_779334 = ref object of OpenApiRestCall_777573
proc url_PatchReposOwnerRepoIssuesNumber_779336(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoIssuesNumber_779335(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Edit an issue.
  ## Issue owners and users with push access can edit an issue.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779337 = path.getOrDefault("repo")
  valid_779337 = validateParameter(valid_779337, JString, required = true,
                                 default = nil)
  if valid_779337 != nil:
    section.add "repo", valid_779337
  var valid_779338 = path.getOrDefault("number")
  valid_779338 = validateParameter(valid_779338, JInt, required = true, default = nil)
  if valid_779338 != nil:
    section.add "number", valid_779338
  var valid_779339 = path.getOrDefault("owner")
  valid_779339 = validateParameter(valid_779339, JString, required = true,
                                 default = nil)
  if valid_779339 != nil:
    section.add "owner", valid_779339
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779340 = header.getOrDefault("Accept")
  valid_779340 = validateParameter(valid_779340, JString, required = false,
                                 default = nil)
  if valid_779340 != nil:
    section.add "Accept", valid_779340
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_779342: Call_PatchReposOwnerRepoIssuesNumber_779334;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Edit an issue.
  ## Issue owners and users with push access can edit an issue.
  ## 
  ## 
  let valid = call_779342.validator(path, query, header, formData, body)
  let scheme = call_779342.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779342.url(scheme.get, call_779342.host, call_779342.base,
                         call_779342.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779342, url, valid)

proc call*(call_779343: Call_PatchReposOwnerRepoIssuesNumber_779334; repo: string;
          number: int; owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoIssuesNumber
  ## Edit an issue.
  ## Issue owners and users with push access can edit an issue.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Number of issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779344 = newJObject()
  var header_779345 = newJObject()
  var body_779346 = newJObject()
  add(path_779344, "repo", newJString(repo))
  add(path_779344, "number", newJInt(number))
  add(path_779344, "owner", newJString(owner))
  if body != nil:
    body_779346 = body
  add(header_779345, "Accept", newJString(Accept))
  result = call_779343.call(path_779344, nil, header_779345, nil, body_779346)

var patchReposOwnerRepoIssuesNumber* = Call_PatchReposOwnerRepoIssuesNumber_779334(
    name: "patchReposOwnerRepoIssuesNumber", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}",
    validator: validate_PatchReposOwnerRepoIssuesNumber_779335, base: "/",
    url: url_PatchReposOwnerRepoIssuesNumber_779336, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoIssuesNumberComments_779358 = ref object of OpenApiRestCall_777573
proc url_PostReposOwnerRepoIssuesNumberComments_779360(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoIssuesNumberComments_779359(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779361 = path.getOrDefault("repo")
  valid_779361 = validateParameter(valid_779361, JString, required = true,
                                 default = nil)
  if valid_779361 != nil:
    section.add "repo", valid_779361
  var valid_779362 = path.getOrDefault("number")
  valid_779362 = validateParameter(valid_779362, JInt, required = true, default = nil)
  if valid_779362 != nil:
    section.add "number", valid_779362
  var valid_779363 = path.getOrDefault("owner")
  valid_779363 = validateParameter(valid_779363, JString, required = true,
                                 default = nil)
  if valid_779363 != nil:
    section.add "owner", valid_779363
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779364 = header.getOrDefault("Accept")
  valid_779364 = validateParameter(valid_779364, JString, required = false,
                                 default = nil)
  if valid_779364 != nil:
    section.add "Accept", valid_779364
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_779366: Call_PostReposOwnerRepoIssuesNumberComments_779358;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Create a comment.
  ## 
  let valid = call_779366.validator(path, query, header, formData, body)
  let scheme = call_779366.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779366.url(scheme.get, call_779366.host, call_779366.base,
                         call_779366.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779366, url, valid)

proc call*(call_779367: Call_PostReposOwnerRepoIssuesNumberComments_779358;
          repo: string; number: int; owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoIssuesNumberComments
  ## Create a comment.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Number of issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779368 = newJObject()
  var header_779369 = newJObject()
  var body_779370 = newJObject()
  add(path_779368, "repo", newJString(repo))
  add(path_779368, "number", newJInt(number))
  add(path_779368, "owner", newJString(owner))
  if body != nil:
    body_779370 = body
  add(header_779369, "Accept", newJString(Accept))
  result = call_779367.call(path_779368, nil, header_779369, nil, body_779370)

var postReposOwnerRepoIssuesNumberComments* = Call_PostReposOwnerRepoIssuesNumberComments_779358(
    name: "postReposOwnerRepoIssuesNumberComments", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/{number}/comments",
    validator: validate_PostReposOwnerRepoIssuesNumberComments_779359, base: "/",
    url: url_PostReposOwnerRepoIssuesNumberComments_779360,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumberComments_779347 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoIssuesNumberComments_779349(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumberComments_779348(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List comments on an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779350 = path.getOrDefault("repo")
  valid_779350 = validateParameter(valid_779350, JString, required = true,
                                 default = nil)
  if valid_779350 != nil:
    section.add "repo", valid_779350
  var valid_779351 = path.getOrDefault("number")
  valid_779351 = validateParameter(valid_779351, JInt, required = true, default = nil)
  if valid_779351 != nil:
    section.add "number", valid_779351
  var valid_779352 = path.getOrDefault("owner")
  valid_779352 = validateParameter(valid_779352, JString, required = true,
                                 default = nil)
  if valid_779352 != nil:
    section.add "owner", valid_779352
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779353 = header.getOrDefault("Accept")
  valid_779353 = validateParameter(valid_779353, JString, required = false,
                                 default = nil)
  if valid_779353 != nil:
    section.add "Accept", valid_779353
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779354: Call_GetReposOwnerRepoIssuesNumberComments_779347;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List comments on an issue.
  ## 
  let valid = call_779354.validator(path, query, header, formData, body)
  let scheme = call_779354.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779354.url(scheme.get, call_779354.host, call_779354.base,
                         call_779354.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779354, url, valid)

proc call*(call_779355: Call_GetReposOwnerRepoIssuesNumberComments_779347;
          repo: string; number: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumberComments
  ## List comments on an issue.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Number of issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779356 = newJObject()
  var header_779357 = newJObject()
  add(path_779356, "repo", newJString(repo))
  add(path_779356, "number", newJInt(number))
  add(path_779356, "owner", newJString(owner))
  add(header_779357, "Accept", newJString(Accept))
  result = call_779355.call(path_779356, nil, header_779357, nil, nil)

var getReposOwnerRepoIssuesNumberComments* = Call_GetReposOwnerRepoIssuesNumberComments_779347(
    name: "getReposOwnerRepoIssuesNumberComments", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/{number}/comments",
    validator: validate_GetReposOwnerRepoIssuesNumberComments_779348, base: "/",
    url: url_GetReposOwnerRepoIssuesNumberComments_779349, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumberEvents_779371 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoIssuesNumberEvents_779373(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumberEvents_779372(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List events for an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779374 = path.getOrDefault("repo")
  valid_779374 = validateParameter(valid_779374, JString, required = true,
                                 default = nil)
  if valid_779374 != nil:
    section.add "repo", valid_779374
  var valid_779375 = path.getOrDefault("number")
  valid_779375 = validateParameter(valid_779375, JInt, required = true, default = nil)
  if valid_779375 != nil:
    section.add "number", valid_779375
  var valid_779376 = path.getOrDefault("owner")
  valid_779376 = validateParameter(valid_779376, JString, required = true,
                                 default = nil)
  if valid_779376 != nil:
    section.add "owner", valid_779376
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779377 = header.getOrDefault("Accept")
  valid_779377 = validateParameter(valid_779377, JString, required = false,
                                 default = nil)
  if valid_779377 != nil:
    section.add "Accept", valid_779377
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779378: Call_GetReposOwnerRepoIssuesNumberEvents_779371;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List events for an issue.
  ## 
  let valid = call_779378.validator(path, query, header, formData, body)
  let scheme = call_779378.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779378.url(scheme.get, call_779378.host, call_779378.base,
                         call_779378.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779378, url, valid)

proc call*(call_779379: Call_GetReposOwnerRepoIssuesNumberEvents_779371;
          repo: string; number: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumberEvents
  ## List events for an issue.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Number of issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779380 = newJObject()
  var header_779381 = newJObject()
  add(path_779380, "repo", newJString(repo))
  add(path_779380, "number", newJInt(number))
  add(path_779380, "owner", newJString(owner))
  add(header_779381, "Accept", newJString(Accept))
  result = call_779379.call(path_779380, nil, header_779381, nil, nil)

var getReposOwnerRepoIssuesNumberEvents* = Call_GetReposOwnerRepoIssuesNumberEvents_779371(
    name: "getReposOwnerRepoIssuesNumberEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/events",
    validator: validate_GetReposOwnerRepoIssuesNumberEvents_779372, base: "/",
    url: url_GetReposOwnerRepoIssuesNumberEvents_779373, schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoIssuesNumberLabels_779393 = ref object of OpenApiRestCall_777573
proc url_PutReposOwnerRepoIssuesNumberLabels_779395(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoIssuesNumberLabels_779394(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Replace all labels for an issue.
  ## Sending an empty array ([]) will remove all Labels from the Issue.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779396 = path.getOrDefault("repo")
  valid_779396 = validateParameter(valid_779396, JString, required = true,
                                 default = nil)
  if valid_779396 != nil:
    section.add "repo", valid_779396
  var valid_779397 = path.getOrDefault("number")
  valid_779397 = validateParameter(valid_779397, JInt, required = true, default = nil)
  if valid_779397 != nil:
    section.add "number", valid_779397
  var valid_779398 = path.getOrDefault("owner")
  valid_779398 = validateParameter(valid_779398, JString, required = true,
                                 default = nil)
  if valid_779398 != nil:
    section.add "owner", valid_779398
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779399 = header.getOrDefault("Accept")
  valid_779399 = validateParameter(valid_779399, JString, required = false,
                                 default = nil)
  if valid_779399 != nil:
    section.add "Accept", valid_779399
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_779401: Call_PutReposOwnerRepoIssuesNumberLabels_779393;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Replace all labels for an issue.
  ## Sending an empty array ([]) will remove all Labels from the Issue.
  ## 
  ## 
  let valid = call_779401.validator(path, query, header, formData, body)
  let scheme = call_779401.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779401.url(scheme.get, call_779401.host, call_779401.base,
                         call_779401.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779401, url, valid)

proc call*(call_779402: Call_PutReposOwnerRepoIssuesNumberLabels_779393;
          repo: string; number: int; owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## putReposOwnerRepoIssuesNumberLabels
  ## Replace all labels for an issue.
  ## Sending an empty array ([]) will remove all Labels from the Issue.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Number of issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JArray (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779403 = newJObject()
  var header_779404 = newJObject()
  var body_779405 = newJObject()
  add(path_779403, "repo", newJString(repo))
  add(path_779403, "number", newJInt(number))
  add(path_779403, "owner", newJString(owner))
  if body != nil:
    body_779405 = body
  add(header_779404, "Accept", newJString(Accept))
  result = call_779402.call(path_779403, nil, header_779404, nil, body_779405)

var putReposOwnerRepoIssuesNumberLabels* = Call_PutReposOwnerRepoIssuesNumberLabels_779393(
    name: "putReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_PutReposOwnerRepoIssuesNumberLabels_779394, base: "/",
    url: url_PutReposOwnerRepoIssuesNumberLabels_779395, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoIssuesNumberLabels_779406 = ref object of OpenApiRestCall_777573
proc url_PostReposOwnerRepoIssuesNumberLabels_779408(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoIssuesNumberLabels_779407(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Add labels to an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779409 = path.getOrDefault("repo")
  valid_779409 = validateParameter(valid_779409, JString, required = true,
                                 default = nil)
  if valid_779409 != nil:
    section.add "repo", valid_779409
  var valid_779410 = path.getOrDefault("number")
  valid_779410 = validateParameter(valid_779410, JInt, required = true, default = nil)
  if valid_779410 != nil:
    section.add "number", valid_779410
  var valid_779411 = path.getOrDefault("owner")
  valid_779411 = validateParameter(valid_779411, JString, required = true,
                                 default = nil)
  if valid_779411 != nil:
    section.add "owner", valid_779411
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779412 = header.getOrDefault("Accept")
  valid_779412 = validateParameter(valid_779412, JString, required = false,
                                 default = nil)
  if valid_779412 != nil:
    section.add "Accept", valid_779412
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_779414: Call_PostReposOwnerRepoIssuesNumberLabels_779406;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Add labels to an issue.
  ## 
  let valid = call_779414.validator(path, query, header, formData, body)
  let scheme = call_779414.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779414.url(scheme.get, call_779414.host, call_779414.base,
                         call_779414.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779414, url, valid)

proc call*(call_779415: Call_PostReposOwnerRepoIssuesNumberLabels_779406;
          repo: string; number: int; owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoIssuesNumberLabels
  ## Add labels to an issue.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Number of issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JArray (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779416 = newJObject()
  var header_779417 = newJObject()
  var body_779418 = newJObject()
  add(path_779416, "repo", newJString(repo))
  add(path_779416, "number", newJInt(number))
  add(path_779416, "owner", newJString(owner))
  if body != nil:
    body_779418 = body
  add(header_779417, "Accept", newJString(Accept))
  result = call_779415.call(path_779416, nil, header_779417, nil, body_779418)

var postReposOwnerRepoIssuesNumberLabels* = Call_PostReposOwnerRepoIssuesNumberLabels_779406(
    name: "postReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_PostReposOwnerRepoIssuesNumberLabels_779407, base: "/",
    url: url_PostReposOwnerRepoIssuesNumberLabels_779408, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumberLabels_779382 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoIssuesNumberLabels_779384(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumberLabels_779383(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List labels on an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779385 = path.getOrDefault("repo")
  valid_779385 = validateParameter(valid_779385, JString, required = true,
                                 default = nil)
  if valid_779385 != nil:
    section.add "repo", valid_779385
  var valid_779386 = path.getOrDefault("number")
  valid_779386 = validateParameter(valid_779386, JInt, required = true, default = nil)
  if valid_779386 != nil:
    section.add "number", valid_779386
  var valid_779387 = path.getOrDefault("owner")
  valid_779387 = validateParameter(valid_779387, JString, required = true,
                                 default = nil)
  if valid_779387 != nil:
    section.add "owner", valid_779387
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779388 = header.getOrDefault("Accept")
  valid_779388 = validateParameter(valid_779388, JString, required = false,
                                 default = nil)
  if valid_779388 != nil:
    section.add "Accept", valid_779388
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779389: Call_GetReposOwnerRepoIssuesNumberLabels_779382;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List labels on an issue.
  ## 
  let valid = call_779389.validator(path, query, header, formData, body)
  let scheme = call_779389.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779389.url(scheme.get, call_779389.host, call_779389.base,
                         call_779389.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779389, url, valid)

proc call*(call_779390: Call_GetReposOwnerRepoIssuesNumberLabels_779382;
          repo: string; number: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumberLabels
  ## List labels on an issue.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Number of issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779391 = newJObject()
  var header_779392 = newJObject()
  add(path_779391, "repo", newJString(repo))
  add(path_779391, "number", newJInt(number))
  add(path_779391, "owner", newJString(owner))
  add(header_779392, "Accept", newJString(Accept))
  result = call_779390.call(path_779391, nil, header_779392, nil, nil)

var getReposOwnerRepoIssuesNumberLabels* = Call_GetReposOwnerRepoIssuesNumberLabels_779382(
    name: "getReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_GetReposOwnerRepoIssuesNumberLabels_779383, base: "/",
    url: url_GetReposOwnerRepoIssuesNumberLabels_779384, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoIssuesNumberLabels_779419 = ref object of OpenApiRestCall_777573
proc url_DeleteReposOwnerRepoIssuesNumberLabels_779421(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoIssuesNumberLabels_779420(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Remove all labels from an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779422 = path.getOrDefault("repo")
  valid_779422 = validateParameter(valid_779422, JString, required = true,
                                 default = nil)
  if valid_779422 != nil:
    section.add "repo", valid_779422
  var valid_779423 = path.getOrDefault("number")
  valid_779423 = validateParameter(valid_779423, JInt, required = true, default = nil)
  if valid_779423 != nil:
    section.add "number", valid_779423
  var valid_779424 = path.getOrDefault("owner")
  valid_779424 = validateParameter(valid_779424, JString, required = true,
                                 default = nil)
  if valid_779424 != nil:
    section.add "owner", valid_779424
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779425 = header.getOrDefault("Accept")
  valid_779425 = validateParameter(valid_779425, JString, required = false,
                                 default = nil)
  if valid_779425 != nil:
    section.add "Accept", valid_779425
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779426: Call_DeleteReposOwnerRepoIssuesNumberLabels_779419;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Remove all labels from an issue.
  ## 
  let valid = call_779426.validator(path, query, header, formData, body)
  let scheme = call_779426.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779426.url(scheme.get, call_779426.host, call_779426.base,
                         call_779426.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779426, url, valid)

proc call*(call_779427: Call_DeleteReposOwnerRepoIssuesNumberLabels_779419;
          repo: string; number: int; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoIssuesNumberLabels
  ## Remove all labels from an issue.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Number of issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779428 = newJObject()
  var header_779429 = newJObject()
  add(path_779428, "repo", newJString(repo))
  add(path_779428, "number", newJInt(number))
  add(path_779428, "owner", newJString(owner))
  add(header_779429, "Accept", newJString(Accept))
  result = call_779427.call(path_779428, nil, header_779429, nil, nil)

var deleteReposOwnerRepoIssuesNumberLabels* = Call_DeleteReposOwnerRepoIssuesNumberLabels_779419(
    name: "deleteReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_DeleteReposOwnerRepoIssuesNumberLabels_779420, base: "/",
    url: url_DeleteReposOwnerRepoIssuesNumberLabels_779421,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoIssuesNumberLabelsName_779430 = ref object of OpenApiRestCall_777573
proc url_DeleteReposOwnerRepoIssuesNumberLabelsName_779432(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoIssuesNumberLabelsName_779431(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Remove a label from an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   name: JString (required)
  ##       : Name of the label.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779433 = path.getOrDefault("repo")
  valid_779433 = validateParameter(valid_779433, JString, required = true,
                                 default = nil)
  if valid_779433 != nil:
    section.add "repo", valid_779433
  var valid_779434 = path.getOrDefault("name")
  valid_779434 = validateParameter(valid_779434, JString, required = true,
                                 default = nil)
  if valid_779434 != nil:
    section.add "name", valid_779434
  var valid_779435 = path.getOrDefault("number")
  valid_779435 = validateParameter(valid_779435, JInt, required = true, default = nil)
  if valid_779435 != nil:
    section.add "number", valid_779435
  var valid_779436 = path.getOrDefault("owner")
  valid_779436 = validateParameter(valid_779436, JString, required = true,
                                 default = nil)
  if valid_779436 != nil:
    section.add "owner", valid_779436
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779437 = header.getOrDefault("Accept")
  valid_779437 = validateParameter(valid_779437, JString, required = false,
                                 default = nil)
  if valid_779437 != nil:
    section.add "Accept", valid_779437
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779438: Call_DeleteReposOwnerRepoIssuesNumberLabelsName_779430;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Remove a label from an issue.
  ## 
  let valid = call_779438.validator(path, query, header, formData, body)
  let scheme = call_779438.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779438.url(scheme.get, call_779438.host, call_779438.base,
                         call_779438.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779438, url, valid)

proc call*(call_779439: Call_DeleteReposOwnerRepoIssuesNumberLabelsName_779430;
          repo: string; name: string; number: int; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoIssuesNumberLabelsName
  ## Remove a label from an issue.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   name: string (required)
  ##       : Name of the label.
  ##   number: int (required)
  ##         : Number of issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779440 = newJObject()
  var header_779441 = newJObject()
  add(path_779440, "repo", newJString(repo))
  add(path_779440, "name", newJString(name))
  add(path_779440, "number", newJInt(number))
  add(path_779440, "owner", newJString(owner))
  add(header_779441, "Accept", newJString(Accept))
  result = call_779439.call(path_779440, nil, header_779441, nil, nil)

var deleteReposOwnerRepoIssuesNumberLabelsName* = Call_DeleteReposOwnerRepoIssuesNumberLabelsName_779430(
    name: "deleteReposOwnerRepoIssuesNumberLabelsName",
    meth: HttpMethod.HttpDelete, host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/{number}/labels/{name}",
    validator: validate_DeleteReposOwnerRepoIssuesNumberLabelsName_779431,
    base: "/", url: url_DeleteReposOwnerRepoIssuesNumberLabelsName_779432,
    schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoKeys_779452 = ref object of OpenApiRestCall_777573
proc url_PostReposOwnerRepoKeys_779454(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/keys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoKeys_779453(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a key.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779455 = path.getOrDefault("repo")
  valid_779455 = validateParameter(valid_779455, JString, required = true,
                                 default = nil)
  if valid_779455 != nil:
    section.add "repo", valid_779455
  var valid_779456 = path.getOrDefault("owner")
  valid_779456 = validateParameter(valid_779456, JString, required = true,
                                 default = nil)
  if valid_779456 != nil:
    section.add "owner", valid_779456
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779457 = header.getOrDefault("Accept")
  valid_779457 = validateParameter(valid_779457, JString, required = false,
                                 default = nil)
  if valid_779457 != nil:
    section.add "Accept", valid_779457
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_779459: Call_PostReposOwnerRepoKeys_779452; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a key.
  ## 
  let valid = call_779459.validator(path, query, header, formData, body)
  let scheme = call_779459.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779459.url(scheme.get, call_779459.host, call_779459.base,
                         call_779459.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779459, url, valid)

proc call*(call_779460: Call_PostReposOwnerRepoKeys_779452; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoKeys
  ## Create a key.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779461 = newJObject()
  var header_779462 = newJObject()
  var body_779463 = newJObject()
  add(path_779461, "repo", newJString(repo))
  add(path_779461, "owner", newJString(owner))
  if body != nil:
    body_779463 = body
  add(header_779462, "Accept", newJString(Accept))
  result = call_779460.call(path_779461, nil, header_779462, nil, body_779463)

var postReposOwnerRepoKeys* = Call_PostReposOwnerRepoKeys_779452(
    name: "postReposOwnerRepoKeys", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/keys",
    validator: validate_PostReposOwnerRepoKeys_779453, base: "/",
    url: url_PostReposOwnerRepoKeys_779454, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoKeys_779442 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoKeys_779444(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/keys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoKeys_779443(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get list of keys.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779445 = path.getOrDefault("repo")
  valid_779445 = validateParameter(valid_779445, JString, required = true,
                                 default = nil)
  if valid_779445 != nil:
    section.add "repo", valid_779445
  var valid_779446 = path.getOrDefault("owner")
  valid_779446 = validateParameter(valid_779446, JString, required = true,
                                 default = nil)
  if valid_779446 != nil:
    section.add "owner", valid_779446
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779447 = header.getOrDefault("Accept")
  valid_779447 = validateParameter(valid_779447, JString, required = false,
                                 default = nil)
  if valid_779447 != nil:
    section.add "Accept", valid_779447
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779448: Call_GetReposOwnerRepoKeys_779442; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get list of keys.
  ## 
  let valid = call_779448.validator(path, query, header, formData, body)
  let scheme = call_779448.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779448.url(scheme.get, call_779448.host, call_779448.base,
                         call_779448.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779448, url, valid)

proc call*(call_779449: Call_GetReposOwnerRepoKeys_779442; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoKeys
  ## Get list of keys.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779450 = newJObject()
  var header_779451 = newJObject()
  add(path_779450, "repo", newJString(repo))
  add(path_779450, "owner", newJString(owner))
  add(header_779451, "Accept", newJString(Accept))
  result = call_779449.call(path_779450, nil, header_779451, nil, nil)

var getReposOwnerRepoKeys* = Call_GetReposOwnerRepoKeys_779442(
    name: "getReposOwnerRepoKeys", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/repos/{owner}/{repo}/keys",
    validator: validate_GetReposOwnerRepoKeys_779443, base: "/",
    url: url_GetReposOwnerRepoKeys_779444, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoKeysKeyId_779464 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoKeysKeyId_779466(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/keys/"),
               (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoKeysKeyId_779465(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a key
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   keyId: JInt (required)
  ##        : Id of key.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779467 = path.getOrDefault("repo")
  valid_779467 = validateParameter(valid_779467, JString, required = true,
                                 default = nil)
  if valid_779467 != nil:
    section.add "repo", valid_779467
  var valid_779468 = path.getOrDefault("keyId")
  valid_779468 = validateParameter(valid_779468, JInt, required = true, default = nil)
  if valid_779468 != nil:
    section.add "keyId", valid_779468
  var valid_779469 = path.getOrDefault("owner")
  valid_779469 = validateParameter(valid_779469, JString, required = true,
                                 default = nil)
  if valid_779469 != nil:
    section.add "owner", valid_779469
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779470 = header.getOrDefault("Accept")
  valid_779470 = validateParameter(valid_779470, JString, required = false,
                                 default = nil)
  if valid_779470 != nil:
    section.add "Accept", valid_779470
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779471: Call_GetReposOwnerRepoKeysKeyId_779464; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a key
  ## 
  let valid = call_779471.validator(path, query, header, formData, body)
  let scheme = call_779471.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779471.url(scheme.get, call_779471.host, call_779471.base,
                         call_779471.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779471, url, valid)

proc call*(call_779472: Call_GetReposOwnerRepoKeysKeyId_779464; repo: string;
          keyId: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoKeysKeyId
  ## Get a key
  ##   repo: string (required)
  ##       : Name of repository.
  ##   keyId: int (required)
  ##        : Id of key.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779473 = newJObject()
  var header_779474 = newJObject()
  add(path_779473, "repo", newJString(repo))
  add(path_779473, "keyId", newJInt(keyId))
  add(path_779473, "owner", newJString(owner))
  add(header_779474, "Accept", newJString(Accept))
  result = call_779472.call(path_779473, nil, header_779474, nil, nil)

var getReposOwnerRepoKeysKeyId* = Call_GetReposOwnerRepoKeysKeyId_779464(
    name: "getReposOwnerRepoKeysKeyId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/keys/{keyId}",
    validator: validate_GetReposOwnerRepoKeysKeyId_779465, base: "/",
    url: url_GetReposOwnerRepoKeysKeyId_779466, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoKeysKeyId_779475 = ref object of OpenApiRestCall_777573
proc url_DeleteReposOwnerRepoKeysKeyId_779477(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/keys/"),
               (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoKeysKeyId_779476(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a key.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   keyId: JInt (required)
  ##        : Id of key.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779478 = path.getOrDefault("repo")
  valid_779478 = validateParameter(valid_779478, JString, required = true,
                                 default = nil)
  if valid_779478 != nil:
    section.add "repo", valid_779478
  var valid_779479 = path.getOrDefault("keyId")
  valid_779479 = validateParameter(valid_779479, JInt, required = true, default = nil)
  if valid_779479 != nil:
    section.add "keyId", valid_779479
  var valid_779480 = path.getOrDefault("owner")
  valid_779480 = validateParameter(valid_779480, JString, required = true,
                                 default = nil)
  if valid_779480 != nil:
    section.add "owner", valid_779480
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779481 = header.getOrDefault("Accept")
  valid_779481 = validateParameter(valid_779481, JString, required = false,
                                 default = nil)
  if valid_779481 != nil:
    section.add "Accept", valid_779481
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779482: Call_DeleteReposOwnerRepoKeysKeyId_779475; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete a key.
  ## 
  let valid = call_779482.validator(path, query, header, formData, body)
  let scheme = call_779482.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779482.url(scheme.get, call_779482.host, call_779482.base,
                         call_779482.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779482, url, valid)

proc call*(call_779483: Call_DeleteReposOwnerRepoKeysKeyId_779475; repo: string;
          keyId: int; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoKeysKeyId
  ## Delete a key.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   keyId: int (required)
  ##        : Id of key.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779484 = newJObject()
  var header_779485 = newJObject()
  add(path_779484, "repo", newJString(repo))
  add(path_779484, "keyId", newJInt(keyId))
  add(path_779484, "owner", newJString(owner))
  add(header_779485, "Accept", newJString(Accept))
  result = call_779483.call(path_779484, nil, header_779485, nil, nil)

var deleteReposOwnerRepoKeysKeyId* = Call_DeleteReposOwnerRepoKeysKeyId_779475(
    name: "deleteReposOwnerRepoKeysKeyId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/keys/{keyId}",
    validator: validate_DeleteReposOwnerRepoKeysKeyId_779476, base: "/",
    url: url_DeleteReposOwnerRepoKeysKeyId_779477, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoLabels_779496 = ref object of OpenApiRestCall_777573
proc url_PostReposOwnerRepoLabels_779498(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoLabels_779497(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779499 = path.getOrDefault("repo")
  valid_779499 = validateParameter(valid_779499, JString, required = true,
                                 default = nil)
  if valid_779499 != nil:
    section.add "repo", valid_779499
  var valid_779500 = path.getOrDefault("owner")
  valid_779500 = validateParameter(valid_779500, JString, required = true,
                                 default = nil)
  if valid_779500 != nil:
    section.add "owner", valid_779500
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779501 = header.getOrDefault("Accept")
  valid_779501 = validateParameter(valid_779501, JString, required = false,
                                 default = nil)
  if valid_779501 != nil:
    section.add "Accept", valid_779501
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_779503: Call_PostReposOwnerRepoLabels_779496; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a label.
  ## 
  let valid = call_779503.validator(path, query, header, formData, body)
  let scheme = call_779503.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779503.url(scheme.get, call_779503.host, call_779503.base,
                         call_779503.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779503, url, valid)

proc call*(call_779504: Call_PostReposOwnerRepoLabels_779496; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoLabels
  ## Create a label.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JArray (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779505 = newJObject()
  var header_779506 = newJObject()
  var body_779507 = newJObject()
  add(path_779505, "repo", newJString(repo))
  add(path_779505, "owner", newJString(owner))
  if body != nil:
    body_779507 = body
  add(header_779506, "Accept", newJString(Accept))
  result = call_779504.call(path_779505, nil, header_779506, nil, body_779507)

var postReposOwnerRepoLabels* = Call_PostReposOwnerRepoLabels_779496(
    name: "postReposOwnerRepoLabels", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels",
    validator: validate_PostReposOwnerRepoLabels_779497, base: "/",
    url: url_PostReposOwnerRepoLabels_779498, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoLabels_779486 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoLabels_779488(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoLabels_779487(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List all labels for this repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779489 = path.getOrDefault("repo")
  valid_779489 = validateParameter(valid_779489, JString, required = true,
                                 default = nil)
  if valid_779489 != nil:
    section.add "repo", valid_779489
  var valid_779490 = path.getOrDefault("owner")
  valid_779490 = validateParameter(valid_779490, JString, required = true,
                                 default = nil)
  if valid_779490 != nil:
    section.add "owner", valid_779490
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779491 = header.getOrDefault("Accept")
  valid_779491 = validateParameter(valid_779491, JString, required = false,
                                 default = nil)
  if valid_779491 != nil:
    section.add "Accept", valid_779491
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779492: Call_GetReposOwnerRepoLabels_779486; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List all labels for this repository.
  ## 
  let valid = call_779492.validator(path, query, header, formData, body)
  let scheme = call_779492.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779492.url(scheme.get, call_779492.host, call_779492.base,
                         call_779492.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779492, url, valid)

proc call*(call_779493: Call_GetReposOwnerRepoLabels_779486; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoLabels
  ## List all labels for this repository.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779494 = newJObject()
  var header_779495 = newJObject()
  add(path_779494, "repo", newJString(repo))
  add(path_779494, "owner", newJString(owner))
  add(header_779495, "Accept", newJString(Accept))
  result = call_779493.call(path_779494, nil, header_779495, nil, nil)

var getReposOwnerRepoLabels* = Call_GetReposOwnerRepoLabels_779486(
    name: "getReposOwnerRepoLabels", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels",
    validator: validate_GetReposOwnerRepoLabels_779487, base: "/",
    url: url_GetReposOwnerRepoLabels_779488, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoLabelsName_779508 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoLabelsName_779510(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoLabelsName_779509(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   name: JString (required)
  ##       : Name of the label.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779511 = path.getOrDefault("repo")
  valid_779511 = validateParameter(valid_779511, JString, required = true,
                                 default = nil)
  if valid_779511 != nil:
    section.add "repo", valid_779511
  var valid_779512 = path.getOrDefault("name")
  valid_779512 = validateParameter(valid_779512, JString, required = true,
                                 default = nil)
  if valid_779512 != nil:
    section.add "name", valid_779512
  var valid_779513 = path.getOrDefault("owner")
  valid_779513 = validateParameter(valid_779513, JString, required = true,
                                 default = nil)
  if valid_779513 != nil:
    section.add "owner", valid_779513
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779514 = header.getOrDefault("Accept")
  valid_779514 = validateParameter(valid_779514, JString, required = false,
                                 default = nil)
  if valid_779514 != nil:
    section.add "Accept", valid_779514
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779515: Call_GetReposOwnerRepoLabelsName_779508; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a single label.
  ## 
  let valid = call_779515.validator(path, query, header, formData, body)
  let scheme = call_779515.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779515.url(scheme.get, call_779515.host, call_779515.base,
                         call_779515.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779515, url, valid)

proc call*(call_779516: Call_GetReposOwnerRepoLabelsName_779508; repo: string;
          name: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoLabelsName
  ## Get a single label.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   name: string (required)
  ##       : Name of the label.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779517 = newJObject()
  var header_779518 = newJObject()
  add(path_779517, "repo", newJString(repo))
  add(path_779517, "name", newJString(name))
  add(path_779517, "owner", newJString(owner))
  add(header_779518, "Accept", newJString(Accept))
  result = call_779516.call(path_779517, nil, header_779518, nil, nil)

var getReposOwnerRepoLabelsName* = Call_GetReposOwnerRepoLabelsName_779508(
    name: "getReposOwnerRepoLabelsName", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels/{name}",
    validator: validate_GetReposOwnerRepoLabelsName_779509, base: "/",
    url: url_GetReposOwnerRepoLabelsName_779510, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoLabelsName_779530 = ref object of OpenApiRestCall_777573
proc url_PatchReposOwnerRepoLabelsName_779532(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoLabelsName_779531(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Update a label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   name: JString (required)
  ##       : Name of the label.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779533 = path.getOrDefault("repo")
  valid_779533 = validateParameter(valid_779533, JString, required = true,
                                 default = nil)
  if valid_779533 != nil:
    section.add "repo", valid_779533
  var valid_779534 = path.getOrDefault("name")
  valid_779534 = validateParameter(valid_779534, JString, required = true,
                                 default = nil)
  if valid_779534 != nil:
    section.add "name", valid_779534
  var valid_779535 = path.getOrDefault("owner")
  valid_779535 = validateParameter(valid_779535, JString, required = true,
                                 default = nil)
  if valid_779535 != nil:
    section.add "owner", valid_779535
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779536 = header.getOrDefault("Accept")
  valid_779536 = validateParameter(valid_779536, JString, required = false,
                                 default = nil)
  if valid_779536 != nil:
    section.add "Accept", valid_779536
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_779538: Call_PatchReposOwnerRepoLabelsName_779530; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Update a label.
  ## 
  let valid = call_779538.validator(path, query, header, formData, body)
  let scheme = call_779538.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779538.url(scheme.get, call_779538.host, call_779538.base,
                         call_779538.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779538, url, valid)

proc call*(call_779539: Call_PatchReposOwnerRepoLabelsName_779530; repo: string;
          name: string; owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoLabelsName
  ## Update a label.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   name: string (required)
  ##       : Name of the label.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JArray (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779540 = newJObject()
  var header_779541 = newJObject()
  var body_779542 = newJObject()
  add(path_779540, "repo", newJString(repo))
  add(path_779540, "name", newJString(name))
  add(path_779540, "owner", newJString(owner))
  if body != nil:
    body_779542 = body
  add(header_779541, "Accept", newJString(Accept))
  result = call_779539.call(path_779540, nil, header_779541, nil, body_779542)

var patchReposOwnerRepoLabelsName* = Call_PatchReposOwnerRepoLabelsName_779530(
    name: "patchReposOwnerRepoLabelsName", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels/{name}",
    validator: validate_PatchReposOwnerRepoLabelsName_779531, base: "/",
    url: url_PatchReposOwnerRepoLabelsName_779532, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoLabelsName_779519 = ref object of OpenApiRestCall_777573
proc url_DeleteReposOwnerRepoLabelsName_779521(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoLabelsName_779520(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   name: JString (required)
  ##       : Name of the label.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779522 = path.getOrDefault("repo")
  valid_779522 = validateParameter(valid_779522, JString, required = true,
                                 default = nil)
  if valid_779522 != nil:
    section.add "repo", valid_779522
  var valid_779523 = path.getOrDefault("name")
  valid_779523 = validateParameter(valid_779523, JString, required = true,
                                 default = nil)
  if valid_779523 != nil:
    section.add "name", valid_779523
  var valid_779524 = path.getOrDefault("owner")
  valid_779524 = validateParameter(valid_779524, JString, required = true,
                                 default = nil)
  if valid_779524 != nil:
    section.add "owner", valid_779524
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779525 = header.getOrDefault("Accept")
  valid_779525 = validateParameter(valid_779525, JString, required = false,
                                 default = nil)
  if valid_779525 != nil:
    section.add "Accept", valid_779525
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779526: Call_DeleteReposOwnerRepoLabelsName_779519; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete a label.
  ## 
  let valid = call_779526.validator(path, query, header, formData, body)
  let scheme = call_779526.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779526.url(scheme.get, call_779526.host, call_779526.base,
                         call_779526.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779526, url, valid)

proc call*(call_779527: Call_DeleteReposOwnerRepoLabelsName_779519; repo: string;
          name: string; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoLabelsName
  ## Delete a label.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   name: string (required)
  ##       : Name of the label.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779528 = newJObject()
  var header_779529 = newJObject()
  add(path_779528, "repo", newJString(repo))
  add(path_779528, "name", newJString(name))
  add(path_779528, "owner", newJString(owner))
  add(header_779529, "Accept", newJString(Accept))
  result = call_779527.call(path_779528, nil, header_779529, nil, nil)

var deleteReposOwnerRepoLabelsName* = Call_DeleteReposOwnerRepoLabelsName_779519(
    name: "deleteReposOwnerRepoLabelsName", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels/{name}",
    validator: validate_DeleteReposOwnerRepoLabelsName_779520, base: "/",
    url: url_DeleteReposOwnerRepoLabelsName_779521, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoLanguages_779543 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoLanguages_779545(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/languages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoLanguages_779544(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List languages.
  ## List languages for the specified repository. The value on the right of a
  ## language is the number of bytes of code written in that language.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779546 = path.getOrDefault("repo")
  valid_779546 = validateParameter(valid_779546, JString, required = true,
                                 default = nil)
  if valid_779546 != nil:
    section.add "repo", valid_779546
  var valid_779547 = path.getOrDefault("owner")
  valid_779547 = validateParameter(valid_779547, JString, required = true,
                                 default = nil)
  if valid_779547 != nil:
    section.add "owner", valid_779547
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779548 = header.getOrDefault("Accept")
  valid_779548 = validateParameter(valid_779548, JString, required = false,
                                 default = nil)
  if valid_779548 != nil:
    section.add "Accept", valid_779548
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779549: Call_GetReposOwnerRepoLanguages_779543; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List languages.
  ## List languages for the specified repository. The value on the right of a
  ## language is the number of bytes of code written in that language.
  ## 
  ## 
  let valid = call_779549.validator(path, query, header, formData, body)
  let scheme = call_779549.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779549.url(scheme.get, call_779549.host, call_779549.base,
                         call_779549.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779549, url, valid)

proc call*(call_779550: Call_GetReposOwnerRepoLanguages_779543; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoLanguages
  ## List languages.
  ## List languages for the specified repository. The value on the right of a
  ## language is the number of bytes of code written in that language.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779551 = newJObject()
  var header_779552 = newJObject()
  add(path_779551, "repo", newJString(repo))
  add(path_779551, "owner", newJString(owner))
  add(header_779552, "Accept", newJString(Accept))
  result = call_779550.call(path_779551, nil, header_779552, nil, nil)

var getReposOwnerRepoLanguages* = Call_GetReposOwnerRepoLanguages_779543(
    name: "getReposOwnerRepoLanguages", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/languages",
    validator: validate_GetReposOwnerRepoLanguages_779544, base: "/",
    url: url_GetReposOwnerRepoLanguages_779545, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoMerges_779553 = ref object of OpenApiRestCall_777573
proc url_PostReposOwnerRepoMerges_779555(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/merges")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoMerges_779554(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Perform a merge.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779556 = path.getOrDefault("repo")
  valid_779556 = validateParameter(valid_779556, JString, required = true,
                                 default = nil)
  if valid_779556 != nil:
    section.add "repo", valid_779556
  var valid_779557 = path.getOrDefault("owner")
  valid_779557 = validateParameter(valid_779557, JString, required = true,
                                 default = nil)
  if valid_779557 != nil:
    section.add "owner", valid_779557
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779558 = header.getOrDefault("Accept")
  valid_779558 = validateParameter(valid_779558, JString, required = false,
                                 default = nil)
  if valid_779558 != nil:
    section.add "Accept", valid_779558
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_779560: Call_PostReposOwnerRepoMerges_779553; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Perform a merge.
  ## 
  let valid = call_779560.validator(path, query, header, formData, body)
  let scheme = call_779560.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779560.url(scheme.get, call_779560.host, call_779560.base,
                         call_779560.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779560, url, valid)

proc call*(call_779561: Call_PostReposOwnerRepoMerges_779553; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoMerges
  ## Perform a merge.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779562 = newJObject()
  var header_779563 = newJObject()
  var body_779564 = newJObject()
  add(path_779562, "repo", newJString(repo))
  add(path_779562, "owner", newJString(owner))
  if body != nil:
    body_779564 = body
  add(header_779563, "Accept", newJString(Accept))
  result = call_779561.call(path_779562, nil, header_779563, nil, body_779564)

var postReposOwnerRepoMerges* = Call_PostReposOwnerRepoMerges_779553(
    name: "postReposOwnerRepoMerges", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/merges",
    validator: validate_PostReposOwnerRepoMerges_779554, base: "/",
    url: url_PostReposOwnerRepoMerges_779555, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoMilestones_779579 = ref object of OpenApiRestCall_777573
proc url_PostReposOwnerRepoMilestones_779581(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoMilestones_779580(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779582 = path.getOrDefault("repo")
  valid_779582 = validateParameter(valid_779582, JString, required = true,
                                 default = nil)
  if valid_779582 != nil:
    section.add "repo", valid_779582
  var valid_779583 = path.getOrDefault("owner")
  valid_779583 = validateParameter(valid_779583, JString, required = true,
                                 default = nil)
  if valid_779583 != nil:
    section.add "owner", valid_779583
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779584 = header.getOrDefault("Accept")
  valid_779584 = validateParameter(valid_779584, JString, required = false,
                                 default = nil)
  if valid_779584 != nil:
    section.add "Accept", valid_779584
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_779586: Call_PostReposOwnerRepoMilestones_779579; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a milestone.
  ## 
  let valid = call_779586.validator(path, query, header, formData, body)
  let scheme = call_779586.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779586.url(scheme.get, call_779586.host, call_779586.base,
                         call_779586.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779586, url, valid)

proc call*(call_779587: Call_PostReposOwnerRepoMilestones_779579; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoMilestones
  ## Create a milestone.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779588 = newJObject()
  var header_779589 = newJObject()
  var body_779590 = newJObject()
  add(path_779588, "repo", newJString(repo))
  add(path_779588, "owner", newJString(owner))
  if body != nil:
    body_779590 = body
  add(header_779589, "Accept", newJString(Accept))
  result = call_779587.call(path_779588, nil, header_779589, nil, body_779590)

var postReposOwnerRepoMilestones* = Call_PostReposOwnerRepoMilestones_779579(
    name: "postReposOwnerRepoMilestones", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones",
    validator: validate_PostReposOwnerRepoMilestones_779580, base: "/",
    url: url_PostReposOwnerRepoMilestones_779581, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoMilestones_779565 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoMilestones_779567(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoMilestones_779566(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List milestones for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779568 = path.getOrDefault("repo")
  valid_779568 = validateParameter(valid_779568, JString, required = true,
                                 default = nil)
  if valid_779568 != nil:
    section.add "repo", valid_779568
  var valid_779569 = path.getOrDefault("owner")
  valid_779569 = validateParameter(valid_779569, JString, required = true,
                                 default = nil)
  if valid_779569 != nil:
    section.add "owner", valid_779569
  result.add "path", section
  ## parameters in `query` object:
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  ##   state: JString
  ##        : String to filter by state.
  ##   sort: JString
  section = newJObject()
  var valid_779570 = query.getOrDefault("direction")
  valid_779570 = validateParameter(valid_779570, JString, required = false,
                                 default = nil)
  if valid_779570 != nil:
    section.add "direction", valid_779570
  var valid_779571 = query.getOrDefault("state")
  valid_779571 = validateParameter(valid_779571, JString, required = false,
                                 default = newJString("open"))
  if valid_779571 != nil:
    section.add "state", valid_779571
  var valid_779572 = query.getOrDefault("sort")
  valid_779572 = validateParameter(valid_779572, JString, required = false,
                                 default = newJString("due_date"))
  if valid_779572 != nil:
    section.add "sort", valid_779572
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779573 = header.getOrDefault("Accept")
  valid_779573 = validateParameter(valid_779573, JString, required = false,
                                 default = nil)
  if valid_779573 != nil:
    section.add "Accept", valid_779573
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779574: Call_GetReposOwnerRepoMilestones_779565; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List milestones for a repository.
  ## 
  let valid = call_779574.validator(path, query, header, formData, body)
  let scheme = call_779574.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779574.url(scheme.get, call_779574.host, call_779574.base,
                         call_779574.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779574, url, valid)

proc call*(call_779575: Call_GetReposOwnerRepoMilestones_779565; repo: string;
          owner: string; direction: string = ""; state: string = "open";
          Accept: string = ""; sort: string = "due_date"): Recallable =
  ## getReposOwnerRepoMilestones
  ## List milestones for a repository.
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   state: string
  ##        : String to filter by state.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  var path_779576 = newJObject()
  var query_779577 = newJObject()
  var header_779578 = newJObject()
  add(query_779577, "direction", newJString(direction))
  add(path_779576, "repo", newJString(repo))
  add(query_779577, "state", newJString(state))
  add(path_779576, "owner", newJString(owner))
  add(header_779578, "Accept", newJString(Accept))
  add(query_779577, "sort", newJString(sort))
  result = call_779575.call(path_779576, query_779577, header_779578, nil, nil)

var getReposOwnerRepoMilestones* = Call_GetReposOwnerRepoMilestones_779565(
    name: "getReposOwnerRepoMilestones", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones",
    validator: validate_GetReposOwnerRepoMilestones_779566, base: "/",
    url: url_GetReposOwnerRepoMilestones_779567, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoMilestonesNumber_779591 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoMilestonesNumber_779593(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoMilestonesNumber_779592(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779594 = path.getOrDefault("repo")
  valid_779594 = validateParameter(valid_779594, JString, required = true,
                                 default = nil)
  if valid_779594 != nil:
    section.add "repo", valid_779594
  var valid_779595 = path.getOrDefault("number")
  valid_779595 = validateParameter(valid_779595, JInt, required = true, default = nil)
  if valid_779595 != nil:
    section.add "number", valid_779595
  var valid_779596 = path.getOrDefault("owner")
  valid_779596 = validateParameter(valid_779596, JString, required = true,
                                 default = nil)
  if valid_779596 != nil:
    section.add "owner", valid_779596
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779597 = header.getOrDefault("Accept")
  valid_779597 = validateParameter(valid_779597, JString, required = false,
                                 default = nil)
  if valid_779597 != nil:
    section.add "Accept", valid_779597
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779598: Call_GetReposOwnerRepoMilestonesNumber_779591;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single milestone.
  ## 
  let valid = call_779598.validator(path, query, header, formData, body)
  let scheme = call_779598.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779598.url(scheme.get, call_779598.host, call_779598.base,
                         call_779598.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779598, url, valid)

proc call*(call_779599: Call_GetReposOwnerRepoMilestonesNumber_779591;
          repo: string; number: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoMilestonesNumber
  ## Get a single milestone.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779600 = newJObject()
  var header_779601 = newJObject()
  add(path_779600, "repo", newJString(repo))
  add(path_779600, "number", newJInt(number))
  add(path_779600, "owner", newJString(owner))
  add(header_779601, "Accept", newJString(Accept))
  result = call_779599.call(path_779600, nil, header_779601, nil, nil)

var getReposOwnerRepoMilestonesNumber* = Call_GetReposOwnerRepoMilestonesNumber_779591(
    name: "getReposOwnerRepoMilestonesNumber", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones/{number}",
    validator: validate_GetReposOwnerRepoMilestonesNumber_779592, base: "/",
    url: url_GetReposOwnerRepoMilestonesNumber_779593, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoMilestonesNumber_779613 = ref object of OpenApiRestCall_777573
proc url_PatchReposOwnerRepoMilestonesNumber_779615(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoMilestonesNumber_779614(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Update a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779616 = path.getOrDefault("repo")
  valid_779616 = validateParameter(valid_779616, JString, required = true,
                                 default = nil)
  if valid_779616 != nil:
    section.add "repo", valid_779616
  var valid_779617 = path.getOrDefault("number")
  valid_779617 = validateParameter(valid_779617, JInt, required = true, default = nil)
  if valid_779617 != nil:
    section.add "number", valid_779617
  var valid_779618 = path.getOrDefault("owner")
  valid_779618 = validateParameter(valid_779618, JString, required = true,
                                 default = nil)
  if valid_779618 != nil:
    section.add "owner", valid_779618
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779619 = header.getOrDefault("Accept")
  valid_779619 = validateParameter(valid_779619, JString, required = false,
                                 default = nil)
  if valid_779619 != nil:
    section.add "Accept", valid_779619
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_779621: Call_PatchReposOwnerRepoMilestonesNumber_779613;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Update a milestone.
  ## 
  let valid = call_779621.validator(path, query, header, formData, body)
  let scheme = call_779621.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779621.url(scheme.get, call_779621.host, call_779621.base,
                         call_779621.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779621, url, valid)

proc call*(call_779622: Call_PatchReposOwnerRepoMilestonesNumber_779613;
          repo: string; number: int; owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoMilestonesNumber
  ## Update a milestone.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779623 = newJObject()
  var header_779624 = newJObject()
  var body_779625 = newJObject()
  add(path_779623, "repo", newJString(repo))
  add(path_779623, "number", newJInt(number))
  add(path_779623, "owner", newJString(owner))
  if body != nil:
    body_779625 = body
  add(header_779624, "Accept", newJString(Accept))
  result = call_779622.call(path_779623, nil, header_779624, nil, body_779625)

var patchReposOwnerRepoMilestonesNumber* = Call_PatchReposOwnerRepoMilestonesNumber_779613(
    name: "patchReposOwnerRepoMilestonesNumber", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones/{number}",
    validator: validate_PatchReposOwnerRepoMilestonesNumber_779614, base: "/",
    url: url_PatchReposOwnerRepoMilestonesNumber_779615, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoMilestonesNumber_779602 = ref object of OpenApiRestCall_777573
proc url_DeleteReposOwnerRepoMilestonesNumber_779604(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoMilestonesNumber_779603(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779605 = path.getOrDefault("repo")
  valid_779605 = validateParameter(valid_779605, JString, required = true,
                                 default = nil)
  if valid_779605 != nil:
    section.add "repo", valid_779605
  var valid_779606 = path.getOrDefault("number")
  valid_779606 = validateParameter(valid_779606, JInt, required = true, default = nil)
  if valid_779606 != nil:
    section.add "number", valid_779606
  var valid_779607 = path.getOrDefault("owner")
  valid_779607 = validateParameter(valid_779607, JString, required = true,
                                 default = nil)
  if valid_779607 != nil:
    section.add "owner", valid_779607
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779608 = header.getOrDefault("Accept")
  valid_779608 = validateParameter(valid_779608, JString, required = false,
                                 default = nil)
  if valid_779608 != nil:
    section.add "Accept", valid_779608
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779609: Call_DeleteReposOwnerRepoMilestonesNumber_779602;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a milestone.
  ## 
  let valid = call_779609.validator(path, query, header, formData, body)
  let scheme = call_779609.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779609.url(scheme.get, call_779609.host, call_779609.base,
                         call_779609.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779609, url, valid)

proc call*(call_779610: Call_DeleteReposOwnerRepoMilestonesNumber_779602;
          repo: string; number: int; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoMilestonesNumber
  ## Delete a milestone.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779611 = newJObject()
  var header_779612 = newJObject()
  add(path_779611, "repo", newJString(repo))
  add(path_779611, "number", newJInt(number))
  add(path_779611, "owner", newJString(owner))
  add(header_779612, "Accept", newJString(Accept))
  result = call_779610.call(path_779611, nil, header_779612, nil, nil)

var deleteReposOwnerRepoMilestonesNumber* = Call_DeleteReposOwnerRepoMilestonesNumber_779602(
    name: "deleteReposOwnerRepoMilestonesNumber", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones/{number}",
    validator: validate_DeleteReposOwnerRepoMilestonesNumber_779603, base: "/",
    url: url_DeleteReposOwnerRepoMilestonesNumber_779604, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoMilestonesNumberLabels_779626 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoMilestonesNumberLabels_779628(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoMilestonesNumberLabels_779627(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get labels for every issue in a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779629 = path.getOrDefault("repo")
  valid_779629 = validateParameter(valid_779629, JString, required = true,
                                 default = nil)
  if valid_779629 != nil:
    section.add "repo", valid_779629
  var valid_779630 = path.getOrDefault("number")
  valid_779630 = validateParameter(valid_779630, JInt, required = true, default = nil)
  if valid_779630 != nil:
    section.add "number", valid_779630
  var valid_779631 = path.getOrDefault("owner")
  valid_779631 = validateParameter(valid_779631, JString, required = true,
                                 default = nil)
  if valid_779631 != nil:
    section.add "owner", valid_779631
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779632 = header.getOrDefault("Accept")
  valid_779632 = validateParameter(valid_779632, JString, required = false,
                                 default = nil)
  if valid_779632 != nil:
    section.add "Accept", valid_779632
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779633: Call_GetReposOwnerRepoMilestonesNumberLabels_779626;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get labels for every issue in a milestone.
  ## 
  let valid = call_779633.validator(path, query, header, formData, body)
  let scheme = call_779633.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779633.url(scheme.get, call_779633.host, call_779633.base,
                         call_779633.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779633, url, valid)

proc call*(call_779634: Call_GetReposOwnerRepoMilestonesNumberLabels_779626;
          repo: string; number: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoMilestonesNumberLabels
  ## Get labels for every issue in a milestone.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779635 = newJObject()
  var header_779636 = newJObject()
  add(path_779635, "repo", newJString(repo))
  add(path_779635, "number", newJInt(number))
  add(path_779635, "owner", newJString(owner))
  add(header_779636, "Accept", newJString(Accept))
  result = call_779634.call(path_779635, nil, header_779636, nil, nil)

var getReposOwnerRepoMilestonesNumberLabels* = Call_GetReposOwnerRepoMilestonesNumberLabels_779626(
    name: "getReposOwnerRepoMilestonesNumberLabels", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/milestones/{number}/labels",
    validator: validate_GetReposOwnerRepoMilestonesNumberLabels_779627, base: "/",
    url: url_GetReposOwnerRepoMilestonesNumberLabels_779628,
    schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoNotifications_779651 = ref object of OpenApiRestCall_777573
proc url_PutReposOwnerRepoNotifications_779653(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/notifications")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoNotifications_779652(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Mark notifications as read in a repository.
  ## Marking all notifications in a repository as "read" removes them from the
  ## default view on GitHub.com.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779654 = path.getOrDefault("repo")
  valid_779654 = validateParameter(valid_779654, JString, required = true,
                                 default = nil)
  if valid_779654 != nil:
    section.add "repo", valid_779654
  var valid_779655 = path.getOrDefault("owner")
  valid_779655 = validateParameter(valid_779655, JString, required = true,
                                 default = nil)
  if valid_779655 != nil:
    section.add "owner", valid_779655
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779656 = header.getOrDefault("Accept")
  valid_779656 = validateParameter(valid_779656, JString, required = false,
                                 default = nil)
  if valid_779656 != nil:
    section.add "Accept", valid_779656
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_779658: Call_PutReposOwnerRepoNotifications_779651; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Mark notifications as read in a repository.
  ## Marking all notifications in a repository as "read" removes them from the
  ## default view on GitHub.com.
  ## 
  ## 
  let valid = call_779658.validator(path, query, header, formData, body)
  let scheme = call_779658.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779658.url(scheme.get, call_779658.host, call_779658.base,
                         call_779658.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779658, url, valid)

proc call*(call_779659: Call_PutReposOwnerRepoNotifications_779651; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## putReposOwnerRepoNotifications
  ## Mark notifications as read in a repository.
  ## Marking all notifications in a repository as "read" removes them from the
  ## default view on GitHub.com.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779660 = newJObject()
  var header_779661 = newJObject()
  var body_779662 = newJObject()
  add(path_779660, "repo", newJString(repo))
  add(path_779660, "owner", newJString(owner))
  if body != nil:
    body_779662 = body
  add(header_779661, "Accept", newJString(Accept))
  result = call_779659.call(path_779660, nil, header_779661, nil, body_779662)

var putReposOwnerRepoNotifications* = Call_PutReposOwnerRepoNotifications_779651(
    name: "putReposOwnerRepoNotifications", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/notifications",
    validator: validate_PutReposOwnerRepoNotifications_779652, base: "/",
    url: url_PutReposOwnerRepoNotifications_779653, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoNotifications_779637 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoNotifications_779639(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/notifications")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoNotifications_779638(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List your notifications in a repository
  ## List all notifications for the current user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779640 = path.getOrDefault("repo")
  valid_779640 = validateParameter(valid_779640, JString, required = true,
                                 default = nil)
  if valid_779640 != nil:
    section.add "repo", valid_779640
  var valid_779641 = path.getOrDefault("owner")
  valid_779641 = validateParameter(valid_779641, JString, required = true,
                                 default = nil)
  if valid_779641 != nil:
    section.add "owner", valid_779641
  result.add "path", section
  ## parameters in `query` object:
  ##   all: JBool
  ##      : True to show notifications marked as read.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   participating: JBool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  section = newJObject()
  var valid_779642 = query.getOrDefault("all")
  valid_779642 = validateParameter(valid_779642, JBool, required = false, default = nil)
  if valid_779642 != nil:
    section.add "all", valid_779642
  var valid_779643 = query.getOrDefault("since")
  valid_779643 = validateParameter(valid_779643, JString, required = false,
                                 default = nil)
  if valid_779643 != nil:
    section.add "since", valid_779643
  var valid_779644 = query.getOrDefault("participating")
  valid_779644 = validateParameter(valid_779644, JBool, required = false, default = nil)
  if valid_779644 != nil:
    section.add "participating", valid_779644
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779645 = header.getOrDefault("Accept")
  valid_779645 = validateParameter(valid_779645, JString, required = false,
                                 default = nil)
  if valid_779645 != nil:
    section.add "Accept", valid_779645
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779646: Call_GetReposOwnerRepoNotifications_779637; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List your notifications in a repository
  ## List all notifications for the current user.
  ## 
  ## 
  let valid = call_779646.validator(path, query, header, formData, body)
  let scheme = call_779646.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779646.url(scheme.get, call_779646.host, call_779646.base,
                         call_779646.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779646, url, valid)

proc call*(call_779647: Call_GetReposOwnerRepoNotifications_779637; repo: string;
          owner: string; all: bool = false; since: string = "";
          participating: bool = false; Accept: string = ""): Recallable =
  ## getReposOwnerRepoNotifications
  ## List your notifications in a repository
  ## List all notifications for the current user.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   all: bool
  ##      : True to show notifications marked as read.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   participating: bool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779648 = newJObject()
  var query_779649 = newJObject()
  var header_779650 = newJObject()
  add(path_779648, "repo", newJString(repo))
  add(query_779649, "all", newJBool(all))
  add(query_779649, "since", newJString(since))
  add(query_779649, "participating", newJBool(participating))
  add(path_779648, "owner", newJString(owner))
  add(header_779650, "Accept", newJString(Accept))
  result = call_779647.call(path_779648, query_779649, header_779650, nil, nil)

var getReposOwnerRepoNotifications* = Call_GetReposOwnerRepoNotifications_779637(
    name: "getReposOwnerRepoNotifications", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/notifications",
    validator: validate_GetReposOwnerRepoNotifications_779638, base: "/",
    url: url_GetReposOwnerRepoNotifications_779639, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoPulls_779677 = ref object of OpenApiRestCall_777573
proc url_PostReposOwnerRepoPulls_779679(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoPulls_779678(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779680 = path.getOrDefault("repo")
  valid_779680 = validateParameter(valid_779680, JString, required = true,
                                 default = nil)
  if valid_779680 != nil:
    section.add "repo", valid_779680
  var valid_779681 = path.getOrDefault("owner")
  valid_779681 = validateParameter(valid_779681, JString, required = true,
                                 default = nil)
  if valid_779681 != nil:
    section.add "owner", valid_779681
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779682 = header.getOrDefault("Accept")
  valid_779682 = validateParameter(valid_779682, JString, required = false,
                                 default = nil)
  if valid_779682 != nil:
    section.add "Accept", valid_779682
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_779684: Call_PostReposOwnerRepoPulls_779677; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a pull request.
  ## 
  let valid = call_779684.validator(path, query, header, formData, body)
  let scheme = call_779684.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779684.url(scheme.get, call_779684.host, call_779684.base,
                         call_779684.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779684, url, valid)

proc call*(call_779685: Call_PostReposOwnerRepoPulls_779677; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoPulls
  ## Create a pull request.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779686 = newJObject()
  var header_779687 = newJObject()
  var body_779688 = newJObject()
  add(path_779686, "repo", newJString(repo))
  add(path_779686, "owner", newJString(owner))
  if body != nil:
    body_779688 = body
  add(header_779687, "Accept", newJString(Accept))
  result = call_779685.call(path_779686, nil, header_779687, nil, body_779688)

var postReposOwnerRepoPulls* = Call_PostReposOwnerRepoPulls_779677(
    name: "postReposOwnerRepoPulls", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls",
    validator: validate_PostReposOwnerRepoPulls_779678, base: "/",
    url: url_PostReposOwnerRepoPulls_779679, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPulls_779663 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoPulls_779665(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPulls_779664(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List pull requests.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779666 = path.getOrDefault("repo")
  valid_779666 = validateParameter(valid_779666, JString, required = true,
                                 default = nil)
  if valid_779666 != nil:
    section.add "repo", valid_779666
  var valid_779667 = path.getOrDefault("owner")
  valid_779667 = validateParameter(valid_779667, JString, required = true,
                                 default = nil)
  if valid_779667 != nil:
    section.add "owner", valid_779667
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString
  ##        : String to filter by state.
  ##   head: JString
  ##       : Filter pulls by head user and branch name in the format of 'user:ref-name'.
  ## Example: github:new-script-format.
  ## 
  ##   base: JString
  ##       : Filter pulls by base branch name. Example - gh-pages.
  section = newJObject()
  var valid_779668 = query.getOrDefault("state")
  valid_779668 = validateParameter(valid_779668, JString, required = false,
                                 default = newJString("open"))
  if valid_779668 != nil:
    section.add "state", valid_779668
  var valid_779669 = query.getOrDefault("head")
  valid_779669 = validateParameter(valid_779669, JString, required = false,
                                 default = nil)
  if valid_779669 != nil:
    section.add "head", valid_779669
  var valid_779670 = query.getOrDefault("base")
  valid_779670 = validateParameter(valid_779670, JString, required = false,
                                 default = nil)
  if valid_779670 != nil:
    section.add "base", valid_779670
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779671 = header.getOrDefault("Accept")
  valid_779671 = validateParameter(valid_779671, JString, required = false,
                                 default = nil)
  if valid_779671 != nil:
    section.add "Accept", valid_779671
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779672: Call_GetReposOwnerRepoPulls_779663; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List pull requests.
  ## 
  let valid = call_779672.validator(path, query, header, formData, body)
  let scheme = call_779672.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779672.url(scheme.get, call_779672.host, call_779672.base,
                         call_779672.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779672, url, valid)

proc call*(call_779673: Call_GetReposOwnerRepoPulls_779663; repo: string;
          owner: string; state: string = "open"; head: string = ""; Accept: string = "";
          base: string = ""): Recallable =
  ## getReposOwnerRepoPulls
  ## List pull requests.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   state: string
  ##        : String to filter by state.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   head: string
  ##       : Filter pulls by head user and branch name in the format of 'user:ref-name'.
  ## Example: github:new-script-format.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   base: string
  ##       : Filter pulls by base branch name. Example - gh-pages.
  var path_779674 = newJObject()
  var query_779675 = newJObject()
  var header_779676 = newJObject()
  add(path_779674, "repo", newJString(repo))
  add(query_779675, "state", newJString(state))
  add(path_779674, "owner", newJString(owner))
  add(query_779675, "head", newJString(head))
  add(header_779676, "Accept", newJString(Accept))
  add(query_779675, "base", newJString(base))
  result = call_779673.call(path_779674, query_779675, header_779676, nil, nil)

var getReposOwnerRepoPulls* = Call_GetReposOwnerRepoPulls_779663(
    name: "getReposOwnerRepoPulls", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls",
    validator: validate_GetReposOwnerRepoPulls_779664, base: "/",
    url: url_GetReposOwnerRepoPulls_779665, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsComments_779689 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoPullsComments_779691(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsComments_779690(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List comments in a repository.
  ## By default, Review Comments are ordered by ascending ID.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779692 = path.getOrDefault("repo")
  valid_779692 = validateParameter(valid_779692, JString, required = true,
                                 default = nil)
  if valid_779692 != nil:
    section.add "repo", valid_779692
  var valid_779693 = path.getOrDefault("owner")
  valid_779693 = validateParameter(valid_779693, JString, required = true,
                                 default = nil)
  if valid_779693 != nil:
    section.add "owner", valid_779693
  result.add "path", section
  ## parameters in `query` object:
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   sort: JString
  section = newJObject()
  var valid_779694 = query.getOrDefault("direction")
  valid_779694 = validateParameter(valid_779694, JString, required = false,
                                 default = nil)
  if valid_779694 != nil:
    section.add "direction", valid_779694
  var valid_779695 = query.getOrDefault("since")
  valid_779695 = validateParameter(valid_779695, JString, required = false,
                                 default = nil)
  if valid_779695 != nil:
    section.add "since", valid_779695
  var valid_779696 = query.getOrDefault("sort")
  valid_779696 = validateParameter(valid_779696, JString, required = false,
                                 default = newJString("created"))
  if valid_779696 != nil:
    section.add "sort", valid_779696
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779697 = header.getOrDefault("Accept")
  valid_779697 = validateParameter(valid_779697, JString, required = false,
                                 default = nil)
  if valid_779697 != nil:
    section.add "Accept", valid_779697
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779698: Call_GetReposOwnerRepoPullsComments_779689; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List comments in a repository.
  ## By default, Review Comments are ordered by ascending ID.
  ## 
  ## 
  let valid = call_779698.validator(path, query, header, formData, body)
  let scheme = call_779698.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779698.url(scheme.get, call_779698.host, call_779698.base,
                         call_779698.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779698, url, valid)

proc call*(call_779699: Call_GetReposOwnerRepoPullsComments_779689; repo: string;
          owner: string; direction: string = ""; since: string = ""; Accept: string = "";
          sort: string = "created"): Recallable =
  ## getReposOwnerRepoPullsComments
  ## List comments in a repository.
  ## By default, Review Comments are ordered by ascending ID.
  ## 
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  var path_779700 = newJObject()
  var query_779701 = newJObject()
  var header_779702 = newJObject()
  add(query_779701, "direction", newJString(direction))
  add(path_779700, "repo", newJString(repo))
  add(query_779701, "since", newJString(since))
  add(path_779700, "owner", newJString(owner))
  add(header_779702, "Accept", newJString(Accept))
  add(query_779701, "sort", newJString(sort))
  result = call_779699.call(path_779700, query_779701, header_779702, nil, nil)

var getReposOwnerRepoPullsComments* = Call_GetReposOwnerRepoPullsComments_779689(
    name: "getReposOwnerRepoPullsComments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/comments",
    validator: validate_GetReposOwnerRepoPullsComments_779690, base: "/",
    url: url_GetReposOwnerRepoPullsComments_779691, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsCommentsCommentId_779703 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoPullsCommentsCommentId_779705(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsCommentsCommentId_779704(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779706 = path.getOrDefault("repo")
  valid_779706 = validateParameter(valid_779706, JString, required = true,
                                 default = nil)
  if valid_779706 != nil:
    section.add "repo", valid_779706
  var valid_779707 = path.getOrDefault("commentId")
  valid_779707 = validateParameter(valid_779707, JInt, required = true, default = nil)
  if valid_779707 != nil:
    section.add "commentId", valid_779707
  var valid_779708 = path.getOrDefault("owner")
  valid_779708 = validateParameter(valid_779708, JString, required = true,
                                 default = nil)
  if valid_779708 != nil:
    section.add "owner", valid_779708
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779709 = header.getOrDefault("Accept")
  valid_779709 = validateParameter(valid_779709, JString, required = false,
                                 default = nil)
  if valid_779709 != nil:
    section.add "Accept", valid_779709
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779710: Call_GetReposOwnerRepoPullsCommentsCommentId_779703;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single comment.
  ## 
  let valid = call_779710.validator(path, query, header, formData, body)
  let scheme = call_779710.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779710.url(scheme.get, call_779710.host, call_779710.base,
                         call_779710.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779710, url, valid)

proc call*(call_779711: Call_GetReposOwnerRepoPullsCommentsCommentId_779703;
          repo: string; commentId: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsCommentsCommentId
  ## Get a single comment.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779712 = newJObject()
  var header_779713 = newJObject()
  add(path_779712, "repo", newJString(repo))
  add(path_779712, "commentId", newJInt(commentId))
  add(path_779712, "owner", newJString(owner))
  add(header_779713, "Accept", newJString(Accept))
  result = call_779711.call(path_779712, nil, header_779713, nil, nil)

var getReposOwnerRepoPullsCommentsCommentId* = Call_GetReposOwnerRepoPullsCommentsCommentId_779703(
    name: "getReposOwnerRepoPullsCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/comments/{commentId}",
    validator: validate_GetReposOwnerRepoPullsCommentsCommentId_779704, base: "/",
    url: url_GetReposOwnerRepoPullsCommentsCommentId_779705,
    schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoPullsCommentsCommentId_779725 = ref object of OpenApiRestCall_777573
proc url_PatchReposOwnerRepoPullsCommentsCommentId_779727(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoPullsCommentsCommentId_779726(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Edit a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779728 = path.getOrDefault("repo")
  valid_779728 = validateParameter(valid_779728, JString, required = true,
                                 default = nil)
  if valid_779728 != nil:
    section.add "repo", valid_779728
  var valid_779729 = path.getOrDefault("commentId")
  valid_779729 = validateParameter(valid_779729, JInt, required = true, default = nil)
  if valid_779729 != nil:
    section.add "commentId", valid_779729
  var valid_779730 = path.getOrDefault("owner")
  valid_779730 = validateParameter(valid_779730, JString, required = true,
                                 default = nil)
  if valid_779730 != nil:
    section.add "owner", valid_779730
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779731 = header.getOrDefault("Accept")
  valid_779731 = validateParameter(valid_779731, JString, required = false,
                                 default = nil)
  if valid_779731 != nil:
    section.add "Accept", valid_779731
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_779733: Call_PatchReposOwnerRepoPullsCommentsCommentId_779725;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Edit a comment.
  ## 
  let valid = call_779733.validator(path, query, header, formData, body)
  let scheme = call_779733.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779733.url(scheme.get, call_779733.host, call_779733.base,
                         call_779733.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779733, url, valid)

proc call*(call_779734: Call_PatchReposOwnerRepoPullsCommentsCommentId_779725;
          repo: string; commentId: int; owner: string; body: JsonNode;
          Accept: string = ""): Recallable =
  ## patchReposOwnerRepoPullsCommentsCommentId
  ## Edit a comment.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779735 = newJObject()
  var header_779736 = newJObject()
  var body_779737 = newJObject()
  add(path_779735, "repo", newJString(repo))
  add(path_779735, "commentId", newJInt(commentId))
  add(path_779735, "owner", newJString(owner))
  if body != nil:
    body_779737 = body
  add(header_779736, "Accept", newJString(Accept))
  result = call_779734.call(path_779735, nil, header_779736, nil, body_779737)

var patchReposOwnerRepoPullsCommentsCommentId* = Call_PatchReposOwnerRepoPullsCommentsCommentId_779725(
    name: "patchReposOwnerRepoPullsCommentsCommentId", meth: HttpMethod.HttpPatch,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/comments/{commentId}",
    validator: validate_PatchReposOwnerRepoPullsCommentsCommentId_779726,
    base: "/", url: url_PatchReposOwnerRepoPullsCommentsCommentId_779727,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoPullsCommentsCommentId_779714 = ref object of OpenApiRestCall_777573
proc url_DeleteReposOwnerRepoPullsCommentsCommentId_779716(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoPullsCommentsCommentId_779715(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779717 = path.getOrDefault("repo")
  valid_779717 = validateParameter(valid_779717, JString, required = true,
                                 default = nil)
  if valid_779717 != nil:
    section.add "repo", valid_779717
  var valid_779718 = path.getOrDefault("commentId")
  valid_779718 = validateParameter(valid_779718, JInt, required = true, default = nil)
  if valid_779718 != nil:
    section.add "commentId", valid_779718
  var valid_779719 = path.getOrDefault("owner")
  valid_779719 = validateParameter(valid_779719, JString, required = true,
                                 default = nil)
  if valid_779719 != nil:
    section.add "owner", valid_779719
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779720 = header.getOrDefault("Accept")
  valid_779720 = validateParameter(valid_779720, JString, required = false,
                                 default = nil)
  if valid_779720 != nil:
    section.add "Accept", valid_779720
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779721: Call_DeleteReposOwnerRepoPullsCommentsCommentId_779714;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a comment.
  ## 
  let valid = call_779721.validator(path, query, header, formData, body)
  let scheme = call_779721.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779721.url(scheme.get, call_779721.host, call_779721.base,
                         call_779721.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779721, url, valid)

proc call*(call_779722: Call_DeleteReposOwnerRepoPullsCommentsCommentId_779714;
          repo: string; commentId: int; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoPullsCommentsCommentId
  ## Delete a comment.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779723 = newJObject()
  var header_779724 = newJObject()
  add(path_779723, "repo", newJString(repo))
  add(path_779723, "commentId", newJInt(commentId))
  add(path_779723, "owner", newJString(owner))
  add(header_779724, "Accept", newJString(Accept))
  result = call_779722.call(path_779723, nil, header_779724, nil, nil)

var deleteReposOwnerRepoPullsCommentsCommentId* = Call_DeleteReposOwnerRepoPullsCommentsCommentId_779714(
    name: "deleteReposOwnerRepoPullsCommentsCommentId",
    meth: HttpMethod.HttpDelete, host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/comments/{commentId}",
    validator: validate_DeleteReposOwnerRepoPullsCommentsCommentId_779715,
    base: "/", url: url_DeleteReposOwnerRepoPullsCommentsCommentId_779716,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumber_779738 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoPullsNumber_779740(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumber_779739(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779741 = path.getOrDefault("repo")
  valid_779741 = validateParameter(valid_779741, JString, required = true,
                                 default = nil)
  if valid_779741 != nil:
    section.add "repo", valid_779741
  var valid_779742 = path.getOrDefault("number")
  valid_779742 = validateParameter(valid_779742, JInt, required = true, default = nil)
  if valid_779742 != nil:
    section.add "number", valid_779742
  var valid_779743 = path.getOrDefault("owner")
  valid_779743 = validateParameter(valid_779743, JString, required = true,
                                 default = nil)
  if valid_779743 != nil:
    section.add "owner", valid_779743
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779744 = header.getOrDefault("Accept")
  valid_779744 = validateParameter(valid_779744, JString, required = false,
                                 default = nil)
  if valid_779744 != nil:
    section.add "Accept", valid_779744
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779745: Call_GetReposOwnerRepoPullsNumber_779738; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a single pull request.
  ## 
  let valid = call_779745.validator(path, query, header, formData, body)
  let scheme = call_779745.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779745.url(scheme.get, call_779745.host, call_779745.base,
                         call_779745.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779745, url, valid)

proc call*(call_779746: Call_GetReposOwnerRepoPullsNumber_779738; repo: string;
          number: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumber
  ## Get a single pull request.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Id of pull.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779747 = newJObject()
  var header_779748 = newJObject()
  add(path_779747, "repo", newJString(repo))
  add(path_779747, "number", newJInt(number))
  add(path_779747, "owner", newJString(owner))
  add(header_779748, "Accept", newJString(Accept))
  result = call_779746.call(path_779747, nil, header_779748, nil, nil)

var getReposOwnerRepoPullsNumber* = Call_GetReposOwnerRepoPullsNumber_779738(
    name: "getReposOwnerRepoPullsNumber", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}",
    validator: validate_GetReposOwnerRepoPullsNumber_779739, base: "/",
    url: url_GetReposOwnerRepoPullsNumber_779740, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoPullsNumber_779749 = ref object of OpenApiRestCall_777573
proc url_PatchReposOwnerRepoPullsNumber_779751(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoPullsNumber_779750(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Update a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779752 = path.getOrDefault("repo")
  valid_779752 = validateParameter(valid_779752, JString, required = true,
                                 default = nil)
  if valid_779752 != nil:
    section.add "repo", valid_779752
  var valid_779753 = path.getOrDefault("number")
  valid_779753 = validateParameter(valid_779753, JInt, required = true, default = nil)
  if valid_779753 != nil:
    section.add "number", valid_779753
  var valid_779754 = path.getOrDefault("owner")
  valid_779754 = validateParameter(valid_779754, JString, required = true,
                                 default = nil)
  if valid_779754 != nil:
    section.add "owner", valid_779754
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779755 = header.getOrDefault("Accept")
  valid_779755 = validateParameter(valid_779755, JString, required = false,
                                 default = nil)
  if valid_779755 != nil:
    section.add "Accept", valid_779755
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_779757: Call_PatchReposOwnerRepoPullsNumber_779749; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Update a pull request.
  ## 
  let valid = call_779757.validator(path, query, header, formData, body)
  let scheme = call_779757.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779757.url(scheme.get, call_779757.host, call_779757.base,
                         call_779757.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779757, url, valid)

proc call*(call_779758: Call_PatchReposOwnerRepoPullsNumber_779749; repo: string;
          number: int; owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoPullsNumber
  ## Update a pull request.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Id of pull.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779759 = newJObject()
  var header_779760 = newJObject()
  var body_779761 = newJObject()
  add(path_779759, "repo", newJString(repo))
  add(path_779759, "number", newJInt(number))
  add(path_779759, "owner", newJString(owner))
  if body != nil:
    body_779761 = body
  add(header_779760, "Accept", newJString(Accept))
  result = call_779758.call(path_779759, nil, header_779760, nil, body_779761)

var patchReposOwnerRepoPullsNumber* = Call_PatchReposOwnerRepoPullsNumber_779749(
    name: "patchReposOwnerRepoPullsNumber", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}",
    validator: validate_PatchReposOwnerRepoPullsNumber_779750, base: "/",
    url: url_PatchReposOwnerRepoPullsNumber_779751, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoPullsNumberComments_779773 = ref object of OpenApiRestCall_777573
proc url_PostReposOwnerRepoPullsNumberComments_779775(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoPullsNumberComments_779774(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a comment.
  ##   #TODO Alternative input ( http://developer.github.com/v3/pulls/comments/ )
  ##   description: |
  ##     Alternative Input.
  ##     Instead of passing commit_id, path, and position you can reply to an
  ##     existing Pull Request Comment like this:
  ## 
  ##         body
  ##            Required string
  ##         in_reply_to
  ##            Required number - Comment id to reply to.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779776 = path.getOrDefault("repo")
  valid_779776 = validateParameter(valid_779776, JString, required = true,
                                 default = nil)
  if valid_779776 != nil:
    section.add "repo", valid_779776
  var valid_779777 = path.getOrDefault("number")
  valid_779777 = validateParameter(valid_779777, JInt, required = true, default = nil)
  if valid_779777 != nil:
    section.add "number", valid_779777
  var valid_779778 = path.getOrDefault("owner")
  valid_779778 = validateParameter(valid_779778, JString, required = true,
                                 default = nil)
  if valid_779778 != nil:
    section.add "owner", valid_779778
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779779 = header.getOrDefault("Accept")
  valid_779779 = validateParameter(valid_779779, JString, required = false,
                                 default = nil)
  if valid_779779 != nil:
    section.add "Accept", valid_779779
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_779781: Call_PostReposOwnerRepoPullsNumberComments_779773;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Create a comment.
  ##   #TODO Alternative input ( http://developer.github.com/v3/pulls/comments/ )
  ##   description: |
  ##     Alternative Input.
  ##     Instead of passing commit_id, path, and position you can reply to an
  ##     existing Pull Request Comment like this:
  ## 
  ##         body
  ##            Required string
  ##         in_reply_to
  ##            Required number - Comment id to reply to.
  ## 
  ## 
  let valid = call_779781.validator(path, query, header, formData, body)
  let scheme = call_779781.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779781.url(scheme.get, call_779781.host, call_779781.base,
                         call_779781.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779781, url, valid)

proc call*(call_779782: Call_PostReposOwnerRepoPullsNumberComments_779773;
          repo: string; number: int; owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoPullsNumberComments
  ## Create a comment.
  ##   #TODO Alternative input ( http://developer.github.com/v3/pulls/comments/ )
  ##   description: |
  ##     Alternative Input.
  ##     Instead of passing commit_id, path, and position you can reply to an
  ##     existing Pull Request Comment like this:
  ## 
  ##         body
  ##            Required string
  ##         in_reply_to
  ##            Required number - Comment id to reply to.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Id of pull.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779783 = newJObject()
  var header_779784 = newJObject()
  var body_779785 = newJObject()
  add(path_779783, "repo", newJString(repo))
  add(path_779783, "number", newJInt(number))
  add(path_779783, "owner", newJString(owner))
  if body != nil:
    body_779785 = body
  add(header_779784, "Accept", newJString(Accept))
  result = call_779782.call(path_779783, nil, header_779784, nil, body_779785)

var postReposOwnerRepoPullsNumberComments* = Call_PostReposOwnerRepoPullsNumberComments_779773(
    name: "postReposOwnerRepoPullsNumberComments", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/{number}/comments",
    validator: validate_PostReposOwnerRepoPullsNumberComments_779774, base: "/",
    url: url_PostReposOwnerRepoPullsNumberComments_779775, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberComments_779762 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoPullsNumberComments_779764(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberComments_779763(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List comments on a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779765 = path.getOrDefault("repo")
  valid_779765 = validateParameter(valid_779765, JString, required = true,
                                 default = nil)
  if valid_779765 != nil:
    section.add "repo", valid_779765
  var valid_779766 = path.getOrDefault("number")
  valid_779766 = validateParameter(valid_779766, JInt, required = true, default = nil)
  if valid_779766 != nil:
    section.add "number", valid_779766
  var valid_779767 = path.getOrDefault("owner")
  valid_779767 = validateParameter(valid_779767, JString, required = true,
                                 default = nil)
  if valid_779767 != nil:
    section.add "owner", valid_779767
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779768 = header.getOrDefault("Accept")
  valid_779768 = validateParameter(valid_779768, JString, required = false,
                                 default = nil)
  if valid_779768 != nil:
    section.add "Accept", valid_779768
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779769: Call_GetReposOwnerRepoPullsNumberComments_779762;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List comments on a pull request.
  ## 
  let valid = call_779769.validator(path, query, header, formData, body)
  let scheme = call_779769.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779769.url(scheme.get, call_779769.host, call_779769.base,
                         call_779769.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779769, url, valid)

proc call*(call_779770: Call_GetReposOwnerRepoPullsNumberComments_779762;
          repo: string; number: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberComments
  ## List comments on a pull request.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Id of pull.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779771 = newJObject()
  var header_779772 = newJObject()
  add(path_779771, "repo", newJString(repo))
  add(path_779771, "number", newJInt(number))
  add(path_779771, "owner", newJString(owner))
  add(header_779772, "Accept", newJString(Accept))
  result = call_779770.call(path_779771, nil, header_779772, nil, nil)

var getReposOwnerRepoPullsNumberComments* = Call_GetReposOwnerRepoPullsNumberComments_779762(
    name: "getReposOwnerRepoPullsNumberComments", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/{number}/comments",
    validator: validate_GetReposOwnerRepoPullsNumberComments_779763, base: "/",
    url: url_GetReposOwnerRepoPullsNumberComments_779764, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberCommits_779786 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoPullsNumberCommits_779788(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/commits")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberCommits_779787(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List commits on a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779789 = path.getOrDefault("repo")
  valid_779789 = validateParameter(valid_779789, JString, required = true,
                                 default = nil)
  if valid_779789 != nil:
    section.add "repo", valid_779789
  var valid_779790 = path.getOrDefault("number")
  valid_779790 = validateParameter(valid_779790, JInt, required = true, default = nil)
  if valid_779790 != nil:
    section.add "number", valid_779790
  var valid_779791 = path.getOrDefault("owner")
  valid_779791 = validateParameter(valid_779791, JString, required = true,
                                 default = nil)
  if valid_779791 != nil:
    section.add "owner", valid_779791
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779792 = header.getOrDefault("Accept")
  valid_779792 = validateParameter(valid_779792, JString, required = false,
                                 default = nil)
  if valid_779792 != nil:
    section.add "Accept", valid_779792
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779793: Call_GetReposOwnerRepoPullsNumberCommits_779786;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List commits on a pull request.
  ## 
  let valid = call_779793.validator(path, query, header, formData, body)
  let scheme = call_779793.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779793.url(scheme.get, call_779793.host, call_779793.base,
                         call_779793.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779793, url, valid)

proc call*(call_779794: Call_GetReposOwnerRepoPullsNumberCommits_779786;
          repo: string; number: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberCommits
  ## List commits on a pull request.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Id of pull.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779795 = newJObject()
  var header_779796 = newJObject()
  add(path_779795, "repo", newJString(repo))
  add(path_779795, "number", newJInt(number))
  add(path_779795, "owner", newJString(owner))
  add(header_779796, "Accept", newJString(Accept))
  result = call_779794.call(path_779795, nil, header_779796, nil, nil)

var getReposOwnerRepoPullsNumberCommits* = Call_GetReposOwnerRepoPullsNumberCommits_779786(
    name: "getReposOwnerRepoPullsNumberCommits", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/commits",
    validator: validate_GetReposOwnerRepoPullsNumberCommits_779787, base: "/",
    url: url_GetReposOwnerRepoPullsNumberCommits_779788, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberFiles_779797 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoPullsNumberFiles_779799(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/files")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberFiles_779798(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List pull requests files.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779800 = path.getOrDefault("repo")
  valid_779800 = validateParameter(valid_779800, JString, required = true,
                                 default = nil)
  if valid_779800 != nil:
    section.add "repo", valid_779800
  var valid_779801 = path.getOrDefault("number")
  valid_779801 = validateParameter(valid_779801, JInt, required = true, default = nil)
  if valid_779801 != nil:
    section.add "number", valid_779801
  var valid_779802 = path.getOrDefault("owner")
  valid_779802 = validateParameter(valid_779802, JString, required = true,
                                 default = nil)
  if valid_779802 != nil:
    section.add "owner", valid_779802
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779803 = header.getOrDefault("Accept")
  valid_779803 = validateParameter(valid_779803, JString, required = false,
                                 default = nil)
  if valid_779803 != nil:
    section.add "Accept", valid_779803
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779804: Call_GetReposOwnerRepoPullsNumberFiles_779797;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List pull requests files.
  ## 
  let valid = call_779804.validator(path, query, header, formData, body)
  let scheme = call_779804.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779804.url(scheme.get, call_779804.host, call_779804.base,
                         call_779804.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779804, url, valid)

proc call*(call_779805: Call_GetReposOwnerRepoPullsNumberFiles_779797;
          repo: string; number: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberFiles
  ## List pull requests files.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Id of pull.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779806 = newJObject()
  var header_779807 = newJObject()
  add(path_779806, "repo", newJString(repo))
  add(path_779806, "number", newJInt(number))
  add(path_779806, "owner", newJString(owner))
  add(header_779807, "Accept", newJString(Accept))
  result = call_779805.call(path_779806, nil, header_779807, nil, nil)

var getReposOwnerRepoPullsNumberFiles* = Call_GetReposOwnerRepoPullsNumberFiles_779797(
    name: "getReposOwnerRepoPullsNumberFiles", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/files",
    validator: validate_GetReposOwnerRepoPullsNumberFiles_779798, base: "/",
    url: url_GetReposOwnerRepoPullsNumberFiles_779799, schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoPullsNumberMerge_779819 = ref object of OpenApiRestCall_777573
proc url_PutReposOwnerRepoPullsNumberMerge_779821(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/merge")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoPullsNumberMerge_779820(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Merge a pull request (Merge Button's)
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779822 = path.getOrDefault("repo")
  valid_779822 = validateParameter(valid_779822, JString, required = true,
                                 default = nil)
  if valid_779822 != nil:
    section.add "repo", valid_779822
  var valid_779823 = path.getOrDefault("number")
  valid_779823 = validateParameter(valid_779823, JInt, required = true, default = nil)
  if valid_779823 != nil:
    section.add "number", valid_779823
  var valid_779824 = path.getOrDefault("owner")
  valid_779824 = validateParameter(valid_779824, JString, required = true,
                                 default = nil)
  if valid_779824 != nil:
    section.add "owner", valid_779824
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779825 = header.getOrDefault("Accept")
  valid_779825 = validateParameter(valid_779825, JString, required = false,
                                 default = nil)
  if valid_779825 != nil:
    section.add "Accept", valid_779825
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_779827: Call_PutReposOwnerRepoPullsNumberMerge_779819;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Merge a pull request (Merge Button's)
  ## 
  let valid = call_779827.validator(path, query, header, formData, body)
  let scheme = call_779827.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779827.url(scheme.get, call_779827.host, call_779827.base,
                         call_779827.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779827, url, valid)

proc call*(call_779828: Call_PutReposOwnerRepoPullsNumberMerge_779819;
          repo: string; number: int; owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## putReposOwnerRepoPullsNumberMerge
  ## Merge a pull request (Merge Button's)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Id of pull.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779829 = newJObject()
  var header_779830 = newJObject()
  var body_779831 = newJObject()
  add(path_779829, "repo", newJString(repo))
  add(path_779829, "number", newJInt(number))
  add(path_779829, "owner", newJString(owner))
  if body != nil:
    body_779831 = body
  add(header_779830, "Accept", newJString(Accept))
  result = call_779828.call(path_779829, nil, header_779830, nil, body_779831)

var putReposOwnerRepoPullsNumberMerge* = Call_PutReposOwnerRepoPullsNumberMerge_779819(
    name: "putReposOwnerRepoPullsNumberMerge", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/merge",
    validator: validate_PutReposOwnerRepoPullsNumberMerge_779820, base: "/",
    url: url_PutReposOwnerRepoPullsNumberMerge_779821, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberMerge_779808 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoPullsNumberMerge_779810(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/merge")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberMerge_779809(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get if a pull request has been merged.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779811 = path.getOrDefault("repo")
  valid_779811 = validateParameter(valid_779811, JString, required = true,
                                 default = nil)
  if valid_779811 != nil:
    section.add "repo", valid_779811
  var valid_779812 = path.getOrDefault("number")
  valid_779812 = validateParameter(valid_779812, JInt, required = true, default = nil)
  if valid_779812 != nil:
    section.add "number", valid_779812
  var valid_779813 = path.getOrDefault("owner")
  valid_779813 = validateParameter(valid_779813, JString, required = true,
                                 default = nil)
  if valid_779813 != nil:
    section.add "owner", valid_779813
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779814 = header.getOrDefault("Accept")
  valid_779814 = validateParameter(valid_779814, JString, required = false,
                                 default = nil)
  if valid_779814 != nil:
    section.add "Accept", valid_779814
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779815: Call_GetReposOwnerRepoPullsNumberMerge_779808;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get if a pull request has been merged.
  ## 
  let valid = call_779815.validator(path, query, header, formData, body)
  let scheme = call_779815.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779815.url(scheme.get, call_779815.host, call_779815.base,
                         call_779815.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779815, url, valid)

proc call*(call_779816: Call_GetReposOwnerRepoPullsNumberMerge_779808;
          repo: string; number: int; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberMerge
  ## Get if a pull request has been merged.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   number: int (required)
  ##         : Id of pull.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779817 = newJObject()
  var header_779818 = newJObject()
  add(path_779817, "repo", newJString(repo))
  add(path_779817, "number", newJInt(number))
  add(path_779817, "owner", newJString(owner))
  add(header_779818, "Accept", newJString(Accept))
  result = call_779816.call(path_779817, nil, header_779818, nil, nil)

var getReposOwnerRepoPullsNumberMerge* = Call_GetReposOwnerRepoPullsNumberMerge_779808(
    name: "getReposOwnerRepoPullsNumberMerge", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/merge",
    validator: validate_GetReposOwnerRepoPullsNumberMerge_779809, base: "/",
    url: url_GetReposOwnerRepoPullsNumberMerge_779810, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReadme_779832 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoReadme_779834(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/readme")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReadme_779833(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the README.
  ## This method returns the preferred README for a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779835 = path.getOrDefault("repo")
  valid_779835 = validateParameter(valid_779835, JString, required = true,
                                 default = nil)
  if valid_779835 != nil:
    section.add "repo", valid_779835
  var valid_779836 = path.getOrDefault("owner")
  valid_779836 = validateParameter(valid_779836, JString, required = true,
                                 default = nil)
  if valid_779836 != nil:
    section.add "owner", valid_779836
  result.add "path", section
  ## parameters in `query` object:
  ##   ref: JString
  ##      : The String name of the Commit/Branch/Tag. Defaults to master.
  section = newJObject()
  var valid_779837 = query.getOrDefault("ref")
  valid_779837 = validateParameter(valid_779837, JString, required = false,
                                 default = nil)
  if valid_779837 != nil:
    section.add "ref", valid_779837
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779838 = header.getOrDefault("Accept")
  valid_779838 = validateParameter(valid_779838, JString, required = false,
                                 default = nil)
  if valid_779838 != nil:
    section.add "Accept", valid_779838
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779839: Call_GetReposOwnerRepoReadme_779832; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get the README.
  ## This method returns the preferred README for a repository.
  ## 
  ## 
  let valid = call_779839.validator(path, query, header, formData, body)
  let scheme = call_779839.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779839.url(scheme.get, call_779839.host, call_779839.base,
                         call_779839.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779839, url, valid)

proc call*(call_779840: Call_GetReposOwnerRepoReadme_779832; repo: string;
          owner: string; Accept: string = ""; `ref`: string = ""): Recallable =
  ## getReposOwnerRepoReadme
  ## Get the README.
  ## This method returns the preferred README for a repository.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   ref: string
  ##      : The String name of the Commit/Branch/Tag. Defaults to master.
  var path_779841 = newJObject()
  var query_779842 = newJObject()
  var header_779843 = newJObject()
  add(path_779841, "repo", newJString(repo))
  add(path_779841, "owner", newJString(owner))
  add(header_779843, "Accept", newJString(Accept))
  add(query_779842, "ref", newJString(`ref`))
  result = call_779840.call(path_779841, query_779842, header_779843, nil, nil)

var getReposOwnerRepoReadme* = Call_GetReposOwnerRepoReadme_779832(
    name: "getReposOwnerRepoReadme", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/readme",
    validator: validate_GetReposOwnerRepoReadme_779833, base: "/",
    url: url_GetReposOwnerRepoReadme_779834, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoReleases_779854 = ref object of OpenApiRestCall_777573
proc url_PostReposOwnerRepoReleases_779856(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoReleases_779855(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a release
  ## Users with push access to the repository can create a release.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779857 = path.getOrDefault("repo")
  valid_779857 = validateParameter(valid_779857, JString, required = true,
                                 default = nil)
  if valid_779857 != nil:
    section.add "repo", valid_779857
  var valid_779858 = path.getOrDefault("owner")
  valid_779858 = validateParameter(valid_779858, JString, required = true,
                                 default = nil)
  if valid_779858 != nil:
    section.add "owner", valid_779858
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779859 = header.getOrDefault("Accept")
  valid_779859 = validateParameter(valid_779859, JString, required = false,
                                 default = nil)
  if valid_779859 != nil:
    section.add "Accept", valid_779859
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_779861: Call_PostReposOwnerRepoReleases_779854; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a release
  ## Users with push access to the repository can create a release.
  ## 
  ## 
  let valid = call_779861.validator(path, query, header, formData, body)
  let scheme = call_779861.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779861.url(scheme.get, call_779861.host, call_779861.base,
                         call_779861.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779861, url, valid)

proc call*(call_779862: Call_PostReposOwnerRepoReleases_779854; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoReleases
  ## Create a release
  ## Users with push access to the repository can create a release.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779863 = newJObject()
  var header_779864 = newJObject()
  var body_779865 = newJObject()
  add(path_779863, "repo", newJString(repo))
  add(path_779863, "owner", newJString(owner))
  if body != nil:
    body_779865 = body
  add(header_779864, "Accept", newJString(Accept))
  result = call_779862.call(path_779863, nil, header_779864, nil, body_779865)

var postReposOwnerRepoReleases* = Call_PostReposOwnerRepoReleases_779854(
    name: "postReposOwnerRepoReleases", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases",
    validator: validate_PostReposOwnerRepoReleases_779855, base: "/",
    url: url_PostReposOwnerRepoReleases_779856, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleases_779844 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoReleases_779846(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleases_779845(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Users with push access to the repository will receive all releases (i.e., published releases and draft releases). Users with pull access will receive published releases only
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779847 = path.getOrDefault("repo")
  valid_779847 = validateParameter(valid_779847, JString, required = true,
                                 default = nil)
  if valid_779847 != nil:
    section.add "repo", valid_779847
  var valid_779848 = path.getOrDefault("owner")
  valid_779848 = validateParameter(valid_779848, JString, required = true,
                                 default = nil)
  if valid_779848 != nil:
    section.add "owner", valid_779848
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779849 = header.getOrDefault("Accept")
  valid_779849 = validateParameter(valid_779849, JString, required = false,
                                 default = nil)
  if valid_779849 != nil:
    section.add "Accept", valid_779849
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779850: Call_GetReposOwnerRepoReleases_779844; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Users with push access to the repository will receive all releases (i.e., published releases and draft releases). Users with pull access will receive published releases only
  ## 
  let valid = call_779850.validator(path, query, header, formData, body)
  let scheme = call_779850.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779850.url(scheme.get, call_779850.host, call_779850.base,
                         call_779850.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779850, url, valid)

proc call*(call_779851: Call_GetReposOwnerRepoReleases_779844; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleases
  ## Users with push access to the repository will receive all releases (i.e., published releases and draft releases). Users with pull access will receive published releases only
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779852 = newJObject()
  var header_779853 = newJObject()
  add(path_779852, "repo", newJString(repo))
  add(path_779852, "owner", newJString(owner))
  add(header_779853, "Accept", newJString(Accept))
  result = call_779851.call(path_779852, nil, header_779853, nil, nil)

var getReposOwnerRepoReleases* = Call_GetReposOwnerRepoReleases_779844(
    name: "getReposOwnerRepoReleases", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases",
    validator: validate_GetReposOwnerRepoReleases_779845, base: "/",
    url: url_GetReposOwnerRepoReleases_779846, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleasesAssetsId_779866 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoReleasesAssetsId_779868(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/assets/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleasesAssetsId_779867(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single release asset
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   id: JString (required)
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779869 = path.getOrDefault("repo")
  valid_779869 = validateParameter(valid_779869, JString, required = true,
                                 default = nil)
  if valid_779869 != nil:
    section.add "repo", valid_779869
  var valid_779870 = path.getOrDefault("id")
  valid_779870 = validateParameter(valid_779870, JString, required = true,
                                 default = nil)
  if valid_779870 != nil:
    section.add "id", valid_779870
  var valid_779871 = path.getOrDefault("owner")
  valid_779871 = validateParameter(valid_779871, JString, required = true,
                                 default = nil)
  if valid_779871 != nil:
    section.add "owner", valid_779871
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779872 = header.getOrDefault("Accept")
  valid_779872 = validateParameter(valid_779872, JString, required = false,
                                 default = nil)
  if valid_779872 != nil:
    section.add "Accept", valid_779872
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779873: Call_GetReposOwnerRepoReleasesAssetsId_779866;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get a single release asset
  ## 
  let valid = call_779873.validator(path, query, header, formData, body)
  let scheme = call_779873.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779873.url(scheme.get, call_779873.host, call_779873.base,
                         call_779873.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779873, url, valid)

proc call*(call_779874: Call_GetReposOwnerRepoReleasesAssetsId_779866;
          repo: string; id: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleasesAssetsId
  ## Get a single release asset
  ##   repo: string (required)
  ##       : Name of repository.
  ##   id: string (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779875 = newJObject()
  var header_779876 = newJObject()
  add(path_779875, "repo", newJString(repo))
  add(path_779875, "id", newJString(id))
  add(path_779875, "owner", newJString(owner))
  add(header_779876, "Accept", newJString(Accept))
  result = call_779874.call(path_779875, nil, header_779876, nil, nil)

var getReposOwnerRepoReleasesAssetsId* = Call_GetReposOwnerRepoReleasesAssetsId_779866(
    name: "getReposOwnerRepoReleasesAssetsId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/assets/{id}",
    validator: validate_GetReposOwnerRepoReleasesAssetsId_779867, base: "/",
    url: url_GetReposOwnerRepoReleasesAssetsId_779868, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoReleasesAssetsId_779888 = ref object of OpenApiRestCall_777573
proc url_PatchReposOwnerRepoReleasesAssetsId_779890(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/assets/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoReleasesAssetsId_779889(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Edit a release asset
  ## Users with push access to the repository can edit a release asset.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   id: JString (required)
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779891 = path.getOrDefault("repo")
  valid_779891 = validateParameter(valid_779891, JString, required = true,
                                 default = nil)
  if valid_779891 != nil:
    section.add "repo", valid_779891
  var valid_779892 = path.getOrDefault("id")
  valid_779892 = validateParameter(valid_779892, JString, required = true,
                                 default = nil)
  if valid_779892 != nil:
    section.add "id", valid_779892
  var valid_779893 = path.getOrDefault("owner")
  valid_779893 = validateParameter(valid_779893, JString, required = true,
                                 default = nil)
  if valid_779893 != nil:
    section.add "owner", valid_779893
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779894 = header.getOrDefault("Accept")
  valid_779894 = validateParameter(valid_779894, JString, required = false,
                                 default = nil)
  if valid_779894 != nil:
    section.add "Accept", valid_779894
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_779896: Call_PatchReposOwnerRepoReleasesAssetsId_779888;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Edit a release asset
  ## Users with push access to the repository can edit a release asset.
  ## 
  ## 
  let valid = call_779896.validator(path, query, header, formData, body)
  let scheme = call_779896.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779896.url(scheme.get, call_779896.host, call_779896.base,
                         call_779896.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779896, url, valid)

proc call*(call_779897: Call_PatchReposOwnerRepoReleasesAssetsId_779888;
          repo: string; id: string; owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoReleasesAssetsId
  ## Edit a release asset
  ## Users with push access to the repository can edit a release asset.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   id: string (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779898 = newJObject()
  var header_779899 = newJObject()
  var body_779900 = newJObject()
  add(path_779898, "repo", newJString(repo))
  add(path_779898, "id", newJString(id))
  add(path_779898, "owner", newJString(owner))
  if body != nil:
    body_779900 = body
  add(header_779899, "Accept", newJString(Accept))
  result = call_779897.call(path_779898, nil, header_779899, nil, body_779900)

var patchReposOwnerRepoReleasesAssetsId* = Call_PatchReposOwnerRepoReleasesAssetsId_779888(
    name: "patchReposOwnerRepoReleasesAssetsId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/assets/{id}",
    validator: validate_PatchReposOwnerRepoReleasesAssetsId_779889, base: "/",
    url: url_PatchReposOwnerRepoReleasesAssetsId_779890, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoReleasesAssetsId_779877 = ref object of OpenApiRestCall_777573
proc url_DeleteReposOwnerRepoReleasesAssetsId_779879(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/assets/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoReleasesAssetsId_779878(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a release asset
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   id: JString (required)
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779880 = path.getOrDefault("repo")
  valid_779880 = validateParameter(valid_779880, JString, required = true,
                                 default = nil)
  if valid_779880 != nil:
    section.add "repo", valid_779880
  var valid_779881 = path.getOrDefault("id")
  valid_779881 = validateParameter(valid_779881, JString, required = true,
                                 default = nil)
  if valid_779881 != nil:
    section.add "id", valid_779881
  var valid_779882 = path.getOrDefault("owner")
  valid_779882 = validateParameter(valid_779882, JString, required = true,
                                 default = nil)
  if valid_779882 != nil:
    section.add "owner", valid_779882
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779883 = header.getOrDefault("Accept")
  valid_779883 = validateParameter(valid_779883, JString, required = false,
                                 default = nil)
  if valid_779883 != nil:
    section.add "Accept", valid_779883
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779884: Call_DeleteReposOwnerRepoReleasesAssetsId_779877;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a release asset
  ## 
  let valid = call_779884.validator(path, query, header, formData, body)
  let scheme = call_779884.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779884.url(scheme.get, call_779884.host, call_779884.base,
                         call_779884.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779884, url, valid)

proc call*(call_779885: Call_DeleteReposOwnerRepoReleasesAssetsId_779877;
          repo: string; id: string; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoReleasesAssetsId
  ## Delete a release asset
  ##   repo: string (required)
  ##       : Name of repository.
  ##   id: string (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779886 = newJObject()
  var header_779887 = newJObject()
  add(path_779886, "repo", newJString(repo))
  add(path_779886, "id", newJString(id))
  add(path_779886, "owner", newJString(owner))
  add(header_779887, "Accept", newJString(Accept))
  result = call_779885.call(path_779886, nil, header_779887, nil, nil)

var deleteReposOwnerRepoReleasesAssetsId* = Call_DeleteReposOwnerRepoReleasesAssetsId_779877(
    name: "deleteReposOwnerRepoReleasesAssetsId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/assets/{id}",
    validator: validate_DeleteReposOwnerRepoReleasesAssetsId_779878, base: "/",
    url: url_DeleteReposOwnerRepoReleasesAssetsId_779879, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleasesId_779901 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoReleasesId_779903(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleasesId_779902(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a single release
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   id: JString (required)
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779904 = path.getOrDefault("repo")
  valid_779904 = validateParameter(valid_779904, JString, required = true,
                                 default = nil)
  if valid_779904 != nil:
    section.add "repo", valid_779904
  var valid_779905 = path.getOrDefault("id")
  valid_779905 = validateParameter(valid_779905, JString, required = true,
                                 default = nil)
  if valid_779905 != nil:
    section.add "id", valid_779905
  var valid_779906 = path.getOrDefault("owner")
  valid_779906 = validateParameter(valid_779906, JString, required = true,
                                 default = nil)
  if valid_779906 != nil:
    section.add "owner", valid_779906
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779907 = header.getOrDefault("Accept")
  valid_779907 = validateParameter(valid_779907, JString, required = false,
                                 default = nil)
  if valid_779907 != nil:
    section.add "Accept", valid_779907
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779908: Call_GetReposOwnerRepoReleasesId_779901; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a single release
  ## 
  let valid = call_779908.validator(path, query, header, formData, body)
  let scheme = call_779908.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779908.url(scheme.get, call_779908.host, call_779908.base,
                         call_779908.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779908, url, valid)

proc call*(call_779909: Call_GetReposOwnerRepoReleasesId_779901; repo: string;
          id: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleasesId
  ## Get a single release
  ##   repo: string (required)
  ##       : Name of repository.
  ##   id: string (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779910 = newJObject()
  var header_779911 = newJObject()
  add(path_779910, "repo", newJString(repo))
  add(path_779910, "id", newJString(id))
  add(path_779910, "owner", newJString(owner))
  add(header_779911, "Accept", newJString(Accept))
  result = call_779909.call(path_779910, nil, header_779911, nil, nil)

var getReposOwnerRepoReleasesId* = Call_GetReposOwnerRepoReleasesId_779901(
    name: "getReposOwnerRepoReleasesId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}",
    validator: validate_GetReposOwnerRepoReleasesId_779902, base: "/",
    url: url_GetReposOwnerRepoReleasesId_779903, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoReleasesId_779923 = ref object of OpenApiRestCall_777573
proc url_PatchReposOwnerRepoReleasesId_779925(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoReleasesId_779924(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Users with push access to the repository can edit a release
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   id: JString (required)
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779926 = path.getOrDefault("repo")
  valid_779926 = validateParameter(valid_779926, JString, required = true,
                                 default = nil)
  if valid_779926 != nil:
    section.add "repo", valid_779926
  var valid_779927 = path.getOrDefault("id")
  valid_779927 = validateParameter(valid_779927, JString, required = true,
                                 default = nil)
  if valid_779927 != nil:
    section.add "id", valid_779927
  var valid_779928 = path.getOrDefault("owner")
  valid_779928 = validateParameter(valid_779928, JString, required = true,
                                 default = nil)
  if valid_779928 != nil:
    section.add "owner", valid_779928
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779929 = header.getOrDefault("Accept")
  valid_779929 = validateParameter(valid_779929, JString, required = false,
                                 default = nil)
  if valid_779929 != nil:
    section.add "Accept", valid_779929
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_779931: Call_PatchReposOwnerRepoReleasesId_779923; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Users with push access to the repository can edit a release
  ## 
  let valid = call_779931.validator(path, query, header, formData, body)
  let scheme = call_779931.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779931.url(scheme.get, call_779931.host, call_779931.base,
                         call_779931.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779931, url, valid)

proc call*(call_779932: Call_PatchReposOwnerRepoReleasesId_779923; repo: string;
          id: string; owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoReleasesId
  ## Users with push access to the repository can edit a release
  ##   repo: string (required)
  ##       : Name of repository.
  ##   id: string (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779933 = newJObject()
  var header_779934 = newJObject()
  var body_779935 = newJObject()
  add(path_779933, "repo", newJString(repo))
  add(path_779933, "id", newJString(id))
  add(path_779933, "owner", newJString(owner))
  if body != nil:
    body_779935 = body
  add(header_779934, "Accept", newJString(Accept))
  result = call_779932.call(path_779933, nil, header_779934, nil, body_779935)

var patchReposOwnerRepoReleasesId* = Call_PatchReposOwnerRepoReleasesId_779923(
    name: "patchReposOwnerRepoReleasesId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}",
    validator: validate_PatchReposOwnerRepoReleasesId_779924, base: "/",
    url: url_PatchReposOwnerRepoReleasesId_779925, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoReleasesId_779912 = ref object of OpenApiRestCall_777573
proc url_DeleteReposOwnerRepoReleasesId_779914(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoReleasesId_779913(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Users with push access to the repository can delete a release.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   id: JString (required)
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779915 = path.getOrDefault("repo")
  valid_779915 = validateParameter(valid_779915, JString, required = true,
                                 default = nil)
  if valid_779915 != nil:
    section.add "repo", valid_779915
  var valid_779916 = path.getOrDefault("id")
  valid_779916 = validateParameter(valid_779916, JString, required = true,
                                 default = nil)
  if valid_779916 != nil:
    section.add "id", valid_779916
  var valid_779917 = path.getOrDefault("owner")
  valid_779917 = validateParameter(valid_779917, JString, required = true,
                                 default = nil)
  if valid_779917 != nil:
    section.add "owner", valid_779917
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779918 = header.getOrDefault("Accept")
  valid_779918 = validateParameter(valid_779918, JString, required = false,
                                 default = nil)
  if valid_779918 != nil:
    section.add "Accept", valid_779918
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779919: Call_DeleteReposOwnerRepoReleasesId_779912; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Users with push access to the repository can delete a release.
  ## 
  let valid = call_779919.validator(path, query, header, formData, body)
  let scheme = call_779919.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779919.url(scheme.get, call_779919.host, call_779919.base,
                         call_779919.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779919, url, valid)

proc call*(call_779920: Call_DeleteReposOwnerRepoReleasesId_779912; repo: string;
          id: string; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoReleasesId
  ## Users with push access to the repository can delete a release.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   id: string (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779921 = newJObject()
  var header_779922 = newJObject()
  add(path_779921, "repo", newJString(repo))
  add(path_779921, "id", newJString(id))
  add(path_779921, "owner", newJString(owner))
  add(header_779922, "Accept", newJString(Accept))
  result = call_779920.call(path_779921, nil, header_779922, nil, nil)

var deleteReposOwnerRepoReleasesId* = Call_DeleteReposOwnerRepoReleasesId_779912(
    name: "deleteReposOwnerRepoReleasesId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}",
    validator: validate_DeleteReposOwnerRepoReleasesId_779913, base: "/",
    url: url_DeleteReposOwnerRepoReleasesId_779914, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleasesIdAssets_779936 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoReleasesIdAssets_779938(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/assets")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleasesIdAssets_779937(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List assets for a release
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   id: JString (required)
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779939 = path.getOrDefault("repo")
  valid_779939 = validateParameter(valid_779939, JString, required = true,
                                 default = nil)
  if valid_779939 != nil:
    section.add "repo", valid_779939
  var valid_779940 = path.getOrDefault("id")
  valid_779940 = validateParameter(valid_779940, JString, required = true,
                                 default = nil)
  if valid_779940 != nil:
    section.add "id", valid_779940
  var valid_779941 = path.getOrDefault("owner")
  valid_779941 = validateParameter(valid_779941, JString, required = true,
                                 default = nil)
  if valid_779941 != nil:
    section.add "owner", valid_779941
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779942 = header.getOrDefault("Accept")
  valid_779942 = validateParameter(valid_779942, JString, required = false,
                                 default = nil)
  if valid_779942 != nil:
    section.add "Accept", valid_779942
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779943: Call_GetReposOwnerRepoReleasesIdAssets_779936;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List assets for a release
  ## 
  let valid = call_779943.validator(path, query, header, formData, body)
  let scheme = call_779943.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779943.url(scheme.get, call_779943.host, call_779943.base,
                         call_779943.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779943, url, valid)

proc call*(call_779944: Call_GetReposOwnerRepoReleasesIdAssets_779936;
          repo: string; id: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleasesIdAssets
  ## List assets for a release
  ##   repo: string (required)
  ##       : Name of repository.
  ##   id: string (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779945 = newJObject()
  var header_779946 = newJObject()
  add(path_779945, "repo", newJString(repo))
  add(path_779945, "id", newJString(id))
  add(path_779945, "owner", newJString(owner))
  add(header_779946, "Accept", newJString(Accept))
  result = call_779944.call(path_779945, nil, header_779946, nil, nil)

var getReposOwnerRepoReleasesIdAssets* = Call_GetReposOwnerRepoReleasesIdAssets_779936(
    name: "getReposOwnerRepoReleasesIdAssets", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}/assets",
    validator: validate_GetReposOwnerRepoReleasesIdAssets_779937, base: "/",
    url: url_GetReposOwnerRepoReleasesIdAssets_779938, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStargazers_779947 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoStargazers_779949(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stargazers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStargazers_779948(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List Stargazers.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779950 = path.getOrDefault("repo")
  valid_779950 = validateParameter(valid_779950, JString, required = true,
                                 default = nil)
  if valid_779950 != nil:
    section.add "repo", valid_779950
  var valid_779951 = path.getOrDefault("owner")
  valid_779951 = validateParameter(valid_779951, JString, required = true,
                                 default = nil)
  if valid_779951 != nil:
    section.add "owner", valid_779951
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779952 = header.getOrDefault("Accept")
  valid_779952 = validateParameter(valid_779952, JString, required = false,
                                 default = nil)
  if valid_779952 != nil:
    section.add "Accept", valid_779952
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779953: Call_GetReposOwnerRepoStargazers_779947; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List Stargazers.
  ## 
  let valid = call_779953.validator(path, query, header, formData, body)
  let scheme = call_779953.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779953.url(scheme.get, call_779953.host, call_779953.base,
                         call_779953.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779953, url, valid)

proc call*(call_779954: Call_GetReposOwnerRepoStargazers_779947; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStargazers
  ## List Stargazers.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779955 = newJObject()
  var header_779956 = newJObject()
  add(path_779955, "repo", newJString(repo))
  add(path_779955, "owner", newJString(owner))
  add(header_779956, "Accept", newJString(Accept))
  result = call_779954.call(path_779955, nil, header_779956, nil, nil)

var getReposOwnerRepoStargazers* = Call_GetReposOwnerRepoStargazers_779947(
    name: "getReposOwnerRepoStargazers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stargazers",
    validator: validate_GetReposOwnerRepoStargazers_779948, base: "/",
    url: url_GetReposOwnerRepoStargazers_779949, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsCodeFrequency_779957 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoStatsCodeFrequency_779959(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/code_frequency")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsCodeFrequency_779958(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the number of additions and deletions per week.
  ## Returns a weekly aggregate of the number of additions and deletions pushed
  ## to a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779960 = path.getOrDefault("repo")
  valid_779960 = validateParameter(valid_779960, JString, required = true,
                                 default = nil)
  if valid_779960 != nil:
    section.add "repo", valid_779960
  var valid_779961 = path.getOrDefault("owner")
  valid_779961 = validateParameter(valid_779961, JString, required = true,
                                 default = nil)
  if valid_779961 != nil:
    section.add "owner", valid_779961
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779962 = header.getOrDefault("Accept")
  valid_779962 = validateParameter(valid_779962, JString, required = false,
                                 default = nil)
  if valid_779962 != nil:
    section.add "Accept", valid_779962
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779963: Call_GetReposOwnerRepoStatsCodeFrequency_779957;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get the number of additions and deletions per week.
  ## Returns a weekly aggregate of the number of additions and deletions pushed
  ## to a repository.
  ## 
  ## 
  let valid = call_779963.validator(path, query, header, formData, body)
  let scheme = call_779963.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779963.url(scheme.get, call_779963.host, call_779963.base,
                         call_779963.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779963, url, valid)

proc call*(call_779964: Call_GetReposOwnerRepoStatsCodeFrequency_779957;
          repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsCodeFrequency
  ## Get the number of additions and deletions per week.
  ## Returns a weekly aggregate of the number of additions and deletions pushed
  ## to a repository.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779965 = newJObject()
  var header_779966 = newJObject()
  add(path_779965, "repo", newJString(repo))
  add(path_779965, "owner", newJString(owner))
  add(header_779966, "Accept", newJString(Accept))
  result = call_779964.call(path_779965, nil, header_779966, nil, nil)

var getReposOwnerRepoStatsCodeFrequency* = Call_GetReposOwnerRepoStatsCodeFrequency_779957(
    name: "getReposOwnerRepoStatsCodeFrequency", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/code_frequency",
    validator: validate_GetReposOwnerRepoStatsCodeFrequency_779958, base: "/",
    url: url_GetReposOwnerRepoStatsCodeFrequency_779959, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsCommitActivity_779967 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoStatsCommitActivity_779969(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/commit_activity")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsCommitActivity_779968(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the last year of commit activity data.
  ## Returns the last year of commit activity grouped by week. The days array
  ## is a group of commits per day, starting on Sunday.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779970 = path.getOrDefault("repo")
  valid_779970 = validateParameter(valid_779970, JString, required = true,
                                 default = nil)
  if valid_779970 != nil:
    section.add "repo", valid_779970
  var valid_779971 = path.getOrDefault("owner")
  valid_779971 = validateParameter(valid_779971, JString, required = true,
                                 default = nil)
  if valid_779971 != nil:
    section.add "owner", valid_779971
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779972 = header.getOrDefault("Accept")
  valid_779972 = validateParameter(valid_779972, JString, required = false,
                                 default = nil)
  if valid_779972 != nil:
    section.add "Accept", valid_779972
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779973: Call_GetReposOwnerRepoStatsCommitActivity_779967;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get the last year of commit activity data.
  ## Returns the last year of commit activity grouped by week. The days array
  ## is a group of commits per day, starting on Sunday.
  ## 
  ## 
  let valid = call_779973.validator(path, query, header, formData, body)
  let scheme = call_779973.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779973.url(scheme.get, call_779973.host, call_779973.base,
                         call_779973.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779973, url, valid)

proc call*(call_779974: Call_GetReposOwnerRepoStatsCommitActivity_779967;
          repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsCommitActivity
  ## Get the last year of commit activity data.
  ## Returns the last year of commit activity grouped by week. The days array
  ## is a group of commits per day, starting on Sunday.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779975 = newJObject()
  var header_779976 = newJObject()
  add(path_779975, "repo", newJString(repo))
  add(path_779975, "owner", newJString(owner))
  add(header_779976, "Accept", newJString(Accept))
  result = call_779974.call(path_779975, nil, header_779976, nil, nil)

var getReposOwnerRepoStatsCommitActivity* = Call_GetReposOwnerRepoStatsCommitActivity_779967(
    name: "getReposOwnerRepoStatsCommitActivity", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/commit_activity",
    validator: validate_GetReposOwnerRepoStatsCommitActivity_779968, base: "/",
    url: url_GetReposOwnerRepoStatsCommitActivity_779969, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsContributors_779977 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoStatsContributors_779979(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/contributors")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsContributors_779978(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get contributors list with additions, deletions, and commit counts.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779980 = path.getOrDefault("repo")
  valid_779980 = validateParameter(valid_779980, JString, required = true,
                                 default = nil)
  if valid_779980 != nil:
    section.add "repo", valid_779980
  var valid_779981 = path.getOrDefault("owner")
  valid_779981 = validateParameter(valid_779981, JString, required = true,
                                 default = nil)
  if valid_779981 != nil:
    section.add "owner", valid_779981
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779982 = header.getOrDefault("Accept")
  valid_779982 = validateParameter(valid_779982, JString, required = false,
                                 default = nil)
  if valid_779982 != nil:
    section.add "Accept", valid_779982
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779983: Call_GetReposOwnerRepoStatsContributors_779977;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get contributors list with additions, deletions, and commit counts.
  ## 
  let valid = call_779983.validator(path, query, header, formData, body)
  let scheme = call_779983.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779983.url(scheme.get, call_779983.host, call_779983.base,
                         call_779983.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779983, url, valid)

proc call*(call_779984: Call_GetReposOwnerRepoStatsContributors_779977;
          repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsContributors
  ## Get contributors list with additions, deletions, and commit counts.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779985 = newJObject()
  var header_779986 = newJObject()
  add(path_779985, "repo", newJString(repo))
  add(path_779985, "owner", newJString(owner))
  add(header_779986, "Accept", newJString(Accept))
  result = call_779984.call(path_779985, nil, header_779986, nil, nil)

var getReposOwnerRepoStatsContributors* = Call_GetReposOwnerRepoStatsContributors_779977(
    name: "getReposOwnerRepoStatsContributors", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/contributors",
    validator: validate_GetReposOwnerRepoStatsContributors_779978, base: "/",
    url: url_GetReposOwnerRepoStatsContributors_779979, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsParticipation_779987 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoStatsParticipation_779989(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/participation")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsParticipation_779988(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the weekly commit count for the repo owner and everyone else.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_779990 = path.getOrDefault("repo")
  valid_779990 = validateParameter(valid_779990, JString, required = true,
                                 default = nil)
  if valid_779990 != nil:
    section.add "repo", valid_779990
  var valid_779991 = path.getOrDefault("owner")
  valid_779991 = validateParameter(valid_779991, JString, required = true,
                                 default = nil)
  if valid_779991 != nil:
    section.add "owner", valid_779991
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_779992 = header.getOrDefault("Accept")
  valid_779992 = validateParameter(valid_779992, JString, required = false,
                                 default = nil)
  if valid_779992 != nil:
    section.add "Accept", valid_779992
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_779993: Call_GetReposOwnerRepoStatsParticipation_779987;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get the weekly commit count for the repo owner and everyone else.
  ## 
  let valid = call_779993.validator(path, query, header, formData, body)
  let scheme = call_779993.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_779993.url(scheme.get, call_779993.host, call_779993.base,
                         call_779993.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_779993, url, valid)

proc call*(call_779994: Call_GetReposOwnerRepoStatsParticipation_779987;
          repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsParticipation
  ## Get the weekly commit count for the repo owner and everyone else.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_779995 = newJObject()
  var header_779996 = newJObject()
  add(path_779995, "repo", newJString(repo))
  add(path_779995, "owner", newJString(owner))
  add(header_779996, "Accept", newJString(Accept))
  result = call_779994.call(path_779995, nil, header_779996, nil, nil)

var getReposOwnerRepoStatsParticipation* = Call_GetReposOwnerRepoStatsParticipation_779987(
    name: "getReposOwnerRepoStatsParticipation", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/participation",
    validator: validate_GetReposOwnerRepoStatsParticipation_779988, base: "/",
    url: url_GetReposOwnerRepoStatsParticipation_779989, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsPunchCard_779997 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoStatsPunchCard_779999(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/punch_card")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsPunchCard_779998(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the number of commits per hour in each day.
  ## Each array contains the day number, hour number, and number of commits
  ## 0-6 Sunday - Saturday
  ## 0-23 Hour of day
  ## Number of commits
  ## 
  ## For example, [2, 14, 25] indicates that there were 25 total commits, during
  ## the 2.00pm hour on Tuesdays. All times are based on the time zone of
  ## individual commits.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_780000 = path.getOrDefault("repo")
  valid_780000 = validateParameter(valid_780000, JString, required = true,
                                 default = nil)
  if valid_780000 != nil:
    section.add "repo", valid_780000
  var valid_780001 = path.getOrDefault("owner")
  valid_780001 = validateParameter(valid_780001, JString, required = true,
                                 default = nil)
  if valid_780001 != nil:
    section.add "owner", valid_780001
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780002 = header.getOrDefault("Accept")
  valid_780002 = validateParameter(valid_780002, JString, required = false,
                                 default = nil)
  if valid_780002 != nil:
    section.add "Accept", valid_780002
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780003: Call_GetReposOwnerRepoStatsPunchCard_779997;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get the number of commits per hour in each day.
  ## Each array contains the day number, hour number, and number of commits
  ## 0-6 Sunday - Saturday
  ## 0-23 Hour of day
  ## Number of commits
  ## 
  ## For example, [2, 14, 25] indicates that there were 25 total commits, during
  ## the 2.00pm hour on Tuesdays. All times are based on the time zone of
  ## individual commits.
  ## 
  ## 
  let valid = call_780003.validator(path, query, header, formData, body)
  let scheme = call_780003.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780003.url(scheme.get, call_780003.host, call_780003.base,
                         call_780003.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780003, url, valid)

proc call*(call_780004: Call_GetReposOwnerRepoStatsPunchCard_779997; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsPunchCard
  ## Get the number of commits per hour in each day.
  ## Each array contains the day number, hour number, and number of commits
  ## 0-6 Sunday - Saturday
  ## 0-23 Hour of day
  ## Number of commits
  ## 
  ## For example, [2, 14, 25] indicates that there were 25 total commits, during
  ## the 2.00pm hour on Tuesdays. All times are based on the time zone of
  ## individual commits.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780005 = newJObject()
  var header_780006 = newJObject()
  add(path_780005, "repo", newJString(repo))
  add(path_780005, "owner", newJString(owner))
  add(header_780006, "Accept", newJString(Accept))
  result = call_780004.call(path_780005, nil, header_780006, nil, nil)

var getReposOwnerRepoStatsPunchCard* = Call_GetReposOwnerRepoStatsPunchCard_779997(
    name: "getReposOwnerRepoStatsPunchCard", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/punch_card",
    validator: validate_GetReposOwnerRepoStatsPunchCard_779998, base: "/",
    url: url_GetReposOwnerRepoStatsPunchCard_779999, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoStatusesRef_780018 = ref object of OpenApiRestCall_777573
proc url_PostReposOwnerRepoStatusesRef_780020(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/statuses/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoStatusesRef_780019(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a Status.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   ref: JString (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_780021 = path.getOrDefault("repo")
  valid_780021 = validateParameter(valid_780021, JString, required = true,
                                 default = nil)
  if valid_780021 != nil:
    section.add "repo", valid_780021
  var valid_780022 = path.getOrDefault("ref")
  valid_780022 = validateParameter(valid_780022, JString, required = true,
                                 default = nil)
  if valid_780022 != nil:
    section.add "ref", valid_780022
  var valid_780023 = path.getOrDefault("owner")
  valid_780023 = validateParameter(valid_780023, JString, required = true,
                                 default = nil)
  if valid_780023 != nil:
    section.add "owner", valid_780023
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780024 = header.getOrDefault("Accept")
  valid_780024 = validateParameter(valid_780024, JString, required = false,
                                 default = nil)
  if valid_780024 != nil:
    section.add "Accept", valid_780024
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_780026: Call_PostReposOwnerRepoStatusesRef_780018; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a Status.
  ## 
  let valid = call_780026.validator(path, query, header, formData, body)
  let scheme = call_780026.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780026.url(scheme.get, call_780026.host, call_780026.base,
                         call_780026.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780026, url, valid)

proc call*(call_780027: Call_PostReposOwnerRepoStatusesRef_780018; repo: string;
          `ref`: string; owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## postReposOwnerRepoStatusesRef
  ## Create a Status.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   ref: string (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780028 = newJObject()
  var header_780029 = newJObject()
  var body_780030 = newJObject()
  add(path_780028, "repo", newJString(repo))
  add(path_780028, "ref", newJString(`ref`))
  add(path_780028, "owner", newJString(owner))
  if body != nil:
    body_780030 = body
  add(header_780029, "Accept", newJString(Accept))
  result = call_780027.call(path_780028, nil, header_780029, nil, body_780030)

var postReposOwnerRepoStatusesRef* = Call_PostReposOwnerRepoStatusesRef_780018(
    name: "postReposOwnerRepoStatusesRef", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/statuses/{ref}",
    validator: validate_PostReposOwnerRepoStatusesRef_780019, base: "/",
    url: url_PostReposOwnerRepoStatusesRef_780020, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatusesRef_780007 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoStatusesRef_780009(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/statuses/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatusesRef_780008(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List Statuses for a specific Ref.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   ref: JString (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_780010 = path.getOrDefault("repo")
  valid_780010 = validateParameter(valid_780010, JString, required = true,
                                 default = nil)
  if valid_780010 != nil:
    section.add "repo", valid_780010
  var valid_780011 = path.getOrDefault("ref")
  valid_780011 = validateParameter(valid_780011, JString, required = true,
                                 default = nil)
  if valid_780011 != nil:
    section.add "ref", valid_780011
  var valid_780012 = path.getOrDefault("owner")
  valid_780012 = validateParameter(valid_780012, JString, required = true,
                                 default = nil)
  if valid_780012 != nil:
    section.add "owner", valid_780012
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780013 = header.getOrDefault("Accept")
  valid_780013 = validateParameter(valid_780013, JString, required = false,
                                 default = nil)
  if valid_780013 != nil:
    section.add "Accept", valid_780013
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780014: Call_GetReposOwnerRepoStatusesRef_780007; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List Statuses for a specific Ref.
  ## 
  let valid = call_780014.validator(path, query, header, formData, body)
  let scheme = call_780014.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780014.url(scheme.get, call_780014.host, call_780014.base,
                         call_780014.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780014, url, valid)

proc call*(call_780015: Call_GetReposOwnerRepoStatusesRef_780007; repo: string;
          `ref`: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatusesRef
  ## List Statuses for a specific Ref.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   ref: string (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780016 = newJObject()
  var header_780017 = newJObject()
  add(path_780016, "repo", newJString(repo))
  add(path_780016, "ref", newJString(`ref`))
  add(path_780016, "owner", newJString(owner))
  add(header_780017, "Accept", newJString(Accept))
  result = call_780015.call(path_780016, nil, header_780017, nil, nil)

var getReposOwnerRepoStatusesRef* = Call_GetReposOwnerRepoStatusesRef_780007(
    name: "getReposOwnerRepoStatusesRef", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/statuses/{ref}",
    validator: validate_GetReposOwnerRepoStatusesRef_780008, base: "/",
    url: url_GetReposOwnerRepoStatusesRef_780009, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoSubscribers_780031 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoSubscribers_780033(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/subscribers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoSubscribers_780032(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List watchers.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_780034 = path.getOrDefault("repo")
  valid_780034 = validateParameter(valid_780034, JString, required = true,
                                 default = nil)
  if valid_780034 != nil:
    section.add "repo", valid_780034
  var valid_780035 = path.getOrDefault("owner")
  valid_780035 = validateParameter(valid_780035, JString, required = true,
                                 default = nil)
  if valid_780035 != nil:
    section.add "owner", valid_780035
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780036 = header.getOrDefault("Accept")
  valid_780036 = validateParameter(valid_780036, JString, required = false,
                                 default = nil)
  if valid_780036 != nil:
    section.add "Accept", valid_780036
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780037: Call_GetReposOwnerRepoSubscribers_780031; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List watchers.
  ## 
  let valid = call_780037.validator(path, query, header, formData, body)
  let scheme = call_780037.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780037.url(scheme.get, call_780037.host, call_780037.base,
                         call_780037.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780037, url, valid)

proc call*(call_780038: Call_GetReposOwnerRepoSubscribers_780031; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoSubscribers
  ## List watchers.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780039 = newJObject()
  var header_780040 = newJObject()
  add(path_780039, "repo", newJString(repo))
  add(path_780039, "owner", newJString(owner))
  add(header_780040, "Accept", newJString(Accept))
  result = call_780038.call(path_780039, nil, header_780040, nil, nil)

var getReposOwnerRepoSubscribers* = Call_GetReposOwnerRepoSubscribers_780031(
    name: "getReposOwnerRepoSubscribers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscribers",
    validator: validate_GetReposOwnerRepoSubscribers_780032, base: "/",
    url: url_GetReposOwnerRepoSubscribers_780033, schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoSubscription_780051 = ref object of OpenApiRestCall_777573
proc url_PutReposOwnerRepoSubscription_780053(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoSubscription_780052(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Set a Repository Subscription
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_780054 = path.getOrDefault("repo")
  valid_780054 = validateParameter(valid_780054, JString, required = true,
                                 default = nil)
  if valid_780054 != nil:
    section.add "repo", valid_780054
  var valid_780055 = path.getOrDefault("owner")
  valid_780055 = validateParameter(valid_780055, JString, required = true,
                                 default = nil)
  if valid_780055 != nil:
    section.add "owner", valid_780055
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780056 = header.getOrDefault("Accept")
  valid_780056 = validateParameter(valid_780056, JString, required = false,
                                 default = nil)
  if valid_780056 != nil:
    section.add "Accept", valid_780056
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_780058: Call_PutReposOwnerRepoSubscription_780051; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Set a Repository Subscription
  ## 
  let valid = call_780058.validator(path, query, header, formData, body)
  let scheme = call_780058.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780058.url(scheme.get, call_780058.host, call_780058.base,
                         call_780058.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780058, url, valid)

proc call*(call_780059: Call_PutReposOwnerRepoSubscription_780051; repo: string;
          owner: string; body: JsonNode; Accept: string = ""): Recallable =
  ## putReposOwnerRepoSubscription
  ## Set a Repository Subscription
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780060 = newJObject()
  var header_780061 = newJObject()
  var body_780062 = newJObject()
  add(path_780060, "repo", newJString(repo))
  add(path_780060, "owner", newJString(owner))
  if body != nil:
    body_780062 = body
  add(header_780061, "Accept", newJString(Accept))
  result = call_780059.call(path_780060, nil, header_780061, nil, body_780062)

var putReposOwnerRepoSubscription* = Call_PutReposOwnerRepoSubscription_780051(
    name: "putReposOwnerRepoSubscription", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscription",
    validator: validate_PutReposOwnerRepoSubscription_780052, base: "/",
    url: url_PutReposOwnerRepoSubscription_780053, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoSubscription_780041 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoSubscription_780043(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoSubscription_780042(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get a Repository Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_780044 = path.getOrDefault("repo")
  valid_780044 = validateParameter(valid_780044, JString, required = true,
                                 default = nil)
  if valid_780044 != nil:
    section.add "repo", valid_780044
  var valid_780045 = path.getOrDefault("owner")
  valid_780045 = validateParameter(valid_780045, JString, required = true,
                                 default = nil)
  if valid_780045 != nil:
    section.add "owner", valid_780045
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780046 = header.getOrDefault("Accept")
  valid_780046 = validateParameter(valid_780046, JString, required = false,
                                 default = nil)
  if valid_780046 != nil:
    section.add "Accept", valid_780046
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780047: Call_GetReposOwnerRepoSubscription_780041; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a Repository Subscription.
  ## 
  let valid = call_780047.validator(path, query, header, formData, body)
  let scheme = call_780047.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780047.url(scheme.get, call_780047.host, call_780047.base,
                         call_780047.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780047, url, valid)

proc call*(call_780048: Call_GetReposOwnerRepoSubscription_780041; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoSubscription
  ## Get a Repository Subscription.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780049 = newJObject()
  var header_780050 = newJObject()
  add(path_780049, "repo", newJString(repo))
  add(path_780049, "owner", newJString(owner))
  add(header_780050, "Accept", newJString(Accept))
  result = call_780048.call(path_780049, nil, header_780050, nil, nil)

var getReposOwnerRepoSubscription* = Call_GetReposOwnerRepoSubscription_780041(
    name: "getReposOwnerRepoSubscription", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscription",
    validator: validate_GetReposOwnerRepoSubscription_780042, base: "/",
    url: url_GetReposOwnerRepoSubscription_780043, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoSubscription_780063 = ref object of OpenApiRestCall_777573
proc url_DeleteReposOwnerRepoSubscription_780065(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoSubscription_780064(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Delete a Repository Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_780066 = path.getOrDefault("repo")
  valid_780066 = validateParameter(valid_780066, JString, required = true,
                                 default = nil)
  if valid_780066 != nil:
    section.add "repo", valid_780066
  var valid_780067 = path.getOrDefault("owner")
  valid_780067 = validateParameter(valid_780067, JString, required = true,
                                 default = nil)
  if valid_780067 != nil:
    section.add "owner", valid_780067
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780068 = header.getOrDefault("Accept")
  valid_780068 = validateParameter(valid_780068, JString, required = false,
                                 default = nil)
  if valid_780068 != nil:
    section.add "Accept", valid_780068
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780069: Call_DeleteReposOwnerRepoSubscription_780063;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Delete a Repository Subscription.
  ## 
  let valid = call_780069.validator(path, query, header, formData, body)
  let scheme = call_780069.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780069.url(scheme.get, call_780069.host, call_780069.base,
                         call_780069.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780069, url, valid)

proc call*(call_780070: Call_DeleteReposOwnerRepoSubscription_780063; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoSubscription
  ## Delete a Repository Subscription.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780071 = newJObject()
  var header_780072 = newJObject()
  add(path_780071, "repo", newJString(repo))
  add(path_780071, "owner", newJString(owner))
  add(header_780072, "Accept", newJString(Accept))
  result = call_780070.call(path_780071, nil, header_780072, nil, nil)

var deleteReposOwnerRepoSubscription* = Call_DeleteReposOwnerRepoSubscription_780063(
    name: "deleteReposOwnerRepoSubscription", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscription",
    validator: validate_DeleteReposOwnerRepoSubscription_780064, base: "/",
    url: url_DeleteReposOwnerRepoSubscription_780065, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoTags_780073 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoTags_780075(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/tags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoTags_780074(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get list of tags.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_780076 = path.getOrDefault("repo")
  valid_780076 = validateParameter(valid_780076, JString, required = true,
                                 default = nil)
  if valid_780076 != nil:
    section.add "repo", valid_780076
  var valid_780077 = path.getOrDefault("owner")
  valid_780077 = validateParameter(valid_780077, JString, required = true,
                                 default = nil)
  if valid_780077 != nil:
    section.add "owner", valid_780077
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780078 = header.getOrDefault("Accept")
  valid_780078 = validateParameter(valid_780078, JString, required = false,
                                 default = nil)
  if valid_780078 != nil:
    section.add "Accept", valid_780078
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780079: Call_GetReposOwnerRepoTags_780073; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get list of tags.
  ## 
  let valid = call_780079.validator(path, query, header, formData, body)
  let scheme = call_780079.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780079.url(scheme.get, call_780079.host, call_780079.base,
                         call_780079.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780079, url, valid)

proc call*(call_780080: Call_GetReposOwnerRepoTags_780073; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoTags
  ## Get list of tags.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780081 = newJObject()
  var header_780082 = newJObject()
  add(path_780081, "repo", newJString(repo))
  add(path_780081, "owner", newJString(owner))
  add(header_780082, "Accept", newJString(Accept))
  result = call_780080.call(path_780081, nil, header_780082, nil, nil)

var getReposOwnerRepoTags* = Call_GetReposOwnerRepoTags_780073(
    name: "getReposOwnerRepoTags", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/repos/{owner}/{repo}/tags",
    validator: validate_GetReposOwnerRepoTags_780074, base: "/",
    url: url_GetReposOwnerRepoTags_780075, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoTeams_780083 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoTeams_780085(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/teams")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoTeams_780084(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get list of teams
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_780086 = path.getOrDefault("repo")
  valid_780086 = validateParameter(valid_780086, JString, required = true,
                                 default = nil)
  if valid_780086 != nil:
    section.add "repo", valid_780086
  var valid_780087 = path.getOrDefault("owner")
  valid_780087 = validateParameter(valid_780087, JString, required = true,
                                 default = nil)
  if valid_780087 != nil:
    section.add "owner", valid_780087
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780088 = header.getOrDefault("Accept")
  valid_780088 = validateParameter(valid_780088, JString, required = false,
                                 default = nil)
  if valid_780088 != nil:
    section.add "Accept", valid_780088
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780089: Call_GetReposOwnerRepoTeams_780083; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get list of teams
  ## 
  let valid = call_780089.validator(path, query, header, formData, body)
  let scheme = call_780089.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780089.url(scheme.get, call_780089.host, call_780089.base,
                         call_780089.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780089, url, valid)

proc call*(call_780090: Call_GetReposOwnerRepoTeams_780083; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoTeams
  ## Get list of teams
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780091 = newJObject()
  var header_780092 = newJObject()
  add(path_780091, "repo", newJString(repo))
  add(path_780091, "owner", newJString(owner))
  add(header_780092, "Accept", newJString(Accept))
  result = call_780090.call(path_780091, nil, header_780092, nil, nil)

var getReposOwnerRepoTeams* = Call_GetReposOwnerRepoTeams_780083(
    name: "getReposOwnerRepoTeams", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/teams",
    validator: validate_GetReposOwnerRepoTeams_780084, base: "/",
    url: url_GetReposOwnerRepoTeams_780085, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoWatchers_780093 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoWatchers_780095(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/watchers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoWatchers_780094(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List Stargazers. New implementation.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_780096 = path.getOrDefault("repo")
  valid_780096 = validateParameter(valid_780096, JString, required = true,
                                 default = nil)
  if valid_780096 != nil:
    section.add "repo", valid_780096
  var valid_780097 = path.getOrDefault("owner")
  valid_780097 = validateParameter(valid_780097, JString, required = true,
                                 default = nil)
  if valid_780097 != nil:
    section.add "owner", valid_780097
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780098 = header.getOrDefault("Accept")
  valid_780098 = validateParameter(valid_780098, JString, required = false,
                                 default = nil)
  if valid_780098 != nil:
    section.add "Accept", valid_780098
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780099: Call_GetReposOwnerRepoWatchers_780093; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List Stargazers. New implementation.
  ## 
  let valid = call_780099.validator(path, query, header, formData, body)
  let scheme = call_780099.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780099.url(scheme.get, call_780099.host, call_780099.base,
                         call_780099.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780099, url, valid)

proc call*(call_780100: Call_GetReposOwnerRepoWatchers_780093; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoWatchers
  ## List Stargazers. New implementation.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780101 = newJObject()
  var header_780102 = newJObject()
  add(path_780101, "repo", newJString(repo))
  add(path_780101, "owner", newJString(owner))
  add(header_780102, "Accept", newJString(Accept))
  result = call_780100.call(path_780101, nil, header_780102, nil, nil)

var getReposOwnerRepoWatchers* = Call_GetReposOwnerRepoWatchers_780093(
    name: "getReposOwnerRepoWatchers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/watchers",
    validator: validate_GetReposOwnerRepoWatchers_780094, base: "/",
    url: url_GetReposOwnerRepoWatchers_780095, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoArchiveFormatPath_780103 = ref object of OpenApiRestCall_777573
proc url_GetReposOwnerRepoArchiveFormatPath_780105(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "archive_format" in path, "`archive_format` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "archive_format"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoArchiveFormatPath_780104(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get archive link.
  ## This method will return a 302 to a URL to download a tarball or zipball
  ## archive for a repository. Please make sure your HTTP framework is
  ## configured to follow redirects or you will need to use the Location header
  ## to make a second GET request.
  ## Note: For private repositories, these links are temporary and expire quickly.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   archive_format: JString (required)
  ##   path: JString (required)
  ##       : Valid Git reference, defaults to 'master'.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_780106 = path.getOrDefault("repo")
  valid_780106 = validateParameter(valid_780106, JString, required = true,
                                 default = nil)
  if valid_780106 != nil:
    section.add "repo", valid_780106
  var valid_780107 = path.getOrDefault("owner")
  valid_780107 = validateParameter(valid_780107, JString, required = true,
                                 default = nil)
  if valid_780107 != nil:
    section.add "owner", valid_780107
  var valid_780108 = path.getOrDefault("archive_format")
  valid_780108 = validateParameter(valid_780108, JString, required = true,
                                 default = newJString("tarball"))
  if valid_780108 != nil:
    section.add "archive_format", valid_780108
  var valid_780109 = path.getOrDefault("path")
  valid_780109 = validateParameter(valid_780109, JString, required = true,
                                 default = nil)
  if valid_780109 != nil:
    section.add "path", valid_780109
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780110 = header.getOrDefault("Accept")
  valid_780110 = validateParameter(valid_780110, JString, required = false,
                                 default = nil)
  if valid_780110 != nil:
    section.add "Accept", valid_780110
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780111: Call_GetReposOwnerRepoArchiveFormatPath_780103;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get archive link.
  ## This method will return a 302 to a URL to download a tarball or zipball
  ## archive for a repository. Please make sure your HTTP framework is
  ## configured to follow redirects or you will need to use the Location header
  ## to make a second GET request.
  ## Note: For private repositories, these links are temporary and expire quickly.
  ## 
  ## 
  let valid = call_780111.validator(path, query, header, formData, body)
  let scheme = call_780111.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780111.url(scheme.get, call_780111.host, call_780111.base,
                         call_780111.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780111, url, valid)

proc call*(call_780112: Call_GetReposOwnerRepoArchiveFormatPath_780103;
          repo: string; owner: string; path: string;
          archiveFormat: string = "tarball"; Accept: string = ""): Recallable =
  ## getReposOwnerRepoArchiveFormatPath
  ## Get archive link.
  ## This method will return a 302 to a URL to download a tarball or zipball
  ## archive for a repository. Please make sure your HTTP framework is
  ## configured to follow redirects or you will need to use the Location header
  ## to make a second GET request.
  ## Note: For private repositories, these links are temporary and expire quickly.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   archiveFormat: string (required)
  ##   path: string (required)
  ##       : Valid Git reference, defaults to 'master'.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780113 = newJObject()
  var header_780114 = newJObject()
  add(path_780113, "repo", newJString(repo))
  add(path_780113, "owner", newJString(owner))
  add(path_780113, "archive_format", newJString(archiveFormat))
  add(path_780113, "path", newJString(path))
  add(header_780114, "Accept", newJString(Accept))
  result = call_780112.call(path_780113, nil, header_780114, nil, nil)

var getReposOwnerRepoArchiveFormatPath* = Call_GetReposOwnerRepoArchiveFormatPath_780103(
    name: "getReposOwnerRepoArchiveFormatPath", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/{archive_format}/{path}",
    validator: validate_GetReposOwnerRepoArchiveFormatPath_780104, base: "/",
    url: url_GetReposOwnerRepoArchiveFormatPath_780105, schemes: {Scheme.Https})
type
  Call_GetRepositories_780115 = ref object of OpenApiRestCall_777573
proc url_GetRepositories_780117(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRepositories_780116(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## List all public repositories.
  ## This provides a dump of every public repository, in the order that they
  ## were created.
  ## Note: Pagination is powered exclusively by the since parameter. is the
  ## Link header to get the URL for the next page of repositories.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_780118 = query.getOrDefault("since")
  valid_780118 = validateParameter(valid_780118, JString, required = false,
                                 default = nil)
  if valid_780118 != nil:
    section.add "since", valid_780118
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780119 = header.getOrDefault("Accept")
  valid_780119 = validateParameter(valid_780119, JString, required = false,
                                 default = nil)
  if valid_780119 != nil:
    section.add "Accept", valid_780119
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780120: Call_GetRepositories_780115; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List all public repositories.
  ## This provides a dump of every public repository, in the order that they
  ## were created.
  ## Note: Pagination is powered exclusively by the since parameter. is the
  ## Link header to get the URL for the next page of repositories.
  ## 
  ## 
  let valid = call_780120.validator(path, query, header, formData, body)
  let scheme = call_780120.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780120.url(scheme.get, call_780120.host, call_780120.base,
                         call_780120.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780120, url, valid)

proc call*(call_780121: Call_GetRepositories_780115; since: string = "";
          Accept: string = ""): Recallable =
  ## getRepositories
  ## List all public repositories.
  ## This provides a dump of every public repository, in the order that they
  ## were created.
  ## Note: Pagination is powered exclusively by the since parameter. is the
  ## Link header to get the URL for the next page of repositories.
  ## 
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var query_780122 = newJObject()
  var header_780123 = newJObject()
  add(query_780122, "since", newJString(since))
  add(header_780123, "Accept", newJString(Accept))
  result = call_780121.call(nil, query_780122, header_780123, nil, nil)

var getRepositories* = Call_GetRepositories_780115(name: "getRepositories",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/repositories",
    validator: validate_GetRepositories_780116, base: "/", url: url_GetRepositories_780117,
    schemes: {Scheme.Https})
type
  Call_GetSearchCode_780124 = ref object of OpenApiRestCall_777573
proc url_GetSearchCode_780126(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchCode_780125(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Search code.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   q: JString (required)
  ##    : The search terms. This can be any combination of the supported code
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier
  ## you can restrict the search to just the file contents, the file path,
  ## or both.
  ## 'Languages' Searches code based on the language it's written in.
  ## 'Forks' Filters repositories based on the number of forks, and/or
  ## whether code from forked repositories should be included in the results
  ## at all.
  ## 'Size' Finds files that match a certain size (in bytes).
  ## 'Path' Specifies the path that the resulting file must be at.
  ## 'Extension' Matches files with a certain extension.
  ## 'Users' or 'Repositories' Limits searches to a specific user or repository.
  ## 
  ##   sort: JString
  ##       : Can only be 'indexed', which indicates how recently a file has been indexed
  ## by the GitHub search infrastructure. If not provided, results are sorted
  ## by best match.
  ## 
  section = newJObject()
  var valid_780127 = query.getOrDefault("order")
  valid_780127 = validateParameter(valid_780127, JString, required = false,
                                 default = newJString("desc"))
  if valid_780127 != nil:
    section.add "order", valid_780127
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_780128 = query.getOrDefault("q")
  valid_780128 = validateParameter(valid_780128, JString, required = true,
                                 default = nil)
  if valid_780128 != nil:
    section.add "q", valid_780128
  var valid_780129 = query.getOrDefault("sort")
  valid_780129 = validateParameter(valid_780129, JString, required = false,
                                 default = newJString("indexed"))
  if valid_780129 != nil:
    section.add "sort", valid_780129
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780130 = header.getOrDefault("Accept")
  valid_780130 = validateParameter(valid_780130, JString, required = false,
                                 default = nil)
  if valid_780130 != nil:
    section.add "Accept", valid_780130
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780131: Call_GetSearchCode_780124; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Search code.
  ## 
  let valid = call_780131.validator(path, query, header, formData, body)
  let scheme = call_780131.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780131.url(scheme.get, call_780131.host, call_780131.base,
                         call_780131.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780131, url, valid)

proc call*(call_780132: Call_GetSearchCode_780124; q: string; order: string = "desc";
          Accept: string = ""; sort: string = "indexed"): Recallable =
  ## getSearchCode
  ## Search code.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   q: string (required)
  ##    : The search terms. This can be any combination of the supported code
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier
  ## you can restrict the search to just the file contents, the file path,
  ## or both.
  ## 'Languages' Searches code based on the language it's written in.
  ## 'Forks' Filters repositories based on the number of forks, and/or
  ## whether code from forked repositories should be included in the results
  ## at all.
  ## 'Size' Finds files that match a certain size (in bytes).
  ## 'Path' Specifies the path that the resulting file must be at.
  ## 'Extension' Matches files with a certain extension.
  ## 'Users' or 'Repositories' Limits searches to a specific user or repository.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##       : Can only be 'indexed', which indicates how recently a file has been indexed
  ## by the GitHub search infrastructure. If not provided, results are sorted
  ## by best match.
  ## 
  var query_780133 = newJObject()
  var header_780134 = newJObject()
  add(query_780133, "order", newJString(order))
  add(query_780133, "q", newJString(q))
  add(header_780134, "Accept", newJString(Accept))
  add(query_780133, "sort", newJString(sort))
  result = call_780132.call(nil, query_780133, header_780134, nil, nil)

var getSearchCode* = Call_GetSearchCode_780124(name: "getSearchCode",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/search/code",
    validator: validate_GetSearchCode_780125, base: "/", url: url_GetSearchCode_780126,
    schemes: {Scheme.Https})
type
  Call_GetSearchIssues_780135 = ref object of OpenApiRestCall_777573
proc url_GetSearchIssues_780137(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchIssues_780136(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Find issues by state and keyword. (This method returns up to 100 results per page.)
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   q: JString (required)
  ##    : The q search term can also contain any combination of the supported issue search qualifiers:
  ##   sort: JString
  ##       : The sort field. Can be comments, created, or updated. Default: results are sorted by best match.
  section = newJObject()
  var valid_780138 = query.getOrDefault("order")
  valid_780138 = validateParameter(valid_780138, JString, required = false,
                                 default = newJString("desc"))
  if valid_780138 != nil:
    section.add "order", valid_780138
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_780139 = query.getOrDefault("q")
  valid_780139 = validateParameter(valid_780139, JString, required = true,
                                 default = nil)
  if valid_780139 != nil:
    section.add "q", valid_780139
  var valid_780140 = query.getOrDefault("sort")
  valid_780140 = validateParameter(valid_780140, JString, required = false,
                                 default = newJString("updated"))
  if valid_780140 != nil:
    section.add "sort", valid_780140
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780141 = header.getOrDefault("Accept")
  valid_780141 = validateParameter(valid_780141, JString, required = false,
                                 default = nil)
  if valid_780141 != nil:
    section.add "Accept", valid_780141
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780142: Call_GetSearchIssues_780135; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Find issues by state and keyword. (This method returns up to 100 results per page.)
  ## 
  let valid = call_780142.validator(path, query, header, formData, body)
  let scheme = call_780142.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780142.url(scheme.get, call_780142.host, call_780142.base,
                         call_780142.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780142, url, valid)

proc call*(call_780143: Call_GetSearchIssues_780135; q: string;
          order: string = "desc"; Accept: string = ""; sort: string = "updated"): Recallable =
  ## getSearchIssues
  ## Find issues by state and keyword. (This method returns up to 100 results per page.)
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   q: string (required)
  ##    : The q search term can also contain any combination of the supported issue search qualifiers:
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##       : The sort field. Can be comments, created, or updated. Default: results are sorted by best match.
  var query_780144 = newJObject()
  var header_780145 = newJObject()
  add(query_780144, "order", newJString(order))
  add(query_780144, "q", newJString(q))
  add(header_780145, "Accept", newJString(Accept))
  add(query_780144, "sort", newJString(sort))
  result = call_780143.call(nil, query_780144, header_780145, nil, nil)

var getSearchIssues* = Call_GetSearchIssues_780135(name: "getSearchIssues",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/search/issues",
    validator: validate_GetSearchIssues_780136, base: "/", url: url_GetSearchIssues_780137,
    schemes: {Scheme.Https})
type
  Call_GetSearchRepositories_780146 = ref object of OpenApiRestCall_777573
proc url_GetSearchRepositories_780148(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchRepositories_780147(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Search repositories.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   q: JString (required)
  ##    : The search terms. This can be any combination of the supported repository
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the repository name, description, readme,
  ## or any combination of these.
  ## 'Size' Finds repositories that match a certain size (in kilobytes).
  ## 'Forks' Filters repositories based on the number of forks, and/or whether
  ## forked repositories should be included in the results at all.
  ## 'Created' and 'Last Updated' Filters repositories based on times of
  ## creation, or when they were last updated.
  ## 'Users or Repositories' Limits searches to a specific user or repository.
  ## 'Languages' Searches repositories based on the language they are written in.
  ## 'Stars' Searches repositories based on the number of stars.
  ## 
  ##   sort: JString
  ##       : If not provided, results are sorted by best match.
  section = newJObject()
  var valid_780149 = query.getOrDefault("order")
  valid_780149 = validateParameter(valid_780149, JString, required = false,
                                 default = newJString("desc"))
  if valid_780149 != nil:
    section.add "order", valid_780149
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_780150 = query.getOrDefault("q")
  valid_780150 = validateParameter(valid_780150, JString, required = true,
                                 default = nil)
  if valid_780150 != nil:
    section.add "q", valid_780150
  var valid_780151 = query.getOrDefault("sort")
  valid_780151 = validateParameter(valid_780151, JString, required = false,
                                 default = newJString("stars"))
  if valid_780151 != nil:
    section.add "sort", valid_780151
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780152 = header.getOrDefault("Accept")
  valid_780152 = validateParameter(valid_780152, JString, required = false,
                                 default = nil)
  if valid_780152 != nil:
    section.add "Accept", valid_780152
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780153: Call_GetSearchRepositories_780146; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Search repositories.
  ## 
  let valid = call_780153.validator(path, query, header, formData, body)
  let scheme = call_780153.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780153.url(scheme.get, call_780153.host, call_780153.base,
                         call_780153.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780153, url, valid)

proc call*(call_780154: Call_GetSearchRepositories_780146; q: string;
          order: string = "desc"; Accept: string = ""; sort: string = "stars"): Recallable =
  ## getSearchRepositories
  ## Search repositories.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   q: string (required)
  ##    : The search terms. This can be any combination of the supported repository
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the repository name, description, readme,
  ## or any combination of these.
  ## 'Size' Finds repositories that match a certain size (in kilobytes).
  ## 'Forks' Filters repositories based on the number of forks, and/or whether
  ## forked repositories should be included in the results at all.
  ## 'Created' and 'Last Updated' Filters repositories based on times of
  ## creation, or when they were last updated.
  ## 'Users or Repositories' Limits searches to a specific user or repository.
  ## 'Languages' Searches repositories based on the language they are written in.
  ## 'Stars' Searches repositories based on the number of stars.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##       : If not provided, results are sorted by best match.
  var query_780155 = newJObject()
  var header_780156 = newJObject()
  add(query_780155, "order", newJString(order))
  add(query_780155, "q", newJString(q))
  add(header_780156, "Accept", newJString(Accept))
  add(query_780155, "sort", newJString(sort))
  result = call_780154.call(nil, query_780155, header_780156, nil, nil)

var getSearchRepositories* = Call_GetSearchRepositories_780146(
    name: "getSearchRepositories", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/search/repositories", validator: validate_GetSearchRepositories_780147,
    base: "/", url: url_GetSearchRepositories_780148, schemes: {Scheme.Https})
type
  Call_GetSearchUsers_780157 = ref object of OpenApiRestCall_777573
proc url_GetSearchUsers_780159(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchUsers_780158(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Search users.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   q: JString (required)
  ##    : The search terms. This can be any combination of the supported user
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the username, public email, full name,
  ## location, or any combination of these.
  ## 'Repository count' Filters users based on the number of repositories they
  ## have.
  ## 'Location' Filter users by the location indicated in their profile.
  ## 'Language' Search for users that have repositories that match a certain
  ## language.
  ## 'Created' Filter users based on when they joined.
  ## 'Followers' Filter users based on the number of followers they have.
  ## 
  ##   sort: JString
  ##       : If not provided, results are sorted by best match.
  section = newJObject()
  var valid_780160 = query.getOrDefault("order")
  valid_780160 = validateParameter(valid_780160, JString, required = false,
                                 default = newJString("desc"))
  if valid_780160 != nil:
    section.add "order", valid_780160
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_780161 = query.getOrDefault("q")
  valid_780161 = validateParameter(valid_780161, JString, required = true,
                                 default = nil)
  if valid_780161 != nil:
    section.add "q", valid_780161
  var valid_780162 = query.getOrDefault("sort")
  valid_780162 = validateParameter(valid_780162, JString, required = false,
                                 default = newJString("followers"))
  if valid_780162 != nil:
    section.add "sort", valid_780162
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780163 = header.getOrDefault("Accept")
  valid_780163 = validateParameter(valid_780163, JString, required = false,
                                 default = nil)
  if valid_780163 != nil:
    section.add "Accept", valid_780163
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780164: Call_GetSearchUsers_780157; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Search users.
  ## 
  let valid = call_780164.validator(path, query, header, formData, body)
  let scheme = call_780164.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780164.url(scheme.get, call_780164.host, call_780164.base,
                         call_780164.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780164, url, valid)

proc call*(call_780165: Call_GetSearchUsers_780157; q: string;
          order: string = "desc"; Accept: string = ""; sort: string = "followers"): Recallable =
  ## getSearchUsers
  ## Search users.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   q: string (required)
  ##    : The search terms. This can be any combination of the supported user
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the username, public email, full name,
  ## location, or any combination of these.
  ## 'Repository count' Filters users based on the number of repositories they
  ## have.
  ## 'Location' Filter users by the location indicated in their profile.
  ## 'Language' Search for users that have repositories that match a certain
  ## language.
  ## 'Created' Filter users based on when they joined.
  ## 'Followers' Filter users based on the number of followers they have.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##       : If not provided, results are sorted by best match.
  var query_780166 = newJObject()
  var header_780167 = newJObject()
  add(query_780166, "order", newJString(order))
  add(query_780166, "q", newJString(q))
  add(header_780167, "Accept", newJString(Accept))
  add(query_780166, "sort", newJString(sort))
  result = call_780165.call(nil, query_780166, header_780167, nil, nil)

var getSearchUsers* = Call_GetSearchUsers_780157(name: "getSearchUsers",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/search/users",
    validator: validate_GetSearchUsers_780158, base: "/", url: url_GetSearchUsers_780159,
    schemes: {Scheme.Https})
type
  Call_GetTeamsTeamId_780168 = ref object of OpenApiRestCall_777573
proc url_GetTeamsTeamId_780170(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamId_780169(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Get team.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_780171 = path.getOrDefault("teamId")
  valid_780171 = validateParameter(valid_780171, JInt, required = true, default = nil)
  if valid_780171 != nil:
    section.add "teamId", valid_780171
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780172 = header.getOrDefault("Accept")
  valid_780172 = validateParameter(valid_780172, JString, required = false,
                                 default = nil)
  if valid_780172 != nil:
    section.add "Accept", valid_780172
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780173: Call_GetTeamsTeamId_780168; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get team.
  ## 
  let valid = call_780173.validator(path, query, header, formData, body)
  let scheme = call_780173.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780173.url(scheme.get, call_780173.host, call_780173.base,
                         call_780173.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780173, url, valid)

proc call*(call_780174: Call_GetTeamsTeamId_780168; teamId: int; Accept: string = ""): Recallable =
  ## getTeamsTeamId
  ## Get team.
  ##   teamId: int (required)
  ##         : Id of team.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780175 = newJObject()
  var header_780176 = newJObject()
  add(path_780175, "teamId", newJInt(teamId))
  add(header_780176, "Accept", newJString(Accept))
  result = call_780174.call(path_780175, nil, header_780176, nil, nil)

var getTeamsTeamId* = Call_GetTeamsTeamId_780168(name: "getTeamsTeamId",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/teams/{teamId}",
    validator: validate_GetTeamsTeamId_780169, base: "/", url: url_GetTeamsTeamId_780170,
    schemes: {Scheme.Https})
type
  Call_PatchTeamsTeamId_780186 = ref object of OpenApiRestCall_777573
proc url_PatchTeamsTeamId_780188(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchTeamsTeamId_780187(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Edit team.
  ## In order to edit a team, the authenticated user must be an owner of the org
  ## that the team is associated with.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_780189 = path.getOrDefault("teamId")
  valid_780189 = validateParameter(valid_780189, JInt, required = true, default = nil)
  if valid_780189 != nil:
    section.add "teamId", valid_780189
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780190 = header.getOrDefault("Accept")
  valid_780190 = validateParameter(valid_780190, JString, required = false,
                                 default = nil)
  if valid_780190 != nil:
    section.add "Accept", valid_780190
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_780192: Call_PatchTeamsTeamId_780186; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Edit team.
  ## In order to edit a team, the authenticated user must be an owner of the org
  ## that the team is associated with.
  ## 
  ## 
  let valid = call_780192.validator(path, query, header, formData, body)
  let scheme = call_780192.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780192.url(scheme.get, call_780192.host, call_780192.base,
                         call_780192.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780192, url, valid)

proc call*(call_780193: Call_PatchTeamsTeamId_780186; teamId: int; body: JsonNode;
          Accept: string = ""): Recallable =
  ## patchTeamsTeamId
  ## Edit team.
  ## In order to edit a team, the authenticated user must be an owner of the org
  ## that the team is associated with.
  ## 
  ##   teamId: int (required)
  ##         : Id of team.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780194 = newJObject()
  var header_780195 = newJObject()
  var body_780196 = newJObject()
  add(path_780194, "teamId", newJInt(teamId))
  if body != nil:
    body_780196 = body
  add(header_780195, "Accept", newJString(Accept))
  result = call_780193.call(path_780194, nil, header_780195, nil, body_780196)

var patchTeamsTeamId* = Call_PatchTeamsTeamId_780186(name: "patchTeamsTeamId",
    meth: HttpMethod.HttpPatch, host: "api.github.com", route: "/teams/{teamId}",
    validator: validate_PatchTeamsTeamId_780187, base: "/",
    url: url_PatchTeamsTeamId_780188, schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamId_780177 = ref object of OpenApiRestCall_777573
proc url_DeleteTeamsTeamId_780179(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamId_780178(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Delete team.
  ## In order to delete a team, the authenticated user must be an owner of the
  ## org that the team is associated with.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_780180 = path.getOrDefault("teamId")
  valid_780180 = validateParameter(valid_780180, JInt, required = true, default = nil)
  if valid_780180 != nil:
    section.add "teamId", valid_780180
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780181 = header.getOrDefault("Accept")
  valid_780181 = validateParameter(valid_780181, JString, required = false,
                                 default = nil)
  if valid_780181 != nil:
    section.add "Accept", valid_780181
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780182: Call_DeleteTeamsTeamId_780177; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete team.
  ## In order to delete a team, the authenticated user must be an owner of the
  ## org that the team is associated with.
  ## 
  ## 
  let valid = call_780182.validator(path, query, header, formData, body)
  let scheme = call_780182.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780182.url(scheme.get, call_780182.host, call_780182.base,
                         call_780182.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780182, url, valid)

proc call*(call_780183: Call_DeleteTeamsTeamId_780177; teamId: int;
          Accept: string = ""): Recallable =
  ## deleteTeamsTeamId
  ## Delete team.
  ## In order to delete a team, the authenticated user must be an owner of the
  ## org that the team is associated with.
  ## 
  ##   teamId: int (required)
  ##         : Id of team.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780184 = newJObject()
  var header_780185 = newJObject()
  add(path_780184, "teamId", newJInt(teamId))
  add(header_780185, "Accept", newJString(Accept))
  result = call_780183.call(path_780184, nil, header_780185, nil, nil)

var deleteTeamsTeamId* = Call_DeleteTeamsTeamId_780177(name: "deleteTeamsTeamId",
    meth: HttpMethod.HttpDelete, host: "api.github.com", route: "/teams/{teamId}",
    validator: validate_DeleteTeamsTeamId_780178, base: "/",
    url: url_DeleteTeamsTeamId_780179, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdMembers_780197 = ref object of OpenApiRestCall_777573
proc url_GetTeamsTeamIdMembers_780199(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/members")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdMembers_780198(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List team members.
  ## In order to list members in a team, the authenticated user must be a member
  ## of the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_780200 = path.getOrDefault("teamId")
  valid_780200 = validateParameter(valid_780200, JInt, required = true, default = nil)
  if valid_780200 != nil:
    section.add "teamId", valid_780200
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780201 = header.getOrDefault("Accept")
  valid_780201 = validateParameter(valid_780201, JString, required = false,
                                 default = nil)
  if valid_780201 != nil:
    section.add "Accept", valid_780201
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780202: Call_GetTeamsTeamIdMembers_780197; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List team members.
  ## In order to list members in a team, the authenticated user must be a member
  ## of the team.
  ## 
  ## 
  let valid = call_780202.validator(path, query, header, formData, body)
  let scheme = call_780202.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780202.url(scheme.get, call_780202.host, call_780202.base,
                         call_780202.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780202, url, valid)

proc call*(call_780203: Call_GetTeamsTeamIdMembers_780197; teamId: int;
          Accept: string = ""): Recallable =
  ## getTeamsTeamIdMembers
  ## List team members.
  ## In order to list members in a team, the authenticated user must be a member
  ## of the team.
  ## 
  ##   teamId: int (required)
  ##         : Id of team.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780204 = newJObject()
  var header_780205 = newJObject()
  add(path_780204, "teamId", newJInt(teamId))
  add(header_780205, "Accept", newJString(Accept))
  result = call_780203.call(path_780204, nil, header_780205, nil, nil)

var getTeamsTeamIdMembers* = Call_GetTeamsTeamIdMembers_780197(
    name: "getTeamsTeamIdMembers", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/teams/{teamId}/members", validator: validate_GetTeamsTeamIdMembers_780198,
    base: "/", url: url_GetTeamsTeamIdMembers_780199, schemes: {Scheme.Https})
type
  Call_PutTeamsTeamIdMembersUsername_780216 = ref object of OpenApiRestCall_777573
proc url_PutTeamsTeamIdMembersUsername_780218(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutTeamsTeamIdMembersUsername_780217(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## The API (described below) is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Add team membership API instead. It allows you to invite new organization members to your teams.
  ## 
  ## Add team member.
  ## In order to add a user to a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  ##   username: JString (required)
  ##           : Name of a member.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_780219 = path.getOrDefault("teamId")
  valid_780219 = validateParameter(valid_780219, JInt, required = true, default = nil)
  if valid_780219 != nil:
    section.add "teamId", valid_780219
  var valid_780220 = path.getOrDefault("username")
  valid_780220 = validateParameter(valid_780220, JString, required = true,
                                 default = nil)
  if valid_780220 != nil:
    section.add "username", valid_780220
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780221 = header.getOrDefault("Accept")
  valid_780221 = validateParameter(valid_780221, JString, required = false,
                                 default = nil)
  if valid_780221 != nil:
    section.add "Accept", valid_780221
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780222: Call_PutTeamsTeamIdMembersUsername_780216; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The API (described below) is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Add team membership API instead. It allows you to invite new organization members to your teams.
  ## 
  ## Add team member.
  ## In order to add a user to a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## 
  ## 
  let valid = call_780222.validator(path, query, header, formData, body)
  let scheme = call_780222.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780222.url(scheme.get, call_780222.host, call_780222.base,
                         call_780222.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780222, url, valid)

proc call*(call_780223: Call_PutTeamsTeamIdMembersUsername_780216; teamId: int;
          username: string; Accept: string = ""): Recallable =
  ## putTeamsTeamIdMembersUsername
  ## The API (described below) is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Add team membership API instead. It allows you to invite new organization members to your teams.
  ## 
  ## Add team member.
  ## In order to add a user to a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## 
  ##   teamId: int (required)
  ##         : Id of team.
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780224 = newJObject()
  var header_780225 = newJObject()
  add(path_780224, "teamId", newJInt(teamId))
  add(path_780224, "username", newJString(username))
  add(header_780225, "Accept", newJString(Accept))
  result = call_780223.call(path_780224, nil, header_780225, nil, nil)

var putTeamsTeamIdMembersUsername* = Call_PutTeamsTeamIdMembersUsername_780216(
    name: "putTeamsTeamIdMembersUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/teams/{teamId}/members/{username}",
    validator: validate_PutTeamsTeamIdMembersUsername_780217, base: "/",
    url: url_PutTeamsTeamIdMembersUsername_780218, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdMembersUsername_780206 = ref object of OpenApiRestCall_777573
proc url_GetTeamsTeamIdMembersUsername_780208(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdMembersUsername_780207(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## The "Get team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Get team membership API instead. It allows you to get both active and pending memberships.
  ## 
  ## Get team member.
  ## In order to get if a user is a member of a team, the authenticated user mus
  ## be a member of the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  ##   username: JString (required)
  ##           : Name of a member.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_780209 = path.getOrDefault("teamId")
  valid_780209 = validateParameter(valid_780209, JInt, required = true, default = nil)
  if valid_780209 != nil:
    section.add "teamId", valid_780209
  var valid_780210 = path.getOrDefault("username")
  valid_780210 = validateParameter(valid_780210, JString, required = true,
                                 default = nil)
  if valid_780210 != nil:
    section.add "username", valid_780210
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780211 = header.getOrDefault("Accept")
  valid_780211 = validateParameter(valid_780211, JString, required = false,
                                 default = nil)
  if valid_780211 != nil:
    section.add "Accept", valid_780211
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780212: Call_GetTeamsTeamIdMembersUsername_780206; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## The "Get team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Get team membership API instead. It allows you to get both active and pending memberships.
  ## 
  ## Get team member.
  ## In order to get if a user is a member of a team, the authenticated user mus
  ## be a member of the team.
  ## 
  ## 
  let valid = call_780212.validator(path, query, header, formData, body)
  let scheme = call_780212.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780212.url(scheme.get, call_780212.host, call_780212.base,
                         call_780212.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780212, url, valid)

proc call*(call_780213: Call_GetTeamsTeamIdMembersUsername_780206; teamId: int;
          username: string; Accept: string = ""): Recallable =
  ## getTeamsTeamIdMembersUsername
  ## The "Get team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Get team membership API instead. It allows you to get both active and pending memberships.
  ## 
  ## Get team member.
  ## In order to get if a user is a member of a team, the authenticated user mus
  ## be a member of the team.
  ## 
  ##   teamId: int (required)
  ##         : Id of team.
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780214 = newJObject()
  var header_780215 = newJObject()
  add(path_780214, "teamId", newJInt(teamId))
  add(path_780214, "username", newJString(username))
  add(header_780215, "Accept", newJString(Accept))
  result = call_780213.call(path_780214, nil, header_780215, nil, nil)

var getTeamsTeamIdMembersUsername* = Call_GetTeamsTeamIdMembersUsername_780206(
    name: "getTeamsTeamIdMembersUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/teams/{teamId}/members/{username}",
    validator: validate_GetTeamsTeamIdMembersUsername_780207, base: "/",
    url: url_GetTeamsTeamIdMembersUsername_780208, schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamIdMembersUsername_780226 = ref object of OpenApiRestCall_777573
proc url_DeleteTeamsTeamIdMembersUsername_780228(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamIdMembersUsername_780227(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## The "Remove team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Remove team membership API instead. It allows you to remove both active and pending memberships.
  ## 
  ## Remove team member.
  ## In order to remove a user from a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## NOTE This does not delete the user, it just remove them from the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  ##   username: JString (required)
  ##           : Name of a member.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_780229 = path.getOrDefault("teamId")
  valid_780229 = validateParameter(valid_780229, JInt, required = true, default = nil)
  if valid_780229 != nil:
    section.add "teamId", valid_780229
  var valid_780230 = path.getOrDefault("username")
  valid_780230 = validateParameter(valid_780230, JString, required = true,
                                 default = nil)
  if valid_780230 != nil:
    section.add "username", valid_780230
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780231 = header.getOrDefault("Accept")
  valid_780231 = validateParameter(valid_780231, JString, required = false,
                                 default = nil)
  if valid_780231 != nil:
    section.add "Accept", valid_780231
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780232: Call_DeleteTeamsTeamIdMembersUsername_780226;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## The "Remove team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Remove team membership API instead. It allows you to remove both active and pending memberships.
  ## 
  ## Remove team member.
  ## In order to remove a user from a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## NOTE This does not delete the user, it just remove them from the team.
  ## 
  ## 
  let valid = call_780232.validator(path, query, header, formData, body)
  let scheme = call_780232.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780232.url(scheme.get, call_780232.host, call_780232.base,
                         call_780232.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780232, url, valid)

proc call*(call_780233: Call_DeleteTeamsTeamIdMembersUsername_780226; teamId: int;
          username: string; Accept: string = ""): Recallable =
  ## deleteTeamsTeamIdMembersUsername
  ## The "Remove team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Remove team membership API instead. It allows you to remove both active and pending memberships.
  ## 
  ## Remove team member.
  ## In order to remove a user from a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## NOTE This does not delete the user, it just remove them from the team.
  ## 
  ##   teamId: int (required)
  ##         : Id of team.
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780234 = newJObject()
  var header_780235 = newJObject()
  add(path_780234, "teamId", newJInt(teamId))
  add(path_780234, "username", newJString(username))
  add(header_780235, "Accept", newJString(Accept))
  result = call_780233.call(path_780234, nil, header_780235, nil, nil)

var deleteTeamsTeamIdMembersUsername* = Call_DeleteTeamsTeamIdMembersUsername_780226(
    name: "deleteTeamsTeamIdMembersUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/teams/{teamId}/members/{username}",
    validator: validate_DeleteTeamsTeamIdMembersUsername_780227, base: "/",
    url: url_DeleteTeamsTeamIdMembersUsername_780228, schemes: {Scheme.Https})
type
  Call_PutTeamsTeamIdMembershipsUsername_780246 = ref object of OpenApiRestCall_777573
proc url_PutTeamsTeamIdMembershipsUsername_780248(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/memberships/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutTeamsTeamIdMembershipsUsername_780247(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Add team membership.
  ## In order to add a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with.
  ## 
  ## If the user is already a part of the team's organization (meaning they're on at least one other team in the organization), this endpoint will add the user to the team.
  ## 
  ## If the user is completely unaffiliated with the team's organization (meaning they're on none of the organization's teams), this endpoint will send an invitation to the user via email. This newly-created membership will be in the 'pending' state until the user accepts the invitation, at which point the membership will transition to the 'active' state and the user will be added as a member of the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  ##   username: JString (required)
  ##           : Name of a member.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_780249 = path.getOrDefault("teamId")
  valid_780249 = validateParameter(valid_780249, JInt, required = true, default = nil)
  if valid_780249 != nil:
    section.add "teamId", valid_780249
  var valid_780250 = path.getOrDefault("username")
  valid_780250 = validateParameter(valid_780250, JString, required = true,
                                 default = nil)
  if valid_780250 != nil:
    section.add "username", valid_780250
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780251 = header.getOrDefault("Accept")
  valid_780251 = validateParameter(valid_780251, JString, required = false,
                                 default = nil)
  if valid_780251 != nil:
    section.add "Accept", valid_780251
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780252: Call_PutTeamsTeamIdMembershipsUsername_780246;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Add team membership.
  ## In order to add a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with.
  ## 
  ## If the user is already a part of the team's organization (meaning they're on at least one other team in the organization), this endpoint will add the user to the team.
  ## 
  ## If the user is completely unaffiliated with the team's organization (meaning they're on none of the organization's teams), this endpoint will send an invitation to the user via email. This newly-created membership will be in the 'pending' state until the user accepts the invitation, at which point the membership will transition to the 'active' state and the user will be added as a member of the team.
  ## 
  ## 
  let valid = call_780252.validator(path, query, header, formData, body)
  let scheme = call_780252.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780252.url(scheme.get, call_780252.host, call_780252.base,
                         call_780252.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780252, url, valid)

proc call*(call_780253: Call_PutTeamsTeamIdMembershipsUsername_780246; teamId: int;
          username: string; Accept: string = ""): Recallable =
  ## putTeamsTeamIdMembershipsUsername
  ## Add team membership.
  ## In order to add a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with.
  ## 
  ## If the user is already a part of the team's organization (meaning they're on at least one other team in the organization), this endpoint will add the user to the team.
  ## 
  ## If the user is completely unaffiliated with the team's organization (meaning they're on none of the organization's teams), this endpoint will send an invitation to the user via email. This newly-created membership will be in the 'pending' state until the user accepts the invitation, at which point the membership will transition to the 'active' state and the user will be added as a member of the team.
  ## 
  ##   teamId: int (required)
  ##         : Id of team.
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780254 = newJObject()
  var header_780255 = newJObject()
  add(path_780254, "teamId", newJInt(teamId))
  add(path_780254, "username", newJString(username))
  add(header_780255, "Accept", newJString(Accept))
  result = call_780253.call(path_780254, nil, header_780255, nil, nil)

var putTeamsTeamIdMembershipsUsername* = Call_PutTeamsTeamIdMembershipsUsername_780246(
    name: "putTeamsTeamIdMembershipsUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/teams/{teamId}/memberships/{username}",
    validator: validate_PutTeamsTeamIdMembershipsUsername_780247, base: "/",
    url: url_PutTeamsTeamIdMembershipsUsername_780248, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdMembershipsUsername_780236 = ref object of OpenApiRestCall_777573
proc url_GetTeamsTeamIdMembershipsUsername_780238(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/memberships/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdMembershipsUsername_780237(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Get team membership.
  ## In order to get a user's membership with a team, the authenticated user must be a member of the team or an owner of the team's organization.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  ##   username: JString (required)
  ##           : Name of a member.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_780239 = path.getOrDefault("teamId")
  valid_780239 = validateParameter(valid_780239, JInt, required = true, default = nil)
  if valid_780239 != nil:
    section.add "teamId", valid_780239
  var valid_780240 = path.getOrDefault("username")
  valid_780240 = validateParameter(valid_780240, JString, required = true,
                                 default = nil)
  if valid_780240 != nil:
    section.add "username", valid_780240
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780241 = header.getOrDefault("Accept")
  valid_780241 = validateParameter(valid_780241, JString, required = false,
                                 default = nil)
  if valid_780241 != nil:
    section.add "Accept", valid_780241
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780242: Call_GetTeamsTeamIdMembershipsUsername_780236;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Get team membership.
  ## In order to get a user's membership with a team, the authenticated user must be a member of the team or an owner of the team's organization.
  ## 
  ## 
  let valid = call_780242.validator(path, query, header, formData, body)
  let scheme = call_780242.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780242.url(scheme.get, call_780242.host, call_780242.base,
                         call_780242.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780242, url, valid)

proc call*(call_780243: Call_GetTeamsTeamIdMembershipsUsername_780236; teamId: int;
          username: string; Accept: string = ""): Recallable =
  ## getTeamsTeamIdMembershipsUsername
  ## Get team membership.
  ## In order to get a user's membership with a team, the authenticated user must be a member of the team or an owner of the team's organization.
  ## 
  ##   teamId: int (required)
  ##         : Id of team.
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780244 = newJObject()
  var header_780245 = newJObject()
  add(path_780244, "teamId", newJInt(teamId))
  add(path_780244, "username", newJString(username))
  add(header_780245, "Accept", newJString(Accept))
  result = call_780243.call(path_780244, nil, header_780245, nil, nil)

var getTeamsTeamIdMembershipsUsername* = Call_GetTeamsTeamIdMembershipsUsername_780236(
    name: "getTeamsTeamIdMembershipsUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/teams/{teamId}/memberships/{username}",
    validator: validate_GetTeamsTeamIdMembershipsUsername_780237, base: "/",
    url: url_GetTeamsTeamIdMembershipsUsername_780238, schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamIdMembershipsUsername_780256 = ref object of OpenApiRestCall_777573
proc url_DeleteTeamsTeamIdMembershipsUsername_780258(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/memberships/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamIdMembershipsUsername_780257(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Remove team membership.
  ## In order to remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. NOTE: This does not delete the user, it just removes their membership from the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  ##   username: JString (required)
  ##           : Name of a member.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_780259 = path.getOrDefault("teamId")
  valid_780259 = validateParameter(valid_780259, JInt, required = true, default = nil)
  if valid_780259 != nil:
    section.add "teamId", valid_780259
  var valid_780260 = path.getOrDefault("username")
  valid_780260 = validateParameter(valid_780260, JString, required = true,
                                 default = nil)
  if valid_780260 != nil:
    section.add "username", valid_780260
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780261 = header.getOrDefault("Accept")
  valid_780261 = validateParameter(valid_780261, JString, required = false,
                                 default = nil)
  if valid_780261 != nil:
    section.add "Accept", valid_780261
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780262: Call_DeleteTeamsTeamIdMembershipsUsername_780256;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Remove team membership.
  ## In order to remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. NOTE: This does not delete the user, it just removes their membership from the team.
  ## 
  ## 
  let valid = call_780262.validator(path, query, header, formData, body)
  let scheme = call_780262.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780262.url(scheme.get, call_780262.host, call_780262.base,
                         call_780262.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780262, url, valid)

proc call*(call_780263: Call_DeleteTeamsTeamIdMembershipsUsername_780256;
          teamId: int; username: string; Accept: string = ""): Recallable =
  ## deleteTeamsTeamIdMembershipsUsername
  ## Remove team membership.
  ## In order to remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. NOTE: This does not delete the user, it just removes their membership from the team.
  ## 
  ##   teamId: int (required)
  ##         : Id of team.
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780264 = newJObject()
  var header_780265 = newJObject()
  add(path_780264, "teamId", newJInt(teamId))
  add(path_780264, "username", newJString(username))
  add(header_780265, "Accept", newJString(Accept))
  result = call_780263.call(path_780264, nil, header_780265, nil, nil)

var deleteTeamsTeamIdMembershipsUsername* = Call_DeleteTeamsTeamIdMembershipsUsername_780256(
    name: "deleteTeamsTeamIdMembershipsUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/teams/{teamId}/memberships/{username}",
    validator: validate_DeleteTeamsTeamIdMembershipsUsername_780257, base: "/",
    url: url_DeleteTeamsTeamIdMembershipsUsername_780258, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdRepos_780266 = ref object of OpenApiRestCall_777573
proc url_GetTeamsTeamIdRepos_780268(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdRepos_780267(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## List team repos
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_780269 = path.getOrDefault("teamId")
  valid_780269 = validateParameter(valid_780269, JInt, required = true, default = nil)
  if valid_780269 != nil:
    section.add "teamId", valid_780269
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780270 = header.getOrDefault("Accept")
  valid_780270 = validateParameter(valid_780270, JString, required = false,
                                 default = nil)
  if valid_780270 != nil:
    section.add "Accept", valid_780270
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780271: Call_GetTeamsTeamIdRepos_780266; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List team repos
  ## 
  let valid = call_780271.validator(path, query, header, formData, body)
  let scheme = call_780271.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780271.url(scheme.get, call_780271.host, call_780271.base,
                         call_780271.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780271, url, valid)

proc call*(call_780272: Call_GetTeamsTeamIdRepos_780266; teamId: int;
          Accept: string = ""): Recallable =
  ## getTeamsTeamIdRepos
  ## List team repos
  ##   teamId: int (required)
  ##         : Id of team.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780273 = newJObject()
  var header_780274 = newJObject()
  add(path_780273, "teamId", newJInt(teamId))
  add(header_780274, "Accept", newJString(Accept))
  result = call_780272.call(path_780273, nil, header_780274, nil, nil)

var getTeamsTeamIdRepos* = Call_GetTeamsTeamIdRepos_780266(
    name: "getTeamsTeamIdRepos", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/teams/{teamId}/repos", validator: validate_GetTeamsTeamIdRepos_780267,
    base: "/", url: url_GetTeamsTeamIdRepos_780268, schemes: {Scheme.Https})
type
  Call_PutTeamsTeamIdReposOwnerRepo_780286 = ref object of OpenApiRestCall_777573
proc url_PutTeamsTeamIdReposOwnerRepo_780288(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutTeamsTeamIdReposOwnerRepo_780287(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## In order to add a repository to a team, the authenticated user must be an owner of the org that the team is associated with. Also, the repository must be owned by the organization, or a direct fork of a repository owned by the organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   teamId: JInt (required)
  ##         : Id of team.
  ##   owner: JString (required)
  ##        : Name of a organization.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_780289 = path.getOrDefault("repo")
  valid_780289 = validateParameter(valid_780289, JString, required = true,
                                 default = nil)
  if valid_780289 != nil:
    section.add "repo", valid_780289
  var valid_780290 = path.getOrDefault("teamId")
  valid_780290 = validateParameter(valid_780290, JInt, required = true, default = nil)
  if valid_780290 != nil:
    section.add "teamId", valid_780290
  var valid_780291 = path.getOrDefault("owner")
  valid_780291 = validateParameter(valid_780291, JString, required = true,
                                 default = nil)
  if valid_780291 != nil:
    section.add "owner", valid_780291
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780292 = header.getOrDefault("Accept")
  valid_780292 = validateParameter(valid_780292, JString, required = false,
                                 default = nil)
  if valid_780292 != nil:
    section.add "Accept", valid_780292
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780293: Call_PutTeamsTeamIdReposOwnerRepo_780286; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## In order to add a repository to a team, the authenticated user must be an owner of the org that the team is associated with. Also, the repository must be owned by the organization, or a direct fork of a repository owned by the organization.
  ## 
  let valid = call_780293.validator(path, query, header, formData, body)
  let scheme = call_780293.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780293.url(scheme.get, call_780293.host, call_780293.base,
                         call_780293.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780293, url, valid)

proc call*(call_780294: Call_PutTeamsTeamIdReposOwnerRepo_780286; repo: string;
          teamId: int; owner: string; Accept: string = ""): Recallable =
  ## putTeamsTeamIdReposOwnerRepo
  ## In order to add a repository to a team, the authenticated user must be an owner of the org that the team is associated with. Also, the repository must be owned by the organization, or a direct fork of a repository owned by the organization.
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   teamId: int (required)
  ##         : Id of team.
  ##   owner: string (required)
  ##        : Name of a organization.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780295 = newJObject()
  var header_780296 = newJObject()
  add(path_780295, "repo", newJString(repo))
  add(path_780295, "teamId", newJInt(teamId))
  add(path_780295, "owner", newJString(owner))
  add(header_780296, "Accept", newJString(Accept))
  result = call_780294.call(path_780295, nil, header_780296, nil, nil)

var putTeamsTeamIdReposOwnerRepo* = Call_PutTeamsTeamIdReposOwnerRepo_780286(
    name: "putTeamsTeamIdReposOwnerRepo", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/teams/{teamId}/repos/{owner}/{repo}",
    validator: validate_PutTeamsTeamIdReposOwnerRepo_780287, base: "/",
    url: url_PutTeamsTeamIdReposOwnerRepo_780288, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdReposOwnerRepo_780275 = ref object of OpenApiRestCall_777573
proc url_GetTeamsTeamIdReposOwnerRepo_780277(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdReposOwnerRepo_780276(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Check if a team manages a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   teamId: JInt (required)
  ##         : Id of team.
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_780278 = path.getOrDefault("repo")
  valid_780278 = validateParameter(valid_780278, JString, required = true,
                                 default = nil)
  if valid_780278 != nil:
    section.add "repo", valid_780278
  var valid_780279 = path.getOrDefault("teamId")
  valid_780279 = validateParameter(valid_780279, JInt, required = true, default = nil)
  if valid_780279 != nil:
    section.add "teamId", valid_780279
  var valid_780280 = path.getOrDefault("owner")
  valid_780280 = validateParameter(valid_780280, JString, required = true,
                                 default = nil)
  if valid_780280 != nil:
    section.add "owner", valid_780280
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780281 = header.getOrDefault("Accept")
  valid_780281 = validateParameter(valid_780281, JString, required = false,
                                 default = nil)
  if valid_780281 != nil:
    section.add "Accept", valid_780281
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780282: Call_GetTeamsTeamIdReposOwnerRepo_780275; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Check if a team manages a repository
  ## 
  let valid = call_780282.validator(path, query, header, formData, body)
  let scheme = call_780282.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780282.url(scheme.get, call_780282.host, call_780282.base,
                         call_780282.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780282, url, valid)

proc call*(call_780283: Call_GetTeamsTeamIdReposOwnerRepo_780275; repo: string;
          teamId: int; owner: string; Accept: string = ""): Recallable =
  ## getTeamsTeamIdReposOwnerRepo
  ## Check if a team manages a repository
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   teamId: int (required)
  ##         : Id of team.
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780284 = newJObject()
  var header_780285 = newJObject()
  add(path_780284, "repo", newJString(repo))
  add(path_780284, "teamId", newJInt(teamId))
  add(path_780284, "owner", newJString(owner))
  add(header_780285, "Accept", newJString(Accept))
  result = call_780283.call(path_780284, nil, header_780285, nil, nil)

var getTeamsTeamIdReposOwnerRepo* = Call_GetTeamsTeamIdReposOwnerRepo_780275(
    name: "getTeamsTeamIdReposOwnerRepo", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/teams/{teamId}/repos/{owner}/{repo}",
    validator: validate_GetTeamsTeamIdReposOwnerRepo_780276, base: "/",
    url: url_GetTeamsTeamIdReposOwnerRepo_780277, schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamIdReposOwnerRepo_780297 = ref object of OpenApiRestCall_777573
proc url_DeleteTeamsTeamIdReposOwnerRepo_780299(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamIdReposOwnerRepo_780298(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## In order to remove a repository from a team, the authenticated user must be an owner of the org that the team is associated with. NOTE: This does not delete the repository, it just removes it from the team.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   teamId: JInt (required)
  ##         : Id of team.
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_780300 = path.getOrDefault("repo")
  valid_780300 = validateParameter(valid_780300, JString, required = true,
                                 default = nil)
  if valid_780300 != nil:
    section.add "repo", valid_780300
  var valid_780301 = path.getOrDefault("teamId")
  valid_780301 = validateParameter(valid_780301, JInt, required = true, default = nil)
  if valid_780301 != nil:
    section.add "teamId", valid_780301
  var valid_780302 = path.getOrDefault("owner")
  valid_780302 = validateParameter(valid_780302, JString, required = true,
                                 default = nil)
  if valid_780302 != nil:
    section.add "owner", valid_780302
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780303 = header.getOrDefault("Accept")
  valid_780303 = validateParameter(valid_780303, JString, required = false,
                                 default = nil)
  if valid_780303 != nil:
    section.add "Accept", valid_780303
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780304: Call_DeleteTeamsTeamIdReposOwnerRepo_780297;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## In order to remove a repository from a team, the authenticated user must be an owner of the org that the team is associated with. NOTE: This does not delete the repository, it just removes it from the team.
  ## 
  let valid = call_780304.validator(path, query, header, formData, body)
  let scheme = call_780304.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780304.url(scheme.get, call_780304.host, call_780304.base,
                         call_780304.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780304, url, valid)

proc call*(call_780305: Call_DeleteTeamsTeamIdReposOwnerRepo_780297; repo: string;
          teamId: int; owner: string; Accept: string = ""): Recallable =
  ## deleteTeamsTeamIdReposOwnerRepo
  ## In order to remove a repository from a team, the authenticated user must be an owner of the org that the team is associated with. NOTE: This does not delete the repository, it just removes it from the team.
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   teamId: int (required)
  ##         : Id of team.
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780306 = newJObject()
  var header_780307 = newJObject()
  add(path_780306, "repo", newJString(repo))
  add(path_780306, "teamId", newJInt(teamId))
  add(path_780306, "owner", newJString(owner))
  add(header_780307, "Accept", newJString(Accept))
  result = call_780305.call(path_780306, nil, header_780307, nil, nil)

var deleteTeamsTeamIdReposOwnerRepo* = Call_DeleteTeamsTeamIdReposOwnerRepo_780297(
    name: "deleteTeamsTeamIdReposOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/teams/{teamId}/repos/{owner}/{repo}",
    validator: validate_DeleteTeamsTeamIdReposOwnerRepo_780298, base: "/",
    url: url_DeleteTeamsTeamIdReposOwnerRepo_780299, schemes: {Scheme.Https})
type
  Call_GetUser_780308 = ref object of OpenApiRestCall_777573
proc url_GetUser_780310(protocol: Scheme; host: string; base: string; route: string;
                       path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUser_780309(path: JsonNode; query: JsonNode; header: JsonNode;
                            formData: JsonNode; body: JsonNode): JsonNode =
  ## Get the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780311 = header.getOrDefault("Accept")
  valid_780311 = validateParameter(valid_780311, JString, required = false,
                                 default = nil)
  if valid_780311 != nil:
    section.add "Accept", valid_780311
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780312: Call_GetUser_780308; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get the authenticated user.
  ## 
  let valid = call_780312.validator(path, query, header, formData, body)
  let scheme = call_780312.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780312.url(scheme.get, call_780312.host, call_780312.base,
                         call_780312.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780312, url, valid)

proc call*(call_780313: Call_GetUser_780308; Accept: string = ""): Recallable =
  ## getUser
  ## Get the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_780314 = newJObject()
  add(header_780314, "Accept", newJString(Accept))
  result = call_780313.call(nil, nil, header_780314, nil, nil)

var getUser* = Call_GetUser_780308(name: "getUser", meth: HttpMethod.HttpGet,
                                host: "api.github.com", route: "/user",
                                validator: validate_GetUser_780309, base: "/",
                                url: url_GetUser_780310, schemes: {Scheme.Https})
type
  Call_PatchUser_780315 = ref object of OpenApiRestCall_777573
proc url_PatchUser_780317(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PatchUser_780316(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode): JsonNode =
  ## Update the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780318 = header.getOrDefault("Accept")
  valid_780318 = validateParameter(valid_780318, JString, required = false,
                                 default = nil)
  if valid_780318 != nil:
    section.add "Accept", valid_780318
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_780320: Call_PatchUser_780315; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Update the authenticated user.
  ## 
  let valid = call_780320.validator(path, query, header, formData, body)
  let scheme = call_780320.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780320.url(scheme.get, call_780320.host, call_780320.base,
                         call_780320.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780320, url, valid)

proc call*(call_780321: Call_PatchUser_780315; body: JsonNode; Accept: string = ""): Recallable =
  ## patchUser
  ## Update the authenticated user.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_780322 = newJObject()
  var body_780323 = newJObject()
  if body != nil:
    body_780323 = body
  add(header_780322, "Accept", newJString(Accept))
  result = call_780321.call(nil, nil, header_780322, nil, body_780323)

var patchUser* = Call_PatchUser_780315(name: "patchUser", meth: HttpMethod.HttpPatch,
                                    host: "api.github.com", route: "/user",
                                    validator: validate_PatchUser_780316,
                                    base: "/", url: url_PatchUser_780317,
                                    schemes: {Scheme.Https})
type
  Call_PostUserEmails_780331 = ref object of OpenApiRestCall_777573
proc url_PostUserEmails_780333(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostUserEmails_780332(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Add email address(es).
  ## You can post a single email address or an array of addresses.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780334 = header.getOrDefault("Accept")
  valid_780334 = validateParameter(valid_780334, JString, required = false,
                                 default = nil)
  if valid_780334 != nil:
    section.add "Accept", valid_780334
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_780336: Call_PostUserEmails_780331; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Add email address(es).
  ## You can post a single email address or an array of addresses.
  ## 
  ## 
  let valid = call_780336.validator(path, query, header, formData, body)
  let scheme = call_780336.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780336.url(scheme.get, call_780336.host, call_780336.base,
                         call_780336.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780336, url, valid)

proc call*(call_780337: Call_PostUserEmails_780331; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postUserEmails
  ## Add email address(es).
  ## You can post a single email address or an array of addresses.
  ## 
  ##   body: JArray (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_780338 = newJObject()
  var body_780339 = newJObject()
  if body != nil:
    body_780339 = body
  add(header_780338, "Accept", newJString(Accept))
  result = call_780337.call(nil, nil, header_780338, nil, body_780339)

var postUserEmails* = Call_PostUserEmails_780331(name: "postUserEmails",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/user/emails",
    validator: validate_PostUserEmails_780332, base: "/", url: url_PostUserEmails_780333,
    schemes: {Scheme.Https})
type
  Call_GetUserEmails_780324 = ref object of OpenApiRestCall_777573
proc url_GetUserEmails_780326(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserEmails_780325(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## List email addresses for a user.
  ## In the final version of the API, this method will return an array of hashes
  ## with extended information for each email address indicating if the address
  ## has been verified and if it's primary email address for GitHub.
  ## Until API v3 is finalized, use the application/vnd.github.v3 media type to
  ## get other response format.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780327 = header.getOrDefault("Accept")
  valid_780327 = validateParameter(valid_780327, JString, required = false,
                                 default = nil)
  if valid_780327 != nil:
    section.add "Accept", valid_780327
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780328: Call_GetUserEmails_780324; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List email addresses for a user.
  ## In the final version of the API, this method will return an array of hashes
  ## with extended information for each email address indicating if the address
  ## has been verified and if it's primary email address for GitHub.
  ## Until API v3 is finalized, use the application/vnd.github.v3 media type to
  ## get other response format.
  ## 
  ## 
  let valid = call_780328.validator(path, query, header, formData, body)
  let scheme = call_780328.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780328.url(scheme.get, call_780328.host, call_780328.base,
                         call_780328.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780328, url, valid)

proc call*(call_780329: Call_GetUserEmails_780324; Accept: string = ""): Recallable =
  ## getUserEmails
  ## List email addresses for a user.
  ## In the final version of the API, this method will return an array of hashes
  ## with extended information for each email address indicating if the address
  ## has been verified and if it's primary email address for GitHub.
  ## Until API v3 is finalized, use the application/vnd.github.v3 media type to
  ## get other response format.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_780330 = newJObject()
  add(header_780330, "Accept", newJString(Accept))
  result = call_780329.call(nil, nil, header_780330, nil, nil)

var getUserEmails* = Call_GetUserEmails_780324(name: "getUserEmails",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/emails",
    validator: validate_GetUserEmails_780325, base: "/", url: url_GetUserEmails_780326,
    schemes: {Scheme.Https})
type
  Call_DeleteUserEmails_780340 = ref object of OpenApiRestCall_777573
proc url_DeleteUserEmails_780342(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DeleteUserEmails_780341(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Delete email address(es).
  ## You can include a single email address or an array of addresses.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780343 = header.getOrDefault("Accept")
  valid_780343 = validateParameter(valid_780343, JString, required = false,
                                 default = nil)
  if valid_780343 != nil:
    section.add "Accept", valid_780343
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_780345: Call_DeleteUserEmails_780340; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete email address(es).
  ## You can include a single email address or an array of addresses.
  ## 
  ## 
  let valid = call_780345.validator(path, query, header, formData, body)
  let scheme = call_780345.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780345.url(scheme.get, call_780345.host, call_780345.base,
                         call_780345.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780345, url, valid)

proc call*(call_780346: Call_DeleteUserEmails_780340; body: JsonNode;
          Accept: string = ""): Recallable =
  ## deleteUserEmails
  ## Delete email address(es).
  ## You can include a single email address or an array of addresses.
  ## 
  ##   body: JArray (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_780347 = newJObject()
  var body_780348 = newJObject()
  if body != nil:
    body_780348 = body
  add(header_780347, "Accept", newJString(Accept))
  result = call_780346.call(nil, nil, header_780347, nil, body_780348)

var deleteUserEmails* = Call_DeleteUserEmails_780340(name: "deleteUserEmails",
    meth: HttpMethod.HttpDelete, host: "api.github.com", route: "/user/emails",
    validator: validate_DeleteUserEmails_780341, base: "/",
    url: url_DeleteUserEmails_780342, schemes: {Scheme.Https})
type
  Call_GetUserFollowers_780349 = ref object of OpenApiRestCall_777573
proc url_GetUserFollowers_780351(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserFollowers_780350(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## List the authenticated user's followers
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780352 = header.getOrDefault("Accept")
  valid_780352 = validateParameter(valid_780352, JString, required = false,
                                 default = nil)
  if valid_780352 != nil:
    section.add "Accept", valid_780352
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780353: Call_GetUserFollowers_780349; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List the authenticated user's followers
  ## 
  let valid = call_780353.validator(path, query, header, formData, body)
  let scheme = call_780353.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780353.url(scheme.get, call_780353.host, call_780353.base,
                         call_780353.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780353, url, valid)

proc call*(call_780354: Call_GetUserFollowers_780349; Accept: string = ""): Recallable =
  ## getUserFollowers
  ## List the authenticated user's followers
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_780355 = newJObject()
  add(header_780355, "Accept", newJString(Accept))
  result = call_780354.call(nil, nil, header_780355, nil, nil)

var getUserFollowers* = Call_GetUserFollowers_780349(name: "getUserFollowers",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/followers",
    validator: validate_GetUserFollowers_780350, base: "/",
    url: url_GetUserFollowers_780351, schemes: {Scheme.Https})
type
  Call_GetUserFollowing_780356 = ref object of OpenApiRestCall_777573
proc url_GetUserFollowing_780358(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserFollowing_780357(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## List who the authenticated user is following.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780359 = header.getOrDefault("Accept")
  valid_780359 = validateParameter(valid_780359, JString, required = false,
                                 default = nil)
  if valid_780359 != nil:
    section.add "Accept", valid_780359
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780360: Call_GetUserFollowing_780356; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List who the authenticated user is following.
  ## 
  let valid = call_780360.validator(path, query, header, formData, body)
  let scheme = call_780360.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780360.url(scheme.get, call_780360.host, call_780360.base,
                         call_780360.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780360, url, valid)

proc call*(call_780361: Call_GetUserFollowing_780356; Accept: string = ""): Recallable =
  ## getUserFollowing
  ## List who the authenticated user is following.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_780362 = newJObject()
  add(header_780362, "Accept", newJString(Accept))
  result = call_780361.call(nil, nil, header_780362, nil, nil)

var getUserFollowing* = Call_GetUserFollowing_780356(name: "getUserFollowing",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/following",
    validator: validate_GetUserFollowing_780357, base: "/",
    url: url_GetUserFollowing_780358, schemes: {Scheme.Https})
type
  Call_PutUserFollowingUsername_780372 = ref object of OpenApiRestCall_777573
proc url_PutUserFollowingUsername_780374(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/following/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutUserFollowingUsername_780373(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Follow a user.
  ## Following a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_780375 = path.getOrDefault("username")
  valid_780375 = validateParameter(valid_780375, JString, required = true,
                                 default = nil)
  if valid_780375 != nil:
    section.add "username", valid_780375
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780376 = header.getOrDefault("Accept")
  valid_780376 = validateParameter(valid_780376, JString, required = false,
                                 default = nil)
  if valid_780376 != nil:
    section.add "Accept", valid_780376
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780377: Call_PutUserFollowingUsername_780372; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Follow a user.
  ## Following a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  let valid = call_780377.validator(path, query, header, formData, body)
  let scheme = call_780377.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780377.url(scheme.get, call_780377.host, call_780377.base,
                         call_780377.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780377, url, valid)

proc call*(call_780378: Call_PutUserFollowingUsername_780372; username: string;
          Accept: string = ""): Recallable =
  ## putUserFollowingUsername
  ## Follow a user.
  ## Following a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780379 = newJObject()
  var header_780380 = newJObject()
  add(path_780379, "username", newJString(username))
  add(header_780380, "Accept", newJString(Accept))
  result = call_780378.call(path_780379, nil, header_780380, nil, nil)

var putUserFollowingUsername* = Call_PutUserFollowingUsername_780372(
    name: "putUserFollowingUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/user/following/{username}",
    validator: validate_PutUserFollowingUsername_780373, base: "/",
    url: url_PutUserFollowingUsername_780374, schemes: {Scheme.Https})
type
  Call_GetUserFollowingUsername_780363 = ref object of OpenApiRestCall_777573
proc url_GetUserFollowingUsername_780365(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/following/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserFollowingUsername_780364(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Check if you are following a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_780366 = path.getOrDefault("username")
  valid_780366 = validateParameter(valid_780366, JString, required = true,
                                 default = nil)
  if valid_780366 != nil:
    section.add "username", valid_780366
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780367 = header.getOrDefault("Accept")
  valid_780367 = validateParameter(valid_780367, JString, required = false,
                                 default = nil)
  if valid_780367 != nil:
    section.add "Accept", valid_780367
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780368: Call_GetUserFollowingUsername_780363; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Check if you are following a user.
  ## 
  let valid = call_780368.validator(path, query, header, formData, body)
  let scheme = call_780368.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780368.url(scheme.get, call_780368.host, call_780368.base,
                         call_780368.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780368, url, valid)

proc call*(call_780369: Call_GetUserFollowingUsername_780363; username: string;
          Accept: string = ""): Recallable =
  ## getUserFollowingUsername
  ## Check if you are following a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780370 = newJObject()
  var header_780371 = newJObject()
  add(path_780370, "username", newJString(username))
  add(header_780371, "Accept", newJString(Accept))
  result = call_780369.call(path_780370, nil, header_780371, nil, nil)

var getUserFollowingUsername* = Call_GetUserFollowingUsername_780363(
    name: "getUserFollowingUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/user/following/{username}",
    validator: validate_GetUserFollowingUsername_780364, base: "/",
    url: url_GetUserFollowingUsername_780365, schemes: {Scheme.Https})
type
  Call_DeleteUserFollowingUsername_780381 = ref object of OpenApiRestCall_777573
proc url_DeleteUserFollowingUsername_780383(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/following/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserFollowingUsername_780382(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Unfollow a user.
  ## Unfollowing a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_780384 = path.getOrDefault("username")
  valid_780384 = validateParameter(valid_780384, JString, required = true,
                                 default = nil)
  if valid_780384 != nil:
    section.add "username", valid_780384
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780385 = header.getOrDefault("Accept")
  valid_780385 = validateParameter(valid_780385, JString, required = false,
                                 default = nil)
  if valid_780385 != nil:
    section.add "Accept", valid_780385
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780386: Call_DeleteUserFollowingUsername_780381; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Unfollow a user.
  ## Unfollowing a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  let valid = call_780386.validator(path, query, header, formData, body)
  let scheme = call_780386.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780386.url(scheme.get, call_780386.host, call_780386.base,
                         call_780386.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780386, url, valid)

proc call*(call_780387: Call_DeleteUserFollowingUsername_780381; username: string;
          Accept: string = ""): Recallable =
  ## deleteUserFollowingUsername
  ## Unfollow a user.
  ## Unfollowing a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780388 = newJObject()
  var header_780389 = newJObject()
  add(path_780388, "username", newJString(username))
  add(header_780389, "Accept", newJString(Accept))
  result = call_780387.call(path_780388, nil, header_780389, nil, nil)

var deleteUserFollowingUsername* = Call_DeleteUserFollowingUsername_780381(
    name: "deleteUserFollowingUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/following/{username}",
    validator: validate_DeleteUserFollowingUsername_780382, base: "/",
    url: url_DeleteUserFollowingUsername_780383, schemes: {Scheme.Https})
type
  Call_GetUserIssues_780390 = ref object of OpenApiRestCall_777573
proc url_GetUserIssues_780392(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserIssues_780391(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## List issues.
  ## List all issues across owned and member repositories for the authenticated
  ## user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   direction: JString (required)
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  ##   state: JString (required)
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   sort: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `labels` field"
  var valid_780393 = query.getOrDefault("labels")
  valid_780393 = validateParameter(valid_780393, JString, required = true,
                                 default = nil)
  if valid_780393 != nil:
    section.add "labels", valid_780393
  var valid_780394 = query.getOrDefault("direction")
  valid_780394 = validateParameter(valid_780394, JString, required = true,
                                 default = newJString("desc"))
  if valid_780394 != nil:
    section.add "direction", valid_780394
  var valid_780395 = query.getOrDefault("since")
  valid_780395 = validateParameter(valid_780395, JString, required = false,
                                 default = nil)
  if valid_780395 != nil:
    section.add "since", valid_780395
  var valid_780396 = query.getOrDefault("state")
  valid_780396 = validateParameter(valid_780396, JString, required = true,
                                 default = newJString("open"))
  if valid_780396 != nil:
    section.add "state", valid_780396
  var valid_780397 = query.getOrDefault("filter")
  valid_780397 = validateParameter(valid_780397, JString, required = true,
                                 default = newJString("all"))
  if valid_780397 != nil:
    section.add "filter", valid_780397
  var valid_780398 = query.getOrDefault("sort")
  valid_780398 = validateParameter(valid_780398, JString, required = true,
                                 default = newJString("created"))
  if valid_780398 != nil:
    section.add "sort", valid_780398
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780399 = header.getOrDefault("Accept")
  valid_780399 = validateParameter(valid_780399, JString, required = false,
                                 default = nil)
  if valid_780399 != nil:
    section.add "Accept", valid_780399
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780400: Call_GetUserIssues_780390; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List issues.
  ## List all issues across owned and member repositories for the authenticated
  ## user.
  ## 
  ## 
  let valid = call_780400.validator(path, query, header, formData, body)
  let scheme = call_780400.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780400.url(scheme.get, call_780400.host, call_780400.base,
                         call_780400.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780400, url, valid)

proc call*(call_780401: Call_GetUserIssues_780390; labels: string;
          direction: string = "desc"; since: string = ""; state: string = "open";
          filter: string = "all"; Accept: string = ""; sort: string = "created"): Recallable =
  ## getUserIssues
  ## List issues.
  ## List all issues across owned and member repositories for the authenticated
  ## user.
  ## 
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   direction: string (required)
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  ##   state: string (required)
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string (required)
  var query_780402 = newJObject()
  var header_780403 = newJObject()
  add(query_780402, "labels", newJString(labels))
  add(query_780402, "direction", newJString(direction))
  add(query_780402, "since", newJString(since))
  add(query_780402, "state", newJString(state))
  add(query_780402, "filter", newJString(filter))
  add(header_780403, "Accept", newJString(Accept))
  add(query_780402, "sort", newJString(sort))
  result = call_780401.call(nil, query_780402, header_780403, nil, nil)

var getUserIssues* = Call_GetUserIssues_780390(name: "getUserIssues",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/issues",
    validator: validate_GetUserIssues_780391, base: "/", url: url_GetUserIssues_780392,
    schemes: {Scheme.Https})
type
  Call_PostUserKeys_780411 = ref object of OpenApiRestCall_777573
proc url_PostUserKeys_780413(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostUserKeys_780412(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a public key.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780414 = header.getOrDefault("Accept")
  valid_780414 = validateParameter(valid_780414, JString, required = false,
                                 default = nil)
  if valid_780414 != nil:
    section.add "Accept", valid_780414
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_780416: Call_PostUserKeys_780411; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a public key.
  ## 
  let valid = call_780416.validator(path, query, header, formData, body)
  let scheme = call_780416.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780416.url(scheme.get, call_780416.host, call_780416.base,
                         call_780416.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780416, url, valid)

proc call*(call_780417: Call_PostUserKeys_780411; body: JsonNode; Accept: string = ""): Recallable =
  ## postUserKeys
  ## Create a public key.
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_780418 = newJObject()
  var body_780419 = newJObject()
  if body != nil:
    body_780419 = body
  add(header_780418, "Accept", newJString(Accept))
  result = call_780417.call(nil, nil, header_780418, nil, body_780419)

var postUserKeys* = Call_PostUserKeys_780411(name: "postUserKeys",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/user/keys",
    validator: validate_PostUserKeys_780412, base: "/", url: url_PostUserKeys_780413,
    schemes: {Scheme.Https})
type
  Call_GetUserKeys_780404 = ref object of OpenApiRestCall_777573
proc url_GetUserKeys_780406(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserKeys_780405(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## List your public keys.
  ## Lists the current user's keys. Management of public keys via the API requires
  ## that you are authenticated through basic auth, or OAuth with the 'user', 'write:public_key' scopes.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780407 = header.getOrDefault("Accept")
  valid_780407 = validateParameter(valid_780407, JString, required = false,
                                 default = nil)
  if valid_780407 != nil:
    section.add "Accept", valid_780407
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780408: Call_GetUserKeys_780404; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List your public keys.
  ## Lists the current user's keys. Management of public keys via the API requires
  ## that you are authenticated through basic auth, or OAuth with the 'user', 'write:public_key' scopes.
  ## 
  ## 
  let valid = call_780408.validator(path, query, header, formData, body)
  let scheme = call_780408.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780408.url(scheme.get, call_780408.host, call_780408.base,
                         call_780408.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780408, url, valid)

proc call*(call_780409: Call_GetUserKeys_780404; Accept: string = ""): Recallable =
  ## getUserKeys
  ## List your public keys.
  ## Lists the current user's keys. Management of public keys via the API requires
  ## that you are authenticated through basic auth, or OAuth with the 'user', 'write:public_key' scopes.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_780410 = newJObject()
  add(header_780410, "Accept", newJString(Accept))
  result = call_780409.call(nil, nil, header_780410, nil, nil)

var getUserKeys* = Call_GetUserKeys_780404(name: "getUserKeys",
                                        meth: HttpMethod.HttpGet,
                                        host: "api.github.com",
                                        route: "/user/keys",
                                        validator: validate_GetUserKeys_780405,
                                        base: "/", url: url_GetUserKeys_780406,
                                        schemes: {Scheme.Https})
type
  Call_GetUserKeysKeyId_780420 = ref object of OpenApiRestCall_777573
proc url_GetUserKeysKeyId_780422(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/keys/"),
               (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserKeysKeyId_780421(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Get a single public key.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyId: JInt (required)
  ##        : ID of key.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyId` field"
  var valid_780423 = path.getOrDefault("keyId")
  valid_780423 = validateParameter(valid_780423, JInt, required = true, default = nil)
  if valid_780423 != nil:
    section.add "keyId", valid_780423
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780424 = header.getOrDefault("Accept")
  valid_780424 = validateParameter(valid_780424, JString, required = false,
                                 default = nil)
  if valid_780424 != nil:
    section.add "Accept", valid_780424
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780425: Call_GetUserKeysKeyId_780420; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a single public key.
  ## 
  let valid = call_780425.validator(path, query, header, formData, body)
  let scheme = call_780425.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780425.url(scheme.get, call_780425.host, call_780425.base,
                         call_780425.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780425, url, valid)

proc call*(call_780426: Call_GetUserKeysKeyId_780420; keyId: int; Accept: string = ""): Recallable =
  ## getUserKeysKeyId
  ## Get a single public key.
  ##   keyId: int (required)
  ##        : ID of key.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780427 = newJObject()
  var header_780428 = newJObject()
  add(path_780427, "keyId", newJInt(keyId))
  add(header_780428, "Accept", newJString(Accept))
  result = call_780426.call(path_780427, nil, header_780428, nil, nil)

var getUserKeysKeyId* = Call_GetUserKeysKeyId_780420(name: "getUserKeysKeyId",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/keys/{keyId}",
    validator: validate_GetUserKeysKeyId_780421, base: "/",
    url: url_GetUserKeysKeyId_780422, schemes: {Scheme.Https})
type
  Call_DeleteUserKeysKeyId_780429 = ref object of OpenApiRestCall_777573
proc url_DeleteUserKeysKeyId_780431(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/keys/"),
               (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserKeysKeyId_780430(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Delete a public key. Removes a public key. Requires that you are authenticated via Basic Auth or via OAuth with at least admin:public_key scope.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyId: JInt (required)
  ##        : ID of key.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyId` field"
  var valid_780432 = path.getOrDefault("keyId")
  valid_780432 = validateParameter(valid_780432, JInt, required = true, default = nil)
  if valid_780432 != nil:
    section.add "keyId", valid_780432
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780433 = header.getOrDefault("Accept")
  valid_780433 = validateParameter(valid_780433, JString, required = false,
                                 default = nil)
  if valid_780433 != nil:
    section.add "Accept", valid_780433
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780434: Call_DeleteUserKeysKeyId_780429; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Delete a public key. Removes a public key. Requires that you are authenticated via Basic Auth or via OAuth with at least admin:public_key scope.
  ## 
  let valid = call_780434.validator(path, query, header, formData, body)
  let scheme = call_780434.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780434.url(scheme.get, call_780434.host, call_780434.base,
                         call_780434.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780434, url, valid)

proc call*(call_780435: Call_DeleteUserKeysKeyId_780429; keyId: int;
          Accept: string = ""): Recallable =
  ## deleteUserKeysKeyId
  ## Delete a public key. Removes a public key. Requires that you are authenticated via Basic Auth or via OAuth with at least admin:public_key scope.
  ##   keyId: int (required)
  ##        : ID of key.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780436 = newJObject()
  var header_780437 = newJObject()
  add(path_780436, "keyId", newJInt(keyId))
  add(header_780437, "Accept", newJString(Accept))
  result = call_780435.call(path_780436, nil, header_780437, nil, nil)

var deleteUserKeysKeyId* = Call_DeleteUserKeysKeyId_780429(
    name: "deleteUserKeysKeyId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/keys/{keyId}",
    validator: validate_DeleteUserKeysKeyId_780430, base: "/",
    url: url_DeleteUserKeysKeyId_780431, schemes: {Scheme.Https})
type
  Call_GetUserOrgs_780438 = ref object of OpenApiRestCall_777573
proc url_GetUserOrgs_780440(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserOrgs_780439(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode): JsonNode =
  ## List public and private organizations for the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780441 = header.getOrDefault("Accept")
  valid_780441 = validateParameter(valid_780441, JString, required = false,
                                 default = nil)
  if valid_780441 != nil:
    section.add "Accept", valid_780441
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780442: Call_GetUserOrgs_780438; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List public and private organizations for the authenticated user.
  ## 
  let valid = call_780442.validator(path, query, header, formData, body)
  let scheme = call_780442.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780442.url(scheme.get, call_780442.host, call_780442.base,
                         call_780442.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780442, url, valid)

proc call*(call_780443: Call_GetUserOrgs_780438; Accept: string = ""): Recallable =
  ## getUserOrgs
  ## List public and private organizations for the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_780444 = newJObject()
  add(header_780444, "Accept", newJString(Accept))
  result = call_780443.call(nil, nil, header_780444, nil, nil)

var getUserOrgs* = Call_GetUserOrgs_780438(name: "getUserOrgs",
                                        meth: HttpMethod.HttpGet,
                                        host: "api.github.com",
                                        route: "/user/orgs",
                                        validator: validate_GetUserOrgs_780439,
                                        base: "/", url: url_GetUserOrgs_780440,
                                        schemes: {Scheme.Https})
type
  Call_PostUserRepos_780454 = ref object of OpenApiRestCall_777573
proc url_PostUserRepos_780456(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostUserRepos_780455(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780457 = header.getOrDefault("Accept")
  valid_780457 = validateParameter(valid_780457, JString, required = false,
                                 default = nil)
  if valid_780457 != nil:
    section.add "Accept", valid_780457
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_780459: Call_PostUserRepos_780454; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  let valid = call_780459.validator(path, query, header, formData, body)
  let scheme = call_780459.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780459.url(scheme.get, call_780459.host, call_780459.base,
                         call_780459.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780459, url, valid)

proc call*(call_780460: Call_PostUserRepos_780454; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postUserRepos
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ##   body: JObject (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_780461 = newJObject()
  var body_780462 = newJObject()
  if body != nil:
    body_780462 = body
  add(header_780461, "Accept", newJString(Accept))
  result = call_780460.call(nil, nil, header_780461, nil, body_780462)

var postUserRepos* = Call_PostUserRepos_780454(name: "postUserRepos",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/user/repos",
    validator: validate_PostUserRepos_780455, base: "/", url: url_PostUserRepos_780456,
    schemes: {Scheme.Https})
type
  Call_GetUserRepos_780445 = ref object of OpenApiRestCall_777573
proc url_GetUserRepos_780447(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserRepos_780446(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## List repositories for the authenticated user. Note that this does not include
  ## repositories owned by organizations which the user can access. You can lis
  ## user organizations and list organization repositories separately.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   type: JString
  section = newJObject()
  var valid_780448 = query.getOrDefault("type")
  valid_780448 = validateParameter(valid_780448, JString, required = false,
                                 default = newJString("all"))
  if valid_780448 != nil:
    section.add "type", valid_780448
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780449 = header.getOrDefault("Accept")
  valid_780449 = validateParameter(valid_780449, JString, required = false,
                                 default = nil)
  if valid_780449 != nil:
    section.add "Accept", valid_780449
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780450: Call_GetUserRepos_780445; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List repositories for the authenticated user. Note that this does not include
  ## repositories owned by organizations which the user can access. You can lis
  ## user organizations and list organization repositories separately.
  ## 
  ## 
  let valid = call_780450.validator(path, query, header, formData, body)
  let scheme = call_780450.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780450.url(scheme.get, call_780450.host, call_780450.base,
                         call_780450.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780450, url, valid)

proc call*(call_780451: Call_GetUserRepos_780445; `type`: string = "all";
          Accept: string = ""): Recallable =
  ## getUserRepos
  ## List repositories for the authenticated user. Note that this does not include
  ## repositories owned by organizations which the user can access. You can lis
  ## user organizations and list organization repositories separately.
  ## 
  ##   type: string
  ##   Accept: string
  ##         : Is used to set specified media type.
  var query_780452 = newJObject()
  var header_780453 = newJObject()
  add(query_780452, "type", newJString(`type`))
  add(header_780453, "Accept", newJString(Accept))
  result = call_780451.call(nil, query_780452, header_780453, nil, nil)

var getUserRepos* = Call_GetUserRepos_780445(name: "getUserRepos",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/repos",
    validator: validate_GetUserRepos_780446, base: "/", url: url_GetUserRepos_780447,
    schemes: {Scheme.Https})
type
  Call_GetUserStarred_780463 = ref object of OpenApiRestCall_777573
proc url_GetUserStarred_780465(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserStarred_780464(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## List repositories being starred by the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  ##   sort: JString
  section = newJObject()
  var valid_780466 = query.getOrDefault("direction")
  valid_780466 = validateParameter(valid_780466, JString, required = false,
                                 default = nil)
  if valid_780466 != nil:
    section.add "direction", valid_780466
  var valid_780467 = query.getOrDefault("sort")
  valid_780467 = validateParameter(valid_780467, JString, required = false,
                                 default = newJString("created"))
  if valid_780467 != nil:
    section.add "sort", valid_780467
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780468 = header.getOrDefault("Accept")
  valid_780468 = validateParameter(valid_780468, JString, required = false,
                                 default = nil)
  if valid_780468 != nil:
    section.add "Accept", valid_780468
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780469: Call_GetUserStarred_780463; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List repositories being starred by the authenticated user.
  ## 
  let valid = call_780469.validator(path, query, header, formData, body)
  let scheme = call_780469.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780469.url(scheme.get, call_780469.host, call_780469.base,
                         call_780469.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780469, url, valid)

proc call*(call_780470: Call_GetUserStarred_780463; direction: string = "";
          Accept: string = ""; sort: string = "created"): Recallable =
  ## getUserStarred
  ## List repositories being starred by the authenticated user.
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  var query_780471 = newJObject()
  var header_780472 = newJObject()
  add(query_780471, "direction", newJString(direction))
  add(header_780472, "Accept", newJString(Accept))
  add(query_780471, "sort", newJString(sort))
  result = call_780470.call(nil, query_780471, header_780472, nil, nil)

var getUserStarred* = Call_GetUserStarred_780463(name: "getUserStarred",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/starred",
    validator: validate_GetUserStarred_780464, base: "/", url: url_GetUserStarred_780465,
    schemes: {Scheme.Https})
type
  Call_PutUserStarredOwnerRepo_780483 = ref object of OpenApiRestCall_777573
proc url_PutUserStarredOwnerRepo_780485(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/starred/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutUserStarredOwnerRepo_780484(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Star a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_780486 = path.getOrDefault("repo")
  valid_780486 = validateParameter(valid_780486, JString, required = true,
                                 default = nil)
  if valid_780486 != nil:
    section.add "repo", valid_780486
  var valid_780487 = path.getOrDefault("owner")
  valid_780487 = validateParameter(valid_780487, JString, required = true,
                                 default = nil)
  if valid_780487 != nil:
    section.add "owner", valid_780487
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780488 = header.getOrDefault("Accept")
  valid_780488 = validateParameter(valid_780488, JString, required = false,
                                 default = nil)
  if valid_780488 != nil:
    section.add "Accept", valid_780488
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780489: Call_PutUserStarredOwnerRepo_780483; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Star a repository.
  ## 
  let valid = call_780489.validator(path, query, header, formData, body)
  let scheme = call_780489.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780489.url(scheme.get, call_780489.host, call_780489.base,
                         call_780489.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780489, url, valid)

proc call*(call_780490: Call_PutUserStarredOwnerRepo_780483; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## putUserStarredOwnerRepo
  ## Star a repository.
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780491 = newJObject()
  var header_780492 = newJObject()
  add(path_780491, "repo", newJString(repo))
  add(path_780491, "owner", newJString(owner))
  add(header_780492, "Accept", newJString(Accept))
  result = call_780490.call(path_780491, nil, header_780492, nil, nil)

var putUserStarredOwnerRepo* = Call_PutUserStarredOwnerRepo_780483(
    name: "putUserStarredOwnerRepo", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/user/starred/{owner}/{repo}",
    validator: validate_PutUserStarredOwnerRepo_780484, base: "/",
    url: url_PutUserStarredOwnerRepo_780485, schemes: {Scheme.Https})
type
  Call_GetUserStarredOwnerRepo_780473 = ref object of OpenApiRestCall_777573
proc url_GetUserStarredOwnerRepo_780475(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/starred/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserStarredOwnerRepo_780474(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Check if you are starring a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_780476 = path.getOrDefault("repo")
  valid_780476 = validateParameter(valid_780476, JString, required = true,
                                 default = nil)
  if valid_780476 != nil:
    section.add "repo", valid_780476
  var valid_780477 = path.getOrDefault("owner")
  valid_780477 = validateParameter(valid_780477, JString, required = true,
                                 default = nil)
  if valid_780477 != nil:
    section.add "owner", valid_780477
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780478 = header.getOrDefault("Accept")
  valid_780478 = validateParameter(valid_780478, JString, required = false,
                                 default = nil)
  if valid_780478 != nil:
    section.add "Accept", valid_780478
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780479: Call_GetUserStarredOwnerRepo_780473; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Check if you are starring a repository.
  ## 
  let valid = call_780479.validator(path, query, header, formData, body)
  let scheme = call_780479.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780479.url(scheme.get, call_780479.host, call_780479.base,
                         call_780479.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780479, url, valid)

proc call*(call_780480: Call_GetUserStarredOwnerRepo_780473; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getUserStarredOwnerRepo
  ## Check if you are starring a repository.
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780481 = newJObject()
  var header_780482 = newJObject()
  add(path_780481, "repo", newJString(repo))
  add(path_780481, "owner", newJString(owner))
  add(header_780482, "Accept", newJString(Accept))
  result = call_780480.call(path_780481, nil, header_780482, nil, nil)

var getUserStarredOwnerRepo* = Call_GetUserStarredOwnerRepo_780473(
    name: "getUserStarredOwnerRepo", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/user/starred/{owner}/{repo}",
    validator: validate_GetUserStarredOwnerRepo_780474, base: "/",
    url: url_GetUserStarredOwnerRepo_780475, schemes: {Scheme.Https})
type
  Call_DeleteUserStarredOwnerRepo_780493 = ref object of OpenApiRestCall_777573
proc url_DeleteUserStarredOwnerRepo_780495(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/starred/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserStarredOwnerRepo_780494(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Unstar a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_780496 = path.getOrDefault("repo")
  valid_780496 = validateParameter(valid_780496, JString, required = true,
                                 default = nil)
  if valid_780496 != nil:
    section.add "repo", valid_780496
  var valid_780497 = path.getOrDefault("owner")
  valid_780497 = validateParameter(valid_780497, JString, required = true,
                                 default = nil)
  if valid_780497 != nil:
    section.add "owner", valid_780497
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780498 = header.getOrDefault("Accept")
  valid_780498 = validateParameter(valid_780498, JString, required = false,
                                 default = nil)
  if valid_780498 != nil:
    section.add "Accept", valid_780498
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780499: Call_DeleteUserStarredOwnerRepo_780493; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Unstar a repository
  ## 
  let valid = call_780499.validator(path, query, header, formData, body)
  let scheme = call_780499.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780499.url(scheme.get, call_780499.host, call_780499.base,
                         call_780499.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780499, url, valid)

proc call*(call_780500: Call_DeleteUserStarredOwnerRepo_780493; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## deleteUserStarredOwnerRepo
  ## Unstar a repository
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780501 = newJObject()
  var header_780502 = newJObject()
  add(path_780501, "repo", newJString(repo))
  add(path_780501, "owner", newJString(owner))
  add(header_780502, "Accept", newJString(Accept))
  result = call_780500.call(path_780501, nil, header_780502, nil, nil)

var deleteUserStarredOwnerRepo* = Call_DeleteUserStarredOwnerRepo_780493(
    name: "deleteUserStarredOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/starred/{owner}/{repo}",
    validator: validate_DeleteUserStarredOwnerRepo_780494, base: "/",
    url: url_DeleteUserStarredOwnerRepo_780495, schemes: {Scheme.Https})
type
  Call_GetUserSubscriptions_780503 = ref object of OpenApiRestCall_777573
proc url_GetUserSubscriptions_780505(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserSubscriptions_780504(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List repositories being watched by the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780506 = header.getOrDefault("Accept")
  valid_780506 = validateParameter(valid_780506, JString, required = false,
                                 default = nil)
  if valid_780506 != nil:
    section.add "Accept", valid_780506
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780507: Call_GetUserSubscriptions_780503; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List repositories being watched by the authenticated user.
  ## 
  let valid = call_780507.validator(path, query, header, formData, body)
  let scheme = call_780507.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780507.url(scheme.get, call_780507.host, call_780507.base,
                         call_780507.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780507, url, valid)

proc call*(call_780508: Call_GetUserSubscriptions_780503; Accept: string = ""): Recallable =
  ## getUserSubscriptions
  ## List repositories being watched by the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_780509 = newJObject()
  add(header_780509, "Accept", newJString(Accept))
  result = call_780508.call(nil, nil, header_780509, nil, nil)

var getUserSubscriptions* = Call_GetUserSubscriptions_780503(
    name: "getUserSubscriptions", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/user/subscriptions", validator: validate_GetUserSubscriptions_780504,
    base: "/", url: url_GetUserSubscriptions_780505, schemes: {Scheme.Https})
type
  Call_PutUserSubscriptionsOwnerRepo_780520 = ref object of OpenApiRestCall_777573
proc url_PutUserSubscriptionsOwnerRepo_780522(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/subscriptions/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutUserSubscriptionsOwnerRepo_780521(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Watch a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of the owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_780523 = path.getOrDefault("repo")
  valid_780523 = validateParameter(valid_780523, JString, required = true,
                                 default = nil)
  if valid_780523 != nil:
    section.add "repo", valid_780523
  var valid_780524 = path.getOrDefault("owner")
  valid_780524 = validateParameter(valid_780524, JString, required = true,
                                 default = nil)
  if valid_780524 != nil:
    section.add "owner", valid_780524
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780525 = header.getOrDefault("Accept")
  valid_780525 = validateParameter(valid_780525, JString, required = false,
                                 default = nil)
  if valid_780525 != nil:
    section.add "Accept", valid_780525
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780526: Call_PutUserSubscriptionsOwnerRepo_780520; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Watch a repository.
  ## 
  let valid = call_780526.validator(path, query, header, formData, body)
  let scheme = call_780526.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780526.url(scheme.get, call_780526.host, call_780526.base,
                         call_780526.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780526, url, valid)

proc call*(call_780527: Call_PutUserSubscriptionsOwnerRepo_780520; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## putUserSubscriptionsOwnerRepo
  ## Watch a repository.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of the owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780528 = newJObject()
  var header_780529 = newJObject()
  add(path_780528, "repo", newJString(repo))
  add(path_780528, "owner", newJString(owner))
  add(header_780529, "Accept", newJString(Accept))
  result = call_780527.call(path_780528, nil, header_780529, nil, nil)

var putUserSubscriptionsOwnerRepo* = Call_PutUserSubscriptionsOwnerRepo_780520(
    name: "putUserSubscriptionsOwnerRepo", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/user/subscriptions/{owner}/{repo}",
    validator: validate_PutUserSubscriptionsOwnerRepo_780521, base: "/",
    url: url_PutUserSubscriptionsOwnerRepo_780522, schemes: {Scheme.Https})
type
  Call_GetUserSubscriptionsOwnerRepo_780510 = ref object of OpenApiRestCall_777573
proc url_GetUserSubscriptionsOwnerRepo_780512(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/subscriptions/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserSubscriptionsOwnerRepo_780511(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Check if you are watching a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of the owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_780513 = path.getOrDefault("repo")
  valid_780513 = validateParameter(valid_780513, JString, required = true,
                                 default = nil)
  if valid_780513 != nil:
    section.add "repo", valid_780513
  var valid_780514 = path.getOrDefault("owner")
  valid_780514 = validateParameter(valid_780514, JString, required = true,
                                 default = nil)
  if valid_780514 != nil:
    section.add "owner", valid_780514
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780515 = header.getOrDefault("Accept")
  valid_780515 = validateParameter(valid_780515, JString, required = false,
                                 default = nil)
  if valid_780515 != nil:
    section.add "Accept", valid_780515
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780516: Call_GetUserSubscriptionsOwnerRepo_780510; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Check if you are watching a repository.
  ## 
  let valid = call_780516.validator(path, query, header, formData, body)
  let scheme = call_780516.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780516.url(scheme.get, call_780516.host, call_780516.base,
                         call_780516.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780516, url, valid)

proc call*(call_780517: Call_GetUserSubscriptionsOwnerRepo_780510; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getUserSubscriptionsOwnerRepo
  ## Check if you are watching a repository.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of the owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780518 = newJObject()
  var header_780519 = newJObject()
  add(path_780518, "repo", newJString(repo))
  add(path_780518, "owner", newJString(owner))
  add(header_780519, "Accept", newJString(Accept))
  result = call_780517.call(path_780518, nil, header_780519, nil, nil)

var getUserSubscriptionsOwnerRepo* = Call_GetUserSubscriptionsOwnerRepo_780510(
    name: "getUserSubscriptionsOwnerRepo", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/user/subscriptions/{owner}/{repo}",
    validator: validate_GetUserSubscriptionsOwnerRepo_780511, base: "/",
    url: url_GetUserSubscriptionsOwnerRepo_780512, schemes: {Scheme.Https})
type
  Call_DeleteUserSubscriptionsOwnerRepo_780530 = ref object of OpenApiRestCall_777573
proc url_DeleteUserSubscriptionsOwnerRepo_780532(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/subscriptions/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserSubscriptionsOwnerRepo_780531(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Stop watching a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of the owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_780533 = path.getOrDefault("repo")
  valid_780533 = validateParameter(valid_780533, JString, required = true,
                                 default = nil)
  if valid_780533 != nil:
    section.add "repo", valid_780533
  var valid_780534 = path.getOrDefault("owner")
  valid_780534 = validateParameter(valid_780534, JString, required = true,
                                 default = nil)
  if valid_780534 != nil:
    section.add "owner", valid_780534
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780535 = header.getOrDefault("Accept")
  valid_780535 = validateParameter(valid_780535, JString, required = false,
                                 default = nil)
  if valid_780535 != nil:
    section.add "Accept", valid_780535
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780536: Call_DeleteUserSubscriptionsOwnerRepo_780530;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Stop watching a repository
  ## 
  let valid = call_780536.validator(path, query, header, formData, body)
  let scheme = call_780536.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780536.url(scheme.get, call_780536.host, call_780536.base,
                         call_780536.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780536, url, valid)

proc call*(call_780537: Call_DeleteUserSubscriptionsOwnerRepo_780530; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## deleteUserSubscriptionsOwnerRepo
  ## Stop watching a repository
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of the owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780538 = newJObject()
  var header_780539 = newJObject()
  add(path_780538, "repo", newJString(repo))
  add(path_780538, "owner", newJString(owner))
  add(header_780539, "Accept", newJString(Accept))
  result = call_780537.call(path_780538, nil, header_780539, nil, nil)

var deleteUserSubscriptionsOwnerRepo* = Call_DeleteUserSubscriptionsOwnerRepo_780530(
    name: "deleteUserSubscriptionsOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/subscriptions/{owner}/{repo}",
    validator: validate_DeleteUserSubscriptionsOwnerRepo_780531, base: "/",
    url: url_DeleteUserSubscriptionsOwnerRepo_780532, schemes: {Scheme.Https})
type
  Call_GetUserTeams_780540 = ref object of OpenApiRestCall_777573
proc url_GetUserTeams_780542(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserTeams_780541(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode): JsonNode =
  ## List all of the teams across all of the organizations to which the authenticated user belongs. This method requires user or repo scope when authenticating via OAuth.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780543 = header.getOrDefault("Accept")
  valid_780543 = validateParameter(valid_780543, JString, required = false,
                                 default = nil)
  if valid_780543 != nil:
    section.add "Accept", valid_780543
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780544: Call_GetUserTeams_780540; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List all of the teams across all of the organizations to which the authenticated user belongs. This method requires user or repo scope when authenticating via OAuth.
  ## 
  let valid = call_780544.validator(path, query, header, formData, body)
  let scheme = call_780544.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780544.url(scheme.get, call_780544.host, call_780544.base,
                         call_780544.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780544, url, valid)

proc call*(call_780545: Call_GetUserTeams_780540; Accept: string = ""): Recallable =
  ## getUserTeams
  ## List all of the teams across all of the organizations to which the authenticated user belongs. This method requires user or repo scope when authenticating via OAuth.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_780546 = newJObject()
  add(header_780546, "Accept", newJString(Accept))
  result = call_780545.call(nil, nil, header_780546, nil, nil)

var getUserTeams* = Call_GetUserTeams_780540(name: "getUserTeams",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/teams",
    validator: validate_GetUserTeams_780541, base: "/", url: url_GetUserTeams_780542,
    schemes: {Scheme.Https})
type
  Call_GetUsers_780547 = ref object of OpenApiRestCall_777573
proc url_GetUsers_780549(protocol: Scheme; host: string; base: string; route: string;
                        path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUsers_780548(path: JsonNode; query: JsonNode; header: JsonNode;
                             formData: JsonNode; body: JsonNode): JsonNode =
  ## Get all users.
  ## This provides a dump of every user, in the order that they signed up for GitHub.
  ## Note: Pagination is powered exclusively by the since parameter. Use the Link
  ## header to get the URL for the next page of users.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JInt
  ##        : The integer ID of the last user that you've seen.
  section = newJObject()
  var valid_780550 = query.getOrDefault("since")
  valid_780550 = validateParameter(valid_780550, JInt, required = false, default = nil)
  if valid_780550 != nil:
    section.add "since", valid_780550
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780551 = header.getOrDefault("Accept")
  valid_780551 = validateParameter(valid_780551, JString, required = false,
                                 default = nil)
  if valid_780551 != nil:
    section.add "Accept", valid_780551
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780552: Call_GetUsers_780547; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get all users.
  ## This provides a dump of every user, in the order that they signed up for GitHub.
  ## Note: Pagination is powered exclusively by the since parameter. Use the Link
  ## header to get the URL for the next page of users.
  ## 
  ## 
  let valid = call_780552.validator(path, query, header, formData, body)
  let scheme = call_780552.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780552.url(scheme.get, call_780552.host, call_780552.base,
                         call_780552.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780552, url, valid)

proc call*(call_780553: Call_GetUsers_780547; since: int = 0; Accept: string = ""): Recallable =
  ## getUsers
  ## Get all users.
  ## This provides a dump of every user, in the order that they signed up for GitHub.
  ## Note: Pagination is powered exclusively by the since parameter. Use the Link
  ## header to get the URL for the next page of users.
  ## 
  ##   since: int
  ##        : The integer ID of the last user that you've seen.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var query_780554 = newJObject()
  var header_780555 = newJObject()
  add(query_780554, "since", newJInt(since))
  add(header_780555, "Accept", newJString(Accept))
  result = call_780553.call(nil, query_780554, header_780555, nil, nil)

var getUsers* = Call_GetUsers_780547(name: "getUsers", meth: HttpMethod.HttpGet,
                                  host: "api.github.com", route: "/users",
                                  validator: validate_GetUsers_780548, base: "/",
                                  url: url_GetUsers_780549,
                                  schemes: {Scheme.Https})
type
  Call_GetUsersUsername_780556 = ref object of OpenApiRestCall_777573
proc url_GetUsersUsername_780558(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsername_780557(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Get a single user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_780559 = path.getOrDefault("username")
  valid_780559 = validateParameter(valid_780559, JString, required = true,
                                 default = nil)
  if valid_780559 != nil:
    section.add "username", valid_780559
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780560 = header.getOrDefault("Accept")
  valid_780560 = validateParameter(valid_780560, JString, required = false,
                                 default = nil)
  if valid_780560 != nil:
    section.add "Accept", valid_780560
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780561: Call_GetUsersUsername_780556; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Get a single user.
  ## 
  let valid = call_780561.validator(path, query, header, formData, body)
  let scheme = call_780561.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780561.url(scheme.get, call_780561.host, call_780561.base,
                         call_780561.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780561, url, valid)

proc call*(call_780562: Call_GetUsersUsername_780556; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsername
  ## Get a single user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780563 = newJObject()
  var header_780564 = newJObject()
  add(path_780563, "username", newJString(username))
  add(header_780564, "Accept", newJString(Accept))
  result = call_780562.call(path_780563, nil, header_780564, nil, nil)

var getUsersUsername* = Call_GetUsersUsername_780556(name: "getUsersUsername",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/users/{username}",
    validator: validate_GetUsersUsername_780557, base: "/",
    url: url_GetUsersUsername_780558, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameEvents_780565 = ref object of OpenApiRestCall_777573
proc url_GetUsersUsernameEvents_780567(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameEvents_780566(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_780568 = path.getOrDefault("username")
  valid_780568 = validateParameter(valid_780568, JString, required = true,
                                 default = nil)
  if valid_780568 != nil:
    section.add "username", valid_780568
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780569 = header.getOrDefault("Accept")
  valid_780569 = validateParameter(valid_780569, JString, required = false,
                                 default = nil)
  if valid_780569 != nil:
    section.add "Accept", valid_780569
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780570: Call_GetUsersUsernameEvents_780565; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
  ## 
  let valid = call_780570.validator(path, query, header, formData, body)
  let scheme = call_780570.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780570.url(scheme.get, call_780570.host, call_780570.base,
                         call_780570.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780570, url, valid)

proc call*(call_780571: Call_GetUsersUsernameEvents_780565; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameEvents
  ## If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780572 = newJObject()
  var header_780573 = newJObject()
  add(path_780572, "username", newJString(username))
  add(header_780573, "Accept", newJString(Accept))
  result = call_780571.call(path_780572, nil, header_780573, nil, nil)

var getUsersUsernameEvents* = Call_GetUsersUsernameEvents_780565(
    name: "getUsersUsernameEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/events",
    validator: validate_GetUsersUsernameEvents_780566, base: "/",
    url: url_GetUsersUsernameEvents_780567, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameEventsOrgsOrg_780574 = ref object of OpenApiRestCall_777573
proc url_GetUsersUsernameEventsOrgsOrg_780576(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/events/orgs/"),
               (kind: VariableSegment, value: "org")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameEventsOrgsOrg_780575(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## This is the user's organization dashboard. You must be authenticated as the user to view this.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_780577 = path.getOrDefault("org")
  valid_780577 = validateParameter(valid_780577, JString, required = true,
                                 default = nil)
  if valid_780577 != nil:
    section.add "org", valid_780577
  var valid_780578 = path.getOrDefault("username")
  valid_780578 = validateParameter(valid_780578, JString, required = true,
                                 default = nil)
  if valid_780578 != nil:
    section.add "username", valid_780578
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780579 = header.getOrDefault("Accept")
  valid_780579 = validateParameter(valid_780579, JString, required = false,
                                 default = nil)
  if valid_780579 != nil:
    section.add "Accept", valid_780579
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780580: Call_GetUsersUsernameEventsOrgsOrg_780574; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## This is the user's organization dashboard. You must be authenticated as the user to view this.
  ## 
  let valid = call_780580.validator(path, query, header, formData, body)
  let scheme = call_780580.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780580.url(scheme.get, call_780580.host, call_780580.base,
                         call_780580.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780580, url, valid)

proc call*(call_780581: Call_GetUsersUsernameEventsOrgsOrg_780574; org: string;
          username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameEventsOrgsOrg
  ## This is the user's organization dashboard. You must be authenticated as the user to view this.
  ##   org: string (required)
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780582 = newJObject()
  var header_780583 = newJObject()
  add(path_780582, "org", newJString(org))
  add(path_780582, "username", newJString(username))
  add(header_780583, "Accept", newJString(Accept))
  result = call_780581.call(path_780582, nil, header_780583, nil, nil)

var getUsersUsernameEventsOrgsOrg* = Call_GetUsersUsernameEventsOrgsOrg_780574(
    name: "getUsersUsernameEventsOrgsOrg", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/events/orgs/{org}",
    validator: validate_GetUsersUsernameEventsOrgsOrg_780575, base: "/",
    url: url_GetUsersUsernameEventsOrgsOrg_780576, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameFollowers_780584 = ref object of OpenApiRestCall_777573
proc url_GetUsersUsernameFollowers_780586(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/followers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameFollowers_780585(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List a user's followers
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_780587 = path.getOrDefault("username")
  valid_780587 = validateParameter(valid_780587, JString, required = true,
                                 default = nil)
  if valid_780587 != nil:
    section.add "username", valid_780587
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780588 = header.getOrDefault("Accept")
  valid_780588 = validateParameter(valid_780588, JString, required = false,
                                 default = nil)
  if valid_780588 != nil:
    section.add "Accept", valid_780588
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780589: Call_GetUsersUsernameFollowers_780584; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List a user's followers
  ## 
  let valid = call_780589.validator(path, query, header, formData, body)
  let scheme = call_780589.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780589.url(scheme.get, call_780589.host, call_780589.base,
                         call_780589.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780589, url, valid)

proc call*(call_780590: Call_GetUsersUsernameFollowers_780584; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameFollowers
  ## List a user's followers
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780591 = newJObject()
  var header_780592 = newJObject()
  add(path_780591, "username", newJString(username))
  add(header_780592, "Accept", newJString(Accept))
  result = call_780590.call(path_780591, nil, header_780592, nil, nil)

var getUsersUsernameFollowers* = Call_GetUsersUsernameFollowers_780584(
    name: "getUsersUsernameFollowers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/followers",
    validator: validate_GetUsersUsernameFollowers_780585, base: "/",
    url: url_GetUsersUsernameFollowers_780586, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameFollowingTargetUser_780593 = ref object of OpenApiRestCall_777573
proc url_GetUsersUsernameFollowingTargetUser_780595(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  assert "targetUser" in path, "`targetUser` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/following/"),
               (kind: VariableSegment, value: "targetUser")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameFollowingTargetUser_780594(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Check if one user follows another.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   targetUser: JString (required)
  ##             : Name of user.
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `targetUser` field"
  var valid_780596 = path.getOrDefault("targetUser")
  valid_780596 = validateParameter(valid_780596, JString, required = true,
                                 default = nil)
  if valid_780596 != nil:
    section.add "targetUser", valid_780596
  var valid_780597 = path.getOrDefault("username")
  valid_780597 = validateParameter(valid_780597, JString, required = true,
                                 default = nil)
  if valid_780597 != nil:
    section.add "username", valid_780597
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780598 = header.getOrDefault("Accept")
  valid_780598 = validateParameter(valid_780598, JString, required = false,
                                 default = nil)
  if valid_780598 != nil:
    section.add "Accept", valid_780598
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780599: Call_GetUsersUsernameFollowingTargetUser_780593;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Check if one user follows another.
  ## 
  let valid = call_780599.validator(path, query, header, formData, body)
  let scheme = call_780599.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780599.url(scheme.get, call_780599.host, call_780599.base,
                         call_780599.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780599, url, valid)

proc call*(call_780600: Call_GetUsersUsernameFollowingTargetUser_780593;
          targetUser: string; username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameFollowingTargetUser
  ## Check if one user follows another.
  ##   targetUser: string (required)
  ##             : Name of user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780601 = newJObject()
  var header_780602 = newJObject()
  add(path_780601, "targetUser", newJString(targetUser))
  add(path_780601, "username", newJString(username))
  add(header_780602, "Accept", newJString(Accept))
  result = call_780600.call(path_780601, nil, header_780602, nil, nil)

var getUsersUsernameFollowingTargetUser* = Call_GetUsersUsernameFollowingTargetUser_780593(
    name: "getUsersUsernameFollowingTargetUser", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/following/{targetUser}",
    validator: validate_GetUsersUsernameFollowingTargetUser_780594, base: "/",
    url: url_GetUsersUsernameFollowingTargetUser_780595, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameGists_780603 = ref object of OpenApiRestCall_777573
proc url_GetUsersUsernameGists_780605(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/gists")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameGists_780604(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List a users gists.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_780606 = path.getOrDefault("username")
  valid_780606 = validateParameter(valid_780606, JString, required = true,
                                 default = nil)
  if valid_780606 != nil:
    section.add "username", valid_780606
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_780607 = query.getOrDefault("since")
  valid_780607 = validateParameter(valid_780607, JString, required = false,
                                 default = nil)
  if valid_780607 != nil:
    section.add "since", valid_780607
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780608 = header.getOrDefault("Accept")
  valid_780608 = validateParameter(valid_780608, JString, required = false,
                                 default = nil)
  if valid_780608 != nil:
    section.add "Accept", valid_780608
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780609: Call_GetUsersUsernameGists_780603; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List a users gists.
  ## 
  let valid = call_780609.validator(path, query, header, formData, body)
  let scheme = call_780609.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780609.url(scheme.get, call_780609.host, call_780609.base,
                         call_780609.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780609, url, valid)

proc call*(call_780610: Call_GetUsersUsernameGists_780603; username: string;
          since: string = ""; Accept: string = ""): Recallable =
  ## getUsersUsernameGists
  ## List a users gists.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780611 = newJObject()
  var query_780612 = newJObject()
  var header_780613 = newJObject()
  add(query_780612, "since", newJString(since))
  add(path_780611, "username", newJString(username))
  add(header_780613, "Accept", newJString(Accept))
  result = call_780610.call(path_780611, query_780612, header_780613, nil, nil)

var getUsersUsernameGists* = Call_GetUsersUsernameGists_780603(
    name: "getUsersUsernameGists", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/users/{username}/gists", validator: validate_GetUsersUsernameGists_780604,
    base: "/", url: url_GetUsersUsernameGists_780605, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameKeys_780614 = ref object of OpenApiRestCall_777573
proc url_GetUsersUsernameKeys_780616(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/keys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameKeys_780615(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List public keys for a user.
  ## Lists the verified public keys for a user. This is accessible by anyone.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_780617 = path.getOrDefault("username")
  valid_780617 = validateParameter(valid_780617, JString, required = true,
                                 default = nil)
  if valid_780617 != nil:
    section.add "username", valid_780617
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780618 = header.getOrDefault("Accept")
  valid_780618 = validateParameter(valid_780618, JString, required = false,
                                 default = nil)
  if valid_780618 != nil:
    section.add "Accept", valid_780618
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780619: Call_GetUsersUsernameKeys_780614; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List public keys for a user.
  ## Lists the verified public keys for a user. This is accessible by anyone.
  ## 
  ## 
  let valid = call_780619.validator(path, query, header, formData, body)
  let scheme = call_780619.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780619.url(scheme.get, call_780619.host, call_780619.base,
                         call_780619.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780619, url, valid)

proc call*(call_780620: Call_GetUsersUsernameKeys_780614; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameKeys
  ## List public keys for a user.
  ## Lists the verified public keys for a user. This is accessible by anyone.
  ## 
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780621 = newJObject()
  var header_780622 = newJObject()
  add(path_780621, "username", newJString(username))
  add(header_780622, "Accept", newJString(Accept))
  result = call_780620.call(path_780621, nil, header_780622, nil, nil)

var getUsersUsernameKeys* = Call_GetUsersUsernameKeys_780614(
    name: "getUsersUsernameKeys", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/users/{username}/keys", validator: validate_GetUsersUsernameKeys_780615,
    base: "/", url: url_GetUsersUsernameKeys_780616, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameOrgs_780623 = ref object of OpenApiRestCall_777573
proc url_GetUsersUsernameOrgs_780625(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/orgs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameOrgs_780624(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List all public organizations for a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_780626 = path.getOrDefault("username")
  valid_780626 = validateParameter(valid_780626, JString, required = true,
                                 default = nil)
  if valid_780626 != nil:
    section.add "username", valid_780626
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780627 = header.getOrDefault("Accept")
  valid_780627 = validateParameter(valid_780627, JString, required = false,
                                 default = nil)
  if valid_780627 != nil:
    section.add "Accept", valid_780627
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780628: Call_GetUsersUsernameOrgs_780623; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List all public organizations for a user.
  ## 
  let valid = call_780628.validator(path, query, header, formData, body)
  let scheme = call_780628.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780628.url(scheme.get, call_780628.host, call_780628.base,
                         call_780628.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780628, url, valid)

proc call*(call_780629: Call_GetUsersUsernameOrgs_780623; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameOrgs
  ## List all public organizations for a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780630 = newJObject()
  var header_780631 = newJObject()
  add(path_780630, "username", newJString(username))
  add(header_780631, "Accept", newJString(Accept))
  result = call_780629.call(path_780630, nil, header_780631, nil, nil)

var getUsersUsernameOrgs* = Call_GetUsersUsernameOrgs_780623(
    name: "getUsersUsernameOrgs", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/users/{username}/orgs", validator: validate_GetUsersUsernameOrgs_780624,
    base: "/", url: url_GetUsersUsernameOrgs_780625, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameReceivedEvents_780632 = ref object of OpenApiRestCall_777573
proc url_GetUsersUsernameReceivedEvents_780634(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/received_events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameReceivedEvents_780633(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## These are events that you'll only see public events.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_780635 = path.getOrDefault("username")
  valid_780635 = validateParameter(valid_780635, JString, required = true,
                                 default = nil)
  if valid_780635 != nil:
    section.add "username", valid_780635
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780636 = header.getOrDefault("Accept")
  valid_780636 = validateParameter(valid_780636, JString, required = false,
                                 default = nil)
  if valid_780636 != nil:
    section.add "Accept", valid_780636
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780637: Call_GetUsersUsernameReceivedEvents_780632; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## These are events that you'll only see public events.
  ## 
  let valid = call_780637.validator(path, query, header, formData, body)
  let scheme = call_780637.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780637.url(scheme.get, call_780637.host, call_780637.base,
                         call_780637.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780637, url, valid)

proc call*(call_780638: Call_GetUsersUsernameReceivedEvents_780632;
          username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameReceivedEvents
  ## These are events that you'll only see public events.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780639 = newJObject()
  var header_780640 = newJObject()
  add(path_780639, "username", newJString(username))
  add(header_780640, "Accept", newJString(Accept))
  result = call_780638.call(path_780639, nil, header_780640, nil, nil)

var getUsersUsernameReceivedEvents* = Call_GetUsersUsernameReceivedEvents_780632(
    name: "getUsersUsernameReceivedEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/received_events",
    validator: validate_GetUsersUsernameReceivedEvents_780633, base: "/",
    url: url_GetUsersUsernameReceivedEvents_780634, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameReceivedEventsPublic_780641 = ref object of OpenApiRestCall_777573
proc url_GetUsersUsernameReceivedEventsPublic_780643(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/received_events/public")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameReceivedEventsPublic_780642(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List public events that a user has received
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_780644 = path.getOrDefault("username")
  valid_780644 = validateParameter(valid_780644, JString, required = true,
                                 default = nil)
  if valid_780644 != nil:
    section.add "username", valid_780644
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780645 = header.getOrDefault("Accept")
  valid_780645 = validateParameter(valid_780645, JString, required = false,
                                 default = nil)
  if valid_780645 != nil:
    section.add "Accept", valid_780645
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780646: Call_GetUsersUsernameReceivedEventsPublic_780641;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## List public events that a user has received
  ## 
  let valid = call_780646.validator(path, query, header, formData, body)
  let scheme = call_780646.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780646.url(scheme.get, call_780646.host, call_780646.base,
                         call_780646.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780646, url, valid)

proc call*(call_780647: Call_GetUsersUsernameReceivedEventsPublic_780641;
          username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameReceivedEventsPublic
  ## List public events that a user has received
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780648 = newJObject()
  var header_780649 = newJObject()
  add(path_780648, "username", newJString(username))
  add(header_780649, "Accept", newJString(Accept))
  result = call_780647.call(path_780648, nil, header_780649, nil, nil)

var getUsersUsernameReceivedEventsPublic* = Call_GetUsersUsernameReceivedEventsPublic_780641(
    name: "getUsersUsernameReceivedEventsPublic", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/received_events/public",
    validator: validate_GetUsersUsernameReceivedEventsPublic_780642, base: "/",
    url: url_GetUsersUsernameReceivedEventsPublic_780643, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameRepos_780650 = ref object of OpenApiRestCall_777573
proc url_GetUsersUsernameRepos_780652(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameRepos_780651(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List public repositories for the specified user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_780653 = path.getOrDefault("username")
  valid_780653 = validateParameter(valid_780653, JString, required = true,
                                 default = nil)
  if valid_780653 != nil:
    section.add "username", valid_780653
  result.add "path", section
  ## parameters in `query` object:
  ##   type: JString
  section = newJObject()
  var valid_780654 = query.getOrDefault("type")
  valid_780654 = validateParameter(valid_780654, JString, required = false,
                                 default = newJString("all"))
  if valid_780654 != nil:
    section.add "type", valid_780654
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780655 = header.getOrDefault("Accept")
  valid_780655 = validateParameter(valid_780655, JString, required = false,
                                 default = nil)
  if valid_780655 != nil:
    section.add "Accept", valid_780655
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780656: Call_GetUsersUsernameRepos_780650; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List public repositories for the specified user.
  ## 
  let valid = call_780656.validator(path, query, header, formData, body)
  let scheme = call_780656.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780656.url(scheme.get, call_780656.host, call_780656.base,
                         call_780656.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780656, url, valid)

proc call*(call_780657: Call_GetUsersUsernameRepos_780650; username: string;
          `type`: string = "all"; Accept: string = ""): Recallable =
  ## getUsersUsernameRepos
  ## List public repositories for the specified user.
  ##   type: string
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780658 = newJObject()
  var query_780659 = newJObject()
  var header_780660 = newJObject()
  add(query_780659, "type", newJString(`type`))
  add(path_780658, "username", newJString(username))
  add(header_780660, "Accept", newJString(Accept))
  result = call_780657.call(path_780658, query_780659, header_780660, nil, nil)

var getUsersUsernameRepos* = Call_GetUsersUsernameRepos_780650(
    name: "getUsersUsernameRepos", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/users/{username}/repos", validator: validate_GetUsersUsernameRepos_780651,
    base: "/", url: url_GetUsersUsernameRepos_780652, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameStarred_780661 = ref object of OpenApiRestCall_777573
proc url_GetUsersUsernameStarred_780663(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/starred")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameStarred_780662(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List repositories being starred by a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_780664 = path.getOrDefault("username")
  valid_780664 = validateParameter(valid_780664, JString, required = true,
                                 default = nil)
  if valid_780664 != nil:
    section.add "username", valid_780664
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780665 = header.getOrDefault("Accept")
  valid_780665 = validateParameter(valid_780665, JString, required = false,
                                 default = nil)
  if valid_780665 != nil:
    section.add "Accept", valid_780665
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780666: Call_GetUsersUsernameStarred_780661; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List repositories being starred by a user.
  ## 
  let valid = call_780666.validator(path, query, header, formData, body)
  let scheme = call_780666.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780666.url(scheme.get, call_780666.host, call_780666.base,
                         call_780666.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780666, url, valid)

proc call*(call_780667: Call_GetUsersUsernameStarred_780661; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameStarred
  ## List repositories being starred by a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780668 = newJObject()
  var header_780669 = newJObject()
  add(path_780668, "username", newJString(username))
  add(header_780669, "Accept", newJString(Accept))
  result = call_780667.call(path_780668, nil, header_780669, nil, nil)

var getUsersUsernameStarred* = Call_GetUsersUsernameStarred_780661(
    name: "getUsersUsernameStarred", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/starred",
    validator: validate_GetUsersUsernameStarred_780662, base: "/",
    url: url_GetUsersUsernameStarred_780663, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameSubscriptions_780670 = ref object of OpenApiRestCall_777573
proc url_GetUsersUsernameSubscriptions_780672(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/subscriptions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameSubscriptions_780671(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## List repositories being watched by a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_780673 = path.getOrDefault("username")
  valid_780673 = validateParameter(valid_780673, JString, required = true,
                                 default = nil)
  if valid_780673 != nil:
    section.add "username", valid_780673
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_780674 = header.getOrDefault("Accept")
  valid_780674 = validateParameter(valid_780674, JString, required = false,
                                 default = nil)
  if valid_780674 != nil:
    section.add "Accept", valid_780674
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_780675: Call_GetUsersUsernameSubscriptions_780670; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## List repositories being watched by a user.
  ## 
  let valid = call_780675.validator(path, query, header, formData, body)
  let scheme = call_780675.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_780675.url(scheme.get, call_780675.host, call_780675.base,
                         call_780675.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_780675, url, valid)

proc call*(call_780676: Call_GetUsersUsernameSubscriptions_780670;
          username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameSubscriptions
  ## List repositories being watched by a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_780677 = newJObject()
  var header_780678 = newJObject()
  add(path_780677, "username", newJString(username))
  add(header_780678, "Accept", newJString(Accept))
  result = call_780676.call(path_780677, nil, header_780678, nil, nil)

var getUsersUsernameSubscriptions* = Call_GetUsersUsernameSubscriptions_780670(
    name: "getUsersUsernameSubscriptions", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/subscriptions",
    validator: validate_GetUsersUsernameSubscriptions_780671, base: "/",
    url: url_GetUsersUsernameSubscriptions_780672, schemes: {Scheme.Https})
export
  rest

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.} =
  var headers = massageHeaders(input.getOrDefault("header")).newHttpHeaders
  if not headers.hasKey "Authorization":
    headers.add "Authorization", "token " & os.getEnv "GITHUB_TOKEN"
  if headers.hasKey "Accept":
    headers.del "Accept"
  headers.add "Accept", "application/vnd.github.v3+json"
  result = newRecallable(call, url, headers, input.getOrDefault("body").getStr)
