
import
  json, options, hashes, uri, strutils, rest, os, uri, httpcore

## auto-generated via openapi macro
## title: GitHub
## version: v3
## termsOfService: https://help.github.com/articles/github-terms-of-service/#b-api-terms
## license: (not provided)
## 
## Powerful collaboration, code review, and code management for open source and private projects.
## 
## 
## https://developer.github.com/v3/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (path: JsonNode = nil; query: JsonNode = nil;
                          header: JsonNode = nil; formData: JsonNode = nil;
                          body: JsonNode = nil; _: string = ""): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_38985352 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_38985352](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_38985352): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low .. Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js == nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result == nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind == kind, $kind & " expected; received " & $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string {.used.} =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] {.used.} =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    case js.kind
    of JInt, JFloat, JNull, JBool:
      head = $js
    of JString:
      head = js.getStr
    else:
      return
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode; body: string = ""): Recallable {.
    base.}
type
  Call_GetEmojis_38985539 = ref object of OpenApiRestCall_38985352
proc url_GetEmojis_38985541(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEmojis_38985540(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Lists all the emojis available to use on GitHub.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38985674 = header.getOrDefault("Accept")
  valid_38985674 = validateParameter(valid_38985674, JString, required = false,
                                   default = nil)
  if valid_38985674 != nil:
    section.add "Accept", valid_38985674
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38985699: Call_GetEmojis_38985539; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Lists all the emojis available to use on GitHub.
  ## 
  let valid = call_38985699.validator(path, query, header, formData, body, _)
  let scheme = call_38985699.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38985699.url(scheme.get, call_38985699.host, call_38985699.base,
                           call_38985699.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38985699, url, valid, _)

proc call*(call_38985762: Call_GetEmojis_38985539; Accept: string = ""): Recallable =
  ## getEmojis
  ## Lists all the emojis available to use on GitHub.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_38985764 = newJObject()
  add(header_38985764, "Accept", newJString(Accept))
  result = call_38985762.call(nil, nil, header_38985764, nil, nil)

var getEmojis* = Call_GetEmojis_38985539(name: "getEmojis", meth: HttpMethod.HttpGet,
                                      host: "api.github.com", route: "/emojis",
                                      validator: validate_GetEmojis_38985540,
                                      base: "/", url: url_GetEmojis_38985541,
                                      schemes: {Scheme.Https})
type
  Call_GetEvents_38985806 = ref object of OpenApiRestCall_38985352
proc url_GetEvents_38985808(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEvents_38985807(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List public events.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38985809 = header.getOrDefault("Accept")
  valid_38985809 = validateParameter(valid_38985809, JString, required = false,
                                   default = nil)
  if valid_38985809 != nil:
    section.add "Accept", valid_38985809
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38985810: Call_GetEvents_38985806; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List public events.
  ## 
  let valid = call_38985810.validator(path, query, header, formData, body, _)
  let scheme = call_38985810.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38985810.url(scheme.get, call_38985810.host, call_38985810.base,
                           call_38985810.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38985810, url, valid, _)

proc call*(call_38985811: Call_GetEvents_38985806; Accept: string = ""): Recallable =
  ## getEvents
  ## List public events.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_38985812 = newJObject()
  add(header_38985812, "Accept", newJString(Accept))
  result = call_38985811.call(nil, nil, header_38985812, nil, nil)

var getEvents* = Call_GetEvents_38985806(name: "getEvents", meth: HttpMethod.HttpGet,
                                      host: "api.github.com", route: "/events",
                                      validator: validate_GetEvents_38985807,
                                      base: "/", url: url_GetEvents_38985808,
                                      schemes: {Scheme.Https})
type
  Call_GetFeeds_38985813 = ref object of OpenApiRestCall_38985352
proc url_GetFeeds_38985815(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetFeeds_38985814(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List Feeds.
  ## GitHub provides several timeline resources in Atom format. The Feeds API
  ##  lists all the feeds available to the authenticating user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38985816 = header.getOrDefault("Accept")
  valid_38985816 = validateParameter(valid_38985816, JString, required = false,
                                   default = nil)
  if valid_38985816 != nil:
    section.add "Accept", valid_38985816
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38985817: Call_GetFeeds_38985813; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List Feeds.
  ## GitHub provides several timeline resources in Atom format. The Feeds API
  ##  lists all the feeds available to the authenticating user.
  ## 
  ## 
  let valid = call_38985817.validator(path, query, header, formData, body, _)
  let scheme = call_38985817.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38985817.url(scheme.get, call_38985817.host, call_38985817.base,
                           call_38985817.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38985817, url, valid, _)

proc call*(call_38985818: Call_GetFeeds_38985813; Accept: string = ""): Recallable =
  ## getFeeds
  ## List Feeds.
  ## GitHub provides several timeline resources in Atom format. The Feeds API
  ##  lists all the feeds available to the authenticating user.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_38985819 = newJObject()
  add(header_38985819, "Accept", newJString(Accept))
  result = call_38985818.call(nil, nil, header_38985819, nil, nil)

var getFeeds* = Call_GetFeeds_38985813(name: "getFeeds", meth: HttpMethod.HttpGet,
                                    host: "api.github.com", route: "/feeds",
                                    validator: validate_GetFeeds_38985814,
                                    base: "/", url: url_GetFeeds_38985815,
                                    schemes: {Scheme.Https})
type
  Call_PostGists_38985829 = ref object of OpenApiRestCall_38985352
proc url_PostGists_38985831(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostGists_38985830(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38985841 = header.getOrDefault("Accept")
  valid_38985841 = validateParameter(valid_38985841, JString, required = false,
                                   default = nil)
  if valid_38985841 != nil:
    section.add "Accept", valid_38985841
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38985843: Call_PostGists_38985829; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a gist.
  ## 
  let valid = call_38985843.validator(path, query, header, formData, body, _)
  let scheme = call_38985843.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38985843.url(scheme.get, call_38985843.host, call_38985843.base,
                           call_38985843.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38985843, url, valid, _)

proc call*(call_38985844: Call_PostGists_38985829; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postGists
  ## Create a gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_38985845 = newJObject()
  var body_38985846 = newJObject()
  add(header_38985845, "Accept", newJString(Accept))
  if body != nil:
    body_38985846 = body
  result = call_38985844.call(nil, nil, header_38985845, nil, body_38985846)

var postGists* = Call_PostGists_38985829(name: "postGists",
                                      meth: HttpMethod.HttpPost,
                                      host: "api.github.com", route: "/gists",
                                      validator: validate_PostGists_38985830,
                                      base: "/", url: url_PostGists_38985831,
                                      schemes: {Scheme.Https})
type
  Call_GetGists_38985820 = ref object of OpenApiRestCall_38985352
proc url_GetGists_38985822(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGists_38985821(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List the authenticated user's gists or if called anonymously, this will
  ## return all public gists.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_38985823 = query.getOrDefault("since")
  valid_38985823 = validateParameter(valid_38985823, JString, required = false,
                                   default = nil)
  if valid_38985823 != nil:
    section.add "since", valid_38985823
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38985824 = header.getOrDefault("Accept")
  valid_38985824 = validateParameter(valid_38985824, JString, required = false,
                                   default = nil)
  if valid_38985824 != nil:
    section.add "Accept", valid_38985824
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38985825: Call_GetGists_38985820; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List the authenticated user's gists or if called anonymously, this will
  ## return all public gists.
  ## 
  ## 
  let valid = call_38985825.validator(path, query, header, formData, body, _)
  let scheme = call_38985825.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38985825.url(scheme.get, call_38985825.host, call_38985825.base,
                           call_38985825.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38985825, url, valid, _)

proc call*(call_38985826: Call_GetGists_38985820; Accept: string = "";
          since: string = ""): Recallable =
  ## getGists
  ## List the authenticated user's gists or if called anonymously, this will
  ## return all public gists.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: string
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  var query_38985827 = newJObject()
  var header_38985828 = newJObject()
  add(header_38985828, "Accept", newJString(Accept))
  add(query_38985827, "since", newJString(since))
  result = call_38985826.call(nil, query_38985827, header_38985828, nil, nil)

var getGists* = Call_GetGists_38985820(name: "getGists", meth: HttpMethod.HttpGet,
                                    host: "api.github.com", route: "/gists",
                                    validator: validate_GetGists_38985821,
                                    base: "/", url: url_GetGists_38985822,
                                    schemes: {Scheme.Https})
type
  Call_GetGistsPublic_38985847 = ref object of OpenApiRestCall_38985352
proc url_GetGistsPublic_38985849(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGistsPublic_38985848(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List all public gists.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_38985850 = query.getOrDefault("since")
  valid_38985850 = validateParameter(valid_38985850, JString, required = false,
                                   default = nil)
  if valid_38985850 != nil:
    section.add "since", valid_38985850
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38985851 = header.getOrDefault("Accept")
  valid_38985851 = validateParameter(valid_38985851, JString, required = false,
                                   default = nil)
  if valid_38985851 != nil:
    section.add "Accept", valid_38985851
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38985852: Call_GetGistsPublic_38985847; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List all public gists.
  ## 
  let valid = call_38985852.validator(path, query, header, formData, body, _)
  let scheme = call_38985852.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38985852.url(scheme.get, call_38985852.host, call_38985852.base,
                           call_38985852.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38985852, url, valid, _)

proc call*(call_38985853: Call_GetGistsPublic_38985847; Accept: string = "";
          since: string = ""): Recallable =
  ## getGistsPublic
  ## List all public gists.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: string
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  var query_38985854 = newJObject()
  var header_38985855 = newJObject()
  add(header_38985855, "Accept", newJString(Accept))
  add(query_38985854, "since", newJString(since))
  result = call_38985853.call(nil, query_38985854, header_38985855, nil, nil)

var getGistsPublic* = Call_GetGistsPublic_38985847(name: "getGistsPublic",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/gists/public",
    validator: validate_GetGistsPublic_38985848, base: "/", url: url_GetGistsPublic_38985849,
    schemes: {Scheme.Https})
type
  Call_GetGistsStarred_38985856 = ref object of OpenApiRestCall_38985352
proc url_GetGistsStarred_38985858(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGistsStarred_38985857(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List the authenticated user's starred gists.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_38985859 = query.getOrDefault("since")
  valid_38985859 = validateParameter(valid_38985859, JString, required = false,
                                   default = nil)
  if valid_38985859 != nil:
    section.add "since", valid_38985859
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38985860 = header.getOrDefault("Accept")
  valid_38985860 = validateParameter(valid_38985860, JString, required = false,
                                   default = nil)
  if valid_38985860 != nil:
    section.add "Accept", valid_38985860
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38985861: Call_GetGistsStarred_38985856; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List the authenticated user's starred gists.
  ## 
  let valid = call_38985861.validator(path, query, header, formData, body, _)
  let scheme = call_38985861.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38985861.url(scheme.get, call_38985861.host, call_38985861.base,
                           call_38985861.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38985861, url, valid, _)

proc call*(call_38985862: Call_GetGistsStarred_38985856; Accept: string = "";
          since: string = ""): Recallable =
  ## getGistsStarred
  ## List the authenticated user's starred gists.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: string
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  var query_38985863 = newJObject()
  var header_38985864 = newJObject()
  add(header_38985864, "Accept", newJString(Accept))
  add(query_38985863, "since", newJString(since))
  result = call_38985862.call(nil, query_38985863, header_38985864, nil, nil)

var getGistsStarred* = Call_GetGistsStarred_38985856(name: "getGistsStarred",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/gists/starred",
    validator: validate_GetGistsStarred_38985857, base: "/",
    url: url_GetGistsStarred_38985858, schemes: {Scheme.Https})
type
  Call_GetGistsId_38985865 = ref object of OpenApiRestCall_38985352
proc url_GetGistsId_38985867(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsId_38985866(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get a single gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_38985881 = path.getOrDefault("id")
  valid_38985881 = validateParameter(valid_38985881, JInt, required = true,
                                   default = nil)
  if valid_38985881 != nil:
    section.add "id", valid_38985881
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38985882 = header.getOrDefault("Accept")
  valid_38985882 = validateParameter(valid_38985882, JString, required = false,
                                   default = nil)
  if valid_38985882 != nil:
    section.add "Accept", valid_38985882
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38985883: Call_GetGistsId_38985865; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single gist.
  ## 
  let valid = call_38985883.validator(path, query, header, formData, body, _)
  let scheme = call_38985883.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38985883.url(scheme.get, call_38985883.host, call_38985883.base,
                           call_38985883.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38985883, url, valid, _)

proc call*(call_38985884: Call_GetGistsId_38985865; id: int; Accept: string = ""): Recallable =
  ## getGistsId
  ## Get a single gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_38985885 = newJObject()
  var header_38985886 = newJObject()
  add(path_38985885, "id", newJInt(id))
  add(header_38985886, "Accept", newJString(Accept))
  result = call_38985884.call(path_38985885, nil, header_38985886, nil, nil)

var getGistsId* = Call_GetGistsId_38985865(name: "getGistsId",
                                        meth: HttpMethod.HttpGet,
                                        host: "api.github.com",
                                        route: "/gists/{id}",
                                        validator: validate_GetGistsId_38985866,
                                        base: "/", url: url_GetGistsId_38985867,
                                        schemes: {Scheme.Https})
type
  Call_PatchGistsId_38985896 = ref object of OpenApiRestCall_38985352
proc url_PatchGistsId_38985898(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchGistsId_38985897(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## Edit a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_38985899 = path.getOrDefault("id")
  valid_38985899 = validateParameter(valid_38985899, JInt, required = true,
                                   default = nil)
  if valid_38985899 != nil:
    section.add "id", valid_38985899
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38985900 = header.getOrDefault("Accept")
  valid_38985900 = validateParameter(valid_38985900, JString, required = false,
                                   default = nil)
  if valid_38985900 != nil:
    section.add "Accept", valid_38985900
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38985902: Call_PatchGistsId_38985896; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit a gist.
  ## 
  let valid = call_38985902.validator(path, query, header, formData, body, _)
  let scheme = call_38985902.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38985902.url(scheme.get, call_38985902.host, call_38985902.base,
                           call_38985902.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38985902, url, valid, _)

proc call*(call_38985903: Call_PatchGistsId_38985896; id: int; body: JsonNode;
          Accept: string = ""): Recallable =
  ## patchGistsId
  ## Edit a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var path_38985904 = newJObject()
  var header_38985905 = newJObject()
  var body_38985906 = newJObject()
  add(path_38985904, "id", newJInt(id))
  add(header_38985905, "Accept", newJString(Accept))
  if body != nil:
    body_38985906 = body
  result = call_38985903.call(path_38985904, nil, header_38985905, nil, body_38985906)

var patchGistsId* = Call_PatchGistsId_38985896(name: "patchGistsId",
    meth: HttpMethod.HttpPatch, host: "api.github.com", route: "/gists/{id}",
    validator: validate_PatchGistsId_38985897, base: "/", url: url_PatchGistsId_38985898,
    schemes: {Scheme.Https})
type
  Call_DeleteGistsId_38985887 = ref object of OpenApiRestCall_38985352
proc url_DeleteGistsId_38985889(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteGistsId_38985888(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## Delete a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_38985890 = path.getOrDefault("id")
  valid_38985890 = validateParameter(valid_38985890, JInt, required = true,
                                   default = nil)
  if valid_38985890 != nil:
    section.add "id", valid_38985890
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38985891 = header.getOrDefault("Accept")
  valid_38985891 = validateParameter(valid_38985891, JString, required = false,
                                   default = nil)
  if valid_38985891 != nil:
    section.add "Accept", valid_38985891
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38985892: Call_DeleteGistsId_38985887; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a gist.
  ## 
  let valid = call_38985892.validator(path, query, header, formData, body, _)
  let scheme = call_38985892.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38985892.url(scheme.get, call_38985892.host, call_38985892.base,
                           call_38985892.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38985892, url, valid, _)

proc call*(call_38985893: Call_DeleteGistsId_38985887; id: int; Accept: string = ""): Recallable =
  ## deleteGistsId
  ## Delete a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_38985894 = newJObject()
  var header_38985895 = newJObject()
  add(path_38985894, "id", newJInt(id))
  add(header_38985895, "Accept", newJString(Accept))
  result = call_38985893.call(path_38985894, nil, header_38985895, nil, nil)

var deleteGistsId* = Call_DeleteGistsId_38985887(name: "deleteGistsId",
    meth: HttpMethod.HttpDelete, host: "api.github.com", route: "/gists/{id}",
    validator: validate_DeleteGistsId_38985888, base: "/", url: url_DeleteGistsId_38985889,
    schemes: {Scheme.Https})
type
  Call_PostGistsIdComments_38985916 = ref object of OpenApiRestCall_38985352
proc url_PostGistsIdComments_38985918(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostGistsIdComments_38985917(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a commen
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_38985919 = path.getOrDefault("id")
  valid_38985919 = validateParameter(valid_38985919, JInt, required = true,
                                   default = nil)
  if valid_38985919 != nil:
    section.add "id", valid_38985919
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38985920 = header.getOrDefault("Accept")
  valid_38985920 = validateParameter(valid_38985920, JString, required = false,
                                   default = nil)
  if valid_38985920 != nil:
    section.add "Accept", valid_38985920
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38985922: Call_PostGistsIdComments_38985916; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a commen
  ## 
  let valid = call_38985922.validator(path, query, header, formData, body, _)
  let scheme = call_38985922.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38985922.url(scheme.get, call_38985922.host, call_38985922.base,
                           call_38985922.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38985922, url, valid, _)

proc call*(call_38985923: Call_PostGistsIdComments_38985916; id: int; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postGistsIdComments
  ## Create a commen
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var path_38985924 = newJObject()
  var header_38985925 = newJObject()
  var body_38985926 = newJObject()
  add(path_38985924, "id", newJInt(id))
  add(header_38985925, "Accept", newJString(Accept))
  if body != nil:
    body_38985926 = body
  result = call_38985923.call(path_38985924, nil, header_38985925, nil, body_38985926)

var postGistsIdComments* = Call_PostGistsIdComments_38985916(
    name: "postGistsIdComments", meth: HttpMethod.HttpPost, host: "api.github.com",
    route: "/gists/{id}/comments", validator: validate_PostGistsIdComments_38985917,
    base: "/", url: url_PostGistsIdComments_38985918, schemes: {Scheme.Https})
type
  Call_GetGistsIdComments_38985907 = ref object of OpenApiRestCall_38985352
proc url_GetGistsIdComments_38985909(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsIdComments_38985908(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List comments on a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_38985910 = path.getOrDefault("id")
  valid_38985910 = validateParameter(valid_38985910, JInt, required = true,
                                   default = nil)
  if valid_38985910 != nil:
    section.add "id", valid_38985910
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38985911 = header.getOrDefault("Accept")
  valid_38985911 = validateParameter(valid_38985911, JString, required = false,
                                   default = nil)
  if valid_38985911 != nil:
    section.add "Accept", valid_38985911
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38985912: Call_GetGistsIdComments_38985907; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List comments on a gist.
  ## 
  let valid = call_38985912.validator(path, query, header, formData, body, _)
  let scheme = call_38985912.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38985912.url(scheme.get, call_38985912.host, call_38985912.base,
                           call_38985912.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38985912, url, valid, _)

proc call*(call_38985913: Call_GetGistsIdComments_38985907; id: int;
          Accept: string = ""): Recallable =
  ## getGistsIdComments
  ## List comments on a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_38985914 = newJObject()
  var header_38985915 = newJObject()
  add(path_38985914, "id", newJInt(id))
  add(header_38985915, "Accept", newJString(Accept))
  result = call_38985913.call(path_38985914, nil, header_38985915, nil, nil)

var getGistsIdComments* = Call_GetGistsIdComments_38985907(
    name: "getGistsIdComments", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/gists/{id}/comments", validator: validate_GetGistsIdComments_38985908,
    base: "/", url: url_GetGistsIdComments_38985909, schemes: {Scheme.Https})
type
  Call_GetGistsIdCommentsCommentId_38985927 = ref object of OpenApiRestCall_38985352
proc url_GetGistsIdCommentsCommentId_38985929(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsIdCommentsCommentId_38985928(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get a single comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_38985930 = path.getOrDefault("id")
  valid_38985930 = validateParameter(valid_38985930, JInt, required = true,
                                   default = nil)
  if valid_38985930 != nil:
    section.add "id", valid_38985930
  var valid_38985931 = path.getOrDefault("commentId")
  valid_38985931 = validateParameter(valid_38985931, JInt, required = true,
                                   default = nil)
  if valid_38985931 != nil:
    section.add "commentId", valid_38985931
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38985932 = header.getOrDefault("Accept")
  valid_38985932 = validateParameter(valid_38985932, JString, required = false,
                                   default = nil)
  if valid_38985932 != nil:
    section.add "Accept", valid_38985932
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38985933: Call_GetGistsIdCommentsCommentId_38985927;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single comment.
  ## 
  let valid = call_38985933.validator(path, query, header, formData, body, _)
  let scheme = call_38985933.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38985933.url(scheme.get, call_38985933.host, call_38985933.base,
                           call_38985933.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38985933, url, valid, _)

proc call*(call_38985934: Call_GetGistsIdCommentsCommentId_38985927; id: int;
          commentId: int; Accept: string = ""): Recallable =
  ## getGistsIdCommentsCommentId
  ## Get a single comment.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_38985935 = newJObject()
  var header_38985936 = newJObject()
  add(path_38985935, "id", newJInt(id))
  add(header_38985936, "Accept", newJString(Accept))
  add(path_38985935, "commentId", newJInt(commentId))
  result = call_38985934.call(path_38985935, nil, header_38985936, nil, nil)

var getGistsIdCommentsCommentId* = Call_GetGistsIdCommentsCommentId_38985927(
    name: "getGistsIdCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/gists/{id}/comments/{commentId}",
    validator: validate_GetGistsIdCommentsCommentId_38985928, base: "/",
    url: url_GetGistsIdCommentsCommentId_38985929, schemes: {Scheme.Https})
type
  Call_PatchGistsIdCommentsCommentId_38985947 = ref object of OpenApiRestCall_38985352
proc url_PatchGistsIdCommentsCommentId_38985949(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchGistsIdCommentsCommentId_38985948(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Edit a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_38985950 = path.getOrDefault("id")
  valid_38985950 = validateParameter(valid_38985950, JInt, required = true,
                                   default = nil)
  if valid_38985950 != nil:
    section.add "id", valid_38985950
  var valid_38985951 = path.getOrDefault("commentId")
  valid_38985951 = validateParameter(valid_38985951, JInt, required = true,
                                   default = nil)
  if valid_38985951 != nil:
    section.add "commentId", valid_38985951
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38985952 = header.getOrDefault("Accept")
  valid_38985952 = validateParameter(valid_38985952, JString, required = false,
                                   default = nil)
  if valid_38985952 != nil:
    section.add "Accept", valid_38985952
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38985954: Call_PatchGistsIdCommentsCommentId_38985947;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit a comment.
  ## 
  let valid = call_38985954.validator(path, query, header, formData, body, _)
  let scheme = call_38985954.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38985954.url(scheme.get, call_38985954.host, call_38985954.base,
                           call_38985954.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38985954, url, valid, _)

proc call*(call_38985955: Call_PatchGistsIdCommentsCommentId_38985947; id: int;
          body: JsonNode; commentId: int; Accept: string = ""): Recallable =
  ## patchGistsIdCommentsCommentId
  ## Edit a comment.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_38985956 = newJObject()
  var header_38985957 = newJObject()
  var body_38985958 = newJObject()
  add(path_38985956, "id", newJInt(id))
  add(header_38985957, "Accept", newJString(Accept))
  if body != nil:
    body_38985958 = body
  add(path_38985956, "commentId", newJInt(commentId))
  result = call_38985955.call(path_38985956, nil, header_38985957, nil, body_38985958)

var patchGistsIdCommentsCommentId* = Call_PatchGistsIdCommentsCommentId_38985947(
    name: "patchGistsIdCommentsCommentId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/gists/{id}/comments/{commentId}",
    validator: validate_PatchGistsIdCommentsCommentId_38985948, base: "/",
    url: url_PatchGistsIdCommentsCommentId_38985949, schemes: {Scheme.Https})
type
  Call_DeleteGistsIdCommentsCommentId_38985937 = ref object of OpenApiRestCall_38985352
proc url_DeleteGistsIdCommentsCommentId_38985939(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteGistsIdCommentsCommentId_38985938(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_38985940 = path.getOrDefault("id")
  valid_38985940 = validateParameter(valid_38985940, JInt, required = true,
                                   default = nil)
  if valid_38985940 != nil:
    section.add "id", valid_38985940
  var valid_38985941 = path.getOrDefault("commentId")
  valid_38985941 = validateParameter(valid_38985941, JInt, required = true,
                                   default = nil)
  if valid_38985941 != nil:
    section.add "commentId", valid_38985941
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38985942 = header.getOrDefault("Accept")
  valid_38985942 = validateParameter(valid_38985942, JString, required = false,
                                   default = nil)
  if valid_38985942 != nil:
    section.add "Accept", valid_38985942
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38985943: Call_DeleteGistsIdCommentsCommentId_38985937;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a comment.
  ## 
  let valid = call_38985943.validator(path, query, header, formData, body, _)
  let scheme = call_38985943.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38985943.url(scheme.get, call_38985943.host, call_38985943.base,
                           call_38985943.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38985943, url, valid, _)

proc call*(call_38985944: Call_DeleteGistsIdCommentsCommentId_38985937; id: int;
          commentId: int; Accept: string = ""): Recallable =
  ## deleteGistsIdCommentsCommentId
  ## Delete a comment.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_38985945 = newJObject()
  var header_38985946 = newJObject()
  add(path_38985945, "id", newJInt(id))
  add(header_38985946, "Accept", newJString(Accept))
  add(path_38985945, "commentId", newJInt(commentId))
  result = call_38985944.call(path_38985945, nil, header_38985946, nil, nil)

var deleteGistsIdCommentsCommentId* = Call_DeleteGistsIdCommentsCommentId_38985937(
    name: "deleteGistsIdCommentsCommentId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/gists/{id}/comments/{commentId}",
    validator: validate_DeleteGistsIdCommentsCommentId_38985938, base: "/",
    url: url_DeleteGistsIdCommentsCommentId_38985939, schemes: {Scheme.Https})
type
  Call_PostGistsIdForks_38985959 = ref object of OpenApiRestCall_38985352
proc url_PostGistsIdForks_38985961(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/forks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostGistsIdForks_38985960(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Fork a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_38985962 = path.getOrDefault("id")
  valid_38985962 = validateParameter(valid_38985962, JInt, required = true,
                                   default = nil)
  if valid_38985962 != nil:
    section.add "id", valid_38985962
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38985963 = header.getOrDefault("Accept")
  valid_38985963 = validateParameter(valid_38985963, JString, required = false,
                                   default = nil)
  if valid_38985963 != nil:
    section.add "Accept", valid_38985963
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38985964: Call_PostGistsIdForks_38985959; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Fork a gist.
  ## 
  let valid = call_38985964.validator(path, query, header, formData, body, _)
  let scheme = call_38985964.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38985964.url(scheme.get, call_38985964.host, call_38985964.base,
                           call_38985964.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38985964, url, valid, _)

proc call*(call_38985965: Call_PostGistsIdForks_38985959; id: int;
          Accept: string = ""): Recallable =
  ## postGistsIdForks
  ## Fork a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_38985966 = newJObject()
  var header_38985967 = newJObject()
  add(path_38985966, "id", newJInt(id))
  add(header_38985967, "Accept", newJString(Accept))
  result = call_38985965.call(path_38985966, nil, header_38985967, nil, nil)

var postGistsIdForks* = Call_PostGistsIdForks_38985959(name: "postGistsIdForks",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/gists/{id}/forks",
    validator: validate_PostGistsIdForks_38985960, base: "/",
    url: url_PostGistsIdForks_38985961, schemes: {Scheme.Https})
type
  Call_PutGistsIdStar_38985977 = ref object of OpenApiRestCall_38985352
proc url_PutGistsIdStar_38985979(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/star")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutGistsIdStar_38985978(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Star a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_38985980 = path.getOrDefault("id")
  valid_38985980 = validateParameter(valid_38985980, JInt, required = true,
                                   default = nil)
  if valid_38985980 != nil:
    section.add "id", valid_38985980
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38985981 = header.getOrDefault("Accept")
  valid_38985981 = validateParameter(valid_38985981, JString, required = false,
                                   default = nil)
  if valid_38985981 != nil:
    section.add "Accept", valid_38985981
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38985982: Call_PutGistsIdStar_38985977; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Star a gist.
  ## 
  let valid = call_38985982.validator(path, query, header, formData, body, _)
  let scheme = call_38985982.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38985982.url(scheme.get, call_38985982.host, call_38985982.base,
                           call_38985982.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38985982, url, valid, _)

proc call*(call_38985983: Call_PutGistsIdStar_38985977; id: int; Accept: string = ""): Recallable =
  ## putGistsIdStar
  ## Star a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_38985984 = newJObject()
  var header_38985985 = newJObject()
  add(path_38985984, "id", newJInt(id))
  add(header_38985985, "Accept", newJString(Accept))
  result = call_38985983.call(path_38985984, nil, header_38985985, nil, nil)

var putGistsIdStar* = Call_PutGistsIdStar_38985977(name: "putGistsIdStar",
    meth: HttpMethod.HttpPut, host: "api.github.com", route: "/gists/{id}/star",
    validator: validate_PutGistsIdStar_38985978, base: "/", url: url_PutGistsIdStar_38985979,
    schemes: {Scheme.Https})
type
  Call_GetGistsIdStar_38985968 = ref object of OpenApiRestCall_38985352
proc url_GetGistsIdStar_38985970(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/star")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsIdStar_38985969(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Check if a gist is starred.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_38985971 = path.getOrDefault("id")
  valid_38985971 = validateParameter(valid_38985971, JInt, required = true,
                                   default = nil)
  if valid_38985971 != nil:
    section.add "id", valid_38985971
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38985972 = header.getOrDefault("Accept")
  valid_38985972 = validateParameter(valid_38985972, JString, required = false,
                                   default = nil)
  if valid_38985972 != nil:
    section.add "Accept", valid_38985972
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38985973: Call_GetGistsIdStar_38985968; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if a gist is starred.
  ## 
  let valid = call_38985973.validator(path, query, header, formData, body, _)
  let scheme = call_38985973.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38985973.url(scheme.get, call_38985973.host, call_38985973.base,
                           call_38985973.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38985973, url, valid, _)

proc call*(call_38985974: Call_GetGistsIdStar_38985968; id: int; Accept: string = ""): Recallable =
  ## getGistsIdStar
  ## Check if a gist is starred.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_38985975 = newJObject()
  var header_38985976 = newJObject()
  add(path_38985975, "id", newJInt(id))
  add(header_38985976, "Accept", newJString(Accept))
  result = call_38985974.call(path_38985975, nil, header_38985976, nil, nil)

var getGistsIdStar* = Call_GetGistsIdStar_38985968(name: "getGistsIdStar",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/gists/{id}/star",
    validator: validate_GetGistsIdStar_38985969, base: "/", url: url_GetGistsIdStar_38985970,
    schemes: {Scheme.Https})
type
  Call_DeleteGistsIdStar_38985986 = ref object of OpenApiRestCall_38985352
proc url_DeleteGistsIdStar_38985988(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/star")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteGistsIdStar_38985987(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Unstar a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_38985989 = path.getOrDefault("id")
  valid_38985989 = validateParameter(valid_38985989, JInt, required = true,
                                   default = nil)
  if valid_38985989 != nil:
    section.add "id", valid_38985989
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38985990 = header.getOrDefault("Accept")
  valid_38985990 = validateParameter(valid_38985990, JString, required = false,
                                   default = nil)
  if valid_38985990 != nil:
    section.add "Accept", valid_38985990
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38985991: Call_DeleteGistsIdStar_38985986; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Unstar a gist.
  ## 
  let valid = call_38985991.validator(path, query, header, formData, body, _)
  let scheme = call_38985991.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38985991.url(scheme.get, call_38985991.host, call_38985991.base,
                           call_38985991.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38985991, url, valid, _)

proc call*(call_38985992: Call_DeleteGistsIdStar_38985986; id: int;
          Accept: string = ""): Recallable =
  ## deleteGistsIdStar
  ## Unstar a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_38985993 = newJObject()
  var header_38985994 = newJObject()
  add(path_38985993, "id", newJInt(id))
  add(header_38985994, "Accept", newJString(Accept))
  result = call_38985992.call(path_38985993, nil, header_38985994, nil, nil)

var deleteGistsIdStar* = Call_DeleteGistsIdStar_38985986(name: "deleteGistsIdStar",
    meth: HttpMethod.HttpDelete, host: "api.github.com", route: "/gists/{id}/star",
    validator: validate_DeleteGistsIdStar_38985987, base: "/",
    url: url_DeleteGistsIdStar_38985988, schemes: {Scheme.Https})
type
  Call_GetGitignoreTemplates_38985995 = ref object of OpenApiRestCall_38985352
proc url_GetGitignoreTemplates_38985997(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGitignoreTemplates_38985996(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Listing available templates.
  ## List all templates available to pass as an option when creating a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38985998 = header.getOrDefault("Accept")
  valid_38985998 = validateParameter(valid_38985998, JString, required = false,
                                   default = nil)
  if valid_38985998 != nil:
    section.add "Accept", valid_38985998
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38985999: Call_GetGitignoreTemplates_38985995;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Listing available templates.
  ## List all templates available to pass as an option when creating a repository.
  ## 
  ## 
  let valid = call_38985999.validator(path, query, header, formData, body, _)
  let scheme = call_38985999.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38985999.url(scheme.get, call_38985999.host, call_38985999.base,
                           call_38985999.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38985999, url, valid, _)

proc call*(call_38986000: Call_GetGitignoreTemplates_38985995; Accept: string = ""): Recallable =
  ## getGitignoreTemplates
  ## Listing available templates.
  ## List all templates available to pass as an option when creating a repository.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_38986001 = newJObject()
  add(header_38986001, "Accept", newJString(Accept))
  result = call_38986000.call(nil, nil, header_38986001, nil, nil)

var getGitignoreTemplates* = Call_GetGitignoreTemplates_38985995(
    name: "getGitignoreTemplates", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/gitignore/templates", validator: validate_GetGitignoreTemplates_38985996,
    base: "/", url: url_GetGitignoreTemplates_38985997, schemes: {Scheme.Https})
type
  Call_GetGitignoreTemplatesLanguage_38986002 = ref object of OpenApiRestCall_38985352
proc url_GetGitignoreTemplatesLanguage_38986004(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "language" in path, "`language` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gitignore/templates/"),
               (kind: VariableSegment, value: "language")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGitignoreTemplatesLanguage_38986003(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a single template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   language: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `language` field"
  var valid_38986005 = path.getOrDefault("language")
  valid_38986005 = validateParameter(valid_38986005, JString, required = true,
                                   default = nil)
  if valid_38986005 != nil:
    section.add "language", valid_38986005
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986006 = header.getOrDefault("Accept")
  valid_38986006 = validateParameter(valid_38986006, JString, required = false,
                                   default = nil)
  if valid_38986006 != nil:
    section.add "Accept", valid_38986006
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986007: Call_GetGitignoreTemplatesLanguage_38986002;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single template.
  ## 
  let valid = call_38986007.validator(path, query, header, formData, body, _)
  let scheme = call_38986007.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986007.url(scheme.get, call_38986007.host, call_38986007.base,
                           call_38986007.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986007, url, valid, _)

proc call*(call_38986008: Call_GetGitignoreTemplatesLanguage_38986002;
          language: string; Accept: string = ""): Recallable =
  ## getGitignoreTemplatesLanguage
  ## Get a single template.
  ##   language: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_38986009 = newJObject()
  var header_38986010 = newJObject()
  add(path_38986009, "language", newJString(language))
  add(header_38986010, "Accept", newJString(Accept))
  result = call_38986008.call(path_38986009, nil, header_38986010, nil, nil)

var getGitignoreTemplatesLanguage* = Call_GetGitignoreTemplatesLanguage_38986002(
    name: "getGitignoreTemplatesLanguage", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/gitignore/templates/{language}",
    validator: validate_GetGitignoreTemplatesLanguage_38986003, base: "/",
    url: url_GetGitignoreTemplatesLanguage_38986004, schemes: {Scheme.Https})
type
  Call_GetIssues_38986011 = ref object of OpenApiRestCall_38985352
proc url_GetIssues_38986013(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetIssues_38986012(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List issues.
  ## List all issues across all the authenticated user's visible repositories.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString (required)
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: JString (required)
  ##   direction: JString (required)
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_38986028 = query.getOrDefault("state")
  valid_38986028 = validateParameter(valid_38986028, JString, required = true,
                                   default = newJString("open"))
  if valid_38986028 != nil:
    section.add "state", valid_38986028
  var valid_38986029 = query.getOrDefault("labels")
  valid_38986029 = validateParameter(valid_38986029, JString, required = true,
                                   default = nil)
  if valid_38986029 != nil:
    section.add "labels", valid_38986029
  var valid_38986030 = query.getOrDefault("sort")
  valid_38986030 = validateParameter(valid_38986030, JString, required = true,
                                   default = newJString("created"))
  if valid_38986030 != nil:
    section.add "sort", valid_38986030
  var valid_38986031 = query.getOrDefault("direction")
  valid_38986031 = validateParameter(valid_38986031, JString, required = true,
                                   default = newJString("desc"))
  if valid_38986031 != nil:
    section.add "direction", valid_38986031
  var valid_38986032 = query.getOrDefault("filter")
  valid_38986032 = validateParameter(valid_38986032, JString, required = true,
                                   default = newJString("all"))
  if valid_38986032 != nil:
    section.add "filter", valid_38986032
  var valid_38986033 = query.getOrDefault("since")
  valid_38986033 = validateParameter(valid_38986033, JString, required = false,
                                   default = nil)
  if valid_38986033 != nil:
    section.add "since", valid_38986033
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986034 = header.getOrDefault("Accept")
  valid_38986034 = validateParameter(valid_38986034, JString, required = false,
                                   default = nil)
  if valid_38986034 != nil:
    section.add "Accept", valid_38986034
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986035: Call_GetIssues_38986011; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List issues.
  ## List all issues across all the authenticated user's visible repositories.
  ## 
  ## 
  let valid = call_38986035.validator(path, query, header, formData, body, _)
  let scheme = call_38986035.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986035.url(scheme.get, call_38986035.host, call_38986035.base,
                           call_38986035.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986035, url, valid, _)

proc call*(call_38986036: Call_GetIssues_38986011; labels: string;
          state: string = "open"; Accept: string = ""; sort: string = "created";
          direction: string = "desc"; filter: string = "all"; since: string = ""): Recallable =
  ## getIssues
  ## List issues.
  ## List all issues across all the authenticated user's visible repositories.
  ## 
  ##   state: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: string (required)
  ##   direction: string (required)
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  var query_38986037 = newJObject()
  var header_38986038 = newJObject()
  add(query_38986037, "state", newJString(state))
  add(header_38986038, "Accept", newJString(Accept))
  add(query_38986037, "labels", newJString(labels))
  add(query_38986037, "sort", newJString(sort))
  add(query_38986037, "direction", newJString(direction))
  add(query_38986037, "filter", newJString(filter))
  add(query_38986037, "since", newJString(since))
  result = call_38986036.call(nil, query_38986037, header_38986038, nil, nil)

var getIssues* = Call_GetIssues_38986011(name: "getIssues", meth: HttpMethod.HttpGet,
                                      host: "api.github.com", route: "/issues",
                                      validator: validate_GetIssues_38986012,
                                      base: "/", url: url_GetIssues_38986013,
                                      schemes: {Scheme.Https})
type
  Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_38986040 = ref object of OpenApiRestCall_38985352
proc url_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_38986042(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repository" in path, "`repository` is a required path parameter"
  assert "state" in path, "`state` is a required path parameter"
  assert "keyword" in path, "`keyword` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/issues/search/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repository"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "state"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "keyword")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_38986041(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## Find issues by state and keyword.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##   repository: JString (required)
  ##   keyword: JString (required)
  ##          : The search term.
  ##   state: JString (required)
  ##        : Indicates the state of the issues to return. Can be either open or closed.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986043 = path.getOrDefault("owner")
  valid_38986043 = validateParameter(valid_38986043, JString, required = true,
                                   default = nil)
  if valid_38986043 != nil:
    section.add "owner", valid_38986043
  var valid_38986044 = path.getOrDefault("repository")
  valid_38986044 = validateParameter(valid_38986044, JString, required = true,
                                   default = nil)
  if valid_38986044 != nil:
    section.add "repository", valid_38986044
  var valid_38986045 = path.getOrDefault("keyword")
  valid_38986045 = validateParameter(valid_38986045, JString, required = true,
                                   default = nil)
  if valid_38986045 != nil:
    section.add "keyword", valid_38986045
  var valid_38986046 = path.getOrDefault("state")
  valid_38986046 = validateParameter(valid_38986046, JString, required = true,
                                   default = newJString("open"))
  if valid_38986046 != nil:
    section.add "state", valid_38986046
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986047 = header.getOrDefault("Accept")
  valid_38986047 = validateParameter(valid_38986047, JString, required = false,
                                   default = nil)
  if valid_38986047 != nil:
    section.add "Accept", valid_38986047
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986048: Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_38986040;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Find issues by state and keyword.
  ## 
  let valid = call_38986048.validator(path, query, header, formData, body, _)
  let scheme = call_38986048.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986048.url(scheme.get, call_38986048.host, call_38986048.base,
                           call_38986048.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986048, url, valid, _)

proc call*(call_38986049: Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_38986040;
          owner: string; repository: string; keyword: string; Accept: string = "";
          state: string = "open"): Recallable =
  ## getLegacyIssuesSearchOwnerRepositoryStateKeyword
  ## Find issues by state and keyword.
  ##   owner: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repository: string (required)
  ##   keyword: string (required)
  ##          : The search term.
  ##   state: string (required)
  ##        : Indicates the state of the issues to return. Can be either open or closed.
  var path_38986050 = newJObject()
  var header_38986051 = newJObject()
  add(path_38986050, "owner", newJString(owner))
  add(header_38986051, "Accept", newJString(Accept))
  add(path_38986050, "repository", newJString(repository))
  add(path_38986050, "keyword", newJString(keyword))
  add(path_38986050, "state", newJString(state))
  result = call_38986049.call(path_38986050, nil, header_38986051, nil, nil)

var getLegacyIssuesSearchOwnerRepositoryStateKeyword* = Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_38986040(
    name: "getLegacyIssuesSearchOwnerRepositoryStateKeyword",
    meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/legacy/issues/search/{owner}/{repository}/{state}/{keyword}",
    validator: validate_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_38986041,
    base: "/", url: url_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_38986042,
    schemes: {Scheme.Https})
type
  Call_GetLegacyReposSearchKeyword_38986052 = ref object of OpenApiRestCall_38985352
proc url_GetLegacyReposSearchKeyword_38986054(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyword" in path, "`keyword` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/repos/search/"),
               (kind: VariableSegment, value: "keyword")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyReposSearchKeyword_38986053(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Find repositories by keyword. Note, this legacy method does not follow the v3 pagination pattern. This method returns up to 100 results per page and pages can be fetched using the start_page parameter.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyword: JString (required)
  ##          : The search term
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyword` field"
  var valid_38986055 = path.getOrDefault("keyword")
  valid_38986055 = validateParameter(valid_38986055, JString, required = true,
                                   default = nil)
  if valid_38986055 != nil:
    section.add "keyword", valid_38986055
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   language: JString
  ##           : Filter results by language
  ##   start_page: JString
  ##             : The page number to fetch
  ##   sort: JString
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  section = newJObject()
  var valid_38986056 = query.getOrDefault("order")
  valid_38986056 = validateParameter(valid_38986056, JString, required = false,
                                   default = newJString("desc"))
  if valid_38986056 != nil:
    section.add "order", valid_38986056
  var valid_38986057 = query.getOrDefault("language")
  valid_38986057 = validateParameter(valid_38986057, JString, required = false,
                                   default = nil)
  if valid_38986057 != nil:
    section.add "language", valid_38986057
  var valid_38986058 = query.getOrDefault("start_page")
  valid_38986058 = validateParameter(valid_38986058, JString, required = false,
                                   default = nil)
  if valid_38986058 != nil:
    section.add "start_page", valid_38986058
  var valid_38986059 = query.getOrDefault("sort")
  valid_38986059 = validateParameter(valid_38986059, JString, required = false,
                                   default = newJString("updated"))
  if valid_38986059 != nil:
    section.add "sort", valid_38986059
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986060 = header.getOrDefault("Accept")
  valid_38986060 = validateParameter(valid_38986060, JString, required = false,
                                   default = nil)
  if valid_38986060 != nil:
    section.add "Accept", valid_38986060
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986061: Call_GetLegacyReposSearchKeyword_38986052;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Find repositories by keyword. Note, this legacy method does not follow the v3 pagination pattern. This method returns up to 100 results per page and pages can be fetched using the start_page parameter.
  ## 
  let valid = call_38986061.validator(path, query, header, formData, body, _)
  let scheme = call_38986061.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986061.url(scheme.get, call_38986061.host, call_38986061.base,
                           call_38986061.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986061, url, valid, _)

proc call*(call_38986062: Call_GetLegacyReposSearchKeyword_38986052;
          keyword: string; order: string = "desc"; language: string = "";
          Accept: string = ""; startPage: string = ""; sort: string = "updated"): Recallable =
  ## getLegacyReposSearchKeyword
  ## Find repositories by keyword. Note, this legacy method does not follow the v3 pagination pattern. This method returns up to 100 results per page and pages can be fetched using the start_page parameter.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   language: string
  ##           : Filter results by language
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   startPage: string
  ##            : The page number to fetch
  ##   sort: string
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  ##   keyword: string (required)
  ##          : The search term
  var path_38986063 = newJObject()
  var query_38986064 = newJObject()
  var header_38986065 = newJObject()
  add(query_38986064, "order", newJString(order))
  add(query_38986064, "language", newJString(language))
  add(header_38986065, "Accept", newJString(Accept))
  add(query_38986064, "start_page", newJString(startPage))
  add(query_38986064, "sort", newJString(sort))
  add(path_38986063, "keyword", newJString(keyword))
  result = call_38986062.call(path_38986063, query_38986064, header_38986065, nil, nil)

var getLegacyReposSearchKeyword* = Call_GetLegacyReposSearchKeyword_38986052(
    name: "getLegacyReposSearchKeyword", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/legacy/repos/search/{keyword}",
    validator: validate_GetLegacyReposSearchKeyword_38986053, base: "/",
    url: url_GetLegacyReposSearchKeyword_38986054, schemes: {Scheme.Https})
type
  Call_GetLegacyUserEmailEmail_38986066 = ref object of OpenApiRestCall_38985352
proc url_GetLegacyUserEmailEmail_38986068(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "email" in path, "`email` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/user/email/"),
               (kind: VariableSegment, value: "email")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyUserEmailEmail_38986067(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## This API call is added for compatibility reasons only.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   email: JString (required)
  ##        : The email address
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `email` field"
  var valid_38986069 = path.getOrDefault("email")
  valid_38986069 = validateParameter(valid_38986069, JString, required = true,
                                   default = nil)
  if valid_38986069 != nil:
    section.add "email", valid_38986069
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986070 = header.getOrDefault("Accept")
  valid_38986070 = validateParameter(valid_38986070, JString, required = false,
                                   default = nil)
  if valid_38986070 != nil:
    section.add "Accept", valid_38986070
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986071: Call_GetLegacyUserEmailEmail_38986066;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## This API call is added for compatibility reasons only.
  ## 
  let valid = call_38986071.validator(path, query, header, formData, body, _)
  let scheme = call_38986071.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986071.url(scheme.get, call_38986071.host, call_38986071.base,
                           call_38986071.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986071, url, valid, _)

proc call*(call_38986072: Call_GetLegacyUserEmailEmail_38986066; email: string;
          Accept: string = ""): Recallable =
  ## getLegacyUserEmailEmail
  ## This API call is added for compatibility reasons only.
  ##   email: string (required)
  ##        : The email address
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_38986073 = newJObject()
  var header_38986074 = newJObject()
  add(path_38986073, "email", newJString(email))
  add(header_38986074, "Accept", newJString(Accept))
  result = call_38986072.call(path_38986073, nil, header_38986074, nil, nil)

var getLegacyUserEmailEmail* = Call_GetLegacyUserEmailEmail_38986066(
    name: "getLegacyUserEmailEmail", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/legacy/user/email/{email}",
    validator: validate_GetLegacyUserEmailEmail_38986067, base: "/",
    url: url_GetLegacyUserEmailEmail_38986068, schemes: {Scheme.Https})
type
  Call_GetLegacyUserSearchKeyword_38986075 = ref object of OpenApiRestCall_38985352
proc url_GetLegacyUserSearchKeyword_38986077(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyword" in path, "`keyword` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/user/search/"),
               (kind: VariableSegment, value: "keyword")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyUserSearchKeyword_38986076(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Find users by keyword.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyword: JString (required)
  ##          : The search term
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyword` field"
  var valid_38986078 = path.getOrDefault("keyword")
  valid_38986078 = validateParameter(valid_38986078, JString, required = true,
                                   default = nil)
  if valid_38986078 != nil:
    section.add "keyword", valid_38986078
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   start_page: JString
  ##             : The page number to fetch
  ##   sort: JString
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  section = newJObject()
  var valid_38986079 = query.getOrDefault("order")
  valid_38986079 = validateParameter(valid_38986079, JString, required = false,
                                   default = newJString("desc"))
  if valid_38986079 != nil:
    section.add "order", valid_38986079
  var valid_38986080 = query.getOrDefault("start_page")
  valid_38986080 = validateParameter(valid_38986080, JString, required = false,
                                   default = nil)
  if valid_38986080 != nil:
    section.add "start_page", valid_38986080
  var valid_38986081 = query.getOrDefault("sort")
  valid_38986081 = validateParameter(valid_38986081, JString, required = false,
                                   default = newJString("updated"))
  if valid_38986081 != nil:
    section.add "sort", valid_38986081
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986082 = header.getOrDefault("Accept")
  valid_38986082 = validateParameter(valid_38986082, JString, required = false,
                                   default = nil)
  if valid_38986082 != nil:
    section.add "Accept", valid_38986082
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986083: Call_GetLegacyUserSearchKeyword_38986075;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Find users by keyword.
  ## 
  let valid = call_38986083.validator(path, query, header, formData, body, _)
  let scheme = call_38986083.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986083.url(scheme.get, call_38986083.host, call_38986083.base,
                           call_38986083.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986083, url, valid, _)

proc call*(call_38986084: Call_GetLegacyUserSearchKeyword_38986075;
          keyword: string; order: string = "desc"; Accept: string = "";
          startPage: string = ""; sort: string = "updated"): Recallable =
  ## getLegacyUserSearchKeyword
  ## Find users by keyword.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   startPage: string
  ##            : The page number to fetch
  ##   sort: string
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  ##   keyword: string (required)
  ##          : The search term
  var path_38986085 = newJObject()
  var query_38986086 = newJObject()
  var header_38986087 = newJObject()
  add(query_38986086, "order", newJString(order))
  add(header_38986087, "Accept", newJString(Accept))
  add(query_38986086, "start_page", newJString(startPage))
  add(query_38986086, "sort", newJString(sort))
  add(path_38986085, "keyword", newJString(keyword))
  result = call_38986084.call(path_38986085, query_38986086, header_38986087, nil, nil)

var getLegacyUserSearchKeyword* = Call_GetLegacyUserSearchKeyword_38986075(
    name: "getLegacyUserSearchKeyword", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/legacy/user/search/{keyword}",
    validator: validate_GetLegacyUserSearchKeyword_38986076, base: "/",
    url: url_GetLegacyUserSearchKeyword_38986077, schemes: {Scheme.Https})
type
  Call_PostMarkdown_38986088 = ref object of OpenApiRestCall_38985352
proc url_PostMarkdown_38986090(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostMarkdown_38986089(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## Render an arbitrary Markdown document
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986091 = header.getOrDefault("Accept")
  valid_38986091 = validateParameter(valid_38986091, JString, required = false,
                                   default = nil)
  if valid_38986091 != nil:
    section.add "Accept", valid_38986091
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38986093: Call_PostMarkdown_38986088; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Render an arbitrary Markdown document
  ## 
  let valid = call_38986093.validator(path, query, header, formData, body, _)
  let scheme = call_38986093.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986093.url(scheme.get, call_38986093.host, call_38986093.base,
                           call_38986093.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986093, url, valid, _)

proc call*(call_38986094: Call_PostMarkdown_38986088; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postMarkdown
  ## Render an arbitrary Markdown document
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_38986095 = newJObject()
  var body_38986096 = newJObject()
  add(header_38986095, "Accept", newJString(Accept))
  if body != nil:
    body_38986096 = body
  result = call_38986094.call(nil, nil, header_38986095, nil, body_38986096)

var postMarkdown* = Call_PostMarkdown_38986088(name: "postMarkdown",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/markdown",
    validator: validate_PostMarkdown_38986089, base: "/", url: url_PostMarkdown_38986090,
    schemes: {Scheme.Https})
type
  Call_PostMarkdownRaw_38986097 = ref object of OpenApiRestCall_38985352
proc url_PostMarkdownRaw_38986099(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostMarkdownRaw_38986098(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Render a Markdown document in raw mode
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986100 = header.getOrDefault("Accept")
  valid_38986100 = validateParameter(valid_38986100, JString, required = false,
                                   default = nil)
  if valid_38986100 != nil:
    section.add "Accept", valid_38986100
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986101: Call_PostMarkdownRaw_38986097; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Render a Markdown document in raw mode
  ## 
  let valid = call_38986101.validator(path, query, header, formData, body, _)
  let scheme = call_38986101.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986101.url(scheme.get, call_38986101.host, call_38986101.base,
                           call_38986101.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986101, url, valid, _)

proc call*(call_38986102: Call_PostMarkdownRaw_38986097; Accept: string = ""): Recallable =
  ## postMarkdownRaw
  ## Render a Markdown document in raw mode
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_38986103 = newJObject()
  add(header_38986103, "Accept", newJString(Accept))
  result = call_38986102.call(nil, nil, header_38986103, nil, nil)

var postMarkdownRaw* = Call_PostMarkdownRaw_38986097(name: "postMarkdownRaw",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/markdown/raw",
    validator: validate_PostMarkdownRaw_38986098, base: "/",
    url: url_PostMarkdownRaw_38986099, schemes: {Scheme.Https})
type
  Call_GetMeta_38986104 = ref object of OpenApiRestCall_38985352
proc url_GetMeta_38986106(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetMeta_38986105(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## This gives some information about GitHub.com, the service.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986107 = header.getOrDefault("Accept")
  valid_38986107 = validateParameter(valid_38986107, JString, required = false,
                                   default = nil)
  if valid_38986107 != nil:
    section.add "Accept", valid_38986107
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986108: Call_GetMeta_38986104; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## This gives some information about GitHub.com, the service.
  ## 
  let valid = call_38986108.validator(path, query, header, formData, body, _)
  let scheme = call_38986108.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986108.url(scheme.get, call_38986108.host, call_38986108.base,
                           call_38986108.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986108, url, valid, _)

proc call*(call_38986109: Call_GetMeta_38986104; Accept: string = ""): Recallable =
  ## getMeta
  ## This gives some information about GitHub.com, the service.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_38986110 = newJObject()
  add(header_38986110, "Accept", newJString(Accept))
  result = call_38986109.call(nil, nil, header_38986110, nil, nil)

var getMeta* = Call_GetMeta_38986104(name: "getMeta", meth: HttpMethod.HttpGet,
                                  host: "api.github.com", route: "/meta",
                                  validator: validate_GetMeta_38986105, base: "/",
                                  url: url_GetMeta_38986106,
                                  schemes: {Scheme.Https})
type
  Call_GetNetworksOwnerRepoEvents_38986111 = ref object of OpenApiRestCall_38985352
proc url_GetNetworksOwnerRepoEvents_38986113(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/networks/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetNetworksOwnerRepoEvents_38986112(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List public events for a network of repositories.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of the owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986114 = path.getOrDefault("owner")
  valid_38986114 = validateParameter(valid_38986114, JString, required = true,
                                   default = nil)
  if valid_38986114 != nil:
    section.add "owner", valid_38986114
  var valid_38986115 = path.getOrDefault("repo")
  valid_38986115 = validateParameter(valid_38986115, JString, required = true,
                                   default = nil)
  if valid_38986115 != nil:
    section.add "repo", valid_38986115
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986116 = header.getOrDefault("Accept")
  valid_38986116 = validateParameter(valid_38986116, JString, required = false,
                                   default = nil)
  if valid_38986116 != nil:
    section.add "Accept", valid_38986116
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986117: Call_GetNetworksOwnerRepoEvents_38986111;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List public events for a network of repositories.
  ## 
  let valid = call_38986117.validator(path, query, header, formData, body, _)
  let scheme = call_38986117.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986117.url(scheme.get, call_38986117.host, call_38986117.base,
                           call_38986117.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986117, url, valid, _)

proc call*(call_38986118: Call_GetNetworksOwnerRepoEvents_38986111; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getNetworksOwnerRepoEvents
  ## List public events for a network of repositories.
  ##   owner: string (required)
  ##        : Name of the owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986119 = newJObject()
  var header_38986120 = newJObject()
  add(path_38986119, "owner", newJString(owner))
  add(header_38986120, "Accept", newJString(Accept))
  add(path_38986119, "repo", newJString(repo))
  result = call_38986118.call(path_38986119, nil, header_38986120, nil, nil)

var getNetworksOwnerRepoEvents* = Call_GetNetworksOwnerRepoEvents_38986111(
    name: "getNetworksOwnerRepoEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/networks/{owner}/{repo}/events",
    validator: validate_GetNetworksOwnerRepoEvents_38986112, base: "/",
    url: url_GetNetworksOwnerRepoEvents_38986113, schemes: {Scheme.Https})
type
  Call_PutNotifications_38986132 = ref object of OpenApiRestCall_38985352
proc url_PutNotifications_38986134(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PutNotifications_38986133(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Mark as read.
  ## Marking a notification as "read" removes it from the default view on GitHub.com.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986135 = header.getOrDefault("Accept")
  valid_38986135 = validateParameter(valid_38986135, JString, required = false,
                                   default = nil)
  if valid_38986135 != nil:
    section.add "Accept", valid_38986135
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38986137: Call_PutNotifications_38986132; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Mark as read.
  ## Marking a notification as "read" removes it from the default view on GitHub.com.
  ## 
  ## 
  let valid = call_38986137.validator(path, query, header, formData, body, _)
  let scheme = call_38986137.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986137.url(scheme.get, call_38986137.host, call_38986137.base,
                           call_38986137.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986137, url, valid, _)

proc call*(call_38986138: Call_PutNotifications_38986132; body: JsonNode;
          Accept: string = ""): Recallable =
  ## putNotifications
  ## Mark as read.
  ## Marking a notification as "read" removes it from the default view on GitHub.com.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_38986139 = newJObject()
  var body_38986140 = newJObject()
  add(header_38986139, "Accept", newJString(Accept))
  if body != nil:
    body_38986140 = body
  result = call_38986138.call(nil, nil, header_38986139, nil, body_38986140)

var putNotifications* = Call_PutNotifications_38986132(name: "putNotifications",
    meth: HttpMethod.HttpPut, host: "api.github.com", route: "/notifications",
    validator: validate_PutNotifications_38986133, base: "/",
    url: url_PutNotifications_38986134, schemes: {Scheme.Https})
type
  Call_GetNotifications_38986121 = ref object of OpenApiRestCall_38985352
proc url_GetNotifications_38986123(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetNotifications_38986122(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List your notifications.
  ## List all notifications for the current user, grouped by repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   participating: JBool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  ##   all: JBool
  ##      : True to show notifications marked as read.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_38986124 = query.getOrDefault("participating")
  valid_38986124 = validateParameter(valid_38986124, JBool, required = false,
                                   default = nil)
  if valid_38986124 != nil:
    section.add "participating", valid_38986124
  var valid_38986125 = query.getOrDefault("all")
  valid_38986125 = validateParameter(valid_38986125, JBool, required = false,
                                   default = nil)
  if valid_38986125 != nil:
    section.add "all", valid_38986125
  var valid_38986126 = query.getOrDefault("since")
  valid_38986126 = validateParameter(valid_38986126, JString, required = false,
                                   default = nil)
  if valid_38986126 != nil:
    section.add "since", valid_38986126
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986127 = header.getOrDefault("Accept")
  valid_38986127 = validateParameter(valid_38986127, JString, required = false,
                                   default = nil)
  if valid_38986127 != nil:
    section.add "Accept", valid_38986127
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986128: Call_GetNotifications_38986121; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List your notifications.
  ## List all notifications for the current user, grouped by repository.
  ## 
  ## 
  let valid = call_38986128.validator(path, query, header, formData, body, _)
  let scheme = call_38986128.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986128.url(scheme.get, call_38986128.host, call_38986128.base,
                           call_38986128.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986128, url, valid, _)

proc call*(call_38986129: Call_GetNotifications_38986121;
          participating: bool = false; all: bool = false; Accept: string = "";
          since: string = ""): Recallable =
  ## getNotifications
  ## List your notifications.
  ## List all notifications for the current user, grouped by repository.
  ## 
  ##   participating: bool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  ##   all: bool
  ##      : True to show notifications marked as read.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var query_38986130 = newJObject()
  var header_38986131 = newJObject()
  add(query_38986130, "participating", newJBool(participating))
  add(query_38986130, "all", newJBool(all))
  add(header_38986131, "Accept", newJString(Accept))
  add(query_38986130, "since", newJString(since))
  result = call_38986129.call(nil, query_38986130, header_38986131, nil, nil)

var getNotifications* = Call_GetNotifications_38986121(name: "getNotifications",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/notifications",
    validator: validate_GetNotifications_38986122, base: "/",
    url: url_GetNotifications_38986123, schemes: {Scheme.Https})
type
  Call_GetNotificationsThreadsId_38986141 = ref object of OpenApiRestCall_38985352
proc url_GetNotificationsThreadsId_38986143(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetNotificationsThreadsId_38986142(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## View a single thread.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_38986144 = path.getOrDefault("id")
  valid_38986144 = validateParameter(valid_38986144, JInt, required = true,
                                   default = nil)
  if valid_38986144 != nil:
    section.add "id", valid_38986144
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986145 = header.getOrDefault("Accept")
  valid_38986145 = validateParameter(valid_38986145, JString, required = false,
                                   default = nil)
  if valid_38986145 != nil:
    section.add "Accept", valid_38986145
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986146: Call_GetNotificationsThreadsId_38986141;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## View a single thread.
  ## 
  let valid = call_38986146.validator(path, query, header, formData, body, _)
  let scheme = call_38986146.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986146.url(scheme.get, call_38986146.host, call_38986146.base,
                           call_38986146.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986146, url, valid, _)

proc call*(call_38986147: Call_GetNotificationsThreadsId_38986141; id: int;
          Accept: string = ""): Recallable =
  ## getNotificationsThreadsId
  ## View a single thread.
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_38986148 = newJObject()
  var header_38986149 = newJObject()
  add(path_38986148, "id", newJInt(id))
  add(header_38986149, "Accept", newJString(Accept))
  result = call_38986147.call(path_38986148, nil, header_38986149, nil, nil)

var getNotificationsThreadsId* = Call_GetNotificationsThreadsId_38986141(
    name: "getNotificationsThreadsId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/notifications/threads/{id}",
    validator: validate_GetNotificationsThreadsId_38986142, base: "/",
    url: url_GetNotificationsThreadsId_38986143, schemes: {Scheme.Https})
type
  Call_PatchNotificationsThreadsId_38986150 = ref object of OpenApiRestCall_38985352
proc url_PatchNotificationsThreadsId_38986152(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchNotificationsThreadsId_38986151(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Mark a thread as read
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_38986153 = path.getOrDefault("id")
  valid_38986153 = validateParameter(valid_38986153, JInt, required = true,
                                   default = nil)
  if valid_38986153 != nil:
    section.add "id", valid_38986153
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986154 = header.getOrDefault("Accept")
  valid_38986154 = validateParameter(valid_38986154, JString, required = false,
                                   default = nil)
  if valid_38986154 != nil:
    section.add "Accept", valid_38986154
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986155: Call_PatchNotificationsThreadsId_38986150;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Mark a thread as read
  ## 
  let valid = call_38986155.validator(path, query, header, formData, body, _)
  let scheme = call_38986155.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986155.url(scheme.get, call_38986155.host, call_38986155.base,
                           call_38986155.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986155, url, valid, _)

proc call*(call_38986156: Call_PatchNotificationsThreadsId_38986150; id: int;
          Accept: string = ""): Recallable =
  ## patchNotificationsThreadsId
  ## Mark a thread as read
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_38986157 = newJObject()
  var header_38986158 = newJObject()
  add(path_38986157, "id", newJInt(id))
  add(header_38986158, "Accept", newJString(Accept))
  result = call_38986156.call(path_38986157, nil, header_38986158, nil, nil)

var patchNotificationsThreadsId* = Call_PatchNotificationsThreadsId_38986150(
    name: "patchNotificationsThreadsId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/notifications/threads/{id}",
    validator: validate_PatchNotificationsThreadsId_38986151, base: "/",
    url: url_PatchNotificationsThreadsId_38986152, schemes: {Scheme.Https})
type
  Call_PutNotificationsThreadsIdSubscription_38986168 = ref object of OpenApiRestCall_38985352
proc url_PutNotificationsThreadsIdSubscription_38986170(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutNotificationsThreadsIdSubscription_38986169(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Set a Thread Subscription.
  ## This lets you subscribe to a thread, or ignore it. Subscribing to a thread
  ## is unnecessary if the user is already subscribed to the repository. Ignoring
  ## a thread will mute all future notifications (until you comment or get @mentioned).
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_38986171 = path.getOrDefault("id")
  valid_38986171 = validateParameter(valid_38986171, JInt, required = true,
                                   default = nil)
  if valid_38986171 != nil:
    section.add "id", valid_38986171
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986172 = header.getOrDefault("Accept")
  valid_38986172 = validateParameter(valid_38986172, JString, required = false,
                                   default = nil)
  if valid_38986172 != nil:
    section.add "Accept", valid_38986172
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38986174: Call_PutNotificationsThreadsIdSubscription_38986168;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Set a Thread Subscription.
  ## This lets you subscribe to a thread, or ignore it. Subscribing to a thread
  ## is unnecessary if the user is already subscribed to the repository. Ignoring
  ## a thread will mute all future notifications (until you comment or get @mentioned).
  ## 
  ## 
  let valid = call_38986174.validator(path, query, header, formData, body, _)
  let scheme = call_38986174.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986174.url(scheme.get, call_38986174.host, call_38986174.base,
                           call_38986174.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986174, url, valid, _)

proc call*(call_38986175: Call_PutNotificationsThreadsIdSubscription_38986168;
          id: int; body: JsonNode; Accept: string = ""): Recallable =
  ## putNotificationsThreadsIdSubscription
  ## Set a Thread Subscription.
  ## This lets you subscribe to a thread, or ignore it. Subscribing to a thread
  ## is unnecessary if the user is already subscribed to the repository. Ignoring
  ## a thread will mute all future notifications (until you comment or get @mentioned).
  ## 
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var path_38986176 = newJObject()
  var header_38986177 = newJObject()
  var body_38986178 = newJObject()
  add(path_38986176, "id", newJInt(id))
  add(header_38986177, "Accept", newJString(Accept))
  if body != nil:
    body_38986178 = body
  result = call_38986175.call(path_38986176, nil, header_38986177, nil, body_38986178)

var putNotificationsThreadsIdSubscription* = Call_PutNotificationsThreadsIdSubscription_38986168(
    name: "putNotificationsThreadsIdSubscription", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/notifications/threads/{id}/subscription",
    validator: validate_PutNotificationsThreadsIdSubscription_38986169, base: "/",
    url: url_PutNotificationsThreadsIdSubscription_38986170,
    schemes: {Scheme.Https})
type
  Call_GetNotificationsThreadsIdSubscription_38986159 = ref object of OpenApiRestCall_38985352
proc url_GetNotificationsThreadsIdSubscription_38986161(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetNotificationsThreadsIdSubscription_38986160(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a Thread Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_38986162 = path.getOrDefault("id")
  valid_38986162 = validateParameter(valid_38986162, JInt, required = true,
                                   default = nil)
  if valid_38986162 != nil:
    section.add "id", valid_38986162
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986163 = header.getOrDefault("Accept")
  valid_38986163 = validateParameter(valid_38986163, JString, required = false,
                                   default = nil)
  if valid_38986163 != nil:
    section.add "Accept", valid_38986163
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986164: Call_GetNotificationsThreadsIdSubscription_38986159;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a Thread Subscription.
  ## 
  let valid = call_38986164.validator(path, query, header, formData, body, _)
  let scheme = call_38986164.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986164.url(scheme.get, call_38986164.host, call_38986164.base,
                           call_38986164.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986164, url, valid, _)

proc call*(call_38986165: Call_GetNotificationsThreadsIdSubscription_38986159;
          id: int; Accept: string = ""): Recallable =
  ## getNotificationsThreadsIdSubscription
  ## Get a Thread Subscription.
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_38986166 = newJObject()
  var header_38986167 = newJObject()
  add(path_38986166, "id", newJInt(id))
  add(header_38986167, "Accept", newJString(Accept))
  result = call_38986165.call(path_38986166, nil, header_38986167, nil, nil)

var getNotificationsThreadsIdSubscription* = Call_GetNotificationsThreadsIdSubscription_38986159(
    name: "getNotificationsThreadsIdSubscription", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/notifications/threads/{id}/subscription",
    validator: validate_GetNotificationsThreadsIdSubscription_38986160, base: "/",
    url: url_GetNotificationsThreadsIdSubscription_38986161,
    schemes: {Scheme.Https})
type
  Call_DeleteNotificationsThreadsIdSubscription_38986179 = ref object of OpenApiRestCall_38985352
proc url_DeleteNotificationsThreadsIdSubscription_38986181(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteNotificationsThreadsIdSubscription_38986180(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a Thread Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_38986182 = path.getOrDefault("id")
  valid_38986182 = validateParameter(valid_38986182, JInt, required = true,
                                   default = nil)
  if valid_38986182 != nil:
    section.add "id", valid_38986182
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986183 = header.getOrDefault("Accept")
  valid_38986183 = validateParameter(valid_38986183, JString, required = false,
                                   default = nil)
  if valid_38986183 != nil:
    section.add "Accept", valid_38986183
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986184: Call_DeleteNotificationsThreadsIdSubscription_38986179;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a Thread Subscription.
  ## 
  let valid = call_38986184.validator(path, query, header, formData, body, _)
  let scheme = call_38986184.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986184.url(scheme.get, call_38986184.host, call_38986184.base,
                           call_38986184.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986184, url, valid, _)

proc call*(call_38986185: Call_DeleteNotificationsThreadsIdSubscription_38986179;
          id: int; Accept: string = ""): Recallable =
  ## deleteNotificationsThreadsIdSubscription
  ## Delete a Thread Subscription.
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_38986186 = newJObject()
  var header_38986187 = newJObject()
  add(path_38986186, "id", newJInt(id))
  add(header_38986187, "Accept", newJString(Accept))
  result = call_38986185.call(path_38986186, nil, header_38986187, nil, nil)

var deleteNotificationsThreadsIdSubscription* = Call_DeleteNotificationsThreadsIdSubscription_38986179(
    name: "deleteNotificationsThreadsIdSubscription", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/notifications/threads/{id}/subscription",
    validator: validate_DeleteNotificationsThreadsIdSubscription_38986180,
    base: "/", url: url_DeleteNotificationsThreadsIdSubscription_38986181,
    schemes: {Scheme.Https})
type
  Call_GetOrgsOrg_38986188 = ref object of OpenApiRestCall_38985352
proc url_GetOrgsOrg_38986190(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrg_38986189(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get an Organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_38986191 = path.getOrDefault("org")
  valid_38986191 = validateParameter(valid_38986191, JString, required = true,
                                   default = nil)
  if valid_38986191 != nil:
    section.add "org", valid_38986191
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986192 = header.getOrDefault("Accept")
  valid_38986192 = validateParameter(valid_38986192, JString, required = false,
                                   default = nil)
  if valid_38986192 != nil:
    section.add "Accept", valid_38986192
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986193: Call_GetOrgsOrg_38986188; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get an Organization.
  ## 
  let valid = call_38986193.validator(path, query, header, formData, body, _)
  let scheme = call_38986193.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986193.url(scheme.get, call_38986193.host, call_38986193.base,
                           call_38986193.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986193, url, valid, _)

proc call*(call_38986194: Call_GetOrgsOrg_38986188; org: string; Accept: string = ""): Recallable =
  ## getOrgsOrg
  ## Get an Organization.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_38986195 = newJObject()
  var header_38986196 = newJObject()
  add(header_38986196, "Accept", newJString(Accept))
  add(path_38986195, "org", newJString(org))
  result = call_38986194.call(path_38986195, nil, header_38986196, nil, nil)

var getOrgsOrg* = Call_GetOrgsOrg_38986188(name: "getOrgsOrg",
                                        meth: HttpMethod.HttpGet,
                                        host: "api.github.com",
                                        route: "/orgs/{org}",
                                        validator: validate_GetOrgsOrg_38986189,
                                        base: "/", url: url_GetOrgsOrg_38986190,
                                        schemes: {Scheme.Https})
type
  Call_PatchOrgsOrg_38986197 = ref object of OpenApiRestCall_38985352
proc url_PatchOrgsOrg_38986199(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchOrgsOrg_38986198(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## Edit an Organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_38986200 = path.getOrDefault("org")
  valid_38986200 = validateParameter(valid_38986200, JString, required = true,
                                   default = nil)
  if valid_38986200 != nil:
    section.add "org", valid_38986200
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986201 = header.getOrDefault("Accept")
  valid_38986201 = validateParameter(valid_38986201, JString, required = false,
                                   default = nil)
  if valid_38986201 != nil:
    section.add "Accept", valid_38986201
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38986203: Call_PatchOrgsOrg_38986197; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit an Organization.
  ## 
  let valid = call_38986203.validator(path, query, header, formData, body, _)
  let scheme = call_38986203.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986203.url(scheme.get, call_38986203.host, call_38986203.base,
                           call_38986203.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986203, url, valid, _)

proc call*(call_38986204: Call_PatchOrgsOrg_38986197; body: JsonNode; org: string;
          Accept: string = ""): Recallable =
  ## patchOrgsOrg
  ## Edit an Organization.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   org: string (required)
  ##      : Name of organisation.
  var path_38986205 = newJObject()
  var header_38986206 = newJObject()
  var body_38986207 = newJObject()
  add(header_38986206, "Accept", newJString(Accept))
  if body != nil:
    body_38986207 = body
  add(path_38986205, "org", newJString(org))
  result = call_38986204.call(path_38986205, nil, header_38986206, nil, body_38986207)

var patchOrgsOrg* = Call_PatchOrgsOrg_38986197(name: "patchOrgsOrg",
    meth: HttpMethod.HttpPatch, host: "api.github.com", route: "/orgs/{org}",
    validator: validate_PatchOrgsOrg_38986198, base: "/", url: url_PatchOrgsOrg_38986199,
    schemes: {Scheme.Https})
type
  Call_GetOrgsOrgEvents_38986208 = ref object of OpenApiRestCall_38985352
proc url_GetOrgsOrgEvents_38986210(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgEvents_38986209(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List public events for an organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_38986211 = path.getOrDefault("org")
  valid_38986211 = validateParameter(valid_38986211, JString, required = true,
                                   default = nil)
  if valid_38986211 != nil:
    section.add "org", valid_38986211
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986212 = header.getOrDefault("Accept")
  valid_38986212 = validateParameter(valid_38986212, JString, required = false,
                                   default = nil)
  if valid_38986212 != nil:
    section.add "Accept", valid_38986212
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986213: Call_GetOrgsOrgEvents_38986208; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List public events for an organization.
  ## 
  let valid = call_38986213.validator(path, query, header, formData, body, _)
  let scheme = call_38986213.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986213.url(scheme.get, call_38986213.host, call_38986213.base,
                           call_38986213.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986213, url, valid, _)

proc call*(call_38986214: Call_GetOrgsOrgEvents_38986208; org: string;
          Accept: string = ""): Recallable =
  ## getOrgsOrgEvents
  ## List public events for an organization.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_38986215 = newJObject()
  var header_38986216 = newJObject()
  add(header_38986216, "Accept", newJString(Accept))
  add(path_38986215, "org", newJString(org))
  result = call_38986214.call(path_38986215, nil, header_38986216, nil, nil)

var getOrgsOrgEvents* = Call_GetOrgsOrgEvents_38986208(name: "getOrgsOrgEvents",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/events",
    validator: validate_GetOrgsOrgEvents_38986209, base: "/",
    url: url_GetOrgsOrgEvents_38986210, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgIssues_38986217 = ref object of OpenApiRestCall_38985352
proc url_GetOrgsOrgIssues_38986219(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/issues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgIssues_38986218(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List issues.
  ## List all issues for a given organization for the authenticated user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_38986220 = path.getOrDefault("org")
  valid_38986220 = validateParameter(valid_38986220, JString, required = true,
                                   default = nil)
  if valid_38986220 != nil:
    section.add "org", valid_38986220
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString (required)
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: JString (required)
  ##   direction: JString (required)
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_38986221 = query.getOrDefault("state")
  valid_38986221 = validateParameter(valid_38986221, JString, required = true,
                                   default = newJString("open"))
  if valid_38986221 != nil:
    section.add "state", valid_38986221
  var valid_38986222 = query.getOrDefault("labels")
  valid_38986222 = validateParameter(valid_38986222, JString, required = true,
                                   default = nil)
  if valid_38986222 != nil:
    section.add "labels", valid_38986222
  var valid_38986223 = query.getOrDefault("sort")
  valid_38986223 = validateParameter(valid_38986223, JString, required = true,
                                   default = newJString("created"))
  if valid_38986223 != nil:
    section.add "sort", valid_38986223
  var valid_38986224 = query.getOrDefault("direction")
  valid_38986224 = validateParameter(valid_38986224, JString, required = true,
                                   default = newJString("desc"))
  if valid_38986224 != nil:
    section.add "direction", valid_38986224
  var valid_38986225 = query.getOrDefault("filter")
  valid_38986225 = validateParameter(valid_38986225, JString, required = true,
                                   default = newJString("all"))
  if valid_38986225 != nil:
    section.add "filter", valid_38986225
  var valid_38986226 = query.getOrDefault("since")
  valid_38986226 = validateParameter(valid_38986226, JString, required = false,
                                   default = nil)
  if valid_38986226 != nil:
    section.add "since", valid_38986226
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986227 = header.getOrDefault("Accept")
  valid_38986227 = validateParameter(valid_38986227, JString, required = false,
                                   default = nil)
  if valid_38986227 != nil:
    section.add "Accept", valid_38986227
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986228: Call_GetOrgsOrgIssues_38986217; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List issues.
  ## List all issues for a given organization for the authenticated user.
  ## 
  ## 
  let valid = call_38986228.validator(path, query, header, formData, body, _)
  let scheme = call_38986228.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986228.url(scheme.get, call_38986228.host, call_38986228.base,
                           call_38986228.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986228, url, valid, _)

proc call*(call_38986229: Call_GetOrgsOrgIssues_38986217; labels: string;
          org: string; state: string = "open"; Accept: string = "";
          sort: string = "created"; direction: string = "desc"; filter: string = "all";
          since: string = ""): Recallable =
  ## getOrgsOrgIssues
  ## List issues.
  ## List all issues for a given organization for the authenticated user.
  ## 
  ##   state: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: string (required)
  ##   direction: string (required)
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   org: string (required)
  ##      : Name of organisation.
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  var path_38986230 = newJObject()
  var query_38986231 = newJObject()
  var header_38986232 = newJObject()
  add(query_38986231, "state", newJString(state))
  add(header_38986232, "Accept", newJString(Accept))
  add(query_38986231, "labels", newJString(labels))
  add(query_38986231, "sort", newJString(sort))
  add(query_38986231, "direction", newJString(direction))
  add(query_38986231, "filter", newJString(filter))
  add(path_38986230, "org", newJString(org))
  add(query_38986231, "since", newJString(since))
  result = call_38986229.call(path_38986230, query_38986231, header_38986232, nil, nil)

var getOrgsOrgIssues* = Call_GetOrgsOrgIssues_38986217(name: "getOrgsOrgIssues",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/issues",
    validator: validate_GetOrgsOrgIssues_38986218, base: "/",
    url: url_GetOrgsOrgIssues_38986219, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgMembers_38986233 = ref object of OpenApiRestCall_38985352
proc url_GetOrgsOrgMembers_38986235(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/members")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgMembers_38986234(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Members list.
  ## List all users who are members of an organization. A member is a user tha
  ## belongs to at least 1 team in the organization. If the authenticated user
  ## is also an owner of this organization then both concealed and public members
  ## will be returned. If the requester is not an owner of the organization the
  ## query will be redirected to the public members list.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_38986236 = path.getOrDefault("org")
  valid_38986236 = validateParameter(valid_38986236, JString, required = true,
                                   default = nil)
  if valid_38986236 != nil:
    section.add "org", valid_38986236
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986237 = header.getOrDefault("Accept")
  valid_38986237 = validateParameter(valid_38986237, JString, required = false,
                                   default = nil)
  if valid_38986237 != nil:
    section.add "Accept", valid_38986237
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986238: Call_GetOrgsOrgMembers_38986233; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Members list.
  ## List all users who are members of an organization. A member is a user tha
  ## belongs to at least 1 team in the organization. If the authenticated user
  ## is also an owner of this organization then both concealed and public members
  ## will be returned. If the requester is not an owner of the organization the
  ## query will be redirected to the public members list.
  ## 
  ## 
  let valid = call_38986238.validator(path, query, header, formData, body, _)
  let scheme = call_38986238.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986238.url(scheme.get, call_38986238.host, call_38986238.base,
                           call_38986238.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986238, url, valid, _)

proc call*(call_38986239: Call_GetOrgsOrgMembers_38986233; org: string;
          Accept: string = ""): Recallable =
  ## getOrgsOrgMembers
  ## Members list.
  ## List all users who are members of an organization. A member is a user tha
  ## belongs to at least 1 team in the organization. If the authenticated user
  ## is also an owner of this organization then both concealed and public members
  ## will be returned. If the requester is not an owner of the organization the
  ## query will be redirected to the public members list.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_38986240 = newJObject()
  var header_38986241 = newJObject()
  add(header_38986241, "Accept", newJString(Accept))
  add(path_38986240, "org", newJString(org))
  result = call_38986239.call(path_38986240, nil, header_38986241, nil, nil)

var getOrgsOrgMembers* = Call_GetOrgsOrgMembers_38986233(name: "getOrgsOrgMembers",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/members",
    validator: validate_GetOrgsOrgMembers_38986234, base: "/",
    url: url_GetOrgsOrgMembers_38986235, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgMembersUsername_38986242 = ref object of OpenApiRestCall_38985352
proc url_GetOrgsOrgMembersUsername_38986244(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgMembersUsername_38986243(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Check if a user is, publicly or privately, a member of the organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of the user.
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_38986245 = path.getOrDefault("username")
  valid_38986245 = validateParameter(valid_38986245, JString, required = true,
                                   default = nil)
  if valid_38986245 != nil:
    section.add "username", valid_38986245
  var valid_38986246 = path.getOrDefault("org")
  valid_38986246 = validateParameter(valid_38986246, JString, required = true,
                                   default = nil)
  if valid_38986246 != nil:
    section.add "org", valid_38986246
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986247 = header.getOrDefault("Accept")
  valid_38986247 = validateParameter(valid_38986247, JString, required = false,
                                   default = nil)
  if valid_38986247 != nil:
    section.add "Accept", valid_38986247
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986248: Call_GetOrgsOrgMembersUsername_38986242;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if a user is, publicly or privately, a member of the organization.
  ## 
  let valid = call_38986248.validator(path, query, header, formData, body, _)
  let scheme = call_38986248.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986248.url(scheme.get, call_38986248.host, call_38986248.base,
                           call_38986248.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986248, url, valid, _)

proc call*(call_38986249: Call_GetOrgsOrgMembersUsername_38986242;
          username: string; org: string; Accept: string = ""): Recallable =
  ## getOrgsOrgMembersUsername
  ## Check if a user is, publicly or privately, a member of the organization.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_38986250 = newJObject()
  var header_38986251 = newJObject()
  add(path_38986250, "username", newJString(username))
  add(header_38986251, "Accept", newJString(Accept))
  add(path_38986250, "org", newJString(org))
  result = call_38986249.call(path_38986250, nil, header_38986251, nil, nil)

var getOrgsOrgMembersUsername* = Call_GetOrgsOrgMembersUsername_38986242(
    name: "getOrgsOrgMembersUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/orgs/{org}/members/{username}",
    validator: validate_GetOrgsOrgMembersUsername_38986243, base: "/",
    url: url_GetOrgsOrgMembersUsername_38986244, schemes: {Scheme.Https})
type
  Call_DeleteOrgsOrgMembersUsername_38986252 = ref object of OpenApiRestCall_38985352
proc url_DeleteOrgsOrgMembersUsername_38986254(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteOrgsOrgMembersUsername_38986253(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Remove a member.
  ## Removing a user from this list will remove them from all teams and they
  ## will no longer have any access to the organization's repositories.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of the user.
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_38986255 = path.getOrDefault("username")
  valid_38986255 = validateParameter(valid_38986255, JString, required = true,
                                   default = nil)
  if valid_38986255 != nil:
    section.add "username", valid_38986255
  var valid_38986256 = path.getOrDefault("org")
  valid_38986256 = validateParameter(valid_38986256, JString, required = true,
                                   default = nil)
  if valid_38986256 != nil:
    section.add "org", valid_38986256
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986257 = header.getOrDefault("Accept")
  valid_38986257 = validateParameter(valid_38986257, JString, required = false,
                                   default = nil)
  if valid_38986257 != nil:
    section.add "Accept", valid_38986257
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986258: Call_DeleteOrgsOrgMembersUsername_38986252;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Remove a member.
  ## Removing a user from this list will remove them from all teams and they
  ## will no longer have any access to the organization's repositories.
  ## 
  ## 
  let valid = call_38986258.validator(path, query, header, formData, body, _)
  let scheme = call_38986258.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986258.url(scheme.get, call_38986258.host, call_38986258.base,
                           call_38986258.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986258, url, valid, _)

proc call*(call_38986259: Call_DeleteOrgsOrgMembersUsername_38986252;
          username: string; org: string; Accept: string = ""): Recallable =
  ## deleteOrgsOrgMembersUsername
  ## Remove a member.
  ## Removing a user from this list will remove them from all teams and they
  ## will no longer have any access to the organization's repositories.
  ## 
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_38986260 = newJObject()
  var header_38986261 = newJObject()
  add(path_38986260, "username", newJString(username))
  add(header_38986261, "Accept", newJString(Accept))
  add(path_38986260, "org", newJString(org))
  result = call_38986259.call(path_38986260, nil, header_38986261, nil, nil)

var deleteOrgsOrgMembersUsername* = Call_DeleteOrgsOrgMembersUsername_38986252(
    name: "deleteOrgsOrgMembersUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/orgs/{org}/members/{username}",
    validator: validate_DeleteOrgsOrgMembersUsername_38986253, base: "/",
    url: url_DeleteOrgsOrgMembersUsername_38986254, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgPublicMembers_38986262 = ref object of OpenApiRestCall_38985352
proc url_GetOrgsOrgPublicMembers_38986264(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/public_members")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgPublicMembers_38986263(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Public members list.
  ## Members of an organization can choose to have their membership publicized
  ## or not.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_38986265 = path.getOrDefault("org")
  valid_38986265 = validateParameter(valid_38986265, JString, required = true,
                                   default = nil)
  if valid_38986265 != nil:
    section.add "org", valid_38986265
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986266 = header.getOrDefault("Accept")
  valid_38986266 = validateParameter(valid_38986266, JString, required = false,
                                   default = nil)
  if valid_38986266 != nil:
    section.add "Accept", valid_38986266
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986267: Call_GetOrgsOrgPublicMembers_38986262;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Public members list.
  ## Members of an organization can choose to have their membership publicized
  ## or not.
  ## 
  ## 
  let valid = call_38986267.validator(path, query, header, formData, body, _)
  let scheme = call_38986267.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986267.url(scheme.get, call_38986267.host, call_38986267.base,
                           call_38986267.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986267, url, valid, _)

proc call*(call_38986268: Call_GetOrgsOrgPublicMembers_38986262; org: string;
          Accept: string = ""): Recallable =
  ## getOrgsOrgPublicMembers
  ## Public members list.
  ## Members of an organization can choose to have their membership publicized
  ## or not.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_38986269 = newJObject()
  var header_38986270 = newJObject()
  add(header_38986270, "Accept", newJString(Accept))
  add(path_38986269, "org", newJString(org))
  result = call_38986268.call(path_38986269, nil, header_38986270, nil, nil)

var getOrgsOrgPublicMembers* = Call_GetOrgsOrgPublicMembers_38986262(
    name: "getOrgsOrgPublicMembers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/orgs/{org}/public_members",
    validator: validate_GetOrgsOrgPublicMembers_38986263, base: "/",
    url: url_GetOrgsOrgPublicMembers_38986264, schemes: {Scheme.Https})
type
  Call_PutOrgsOrgPublicMembersUsername_38986281 = ref object of OpenApiRestCall_38985352
proc url_PutOrgsOrgPublicMembersUsername_38986283(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/public_members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutOrgsOrgPublicMembersUsername_38986282(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Publicize a user's membership.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of the user.
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_38986284 = path.getOrDefault("username")
  valid_38986284 = validateParameter(valid_38986284, JString, required = true,
                                   default = nil)
  if valid_38986284 != nil:
    section.add "username", valid_38986284
  var valid_38986285 = path.getOrDefault("org")
  valid_38986285 = validateParameter(valid_38986285, JString, required = true,
                                   default = nil)
  if valid_38986285 != nil:
    section.add "org", valid_38986285
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986286 = header.getOrDefault("Accept")
  valid_38986286 = validateParameter(valid_38986286, JString, required = false,
                                   default = nil)
  if valid_38986286 != nil:
    section.add "Accept", valid_38986286
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986287: Call_PutOrgsOrgPublicMembersUsername_38986281;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Publicize a user's membership.
  ## 
  let valid = call_38986287.validator(path, query, header, formData, body, _)
  let scheme = call_38986287.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986287.url(scheme.get, call_38986287.host, call_38986287.base,
                           call_38986287.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986287, url, valid, _)

proc call*(call_38986288: Call_PutOrgsOrgPublicMembersUsername_38986281;
          username: string; org: string; Accept: string = ""): Recallable =
  ## putOrgsOrgPublicMembersUsername
  ## Publicize a user's membership.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_38986289 = newJObject()
  var header_38986290 = newJObject()
  add(path_38986289, "username", newJString(username))
  add(header_38986290, "Accept", newJString(Accept))
  add(path_38986289, "org", newJString(org))
  result = call_38986288.call(path_38986289, nil, header_38986290, nil, nil)

var putOrgsOrgPublicMembersUsername* = Call_PutOrgsOrgPublicMembersUsername_38986281(
    name: "putOrgsOrgPublicMembersUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/orgs/{org}/public_members/{username}",
    validator: validate_PutOrgsOrgPublicMembersUsername_38986282, base: "/",
    url: url_PutOrgsOrgPublicMembersUsername_38986283, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgPublicMembersUsername_38986271 = ref object of OpenApiRestCall_38985352
proc url_GetOrgsOrgPublicMembersUsername_38986273(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/public_members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgPublicMembersUsername_38986272(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Check public membership.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of the user.
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_38986274 = path.getOrDefault("username")
  valid_38986274 = validateParameter(valid_38986274, JString, required = true,
                                   default = nil)
  if valid_38986274 != nil:
    section.add "username", valid_38986274
  var valid_38986275 = path.getOrDefault("org")
  valid_38986275 = validateParameter(valid_38986275, JString, required = true,
                                   default = nil)
  if valid_38986275 != nil:
    section.add "org", valid_38986275
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986276 = header.getOrDefault("Accept")
  valid_38986276 = validateParameter(valid_38986276, JString, required = false,
                                   default = nil)
  if valid_38986276 != nil:
    section.add "Accept", valid_38986276
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986277: Call_GetOrgsOrgPublicMembersUsername_38986271;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check public membership.
  ## 
  let valid = call_38986277.validator(path, query, header, formData, body, _)
  let scheme = call_38986277.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986277.url(scheme.get, call_38986277.host, call_38986277.base,
                           call_38986277.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986277, url, valid, _)

proc call*(call_38986278: Call_GetOrgsOrgPublicMembersUsername_38986271;
          username: string; org: string; Accept: string = ""): Recallable =
  ## getOrgsOrgPublicMembersUsername
  ## Check public membership.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_38986279 = newJObject()
  var header_38986280 = newJObject()
  add(path_38986279, "username", newJString(username))
  add(header_38986280, "Accept", newJString(Accept))
  add(path_38986279, "org", newJString(org))
  result = call_38986278.call(path_38986279, nil, header_38986280, nil, nil)

var getOrgsOrgPublicMembersUsername* = Call_GetOrgsOrgPublicMembersUsername_38986271(
    name: "getOrgsOrgPublicMembersUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/orgs/{org}/public_members/{username}",
    validator: validate_GetOrgsOrgPublicMembersUsername_38986272, base: "/",
    url: url_GetOrgsOrgPublicMembersUsername_38986273, schemes: {Scheme.Https})
type
  Call_DeleteOrgsOrgPublicMembersUsername_38986291 = ref object of OpenApiRestCall_38985352
proc url_DeleteOrgsOrgPublicMembersUsername_38986293(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/public_members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteOrgsOrgPublicMembersUsername_38986292(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Conceal a user's membership.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of the user.
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_38986294 = path.getOrDefault("username")
  valid_38986294 = validateParameter(valid_38986294, JString, required = true,
                                   default = nil)
  if valid_38986294 != nil:
    section.add "username", valid_38986294
  var valid_38986295 = path.getOrDefault("org")
  valid_38986295 = validateParameter(valid_38986295, JString, required = true,
                                   default = nil)
  if valid_38986295 != nil:
    section.add "org", valid_38986295
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986296 = header.getOrDefault("Accept")
  valid_38986296 = validateParameter(valid_38986296, JString, required = false,
                                   default = nil)
  if valid_38986296 != nil:
    section.add "Accept", valid_38986296
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986297: Call_DeleteOrgsOrgPublicMembersUsername_38986291;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Conceal a user's membership.
  ## 
  let valid = call_38986297.validator(path, query, header, formData, body, _)
  let scheme = call_38986297.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986297.url(scheme.get, call_38986297.host, call_38986297.base,
                           call_38986297.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986297, url, valid, _)

proc call*(call_38986298: Call_DeleteOrgsOrgPublicMembersUsername_38986291;
          username: string; org: string; Accept: string = ""): Recallable =
  ## deleteOrgsOrgPublicMembersUsername
  ## Conceal a user's membership.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_38986299 = newJObject()
  var header_38986300 = newJObject()
  add(path_38986299, "username", newJString(username))
  add(header_38986300, "Accept", newJString(Accept))
  add(path_38986299, "org", newJString(org))
  result = call_38986298.call(path_38986299, nil, header_38986300, nil, nil)

var deleteOrgsOrgPublicMembersUsername* = Call_DeleteOrgsOrgPublicMembersUsername_38986291(
    name: "deleteOrgsOrgPublicMembersUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/orgs/{org}/public_members/{username}",
    validator: validate_DeleteOrgsOrgPublicMembersUsername_38986292, base: "/",
    url: url_DeleteOrgsOrgPublicMembersUsername_38986293, schemes: {Scheme.Https})
type
  Call_PostOrgsOrgRepos_38986312 = ref object of OpenApiRestCall_38985352
proc url_PostOrgsOrgRepos_38986314(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostOrgsOrgRepos_38986313(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_38986315 = path.getOrDefault("org")
  valid_38986315 = validateParameter(valid_38986315, JString, required = true,
                                   default = nil)
  if valid_38986315 != nil:
    section.add "org", valid_38986315
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986316 = header.getOrDefault("Accept")
  valid_38986316 = validateParameter(valid_38986316, JString, required = false,
                                   default = nil)
  if valid_38986316 != nil:
    section.add "Accept", valid_38986316
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38986318: Call_PostOrgsOrgRepos_38986312; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  let valid = call_38986318.validator(path, query, header, formData, body, _)
  let scheme = call_38986318.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986318.url(scheme.get, call_38986318.host, call_38986318.base,
                           call_38986318.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986318, url, valid, _)

proc call*(call_38986319: Call_PostOrgsOrgRepos_38986312; body: JsonNode;
          org: string; Accept: string = ""): Recallable =
  ## postOrgsOrgRepos
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   org: string (required)
  ##      : Name of organisation.
  var path_38986320 = newJObject()
  var header_38986321 = newJObject()
  var body_38986322 = newJObject()
  add(header_38986321, "Accept", newJString(Accept))
  if body != nil:
    body_38986322 = body
  add(path_38986320, "org", newJString(org))
  result = call_38986319.call(path_38986320, nil, header_38986321, nil, body_38986322)

var postOrgsOrgRepos* = Call_PostOrgsOrgRepos_38986312(name: "postOrgsOrgRepos",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/orgs/{org}/repos",
    validator: validate_PostOrgsOrgRepos_38986313, base: "/",
    url: url_PostOrgsOrgRepos_38986314, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgRepos_38986301 = ref object of OpenApiRestCall_38985352
proc url_GetOrgsOrgRepos_38986303(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgRepos_38986302(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List repositories for the specified org.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_38986304 = path.getOrDefault("org")
  valid_38986304 = validateParameter(valid_38986304, JString, required = true,
                                   default = nil)
  if valid_38986304 != nil:
    section.add "org", valid_38986304
  result.add "path", section
  ## parameters in `query` object:
  ##   type: JString
  section = newJObject()
  var valid_38986305 = query.getOrDefault("type")
  valid_38986305 = validateParameter(valid_38986305, JString, required = false,
                                   default = newJString("all"))
  if valid_38986305 != nil:
    section.add "type", valid_38986305
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986306 = header.getOrDefault("Accept")
  valid_38986306 = validateParameter(valid_38986306, JString, required = false,
                                   default = nil)
  if valid_38986306 != nil:
    section.add "Accept", valid_38986306
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986307: Call_GetOrgsOrgRepos_38986301; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List repositories for the specified org.
  ## 
  let valid = call_38986307.validator(path, query, header, formData, body, _)
  let scheme = call_38986307.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986307.url(scheme.get, call_38986307.host, call_38986307.base,
                           call_38986307.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986307, url, valid, _)

proc call*(call_38986308: Call_GetOrgsOrgRepos_38986301; org: string;
          Accept: string = ""; `type`: string = "all"): Recallable =
  ## getOrgsOrgRepos
  ## List repositories for the specified org.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   type: string
  ##   org: string (required)
  ##      : Name of organisation.
  var path_38986309 = newJObject()
  var query_38986310 = newJObject()
  var header_38986311 = newJObject()
  add(header_38986311, "Accept", newJString(Accept))
  add(query_38986310, "type", newJString(`type`))
  add(path_38986309, "org", newJString(org))
  result = call_38986308.call(path_38986309, query_38986310, header_38986311, nil, nil)

var getOrgsOrgRepos* = Call_GetOrgsOrgRepos_38986301(name: "getOrgsOrgRepos",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/repos",
    validator: validate_GetOrgsOrgRepos_38986302, base: "/",
    url: url_GetOrgsOrgRepos_38986303, schemes: {Scheme.Https})
type
  Call_PostOrgsOrgTeams_38986332 = ref object of OpenApiRestCall_38985352
proc url_PostOrgsOrgTeams_38986334(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/teams")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostOrgsOrgTeams_38986333(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create team.
  ## In order to create a team, the authenticated user must be an owner of organization.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_38986335 = path.getOrDefault("org")
  valid_38986335 = validateParameter(valid_38986335, JString, required = true,
                                   default = nil)
  if valid_38986335 != nil:
    section.add "org", valid_38986335
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986336 = header.getOrDefault("Accept")
  valid_38986336 = validateParameter(valid_38986336, JString, required = false,
                                   default = nil)
  if valid_38986336 != nil:
    section.add "Accept", valid_38986336
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38986338: Call_PostOrgsOrgTeams_38986332; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Create team.
  ## In order to create a team, the authenticated user must be an owner of organization.
  ## 
  ## 
  let valid = call_38986338.validator(path, query, header, formData, body, _)
  let scheme = call_38986338.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986338.url(scheme.get, call_38986338.host, call_38986338.base,
                           call_38986338.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986338, url, valid, _)

proc call*(call_38986339: Call_PostOrgsOrgTeams_38986332; body: JsonNode;
          org: string; Accept: string = ""): Recallable =
  ## postOrgsOrgTeams
  ## Create team.
  ## In order to create a team, the authenticated user must be an owner of organization.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   org: string (required)
  ##      : Name of organisation.
  var path_38986340 = newJObject()
  var header_38986341 = newJObject()
  var body_38986342 = newJObject()
  add(header_38986341, "Accept", newJString(Accept))
  if body != nil:
    body_38986342 = body
  add(path_38986340, "org", newJString(org))
  result = call_38986339.call(path_38986340, nil, header_38986341, nil, body_38986342)

var postOrgsOrgTeams* = Call_PostOrgsOrgTeams_38986332(name: "postOrgsOrgTeams",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/orgs/{org}/teams",
    validator: validate_PostOrgsOrgTeams_38986333, base: "/",
    url: url_PostOrgsOrgTeams_38986334, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgTeams_38986323 = ref object of OpenApiRestCall_38985352
proc url_GetOrgsOrgTeams_38986325(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/teams")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgTeams_38986324(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List teams.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_38986326 = path.getOrDefault("org")
  valid_38986326 = validateParameter(valid_38986326, JString, required = true,
                                   default = nil)
  if valid_38986326 != nil:
    section.add "org", valid_38986326
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986327 = header.getOrDefault("Accept")
  valid_38986327 = validateParameter(valid_38986327, JString, required = false,
                                   default = nil)
  if valid_38986327 != nil:
    section.add "Accept", valid_38986327
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986328: Call_GetOrgsOrgTeams_38986323; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List teams.
  ## 
  let valid = call_38986328.validator(path, query, header, formData, body, _)
  let scheme = call_38986328.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986328.url(scheme.get, call_38986328.host, call_38986328.base,
                           call_38986328.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986328, url, valid, _)

proc call*(call_38986329: Call_GetOrgsOrgTeams_38986323; org: string;
          Accept: string = ""): Recallable =
  ## getOrgsOrgTeams
  ## List teams.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_38986330 = newJObject()
  var header_38986331 = newJObject()
  add(header_38986331, "Accept", newJString(Accept))
  add(path_38986330, "org", newJString(org))
  result = call_38986329.call(path_38986330, nil, header_38986331, nil, nil)

var getOrgsOrgTeams* = Call_GetOrgsOrgTeams_38986323(name: "getOrgsOrgTeams",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/teams",
    validator: validate_GetOrgsOrgTeams_38986324, base: "/",
    url: url_GetOrgsOrgTeams_38986325, schemes: {Scheme.Https})
type
  Call_GetRateLimit_38986343 = ref object of OpenApiRestCall_38985352
proc url_GetRateLimit_38986345(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRateLimit_38986344(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## Get your current rate limit status
  ## Note: Accessing this endpoint does not count against your rate limit.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986346 = header.getOrDefault("Accept")
  valid_38986346 = validateParameter(valid_38986346, JString, required = false,
                                   default = nil)
  if valid_38986346 != nil:
    section.add "Accept", valid_38986346
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986347: Call_GetRateLimit_38986343; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get your current rate limit status
  ## Note: Accessing this endpoint does not count against your rate limit.
  ## 
  ## 
  let valid = call_38986347.validator(path, query, header, formData, body, _)
  let scheme = call_38986347.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986347.url(scheme.get, call_38986347.host, call_38986347.base,
                           call_38986347.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986347, url, valid, _)

proc call*(call_38986348: Call_GetRateLimit_38986343; Accept: string = ""): Recallable =
  ## getRateLimit
  ## Get your current rate limit status
  ## Note: Accessing this endpoint does not count against your rate limit.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_38986349 = newJObject()
  add(header_38986349, "Accept", newJString(Accept))
  result = call_38986348.call(nil, nil, header_38986349, nil, nil)

var getRateLimit* = Call_GetRateLimit_38986343(name: "getRateLimit",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/rate_limit",
    validator: validate_GetRateLimit_38986344, base: "/", url: url_GetRateLimit_38986345,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepo_38986350 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepo_38986352(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepo_38986351(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986353 = path.getOrDefault("owner")
  valid_38986353 = validateParameter(valid_38986353, JString, required = true,
                                   default = nil)
  if valid_38986353 != nil:
    section.add "owner", valid_38986353
  var valid_38986354 = path.getOrDefault("repo")
  valid_38986354 = validateParameter(valid_38986354, JString, required = true,
                                   default = nil)
  if valid_38986354 != nil:
    section.add "repo", valid_38986354
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986355 = header.getOrDefault("Accept")
  valid_38986355 = validateParameter(valid_38986355, JString, required = false,
                                   default = nil)
  if valid_38986355 != nil:
    section.add "Accept", valid_38986355
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986356: Call_GetReposOwnerRepo_38986350; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get repository.
  ## 
  let valid = call_38986356.validator(path, query, header, formData, body, _)
  let scheme = call_38986356.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986356.url(scheme.get, call_38986356.host, call_38986356.base,
                           call_38986356.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986356, url, valid, _)

proc call*(call_38986357: Call_GetReposOwnerRepo_38986350; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepo
  ## Get repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986358 = newJObject()
  var header_38986359 = newJObject()
  add(path_38986358, "owner", newJString(owner))
  add(header_38986359, "Accept", newJString(Accept))
  add(path_38986358, "repo", newJString(repo))
  result = call_38986357.call(path_38986358, nil, header_38986359, nil, nil)

var getReposOwnerRepo* = Call_GetReposOwnerRepo_38986350(name: "getReposOwnerRepo",
    meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/repos/{owner}/{repo}", validator: validate_GetReposOwnerRepo_38986351,
    base: "/", url: url_GetReposOwnerRepo_38986352, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepo_38986370 = ref object of OpenApiRestCall_38985352
proc url_PatchReposOwnerRepo_38986372(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepo_38986371(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Edit repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986373 = path.getOrDefault("owner")
  valid_38986373 = validateParameter(valid_38986373, JString, required = true,
                                   default = nil)
  if valid_38986373 != nil:
    section.add "owner", valid_38986373
  var valid_38986374 = path.getOrDefault("repo")
  valid_38986374 = validateParameter(valid_38986374, JString, required = true,
                                   default = nil)
  if valid_38986374 != nil:
    section.add "repo", valid_38986374
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986375 = header.getOrDefault("Accept")
  valid_38986375 = validateParameter(valid_38986375, JString, required = false,
                                   default = nil)
  if valid_38986375 != nil:
    section.add "Accept", valid_38986375
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38986377: Call_PatchReposOwnerRepo_38986370; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit repository.
  ## 
  let valid = call_38986377.validator(path, query, header, formData, body, _)
  let scheme = call_38986377.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986377.url(scheme.get, call_38986377.host, call_38986377.base,
                           call_38986377.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986377, url, valid, _)

proc call*(call_38986378: Call_PatchReposOwnerRepo_38986370; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepo
  ## Edit repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986379 = newJObject()
  var header_38986380 = newJObject()
  var body_38986381 = newJObject()
  add(path_38986379, "owner", newJString(owner))
  add(header_38986380, "Accept", newJString(Accept))
  if body != nil:
    body_38986381 = body
  add(path_38986379, "repo", newJString(repo))
  result = call_38986378.call(path_38986379, nil, header_38986380, nil, body_38986381)

var patchReposOwnerRepo* = Call_PatchReposOwnerRepo_38986370(
    name: "patchReposOwnerRepo", meth: HttpMethod.HttpPatch, host: "api.github.com",
    route: "/repos/{owner}/{repo}", validator: validate_PatchReposOwnerRepo_38986371,
    base: "/", url: url_PatchReposOwnerRepo_38986372, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepo_38986360 = ref object of OpenApiRestCall_38985352
proc url_DeleteReposOwnerRepo_38986362(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepo_38986361(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Delete a Repository.
  ## Deleting a repository requires admin access. If OAuth is used, the delete_repo
  ## scope is required.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986363 = path.getOrDefault("owner")
  valid_38986363 = validateParameter(valid_38986363, JString, required = true,
                                   default = nil)
  if valid_38986363 != nil:
    section.add "owner", valid_38986363
  var valid_38986364 = path.getOrDefault("repo")
  valid_38986364 = validateParameter(valid_38986364, JString, required = true,
                                   default = nil)
  if valid_38986364 != nil:
    section.add "repo", valid_38986364
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986365 = header.getOrDefault("Accept")
  valid_38986365 = validateParameter(valid_38986365, JString, required = false,
                                   default = nil)
  if valid_38986365 != nil:
    section.add "Accept", valid_38986365
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986366: Call_DeleteReposOwnerRepo_38986360; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a Repository.
  ## Deleting a repository requires admin access. If OAuth is used, the delete_repo
  ## scope is required.
  ## 
  ## 
  let valid = call_38986366.validator(path, query, header, formData, body, _)
  let scheme = call_38986366.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986366.url(scheme.get, call_38986366.host, call_38986366.base,
                           call_38986366.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986366, url, valid, _)

proc call*(call_38986367: Call_DeleteReposOwnerRepo_38986360; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepo
  ## Delete a Repository.
  ## Deleting a repository requires admin access. If OAuth is used, the delete_repo
  ## scope is required.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986368 = newJObject()
  var header_38986369 = newJObject()
  add(path_38986368, "owner", newJString(owner))
  add(header_38986369, "Accept", newJString(Accept))
  add(path_38986368, "repo", newJString(repo))
  result = call_38986367.call(path_38986368, nil, header_38986369, nil, nil)

var deleteReposOwnerRepo* = Call_DeleteReposOwnerRepo_38986360(
    name: "deleteReposOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}",
    validator: validate_DeleteReposOwnerRepo_38986361, base: "/",
    url: url_DeleteReposOwnerRepo_38986362, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoAssignees_38986382 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoAssignees_38986384(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/assignees")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoAssignees_38986383(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List assignees.
  ## This call lists all the available assignees (owner + collaborators) to which
  ## issues may be assigned.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986385 = path.getOrDefault("owner")
  valid_38986385 = validateParameter(valid_38986385, JString, required = true,
                                   default = nil)
  if valid_38986385 != nil:
    section.add "owner", valid_38986385
  var valid_38986386 = path.getOrDefault("repo")
  valid_38986386 = validateParameter(valid_38986386, JString, required = true,
                                   default = nil)
  if valid_38986386 != nil:
    section.add "repo", valid_38986386
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986387 = header.getOrDefault("Accept")
  valid_38986387 = validateParameter(valid_38986387, JString, required = false,
                                   default = nil)
  if valid_38986387 != nil:
    section.add "Accept", valid_38986387
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986388: Call_GetReposOwnerRepoAssignees_38986382;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List assignees.
  ## This call lists all the available assignees (owner + collaborators) to which
  ## issues may be assigned.
  ## 
  ## 
  let valid = call_38986388.validator(path, query, header, formData, body, _)
  let scheme = call_38986388.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986388.url(scheme.get, call_38986388.host, call_38986388.base,
                           call_38986388.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986388, url, valid, _)

proc call*(call_38986389: Call_GetReposOwnerRepoAssignees_38986382; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoAssignees
  ## List assignees.
  ## This call lists all the available assignees (owner + collaborators) to which
  ## issues may be assigned.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986390 = newJObject()
  var header_38986391 = newJObject()
  add(path_38986390, "owner", newJString(owner))
  add(header_38986391, "Accept", newJString(Accept))
  add(path_38986390, "repo", newJString(repo))
  result = call_38986389.call(path_38986390, nil, header_38986391, nil, nil)

var getReposOwnerRepoAssignees* = Call_GetReposOwnerRepoAssignees_38986382(
    name: "getReposOwnerRepoAssignees", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/assignees",
    validator: validate_GetReposOwnerRepoAssignees_38986383, base: "/",
    url: url_GetReposOwnerRepoAssignees_38986384, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoAssigneesAssignee_38986392 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoAssigneesAssignee_38986394(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "assignee" in path, "`assignee` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/assignees/"),
               (kind: VariableSegment, value: "assignee")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoAssigneesAssignee_38986393(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Check assignee.
  ## You may also check to see if a particular user is an assignee for a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   assignee: JString (required)
  ##           : Login of the assignee.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986395 = path.getOrDefault("owner")
  valid_38986395 = validateParameter(valid_38986395, JString, required = true,
                                   default = nil)
  if valid_38986395 != nil:
    section.add "owner", valid_38986395
  var valid_38986396 = path.getOrDefault("assignee")
  valid_38986396 = validateParameter(valid_38986396, JString, required = true,
                                   default = nil)
  if valid_38986396 != nil:
    section.add "assignee", valid_38986396
  var valid_38986397 = path.getOrDefault("repo")
  valid_38986397 = validateParameter(valid_38986397, JString, required = true,
                                   default = nil)
  if valid_38986397 != nil:
    section.add "repo", valid_38986397
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986398 = header.getOrDefault("Accept")
  valid_38986398 = validateParameter(valid_38986398, JString, required = false,
                                   default = nil)
  if valid_38986398 != nil:
    section.add "Accept", valid_38986398
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986399: Call_GetReposOwnerRepoAssigneesAssignee_38986392;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check assignee.
  ## You may also check to see if a particular user is an assignee for a repository.
  ## 
  ## 
  let valid = call_38986399.validator(path, query, header, formData, body, _)
  let scheme = call_38986399.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986399.url(scheme.get, call_38986399.host, call_38986399.base,
                           call_38986399.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986399, url, valid, _)

proc call*(call_38986400: Call_GetReposOwnerRepoAssigneesAssignee_38986392;
          owner: string; assignee: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoAssigneesAssignee
  ## Check assignee.
  ## You may also check to see if a particular user is an assignee for a repository.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   assignee: string (required)
  ##           : Login of the assignee.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986401 = newJObject()
  var header_38986402 = newJObject()
  add(path_38986401, "owner", newJString(owner))
  add(path_38986401, "assignee", newJString(assignee))
  add(header_38986402, "Accept", newJString(Accept))
  add(path_38986401, "repo", newJString(repo))
  result = call_38986400.call(path_38986401, nil, header_38986402, nil, nil)

var getReposOwnerRepoAssigneesAssignee* = Call_GetReposOwnerRepoAssigneesAssignee_38986392(
    name: "getReposOwnerRepoAssigneesAssignee", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/assignees/{assignee}",
    validator: validate_GetReposOwnerRepoAssigneesAssignee_38986393, base: "/",
    url: url_GetReposOwnerRepoAssigneesAssignee_38986394, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoBranches_38986403 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoBranches_38986405(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/branches")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoBranches_38986404(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get list of branches
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986406 = path.getOrDefault("owner")
  valid_38986406 = validateParameter(valid_38986406, JString, required = true,
                                   default = nil)
  if valid_38986406 != nil:
    section.add "owner", valid_38986406
  var valid_38986407 = path.getOrDefault("repo")
  valid_38986407 = validateParameter(valid_38986407, JString, required = true,
                                   default = nil)
  if valid_38986407 != nil:
    section.add "repo", valid_38986407
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986408 = header.getOrDefault("Accept")
  valid_38986408 = validateParameter(valid_38986408, JString, required = false,
                                   default = nil)
  if valid_38986408 != nil:
    section.add "Accept", valid_38986408
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986409: Call_GetReposOwnerRepoBranches_38986403;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get list of branches
  ## 
  let valid = call_38986409.validator(path, query, header, formData, body, _)
  let scheme = call_38986409.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986409.url(scheme.get, call_38986409.host, call_38986409.base,
                           call_38986409.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986409, url, valid, _)

proc call*(call_38986410: Call_GetReposOwnerRepoBranches_38986403; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoBranches
  ## Get list of branches
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986411 = newJObject()
  var header_38986412 = newJObject()
  add(path_38986411, "owner", newJString(owner))
  add(header_38986412, "Accept", newJString(Accept))
  add(path_38986411, "repo", newJString(repo))
  result = call_38986410.call(path_38986411, nil, header_38986412, nil, nil)

var getReposOwnerRepoBranches* = Call_GetReposOwnerRepoBranches_38986403(
    name: "getReposOwnerRepoBranches", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/branches",
    validator: validate_GetReposOwnerRepoBranches_38986404, base: "/",
    url: url_GetReposOwnerRepoBranches_38986405, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoBranchesBranch_38986413 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoBranchesBranch_38986415(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "branch" in path, "`branch` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/branches/"),
               (kind: VariableSegment, value: "branch")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoBranchesBranch_38986414(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get Branch
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   branch: JString (required)
  ##         : Name of the branch.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986416 = path.getOrDefault("owner")
  valid_38986416 = validateParameter(valid_38986416, JString, required = true,
                                   default = nil)
  if valid_38986416 != nil:
    section.add "owner", valid_38986416
  var valid_38986417 = path.getOrDefault("branch")
  valid_38986417 = validateParameter(valid_38986417, JString, required = true,
                                   default = nil)
  if valid_38986417 != nil:
    section.add "branch", valid_38986417
  var valid_38986418 = path.getOrDefault("repo")
  valid_38986418 = validateParameter(valid_38986418, JString, required = true,
                                   default = nil)
  if valid_38986418 != nil:
    section.add "repo", valid_38986418
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986419 = header.getOrDefault("Accept")
  valid_38986419 = validateParameter(valid_38986419, JString, required = false,
                                   default = nil)
  if valid_38986419 != nil:
    section.add "Accept", valid_38986419
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986420: Call_GetReposOwnerRepoBranchesBranch_38986413;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get Branch
  ## 
  let valid = call_38986420.validator(path, query, header, formData, body, _)
  let scheme = call_38986420.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986420.url(scheme.get, call_38986420.host, call_38986420.base,
                           call_38986420.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986420, url, valid, _)

proc call*(call_38986421: Call_GetReposOwnerRepoBranchesBranch_38986413;
          owner: string; branch: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoBranchesBranch
  ## Get Branch
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   branch: string (required)
  ##         : Name of the branch.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986422 = newJObject()
  var header_38986423 = newJObject()
  add(path_38986422, "owner", newJString(owner))
  add(path_38986422, "branch", newJString(branch))
  add(header_38986423, "Accept", newJString(Accept))
  add(path_38986422, "repo", newJString(repo))
  result = call_38986421.call(path_38986422, nil, header_38986423, nil, nil)

var getReposOwnerRepoBranchesBranch* = Call_GetReposOwnerRepoBranchesBranch_38986413(
    name: "getReposOwnerRepoBranchesBranch", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/branches/{branch}",
    validator: validate_GetReposOwnerRepoBranchesBranch_38986414, base: "/",
    url: url_GetReposOwnerRepoBranchesBranch_38986415, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCollaborators_38986424 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoCollaborators_38986426(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/collaborators")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCollaborators_38986425(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List.
  ## When authenticating as an organization owner of an organization-owned
  ## repository, all organization owners are included in the list of
  ## collaborators. Otherwise, only users with access to the repository are
  ## returned in the collaborators list.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986427 = path.getOrDefault("owner")
  valid_38986427 = validateParameter(valid_38986427, JString, required = true,
                                   default = nil)
  if valid_38986427 != nil:
    section.add "owner", valid_38986427
  var valid_38986428 = path.getOrDefault("repo")
  valid_38986428 = validateParameter(valid_38986428, JString, required = true,
                                   default = nil)
  if valid_38986428 != nil:
    section.add "repo", valid_38986428
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986429 = header.getOrDefault("Accept")
  valid_38986429 = validateParameter(valid_38986429, JString, required = false,
                                   default = nil)
  if valid_38986429 != nil:
    section.add "Accept", valid_38986429
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986430: Call_GetReposOwnerRepoCollaborators_38986424;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List.
  ## When authenticating as an organization owner of an organization-owned
  ## repository, all organization owners are included in the list of
  ## collaborators. Otherwise, only users with access to the repository are
  ## returned in the collaborators list.
  ## 
  ## 
  let valid = call_38986430.validator(path, query, header, formData, body, _)
  let scheme = call_38986430.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986430.url(scheme.get, call_38986430.host, call_38986430.base,
                           call_38986430.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986430, url, valid, _)

proc call*(call_38986431: Call_GetReposOwnerRepoCollaborators_38986424;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCollaborators
  ## List.
  ## When authenticating as an organization owner of an organization-owned
  ## repository, all organization owners are included in the list of
  ## collaborators. Otherwise, only users with access to the repository are
  ## returned in the collaborators list.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986432 = newJObject()
  var header_38986433 = newJObject()
  add(path_38986432, "owner", newJString(owner))
  add(header_38986433, "Accept", newJString(Accept))
  add(path_38986432, "repo", newJString(repo))
  result = call_38986431.call(path_38986432, nil, header_38986433, nil, nil)

var getReposOwnerRepoCollaborators* = Call_GetReposOwnerRepoCollaborators_38986424(
    name: "getReposOwnerRepoCollaborators", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators",
    validator: validate_GetReposOwnerRepoCollaborators_38986425, base: "/",
    url: url_GetReposOwnerRepoCollaborators_38986426, schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoCollaboratorsUser_38986445 = ref object of OpenApiRestCall_38985352
proc url_PutReposOwnerRepoCollaboratorsUser_38986447(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "user" in path, "`user` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/collaborators/"),
               (kind: VariableSegment, value: "user")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoCollaboratorsUser_38986446(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Add collaborator.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   user: JString (required)
  ##       : Login of the user.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986448 = path.getOrDefault("owner")
  valid_38986448 = validateParameter(valid_38986448, JString, required = true,
                                   default = nil)
  if valid_38986448 != nil:
    section.add "owner", valid_38986448
  var valid_38986449 = path.getOrDefault("user")
  valid_38986449 = validateParameter(valid_38986449, JString, required = true,
                                   default = nil)
  if valid_38986449 != nil:
    section.add "user", valid_38986449
  var valid_38986450 = path.getOrDefault("repo")
  valid_38986450 = validateParameter(valid_38986450, JString, required = true,
                                   default = nil)
  if valid_38986450 != nil:
    section.add "repo", valid_38986450
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986451 = header.getOrDefault("Accept")
  valid_38986451 = validateParameter(valid_38986451, JString, required = false,
                                   default = nil)
  if valid_38986451 != nil:
    section.add "Accept", valid_38986451
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986452: Call_PutReposOwnerRepoCollaboratorsUser_38986445;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Add collaborator.
  ## 
  let valid = call_38986452.validator(path, query, header, formData, body, _)
  let scheme = call_38986452.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986452.url(scheme.get, call_38986452.host, call_38986452.base,
                           call_38986452.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986452, url, valid, _)

proc call*(call_38986453: Call_PutReposOwnerRepoCollaboratorsUser_38986445;
          owner: string; user: string; repo: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoCollaboratorsUser
  ## Add collaborator.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   user: string (required)
  ##       : Login of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986454 = newJObject()
  var header_38986455 = newJObject()
  add(path_38986454, "owner", newJString(owner))
  add(path_38986454, "user", newJString(user))
  add(header_38986455, "Accept", newJString(Accept))
  add(path_38986454, "repo", newJString(repo))
  result = call_38986453.call(path_38986454, nil, header_38986455, nil, nil)

var putReposOwnerRepoCollaboratorsUser* = Call_PutReposOwnerRepoCollaboratorsUser_38986445(
    name: "putReposOwnerRepoCollaboratorsUser", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators/{user}",
    validator: validate_PutReposOwnerRepoCollaboratorsUser_38986446, base: "/",
    url: url_PutReposOwnerRepoCollaboratorsUser_38986447, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCollaboratorsUser_38986434 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoCollaboratorsUser_38986436(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "user" in path, "`user` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/collaborators/"),
               (kind: VariableSegment, value: "user")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCollaboratorsUser_38986435(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Check if user is a collaborator
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   user: JString (required)
  ##       : Login of the user.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986437 = path.getOrDefault("owner")
  valid_38986437 = validateParameter(valid_38986437, JString, required = true,
                                   default = nil)
  if valid_38986437 != nil:
    section.add "owner", valid_38986437
  var valid_38986438 = path.getOrDefault("user")
  valid_38986438 = validateParameter(valid_38986438, JString, required = true,
                                   default = nil)
  if valid_38986438 != nil:
    section.add "user", valid_38986438
  var valid_38986439 = path.getOrDefault("repo")
  valid_38986439 = validateParameter(valid_38986439, JString, required = true,
                                   default = nil)
  if valid_38986439 != nil:
    section.add "repo", valid_38986439
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986440 = header.getOrDefault("Accept")
  valid_38986440 = validateParameter(valid_38986440, JString, required = false,
                                   default = nil)
  if valid_38986440 != nil:
    section.add "Accept", valid_38986440
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986441: Call_GetReposOwnerRepoCollaboratorsUser_38986434;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if user is a collaborator
  ## 
  let valid = call_38986441.validator(path, query, header, formData, body, _)
  let scheme = call_38986441.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986441.url(scheme.get, call_38986441.host, call_38986441.base,
                           call_38986441.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986441, url, valid, _)

proc call*(call_38986442: Call_GetReposOwnerRepoCollaboratorsUser_38986434;
          owner: string; user: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCollaboratorsUser
  ## Check if user is a collaborator
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   user: string (required)
  ##       : Login of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986443 = newJObject()
  var header_38986444 = newJObject()
  add(path_38986443, "owner", newJString(owner))
  add(path_38986443, "user", newJString(user))
  add(header_38986444, "Accept", newJString(Accept))
  add(path_38986443, "repo", newJString(repo))
  result = call_38986442.call(path_38986443, nil, header_38986444, nil, nil)

var getReposOwnerRepoCollaboratorsUser* = Call_GetReposOwnerRepoCollaboratorsUser_38986434(
    name: "getReposOwnerRepoCollaboratorsUser", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators/{user}",
    validator: validate_GetReposOwnerRepoCollaboratorsUser_38986435, base: "/",
    url: url_GetReposOwnerRepoCollaboratorsUser_38986436, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoCollaboratorsUser_38986456 = ref object of OpenApiRestCall_38985352
proc url_DeleteReposOwnerRepoCollaboratorsUser_38986458(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "user" in path, "`user` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/collaborators/"),
               (kind: VariableSegment, value: "user")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoCollaboratorsUser_38986457(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Remove collaborator.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   user: JString (required)
  ##       : Login of the user.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986459 = path.getOrDefault("owner")
  valid_38986459 = validateParameter(valid_38986459, JString, required = true,
                                   default = nil)
  if valid_38986459 != nil:
    section.add "owner", valid_38986459
  var valid_38986460 = path.getOrDefault("user")
  valid_38986460 = validateParameter(valid_38986460, JString, required = true,
                                   default = nil)
  if valid_38986460 != nil:
    section.add "user", valid_38986460
  var valid_38986461 = path.getOrDefault("repo")
  valid_38986461 = validateParameter(valid_38986461, JString, required = true,
                                   default = nil)
  if valid_38986461 != nil:
    section.add "repo", valid_38986461
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986462 = header.getOrDefault("Accept")
  valid_38986462 = validateParameter(valid_38986462, JString, required = false,
                                   default = nil)
  if valid_38986462 != nil:
    section.add "Accept", valid_38986462
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986463: Call_DeleteReposOwnerRepoCollaboratorsUser_38986456;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Remove collaborator.
  ## 
  let valid = call_38986463.validator(path, query, header, formData, body, _)
  let scheme = call_38986463.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986463.url(scheme.get, call_38986463.host, call_38986463.base,
                           call_38986463.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986463, url, valid, _)

proc call*(call_38986464: Call_DeleteReposOwnerRepoCollaboratorsUser_38986456;
          owner: string; user: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoCollaboratorsUser
  ## Remove collaborator.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   user: string (required)
  ##       : Login of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986465 = newJObject()
  var header_38986466 = newJObject()
  add(path_38986465, "owner", newJString(owner))
  add(path_38986465, "user", newJString(user))
  add(header_38986466, "Accept", newJString(Accept))
  add(path_38986465, "repo", newJString(repo))
  result = call_38986464.call(path_38986465, nil, header_38986466, nil, nil)

var deleteReposOwnerRepoCollaboratorsUser* = Call_DeleteReposOwnerRepoCollaboratorsUser_38986456(
    name: "deleteReposOwnerRepoCollaboratorsUser", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators/{user}",
    validator: validate_DeleteReposOwnerRepoCollaboratorsUser_38986457, base: "/",
    url: url_DeleteReposOwnerRepoCollaboratorsUser_38986458,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoComments_38986467 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoComments_38986469(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoComments_38986468(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List commit comments for a repository.
  ## Comments are ordered by ascending ID.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986470 = path.getOrDefault("owner")
  valid_38986470 = validateParameter(valid_38986470, JString, required = true,
                                   default = nil)
  if valid_38986470 != nil:
    section.add "owner", valid_38986470
  var valid_38986471 = path.getOrDefault("repo")
  valid_38986471 = validateParameter(valid_38986471, JString, required = true,
                                   default = nil)
  if valid_38986471 != nil:
    section.add "repo", valid_38986471
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986472 = header.getOrDefault("Accept")
  valid_38986472 = validateParameter(valid_38986472, JString, required = false,
                                   default = nil)
  if valid_38986472 != nil:
    section.add "Accept", valid_38986472
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986473: Call_GetReposOwnerRepoComments_38986467;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List commit comments for a repository.
  ## Comments are ordered by ascending ID.
  ## 
  ## 
  let valid = call_38986473.validator(path, query, header, formData, body, _)
  let scheme = call_38986473.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986473.url(scheme.get, call_38986473.host, call_38986473.base,
                           call_38986473.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986473, url, valid, _)

proc call*(call_38986474: Call_GetReposOwnerRepoComments_38986467; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoComments
  ## List commit comments for a repository.
  ## Comments are ordered by ascending ID.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986475 = newJObject()
  var header_38986476 = newJObject()
  add(path_38986475, "owner", newJString(owner))
  add(header_38986476, "Accept", newJString(Accept))
  add(path_38986475, "repo", newJString(repo))
  result = call_38986474.call(path_38986475, nil, header_38986476, nil, nil)

var getReposOwnerRepoComments* = Call_GetReposOwnerRepoComments_38986467(
    name: "getReposOwnerRepoComments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments",
    validator: validate_GetReposOwnerRepoComments_38986468, base: "/",
    url: url_GetReposOwnerRepoComments_38986469, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommentsCommentId_38986477 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoCommentsCommentId_38986479(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommentsCommentId_38986478(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a single commit comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986480 = path.getOrDefault("owner")
  valid_38986480 = validateParameter(valid_38986480, JString, required = true,
                                   default = nil)
  if valid_38986480 != nil:
    section.add "owner", valid_38986480
  var valid_38986481 = path.getOrDefault("repo")
  valid_38986481 = validateParameter(valid_38986481, JString, required = true,
                                   default = nil)
  if valid_38986481 != nil:
    section.add "repo", valid_38986481
  var valid_38986482 = path.getOrDefault("commentId")
  valid_38986482 = validateParameter(valid_38986482, JInt, required = true,
                                   default = nil)
  if valid_38986482 != nil:
    section.add "commentId", valid_38986482
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986483 = header.getOrDefault("Accept")
  valid_38986483 = validateParameter(valid_38986483, JString, required = false,
                                   default = nil)
  if valid_38986483 != nil:
    section.add "Accept", valid_38986483
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986484: Call_GetReposOwnerRepoCommentsCommentId_38986477;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single commit comment.
  ## 
  let valid = call_38986484.validator(path, query, header, formData, body, _)
  let scheme = call_38986484.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986484.url(scheme.get, call_38986484.host, call_38986484.base,
                           call_38986484.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986484, url, valid, _)

proc call*(call_38986485: Call_GetReposOwnerRepoCommentsCommentId_38986477;
          owner: string; repo: string; commentId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommentsCommentId
  ## Get a single commit comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_38986486 = newJObject()
  var header_38986487 = newJObject()
  add(path_38986486, "owner", newJString(owner))
  add(header_38986487, "Accept", newJString(Accept))
  add(path_38986486, "repo", newJString(repo))
  add(path_38986486, "commentId", newJInt(commentId))
  result = call_38986485.call(path_38986486, nil, header_38986487, nil, nil)

var getReposOwnerRepoCommentsCommentId* = Call_GetReposOwnerRepoCommentsCommentId_38986477(
    name: "getReposOwnerRepoCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments/{commentId}",
    validator: validate_GetReposOwnerRepoCommentsCommentId_38986478, base: "/",
    url: url_GetReposOwnerRepoCommentsCommentId_38986479, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoCommentsCommentId_38986499 = ref object of OpenApiRestCall_38985352
proc url_PatchReposOwnerRepoCommentsCommentId_38986501(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoCommentsCommentId_38986500(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Update a commit comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986502 = path.getOrDefault("owner")
  valid_38986502 = validateParameter(valid_38986502, JString, required = true,
                                   default = nil)
  if valid_38986502 != nil:
    section.add "owner", valid_38986502
  var valid_38986503 = path.getOrDefault("repo")
  valid_38986503 = validateParameter(valid_38986503, JString, required = true,
                                   default = nil)
  if valid_38986503 != nil:
    section.add "repo", valid_38986503
  var valid_38986504 = path.getOrDefault("commentId")
  valid_38986504 = validateParameter(valid_38986504, JInt, required = true,
                                   default = nil)
  if valid_38986504 != nil:
    section.add "commentId", valid_38986504
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986505 = header.getOrDefault("Accept")
  valid_38986505 = validateParameter(valid_38986505, JString, required = false,
                                   default = nil)
  if valid_38986505 != nil:
    section.add "Accept", valid_38986505
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38986507: Call_PatchReposOwnerRepoCommentsCommentId_38986499;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Update a commit comment.
  ## 
  let valid = call_38986507.validator(path, query, header, formData, body, _)
  let scheme = call_38986507.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986507.url(scheme.get, call_38986507.host, call_38986507.base,
                           call_38986507.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986507, url, valid, _)

proc call*(call_38986508: Call_PatchReposOwnerRepoCommentsCommentId_38986499;
          owner: string; body: JsonNode; repo: string; commentId: int;
          Accept: string = ""): Recallable =
  ## patchReposOwnerRepoCommentsCommentId
  ## Update a commit comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_38986509 = newJObject()
  var header_38986510 = newJObject()
  var body_38986511 = newJObject()
  add(path_38986509, "owner", newJString(owner))
  add(header_38986510, "Accept", newJString(Accept))
  if body != nil:
    body_38986511 = body
  add(path_38986509, "repo", newJString(repo))
  add(path_38986509, "commentId", newJInt(commentId))
  result = call_38986508.call(path_38986509, nil, header_38986510, nil, body_38986511)

var patchReposOwnerRepoCommentsCommentId* = Call_PatchReposOwnerRepoCommentsCommentId_38986499(
    name: "patchReposOwnerRepoCommentsCommentId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments/{commentId}",
    validator: validate_PatchReposOwnerRepoCommentsCommentId_38986500, base: "/",
    url: url_PatchReposOwnerRepoCommentsCommentId_38986501,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoCommentsCommentId_38986488 = ref object of OpenApiRestCall_38985352
proc url_DeleteReposOwnerRepoCommentsCommentId_38986490(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoCommentsCommentId_38986489(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a commit comment
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986491 = path.getOrDefault("owner")
  valid_38986491 = validateParameter(valid_38986491, JString, required = true,
                                   default = nil)
  if valid_38986491 != nil:
    section.add "owner", valid_38986491
  var valid_38986492 = path.getOrDefault("repo")
  valid_38986492 = validateParameter(valid_38986492, JString, required = true,
                                   default = nil)
  if valid_38986492 != nil:
    section.add "repo", valid_38986492
  var valid_38986493 = path.getOrDefault("commentId")
  valid_38986493 = validateParameter(valid_38986493, JInt, required = true,
                                   default = nil)
  if valid_38986493 != nil:
    section.add "commentId", valid_38986493
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986494 = header.getOrDefault("Accept")
  valid_38986494 = validateParameter(valid_38986494, JString, required = false,
                                   default = nil)
  if valid_38986494 != nil:
    section.add "Accept", valid_38986494
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986495: Call_DeleteReposOwnerRepoCommentsCommentId_38986488;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a commit comment
  ## 
  let valid = call_38986495.validator(path, query, header, formData, body, _)
  let scheme = call_38986495.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986495.url(scheme.get, call_38986495.host, call_38986495.base,
                           call_38986495.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986495, url, valid, _)

proc call*(call_38986496: Call_DeleteReposOwnerRepoCommentsCommentId_38986488;
          owner: string; repo: string; commentId: int; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoCommentsCommentId
  ## Delete a commit comment
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_38986497 = newJObject()
  var header_38986498 = newJObject()
  add(path_38986497, "owner", newJString(owner))
  add(header_38986498, "Accept", newJString(Accept))
  add(path_38986497, "repo", newJString(repo))
  add(path_38986497, "commentId", newJInt(commentId))
  result = call_38986496.call(path_38986497, nil, header_38986498, nil, nil)

var deleteReposOwnerRepoCommentsCommentId* = Call_DeleteReposOwnerRepoCommentsCommentId_38986488(
    name: "deleteReposOwnerRepoCommentsCommentId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments/{commentId}",
    validator: validate_DeleteReposOwnerRepoCommentsCommentId_38986489, base: "/",
    url: url_DeleteReposOwnerRepoCommentsCommentId_38986490,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommits_38986512 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoCommits_38986514(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommits_38986513(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List commits on a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986515 = path.getOrDefault("owner")
  valid_38986515 = validateParameter(valid_38986515, JString, required = true,
                                   default = nil)
  if valid_38986515 != nil:
    section.add "owner", valid_38986515
  var valid_38986516 = path.getOrDefault("repo")
  valid_38986516 = validateParameter(valid_38986516, JString, required = true,
                                   default = nil)
  if valid_38986516 != nil:
    section.add "repo", valid_38986516
  result.add "path", section
  ## parameters in `query` object:
  ##   path: JString
  ##       : Only commits containing this file path will be returned.
  ##   sha: JString
  ##      : Sha or branch to start listing commits from.
  ##   author: JString
  ##         : GitHub login, name, or email by which to filter by commit author.
  ##   until: JString
  ##        : ISO 8601 Date - Only commits before this date will be returned.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_38986517 = query.getOrDefault("path")
  valid_38986517 = validateParameter(valid_38986517, JString, required = false,
                                   default = nil)
  if valid_38986517 != nil:
    section.add "path", valid_38986517
  var valid_38986518 = query.getOrDefault("sha")
  valid_38986518 = validateParameter(valid_38986518, JString, required = false,
                                   default = nil)
  if valid_38986518 != nil:
    section.add "sha", valid_38986518
  var valid_38986519 = query.getOrDefault("author")
  valid_38986519 = validateParameter(valid_38986519, JString, required = false,
                                   default = nil)
  if valid_38986519 != nil:
    section.add "author", valid_38986519
  var valid_38986520 = query.getOrDefault("until")
  valid_38986520 = validateParameter(valid_38986520, JString, required = false,
                                   default = nil)
  if valid_38986520 != nil:
    section.add "until", valid_38986520
  var valid_38986521 = query.getOrDefault("since")
  valid_38986521 = validateParameter(valid_38986521, JString, required = false,
                                   default = nil)
  if valid_38986521 != nil:
    section.add "since", valid_38986521
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986522 = header.getOrDefault("Accept")
  valid_38986522 = validateParameter(valid_38986522, JString, required = false,
                                   default = nil)
  if valid_38986522 != nil:
    section.add "Accept", valid_38986522
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986523: Call_GetReposOwnerRepoCommits_38986512;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List commits on a repository.
  ## 
  let valid = call_38986523.validator(path, query, header, formData, body, _)
  let scheme = call_38986523.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986523.url(scheme.get, call_38986523.host, call_38986523.base,
                           call_38986523.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986523, url, valid, _)

proc call*(call_38986524: Call_GetReposOwnerRepoCommits_38986512; owner: string;
          repo: string; path: string = ""; Accept: string = ""; sha: string = "";
          author: string = ""; until: string = ""; since: string = ""): Recallable =
  ## getReposOwnerRepoCommits
  ## List commits on a repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   path: string
  ##       : Only commits containing this file path will be returned.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   sha: string
  ##      : Sha or branch to start listing commits from.
  ##   author: string
  ##         : GitHub login, name, or email by which to filter by commit author.
  ##   until: string
  ##        : ISO 8601 Date - Only commits before this date will be returned.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var path_38986525 = newJObject()
  var query_38986526 = newJObject()
  var header_38986527 = newJObject()
  add(path_38986525, "owner", newJString(owner))
  add(query_38986526, "path", newJString(path))
  add(header_38986527, "Accept", newJString(Accept))
  add(path_38986525, "repo", newJString(repo))
  add(query_38986526, "sha", newJString(sha))
  add(query_38986526, "author", newJString(author))
  add(query_38986526, "until", newJString(until))
  add(query_38986526, "since", newJString(since))
  result = call_38986524.call(path_38986525, query_38986526, header_38986527, nil, nil)

var getReposOwnerRepoCommits* = Call_GetReposOwnerRepoCommits_38986512(
    name: "getReposOwnerRepoCommits", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/commits",
    validator: validate_GetReposOwnerRepoCommits_38986513, base: "/",
    url: url_GetReposOwnerRepoCommits_38986514, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommitsRefStatus_38986528 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoCommitsRefStatus_38986530(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits/"),
               (kind: VariableSegment, value: "ref"),
               (kind: ConstantSegment, value: "/status")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommitsRefStatus_38986529(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get the combined Status for a specific Ref
  ## The Combined status endpoint is currently available for developers to preview. During the preview period, the API may change without advance notice. Please see the blog post for full details.
  ## To access this endpoint during the preview period, you must provide a custom media type in the Accept header:
  ## application/vnd.github.she-hulk-preview+json
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   ref: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986531 = path.getOrDefault("owner")
  valid_38986531 = validateParameter(valid_38986531, JString, required = true,
                                   default = nil)
  if valid_38986531 != nil:
    section.add "owner", valid_38986531
  var valid_38986532 = path.getOrDefault("ref")
  valid_38986532 = validateParameter(valid_38986532, JString, required = true,
                                   default = nil)
  if valid_38986532 != nil:
    section.add "ref", valid_38986532
  var valid_38986533 = path.getOrDefault("repo")
  valid_38986533 = validateParameter(valid_38986533, JString, required = true,
                                   default = nil)
  if valid_38986533 != nil:
    section.add "repo", valid_38986533
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986534 = header.getOrDefault("Accept")
  valid_38986534 = validateParameter(valid_38986534, JString, required = false,
                                   default = nil)
  if valid_38986534 != nil:
    section.add "Accept", valid_38986534
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986535: Call_GetReposOwnerRepoCommitsRefStatus_38986528;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get the combined Status for a specific Ref
  ## The Combined status endpoint is currently available for developers to preview. During the preview period, the API may change without advance notice. Please see the blog post for full details.
  ## To access this endpoint during the preview period, you must provide a custom media type in the Accept header:
  ## application/vnd.github.she-hulk-preview+json
  ## 
  ## 
  let valid = call_38986535.validator(path, query, header, formData, body, _)
  let scheme = call_38986535.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986535.url(scheme.get, call_38986535.host, call_38986535.base,
                           call_38986535.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986535, url, valid, _)

proc call*(call_38986536: Call_GetReposOwnerRepoCommitsRefStatus_38986528;
          owner: string; `ref`: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommitsRefStatus
  ## Get the combined Status for a specific Ref
  ## The Combined status endpoint is currently available for developers to preview. During the preview period, the API may change without advance notice. Please see the blog post for full details.
  ## To access this endpoint during the preview period, you must provide a custom media type in the Accept header:
  ## application/vnd.github.she-hulk-preview+json
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   ref: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986537 = newJObject()
  var header_38986538 = newJObject()
  add(path_38986537, "owner", newJString(owner))
  add(path_38986537, "ref", newJString(`ref`))
  add(header_38986538, "Accept", newJString(Accept))
  add(path_38986537, "repo", newJString(repo))
  result = call_38986536.call(path_38986537, nil, header_38986538, nil, nil)

var getReposOwnerRepoCommitsRefStatus* = Call_GetReposOwnerRepoCommitsRefStatus_38986528(
    name: "getReposOwnerRepoCommitsRefStatus", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/commits/{ref}/status",
    validator: validate_GetReposOwnerRepoCommitsRefStatus_38986529, base: "/",
    url: url_GetReposOwnerRepoCommitsRefStatus_38986530, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommitsShaCode_38986539 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoCommitsShaCode_38986541(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommitsShaCode_38986540(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a single commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  ##          : SHA-1 code of the commit.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986542 = path.getOrDefault("owner")
  valid_38986542 = validateParameter(valid_38986542, JString, required = true,
                                   default = nil)
  if valid_38986542 != nil:
    section.add "owner", valid_38986542
  var valid_38986543 = path.getOrDefault("repo")
  valid_38986543 = validateParameter(valid_38986543, JString, required = true,
                                   default = nil)
  if valid_38986543 != nil:
    section.add "repo", valid_38986543
  var valid_38986544 = path.getOrDefault("shaCode")
  valid_38986544 = validateParameter(valid_38986544, JString, required = true,
                                   default = nil)
  if valid_38986544 != nil:
    section.add "shaCode", valid_38986544
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986545 = header.getOrDefault("Accept")
  valid_38986545 = validateParameter(valid_38986545, JString, required = false,
                                   default = nil)
  if valid_38986545 != nil:
    section.add "Accept", valid_38986545
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986546: Call_GetReposOwnerRepoCommitsShaCode_38986539;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single commit.
  ## 
  let valid = call_38986546.validator(path, query, header, formData, body, _)
  let scheme = call_38986546.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986546.url(scheme.get, call_38986546.host, call_38986546.base,
                           call_38986546.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986546, url, valid, _)

proc call*(call_38986547: Call_GetReposOwnerRepoCommitsShaCode_38986539;
          owner: string; repo: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommitsShaCode
  ## Get a single commit.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  ##          : SHA-1 code of the commit.
  var path_38986548 = newJObject()
  var header_38986549 = newJObject()
  add(path_38986548, "owner", newJString(owner))
  add(header_38986549, "Accept", newJString(Accept))
  add(path_38986548, "repo", newJString(repo))
  add(path_38986548, "shaCode", newJString(shaCode))
  result = call_38986547.call(path_38986548, nil, header_38986549, nil, nil)

var getReposOwnerRepoCommitsShaCode* = Call_GetReposOwnerRepoCommitsShaCode_38986539(
    name: "getReposOwnerRepoCommitsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/commits/{shaCode}",
    validator: validate_GetReposOwnerRepoCommitsShaCode_38986540, base: "/",
    url: url_GetReposOwnerRepoCommitsShaCode_38986541, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoCommitsShaCodeComments_38986561 = ref object of OpenApiRestCall_38985352
proc url_PostReposOwnerRepoCommitsShaCodeComments_38986563(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits/"),
               (kind: VariableSegment, value: "shaCode"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoCommitsShaCodeComments_38986562(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Create a commit comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  ##          : SHA-1 code of the commit.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986564 = path.getOrDefault("owner")
  valid_38986564 = validateParameter(valid_38986564, JString, required = true,
                                   default = nil)
  if valid_38986564 != nil:
    section.add "owner", valid_38986564
  var valid_38986565 = path.getOrDefault("repo")
  valid_38986565 = validateParameter(valid_38986565, JString, required = true,
                                   default = nil)
  if valid_38986565 != nil:
    section.add "repo", valid_38986565
  var valid_38986566 = path.getOrDefault("shaCode")
  valid_38986566 = validateParameter(valid_38986566, JString, required = true,
                                   default = nil)
  if valid_38986566 != nil:
    section.add "shaCode", valid_38986566
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986567 = header.getOrDefault("Accept")
  valid_38986567 = validateParameter(valid_38986567, JString, required = false,
                                   default = nil)
  if valid_38986567 != nil:
    section.add "Accept", valid_38986567
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38986569: Call_PostReposOwnerRepoCommitsShaCodeComments_38986561;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a commit comment.
  ## 
  let valid = call_38986569.validator(path, query, header, formData, body, _)
  let scheme = call_38986569.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986569.url(scheme.get, call_38986569.host, call_38986569.base,
                           call_38986569.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986569, url, valid, _)

proc call*(call_38986570: Call_PostReposOwnerRepoCommitsShaCodeComments_38986561;
          owner: string; body: JsonNode; repo: string; shaCode: string;
          Accept: string = ""): Recallable =
  ## postReposOwnerRepoCommitsShaCodeComments
  ## Create a commit comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  ##          : SHA-1 code of the commit.
  var path_38986571 = newJObject()
  var header_38986572 = newJObject()
  var body_38986573 = newJObject()
  add(path_38986571, "owner", newJString(owner))
  add(header_38986572, "Accept", newJString(Accept))
  if body != nil:
    body_38986573 = body
  add(path_38986571, "repo", newJString(repo))
  add(path_38986571, "shaCode", newJString(shaCode))
  result = call_38986570.call(path_38986571, nil, header_38986572, nil, body_38986573)

var postReposOwnerRepoCommitsShaCodeComments* = Call_PostReposOwnerRepoCommitsShaCodeComments_38986561(
    name: "postReposOwnerRepoCommitsShaCodeComments", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/commits/{shaCode}/comments",
    validator: validate_PostReposOwnerRepoCommitsShaCodeComments_38986562,
    base: "/", url: url_PostReposOwnerRepoCommitsShaCodeComments_38986563,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommitsShaCodeComments_38986550 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoCommitsShaCodeComments_38986552(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits/"),
               (kind: VariableSegment, value: "shaCode"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommitsShaCodeComments_38986551(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List comments for a single commitList comments for a single commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  ##          : SHA-1 code of the commit.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986553 = path.getOrDefault("owner")
  valid_38986553 = validateParameter(valid_38986553, JString, required = true,
                                   default = nil)
  if valid_38986553 != nil:
    section.add "owner", valid_38986553
  var valid_38986554 = path.getOrDefault("repo")
  valid_38986554 = validateParameter(valid_38986554, JString, required = true,
                                   default = nil)
  if valid_38986554 != nil:
    section.add "repo", valid_38986554
  var valid_38986555 = path.getOrDefault("shaCode")
  valid_38986555 = validateParameter(valid_38986555, JString, required = true,
                                   default = nil)
  if valid_38986555 != nil:
    section.add "shaCode", valid_38986555
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986556 = header.getOrDefault("Accept")
  valid_38986556 = validateParameter(valid_38986556, JString, required = false,
                                   default = nil)
  if valid_38986556 != nil:
    section.add "Accept", valid_38986556
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986557: Call_GetReposOwnerRepoCommitsShaCodeComments_38986550;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List comments for a single commitList comments for a single commit.
  ## 
  let valid = call_38986557.validator(path, query, header, formData, body, _)
  let scheme = call_38986557.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986557.url(scheme.get, call_38986557.host, call_38986557.base,
                           call_38986557.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986557, url, valid, _)

proc call*(call_38986558: Call_GetReposOwnerRepoCommitsShaCodeComments_38986550;
          owner: string; repo: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommitsShaCodeComments
  ## List comments for a single commitList comments for a single commit.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  ##          : SHA-1 code of the commit.
  var path_38986559 = newJObject()
  var header_38986560 = newJObject()
  add(path_38986559, "owner", newJString(owner))
  add(header_38986560, "Accept", newJString(Accept))
  add(path_38986559, "repo", newJString(repo))
  add(path_38986559, "shaCode", newJString(shaCode))
  result = call_38986558.call(path_38986559, nil, header_38986560, nil, nil)

var getReposOwnerRepoCommitsShaCodeComments* = Call_GetReposOwnerRepoCommitsShaCodeComments_38986550(
    name: "getReposOwnerRepoCommitsShaCodeComments", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/commits/{shaCode}/comments",
    validator: validate_GetReposOwnerRepoCommitsShaCodeComments_38986551,
    base: "/", url: url_GetReposOwnerRepoCommitsShaCodeComments_38986552,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCompareBaseIdHeadId_38986574 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoCompareBaseIdHeadId_38986576(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "baseId" in path, "`baseId` is a required path parameter"
  assert "headId" in path, "`headId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/compare/"),
               (kind: VariableSegment, value: "baseId"),
               (kind: ConstantSegment, value: "..."),
               (kind: VariableSegment, value: "headId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCompareBaseIdHeadId_38986575(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Compare two commits
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   baseId: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   headId: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986577 = path.getOrDefault("owner")
  valid_38986577 = validateParameter(valid_38986577, JString, required = true,
                                   default = nil)
  if valid_38986577 != nil:
    section.add "owner", valid_38986577
  var valid_38986578 = path.getOrDefault("baseId")
  valid_38986578 = validateParameter(valid_38986578, JString, required = true,
                                   default = nil)
  if valid_38986578 != nil:
    section.add "baseId", valid_38986578
  var valid_38986579 = path.getOrDefault("repo")
  valid_38986579 = validateParameter(valid_38986579, JString, required = true,
                                   default = nil)
  if valid_38986579 != nil:
    section.add "repo", valid_38986579
  var valid_38986580 = path.getOrDefault("headId")
  valid_38986580 = validateParameter(valid_38986580, JString, required = true,
                                   default = nil)
  if valid_38986580 != nil:
    section.add "headId", valid_38986580
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986581 = header.getOrDefault("Accept")
  valid_38986581 = validateParameter(valid_38986581, JString, required = false,
                                   default = nil)
  if valid_38986581 != nil:
    section.add "Accept", valid_38986581
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986582: Call_GetReposOwnerRepoCompareBaseIdHeadId_38986574;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Compare two commits
  ## 
  let valid = call_38986582.validator(path, query, header, formData, body, _)
  let scheme = call_38986582.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986582.url(scheme.get, call_38986582.host, call_38986582.base,
                           call_38986582.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986582, url, valid, _)

proc call*(call_38986583: Call_GetReposOwnerRepoCompareBaseIdHeadId_38986574;
          owner: string; baseId: string; repo: string; headId: string;
          Accept: string = ""): Recallable =
  ## getReposOwnerRepoCompareBaseIdHeadId
  ## Compare two commits
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   baseId: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   headId: string (required)
  var path_38986584 = newJObject()
  var header_38986585 = newJObject()
  add(path_38986584, "owner", newJString(owner))
  add(path_38986584, "baseId", newJString(baseId))
  add(header_38986585, "Accept", newJString(Accept))
  add(path_38986584, "repo", newJString(repo))
  add(path_38986584, "headId", newJString(headId))
  result = call_38986583.call(path_38986584, nil, header_38986585, nil, nil)

var getReposOwnerRepoCompareBaseIdHeadId* = Call_GetReposOwnerRepoCompareBaseIdHeadId_38986574(
    name: "getReposOwnerRepoCompareBaseIdHeadId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/compare/{baseId}...{headId}",
    validator: validate_GetReposOwnerRepoCompareBaseIdHeadId_38986575, base: "/",
    url: url_GetReposOwnerRepoCompareBaseIdHeadId_38986576,
    schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoContentsPath_38986600 = ref object of OpenApiRestCall_38985352
proc url_PutReposOwnerRepoContentsPath_38986602(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/contents/"),
               (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoContentsPath_38986601(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Create a file.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   path: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986603 = path.getOrDefault("owner")
  valid_38986603 = validateParameter(valid_38986603, JString, required = true,
                                   default = nil)
  if valid_38986603 != nil:
    section.add "owner", valid_38986603
  var valid_38986604 = path.getOrDefault("repo")
  valid_38986604 = validateParameter(valid_38986604, JString, required = true,
                                   default = nil)
  if valid_38986604 != nil:
    section.add "repo", valid_38986604
  var valid_38986605 = path.getOrDefault("path")
  valid_38986605 = validateParameter(valid_38986605, JString, required = true,
                                   default = nil)
  if valid_38986605 != nil:
    section.add "path", valid_38986605
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986606 = header.getOrDefault("Accept")
  valid_38986606 = validateParameter(valid_38986606, JString, required = false,
                                   default = nil)
  if valid_38986606 != nil:
    section.add "Accept", valid_38986606
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38986608: Call_PutReposOwnerRepoContentsPath_38986600;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a file.
  ## 
  let valid = call_38986608.validator(path, query, header, formData, body, _)
  let scheme = call_38986608.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986608.url(scheme.get, call_38986608.host, call_38986608.base,
                           call_38986608.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986608, url, valid, _)

proc call*(call_38986609: Call_PutReposOwnerRepoContentsPath_38986600;
          owner: string; body: JsonNode; repo: string; path: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoContentsPath
  ## Create a file.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   path: string (required)
  var path_38986610 = newJObject()
  var header_38986611 = newJObject()
  var body_38986612 = newJObject()
  add(path_38986610, "owner", newJString(owner))
  add(header_38986611, "Accept", newJString(Accept))
  if body != nil:
    body_38986612 = body
  add(path_38986610, "repo", newJString(repo))
  add(path_38986610, "path", newJString(path))
  result = call_38986609.call(path_38986610, nil, header_38986611, nil, body_38986612)

var putReposOwnerRepoContentsPath* = Call_PutReposOwnerRepoContentsPath_38986600(
    name: "putReposOwnerRepoContentsPath", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contents/{path}",
    validator: validate_PutReposOwnerRepoContentsPath_38986601, base: "/",
    url: url_PutReposOwnerRepoContentsPath_38986602, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoContentsPath_38986586 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoContentsPath_38986588(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/contents/"),
               (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoContentsPath_38986587(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get contents.
  ## This method returns the contents of a file or directory in a repository.
  ## Files and symlinks support a custom media type for getting the raw content.
  ## Directories and submodules do not support custom media types.
  ## Note: This API supports files up to 1 megabyte in size.
  ## Here can be many outcomes. For details see "http://developer.github.com/v3/repos/contents/"
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   path: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986589 = path.getOrDefault("owner")
  valid_38986589 = validateParameter(valid_38986589, JString, required = true,
                                   default = nil)
  if valid_38986589 != nil:
    section.add "owner", valid_38986589
  var valid_38986590 = path.getOrDefault("repo")
  valid_38986590 = validateParameter(valid_38986590, JString, required = true,
                                   default = nil)
  if valid_38986590 != nil:
    section.add "repo", valid_38986590
  var valid_38986591 = path.getOrDefault("path")
  valid_38986591 = validateParameter(valid_38986591, JString, required = true,
                                   default = nil)
  if valid_38986591 != nil:
    section.add "path", valid_38986591
  result.add "path", section
  ## parameters in `query` object:
  ##   path: JString
  ##       : The content path.
  ##   ref: JString
  ##      : The String name of the Commit/Branch/Tag. Defaults to 'master'.
  section = newJObject()
  var valid_38986592 = query.getOrDefault("path")
  valid_38986592 = validateParameter(valid_38986592, JString, required = false,
                                   default = nil)
  if valid_38986592 != nil:
    section.add "path", valid_38986592
  var valid_38986593 = query.getOrDefault("ref")
  valid_38986593 = validateParameter(valid_38986593, JString, required = false,
                                   default = nil)
  if valid_38986593 != nil:
    section.add "ref", valid_38986593
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986594 = header.getOrDefault("Accept")
  valid_38986594 = validateParameter(valid_38986594, JString, required = false,
                                   default = nil)
  if valid_38986594 != nil:
    section.add "Accept", valid_38986594
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986595: Call_GetReposOwnerRepoContentsPath_38986586;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get contents.
  ## This method returns the contents of a file or directory in a repository.
  ## Files and symlinks support a custom media type for getting the raw content.
  ## Directories and submodules do not support custom media types.
  ## Note: This API supports files up to 1 megabyte in size.
  ## Here can be many outcomes. For details see "http://developer.github.com/v3/repos/contents/"
  ## 
  ## 
  let valid = call_38986595.validator(path, query, header, formData, body, _)
  let scheme = call_38986595.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986595.url(scheme.get, call_38986595.host, call_38986595.base,
                           call_38986595.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986595, url, valid, _)

var getReposOwnerRepoContentsPath* = Call_GetReposOwnerRepoContentsPath_38986586(
    name: "getReposOwnerRepoContentsPath", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contents/{path}",
    validator: validate_GetReposOwnerRepoContentsPath_38986587, base: "/",
    url: url_GetReposOwnerRepoContentsPath_38986588, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoContentsPath_38986613 = ref object of OpenApiRestCall_38985352
proc url_DeleteReposOwnerRepoContentsPath_38986615(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/contents/"),
               (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoContentsPath_38986614(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a file.
  ## This method deletes a file in a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   path: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986616 = path.getOrDefault("owner")
  valid_38986616 = validateParameter(valid_38986616, JString, required = true,
                                   default = nil)
  if valid_38986616 != nil:
    section.add "owner", valid_38986616
  var valid_38986617 = path.getOrDefault("repo")
  valid_38986617 = validateParameter(valid_38986617, JString, required = true,
                                   default = nil)
  if valid_38986617 != nil:
    section.add "repo", valid_38986617
  var valid_38986618 = path.getOrDefault("path")
  valid_38986618 = validateParameter(valid_38986618, JString, required = true,
                                   default = nil)
  if valid_38986618 != nil:
    section.add "path", valid_38986618
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986619 = header.getOrDefault("Accept")
  valid_38986619 = validateParameter(valid_38986619, JString, required = false,
                                   default = nil)
  if valid_38986619 != nil:
    section.add "Accept", valid_38986619
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38986621: Call_DeleteReposOwnerRepoContentsPath_38986613;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a file.
  ## This method deletes a file in a repository.
  ## 
  ## 
  let valid = call_38986621.validator(path, query, header, formData, body, _)
  let scheme = call_38986621.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986621.url(scheme.get, call_38986621.host, call_38986621.base,
                           call_38986621.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986621, url, valid, _)

proc call*(call_38986622: Call_DeleteReposOwnerRepoContentsPath_38986613;
          owner: string; body: JsonNode; repo: string; path: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoContentsPath
  ## Delete a file.
  ## This method deletes a file in a repository.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   path: string (required)
  var path_38986623 = newJObject()
  var header_38986624 = newJObject()
  var body_38986625 = newJObject()
  add(path_38986623, "owner", newJString(owner))
  add(header_38986624, "Accept", newJString(Accept))
  if body != nil:
    body_38986625 = body
  add(path_38986623, "repo", newJString(repo))
  add(path_38986623, "path", newJString(path))
  result = call_38986622.call(path_38986623, nil, header_38986624, nil, body_38986625)

var deleteReposOwnerRepoContentsPath* = Call_DeleteReposOwnerRepoContentsPath_38986613(
    name: "deleteReposOwnerRepoContentsPath", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contents/{path}",
    validator: validate_DeleteReposOwnerRepoContentsPath_38986614, base: "/",
    url: url_DeleteReposOwnerRepoContentsPath_38986615, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoContributors_38986626 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoContributors_38986628(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/contributors")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoContributors_38986627(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get list of contributors.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986629 = path.getOrDefault("owner")
  valid_38986629 = validateParameter(valid_38986629, JString, required = true,
                                   default = nil)
  if valid_38986629 != nil:
    section.add "owner", valid_38986629
  var valid_38986630 = path.getOrDefault("repo")
  valid_38986630 = validateParameter(valid_38986630, JString, required = true,
                                   default = nil)
  if valid_38986630 != nil:
    section.add "repo", valid_38986630
  result.add "path", section
  ## parameters in `query` object:
  ##   anon: JString (required)
  ##       : Set to 1 or true to include anonymous contributors in results.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `anon` field"
  var valid_38986631 = query.getOrDefault("anon")
  valid_38986631 = validateParameter(valid_38986631, JString, required = true,
                                   default = nil)
  if valid_38986631 != nil:
    section.add "anon", valid_38986631
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986632 = header.getOrDefault("Accept")
  valid_38986632 = validateParameter(valid_38986632, JString, required = false,
                                   default = nil)
  if valid_38986632 != nil:
    section.add "Accept", valid_38986632
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986633: Call_GetReposOwnerRepoContributors_38986626;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get list of contributors.
  ## 
  let valid = call_38986633.validator(path, query, header, formData, body, _)
  let scheme = call_38986633.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986633.url(scheme.get, call_38986633.host, call_38986633.base,
                           call_38986633.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986633, url, valid, _)

proc call*(call_38986634: Call_GetReposOwnerRepoContributors_38986626;
          owner: string; repo: string; anon: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoContributors
  ## Get list of contributors.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   anon: string (required)
  ##       : Set to 1 or true to include anonymous contributors in results.
  var path_38986635 = newJObject()
  var query_38986636 = newJObject()
  var header_38986637 = newJObject()
  add(path_38986635, "owner", newJString(owner))
  add(header_38986637, "Accept", newJString(Accept))
  add(path_38986635, "repo", newJString(repo))
  add(query_38986636, "anon", newJString(anon))
  result = call_38986634.call(path_38986635, query_38986636, header_38986637, nil, nil)

var getReposOwnerRepoContributors* = Call_GetReposOwnerRepoContributors_38986626(
    name: "getReposOwnerRepoContributors", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contributors",
    validator: validate_GetReposOwnerRepoContributors_38986627, base: "/",
    url: url_GetReposOwnerRepoContributors_38986628, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoDeployments_38986648 = ref object of OpenApiRestCall_38985352
proc url_PostReposOwnerRepoDeployments_38986650(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/deployments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoDeployments_38986649(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Users with push access can create a deployment for a given ref
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986651 = path.getOrDefault("owner")
  valid_38986651 = validateParameter(valid_38986651, JString, required = true,
                                   default = nil)
  if valid_38986651 != nil:
    section.add "owner", valid_38986651
  var valid_38986652 = path.getOrDefault("repo")
  valid_38986652 = validateParameter(valid_38986652, JString, required = true,
                                   default = nil)
  if valid_38986652 != nil:
    section.add "repo", valid_38986652
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986653 = header.getOrDefault("Accept")
  valid_38986653 = validateParameter(valid_38986653, JString, required = false,
                                   default = nil)
  if valid_38986653 != nil:
    section.add "Accept", valid_38986653
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38986655: Call_PostReposOwnerRepoDeployments_38986648;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Users with push access can create a deployment for a given ref
  ## 
  let valid = call_38986655.validator(path, query, header, formData, body, _)
  let scheme = call_38986655.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986655.url(scheme.get, call_38986655.host, call_38986655.base,
                           call_38986655.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986655, url, valid, _)

proc call*(call_38986656: Call_PostReposOwnerRepoDeployments_38986648;
          owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoDeployments
  ## Users with push access can create a deployment for a given ref
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986657 = newJObject()
  var header_38986658 = newJObject()
  var body_38986659 = newJObject()
  add(path_38986657, "owner", newJString(owner))
  add(header_38986658, "Accept", newJString(Accept))
  if body != nil:
    body_38986659 = body
  add(path_38986657, "repo", newJString(repo))
  result = call_38986656.call(path_38986657, nil, header_38986658, nil, body_38986659)

var postReposOwnerRepoDeployments* = Call_PostReposOwnerRepoDeployments_38986648(
    name: "postReposOwnerRepoDeployments", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/deployments",
    validator: validate_PostReposOwnerRepoDeployments_38986649, base: "/",
    url: url_PostReposOwnerRepoDeployments_38986650, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDeployments_38986638 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoDeployments_38986640(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/deployments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDeployments_38986639(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Users with pull access can view deployments for a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986641 = path.getOrDefault("owner")
  valid_38986641 = validateParameter(valid_38986641, JString, required = true,
                                   default = nil)
  if valid_38986641 != nil:
    section.add "owner", valid_38986641
  var valid_38986642 = path.getOrDefault("repo")
  valid_38986642 = validateParameter(valid_38986642, JString, required = true,
                                   default = nil)
  if valid_38986642 != nil:
    section.add "repo", valid_38986642
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986643 = header.getOrDefault("Accept")
  valid_38986643 = validateParameter(valid_38986643, JString, required = false,
                                   default = nil)
  if valid_38986643 != nil:
    section.add "Accept", valid_38986643
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986644: Call_GetReposOwnerRepoDeployments_38986638;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Users with pull access can view deployments for a repository
  ## 
  let valid = call_38986644.validator(path, query, header, formData, body, _)
  let scheme = call_38986644.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986644.url(scheme.get, call_38986644.host, call_38986644.base,
                           call_38986644.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986644, url, valid, _)

proc call*(call_38986645: Call_GetReposOwnerRepoDeployments_38986638;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDeployments
  ## Users with pull access can view deployments for a repository
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986646 = newJObject()
  var header_38986647 = newJObject()
  add(path_38986646, "owner", newJString(owner))
  add(header_38986647, "Accept", newJString(Accept))
  add(path_38986646, "repo", newJString(repo))
  result = call_38986645.call(path_38986646, nil, header_38986647, nil, nil)

var getReposOwnerRepoDeployments* = Call_GetReposOwnerRepoDeployments_38986638(
    name: "getReposOwnerRepoDeployments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/deployments",
    validator: validate_GetReposOwnerRepoDeployments_38986639, base: "/",
    url: url_GetReposOwnerRepoDeployments_38986640, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoDeploymentsIdStatuses_38986671 = ref object of OpenApiRestCall_38985352
proc url_PostReposOwnerRepoDeploymentsIdStatuses_38986673(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/deployments/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/statuses")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoDeploymentsIdStatuses_38986672(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Create a Deployment Status
  ## Users with push access can create deployment statuses for a given deployment:
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JInt (required)
  ##     : The Deployment ID to list the statuses from.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986674 = path.getOrDefault("owner")
  valid_38986674 = validateParameter(valid_38986674, JString, required = true,
                                   default = nil)
  if valid_38986674 != nil:
    section.add "owner", valid_38986674
  var valid_38986675 = path.getOrDefault("id")
  valid_38986675 = validateParameter(valid_38986675, JInt, required = true,
                                   default = nil)
  if valid_38986675 != nil:
    section.add "id", valid_38986675
  var valid_38986676 = path.getOrDefault("repo")
  valid_38986676 = validateParameter(valid_38986676, JString, required = true,
                                   default = nil)
  if valid_38986676 != nil:
    section.add "repo", valid_38986676
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986677 = header.getOrDefault("Accept")
  valid_38986677 = validateParameter(valid_38986677, JString, required = false,
                                   default = nil)
  if valid_38986677 != nil:
    section.add "Accept", valid_38986677
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38986679: Call_PostReposOwnerRepoDeploymentsIdStatuses_38986671;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a Deployment Status
  ## Users with push access can create deployment statuses for a given deployment:
  ## 
  ## 
  let valid = call_38986679.validator(path, query, header, formData, body, _)
  let scheme = call_38986679.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986679.url(scheme.get, call_38986679.host, call_38986679.base,
                           call_38986679.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986679, url, valid, _)

proc call*(call_38986680: Call_PostReposOwnerRepoDeploymentsIdStatuses_38986671;
          owner: string; id: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoDeploymentsIdStatuses
  ## Create a Deployment Status
  ## Users with push access can create deployment statuses for a given deployment:
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: int (required)
  ##     : The Deployment ID to list the statuses from.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986681 = newJObject()
  var header_38986682 = newJObject()
  var body_38986683 = newJObject()
  add(path_38986681, "owner", newJString(owner))
  add(path_38986681, "id", newJInt(id))
  add(header_38986682, "Accept", newJString(Accept))
  if body != nil:
    body_38986683 = body
  add(path_38986681, "repo", newJString(repo))
  result = call_38986680.call(path_38986681, nil, header_38986682, nil, body_38986683)

var postReposOwnerRepoDeploymentsIdStatuses* = Call_PostReposOwnerRepoDeploymentsIdStatuses_38986671(
    name: "postReposOwnerRepoDeploymentsIdStatuses", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/deployments/{id}/statuses",
    validator: validate_PostReposOwnerRepoDeploymentsIdStatuses_38986672,
    base: "/", url: url_PostReposOwnerRepoDeploymentsIdStatuses_38986673,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDeploymentsIdStatuses_38986660 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoDeploymentsIdStatuses_38986662(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/deployments/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/statuses")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDeploymentsIdStatuses_38986661(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Users with pull access can view deployment statuses for a deployment
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JInt (required)
  ##     : The Deployment ID to list the statuses from.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986663 = path.getOrDefault("owner")
  valid_38986663 = validateParameter(valid_38986663, JString, required = true,
                                   default = nil)
  if valid_38986663 != nil:
    section.add "owner", valid_38986663
  var valid_38986664 = path.getOrDefault("id")
  valid_38986664 = validateParameter(valid_38986664, JInt, required = true,
                                   default = nil)
  if valid_38986664 != nil:
    section.add "id", valid_38986664
  var valid_38986665 = path.getOrDefault("repo")
  valid_38986665 = validateParameter(valid_38986665, JString, required = true,
                                   default = nil)
  if valid_38986665 != nil:
    section.add "repo", valid_38986665
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986666 = header.getOrDefault("Accept")
  valid_38986666 = validateParameter(valid_38986666, JString, required = false,
                                   default = nil)
  if valid_38986666 != nil:
    section.add "Accept", valid_38986666
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986667: Call_GetReposOwnerRepoDeploymentsIdStatuses_38986660;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Users with pull access can view deployment statuses for a deployment
  ## 
  let valid = call_38986667.validator(path, query, header, formData, body, _)
  let scheme = call_38986667.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986667.url(scheme.get, call_38986667.host, call_38986667.base,
                           call_38986667.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986667, url, valid, _)

proc call*(call_38986668: Call_GetReposOwnerRepoDeploymentsIdStatuses_38986660;
          owner: string; id: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDeploymentsIdStatuses
  ## Users with pull access can view deployment statuses for a deployment
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: int (required)
  ##     : The Deployment ID to list the statuses from.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986669 = newJObject()
  var header_38986670 = newJObject()
  add(path_38986669, "owner", newJString(owner))
  add(path_38986669, "id", newJInt(id))
  add(header_38986670, "Accept", newJString(Accept))
  add(path_38986669, "repo", newJString(repo))
  result = call_38986668.call(path_38986669, nil, header_38986670, nil, nil)

var getReposOwnerRepoDeploymentsIdStatuses* = Call_GetReposOwnerRepoDeploymentsIdStatuses_38986660(
    name: "getReposOwnerRepoDeploymentsIdStatuses", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/deployments/{id}/statuses",
    validator: validate_GetReposOwnerRepoDeploymentsIdStatuses_38986661,
    base: "/", url: url_GetReposOwnerRepoDeploymentsIdStatuses_38986662,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDownloads_38986684 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoDownloads_38986686(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/downloads")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDownloads_38986685(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Deprecated. List downloads for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986687 = path.getOrDefault("owner")
  valid_38986687 = validateParameter(valid_38986687, JString, required = true,
                                   default = nil)
  if valid_38986687 != nil:
    section.add "owner", valid_38986687
  var valid_38986688 = path.getOrDefault("repo")
  valid_38986688 = validateParameter(valid_38986688, JString, required = true,
                                   default = nil)
  if valid_38986688 != nil:
    section.add "repo", valid_38986688
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986689 = header.getOrDefault("Accept")
  valid_38986689 = validateParameter(valid_38986689, JString, required = false,
                                   default = nil)
  if valid_38986689 != nil:
    section.add "Accept", valid_38986689
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986690: Call_GetReposOwnerRepoDownloads_38986684;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Deprecated. List downloads for a repository.
  ## 
  let valid = call_38986690.validator(path, query, header, formData, body, _)
  let scheme = call_38986690.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986690.url(scheme.get, call_38986690.host, call_38986690.base,
                           call_38986690.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986690, url, valid, _)

proc call*(call_38986691: Call_GetReposOwnerRepoDownloads_38986684; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDownloads
  ## Deprecated. List downloads for a repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986692 = newJObject()
  var header_38986693 = newJObject()
  add(path_38986692, "owner", newJString(owner))
  add(header_38986693, "Accept", newJString(Accept))
  add(path_38986692, "repo", newJString(repo))
  result = call_38986691.call(path_38986692, nil, header_38986693, nil, nil)

var getReposOwnerRepoDownloads* = Call_GetReposOwnerRepoDownloads_38986684(
    name: "getReposOwnerRepoDownloads", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/downloads",
    validator: validate_GetReposOwnerRepoDownloads_38986685, base: "/",
    url: url_GetReposOwnerRepoDownloads_38986686, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDownloadsDownloadId_38986694 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoDownloadsDownloadId_38986696(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "downloadId" in path, "`downloadId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/downloads/"),
               (kind: VariableSegment, value: "downloadId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDownloadsDownloadId_38986695(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Deprecated. Get a single download.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   downloadId: JInt (required)
  ##             : Id of download.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986697 = path.getOrDefault("owner")
  valid_38986697 = validateParameter(valid_38986697, JString, required = true,
                                   default = nil)
  if valid_38986697 != nil:
    section.add "owner", valid_38986697
  var valid_38986698 = path.getOrDefault("repo")
  valid_38986698 = validateParameter(valid_38986698, JString, required = true,
                                   default = nil)
  if valid_38986698 != nil:
    section.add "repo", valid_38986698
  var valid_38986699 = path.getOrDefault("downloadId")
  valid_38986699 = validateParameter(valid_38986699, JInt, required = true,
                                   default = nil)
  if valid_38986699 != nil:
    section.add "downloadId", valid_38986699
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986700 = header.getOrDefault("Accept")
  valid_38986700 = validateParameter(valid_38986700, JString, required = false,
                                   default = nil)
  if valid_38986700 != nil:
    section.add "Accept", valid_38986700
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986701: Call_GetReposOwnerRepoDownloadsDownloadId_38986694;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Deprecated. Get a single download.
  ## 
  let valid = call_38986701.validator(path, query, header, formData, body, _)
  let scheme = call_38986701.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986701.url(scheme.get, call_38986701.host, call_38986701.base,
                           call_38986701.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986701, url, valid, _)

proc call*(call_38986702: Call_GetReposOwnerRepoDownloadsDownloadId_38986694;
          owner: string; repo: string; downloadId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDownloadsDownloadId
  ## Deprecated. Get a single download.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   downloadId: int (required)
  ##             : Id of download.
  var path_38986703 = newJObject()
  var header_38986704 = newJObject()
  add(path_38986703, "owner", newJString(owner))
  add(header_38986704, "Accept", newJString(Accept))
  add(path_38986703, "repo", newJString(repo))
  add(path_38986703, "downloadId", newJInt(downloadId))
  result = call_38986702.call(path_38986703, nil, header_38986704, nil, nil)

var getReposOwnerRepoDownloadsDownloadId* = Call_GetReposOwnerRepoDownloadsDownloadId_38986694(
    name: "getReposOwnerRepoDownloadsDownloadId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/downloads/{downloadId}",
    validator: validate_GetReposOwnerRepoDownloadsDownloadId_38986695, base: "/",
    url: url_GetReposOwnerRepoDownloadsDownloadId_38986696,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoDownloadsDownloadId_38986705 = ref object of OpenApiRestCall_38985352
proc url_DeleteReposOwnerRepoDownloadsDownloadId_38986707(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "downloadId" in path, "`downloadId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/downloads/"),
               (kind: VariableSegment, value: "downloadId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoDownloadsDownloadId_38986706(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Deprecated. Delete a download.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   downloadId: JInt (required)
  ##             : Id of download.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986708 = path.getOrDefault("owner")
  valid_38986708 = validateParameter(valid_38986708, JString, required = true,
                                   default = nil)
  if valid_38986708 != nil:
    section.add "owner", valid_38986708
  var valid_38986709 = path.getOrDefault("repo")
  valid_38986709 = validateParameter(valid_38986709, JString, required = true,
                                   default = nil)
  if valid_38986709 != nil:
    section.add "repo", valid_38986709
  var valid_38986710 = path.getOrDefault("downloadId")
  valid_38986710 = validateParameter(valid_38986710, JInt, required = true,
                                   default = nil)
  if valid_38986710 != nil:
    section.add "downloadId", valid_38986710
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986711 = header.getOrDefault("Accept")
  valid_38986711 = validateParameter(valid_38986711, JString, required = false,
                                   default = nil)
  if valid_38986711 != nil:
    section.add "Accept", valid_38986711
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986712: Call_DeleteReposOwnerRepoDownloadsDownloadId_38986705;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Deprecated. Delete a download.
  ## 
  let valid = call_38986712.validator(path, query, header, formData, body, _)
  let scheme = call_38986712.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986712.url(scheme.get, call_38986712.host, call_38986712.base,
                           call_38986712.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986712, url, valid, _)

proc call*(call_38986713: Call_DeleteReposOwnerRepoDownloadsDownloadId_38986705;
          owner: string; repo: string; downloadId: int; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoDownloadsDownloadId
  ## Deprecated. Delete a download.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   downloadId: int (required)
  ##             : Id of download.
  var path_38986714 = newJObject()
  var header_38986715 = newJObject()
  add(path_38986714, "owner", newJString(owner))
  add(header_38986715, "Accept", newJString(Accept))
  add(path_38986714, "repo", newJString(repo))
  add(path_38986714, "downloadId", newJInt(downloadId))
  result = call_38986713.call(path_38986714, nil, header_38986715, nil, nil)

var deleteReposOwnerRepoDownloadsDownloadId* = Call_DeleteReposOwnerRepoDownloadsDownloadId_38986705(
    name: "deleteReposOwnerRepoDownloadsDownloadId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/downloads/{downloadId}",
    validator: validate_DeleteReposOwnerRepoDownloadsDownloadId_38986706,
    base: "/", url: url_DeleteReposOwnerRepoDownloadsDownloadId_38986707,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoEvents_38986716 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoEvents_38986718(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoEvents_38986717(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get list of repository events.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986719 = path.getOrDefault("owner")
  valid_38986719 = validateParameter(valid_38986719, JString, required = true,
                                   default = nil)
  if valid_38986719 != nil:
    section.add "owner", valid_38986719
  var valid_38986720 = path.getOrDefault("repo")
  valid_38986720 = validateParameter(valid_38986720, JString, required = true,
                                   default = nil)
  if valid_38986720 != nil:
    section.add "repo", valid_38986720
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986721 = header.getOrDefault("Accept")
  valid_38986721 = validateParameter(valid_38986721, JString, required = false,
                                   default = nil)
  if valid_38986721 != nil:
    section.add "Accept", valid_38986721
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986722: Call_GetReposOwnerRepoEvents_38986716;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get list of repository events.
  ## 
  let valid = call_38986722.validator(path, query, header, formData, body, _)
  let scheme = call_38986722.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986722.url(scheme.get, call_38986722.host, call_38986722.base,
                           call_38986722.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986722, url, valid, _)

proc call*(call_38986723: Call_GetReposOwnerRepoEvents_38986716; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoEvents
  ## Get list of repository events.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986724 = newJObject()
  var header_38986725 = newJObject()
  add(path_38986724, "owner", newJString(owner))
  add(header_38986725, "Accept", newJString(Accept))
  add(path_38986724, "repo", newJString(repo))
  result = call_38986723.call(path_38986724, nil, header_38986725, nil, nil)

var getReposOwnerRepoEvents* = Call_GetReposOwnerRepoEvents_38986716(
    name: "getReposOwnerRepoEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/events",
    validator: validate_GetReposOwnerRepoEvents_38986717, base: "/",
    url: url_GetReposOwnerRepoEvents_38986718, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoForks_38986738 = ref object of OpenApiRestCall_38985352
proc url_PostReposOwnerRepoForks_38986740(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/forks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoForks_38986739(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a fork.
  ## Forking a Repository happens asynchronously. Therefore, you may have to wai
  ## a short period before accessing the git objects. If this takes longer than 5
  ## minutes, be sure to contact Support.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986741 = path.getOrDefault("owner")
  valid_38986741 = validateParameter(valid_38986741, JString, required = true,
                                   default = nil)
  if valid_38986741 != nil:
    section.add "owner", valid_38986741
  var valid_38986742 = path.getOrDefault("repo")
  valid_38986742 = validateParameter(valid_38986742, JString, required = true,
                                   default = nil)
  if valid_38986742 != nil:
    section.add "repo", valid_38986742
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986743 = header.getOrDefault("Accept")
  valid_38986743 = validateParameter(valid_38986743, JString, required = false,
                                   default = nil)
  if valid_38986743 != nil:
    section.add "Accept", valid_38986743
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38986745: Call_PostReposOwnerRepoForks_38986738;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a fork.
  ## Forking a Repository happens asynchronously. Therefore, you may have to wai
  ## a short period before accessing the git objects. If this takes longer than 5
  ## minutes, be sure to contact Support.
  ## 
  ## 
  let valid = call_38986745.validator(path, query, header, formData, body, _)
  let scheme = call_38986745.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986745.url(scheme.get, call_38986745.host, call_38986745.base,
                           call_38986745.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986745, url, valid, _)

proc call*(call_38986746: Call_PostReposOwnerRepoForks_38986738; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoForks
  ## Create a fork.
  ## Forking a Repository happens asynchronously. Therefore, you may have to wai
  ## a short period before accessing the git objects. If this takes longer than 5
  ## minutes, be sure to contact Support.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986747 = newJObject()
  var header_38986748 = newJObject()
  var body_38986749 = newJObject()
  add(path_38986747, "owner", newJString(owner))
  add(header_38986748, "Accept", newJString(Accept))
  if body != nil:
    body_38986749 = body
  add(path_38986747, "repo", newJString(repo))
  result = call_38986746.call(path_38986747, nil, header_38986748, nil, body_38986749)

var postReposOwnerRepoForks* = Call_PostReposOwnerRepoForks_38986738(
    name: "postReposOwnerRepoForks", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/forks",
    validator: validate_PostReposOwnerRepoForks_38986739, base: "/",
    url: url_PostReposOwnerRepoForks_38986740, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoForks_38986726 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoForks_38986728(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/forks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoForks_38986727(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List forks.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986729 = path.getOrDefault("owner")
  valid_38986729 = validateParameter(valid_38986729, JString, required = true,
                                   default = nil)
  if valid_38986729 != nil:
    section.add "owner", valid_38986729
  var valid_38986730 = path.getOrDefault("repo")
  valid_38986730 = validateParameter(valid_38986730, JString, required = true,
                                   default = nil)
  if valid_38986730 != nil:
    section.add "repo", valid_38986730
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  section = newJObject()
  var valid_38986731 = query.getOrDefault("sort")
  valid_38986731 = validateParameter(valid_38986731, JString, required = false,
                                   default = newJString("newes"))
  if valid_38986731 != nil:
    section.add "sort", valid_38986731
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986732 = header.getOrDefault("Accept")
  valid_38986732 = validateParameter(valid_38986732, JString, required = false,
                                   default = nil)
  if valid_38986732 != nil:
    section.add "Accept", valid_38986732
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986733: Call_GetReposOwnerRepoForks_38986726;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List forks.
  ## 
  let valid = call_38986733.validator(path, query, header, formData, body, _)
  let scheme = call_38986733.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986733.url(scheme.get, call_38986733.host, call_38986733.base,
                           call_38986733.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986733, url, valid, _)

proc call*(call_38986734: Call_GetReposOwnerRepoForks_38986726; owner: string;
          repo: string; Accept: string = ""; sort: string = "newes"): Recallable =
  ## getReposOwnerRepoForks
  ## List forks.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   sort: string
  var path_38986735 = newJObject()
  var query_38986736 = newJObject()
  var header_38986737 = newJObject()
  add(path_38986735, "owner", newJString(owner))
  add(header_38986737, "Accept", newJString(Accept))
  add(path_38986735, "repo", newJString(repo))
  add(query_38986736, "sort", newJString(sort))
  result = call_38986734.call(path_38986735, query_38986736, header_38986737, nil, nil)

var getReposOwnerRepoForks* = Call_GetReposOwnerRepoForks_38986726(
    name: "getReposOwnerRepoForks", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/forks",
    validator: validate_GetReposOwnerRepoForks_38986727, base: "/",
    url: url_GetReposOwnerRepoForks_38986728, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitBlobs_38986750 = ref object of OpenApiRestCall_38985352
proc url_PostReposOwnerRepoGitBlobs_38986752(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/blobs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitBlobs_38986751(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a Blob.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986753 = path.getOrDefault("owner")
  valid_38986753 = validateParameter(valid_38986753, JString, required = true,
                                   default = nil)
  if valid_38986753 != nil:
    section.add "owner", valid_38986753
  var valid_38986754 = path.getOrDefault("repo")
  valid_38986754 = validateParameter(valid_38986754, JString, required = true,
                                   default = nil)
  if valid_38986754 != nil:
    section.add "repo", valid_38986754
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986755 = header.getOrDefault("Accept")
  valid_38986755 = validateParameter(valid_38986755, JString, required = false,
                                   default = nil)
  if valid_38986755 != nil:
    section.add "Accept", valid_38986755
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38986757: Call_PostReposOwnerRepoGitBlobs_38986750;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a Blob.
  ## 
  let valid = call_38986757.validator(path, query, header, formData, body, _)
  let scheme = call_38986757.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986757.url(scheme.get, call_38986757.host, call_38986757.base,
                           call_38986757.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986757, url, valid, _)

proc call*(call_38986758: Call_PostReposOwnerRepoGitBlobs_38986750; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitBlobs
  ## Create a Blob.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986759 = newJObject()
  var header_38986760 = newJObject()
  var body_38986761 = newJObject()
  add(path_38986759, "owner", newJString(owner))
  add(header_38986760, "Accept", newJString(Accept))
  if body != nil:
    body_38986761 = body
  add(path_38986759, "repo", newJString(repo))
  result = call_38986758.call(path_38986759, nil, header_38986760, nil, body_38986761)

var postReposOwnerRepoGitBlobs* = Call_PostReposOwnerRepoGitBlobs_38986750(
    name: "postReposOwnerRepoGitBlobs", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/blobs",
    validator: validate_PostReposOwnerRepoGitBlobs_38986751, base: "/",
    url: url_PostReposOwnerRepoGitBlobs_38986752, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitBlobsShaCode_38986762 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoGitBlobsShaCode_38986764(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/blobs/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitBlobsShaCode_38986763(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a Blob.
  ## Since blobs can be any arbitrary binary data, the input and responses for
  ## the blob API takes an encoding parameter that can be either utf-8 or
  ## base64. If your data cannot be losslessly sent as a UTF-8 string, you can
  ## base64 encode it.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  ##          : SHA-1 code.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986765 = path.getOrDefault("owner")
  valid_38986765 = validateParameter(valid_38986765, JString, required = true,
                                   default = nil)
  if valid_38986765 != nil:
    section.add "owner", valid_38986765
  var valid_38986766 = path.getOrDefault("repo")
  valid_38986766 = validateParameter(valid_38986766, JString, required = true,
                                   default = nil)
  if valid_38986766 != nil:
    section.add "repo", valid_38986766
  var valid_38986767 = path.getOrDefault("shaCode")
  valid_38986767 = validateParameter(valid_38986767, JString, required = true,
                                   default = nil)
  if valid_38986767 != nil:
    section.add "shaCode", valid_38986767
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986768 = header.getOrDefault("Accept")
  valid_38986768 = validateParameter(valid_38986768, JString, required = false,
                                   default = nil)
  if valid_38986768 != nil:
    section.add "Accept", valid_38986768
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986769: Call_GetReposOwnerRepoGitBlobsShaCode_38986762;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a Blob.
  ## Since blobs can be any arbitrary binary data, the input and responses for
  ## the blob API takes an encoding parameter that can be either utf-8 or
  ## base64. If your data cannot be losslessly sent as a UTF-8 string, you can
  ## base64 encode it.
  ## 
  ## 
  let valid = call_38986769.validator(path, query, header, formData, body, _)
  let scheme = call_38986769.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986769.url(scheme.get, call_38986769.host, call_38986769.base,
                           call_38986769.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986769, url, valid, _)

proc call*(call_38986770: Call_GetReposOwnerRepoGitBlobsShaCode_38986762;
          owner: string; repo: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitBlobsShaCode
  ## Get a Blob.
  ## Since blobs can be any arbitrary binary data, the input and responses for
  ## the blob API takes an encoding parameter that can be either utf-8 or
  ## base64. If your data cannot be losslessly sent as a UTF-8 string, you can
  ## base64 encode it.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  ##          : SHA-1 code.
  var path_38986771 = newJObject()
  var header_38986772 = newJObject()
  add(path_38986771, "owner", newJString(owner))
  add(header_38986772, "Accept", newJString(Accept))
  add(path_38986771, "repo", newJString(repo))
  add(path_38986771, "shaCode", newJString(shaCode))
  result = call_38986770.call(path_38986771, nil, header_38986772, nil, nil)

var getReposOwnerRepoGitBlobsShaCode* = Call_GetReposOwnerRepoGitBlobsShaCode_38986762(
    name: "getReposOwnerRepoGitBlobsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/blobs/{shaCode}",
    validator: validate_GetReposOwnerRepoGitBlobsShaCode_38986763, base: "/",
    url: url_GetReposOwnerRepoGitBlobsShaCode_38986764, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitCommits_38986773 = ref object of OpenApiRestCall_38985352
proc url_PostReposOwnerRepoGitCommits_38986775(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/commits")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitCommits_38986774(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Create a Commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986776 = path.getOrDefault("owner")
  valid_38986776 = validateParameter(valid_38986776, JString, required = true,
                                   default = nil)
  if valid_38986776 != nil:
    section.add "owner", valid_38986776
  var valid_38986777 = path.getOrDefault("repo")
  valid_38986777 = validateParameter(valid_38986777, JString, required = true,
                                   default = nil)
  if valid_38986777 != nil:
    section.add "repo", valid_38986777
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986778 = header.getOrDefault("Accept")
  valid_38986778 = validateParameter(valid_38986778, JString, required = false,
                                   default = nil)
  if valid_38986778 != nil:
    section.add "Accept", valid_38986778
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38986780: Call_PostReposOwnerRepoGitCommits_38986773;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a Commit.
  ## 
  let valid = call_38986780.validator(path, query, header, formData, body, _)
  let scheme = call_38986780.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986780.url(scheme.get, call_38986780.host, call_38986780.base,
                           call_38986780.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986780, url, valid, _)

proc call*(call_38986781: Call_PostReposOwnerRepoGitCommits_38986773;
          owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitCommits
  ## Create a Commit.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986782 = newJObject()
  var header_38986783 = newJObject()
  var body_38986784 = newJObject()
  add(path_38986782, "owner", newJString(owner))
  add(header_38986783, "Accept", newJString(Accept))
  if body != nil:
    body_38986784 = body
  add(path_38986782, "repo", newJString(repo))
  result = call_38986781.call(path_38986782, nil, header_38986783, nil, body_38986784)

var postReposOwnerRepoGitCommits* = Call_PostReposOwnerRepoGitCommits_38986773(
    name: "postReposOwnerRepoGitCommits", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/commits",
    validator: validate_PostReposOwnerRepoGitCommits_38986774, base: "/",
    url: url_PostReposOwnerRepoGitCommits_38986775, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitCommitsShaCode_38986785 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoGitCommitsShaCode_38986787(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/commits/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitCommitsShaCode_38986786(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a Commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  ##          : SHA-1 code.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986788 = path.getOrDefault("owner")
  valid_38986788 = validateParameter(valid_38986788, JString, required = true,
                                   default = nil)
  if valid_38986788 != nil:
    section.add "owner", valid_38986788
  var valid_38986789 = path.getOrDefault("repo")
  valid_38986789 = validateParameter(valid_38986789, JString, required = true,
                                   default = nil)
  if valid_38986789 != nil:
    section.add "repo", valid_38986789
  var valid_38986790 = path.getOrDefault("shaCode")
  valid_38986790 = validateParameter(valid_38986790, JString, required = true,
                                   default = nil)
  if valid_38986790 != nil:
    section.add "shaCode", valid_38986790
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986791 = header.getOrDefault("Accept")
  valid_38986791 = validateParameter(valid_38986791, JString, required = false,
                                   default = nil)
  if valid_38986791 != nil:
    section.add "Accept", valid_38986791
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986792: Call_GetReposOwnerRepoGitCommitsShaCode_38986785;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a Commit.
  ## 
  let valid = call_38986792.validator(path, query, header, formData, body, _)
  let scheme = call_38986792.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986792.url(scheme.get, call_38986792.host, call_38986792.base,
                           call_38986792.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986792, url, valid, _)

proc call*(call_38986793: Call_GetReposOwnerRepoGitCommitsShaCode_38986785;
          owner: string; repo: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitCommitsShaCode
  ## Get a Commit.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  ##          : SHA-1 code.
  var path_38986794 = newJObject()
  var header_38986795 = newJObject()
  add(path_38986794, "owner", newJString(owner))
  add(header_38986795, "Accept", newJString(Accept))
  add(path_38986794, "repo", newJString(repo))
  add(path_38986794, "shaCode", newJString(shaCode))
  result = call_38986793.call(path_38986794, nil, header_38986795, nil, nil)

var getReposOwnerRepoGitCommitsShaCode* = Call_GetReposOwnerRepoGitCommitsShaCode_38986785(
    name: "getReposOwnerRepoGitCommitsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/commits/{shaCode}",
    validator: validate_GetReposOwnerRepoGitCommitsShaCode_38986786, base: "/",
    url: url_GetReposOwnerRepoGitCommitsShaCode_38986787, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitRefs_38986806 = ref object of OpenApiRestCall_38985352
proc url_PostReposOwnerRepoGitRefs_38986808(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitRefs_38986807(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a Reference
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986809 = path.getOrDefault("owner")
  valid_38986809 = validateParameter(valid_38986809, JString, required = true,
                                   default = nil)
  if valid_38986809 != nil:
    section.add "owner", valid_38986809
  var valid_38986810 = path.getOrDefault("repo")
  valid_38986810 = validateParameter(valid_38986810, JString, required = true,
                                   default = nil)
  if valid_38986810 != nil:
    section.add "repo", valid_38986810
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986811 = header.getOrDefault("Accept")
  valid_38986811 = validateParameter(valid_38986811, JString, required = false,
                                   default = nil)
  if valid_38986811 != nil:
    section.add "Accept", valid_38986811
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38986813: Call_PostReposOwnerRepoGitRefs_38986806;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a Reference
  ## 
  let valid = call_38986813.validator(path, query, header, formData, body, _)
  let scheme = call_38986813.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986813.url(scheme.get, call_38986813.host, call_38986813.base,
                           call_38986813.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986813, url, valid, _)

proc call*(call_38986814: Call_PostReposOwnerRepoGitRefs_38986806; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitRefs
  ## Create a Reference
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986815 = newJObject()
  var header_38986816 = newJObject()
  var body_38986817 = newJObject()
  add(path_38986815, "owner", newJString(owner))
  add(header_38986816, "Accept", newJString(Accept))
  if body != nil:
    body_38986817 = body
  add(path_38986815, "repo", newJString(repo))
  result = call_38986814.call(path_38986815, nil, header_38986816, nil, body_38986817)

var postReposOwnerRepoGitRefs* = Call_PostReposOwnerRepoGitRefs_38986806(
    name: "postReposOwnerRepoGitRefs", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs",
    validator: validate_PostReposOwnerRepoGitRefs_38986807, base: "/",
    url: url_PostReposOwnerRepoGitRefs_38986808, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitRefs_38986796 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoGitRefs_38986798(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitRefs_38986797(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get all References
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986799 = path.getOrDefault("owner")
  valid_38986799 = validateParameter(valid_38986799, JString, required = true,
                                   default = nil)
  if valid_38986799 != nil:
    section.add "owner", valid_38986799
  var valid_38986800 = path.getOrDefault("repo")
  valid_38986800 = validateParameter(valid_38986800, JString, required = true,
                                   default = nil)
  if valid_38986800 != nil:
    section.add "repo", valid_38986800
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986801 = header.getOrDefault("Accept")
  valid_38986801 = validateParameter(valid_38986801, JString, required = false,
                                   default = nil)
  if valid_38986801 != nil:
    section.add "Accept", valid_38986801
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986802: Call_GetReposOwnerRepoGitRefs_38986796;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get all References
  ## 
  let valid = call_38986802.validator(path, query, header, formData, body, _)
  let scheme = call_38986802.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986802.url(scheme.get, call_38986802.host, call_38986802.base,
                           call_38986802.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986802, url, valid, _)

proc call*(call_38986803: Call_GetReposOwnerRepoGitRefs_38986796; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitRefs
  ## Get all References
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986804 = newJObject()
  var header_38986805 = newJObject()
  add(path_38986804, "owner", newJString(owner))
  add(header_38986805, "Accept", newJString(Accept))
  add(path_38986804, "repo", newJString(repo))
  result = call_38986803.call(path_38986804, nil, header_38986805, nil, nil)

var getReposOwnerRepoGitRefs* = Call_GetReposOwnerRepoGitRefs_38986796(
    name: "getReposOwnerRepoGitRefs", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs",
    validator: validate_GetReposOwnerRepoGitRefs_38986797, base: "/",
    url: url_GetReposOwnerRepoGitRefs_38986798, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitRefsRef_38986818 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoGitRefsRef_38986820(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitRefsRef_38986819(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get a Reference
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   ref: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986821 = path.getOrDefault("owner")
  valid_38986821 = validateParameter(valid_38986821, JString, required = true,
                                   default = nil)
  if valid_38986821 != nil:
    section.add "owner", valid_38986821
  var valid_38986822 = path.getOrDefault("ref")
  valid_38986822 = validateParameter(valid_38986822, JString, required = true,
                                   default = nil)
  if valid_38986822 != nil:
    section.add "ref", valid_38986822
  var valid_38986823 = path.getOrDefault("repo")
  valid_38986823 = validateParameter(valid_38986823, JString, required = true,
                                   default = nil)
  if valid_38986823 != nil:
    section.add "repo", valid_38986823
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986824 = header.getOrDefault("Accept")
  valid_38986824 = validateParameter(valid_38986824, JString, required = false,
                                   default = nil)
  if valid_38986824 != nil:
    section.add "Accept", valid_38986824
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986825: Call_GetReposOwnerRepoGitRefsRef_38986818;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a Reference
  ## 
  let valid = call_38986825.validator(path, query, header, formData, body, _)
  let scheme = call_38986825.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986825.url(scheme.get, call_38986825.host, call_38986825.base,
                           call_38986825.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986825, url, valid, _)

proc call*(call_38986826: Call_GetReposOwnerRepoGitRefsRef_38986818; owner: string;
          `ref`: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitRefsRef
  ## Get a Reference
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   ref: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986827 = newJObject()
  var header_38986828 = newJObject()
  add(path_38986827, "owner", newJString(owner))
  add(path_38986827, "ref", newJString(`ref`))
  add(header_38986828, "Accept", newJString(Accept))
  add(path_38986827, "repo", newJString(repo))
  result = call_38986826.call(path_38986827, nil, header_38986828, nil, nil)

var getReposOwnerRepoGitRefsRef* = Call_GetReposOwnerRepoGitRefsRef_38986818(
    name: "getReposOwnerRepoGitRefsRef", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs/{ref}",
    validator: validate_GetReposOwnerRepoGitRefsRef_38986819, base: "/",
    url: url_GetReposOwnerRepoGitRefsRef_38986820, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoGitRefsRef_38986840 = ref object of OpenApiRestCall_38985352
proc url_PatchReposOwnerRepoGitRefsRef_38986842(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoGitRefsRef_38986841(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Update a Reference
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   ref: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986843 = path.getOrDefault("owner")
  valid_38986843 = validateParameter(valid_38986843, JString, required = true,
                                   default = nil)
  if valid_38986843 != nil:
    section.add "owner", valid_38986843
  var valid_38986844 = path.getOrDefault("ref")
  valid_38986844 = validateParameter(valid_38986844, JString, required = true,
                                   default = nil)
  if valid_38986844 != nil:
    section.add "ref", valid_38986844
  var valid_38986845 = path.getOrDefault("repo")
  valid_38986845 = validateParameter(valid_38986845, JString, required = true,
                                   default = nil)
  if valid_38986845 != nil:
    section.add "repo", valid_38986845
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986846 = header.getOrDefault("Accept")
  valid_38986846 = validateParameter(valid_38986846, JString, required = false,
                                   default = nil)
  if valid_38986846 != nil:
    section.add "Accept", valid_38986846
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38986848: Call_PatchReposOwnerRepoGitRefsRef_38986840;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Update a Reference
  ## 
  let valid = call_38986848.validator(path, query, header, formData, body, _)
  let scheme = call_38986848.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986848.url(scheme.get, call_38986848.host, call_38986848.base,
                           call_38986848.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986848, url, valid, _)

proc call*(call_38986849: Call_PatchReposOwnerRepoGitRefsRef_38986840;
          owner: string; `ref`: string; body: JsonNode; repo: string;
          Accept: string = ""): Recallable =
  ## patchReposOwnerRepoGitRefsRef
  ## Update a Reference
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   ref: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986850 = newJObject()
  var header_38986851 = newJObject()
  var body_38986852 = newJObject()
  add(path_38986850, "owner", newJString(owner))
  add(path_38986850, "ref", newJString(`ref`))
  add(header_38986851, "Accept", newJString(Accept))
  if body != nil:
    body_38986852 = body
  add(path_38986850, "repo", newJString(repo))
  result = call_38986849.call(path_38986850, nil, header_38986851, nil, body_38986852)

var patchReposOwnerRepoGitRefsRef* = Call_PatchReposOwnerRepoGitRefsRef_38986840(
    name: "patchReposOwnerRepoGitRefsRef", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs/{ref}",
    validator: validate_PatchReposOwnerRepoGitRefsRef_38986841, base: "/",
    url: url_PatchReposOwnerRepoGitRefsRef_38986842, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoGitRefsRef_38986829 = ref object of OpenApiRestCall_38985352
proc url_DeleteReposOwnerRepoGitRefsRef_38986831(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoGitRefsRef_38986830(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a Reference
  ## Example: Deleting a branch: DELETE /repos/octocat/Hello-World/git/refs/heads/feature-a
  ## Example: Deleting a tag:        DELETE /repos/octocat/Hello-World/git/refs/tags/v1.0
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   ref: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986832 = path.getOrDefault("owner")
  valid_38986832 = validateParameter(valid_38986832, JString, required = true,
                                   default = nil)
  if valid_38986832 != nil:
    section.add "owner", valid_38986832
  var valid_38986833 = path.getOrDefault("ref")
  valid_38986833 = validateParameter(valid_38986833, JString, required = true,
                                   default = nil)
  if valid_38986833 != nil:
    section.add "ref", valid_38986833
  var valid_38986834 = path.getOrDefault("repo")
  valid_38986834 = validateParameter(valid_38986834, JString, required = true,
                                   default = nil)
  if valid_38986834 != nil:
    section.add "repo", valid_38986834
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986835 = header.getOrDefault("Accept")
  valid_38986835 = validateParameter(valid_38986835, JString, required = false,
                                   default = nil)
  if valid_38986835 != nil:
    section.add "Accept", valid_38986835
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986836: Call_DeleteReposOwnerRepoGitRefsRef_38986829;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a Reference
  ## Example: Deleting a branch: DELETE /repos/octocat/Hello-World/git/refs/heads/feature-a
  ## Example: Deleting a tag:        DELETE /repos/octocat/Hello-World/git/refs/tags/v1.0
  ## 
  ## 
  let valid = call_38986836.validator(path, query, header, formData, body, _)
  let scheme = call_38986836.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986836.url(scheme.get, call_38986836.host, call_38986836.base,
                           call_38986836.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986836, url, valid, _)

proc call*(call_38986837: Call_DeleteReposOwnerRepoGitRefsRef_38986829;
          owner: string; `ref`: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoGitRefsRef
  ## Delete a Reference
  ## Example: Deleting a branch: DELETE /repos/octocat/Hello-World/git/refs/heads/feature-a
  ## Example: Deleting a tag:        DELETE /repos/octocat/Hello-World/git/refs/tags/v1.0
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   ref: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986838 = newJObject()
  var header_38986839 = newJObject()
  add(path_38986838, "owner", newJString(owner))
  add(path_38986838, "ref", newJString(`ref`))
  add(header_38986839, "Accept", newJString(Accept))
  add(path_38986838, "repo", newJString(repo))
  result = call_38986837.call(path_38986838, nil, header_38986839, nil, nil)

var deleteReposOwnerRepoGitRefsRef* = Call_DeleteReposOwnerRepoGitRefsRef_38986829(
    name: "deleteReposOwnerRepoGitRefsRef", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs/{ref}",
    validator: validate_DeleteReposOwnerRepoGitRefsRef_38986830, base: "/",
    url: url_DeleteReposOwnerRepoGitRefsRef_38986831, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitTags_38986853 = ref object of OpenApiRestCall_38985352
proc url_PostReposOwnerRepoGitTags_38986855(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/tags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitTags_38986854(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a Tag Object.
  ## Note that creating a tag object does not create the reference that makes a
  ## tag in Git. If you want to create an annotated tag in Git, you have to do
  ## this call to create the tag object, and then create the refs/tags/[tag]
  ## reference. If you want to create a lightweight tag, you only have to create
  ## the tag reference - this call would be unnecessary.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986856 = path.getOrDefault("owner")
  valid_38986856 = validateParameter(valid_38986856, JString, required = true,
                                   default = nil)
  if valid_38986856 != nil:
    section.add "owner", valid_38986856
  var valid_38986857 = path.getOrDefault("repo")
  valid_38986857 = validateParameter(valid_38986857, JString, required = true,
                                   default = nil)
  if valid_38986857 != nil:
    section.add "repo", valid_38986857
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986858 = header.getOrDefault("Accept")
  valid_38986858 = validateParameter(valid_38986858, JString, required = false,
                                   default = nil)
  if valid_38986858 != nil:
    section.add "Accept", valid_38986858
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38986860: Call_PostReposOwnerRepoGitTags_38986853;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a Tag Object.
  ## Note that creating a tag object does not create the reference that makes a
  ## tag in Git. If you want to create an annotated tag in Git, you have to do
  ## this call to create the tag object, and then create the refs/tags/[tag]
  ## reference. If you want to create a lightweight tag, you only have to create
  ## the tag reference - this call would be unnecessary.
  ## 
  ## 
  let valid = call_38986860.validator(path, query, header, formData, body, _)
  let scheme = call_38986860.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986860.url(scheme.get, call_38986860.host, call_38986860.base,
                           call_38986860.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986860, url, valid, _)

proc call*(call_38986861: Call_PostReposOwnerRepoGitTags_38986853; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitTags
  ## Create a Tag Object.
  ## Note that creating a tag object does not create the reference that makes a
  ## tag in Git. If you want to create an annotated tag in Git, you have to do
  ## this call to create the tag object, and then create the refs/tags/[tag]
  ## reference. If you want to create a lightweight tag, you only have to create
  ## the tag reference - this call would be unnecessary.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986862 = newJObject()
  var header_38986863 = newJObject()
  var body_38986864 = newJObject()
  add(path_38986862, "owner", newJString(owner))
  add(header_38986863, "Accept", newJString(Accept))
  if body != nil:
    body_38986864 = body
  add(path_38986862, "repo", newJString(repo))
  result = call_38986861.call(path_38986862, nil, header_38986863, nil, body_38986864)

var postReposOwnerRepoGitTags* = Call_PostReposOwnerRepoGitTags_38986853(
    name: "postReposOwnerRepoGitTags", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/tags",
    validator: validate_PostReposOwnerRepoGitTags_38986854, base: "/",
    url: url_PostReposOwnerRepoGitTags_38986855, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitTagsShaCode_38986865 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoGitTagsShaCode_38986867(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/tags/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitTagsShaCode_38986866(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a Tag.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986868 = path.getOrDefault("owner")
  valid_38986868 = validateParameter(valid_38986868, JString, required = true,
                                   default = nil)
  if valid_38986868 != nil:
    section.add "owner", valid_38986868
  var valid_38986869 = path.getOrDefault("repo")
  valid_38986869 = validateParameter(valid_38986869, JString, required = true,
                                   default = nil)
  if valid_38986869 != nil:
    section.add "repo", valid_38986869
  var valid_38986870 = path.getOrDefault("shaCode")
  valid_38986870 = validateParameter(valid_38986870, JString, required = true,
                                   default = nil)
  if valid_38986870 != nil:
    section.add "shaCode", valid_38986870
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986871 = header.getOrDefault("Accept")
  valid_38986871 = validateParameter(valid_38986871, JString, required = false,
                                   default = nil)
  if valid_38986871 != nil:
    section.add "Accept", valid_38986871
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986872: Call_GetReposOwnerRepoGitTagsShaCode_38986865;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a Tag.
  ## 
  let valid = call_38986872.validator(path, query, header, formData, body, _)
  let scheme = call_38986872.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986872.url(scheme.get, call_38986872.host, call_38986872.base,
                           call_38986872.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986872, url, valid, _)

proc call*(call_38986873: Call_GetReposOwnerRepoGitTagsShaCode_38986865;
          owner: string; repo: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitTagsShaCode
  ## Get a Tag.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  var path_38986874 = newJObject()
  var header_38986875 = newJObject()
  add(path_38986874, "owner", newJString(owner))
  add(header_38986875, "Accept", newJString(Accept))
  add(path_38986874, "repo", newJString(repo))
  add(path_38986874, "shaCode", newJString(shaCode))
  result = call_38986873.call(path_38986874, nil, header_38986875, nil, nil)

var getReposOwnerRepoGitTagsShaCode* = Call_GetReposOwnerRepoGitTagsShaCode_38986865(
    name: "getReposOwnerRepoGitTagsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/tags/{shaCode}",
    validator: validate_GetReposOwnerRepoGitTagsShaCode_38986866, base: "/",
    url: url_GetReposOwnerRepoGitTagsShaCode_38986867, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitTrees_38986876 = ref object of OpenApiRestCall_38985352
proc url_PostReposOwnerRepoGitTrees_38986878(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/trees")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitTrees_38986877(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a Tree.
  ## The tree creation API will take nested entries as well. If both a tree and
  ## a nested path modifying that tree are specified, it will overwrite the
  ## contents of that tree with the new path contents and write a new tree out.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986879 = path.getOrDefault("owner")
  valid_38986879 = validateParameter(valid_38986879, JString, required = true,
                                   default = nil)
  if valid_38986879 != nil:
    section.add "owner", valid_38986879
  var valid_38986880 = path.getOrDefault("repo")
  valid_38986880 = validateParameter(valid_38986880, JString, required = true,
                                   default = nil)
  if valid_38986880 != nil:
    section.add "repo", valid_38986880
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986881 = header.getOrDefault("Accept")
  valid_38986881 = validateParameter(valid_38986881, JString, required = false,
                                   default = nil)
  if valid_38986881 != nil:
    section.add "Accept", valid_38986881
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38986883: Call_PostReposOwnerRepoGitTrees_38986876;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a Tree.
  ## The tree creation API will take nested entries as well. If both a tree and
  ## a nested path modifying that tree are specified, it will overwrite the
  ## contents of that tree with the new path contents and write a new tree out.
  ## 
  ## 
  let valid = call_38986883.validator(path, query, header, formData, body, _)
  let scheme = call_38986883.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986883.url(scheme.get, call_38986883.host, call_38986883.base,
                           call_38986883.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986883, url, valid, _)

proc call*(call_38986884: Call_PostReposOwnerRepoGitTrees_38986876; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitTrees
  ## Create a Tree.
  ## The tree creation API will take nested entries as well. If both a tree and
  ## a nested path modifying that tree are specified, it will overwrite the
  ## contents of that tree with the new path contents and write a new tree out.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986885 = newJObject()
  var header_38986886 = newJObject()
  var body_38986887 = newJObject()
  add(path_38986885, "owner", newJString(owner))
  add(header_38986886, "Accept", newJString(Accept))
  if body != nil:
    body_38986887 = body
  add(path_38986885, "repo", newJString(repo))
  result = call_38986884.call(path_38986885, nil, header_38986886, nil, body_38986887)

var postReposOwnerRepoGitTrees* = Call_PostReposOwnerRepoGitTrees_38986876(
    name: "postReposOwnerRepoGitTrees", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/trees",
    validator: validate_PostReposOwnerRepoGitTrees_38986877, base: "/",
    url: url_PostReposOwnerRepoGitTrees_38986878, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitTreesShaCode_38986888 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoGitTreesShaCode_38986890(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/trees/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitTreesShaCode_38986889(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a Tree.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  ##          : Tree SHA.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986891 = path.getOrDefault("owner")
  valid_38986891 = validateParameter(valid_38986891, JString, required = true,
                                   default = nil)
  if valid_38986891 != nil:
    section.add "owner", valid_38986891
  var valid_38986892 = path.getOrDefault("repo")
  valid_38986892 = validateParameter(valid_38986892, JString, required = true,
                                   default = nil)
  if valid_38986892 != nil:
    section.add "repo", valid_38986892
  var valid_38986893 = path.getOrDefault("shaCode")
  valid_38986893 = validateParameter(valid_38986893, JString, required = true,
                                   default = nil)
  if valid_38986893 != nil:
    section.add "shaCode", valid_38986893
  result.add "path", section
  ## parameters in `query` object:
  ##   recursive: JInt
  ##            : Get a Tree Recursively. (0 or 1)
  section = newJObject()
  var valid_38986894 = query.getOrDefault("recursive")
  valid_38986894 = validateParameter(valid_38986894, JInt, required = false,
                                   default = nil)
  if valid_38986894 != nil:
    section.add "recursive", valid_38986894
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986895 = header.getOrDefault("Accept")
  valid_38986895 = validateParameter(valid_38986895, JString, required = false,
                                   default = nil)
  if valid_38986895 != nil:
    section.add "Accept", valid_38986895
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986896: Call_GetReposOwnerRepoGitTreesShaCode_38986888;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a Tree.
  ## 
  let valid = call_38986896.validator(path, query, header, formData, body, _)
  let scheme = call_38986896.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986896.url(scheme.get, call_38986896.host, call_38986896.base,
                           call_38986896.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986896, url, valid, _)

proc call*(call_38986897: Call_GetReposOwnerRepoGitTreesShaCode_38986888;
          owner: string; repo: string; shaCode: string; recursive: int = 0;
          Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitTreesShaCode
  ## Get a Tree.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   recursive: int
  ##            : Get a Tree Recursively. (0 or 1)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  ##          : Tree SHA.
  var path_38986898 = newJObject()
  var query_38986899 = newJObject()
  var header_38986900 = newJObject()
  add(path_38986898, "owner", newJString(owner))
  add(query_38986899, "recursive", newJInt(recursive))
  add(header_38986900, "Accept", newJString(Accept))
  add(path_38986898, "repo", newJString(repo))
  add(path_38986898, "shaCode", newJString(shaCode))
  result = call_38986897.call(path_38986898, query_38986899, header_38986900, nil, nil)

var getReposOwnerRepoGitTreesShaCode* = Call_GetReposOwnerRepoGitTreesShaCode_38986888(
    name: "getReposOwnerRepoGitTreesShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/trees/{shaCode}",
    validator: validate_GetReposOwnerRepoGitTreesShaCode_38986889, base: "/",
    url: url_GetReposOwnerRepoGitTreesShaCode_38986890, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoHooks_38986911 = ref object of OpenApiRestCall_38985352
proc url_PostReposOwnerRepoHooks_38986913(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoHooks_38986912(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986914 = path.getOrDefault("owner")
  valid_38986914 = validateParameter(valid_38986914, JString, required = true,
                                   default = nil)
  if valid_38986914 != nil:
    section.add "owner", valid_38986914
  var valid_38986915 = path.getOrDefault("repo")
  valid_38986915 = validateParameter(valid_38986915, JString, required = true,
                                   default = nil)
  if valid_38986915 != nil:
    section.add "repo", valid_38986915
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986916 = header.getOrDefault("Accept")
  valid_38986916 = validateParameter(valid_38986916, JString, required = false,
                                   default = nil)
  if valid_38986916 != nil:
    section.add "Accept", valid_38986916
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38986918: Call_PostReposOwnerRepoHooks_38986911;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a hook.
  ## 
  let valid = call_38986918.validator(path, query, header, formData, body, _)
  let scheme = call_38986918.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986918.url(scheme.get, call_38986918.host, call_38986918.base,
                           call_38986918.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986918, url, valid, _)

proc call*(call_38986919: Call_PostReposOwnerRepoHooks_38986911; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoHooks
  ## Create a hook.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986920 = newJObject()
  var header_38986921 = newJObject()
  var body_38986922 = newJObject()
  add(path_38986920, "owner", newJString(owner))
  add(header_38986921, "Accept", newJString(Accept))
  if body != nil:
    body_38986922 = body
  add(path_38986920, "repo", newJString(repo))
  result = call_38986919.call(path_38986920, nil, header_38986921, nil, body_38986922)

var postReposOwnerRepoHooks* = Call_PostReposOwnerRepoHooks_38986911(
    name: "postReposOwnerRepoHooks", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks",
    validator: validate_PostReposOwnerRepoHooks_38986912, base: "/",
    url: url_PostReposOwnerRepoHooks_38986913, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoHooks_38986901 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoHooks_38986903(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoHooks_38986902(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get list of hooks.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986904 = path.getOrDefault("owner")
  valid_38986904 = validateParameter(valid_38986904, JString, required = true,
                                   default = nil)
  if valid_38986904 != nil:
    section.add "owner", valid_38986904
  var valid_38986905 = path.getOrDefault("repo")
  valid_38986905 = validateParameter(valid_38986905, JString, required = true,
                                   default = nil)
  if valid_38986905 != nil:
    section.add "repo", valid_38986905
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986906 = header.getOrDefault("Accept")
  valid_38986906 = validateParameter(valid_38986906, JString, required = false,
                                   default = nil)
  if valid_38986906 != nil:
    section.add "Accept", valid_38986906
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986907: Call_GetReposOwnerRepoHooks_38986901;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get list of hooks.
  ## 
  let valid = call_38986907.validator(path, query, header, formData, body, _)
  let scheme = call_38986907.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986907.url(scheme.get, call_38986907.host, call_38986907.base,
                           call_38986907.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986907, url, valid, _)

proc call*(call_38986908: Call_GetReposOwnerRepoHooks_38986901; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoHooks
  ## Get list of hooks.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986909 = newJObject()
  var header_38986910 = newJObject()
  add(path_38986909, "owner", newJString(owner))
  add(header_38986910, "Accept", newJString(Accept))
  add(path_38986909, "repo", newJString(repo))
  result = call_38986908.call(path_38986909, nil, header_38986910, nil, nil)

var getReposOwnerRepoHooks* = Call_GetReposOwnerRepoHooks_38986901(
    name: "getReposOwnerRepoHooks", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks",
    validator: validate_GetReposOwnerRepoHooks_38986902, base: "/",
    url: url_GetReposOwnerRepoHooks_38986903, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoHooksHookId_38986923 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoHooksHookId_38986925(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hookId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoHooksHookId_38986924(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get single hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   hookId: JInt (required)
  ##         : Id of hook.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986926 = path.getOrDefault("owner")
  valid_38986926 = validateParameter(valid_38986926, JString, required = true,
                                   default = nil)
  if valid_38986926 != nil:
    section.add "owner", valid_38986926
  var valid_38986927 = path.getOrDefault("repo")
  valid_38986927 = validateParameter(valid_38986927, JString, required = true,
                                   default = nil)
  if valid_38986927 != nil:
    section.add "repo", valid_38986927
  var valid_38986928 = path.getOrDefault("hookId")
  valid_38986928 = validateParameter(valid_38986928, JInt, required = true,
                                   default = nil)
  if valid_38986928 != nil:
    section.add "hookId", valid_38986928
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986929 = header.getOrDefault("Accept")
  valid_38986929 = validateParameter(valid_38986929, JString, required = false,
                                   default = nil)
  if valid_38986929 != nil:
    section.add "Accept", valid_38986929
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986930: Call_GetReposOwnerRepoHooksHookId_38986923;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get single hook.
  ## 
  let valid = call_38986930.validator(path, query, header, formData, body, _)
  let scheme = call_38986930.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986930.url(scheme.get, call_38986930.host, call_38986930.base,
                           call_38986930.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986930, url, valid, _)

proc call*(call_38986931: Call_GetReposOwnerRepoHooksHookId_38986923;
          owner: string; repo: string; hookId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoHooksHookId
  ## Get single hook.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   hookId: int (required)
  ##         : Id of hook.
  var path_38986932 = newJObject()
  var header_38986933 = newJObject()
  add(path_38986932, "owner", newJString(owner))
  add(header_38986933, "Accept", newJString(Accept))
  add(path_38986932, "repo", newJString(repo))
  add(path_38986932, "hookId", newJInt(hookId))
  result = call_38986931.call(path_38986932, nil, header_38986933, nil, nil)

var getReposOwnerRepoHooksHookId* = Call_GetReposOwnerRepoHooksHookId_38986923(
    name: "getReposOwnerRepoHooksHookId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}",
    validator: validate_GetReposOwnerRepoHooksHookId_38986924, base: "/",
    url: url_GetReposOwnerRepoHooksHookId_38986925, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoHooksHookId_38986945 = ref object of OpenApiRestCall_38985352
proc url_PatchReposOwnerRepoHooksHookId_38986947(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hookId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoHooksHookId_38986946(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Edit a hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   hookId: JInt (required)
  ##         : Id of hook.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986948 = path.getOrDefault("owner")
  valid_38986948 = validateParameter(valid_38986948, JString, required = true,
                                   default = nil)
  if valid_38986948 != nil:
    section.add "owner", valid_38986948
  var valid_38986949 = path.getOrDefault("repo")
  valid_38986949 = validateParameter(valid_38986949, JString, required = true,
                                   default = nil)
  if valid_38986949 != nil:
    section.add "repo", valid_38986949
  var valid_38986950 = path.getOrDefault("hookId")
  valid_38986950 = validateParameter(valid_38986950, JInt, required = true,
                                   default = nil)
  if valid_38986950 != nil:
    section.add "hookId", valid_38986950
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986951 = header.getOrDefault("Accept")
  valid_38986951 = validateParameter(valid_38986951, JString, required = false,
                                   default = nil)
  if valid_38986951 != nil:
    section.add "Accept", valid_38986951
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38986953: Call_PatchReposOwnerRepoHooksHookId_38986945;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit a hook.
  ## 
  let valid = call_38986953.validator(path, query, header, formData, body, _)
  let scheme = call_38986953.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986953.url(scheme.get, call_38986953.host, call_38986953.base,
                           call_38986953.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986953, url, valid, _)

proc call*(call_38986954: Call_PatchReposOwnerRepoHooksHookId_38986945;
          owner: string; body: JsonNode; repo: string; hookId: int; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoHooksHookId
  ## Edit a hook.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   hookId: int (required)
  ##         : Id of hook.
  var path_38986955 = newJObject()
  var header_38986956 = newJObject()
  var body_38986957 = newJObject()
  add(path_38986955, "owner", newJString(owner))
  add(header_38986956, "Accept", newJString(Accept))
  if body != nil:
    body_38986957 = body
  add(path_38986955, "repo", newJString(repo))
  add(path_38986955, "hookId", newJInt(hookId))
  result = call_38986954.call(path_38986955, nil, header_38986956, nil, body_38986957)

var patchReposOwnerRepoHooksHookId* = Call_PatchReposOwnerRepoHooksHookId_38986945(
    name: "patchReposOwnerRepoHooksHookId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}",
    validator: validate_PatchReposOwnerRepoHooksHookId_38986946, base: "/",
    url: url_PatchReposOwnerRepoHooksHookId_38986947, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoHooksHookId_38986934 = ref object of OpenApiRestCall_38985352
proc url_DeleteReposOwnerRepoHooksHookId_38986936(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hookId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoHooksHookId_38986935(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   hookId: JInt (required)
  ##         : Id of hook.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986937 = path.getOrDefault("owner")
  valid_38986937 = validateParameter(valid_38986937, JString, required = true,
                                   default = nil)
  if valid_38986937 != nil:
    section.add "owner", valid_38986937
  var valid_38986938 = path.getOrDefault("repo")
  valid_38986938 = validateParameter(valid_38986938, JString, required = true,
                                   default = nil)
  if valid_38986938 != nil:
    section.add "repo", valid_38986938
  var valid_38986939 = path.getOrDefault("hookId")
  valid_38986939 = validateParameter(valid_38986939, JInt, required = true,
                                   default = nil)
  if valid_38986939 != nil:
    section.add "hookId", valid_38986939
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986940 = header.getOrDefault("Accept")
  valid_38986940 = validateParameter(valid_38986940, JString, required = false,
                                   default = nil)
  if valid_38986940 != nil:
    section.add "Accept", valid_38986940
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986941: Call_DeleteReposOwnerRepoHooksHookId_38986934;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a hook.
  ## 
  let valid = call_38986941.validator(path, query, header, formData, body, _)
  let scheme = call_38986941.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986941.url(scheme.get, call_38986941.host, call_38986941.base,
                           call_38986941.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986941, url, valid, _)

proc call*(call_38986942: Call_DeleteReposOwnerRepoHooksHookId_38986934;
          owner: string; repo: string; hookId: int; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoHooksHookId
  ## Delete a hook.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   hookId: int (required)
  ##         : Id of hook.
  var path_38986943 = newJObject()
  var header_38986944 = newJObject()
  add(path_38986943, "owner", newJString(owner))
  add(header_38986944, "Accept", newJString(Accept))
  add(path_38986943, "repo", newJString(repo))
  add(path_38986943, "hookId", newJInt(hookId))
  result = call_38986942.call(path_38986943, nil, header_38986944, nil, nil)

var deleteReposOwnerRepoHooksHookId* = Call_DeleteReposOwnerRepoHooksHookId_38986934(
    name: "deleteReposOwnerRepoHooksHookId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}",
    validator: validate_DeleteReposOwnerRepoHooksHookId_38986935, base: "/",
    url: url_DeleteReposOwnerRepoHooksHookId_38986936, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoHooksHookIdTests_38986958 = ref object of OpenApiRestCall_38985352
proc url_PostReposOwnerRepoHooksHookIdTests_38986960(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hookId"),
               (kind: ConstantSegment, value: "/tests")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoHooksHookIdTests_38986959(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Test a push hook.
  ## This will trigger the hook with the latest push to the current repository
  ## if the hook is subscribed to push events. If the hook is not subscribed
  ## to push events, the server will respond with 204 but no test POST will
  ## be generated.
  ## Note: Previously /repos/:owner/:repo/hooks/:id/tes
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   hookId: JInt (required)
  ##         : Id of hook.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986961 = path.getOrDefault("owner")
  valid_38986961 = validateParameter(valid_38986961, JString, required = true,
                                   default = nil)
  if valid_38986961 != nil:
    section.add "owner", valid_38986961
  var valid_38986962 = path.getOrDefault("repo")
  valid_38986962 = validateParameter(valid_38986962, JString, required = true,
                                   default = nil)
  if valid_38986962 != nil:
    section.add "repo", valid_38986962
  var valid_38986963 = path.getOrDefault("hookId")
  valid_38986963 = validateParameter(valid_38986963, JInt, required = true,
                                   default = nil)
  if valid_38986963 != nil:
    section.add "hookId", valid_38986963
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986964 = header.getOrDefault("Accept")
  valid_38986964 = validateParameter(valid_38986964, JString, required = false,
                                   default = nil)
  if valid_38986964 != nil:
    section.add "Accept", valid_38986964
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986965: Call_PostReposOwnerRepoHooksHookIdTests_38986958;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Test a push hook.
  ## This will trigger the hook with the latest push to the current repository
  ## if the hook is subscribed to push events. If the hook is not subscribed
  ## to push events, the server will respond with 204 but no test POST will
  ## be generated.
  ## Note: Previously /repos/:owner/:repo/hooks/:id/tes
  ## 
  ## 
  let valid = call_38986965.validator(path, query, header, formData, body, _)
  let scheme = call_38986965.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986965.url(scheme.get, call_38986965.host, call_38986965.base,
                           call_38986965.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986965, url, valid, _)

proc call*(call_38986966: Call_PostReposOwnerRepoHooksHookIdTests_38986958;
          owner: string; repo: string; hookId: int; Accept: string = ""): Recallable =
  ## postReposOwnerRepoHooksHookIdTests
  ## Test a push hook.
  ## This will trigger the hook with the latest push to the current repository
  ## if the hook is subscribed to push events. If the hook is not subscribed
  ## to push events, the server will respond with 204 but no test POST will
  ## be generated.
  ## Note: Previously /repos/:owner/:repo/hooks/:id/tes
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   hookId: int (required)
  ##         : Id of hook.
  var path_38986967 = newJObject()
  var header_38986968 = newJObject()
  add(path_38986967, "owner", newJString(owner))
  add(header_38986968, "Accept", newJString(Accept))
  add(path_38986967, "repo", newJString(repo))
  add(path_38986967, "hookId", newJInt(hookId))
  result = call_38986966.call(path_38986967, nil, header_38986968, nil, nil)

var postReposOwnerRepoHooksHookIdTests* = Call_PostReposOwnerRepoHooksHookIdTests_38986958(
    name: "postReposOwnerRepoHooksHookIdTests", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}/tests",
    validator: validate_PostReposOwnerRepoHooksHookIdTests_38986959, base: "/",
    url: url_PostReposOwnerRepoHooksHookIdTests_38986960, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoIssues_38986986 = ref object of OpenApiRestCall_38985352
proc url_PostReposOwnerRepoIssues_38986988(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoIssues_38986987(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create an issue.
  ## Any user with pull access to a repository can create an issue.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986989 = path.getOrDefault("owner")
  valid_38986989 = validateParameter(valid_38986989, JString, required = true,
                                   default = nil)
  if valid_38986989 != nil:
    section.add "owner", valid_38986989
  var valid_38986990 = path.getOrDefault("repo")
  valid_38986990 = validateParameter(valid_38986990, JString, required = true,
                                   default = nil)
  if valid_38986990 != nil:
    section.add "repo", valid_38986990
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986991 = header.getOrDefault("Accept")
  valid_38986991 = validateParameter(valid_38986991, JString, required = false,
                                   default = nil)
  if valid_38986991 != nil:
    section.add "Accept", valid_38986991
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38986993: Call_PostReposOwnerRepoIssues_38986986;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create an issue.
  ## Any user with pull access to a repository can create an issue.
  ## 
  ## 
  let valid = call_38986993.validator(path, query, header, formData, body, _)
  let scheme = call_38986993.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986993.url(scheme.get, call_38986993.host, call_38986993.base,
                           call_38986993.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986993, url, valid, _)

proc call*(call_38986994: Call_PostReposOwnerRepoIssues_38986986; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoIssues
  ## Create an issue.
  ## Any user with pull access to a repository can create an issue.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38986995 = newJObject()
  var header_38986996 = newJObject()
  var body_38986997 = newJObject()
  add(path_38986995, "owner", newJString(owner))
  add(header_38986996, "Accept", newJString(Accept))
  if body != nil:
    body_38986997 = body
  add(path_38986995, "repo", newJString(repo))
  result = call_38986994.call(path_38986995, nil, header_38986996, nil, body_38986997)

var postReposOwnerRepoIssues* = Call_PostReposOwnerRepoIssues_38986986(
    name: "postReposOwnerRepoIssues", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues",
    validator: validate_PostReposOwnerRepoIssues_38986987, base: "/",
    url: url_PostReposOwnerRepoIssues_38986988, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssues_38986969 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoIssues_38986971(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssues_38986970(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List issues for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38986972 = path.getOrDefault("owner")
  valid_38986972 = validateParameter(valid_38986972, JString, required = true,
                                   default = nil)
  if valid_38986972 != nil:
    section.add "owner", valid_38986972
  var valid_38986973 = path.getOrDefault("repo")
  valid_38986973 = validateParameter(valid_38986973, JString, required = true,
                                   default = nil)
  if valid_38986973 != nil:
    section.add "repo", valid_38986973
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString (required)
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: JString (required)
  ##   direction: JString (required)
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_38986974 = query.getOrDefault("state")
  valid_38986974 = validateParameter(valid_38986974, JString, required = true,
                                   default = newJString("open"))
  if valid_38986974 != nil:
    section.add "state", valid_38986974
  var valid_38986975 = query.getOrDefault("labels")
  valid_38986975 = validateParameter(valid_38986975, JString, required = true,
                                   default = nil)
  if valid_38986975 != nil:
    section.add "labels", valid_38986975
  var valid_38986976 = query.getOrDefault("sort")
  valid_38986976 = validateParameter(valid_38986976, JString, required = true,
                                   default = newJString("created"))
  if valid_38986976 != nil:
    section.add "sort", valid_38986976
  var valid_38986977 = query.getOrDefault("direction")
  valid_38986977 = validateParameter(valid_38986977, JString, required = true,
                                   default = newJString("desc"))
  if valid_38986977 != nil:
    section.add "direction", valid_38986977
  var valid_38986978 = query.getOrDefault("filter")
  valid_38986978 = validateParameter(valid_38986978, JString, required = true,
                                   default = newJString("all"))
  if valid_38986978 != nil:
    section.add "filter", valid_38986978
  var valid_38986979 = query.getOrDefault("since")
  valid_38986979 = validateParameter(valid_38986979, JString, required = false,
                                   default = nil)
  if valid_38986979 != nil:
    section.add "since", valid_38986979
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38986980 = header.getOrDefault("Accept")
  valid_38986980 = validateParameter(valid_38986980, JString, required = false,
                                   default = nil)
  if valid_38986980 != nil:
    section.add "Accept", valid_38986980
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38986981: Call_GetReposOwnerRepoIssues_38986969;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List issues for a repository.
  ## 
  let valid = call_38986981.validator(path, query, header, formData, body, _)
  let scheme = call_38986981.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38986981.url(scheme.get, call_38986981.host, call_38986981.base,
                           call_38986981.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38986981, url, valid, _)

proc call*(call_38986982: Call_GetReposOwnerRepoIssues_38986969; owner: string;
          repo: string; labels: string; state: string = "open"; Accept: string = "";
          sort: string = "created"; direction: string = "desc"; filter: string = "all";
          since: string = ""): Recallable =
  ## getReposOwnerRepoIssues
  ## List issues for a repository.
  ##   state: string (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: string (required)
  ##   direction: string (required)
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  var path_38986983 = newJObject()
  var query_38986984 = newJObject()
  var header_38986985 = newJObject()
  add(query_38986984, "state", newJString(state))
  add(path_38986983, "owner", newJString(owner))
  add(header_38986985, "Accept", newJString(Accept))
  add(path_38986983, "repo", newJString(repo))
  add(query_38986984, "labels", newJString(labels))
  add(query_38986984, "sort", newJString(sort))
  add(query_38986984, "direction", newJString(direction))
  add(query_38986984, "filter", newJString(filter))
  add(query_38986984, "since", newJString(since))
  result = call_38986982.call(path_38986983, query_38986984, header_38986985, nil, nil)

var getReposOwnerRepoIssues* = Call_GetReposOwnerRepoIssues_38986969(
    name: "getReposOwnerRepoIssues", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues",
    validator: validate_GetReposOwnerRepoIssues_38986970, base: "/",
    url: url_GetReposOwnerRepoIssues_38986971, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesComments_38986998 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoIssuesComments_38987000(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesComments_38986999(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List comments in a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987001 = path.getOrDefault("owner")
  valid_38987001 = validateParameter(valid_38987001, JString, required = true,
                                   default = nil)
  if valid_38987001 != nil:
    section.add "owner", valid_38987001
  var valid_38987002 = path.getOrDefault("repo")
  valid_38987002 = validateParameter(valid_38987002, JString, required = true,
                                   default = nil)
  if valid_38987002 != nil:
    section.add "repo", valid_38987002
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_38987003 = query.getOrDefault("sort")
  valid_38987003 = validateParameter(valid_38987003, JString, required = false,
                                   default = newJString("created"))
  if valid_38987003 != nil:
    section.add "sort", valid_38987003
  var valid_38987004 = query.getOrDefault("direction")
  valid_38987004 = validateParameter(valid_38987004, JString, required = false,
                                   default = nil)
  if valid_38987004 != nil:
    section.add "direction", valid_38987004
  var valid_38987005 = query.getOrDefault("since")
  valid_38987005 = validateParameter(valid_38987005, JString, required = false,
                                   default = nil)
  if valid_38987005 != nil:
    section.add "since", valid_38987005
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987006 = header.getOrDefault("Accept")
  valid_38987006 = validateParameter(valid_38987006, JString, required = false,
                                   default = nil)
  if valid_38987006 != nil:
    section.add "Accept", valid_38987006
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987007: Call_GetReposOwnerRepoIssuesComments_38986998;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List comments in a repository.
  ## 
  let valid = call_38987007.validator(path, query, header, formData, body, _)
  let scheme = call_38987007.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987007.url(scheme.get, call_38987007.host, call_38987007.base,
                           call_38987007.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987007, url, valid, _)

proc call*(call_38987008: Call_GetReposOwnerRepoIssuesComments_38986998;
          owner: string; repo: string; Accept: string = ""; sort: string = "created";
          direction: string = ""; since: string = ""): Recallable =
  ## getReposOwnerRepoIssuesComments
  ## List comments in a repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   sort: string
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var path_38987009 = newJObject()
  var query_38987010 = newJObject()
  var header_38987011 = newJObject()
  add(path_38987009, "owner", newJString(owner))
  add(header_38987011, "Accept", newJString(Accept))
  add(path_38987009, "repo", newJString(repo))
  add(query_38987010, "sort", newJString(sort))
  add(query_38987010, "direction", newJString(direction))
  add(query_38987010, "since", newJString(since))
  result = call_38987008.call(path_38987009, query_38987010, header_38987011, nil, nil)

var getReposOwnerRepoIssuesComments* = Call_GetReposOwnerRepoIssuesComments_38986998(
    name: "getReposOwnerRepoIssuesComments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/comments",
    validator: validate_GetReposOwnerRepoIssuesComments_38986999, base: "/",
    url: url_GetReposOwnerRepoIssuesComments_38987000, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesCommentsCommentId_38987012 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoIssuesCommentsCommentId_38987014(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesCommentsCommentId_38987013(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a single comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : ID of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987015 = path.getOrDefault("owner")
  valid_38987015 = validateParameter(valid_38987015, JString, required = true,
                                   default = nil)
  if valid_38987015 != nil:
    section.add "owner", valid_38987015
  var valid_38987016 = path.getOrDefault("repo")
  valid_38987016 = validateParameter(valid_38987016, JString, required = true,
                                   default = nil)
  if valid_38987016 != nil:
    section.add "repo", valid_38987016
  var valid_38987017 = path.getOrDefault("commentId")
  valid_38987017 = validateParameter(valid_38987017, JInt, required = true,
                                   default = nil)
  if valid_38987017 != nil:
    section.add "commentId", valid_38987017
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987018 = header.getOrDefault("Accept")
  valid_38987018 = validateParameter(valid_38987018, JString, required = false,
                                   default = nil)
  if valid_38987018 != nil:
    section.add "Accept", valid_38987018
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987019: Call_GetReposOwnerRepoIssuesCommentsCommentId_38987012;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single comment.
  ## 
  let valid = call_38987019.validator(path, query, header, formData, body, _)
  let scheme = call_38987019.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987019.url(scheme.get, call_38987019.host, call_38987019.base,
                           call_38987019.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987019, url, valid, _)

proc call*(call_38987020: Call_GetReposOwnerRepoIssuesCommentsCommentId_38987012;
          owner: string; repo: string; commentId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesCommentsCommentId
  ## Get a single comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : ID of comment.
  var path_38987021 = newJObject()
  var header_38987022 = newJObject()
  add(path_38987021, "owner", newJString(owner))
  add(header_38987022, "Accept", newJString(Accept))
  add(path_38987021, "repo", newJString(repo))
  add(path_38987021, "commentId", newJInt(commentId))
  result = call_38987020.call(path_38987021, nil, header_38987022, nil, nil)

var getReposOwnerRepoIssuesCommentsCommentId* = Call_GetReposOwnerRepoIssuesCommentsCommentId_38987012(
    name: "getReposOwnerRepoIssuesCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/comments/{commentId}",
    validator: validate_GetReposOwnerRepoIssuesCommentsCommentId_38987013,
    base: "/", url: url_GetReposOwnerRepoIssuesCommentsCommentId_38987014,
    schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoIssuesCommentsCommentId_38987034 = ref object of OpenApiRestCall_38985352
proc url_PatchReposOwnerRepoIssuesCommentsCommentId_38987036(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoIssuesCommentsCommentId_38987035(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Edit a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : ID of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987037 = path.getOrDefault("owner")
  valid_38987037 = validateParameter(valid_38987037, JString, required = true,
                                   default = nil)
  if valid_38987037 != nil:
    section.add "owner", valid_38987037
  var valid_38987038 = path.getOrDefault("repo")
  valid_38987038 = validateParameter(valid_38987038, JString, required = true,
                                   default = nil)
  if valid_38987038 != nil:
    section.add "repo", valid_38987038
  var valid_38987039 = path.getOrDefault("commentId")
  valid_38987039 = validateParameter(valid_38987039, JInt, required = true,
                                   default = nil)
  if valid_38987039 != nil:
    section.add "commentId", valid_38987039
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987040 = header.getOrDefault("Accept")
  valid_38987040 = validateParameter(valid_38987040, JString, required = false,
                                   default = nil)
  if valid_38987040 != nil:
    section.add "Accept", valid_38987040
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38987042: Call_PatchReposOwnerRepoIssuesCommentsCommentId_38987034;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit a comment.
  ## 
  let valid = call_38987042.validator(path, query, header, formData, body, _)
  let scheme = call_38987042.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987042.url(scheme.get, call_38987042.host, call_38987042.base,
                           call_38987042.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987042, url, valid, _)

proc call*(call_38987043: Call_PatchReposOwnerRepoIssuesCommentsCommentId_38987034;
          owner: string; body: JsonNode; repo: string; commentId: int;
          Accept: string = ""): Recallable =
  ## patchReposOwnerRepoIssuesCommentsCommentId
  ## Edit a comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : ID of comment.
  var path_38987044 = newJObject()
  var header_38987045 = newJObject()
  var body_38987046 = newJObject()
  add(path_38987044, "owner", newJString(owner))
  add(header_38987045, "Accept", newJString(Accept))
  if body != nil:
    body_38987046 = body
  add(path_38987044, "repo", newJString(repo))
  add(path_38987044, "commentId", newJInt(commentId))
  result = call_38987043.call(path_38987044, nil, header_38987045, nil, body_38987046)

var patchReposOwnerRepoIssuesCommentsCommentId* = Call_PatchReposOwnerRepoIssuesCommentsCommentId_38987034(
    name: "patchReposOwnerRepoIssuesCommentsCommentId",
    meth: HttpMethod.HttpPatch, host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/comments/{commentId}",
    validator: validate_PatchReposOwnerRepoIssuesCommentsCommentId_38987035,
    base: "/", url: url_PatchReposOwnerRepoIssuesCommentsCommentId_38987036,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoIssuesCommentsCommentId_38987023 = ref object of OpenApiRestCall_38985352
proc url_DeleteReposOwnerRepoIssuesCommentsCommentId_38987025(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoIssuesCommentsCommentId_38987024(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## Delete a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : ID of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987026 = path.getOrDefault("owner")
  valid_38987026 = validateParameter(valid_38987026, JString, required = true,
                                   default = nil)
  if valid_38987026 != nil:
    section.add "owner", valid_38987026
  var valid_38987027 = path.getOrDefault("repo")
  valid_38987027 = validateParameter(valid_38987027, JString, required = true,
                                   default = nil)
  if valid_38987027 != nil:
    section.add "repo", valid_38987027
  var valid_38987028 = path.getOrDefault("commentId")
  valid_38987028 = validateParameter(valid_38987028, JInt, required = true,
                                   default = nil)
  if valid_38987028 != nil:
    section.add "commentId", valid_38987028
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987029 = header.getOrDefault("Accept")
  valid_38987029 = validateParameter(valid_38987029, JString, required = false,
                                   default = nil)
  if valid_38987029 != nil:
    section.add "Accept", valid_38987029
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987030: Call_DeleteReposOwnerRepoIssuesCommentsCommentId_38987023;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a comment.
  ## 
  let valid = call_38987030.validator(path, query, header, formData, body, _)
  let scheme = call_38987030.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987030.url(scheme.get, call_38987030.host, call_38987030.base,
                           call_38987030.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987030, url, valid, _)

proc call*(call_38987031: Call_DeleteReposOwnerRepoIssuesCommentsCommentId_38987023;
          owner: string; repo: string; commentId: int; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoIssuesCommentsCommentId
  ## Delete a comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : ID of comment.
  var path_38987032 = newJObject()
  var header_38987033 = newJObject()
  add(path_38987032, "owner", newJString(owner))
  add(header_38987033, "Accept", newJString(Accept))
  add(path_38987032, "repo", newJString(repo))
  add(path_38987032, "commentId", newJInt(commentId))
  result = call_38987031.call(path_38987032, nil, header_38987033, nil, nil)

var deleteReposOwnerRepoIssuesCommentsCommentId* = Call_DeleteReposOwnerRepoIssuesCommentsCommentId_38987023(
    name: "deleteReposOwnerRepoIssuesCommentsCommentId",
    meth: HttpMethod.HttpDelete, host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/comments/{commentId}",
    validator: validate_DeleteReposOwnerRepoIssuesCommentsCommentId_38987024,
    base: "/", url: url_DeleteReposOwnerRepoIssuesCommentsCommentId_38987025,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesEvents_38987047 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoIssuesEvents_38987049(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesEvents_38987048(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List issue events for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987050 = path.getOrDefault("owner")
  valid_38987050 = validateParameter(valid_38987050, JString, required = true,
                                   default = nil)
  if valid_38987050 != nil:
    section.add "owner", valid_38987050
  var valid_38987051 = path.getOrDefault("repo")
  valid_38987051 = validateParameter(valid_38987051, JString, required = true,
                                   default = nil)
  if valid_38987051 != nil:
    section.add "repo", valid_38987051
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987052 = header.getOrDefault("Accept")
  valid_38987052 = validateParameter(valid_38987052, JString, required = false,
                                   default = nil)
  if valid_38987052 != nil:
    section.add "Accept", valid_38987052
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987053: Call_GetReposOwnerRepoIssuesEvents_38987047;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List issue events for a repository.
  ## 
  let valid = call_38987053.validator(path, query, header, formData, body, _)
  let scheme = call_38987053.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987053.url(scheme.get, call_38987053.host, call_38987053.base,
                           call_38987053.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987053, url, valid, _)

proc call*(call_38987054: Call_GetReposOwnerRepoIssuesEvents_38987047;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesEvents
  ## List issue events for a repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987055 = newJObject()
  var header_38987056 = newJObject()
  add(path_38987055, "owner", newJString(owner))
  add(header_38987056, "Accept", newJString(Accept))
  add(path_38987055, "repo", newJString(repo))
  result = call_38987054.call(path_38987055, nil, header_38987056, nil, nil)

var getReposOwnerRepoIssuesEvents* = Call_GetReposOwnerRepoIssuesEvents_38987047(
    name: "getReposOwnerRepoIssuesEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/events",
    validator: validate_GetReposOwnerRepoIssuesEvents_38987048, base: "/",
    url: url_GetReposOwnerRepoIssuesEvents_38987049, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesEventsEventId_38987057 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoIssuesEventsEventId_38987059(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "eventId" in path, "`eventId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/events/"),
               (kind: VariableSegment, value: "eventId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesEventsEventId_38987058(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a single event.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   eventId: JInt (required)
  ##          : Id of the event.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987060 = path.getOrDefault("owner")
  valid_38987060 = validateParameter(valid_38987060, JString, required = true,
                                   default = nil)
  if valid_38987060 != nil:
    section.add "owner", valid_38987060
  var valid_38987061 = path.getOrDefault("repo")
  valid_38987061 = validateParameter(valid_38987061, JString, required = true,
                                   default = nil)
  if valid_38987061 != nil:
    section.add "repo", valid_38987061
  var valid_38987062 = path.getOrDefault("eventId")
  valid_38987062 = validateParameter(valid_38987062, JInt, required = true,
                                   default = nil)
  if valid_38987062 != nil:
    section.add "eventId", valid_38987062
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987063 = header.getOrDefault("Accept")
  valid_38987063 = validateParameter(valid_38987063, JString, required = false,
                                   default = nil)
  if valid_38987063 != nil:
    section.add "Accept", valid_38987063
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987064: Call_GetReposOwnerRepoIssuesEventsEventId_38987057;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single event.
  ## 
  let valid = call_38987064.validator(path, query, header, formData, body, _)
  let scheme = call_38987064.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987064.url(scheme.get, call_38987064.host, call_38987064.base,
                           call_38987064.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987064, url, valid, _)

proc call*(call_38987065: Call_GetReposOwnerRepoIssuesEventsEventId_38987057;
          owner: string; repo: string; eventId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesEventsEventId
  ## Get a single event.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   eventId: int (required)
  ##          : Id of the event.
  var path_38987066 = newJObject()
  var header_38987067 = newJObject()
  add(path_38987066, "owner", newJString(owner))
  add(header_38987067, "Accept", newJString(Accept))
  add(path_38987066, "repo", newJString(repo))
  add(path_38987066, "eventId", newJInt(eventId))
  result = call_38987065.call(path_38987066, nil, header_38987067, nil, nil)

var getReposOwnerRepoIssuesEventsEventId* = Call_GetReposOwnerRepoIssuesEventsEventId_38987057(
    name: "getReposOwnerRepoIssuesEventsEventId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/events/{eventId}",
    validator: validate_GetReposOwnerRepoIssuesEventsEventId_38987058, base: "/",
    url: url_GetReposOwnerRepoIssuesEventsEventId_38987059,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumber_38987068 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoIssuesNumber_38987070(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumber_38987069(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a single issue
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987071 = path.getOrDefault("owner")
  valid_38987071 = validateParameter(valid_38987071, JString, required = true,
                                   default = nil)
  if valid_38987071 != nil:
    section.add "owner", valid_38987071
  var valid_38987072 = path.getOrDefault("number")
  valid_38987072 = validateParameter(valid_38987072, JInt, required = true,
                                   default = nil)
  if valid_38987072 != nil:
    section.add "number", valid_38987072
  var valid_38987073 = path.getOrDefault("repo")
  valid_38987073 = validateParameter(valid_38987073, JString, required = true,
                                   default = nil)
  if valid_38987073 != nil:
    section.add "repo", valid_38987073
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987074 = header.getOrDefault("Accept")
  valid_38987074 = validateParameter(valid_38987074, JString, required = false,
                                   default = nil)
  if valid_38987074 != nil:
    section.add "Accept", valid_38987074
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987075: Call_GetReposOwnerRepoIssuesNumber_38987068;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single issue
  ## 
  let valid = call_38987075.validator(path, query, header, formData, body, _)
  let scheme = call_38987075.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987075.url(scheme.get, call_38987075.host, call_38987075.base,
                           call_38987075.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987075, url, valid, _)

proc call*(call_38987076: Call_GetReposOwnerRepoIssuesNumber_38987068;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumber
  ## Get a single issue
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987077 = newJObject()
  var header_38987078 = newJObject()
  add(path_38987077, "owner", newJString(owner))
  add(path_38987077, "number", newJInt(number))
  add(header_38987078, "Accept", newJString(Accept))
  add(path_38987077, "repo", newJString(repo))
  result = call_38987076.call(path_38987077, nil, header_38987078, nil, nil)

var getReposOwnerRepoIssuesNumber* = Call_GetReposOwnerRepoIssuesNumber_38987068(
    name: "getReposOwnerRepoIssuesNumber", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}",
    validator: validate_GetReposOwnerRepoIssuesNumber_38987069, base: "/",
    url: url_GetReposOwnerRepoIssuesNumber_38987070, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoIssuesNumber_38987079 = ref object of OpenApiRestCall_38985352
proc url_PatchReposOwnerRepoIssuesNumber_38987081(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoIssuesNumber_38987080(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Edit an issue.
  ## Issue owners and users with push access can edit an issue.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987082 = path.getOrDefault("owner")
  valid_38987082 = validateParameter(valid_38987082, JString, required = true,
                                   default = nil)
  if valid_38987082 != nil:
    section.add "owner", valid_38987082
  var valid_38987083 = path.getOrDefault("number")
  valid_38987083 = validateParameter(valid_38987083, JInt, required = true,
                                   default = nil)
  if valid_38987083 != nil:
    section.add "number", valid_38987083
  var valid_38987084 = path.getOrDefault("repo")
  valid_38987084 = validateParameter(valid_38987084, JString, required = true,
                                   default = nil)
  if valid_38987084 != nil:
    section.add "repo", valid_38987084
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987085 = header.getOrDefault("Accept")
  valid_38987085 = validateParameter(valid_38987085, JString, required = false,
                                   default = nil)
  if valid_38987085 != nil:
    section.add "Accept", valid_38987085
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38987087: Call_PatchReposOwnerRepoIssuesNumber_38987079;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit an issue.
  ## Issue owners and users with push access can edit an issue.
  ## 
  ## 
  let valid = call_38987087.validator(path, query, header, formData, body, _)
  let scheme = call_38987087.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987087.url(scheme.get, call_38987087.host, call_38987087.base,
                           call_38987087.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987087, url, valid, _)

proc call*(call_38987088: Call_PatchReposOwnerRepoIssuesNumber_38987079;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoIssuesNumber
  ## Edit an issue.
  ## Issue owners and users with push access can edit an issue.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987089 = newJObject()
  var header_38987090 = newJObject()
  var body_38987091 = newJObject()
  add(path_38987089, "owner", newJString(owner))
  add(path_38987089, "number", newJInt(number))
  add(header_38987090, "Accept", newJString(Accept))
  if body != nil:
    body_38987091 = body
  add(path_38987089, "repo", newJString(repo))
  result = call_38987088.call(path_38987089, nil, header_38987090, nil, body_38987091)

var patchReposOwnerRepoIssuesNumber* = Call_PatchReposOwnerRepoIssuesNumber_38987079(
    name: "patchReposOwnerRepoIssuesNumber", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}",
    validator: validate_PatchReposOwnerRepoIssuesNumber_38987080, base: "/",
    url: url_PatchReposOwnerRepoIssuesNumber_38987081, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoIssuesNumberComments_38987103 = ref object of OpenApiRestCall_38985352
proc url_PostReposOwnerRepoIssuesNumberComments_38987105(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoIssuesNumberComments_38987104(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Create a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987106 = path.getOrDefault("owner")
  valid_38987106 = validateParameter(valid_38987106, JString, required = true,
                                   default = nil)
  if valid_38987106 != nil:
    section.add "owner", valid_38987106
  var valid_38987107 = path.getOrDefault("number")
  valid_38987107 = validateParameter(valid_38987107, JInt, required = true,
                                   default = nil)
  if valid_38987107 != nil:
    section.add "number", valid_38987107
  var valid_38987108 = path.getOrDefault("repo")
  valid_38987108 = validateParameter(valid_38987108, JString, required = true,
                                   default = nil)
  if valid_38987108 != nil:
    section.add "repo", valid_38987108
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987109 = header.getOrDefault("Accept")
  valid_38987109 = validateParameter(valid_38987109, JString, required = false,
                                   default = nil)
  if valid_38987109 != nil:
    section.add "Accept", valid_38987109
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38987111: Call_PostReposOwnerRepoIssuesNumberComments_38987103;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a comment.
  ## 
  let valid = call_38987111.validator(path, query, header, formData, body, _)
  let scheme = call_38987111.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987111.url(scheme.get, call_38987111.host, call_38987111.base,
                           call_38987111.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987111, url, valid, _)

proc call*(call_38987112: Call_PostReposOwnerRepoIssuesNumberComments_38987103;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoIssuesNumberComments
  ## Create a comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987113 = newJObject()
  var header_38987114 = newJObject()
  var body_38987115 = newJObject()
  add(path_38987113, "owner", newJString(owner))
  add(path_38987113, "number", newJInt(number))
  add(header_38987114, "Accept", newJString(Accept))
  if body != nil:
    body_38987115 = body
  add(path_38987113, "repo", newJString(repo))
  result = call_38987112.call(path_38987113, nil, header_38987114, nil, body_38987115)

var postReposOwnerRepoIssuesNumberComments* = Call_PostReposOwnerRepoIssuesNumberComments_38987103(
    name: "postReposOwnerRepoIssuesNumberComments", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/{number}/comments",
    validator: validate_PostReposOwnerRepoIssuesNumberComments_38987104,
    base: "/", url: url_PostReposOwnerRepoIssuesNumberComments_38987105,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumberComments_38987092 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoIssuesNumberComments_38987094(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumberComments_38987093(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List comments on an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987095 = path.getOrDefault("owner")
  valid_38987095 = validateParameter(valid_38987095, JString, required = true,
                                   default = nil)
  if valid_38987095 != nil:
    section.add "owner", valid_38987095
  var valid_38987096 = path.getOrDefault("number")
  valid_38987096 = validateParameter(valid_38987096, JInt, required = true,
                                   default = nil)
  if valid_38987096 != nil:
    section.add "number", valid_38987096
  var valid_38987097 = path.getOrDefault("repo")
  valid_38987097 = validateParameter(valid_38987097, JString, required = true,
                                   default = nil)
  if valid_38987097 != nil:
    section.add "repo", valid_38987097
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987098 = header.getOrDefault("Accept")
  valid_38987098 = validateParameter(valid_38987098, JString, required = false,
                                   default = nil)
  if valid_38987098 != nil:
    section.add "Accept", valid_38987098
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987099: Call_GetReposOwnerRepoIssuesNumberComments_38987092;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List comments on an issue.
  ## 
  let valid = call_38987099.validator(path, query, header, formData, body, _)
  let scheme = call_38987099.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987099.url(scheme.get, call_38987099.host, call_38987099.base,
                           call_38987099.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987099, url, valid, _)

proc call*(call_38987100: Call_GetReposOwnerRepoIssuesNumberComments_38987092;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumberComments
  ## List comments on an issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987101 = newJObject()
  var header_38987102 = newJObject()
  add(path_38987101, "owner", newJString(owner))
  add(path_38987101, "number", newJInt(number))
  add(header_38987102, "Accept", newJString(Accept))
  add(path_38987101, "repo", newJString(repo))
  result = call_38987100.call(path_38987101, nil, header_38987102, nil, nil)

var getReposOwnerRepoIssuesNumberComments* = Call_GetReposOwnerRepoIssuesNumberComments_38987092(
    name: "getReposOwnerRepoIssuesNumberComments", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/{number}/comments",
    validator: validate_GetReposOwnerRepoIssuesNumberComments_38987093, base: "/",
    url: url_GetReposOwnerRepoIssuesNumberComments_38987094,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumberEvents_38987116 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoIssuesNumberEvents_38987118(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumberEvents_38987117(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List events for an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987119 = path.getOrDefault("owner")
  valid_38987119 = validateParameter(valid_38987119, JString, required = true,
                                   default = nil)
  if valid_38987119 != nil:
    section.add "owner", valid_38987119
  var valid_38987120 = path.getOrDefault("number")
  valid_38987120 = validateParameter(valid_38987120, JInt, required = true,
                                   default = nil)
  if valid_38987120 != nil:
    section.add "number", valid_38987120
  var valid_38987121 = path.getOrDefault("repo")
  valid_38987121 = validateParameter(valid_38987121, JString, required = true,
                                   default = nil)
  if valid_38987121 != nil:
    section.add "repo", valid_38987121
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987122 = header.getOrDefault("Accept")
  valid_38987122 = validateParameter(valid_38987122, JString, required = false,
                                   default = nil)
  if valid_38987122 != nil:
    section.add "Accept", valid_38987122
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987123: Call_GetReposOwnerRepoIssuesNumberEvents_38987116;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List events for an issue.
  ## 
  let valid = call_38987123.validator(path, query, header, formData, body, _)
  let scheme = call_38987123.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987123.url(scheme.get, call_38987123.host, call_38987123.base,
                           call_38987123.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987123, url, valid, _)

proc call*(call_38987124: Call_GetReposOwnerRepoIssuesNumberEvents_38987116;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumberEvents
  ## List events for an issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987125 = newJObject()
  var header_38987126 = newJObject()
  add(path_38987125, "owner", newJString(owner))
  add(path_38987125, "number", newJInt(number))
  add(header_38987126, "Accept", newJString(Accept))
  add(path_38987125, "repo", newJString(repo))
  result = call_38987124.call(path_38987125, nil, header_38987126, nil, nil)

var getReposOwnerRepoIssuesNumberEvents* = Call_GetReposOwnerRepoIssuesNumberEvents_38987116(
    name: "getReposOwnerRepoIssuesNumberEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/events",
    validator: validate_GetReposOwnerRepoIssuesNumberEvents_38987117, base: "/",
    url: url_GetReposOwnerRepoIssuesNumberEvents_38987118, schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoIssuesNumberLabels_38987138 = ref object of OpenApiRestCall_38985352
proc url_PutReposOwnerRepoIssuesNumberLabels_38987140(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoIssuesNumberLabels_38987139(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Replace all labels for an issue.
  ## Sending an empty array ([]) will remove all Labels from the Issue.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987141 = path.getOrDefault("owner")
  valid_38987141 = validateParameter(valid_38987141, JString, required = true,
                                   default = nil)
  if valid_38987141 != nil:
    section.add "owner", valid_38987141
  var valid_38987142 = path.getOrDefault("number")
  valid_38987142 = validateParameter(valid_38987142, JInt, required = true,
                                   default = nil)
  if valid_38987142 != nil:
    section.add "number", valid_38987142
  var valid_38987143 = path.getOrDefault("repo")
  valid_38987143 = validateParameter(valid_38987143, JString, required = true,
                                   default = nil)
  if valid_38987143 != nil:
    section.add "repo", valid_38987143
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987144 = header.getOrDefault("Accept")
  valid_38987144 = validateParameter(valid_38987144, JString, required = false,
                                   default = nil)
  if valid_38987144 != nil:
    section.add "Accept", valid_38987144
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38987146: Call_PutReposOwnerRepoIssuesNumberLabels_38987138;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Replace all labels for an issue.
  ## Sending an empty array ([]) will remove all Labels from the Issue.
  ## 
  ## 
  let valid = call_38987146.validator(path, query, header, formData, body, _)
  let scheme = call_38987146.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987146.url(scheme.get, call_38987146.host, call_38987146.base,
                           call_38987146.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987146, url, valid, _)

proc call*(call_38987147: Call_PutReposOwnerRepoIssuesNumberLabels_38987138;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoIssuesNumberLabels
  ## Replace all labels for an issue.
  ## Sending an empty array ([]) will remove all Labels from the Issue.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987148 = newJObject()
  var header_38987149 = newJObject()
  var body_38987150 = newJObject()
  add(path_38987148, "owner", newJString(owner))
  add(path_38987148, "number", newJInt(number))
  add(header_38987149, "Accept", newJString(Accept))
  if body != nil:
    body_38987150 = body
  add(path_38987148, "repo", newJString(repo))
  result = call_38987147.call(path_38987148, nil, header_38987149, nil, body_38987150)

var putReposOwnerRepoIssuesNumberLabels* = Call_PutReposOwnerRepoIssuesNumberLabels_38987138(
    name: "putReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_PutReposOwnerRepoIssuesNumberLabels_38987139, base: "/",
    url: url_PutReposOwnerRepoIssuesNumberLabels_38987140, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoIssuesNumberLabels_38987151 = ref object of OpenApiRestCall_38985352
proc url_PostReposOwnerRepoIssuesNumberLabels_38987153(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoIssuesNumberLabels_38987152(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Add labels to an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987154 = path.getOrDefault("owner")
  valid_38987154 = validateParameter(valid_38987154, JString, required = true,
                                   default = nil)
  if valid_38987154 != nil:
    section.add "owner", valid_38987154
  var valid_38987155 = path.getOrDefault("number")
  valid_38987155 = validateParameter(valid_38987155, JInt, required = true,
                                   default = nil)
  if valid_38987155 != nil:
    section.add "number", valid_38987155
  var valid_38987156 = path.getOrDefault("repo")
  valid_38987156 = validateParameter(valid_38987156, JString, required = true,
                                   default = nil)
  if valid_38987156 != nil:
    section.add "repo", valid_38987156
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987157 = header.getOrDefault("Accept")
  valid_38987157 = validateParameter(valid_38987157, JString, required = false,
                                   default = nil)
  if valid_38987157 != nil:
    section.add "Accept", valid_38987157
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38987159: Call_PostReposOwnerRepoIssuesNumberLabels_38987151;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Add labels to an issue.
  ## 
  let valid = call_38987159.validator(path, query, header, formData, body, _)
  let scheme = call_38987159.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987159.url(scheme.get, call_38987159.host, call_38987159.base,
                           call_38987159.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987159, url, valid, _)

proc call*(call_38987160: Call_PostReposOwnerRepoIssuesNumberLabels_38987151;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoIssuesNumberLabels
  ## Add labels to an issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987161 = newJObject()
  var header_38987162 = newJObject()
  var body_38987163 = newJObject()
  add(path_38987161, "owner", newJString(owner))
  add(path_38987161, "number", newJInt(number))
  add(header_38987162, "Accept", newJString(Accept))
  if body != nil:
    body_38987163 = body
  add(path_38987161, "repo", newJString(repo))
  result = call_38987160.call(path_38987161, nil, header_38987162, nil, body_38987163)

var postReposOwnerRepoIssuesNumberLabels* = Call_PostReposOwnerRepoIssuesNumberLabels_38987151(
    name: "postReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_PostReposOwnerRepoIssuesNumberLabels_38987152, base: "/",
    url: url_PostReposOwnerRepoIssuesNumberLabels_38987153,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumberLabels_38987127 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoIssuesNumberLabels_38987129(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumberLabels_38987128(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List labels on an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987130 = path.getOrDefault("owner")
  valid_38987130 = validateParameter(valid_38987130, JString, required = true,
                                   default = nil)
  if valid_38987130 != nil:
    section.add "owner", valid_38987130
  var valid_38987131 = path.getOrDefault("number")
  valid_38987131 = validateParameter(valid_38987131, JInt, required = true,
                                   default = nil)
  if valid_38987131 != nil:
    section.add "number", valid_38987131
  var valid_38987132 = path.getOrDefault("repo")
  valid_38987132 = validateParameter(valid_38987132, JString, required = true,
                                   default = nil)
  if valid_38987132 != nil:
    section.add "repo", valid_38987132
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987133 = header.getOrDefault("Accept")
  valid_38987133 = validateParameter(valid_38987133, JString, required = false,
                                   default = nil)
  if valid_38987133 != nil:
    section.add "Accept", valid_38987133
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987134: Call_GetReposOwnerRepoIssuesNumberLabels_38987127;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List labels on an issue.
  ## 
  let valid = call_38987134.validator(path, query, header, formData, body, _)
  let scheme = call_38987134.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987134.url(scheme.get, call_38987134.host, call_38987134.base,
                           call_38987134.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987134, url, valid, _)

proc call*(call_38987135: Call_GetReposOwnerRepoIssuesNumberLabels_38987127;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumberLabels
  ## List labels on an issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987136 = newJObject()
  var header_38987137 = newJObject()
  add(path_38987136, "owner", newJString(owner))
  add(path_38987136, "number", newJInt(number))
  add(header_38987137, "Accept", newJString(Accept))
  add(path_38987136, "repo", newJString(repo))
  result = call_38987135.call(path_38987136, nil, header_38987137, nil, nil)

var getReposOwnerRepoIssuesNumberLabels* = Call_GetReposOwnerRepoIssuesNumberLabels_38987127(
    name: "getReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_GetReposOwnerRepoIssuesNumberLabels_38987128, base: "/",
    url: url_GetReposOwnerRepoIssuesNumberLabels_38987129, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoIssuesNumberLabels_38987164 = ref object of OpenApiRestCall_38985352
proc url_DeleteReposOwnerRepoIssuesNumberLabels_38987166(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoIssuesNumberLabels_38987165(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Remove all labels from an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987167 = path.getOrDefault("owner")
  valid_38987167 = validateParameter(valid_38987167, JString, required = true,
                                   default = nil)
  if valid_38987167 != nil:
    section.add "owner", valid_38987167
  var valid_38987168 = path.getOrDefault("number")
  valid_38987168 = validateParameter(valid_38987168, JInt, required = true,
                                   default = nil)
  if valid_38987168 != nil:
    section.add "number", valid_38987168
  var valid_38987169 = path.getOrDefault("repo")
  valid_38987169 = validateParameter(valid_38987169, JString, required = true,
                                   default = nil)
  if valid_38987169 != nil:
    section.add "repo", valid_38987169
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987170 = header.getOrDefault("Accept")
  valid_38987170 = validateParameter(valid_38987170, JString, required = false,
                                   default = nil)
  if valid_38987170 != nil:
    section.add "Accept", valid_38987170
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987171: Call_DeleteReposOwnerRepoIssuesNumberLabels_38987164;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Remove all labels from an issue.
  ## 
  let valid = call_38987171.validator(path, query, header, formData, body, _)
  let scheme = call_38987171.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987171.url(scheme.get, call_38987171.host, call_38987171.base,
                           call_38987171.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987171, url, valid, _)

proc call*(call_38987172: Call_DeleteReposOwnerRepoIssuesNumberLabels_38987164;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoIssuesNumberLabels
  ## Remove all labels from an issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987173 = newJObject()
  var header_38987174 = newJObject()
  add(path_38987173, "owner", newJString(owner))
  add(path_38987173, "number", newJInt(number))
  add(header_38987174, "Accept", newJString(Accept))
  add(path_38987173, "repo", newJString(repo))
  result = call_38987172.call(path_38987173, nil, header_38987174, nil, nil)

var deleteReposOwnerRepoIssuesNumberLabels* = Call_DeleteReposOwnerRepoIssuesNumberLabels_38987164(
    name: "deleteReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_DeleteReposOwnerRepoIssuesNumberLabels_38987165,
    base: "/", url: url_DeleteReposOwnerRepoIssuesNumberLabels_38987166,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoIssuesNumberLabelsName_38987175 = ref object of OpenApiRestCall_38985352
proc url_DeleteReposOwnerRepoIssuesNumberLabelsName_38987177(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoIssuesNumberLabelsName_38987176(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Remove a label from an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   name: JString (required)
  ##       : Name of the label.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987178 = path.getOrDefault("owner")
  valid_38987178 = validateParameter(valid_38987178, JString, required = true,
                                   default = nil)
  if valid_38987178 != nil:
    section.add "owner", valid_38987178
  var valid_38987179 = path.getOrDefault("number")
  valid_38987179 = validateParameter(valid_38987179, JInt, required = true,
                                   default = nil)
  if valid_38987179 != nil:
    section.add "number", valid_38987179
  var valid_38987180 = path.getOrDefault("name")
  valid_38987180 = validateParameter(valid_38987180, JString, required = true,
                                   default = nil)
  if valid_38987180 != nil:
    section.add "name", valid_38987180
  var valid_38987181 = path.getOrDefault("repo")
  valid_38987181 = validateParameter(valid_38987181, JString, required = true,
                                   default = nil)
  if valid_38987181 != nil:
    section.add "repo", valid_38987181
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987182 = header.getOrDefault("Accept")
  valid_38987182 = validateParameter(valid_38987182, JString, required = false,
                                   default = nil)
  if valid_38987182 != nil:
    section.add "Accept", valid_38987182
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987183: Call_DeleteReposOwnerRepoIssuesNumberLabelsName_38987175;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Remove a label from an issue.
  ## 
  let valid = call_38987183.validator(path, query, header, formData, body, _)
  let scheme = call_38987183.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987183.url(scheme.get, call_38987183.host, call_38987183.base,
                           call_38987183.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987183, url, valid, _)

proc call*(call_38987184: Call_DeleteReposOwnerRepoIssuesNumberLabelsName_38987175;
          owner: string; number: int; name: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoIssuesNumberLabelsName
  ## Remove a label from an issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   name: string (required)
  ##       : Name of the label.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987185 = newJObject()
  var header_38987186 = newJObject()
  add(path_38987185, "owner", newJString(owner))
  add(path_38987185, "number", newJInt(number))
  add(path_38987185, "name", newJString(name))
  add(header_38987186, "Accept", newJString(Accept))
  add(path_38987185, "repo", newJString(repo))
  result = call_38987184.call(path_38987185, nil, header_38987186, nil, nil)

var deleteReposOwnerRepoIssuesNumberLabelsName* = Call_DeleteReposOwnerRepoIssuesNumberLabelsName_38987175(
    name: "deleteReposOwnerRepoIssuesNumberLabelsName",
    meth: HttpMethod.HttpDelete, host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/{number}/labels/{name}",
    validator: validate_DeleteReposOwnerRepoIssuesNumberLabelsName_38987176,
    base: "/", url: url_DeleteReposOwnerRepoIssuesNumberLabelsName_38987177,
    schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoKeys_38987197 = ref object of OpenApiRestCall_38985352
proc url_PostReposOwnerRepoKeys_38987199(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/keys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoKeys_38987198(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a key.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987200 = path.getOrDefault("owner")
  valid_38987200 = validateParameter(valid_38987200, JString, required = true,
                                   default = nil)
  if valid_38987200 != nil:
    section.add "owner", valid_38987200
  var valid_38987201 = path.getOrDefault("repo")
  valid_38987201 = validateParameter(valid_38987201, JString, required = true,
                                   default = nil)
  if valid_38987201 != nil:
    section.add "repo", valid_38987201
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987202 = header.getOrDefault("Accept")
  valid_38987202 = validateParameter(valid_38987202, JString, required = false,
                                   default = nil)
  if valid_38987202 != nil:
    section.add "Accept", valid_38987202
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38987204: Call_PostReposOwnerRepoKeys_38987197;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a key.
  ## 
  let valid = call_38987204.validator(path, query, header, formData, body, _)
  let scheme = call_38987204.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987204.url(scheme.get, call_38987204.host, call_38987204.base,
                           call_38987204.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987204, url, valid, _)

proc call*(call_38987205: Call_PostReposOwnerRepoKeys_38987197; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoKeys
  ## Create a key.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987206 = newJObject()
  var header_38987207 = newJObject()
  var body_38987208 = newJObject()
  add(path_38987206, "owner", newJString(owner))
  add(header_38987207, "Accept", newJString(Accept))
  if body != nil:
    body_38987208 = body
  add(path_38987206, "repo", newJString(repo))
  result = call_38987205.call(path_38987206, nil, header_38987207, nil, body_38987208)

var postReposOwnerRepoKeys* = Call_PostReposOwnerRepoKeys_38987197(
    name: "postReposOwnerRepoKeys", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/keys",
    validator: validate_PostReposOwnerRepoKeys_38987198, base: "/",
    url: url_PostReposOwnerRepoKeys_38987199, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoKeys_38987187 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoKeys_38987189(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/keys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoKeys_38987188(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get list of keys.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987190 = path.getOrDefault("owner")
  valid_38987190 = validateParameter(valid_38987190, JString, required = true,
                                   default = nil)
  if valid_38987190 != nil:
    section.add "owner", valid_38987190
  var valid_38987191 = path.getOrDefault("repo")
  valid_38987191 = validateParameter(valid_38987191, JString, required = true,
                                   default = nil)
  if valid_38987191 != nil:
    section.add "repo", valid_38987191
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987192 = header.getOrDefault("Accept")
  valid_38987192 = validateParameter(valid_38987192, JString, required = false,
                                   default = nil)
  if valid_38987192 != nil:
    section.add "Accept", valid_38987192
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987193: Call_GetReposOwnerRepoKeys_38987187;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get list of keys.
  ## 
  let valid = call_38987193.validator(path, query, header, formData, body, _)
  let scheme = call_38987193.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987193.url(scheme.get, call_38987193.host, call_38987193.base,
                           call_38987193.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987193, url, valid, _)

proc call*(call_38987194: Call_GetReposOwnerRepoKeys_38987187; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoKeys
  ## Get list of keys.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987195 = newJObject()
  var header_38987196 = newJObject()
  add(path_38987195, "owner", newJString(owner))
  add(header_38987196, "Accept", newJString(Accept))
  add(path_38987195, "repo", newJString(repo))
  result = call_38987194.call(path_38987195, nil, header_38987196, nil, nil)

var getReposOwnerRepoKeys* = Call_GetReposOwnerRepoKeys_38987187(
    name: "getReposOwnerRepoKeys", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/repos/{owner}/{repo}/keys",
    validator: validate_GetReposOwnerRepoKeys_38987188, base: "/",
    url: url_GetReposOwnerRepoKeys_38987189, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoKeysKeyId_38987209 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoKeysKeyId_38987211(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/keys/"),
               (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoKeysKeyId_38987210(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get a key
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   keyId: JInt (required)
  ##        : Id of key.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987212 = path.getOrDefault("owner")
  valid_38987212 = validateParameter(valid_38987212, JString, required = true,
                                   default = nil)
  if valid_38987212 != nil:
    section.add "owner", valid_38987212
  var valid_38987213 = path.getOrDefault("keyId")
  valid_38987213 = validateParameter(valid_38987213, JInt, required = true,
                                   default = nil)
  if valid_38987213 != nil:
    section.add "keyId", valid_38987213
  var valid_38987214 = path.getOrDefault("repo")
  valid_38987214 = validateParameter(valid_38987214, JString, required = true,
                                   default = nil)
  if valid_38987214 != nil:
    section.add "repo", valid_38987214
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987215 = header.getOrDefault("Accept")
  valid_38987215 = validateParameter(valid_38987215, JString, required = false,
                                   default = nil)
  if valid_38987215 != nil:
    section.add "Accept", valid_38987215
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987216: Call_GetReposOwnerRepoKeysKeyId_38987209;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a key
  ## 
  let valid = call_38987216.validator(path, query, header, formData, body, _)
  let scheme = call_38987216.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987216.url(scheme.get, call_38987216.host, call_38987216.base,
                           call_38987216.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987216, url, valid, _)

proc call*(call_38987217: Call_GetReposOwnerRepoKeysKeyId_38987209; owner: string;
          keyId: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoKeysKeyId
  ## Get a key
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   keyId: int (required)
  ##        : Id of key.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987218 = newJObject()
  var header_38987219 = newJObject()
  add(path_38987218, "owner", newJString(owner))
  add(header_38987219, "Accept", newJString(Accept))
  add(path_38987218, "keyId", newJInt(keyId))
  add(path_38987218, "repo", newJString(repo))
  result = call_38987217.call(path_38987218, nil, header_38987219, nil, nil)

var getReposOwnerRepoKeysKeyId* = Call_GetReposOwnerRepoKeysKeyId_38987209(
    name: "getReposOwnerRepoKeysKeyId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/keys/{keyId}",
    validator: validate_GetReposOwnerRepoKeysKeyId_38987210, base: "/",
    url: url_GetReposOwnerRepoKeysKeyId_38987211, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoKeysKeyId_38987220 = ref object of OpenApiRestCall_38985352
proc url_DeleteReposOwnerRepoKeysKeyId_38987222(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/keys/"),
               (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoKeysKeyId_38987221(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a key.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   keyId: JInt (required)
  ##        : Id of key.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987223 = path.getOrDefault("owner")
  valid_38987223 = validateParameter(valid_38987223, JString, required = true,
                                   default = nil)
  if valid_38987223 != nil:
    section.add "owner", valid_38987223
  var valid_38987224 = path.getOrDefault("keyId")
  valid_38987224 = validateParameter(valid_38987224, JInt, required = true,
                                   default = nil)
  if valid_38987224 != nil:
    section.add "keyId", valid_38987224
  var valid_38987225 = path.getOrDefault("repo")
  valid_38987225 = validateParameter(valid_38987225, JString, required = true,
                                   default = nil)
  if valid_38987225 != nil:
    section.add "repo", valid_38987225
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987226 = header.getOrDefault("Accept")
  valid_38987226 = validateParameter(valid_38987226, JString, required = false,
                                   default = nil)
  if valid_38987226 != nil:
    section.add "Accept", valid_38987226
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987227: Call_DeleteReposOwnerRepoKeysKeyId_38987220;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a key.
  ## 
  let valid = call_38987227.validator(path, query, header, formData, body, _)
  let scheme = call_38987227.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987227.url(scheme.get, call_38987227.host, call_38987227.base,
                           call_38987227.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987227, url, valid, _)

proc call*(call_38987228: Call_DeleteReposOwnerRepoKeysKeyId_38987220;
          owner: string; keyId: int; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoKeysKeyId
  ## Delete a key.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   keyId: int (required)
  ##        : Id of key.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987229 = newJObject()
  var header_38987230 = newJObject()
  add(path_38987229, "owner", newJString(owner))
  add(header_38987230, "Accept", newJString(Accept))
  add(path_38987229, "keyId", newJInt(keyId))
  add(path_38987229, "repo", newJString(repo))
  result = call_38987228.call(path_38987229, nil, header_38987230, nil, nil)

var deleteReposOwnerRepoKeysKeyId* = Call_DeleteReposOwnerRepoKeysKeyId_38987220(
    name: "deleteReposOwnerRepoKeysKeyId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/keys/{keyId}",
    validator: validate_DeleteReposOwnerRepoKeysKeyId_38987221, base: "/",
    url: url_DeleteReposOwnerRepoKeysKeyId_38987222, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoLabels_38987241 = ref object of OpenApiRestCall_38985352
proc url_PostReposOwnerRepoLabels_38987243(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoLabels_38987242(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987244 = path.getOrDefault("owner")
  valid_38987244 = validateParameter(valid_38987244, JString, required = true,
                                   default = nil)
  if valid_38987244 != nil:
    section.add "owner", valid_38987244
  var valid_38987245 = path.getOrDefault("repo")
  valid_38987245 = validateParameter(valid_38987245, JString, required = true,
                                   default = nil)
  if valid_38987245 != nil:
    section.add "repo", valid_38987245
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987246 = header.getOrDefault("Accept")
  valid_38987246 = validateParameter(valid_38987246, JString, required = false,
                                   default = nil)
  if valid_38987246 != nil:
    section.add "Accept", valid_38987246
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38987248: Call_PostReposOwnerRepoLabels_38987241;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a label.
  ## 
  let valid = call_38987248.validator(path, query, header, formData, body, _)
  let scheme = call_38987248.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987248.url(scheme.get, call_38987248.host, call_38987248.base,
                           call_38987248.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987248, url, valid, _)

proc call*(call_38987249: Call_PostReposOwnerRepoLabels_38987241; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoLabels
  ## Create a label.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987250 = newJObject()
  var header_38987251 = newJObject()
  var body_38987252 = newJObject()
  add(path_38987250, "owner", newJString(owner))
  add(header_38987251, "Accept", newJString(Accept))
  if body != nil:
    body_38987252 = body
  add(path_38987250, "repo", newJString(repo))
  result = call_38987249.call(path_38987250, nil, header_38987251, nil, body_38987252)

var postReposOwnerRepoLabels* = Call_PostReposOwnerRepoLabels_38987241(
    name: "postReposOwnerRepoLabels", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels",
    validator: validate_PostReposOwnerRepoLabels_38987242, base: "/",
    url: url_PostReposOwnerRepoLabels_38987243, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoLabels_38987231 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoLabels_38987233(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoLabels_38987232(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List all labels for this repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987234 = path.getOrDefault("owner")
  valid_38987234 = validateParameter(valid_38987234, JString, required = true,
                                   default = nil)
  if valid_38987234 != nil:
    section.add "owner", valid_38987234
  var valid_38987235 = path.getOrDefault("repo")
  valid_38987235 = validateParameter(valid_38987235, JString, required = true,
                                   default = nil)
  if valid_38987235 != nil:
    section.add "repo", valid_38987235
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987236 = header.getOrDefault("Accept")
  valid_38987236 = validateParameter(valid_38987236, JString, required = false,
                                   default = nil)
  if valid_38987236 != nil:
    section.add "Accept", valid_38987236
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987237: Call_GetReposOwnerRepoLabels_38987231;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List all labels for this repository.
  ## 
  let valid = call_38987237.validator(path, query, header, formData, body, _)
  let scheme = call_38987237.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987237.url(scheme.get, call_38987237.host, call_38987237.base,
                           call_38987237.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987237, url, valid, _)

proc call*(call_38987238: Call_GetReposOwnerRepoLabels_38987231; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoLabels
  ## List all labels for this repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987239 = newJObject()
  var header_38987240 = newJObject()
  add(path_38987239, "owner", newJString(owner))
  add(header_38987240, "Accept", newJString(Accept))
  add(path_38987239, "repo", newJString(repo))
  result = call_38987238.call(path_38987239, nil, header_38987240, nil, nil)

var getReposOwnerRepoLabels* = Call_GetReposOwnerRepoLabels_38987231(
    name: "getReposOwnerRepoLabels", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels",
    validator: validate_GetReposOwnerRepoLabels_38987232, base: "/",
    url: url_GetReposOwnerRepoLabels_38987233, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoLabelsName_38987253 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoLabelsName_38987255(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoLabelsName_38987254(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get a single label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   name: JString (required)
  ##       : Name of the label.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987256 = path.getOrDefault("owner")
  valid_38987256 = validateParameter(valid_38987256, JString, required = true,
                                   default = nil)
  if valid_38987256 != nil:
    section.add "owner", valid_38987256
  var valid_38987257 = path.getOrDefault("name")
  valid_38987257 = validateParameter(valid_38987257, JString, required = true,
                                   default = nil)
  if valid_38987257 != nil:
    section.add "name", valid_38987257
  var valid_38987258 = path.getOrDefault("repo")
  valid_38987258 = validateParameter(valid_38987258, JString, required = true,
                                   default = nil)
  if valid_38987258 != nil:
    section.add "repo", valid_38987258
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987259 = header.getOrDefault("Accept")
  valid_38987259 = validateParameter(valid_38987259, JString, required = false,
                                   default = nil)
  if valid_38987259 != nil:
    section.add "Accept", valid_38987259
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987260: Call_GetReposOwnerRepoLabelsName_38987253;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single label.
  ## 
  let valid = call_38987260.validator(path, query, header, formData, body, _)
  let scheme = call_38987260.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987260.url(scheme.get, call_38987260.host, call_38987260.base,
                           call_38987260.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987260, url, valid, _)

proc call*(call_38987261: Call_GetReposOwnerRepoLabelsName_38987253; owner: string;
          name: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoLabelsName
  ## Get a single label.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   name: string (required)
  ##       : Name of the label.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987262 = newJObject()
  var header_38987263 = newJObject()
  add(path_38987262, "owner", newJString(owner))
  add(path_38987262, "name", newJString(name))
  add(header_38987263, "Accept", newJString(Accept))
  add(path_38987262, "repo", newJString(repo))
  result = call_38987261.call(path_38987262, nil, header_38987263, nil, nil)

var getReposOwnerRepoLabelsName* = Call_GetReposOwnerRepoLabelsName_38987253(
    name: "getReposOwnerRepoLabelsName", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels/{name}",
    validator: validate_GetReposOwnerRepoLabelsName_38987254, base: "/",
    url: url_GetReposOwnerRepoLabelsName_38987255, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoLabelsName_38987275 = ref object of OpenApiRestCall_38985352
proc url_PatchReposOwnerRepoLabelsName_38987277(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoLabelsName_38987276(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Update a label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   name: JString (required)
  ##       : Name of the label.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987278 = path.getOrDefault("owner")
  valid_38987278 = validateParameter(valid_38987278, JString, required = true,
                                   default = nil)
  if valid_38987278 != nil:
    section.add "owner", valid_38987278
  var valid_38987279 = path.getOrDefault("name")
  valid_38987279 = validateParameter(valid_38987279, JString, required = true,
                                   default = nil)
  if valid_38987279 != nil:
    section.add "name", valid_38987279
  var valid_38987280 = path.getOrDefault("repo")
  valid_38987280 = validateParameter(valid_38987280, JString, required = true,
                                   default = nil)
  if valid_38987280 != nil:
    section.add "repo", valid_38987280
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987281 = header.getOrDefault("Accept")
  valid_38987281 = validateParameter(valid_38987281, JString, required = false,
                                   default = nil)
  if valid_38987281 != nil:
    section.add "Accept", valid_38987281
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38987283: Call_PatchReposOwnerRepoLabelsName_38987275;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Update a label.
  ## 
  let valid = call_38987283.validator(path, query, header, formData, body, _)
  let scheme = call_38987283.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987283.url(scheme.get, call_38987283.host, call_38987283.base,
                           call_38987283.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987283, url, valid, _)

proc call*(call_38987284: Call_PatchReposOwnerRepoLabelsName_38987275;
          owner: string; name: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoLabelsName
  ## Update a label.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   name: string (required)
  ##       : Name of the label.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987285 = newJObject()
  var header_38987286 = newJObject()
  var body_38987287 = newJObject()
  add(path_38987285, "owner", newJString(owner))
  add(path_38987285, "name", newJString(name))
  add(header_38987286, "Accept", newJString(Accept))
  if body != nil:
    body_38987287 = body
  add(path_38987285, "repo", newJString(repo))
  result = call_38987284.call(path_38987285, nil, header_38987286, nil, body_38987287)

var patchReposOwnerRepoLabelsName* = Call_PatchReposOwnerRepoLabelsName_38987275(
    name: "patchReposOwnerRepoLabelsName", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels/{name}",
    validator: validate_PatchReposOwnerRepoLabelsName_38987276, base: "/",
    url: url_PatchReposOwnerRepoLabelsName_38987277, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoLabelsName_38987264 = ref object of OpenApiRestCall_38985352
proc url_DeleteReposOwnerRepoLabelsName_38987266(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoLabelsName_38987265(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   name: JString (required)
  ##       : Name of the label.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987267 = path.getOrDefault("owner")
  valid_38987267 = validateParameter(valid_38987267, JString, required = true,
                                   default = nil)
  if valid_38987267 != nil:
    section.add "owner", valid_38987267
  var valid_38987268 = path.getOrDefault("name")
  valid_38987268 = validateParameter(valid_38987268, JString, required = true,
                                   default = nil)
  if valid_38987268 != nil:
    section.add "name", valid_38987268
  var valid_38987269 = path.getOrDefault("repo")
  valid_38987269 = validateParameter(valid_38987269, JString, required = true,
                                   default = nil)
  if valid_38987269 != nil:
    section.add "repo", valid_38987269
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987270 = header.getOrDefault("Accept")
  valid_38987270 = validateParameter(valid_38987270, JString, required = false,
                                   default = nil)
  if valid_38987270 != nil:
    section.add "Accept", valid_38987270
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987271: Call_DeleteReposOwnerRepoLabelsName_38987264;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a label.
  ## 
  let valid = call_38987271.validator(path, query, header, formData, body, _)
  let scheme = call_38987271.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987271.url(scheme.get, call_38987271.host, call_38987271.base,
                           call_38987271.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987271, url, valid, _)

proc call*(call_38987272: Call_DeleteReposOwnerRepoLabelsName_38987264;
          owner: string; name: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoLabelsName
  ## Delete a label.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   name: string (required)
  ##       : Name of the label.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987273 = newJObject()
  var header_38987274 = newJObject()
  add(path_38987273, "owner", newJString(owner))
  add(path_38987273, "name", newJString(name))
  add(header_38987274, "Accept", newJString(Accept))
  add(path_38987273, "repo", newJString(repo))
  result = call_38987272.call(path_38987273, nil, header_38987274, nil, nil)

var deleteReposOwnerRepoLabelsName* = Call_DeleteReposOwnerRepoLabelsName_38987264(
    name: "deleteReposOwnerRepoLabelsName", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels/{name}",
    validator: validate_DeleteReposOwnerRepoLabelsName_38987265, base: "/",
    url: url_DeleteReposOwnerRepoLabelsName_38987266, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoLanguages_38987288 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoLanguages_38987290(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/languages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoLanguages_38987289(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List languages.
  ## List languages for the specified repository. The value on the right of a
  ## language is the number of bytes of code written in that language.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987291 = path.getOrDefault("owner")
  valid_38987291 = validateParameter(valid_38987291, JString, required = true,
                                   default = nil)
  if valid_38987291 != nil:
    section.add "owner", valid_38987291
  var valid_38987292 = path.getOrDefault("repo")
  valid_38987292 = validateParameter(valid_38987292, JString, required = true,
                                   default = nil)
  if valid_38987292 != nil:
    section.add "repo", valid_38987292
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987293 = header.getOrDefault("Accept")
  valid_38987293 = validateParameter(valid_38987293, JString, required = false,
                                   default = nil)
  if valid_38987293 != nil:
    section.add "Accept", valid_38987293
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987294: Call_GetReposOwnerRepoLanguages_38987288;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List languages.
  ## List languages for the specified repository. The value on the right of a
  ## language is the number of bytes of code written in that language.
  ## 
  ## 
  let valid = call_38987294.validator(path, query, header, formData, body, _)
  let scheme = call_38987294.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987294.url(scheme.get, call_38987294.host, call_38987294.base,
                           call_38987294.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987294, url, valid, _)

proc call*(call_38987295: Call_GetReposOwnerRepoLanguages_38987288; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoLanguages
  ## List languages.
  ## List languages for the specified repository. The value on the right of a
  ## language is the number of bytes of code written in that language.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987296 = newJObject()
  var header_38987297 = newJObject()
  add(path_38987296, "owner", newJString(owner))
  add(header_38987297, "Accept", newJString(Accept))
  add(path_38987296, "repo", newJString(repo))
  result = call_38987295.call(path_38987296, nil, header_38987297, nil, nil)

var getReposOwnerRepoLanguages* = Call_GetReposOwnerRepoLanguages_38987288(
    name: "getReposOwnerRepoLanguages", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/languages",
    validator: validate_GetReposOwnerRepoLanguages_38987289, base: "/",
    url: url_GetReposOwnerRepoLanguages_38987290, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoMerges_38987298 = ref object of OpenApiRestCall_38985352
proc url_PostReposOwnerRepoMerges_38987300(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/merges")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoMerges_38987299(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Perform a merge.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987301 = path.getOrDefault("owner")
  valid_38987301 = validateParameter(valid_38987301, JString, required = true,
                                   default = nil)
  if valid_38987301 != nil:
    section.add "owner", valid_38987301
  var valid_38987302 = path.getOrDefault("repo")
  valid_38987302 = validateParameter(valid_38987302, JString, required = true,
                                   default = nil)
  if valid_38987302 != nil:
    section.add "repo", valid_38987302
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987303 = header.getOrDefault("Accept")
  valid_38987303 = validateParameter(valid_38987303, JString, required = false,
                                   default = nil)
  if valid_38987303 != nil:
    section.add "Accept", valid_38987303
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38987305: Call_PostReposOwnerRepoMerges_38987298;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Perform a merge.
  ## 
  let valid = call_38987305.validator(path, query, header, formData, body, _)
  let scheme = call_38987305.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987305.url(scheme.get, call_38987305.host, call_38987305.base,
                           call_38987305.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987305, url, valid, _)

proc call*(call_38987306: Call_PostReposOwnerRepoMerges_38987298; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoMerges
  ## Perform a merge.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987307 = newJObject()
  var header_38987308 = newJObject()
  var body_38987309 = newJObject()
  add(path_38987307, "owner", newJString(owner))
  add(header_38987308, "Accept", newJString(Accept))
  if body != nil:
    body_38987309 = body
  add(path_38987307, "repo", newJString(repo))
  result = call_38987306.call(path_38987307, nil, header_38987308, nil, body_38987309)

var postReposOwnerRepoMerges* = Call_PostReposOwnerRepoMerges_38987298(
    name: "postReposOwnerRepoMerges", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/merges",
    validator: validate_PostReposOwnerRepoMerges_38987299, base: "/",
    url: url_PostReposOwnerRepoMerges_38987300, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoMilestones_38987324 = ref object of OpenApiRestCall_38985352
proc url_PostReposOwnerRepoMilestones_38987326(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoMilestones_38987325(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Create a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987327 = path.getOrDefault("owner")
  valid_38987327 = validateParameter(valid_38987327, JString, required = true,
                                   default = nil)
  if valid_38987327 != nil:
    section.add "owner", valid_38987327
  var valid_38987328 = path.getOrDefault("repo")
  valid_38987328 = validateParameter(valid_38987328, JString, required = true,
                                   default = nil)
  if valid_38987328 != nil:
    section.add "repo", valid_38987328
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987329 = header.getOrDefault("Accept")
  valid_38987329 = validateParameter(valid_38987329, JString, required = false,
                                   default = nil)
  if valid_38987329 != nil:
    section.add "Accept", valid_38987329
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38987331: Call_PostReposOwnerRepoMilestones_38987324;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a milestone.
  ## 
  let valid = call_38987331.validator(path, query, header, formData, body, _)
  let scheme = call_38987331.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987331.url(scheme.get, call_38987331.host, call_38987331.base,
                           call_38987331.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987331, url, valid, _)

proc call*(call_38987332: Call_PostReposOwnerRepoMilestones_38987324;
          owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoMilestones
  ## Create a milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987333 = newJObject()
  var header_38987334 = newJObject()
  var body_38987335 = newJObject()
  add(path_38987333, "owner", newJString(owner))
  add(header_38987334, "Accept", newJString(Accept))
  if body != nil:
    body_38987335 = body
  add(path_38987333, "repo", newJString(repo))
  result = call_38987332.call(path_38987333, nil, header_38987334, nil, body_38987335)

var postReposOwnerRepoMilestones* = Call_PostReposOwnerRepoMilestones_38987324(
    name: "postReposOwnerRepoMilestones", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones",
    validator: validate_PostReposOwnerRepoMilestones_38987325, base: "/",
    url: url_PostReposOwnerRepoMilestones_38987326, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoMilestones_38987310 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoMilestones_38987312(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoMilestones_38987311(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List milestones for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987313 = path.getOrDefault("owner")
  valid_38987313 = validateParameter(valid_38987313, JString, required = true,
                                   default = nil)
  if valid_38987313 != nil:
    section.add "owner", valid_38987313
  var valid_38987314 = path.getOrDefault("repo")
  valid_38987314 = validateParameter(valid_38987314, JString, required = true,
                                   default = nil)
  if valid_38987314 != nil:
    section.add "repo", valid_38987314
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString
  ##        : String to filter by state.
  ##   sort: JString
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  section = newJObject()
  var valid_38987315 = query.getOrDefault("state")
  valid_38987315 = validateParameter(valid_38987315, JString, required = false,
                                   default = newJString("open"))
  if valid_38987315 != nil:
    section.add "state", valid_38987315
  var valid_38987316 = query.getOrDefault("sort")
  valid_38987316 = validateParameter(valid_38987316, JString, required = false,
                                   default = newJString("due_date"))
  if valid_38987316 != nil:
    section.add "sort", valid_38987316
  var valid_38987317 = query.getOrDefault("direction")
  valid_38987317 = validateParameter(valid_38987317, JString, required = false,
                                   default = nil)
  if valid_38987317 != nil:
    section.add "direction", valid_38987317
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987318 = header.getOrDefault("Accept")
  valid_38987318 = validateParameter(valid_38987318, JString, required = false,
                                   default = nil)
  if valid_38987318 != nil:
    section.add "Accept", valid_38987318
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987319: Call_GetReposOwnerRepoMilestones_38987310;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List milestones for a repository.
  ## 
  let valid = call_38987319.validator(path, query, header, formData, body, _)
  let scheme = call_38987319.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987319.url(scheme.get, call_38987319.host, call_38987319.base,
                           call_38987319.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987319, url, valid, _)

proc call*(call_38987320: Call_GetReposOwnerRepoMilestones_38987310; owner: string;
          repo: string; state: string = "open"; Accept: string = "";
          sort: string = "due_date"; direction: string = ""): Recallable =
  ## getReposOwnerRepoMilestones
  ## List milestones for a repository.
  ##   state: string
  ##        : String to filter by state.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   sort: string
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  var path_38987321 = newJObject()
  var query_38987322 = newJObject()
  var header_38987323 = newJObject()
  add(query_38987322, "state", newJString(state))
  add(path_38987321, "owner", newJString(owner))
  add(header_38987323, "Accept", newJString(Accept))
  add(path_38987321, "repo", newJString(repo))
  add(query_38987322, "sort", newJString(sort))
  add(query_38987322, "direction", newJString(direction))
  result = call_38987320.call(path_38987321, query_38987322, header_38987323, nil, nil)

var getReposOwnerRepoMilestones* = Call_GetReposOwnerRepoMilestones_38987310(
    name: "getReposOwnerRepoMilestones", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones",
    validator: validate_GetReposOwnerRepoMilestones_38987311, base: "/",
    url: url_GetReposOwnerRepoMilestones_38987312, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoMilestonesNumber_38987336 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoMilestonesNumber_38987338(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoMilestonesNumber_38987337(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a single milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987339 = path.getOrDefault("owner")
  valid_38987339 = validateParameter(valid_38987339, JString, required = true,
                                   default = nil)
  if valid_38987339 != nil:
    section.add "owner", valid_38987339
  var valid_38987340 = path.getOrDefault("number")
  valid_38987340 = validateParameter(valid_38987340, JInt, required = true,
                                   default = nil)
  if valid_38987340 != nil:
    section.add "number", valid_38987340
  var valid_38987341 = path.getOrDefault("repo")
  valid_38987341 = validateParameter(valid_38987341, JString, required = true,
                                   default = nil)
  if valid_38987341 != nil:
    section.add "repo", valid_38987341
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987342 = header.getOrDefault("Accept")
  valid_38987342 = validateParameter(valid_38987342, JString, required = false,
                                   default = nil)
  if valid_38987342 != nil:
    section.add "Accept", valid_38987342
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987343: Call_GetReposOwnerRepoMilestonesNumber_38987336;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single milestone.
  ## 
  let valid = call_38987343.validator(path, query, header, formData, body, _)
  let scheme = call_38987343.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987343.url(scheme.get, call_38987343.host, call_38987343.base,
                           call_38987343.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987343, url, valid, _)

proc call*(call_38987344: Call_GetReposOwnerRepoMilestonesNumber_38987336;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoMilestonesNumber
  ## Get a single milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987345 = newJObject()
  var header_38987346 = newJObject()
  add(path_38987345, "owner", newJString(owner))
  add(path_38987345, "number", newJInt(number))
  add(header_38987346, "Accept", newJString(Accept))
  add(path_38987345, "repo", newJString(repo))
  result = call_38987344.call(path_38987345, nil, header_38987346, nil, nil)

var getReposOwnerRepoMilestonesNumber* = Call_GetReposOwnerRepoMilestonesNumber_38987336(
    name: "getReposOwnerRepoMilestonesNumber", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones/{number}",
    validator: validate_GetReposOwnerRepoMilestonesNumber_38987337, base: "/",
    url: url_GetReposOwnerRepoMilestonesNumber_38987338, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoMilestonesNumber_38987358 = ref object of OpenApiRestCall_38985352
proc url_PatchReposOwnerRepoMilestonesNumber_38987360(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoMilestonesNumber_38987359(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Update a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987361 = path.getOrDefault("owner")
  valid_38987361 = validateParameter(valid_38987361, JString, required = true,
                                   default = nil)
  if valid_38987361 != nil:
    section.add "owner", valid_38987361
  var valid_38987362 = path.getOrDefault("number")
  valid_38987362 = validateParameter(valid_38987362, JInt, required = true,
                                   default = nil)
  if valid_38987362 != nil:
    section.add "number", valid_38987362
  var valid_38987363 = path.getOrDefault("repo")
  valid_38987363 = validateParameter(valid_38987363, JString, required = true,
                                   default = nil)
  if valid_38987363 != nil:
    section.add "repo", valid_38987363
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987364 = header.getOrDefault("Accept")
  valid_38987364 = validateParameter(valid_38987364, JString, required = false,
                                   default = nil)
  if valid_38987364 != nil:
    section.add "Accept", valid_38987364
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38987366: Call_PatchReposOwnerRepoMilestonesNumber_38987358;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Update a milestone.
  ## 
  let valid = call_38987366.validator(path, query, header, formData, body, _)
  let scheme = call_38987366.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987366.url(scheme.get, call_38987366.host, call_38987366.base,
                           call_38987366.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987366, url, valid, _)

proc call*(call_38987367: Call_PatchReposOwnerRepoMilestonesNumber_38987358;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoMilestonesNumber
  ## Update a milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987368 = newJObject()
  var header_38987369 = newJObject()
  var body_38987370 = newJObject()
  add(path_38987368, "owner", newJString(owner))
  add(path_38987368, "number", newJInt(number))
  add(header_38987369, "Accept", newJString(Accept))
  if body != nil:
    body_38987370 = body
  add(path_38987368, "repo", newJString(repo))
  result = call_38987367.call(path_38987368, nil, header_38987369, nil, body_38987370)

var patchReposOwnerRepoMilestonesNumber* = Call_PatchReposOwnerRepoMilestonesNumber_38987358(
    name: "patchReposOwnerRepoMilestonesNumber", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones/{number}",
    validator: validate_PatchReposOwnerRepoMilestonesNumber_38987359, base: "/",
    url: url_PatchReposOwnerRepoMilestonesNumber_38987360, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoMilestonesNumber_38987347 = ref object of OpenApiRestCall_38985352
proc url_DeleteReposOwnerRepoMilestonesNumber_38987349(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoMilestonesNumber_38987348(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987350 = path.getOrDefault("owner")
  valid_38987350 = validateParameter(valid_38987350, JString, required = true,
                                   default = nil)
  if valid_38987350 != nil:
    section.add "owner", valid_38987350
  var valid_38987351 = path.getOrDefault("number")
  valid_38987351 = validateParameter(valid_38987351, JInt, required = true,
                                   default = nil)
  if valid_38987351 != nil:
    section.add "number", valid_38987351
  var valid_38987352 = path.getOrDefault("repo")
  valid_38987352 = validateParameter(valid_38987352, JString, required = true,
                                   default = nil)
  if valid_38987352 != nil:
    section.add "repo", valid_38987352
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987353 = header.getOrDefault("Accept")
  valid_38987353 = validateParameter(valid_38987353, JString, required = false,
                                   default = nil)
  if valid_38987353 != nil:
    section.add "Accept", valid_38987353
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987354: Call_DeleteReposOwnerRepoMilestonesNumber_38987347;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a milestone.
  ## 
  let valid = call_38987354.validator(path, query, header, formData, body, _)
  let scheme = call_38987354.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987354.url(scheme.get, call_38987354.host, call_38987354.base,
                           call_38987354.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987354, url, valid, _)

proc call*(call_38987355: Call_DeleteReposOwnerRepoMilestonesNumber_38987347;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoMilestonesNumber
  ## Delete a milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987356 = newJObject()
  var header_38987357 = newJObject()
  add(path_38987356, "owner", newJString(owner))
  add(path_38987356, "number", newJInt(number))
  add(header_38987357, "Accept", newJString(Accept))
  add(path_38987356, "repo", newJString(repo))
  result = call_38987355.call(path_38987356, nil, header_38987357, nil, nil)

var deleteReposOwnerRepoMilestonesNumber* = Call_DeleteReposOwnerRepoMilestonesNumber_38987347(
    name: "deleteReposOwnerRepoMilestonesNumber", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones/{number}",
    validator: validate_DeleteReposOwnerRepoMilestonesNumber_38987348, base: "/",
    url: url_DeleteReposOwnerRepoMilestonesNumber_38987349,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoMilestonesNumberLabels_38987371 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoMilestonesNumberLabels_38987373(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoMilestonesNumberLabels_38987372(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get labels for every issue in a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987374 = path.getOrDefault("owner")
  valid_38987374 = validateParameter(valid_38987374, JString, required = true,
                                   default = nil)
  if valid_38987374 != nil:
    section.add "owner", valid_38987374
  var valid_38987375 = path.getOrDefault("number")
  valid_38987375 = validateParameter(valid_38987375, JInt, required = true,
                                   default = nil)
  if valid_38987375 != nil:
    section.add "number", valid_38987375
  var valid_38987376 = path.getOrDefault("repo")
  valid_38987376 = validateParameter(valid_38987376, JString, required = true,
                                   default = nil)
  if valid_38987376 != nil:
    section.add "repo", valid_38987376
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987377 = header.getOrDefault("Accept")
  valid_38987377 = validateParameter(valid_38987377, JString, required = false,
                                   default = nil)
  if valid_38987377 != nil:
    section.add "Accept", valid_38987377
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987378: Call_GetReposOwnerRepoMilestonesNumberLabels_38987371;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get labels for every issue in a milestone.
  ## 
  let valid = call_38987378.validator(path, query, header, formData, body, _)
  let scheme = call_38987378.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987378.url(scheme.get, call_38987378.host, call_38987378.base,
                           call_38987378.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987378, url, valid, _)

proc call*(call_38987379: Call_GetReposOwnerRepoMilestonesNumberLabels_38987371;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoMilestonesNumberLabels
  ## Get labels for every issue in a milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987380 = newJObject()
  var header_38987381 = newJObject()
  add(path_38987380, "owner", newJString(owner))
  add(path_38987380, "number", newJInt(number))
  add(header_38987381, "Accept", newJString(Accept))
  add(path_38987380, "repo", newJString(repo))
  result = call_38987379.call(path_38987380, nil, header_38987381, nil, nil)

var getReposOwnerRepoMilestonesNumberLabels* = Call_GetReposOwnerRepoMilestonesNumberLabels_38987371(
    name: "getReposOwnerRepoMilestonesNumberLabels", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/milestones/{number}/labels",
    validator: validate_GetReposOwnerRepoMilestonesNumberLabels_38987372,
    base: "/", url: url_GetReposOwnerRepoMilestonesNumberLabels_38987373,
    schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoNotifications_38987396 = ref object of OpenApiRestCall_38985352
proc url_PutReposOwnerRepoNotifications_38987398(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/notifications")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoNotifications_38987397(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Mark notifications as read in a repository.
  ## Marking all notifications in a repository as "read" removes them from the
  ## default view on GitHub.com.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987399 = path.getOrDefault("owner")
  valid_38987399 = validateParameter(valid_38987399, JString, required = true,
                                   default = nil)
  if valid_38987399 != nil:
    section.add "owner", valid_38987399
  var valid_38987400 = path.getOrDefault("repo")
  valid_38987400 = validateParameter(valid_38987400, JString, required = true,
                                   default = nil)
  if valid_38987400 != nil:
    section.add "repo", valid_38987400
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987401 = header.getOrDefault("Accept")
  valid_38987401 = validateParameter(valid_38987401, JString, required = false,
                                   default = nil)
  if valid_38987401 != nil:
    section.add "Accept", valid_38987401
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38987403: Call_PutReposOwnerRepoNotifications_38987396;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Mark notifications as read in a repository.
  ## Marking all notifications in a repository as "read" removes them from the
  ## default view on GitHub.com.
  ## 
  ## 
  let valid = call_38987403.validator(path, query, header, formData, body, _)
  let scheme = call_38987403.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987403.url(scheme.get, call_38987403.host, call_38987403.base,
                           call_38987403.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987403, url, valid, _)

proc call*(call_38987404: Call_PutReposOwnerRepoNotifications_38987396;
          owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoNotifications
  ## Mark notifications as read in a repository.
  ## Marking all notifications in a repository as "read" removes them from the
  ## default view on GitHub.com.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987405 = newJObject()
  var header_38987406 = newJObject()
  var body_38987407 = newJObject()
  add(path_38987405, "owner", newJString(owner))
  add(header_38987406, "Accept", newJString(Accept))
  if body != nil:
    body_38987407 = body
  add(path_38987405, "repo", newJString(repo))
  result = call_38987404.call(path_38987405, nil, header_38987406, nil, body_38987407)

var putReposOwnerRepoNotifications* = Call_PutReposOwnerRepoNotifications_38987396(
    name: "putReposOwnerRepoNotifications", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/notifications",
    validator: validate_PutReposOwnerRepoNotifications_38987397, base: "/",
    url: url_PutReposOwnerRepoNotifications_38987398, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoNotifications_38987382 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoNotifications_38987384(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/notifications")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoNotifications_38987383(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List your notifications in a repository
  ## List all notifications for the current user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987385 = path.getOrDefault("owner")
  valid_38987385 = validateParameter(valid_38987385, JString, required = true,
                                   default = nil)
  if valid_38987385 != nil:
    section.add "owner", valid_38987385
  var valid_38987386 = path.getOrDefault("repo")
  valid_38987386 = validateParameter(valid_38987386, JString, required = true,
                                   default = nil)
  if valid_38987386 != nil:
    section.add "repo", valid_38987386
  result.add "path", section
  ## parameters in `query` object:
  ##   participating: JBool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  ##   all: JBool
  ##      : True to show notifications marked as read.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_38987387 = query.getOrDefault("participating")
  valid_38987387 = validateParameter(valid_38987387, JBool, required = false,
                                   default = nil)
  if valid_38987387 != nil:
    section.add "participating", valid_38987387
  var valid_38987388 = query.getOrDefault("all")
  valid_38987388 = validateParameter(valid_38987388, JBool, required = false,
                                   default = nil)
  if valid_38987388 != nil:
    section.add "all", valid_38987388
  var valid_38987389 = query.getOrDefault("since")
  valid_38987389 = validateParameter(valid_38987389, JString, required = false,
                                   default = nil)
  if valid_38987389 != nil:
    section.add "since", valid_38987389
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987390 = header.getOrDefault("Accept")
  valid_38987390 = validateParameter(valid_38987390, JString, required = false,
                                   default = nil)
  if valid_38987390 != nil:
    section.add "Accept", valid_38987390
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987391: Call_GetReposOwnerRepoNotifications_38987382;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List your notifications in a repository
  ## List all notifications for the current user.
  ## 
  ## 
  let valid = call_38987391.validator(path, query, header, formData, body, _)
  let scheme = call_38987391.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987391.url(scheme.get, call_38987391.host, call_38987391.base,
                           call_38987391.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987391, url, valid, _)

proc call*(call_38987392: Call_GetReposOwnerRepoNotifications_38987382;
          owner: string; repo: string; participating: bool = false; all: bool = false;
          Accept: string = ""; since: string = ""): Recallable =
  ## getReposOwnerRepoNotifications
  ## List your notifications in a repository
  ## List all notifications for the current user.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   participating: bool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  ##   all: bool
  ##      : True to show notifications marked as read.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var path_38987393 = newJObject()
  var query_38987394 = newJObject()
  var header_38987395 = newJObject()
  add(path_38987393, "owner", newJString(owner))
  add(query_38987394, "participating", newJBool(participating))
  add(query_38987394, "all", newJBool(all))
  add(header_38987395, "Accept", newJString(Accept))
  add(path_38987393, "repo", newJString(repo))
  add(query_38987394, "since", newJString(since))
  result = call_38987392.call(path_38987393, query_38987394, header_38987395, nil, nil)

var getReposOwnerRepoNotifications* = Call_GetReposOwnerRepoNotifications_38987382(
    name: "getReposOwnerRepoNotifications", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/notifications",
    validator: validate_GetReposOwnerRepoNotifications_38987383, base: "/",
    url: url_GetReposOwnerRepoNotifications_38987384, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoPulls_38987422 = ref object of OpenApiRestCall_38985352
proc url_PostReposOwnerRepoPulls_38987424(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoPulls_38987423(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987425 = path.getOrDefault("owner")
  valid_38987425 = validateParameter(valid_38987425, JString, required = true,
                                   default = nil)
  if valid_38987425 != nil:
    section.add "owner", valid_38987425
  var valid_38987426 = path.getOrDefault("repo")
  valid_38987426 = validateParameter(valid_38987426, JString, required = true,
                                   default = nil)
  if valid_38987426 != nil:
    section.add "repo", valid_38987426
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987427 = header.getOrDefault("Accept")
  valid_38987427 = validateParameter(valid_38987427, JString, required = false,
                                   default = nil)
  if valid_38987427 != nil:
    section.add "Accept", valid_38987427
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38987429: Call_PostReposOwnerRepoPulls_38987422;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a pull request.
  ## 
  let valid = call_38987429.validator(path, query, header, formData, body, _)
  let scheme = call_38987429.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987429.url(scheme.get, call_38987429.host, call_38987429.base,
                           call_38987429.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987429, url, valid, _)

proc call*(call_38987430: Call_PostReposOwnerRepoPulls_38987422; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoPulls
  ## Create a pull request.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987431 = newJObject()
  var header_38987432 = newJObject()
  var body_38987433 = newJObject()
  add(path_38987431, "owner", newJString(owner))
  add(header_38987432, "Accept", newJString(Accept))
  if body != nil:
    body_38987433 = body
  add(path_38987431, "repo", newJString(repo))
  result = call_38987430.call(path_38987431, nil, header_38987432, nil, body_38987433)

var postReposOwnerRepoPulls* = Call_PostReposOwnerRepoPulls_38987422(
    name: "postReposOwnerRepoPulls", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls",
    validator: validate_PostReposOwnerRepoPulls_38987423, base: "/",
    url: url_PostReposOwnerRepoPulls_38987424, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPulls_38987408 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoPulls_38987410(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPulls_38987409(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List pull requests.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987411 = path.getOrDefault("owner")
  valid_38987411 = validateParameter(valid_38987411, JString, required = true,
                                   default = nil)
  if valid_38987411 != nil:
    section.add "owner", valid_38987411
  var valid_38987412 = path.getOrDefault("repo")
  valid_38987412 = validateParameter(valid_38987412, JString, required = true,
                                   default = nil)
  if valid_38987412 != nil:
    section.add "repo", valid_38987412
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString
  ##        : String to filter by state.
  ##   head: JString
  ##       : Filter pulls by head user and branch name in the format of 'user:ref-name'.
  ## Example: github:new-script-format.
  ## 
  ##   base: JString
  ##       : Filter pulls by base branch name. Example - gh-pages.
  section = newJObject()
  var valid_38987413 = query.getOrDefault("state")
  valid_38987413 = validateParameter(valid_38987413, JString, required = false,
                                   default = newJString("open"))
  if valid_38987413 != nil:
    section.add "state", valid_38987413
  var valid_38987414 = query.getOrDefault("head")
  valid_38987414 = validateParameter(valid_38987414, JString, required = false,
                                   default = nil)
  if valid_38987414 != nil:
    section.add "head", valid_38987414
  var valid_38987415 = query.getOrDefault("base")
  valid_38987415 = validateParameter(valid_38987415, JString, required = false,
                                   default = nil)
  if valid_38987415 != nil:
    section.add "base", valid_38987415
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987416 = header.getOrDefault("Accept")
  valid_38987416 = validateParameter(valid_38987416, JString, required = false,
                                   default = nil)
  if valid_38987416 != nil:
    section.add "Accept", valid_38987416
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987417: Call_GetReposOwnerRepoPulls_38987408;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List pull requests.
  ## 
  let valid = call_38987417.validator(path, query, header, formData, body, _)
  let scheme = call_38987417.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987417.url(scheme.get, call_38987417.host, call_38987417.base,
                           call_38987417.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987417, url, valid, _)

proc call*(call_38987418: Call_GetReposOwnerRepoPulls_38987408; owner: string;
          repo: string; state: string = "open"; head: string = ""; base: string = "";
          Accept: string = ""): Recallable =
  ## getReposOwnerRepoPulls
  ## List pull requests.
  ##   state: string
  ##        : String to filter by state.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   head: string
  ##       : Filter pulls by head user and branch name in the format of 'user:ref-name'.
  ## Example: github:new-script-format.
  ## 
  ##   base: string
  ##       : Filter pulls by base branch name. Example - gh-pages.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987419 = newJObject()
  var query_38987420 = newJObject()
  var header_38987421 = newJObject()
  add(query_38987420, "state", newJString(state))
  add(path_38987419, "owner", newJString(owner))
  add(query_38987420, "head", newJString(head))
  add(query_38987420, "base", newJString(base))
  add(header_38987421, "Accept", newJString(Accept))
  add(path_38987419, "repo", newJString(repo))
  result = call_38987418.call(path_38987419, query_38987420, header_38987421, nil, nil)

var getReposOwnerRepoPulls* = Call_GetReposOwnerRepoPulls_38987408(
    name: "getReposOwnerRepoPulls", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls",
    validator: validate_GetReposOwnerRepoPulls_38987409, base: "/",
    url: url_GetReposOwnerRepoPulls_38987410, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsComments_38987434 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoPullsComments_38987436(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsComments_38987435(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List comments in a repository.
  ## By default, Review Comments are ordered by ascending ID.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987437 = path.getOrDefault("owner")
  valid_38987437 = validateParameter(valid_38987437, JString, required = true,
                                   default = nil)
  if valid_38987437 != nil:
    section.add "owner", valid_38987437
  var valid_38987438 = path.getOrDefault("repo")
  valid_38987438 = validateParameter(valid_38987438, JString, required = true,
                                   default = nil)
  if valid_38987438 != nil:
    section.add "repo", valid_38987438
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_38987439 = query.getOrDefault("sort")
  valid_38987439 = validateParameter(valid_38987439, JString, required = false,
                                   default = newJString("created"))
  if valid_38987439 != nil:
    section.add "sort", valid_38987439
  var valid_38987440 = query.getOrDefault("direction")
  valid_38987440 = validateParameter(valid_38987440, JString, required = false,
                                   default = nil)
  if valid_38987440 != nil:
    section.add "direction", valid_38987440
  var valid_38987441 = query.getOrDefault("since")
  valid_38987441 = validateParameter(valid_38987441, JString, required = false,
                                   default = nil)
  if valid_38987441 != nil:
    section.add "since", valid_38987441
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987442 = header.getOrDefault("Accept")
  valid_38987442 = validateParameter(valid_38987442, JString, required = false,
                                   default = nil)
  if valid_38987442 != nil:
    section.add "Accept", valid_38987442
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987443: Call_GetReposOwnerRepoPullsComments_38987434;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List comments in a repository.
  ## By default, Review Comments are ordered by ascending ID.
  ## 
  ## 
  let valid = call_38987443.validator(path, query, header, formData, body, _)
  let scheme = call_38987443.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987443.url(scheme.get, call_38987443.host, call_38987443.base,
                           call_38987443.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987443, url, valid, _)

proc call*(call_38987444: Call_GetReposOwnerRepoPullsComments_38987434;
          owner: string; repo: string; Accept: string = ""; sort: string = "created";
          direction: string = ""; since: string = ""): Recallable =
  ## getReposOwnerRepoPullsComments
  ## List comments in a repository.
  ## By default, Review Comments are ordered by ascending ID.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   sort: string
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var path_38987445 = newJObject()
  var query_38987446 = newJObject()
  var header_38987447 = newJObject()
  add(path_38987445, "owner", newJString(owner))
  add(header_38987447, "Accept", newJString(Accept))
  add(path_38987445, "repo", newJString(repo))
  add(query_38987446, "sort", newJString(sort))
  add(query_38987446, "direction", newJString(direction))
  add(query_38987446, "since", newJString(since))
  result = call_38987444.call(path_38987445, query_38987446, header_38987447, nil, nil)

var getReposOwnerRepoPullsComments* = Call_GetReposOwnerRepoPullsComments_38987434(
    name: "getReposOwnerRepoPullsComments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/comments",
    validator: validate_GetReposOwnerRepoPullsComments_38987435, base: "/",
    url: url_GetReposOwnerRepoPullsComments_38987436, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsCommentsCommentId_38987448 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoPullsCommentsCommentId_38987450(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsCommentsCommentId_38987449(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a single comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987451 = path.getOrDefault("owner")
  valid_38987451 = validateParameter(valid_38987451, JString, required = true,
                                   default = nil)
  if valid_38987451 != nil:
    section.add "owner", valid_38987451
  var valid_38987452 = path.getOrDefault("repo")
  valid_38987452 = validateParameter(valid_38987452, JString, required = true,
                                   default = nil)
  if valid_38987452 != nil:
    section.add "repo", valid_38987452
  var valid_38987453 = path.getOrDefault("commentId")
  valid_38987453 = validateParameter(valid_38987453, JInt, required = true,
                                   default = nil)
  if valid_38987453 != nil:
    section.add "commentId", valid_38987453
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987454 = header.getOrDefault("Accept")
  valid_38987454 = validateParameter(valid_38987454, JString, required = false,
                                   default = nil)
  if valid_38987454 != nil:
    section.add "Accept", valid_38987454
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987455: Call_GetReposOwnerRepoPullsCommentsCommentId_38987448;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single comment.
  ## 
  let valid = call_38987455.validator(path, query, header, formData, body, _)
  let scheme = call_38987455.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987455.url(scheme.get, call_38987455.host, call_38987455.base,
                           call_38987455.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987455, url, valid, _)

proc call*(call_38987456: Call_GetReposOwnerRepoPullsCommentsCommentId_38987448;
          owner: string; repo: string; commentId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsCommentsCommentId
  ## Get a single comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_38987457 = newJObject()
  var header_38987458 = newJObject()
  add(path_38987457, "owner", newJString(owner))
  add(header_38987458, "Accept", newJString(Accept))
  add(path_38987457, "repo", newJString(repo))
  add(path_38987457, "commentId", newJInt(commentId))
  result = call_38987456.call(path_38987457, nil, header_38987458, nil, nil)

var getReposOwnerRepoPullsCommentsCommentId* = Call_GetReposOwnerRepoPullsCommentsCommentId_38987448(
    name: "getReposOwnerRepoPullsCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/comments/{commentId}",
    validator: validate_GetReposOwnerRepoPullsCommentsCommentId_38987449,
    base: "/", url: url_GetReposOwnerRepoPullsCommentsCommentId_38987450,
    schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoPullsCommentsCommentId_38987470 = ref object of OpenApiRestCall_38985352
proc url_PatchReposOwnerRepoPullsCommentsCommentId_38987472(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoPullsCommentsCommentId_38987471(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Edit a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987473 = path.getOrDefault("owner")
  valid_38987473 = validateParameter(valid_38987473, JString, required = true,
                                   default = nil)
  if valid_38987473 != nil:
    section.add "owner", valid_38987473
  var valid_38987474 = path.getOrDefault("repo")
  valid_38987474 = validateParameter(valid_38987474, JString, required = true,
                                   default = nil)
  if valid_38987474 != nil:
    section.add "repo", valid_38987474
  var valid_38987475 = path.getOrDefault("commentId")
  valid_38987475 = validateParameter(valid_38987475, JInt, required = true,
                                   default = nil)
  if valid_38987475 != nil:
    section.add "commentId", valid_38987475
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987476 = header.getOrDefault("Accept")
  valid_38987476 = validateParameter(valid_38987476, JString, required = false,
                                   default = nil)
  if valid_38987476 != nil:
    section.add "Accept", valid_38987476
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38987478: Call_PatchReposOwnerRepoPullsCommentsCommentId_38987470;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit a comment.
  ## 
  let valid = call_38987478.validator(path, query, header, formData, body, _)
  let scheme = call_38987478.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987478.url(scheme.get, call_38987478.host, call_38987478.base,
                           call_38987478.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987478, url, valid, _)

proc call*(call_38987479: Call_PatchReposOwnerRepoPullsCommentsCommentId_38987470;
          owner: string; body: JsonNode; repo: string; commentId: int;
          Accept: string = ""): Recallable =
  ## patchReposOwnerRepoPullsCommentsCommentId
  ## Edit a comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_38987480 = newJObject()
  var header_38987481 = newJObject()
  var body_38987482 = newJObject()
  add(path_38987480, "owner", newJString(owner))
  add(header_38987481, "Accept", newJString(Accept))
  if body != nil:
    body_38987482 = body
  add(path_38987480, "repo", newJString(repo))
  add(path_38987480, "commentId", newJInt(commentId))
  result = call_38987479.call(path_38987480, nil, header_38987481, nil, body_38987482)

var patchReposOwnerRepoPullsCommentsCommentId* = Call_PatchReposOwnerRepoPullsCommentsCommentId_38987470(
    name: "patchReposOwnerRepoPullsCommentsCommentId", meth: HttpMethod.HttpPatch,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/comments/{commentId}",
    validator: validate_PatchReposOwnerRepoPullsCommentsCommentId_38987471,
    base: "/", url: url_PatchReposOwnerRepoPullsCommentsCommentId_38987472,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoPullsCommentsCommentId_38987459 = ref object of OpenApiRestCall_38985352
proc url_DeleteReposOwnerRepoPullsCommentsCommentId_38987461(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoPullsCommentsCommentId_38987460(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987462 = path.getOrDefault("owner")
  valid_38987462 = validateParameter(valid_38987462, JString, required = true,
                                   default = nil)
  if valid_38987462 != nil:
    section.add "owner", valid_38987462
  var valid_38987463 = path.getOrDefault("repo")
  valid_38987463 = validateParameter(valid_38987463, JString, required = true,
                                   default = nil)
  if valid_38987463 != nil:
    section.add "repo", valid_38987463
  var valid_38987464 = path.getOrDefault("commentId")
  valid_38987464 = validateParameter(valid_38987464, JInt, required = true,
                                   default = nil)
  if valid_38987464 != nil:
    section.add "commentId", valid_38987464
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987465 = header.getOrDefault("Accept")
  valid_38987465 = validateParameter(valid_38987465, JString, required = false,
                                   default = nil)
  if valid_38987465 != nil:
    section.add "Accept", valid_38987465
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987466: Call_DeleteReposOwnerRepoPullsCommentsCommentId_38987459;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a comment.
  ## 
  let valid = call_38987466.validator(path, query, header, formData, body, _)
  let scheme = call_38987466.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987466.url(scheme.get, call_38987466.host, call_38987466.base,
                           call_38987466.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987466, url, valid, _)

proc call*(call_38987467: Call_DeleteReposOwnerRepoPullsCommentsCommentId_38987459;
          owner: string; repo: string; commentId: int; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoPullsCommentsCommentId
  ## Delete a comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_38987468 = newJObject()
  var header_38987469 = newJObject()
  add(path_38987468, "owner", newJString(owner))
  add(header_38987469, "Accept", newJString(Accept))
  add(path_38987468, "repo", newJString(repo))
  add(path_38987468, "commentId", newJInt(commentId))
  result = call_38987467.call(path_38987468, nil, header_38987469, nil, nil)

var deleteReposOwnerRepoPullsCommentsCommentId* = Call_DeleteReposOwnerRepoPullsCommentsCommentId_38987459(
    name: "deleteReposOwnerRepoPullsCommentsCommentId",
    meth: HttpMethod.HttpDelete, host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/comments/{commentId}",
    validator: validate_DeleteReposOwnerRepoPullsCommentsCommentId_38987460,
    base: "/", url: url_DeleteReposOwnerRepoPullsCommentsCommentId_38987461,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumber_38987483 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoPullsNumber_38987485(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumber_38987484(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a single pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987486 = path.getOrDefault("owner")
  valid_38987486 = validateParameter(valid_38987486, JString, required = true,
                                   default = nil)
  if valid_38987486 != nil:
    section.add "owner", valid_38987486
  var valid_38987487 = path.getOrDefault("number")
  valid_38987487 = validateParameter(valid_38987487, JInt, required = true,
                                   default = nil)
  if valid_38987487 != nil:
    section.add "number", valid_38987487
  var valid_38987488 = path.getOrDefault("repo")
  valid_38987488 = validateParameter(valid_38987488, JString, required = true,
                                   default = nil)
  if valid_38987488 != nil:
    section.add "repo", valid_38987488
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987489 = header.getOrDefault("Accept")
  valid_38987489 = validateParameter(valid_38987489, JString, required = false,
                                   default = nil)
  if valid_38987489 != nil:
    section.add "Accept", valid_38987489
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987490: Call_GetReposOwnerRepoPullsNumber_38987483;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single pull request.
  ## 
  let valid = call_38987490.validator(path, query, header, formData, body, _)
  let scheme = call_38987490.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987490.url(scheme.get, call_38987490.host, call_38987490.base,
                           call_38987490.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987490, url, valid, _)

proc call*(call_38987491: Call_GetReposOwnerRepoPullsNumber_38987483;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumber
  ## Get a single pull request.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987492 = newJObject()
  var header_38987493 = newJObject()
  add(path_38987492, "owner", newJString(owner))
  add(path_38987492, "number", newJInt(number))
  add(header_38987493, "Accept", newJString(Accept))
  add(path_38987492, "repo", newJString(repo))
  result = call_38987491.call(path_38987492, nil, header_38987493, nil, nil)

var getReposOwnerRepoPullsNumber* = Call_GetReposOwnerRepoPullsNumber_38987483(
    name: "getReposOwnerRepoPullsNumber", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}",
    validator: validate_GetReposOwnerRepoPullsNumber_38987484, base: "/",
    url: url_GetReposOwnerRepoPullsNumber_38987485, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoPullsNumber_38987494 = ref object of OpenApiRestCall_38985352
proc url_PatchReposOwnerRepoPullsNumber_38987496(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoPullsNumber_38987495(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Update a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987497 = path.getOrDefault("owner")
  valid_38987497 = validateParameter(valid_38987497, JString, required = true,
                                   default = nil)
  if valid_38987497 != nil:
    section.add "owner", valid_38987497
  var valid_38987498 = path.getOrDefault("number")
  valid_38987498 = validateParameter(valid_38987498, JInt, required = true,
                                   default = nil)
  if valid_38987498 != nil:
    section.add "number", valid_38987498
  var valid_38987499 = path.getOrDefault("repo")
  valid_38987499 = validateParameter(valid_38987499, JString, required = true,
                                   default = nil)
  if valid_38987499 != nil:
    section.add "repo", valid_38987499
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987500 = header.getOrDefault("Accept")
  valid_38987500 = validateParameter(valid_38987500, JString, required = false,
                                   default = nil)
  if valid_38987500 != nil:
    section.add "Accept", valid_38987500
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38987502: Call_PatchReposOwnerRepoPullsNumber_38987494;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Update a pull request.
  ## 
  let valid = call_38987502.validator(path, query, header, formData, body, _)
  let scheme = call_38987502.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987502.url(scheme.get, call_38987502.host, call_38987502.base,
                           call_38987502.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987502, url, valid, _)

proc call*(call_38987503: Call_PatchReposOwnerRepoPullsNumber_38987494;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoPullsNumber
  ## Update a pull request.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987504 = newJObject()
  var header_38987505 = newJObject()
  var body_38987506 = newJObject()
  add(path_38987504, "owner", newJString(owner))
  add(path_38987504, "number", newJInt(number))
  add(header_38987505, "Accept", newJString(Accept))
  if body != nil:
    body_38987506 = body
  add(path_38987504, "repo", newJString(repo))
  result = call_38987503.call(path_38987504, nil, header_38987505, nil, body_38987506)

var patchReposOwnerRepoPullsNumber* = Call_PatchReposOwnerRepoPullsNumber_38987494(
    name: "patchReposOwnerRepoPullsNumber", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}",
    validator: validate_PatchReposOwnerRepoPullsNumber_38987495, base: "/",
    url: url_PatchReposOwnerRepoPullsNumber_38987496, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoPullsNumberComments_38987518 = ref object of OpenApiRestCall_38985352
proc url_PostReposOwnerRepoPullsNumberComments_38987520(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoPullsNumberComments_38987519(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Create a comment.
  ##   #TODO Alternative input ( http://developer.github.com/v3/pulls/comments/ )
  ##   description: |
  ##     Alternative Input.
  ##     Instead of passing commit_id, path, and position you can reply to an
  ##     existing Pull Request Comment like this:
  ## 
  ##         body
  ##            Required string
  ##         in_reply_to
  ##            Required number - Comment id to reply to.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987521 = path.getOrDefault("owner")
  valid_38987521 = validateParameter(valid_38987521, JString, required = true,
                                   default = nil)
  if valid_38987521 != nil:
    section.add "owner", valid_38987521
  var valid_38987522 = path.getOrDefault("number")
  valid_38987522 = validateParameter(valid_38987522, JInt, required = true,
                                   default = nil)
  if valid_38987522 != nil:
    section.add "number", valid_38987522
  var valid_38987523 = path.getOrDefault("repo")
  valid_38987523 = validateParameter(valid_38987523, JString, required = true,
                                   default = nil)
  if valid_38987523 != nil:
    section.add "repo", valid_38987523
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987524 = header.getOrDefault("Accept")
  valid_38987524 = validateParameter(valid_38987524, JString, required = false,
                                   default = nil)
  if valid_38987524 != nil:
    section.add "Accept", valid_38987524
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38987526: Call_PostReposOwnerRepoPullsNumberComments_38987518;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a comment.
  ##   #TODO Alternative input ( http://developer.github.com/v3/pulls/comments/ )
  ##   description: |
  ##     Alternative Input.
  ##     Instead of passing commit_id, path, and position you can reply to an
  ##     existing Pull Request Comment like this:
  ## 
  ##         body
  ##            Required string
  ##         in_reply_to
  ##            Required number - Comment id to reply to.
  ## 
  ## 
  let valid = call_38987526.validator(path, query, header, formData, body, _)
  let scheme = call_38987526.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987526.url(scheme.get, call_38987526.host, call_38987526.base,
                           call_38987526.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987526, url, valid, _)

proc call*(call_38987527: Call_PostReposOwnerRepoPullsNumberComments_38987518;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoPullsNumberComments
  ## Create a comment.
  ##   #TODO Alternative input ( http://developer.github.com/v3/pulls/comments/ )
  ##   description: |
  ##     Alternative Input.
  ##     Instead of passing commit_id, path, and position you can reply to an
  ##     existing Pull Request Comment like this:
  ## 
  ##         body
  ##            Required string
  ##         in_reply_to
  ##            Required number - Comment id to reply to.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987528 = newJObject()
  var header_38987529 = newJObject()
  var body_38987530 = newJObject()
  add(path_38987528, "owner", newJString(owner))
  add(path_38987528, "number", newJInt(number))
  add(header_38987529, "Accept", newJString(Accept))
  if body != nil:
    body_38987530 = body
  add(path_38987528, "repo", newJString(repo))
  result = call_38987527.call(path_38987528, nil, header_38987529, nil, body_38987530)

var postReposOwnerRepoPullsNumberComments* = Call_PostReposOwnerRepoPullsNumberComments_38987518(
    name: "postReposOwnerRepoPullsNumberComments", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/{number}/comments",
    validator: validate_PostReposOwnerRepoPullsNumberComments_38987519, base: "/",
    url: url_PostReposOwnerRepoPullsNumberComments_38987520,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberComments_38987507 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoPullsNumberComments_38987509(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberComments_38987508(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List comments on a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987510 = path.getOrDefault("owner")
  valid_38987510 = validateParameter(valid_38987510, JString, required = true,
                                   default = nil)
  if valid_38987510 != nil:
    section.add "owner", valid_38987510
  var valid_38987511 = path.getOrDefault("number")
  valid_38987511 = validateParameter(valid_38987511, JInt, required = true,
                                   default = nil)
  if valid_38987511 != nil:
    section.add "number", valid_38987511
  var valid_38987512 = path.getOrDefault("repo")
  valid_38987512 = validateParameter(valid_38987512, JString, required = true,
                                   default = nil)
  if valid_38987512 != nil:
    section.add "repo", valid_38987512
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987513 = header.getOrDefault("Accept")
  valid_38987513 = validateParameter(valid_38987513, JString, required = false,
                                   default = nil)
  if valid_38987513 != nil:
    section.add "Accept", valid_38987513
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987514: Call_GetReposOwnerRepoPullsNumberComments_38987507;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List comments on a pull request.
  ## 
  let valid = call_38987514.validator(path, query, header, formData, body, _)
  let scheme = call_38987514.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987514.url(scheme.get, call_38987514.host, call_38987514.base,
                           call_38987514.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987514, url, valid, _)

proc call*(call_38987515: Call_GetReposOwnerRepoPullsNumberComments_38987507;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberComments
  ## List comments on a pull request.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987516 = newJObject()
  var header_38987517 = newJObject()
  add(path_38987516, "owner", newJString(owner))
  add(path_38987516, "number", newJInt(number))
  add(header_38987517, "Accept", newJString(Accept))
  add(path_38987516, "repo", newJString(repo))
  result = call_38987515.call(path_38987516, nil, header_38987517, nil, nil)

var getReposOwnerRepoPullsNumberComments* = Call_GetReposOwnerRepoPullsNumberComments_38987507(
    name: "getReposOwnerRepoPullsNumberComments", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/{number}/comments",
    validator: validate_GetReposOwnerRepoPullsNumberComments_38987508, base: "/",
    url: url_GetReposOwnerRepoPullsNumberComments_38987509,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberCommits_38987531 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoPullsNumberCommits_38987533(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/commits")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberCommits_38987532(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List commits on a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987534 = path.getOrDefault("owner")
  valid_38987534 = validateParameter(valid_38987534, JString, required = true,
                                   default = nil)
  if valid_38987534 != nil:
    section.add "owner", valid_38987534
  var valid_38987535 = path.getOrDefault("number")
  valid_38987535 = validateParameter(valid_38987535, JInt, required = true,
                                   default = nil)
  if valid_38987535 != nil:
    section.add "number", valid_38987535
  var valid_38987536 = path.getOrDefault("repo")
  valid_38987536 = validateParameter(valid_38987536, JString, required = true,
                                   default = nil)
  if valid_38987536 != nil:
    section.add "repo", valid_38987536
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987537 = header.getOrDefault("Accept")
  valid_38987537 = validateParameter(valid_38987537, JString, required = false,
                                   default = nil)
  if valid_38987537 != nil:
    section.add "Accept", valid_38987537
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987538: Call_GetReposOwnerRepoPullsNumberCommits_38987531;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List commits on a pull request.
  ## 
  let valid = call_38987538.validator(path, query, header, formData, body, _)
  let scheme = call_38987538.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987538.url(scheme.get, call_38987538.host, call_38987538.base,
                           call_38987538.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987538, url, valid, _)

proc call*(call_38987539: Call_GetReposOwnerRepoPullsNumberCommits_38987531;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberCommits
  ## List commits on a pull request.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987540 = newJObject()
  var header_38987541 = newJObject()
  add(path_38987540, "owner", newJString(owner))
  add(path_38987540, "number", newJInt(number))
  add(header_38987541, "Accept", newJString(Accept))
  add(path_38987540, "repo", newJString(repo))
  result = call_38987539.call(path_38987540, nil, header_38987541, nil, nil)

var getReposOwnerRepoPullsNumberCommits* = Call_GetReposOwnerRepoPullsNumberCommits_38987531(
    name: "getReposOwnerRepoPullsNumberCommits", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/commits",
    validator: validate_GetReposOwnerRepoPullsNumberCommits_38987532, base: "/",
    url: url_GetReposOwnerRepoPullsNumberCommits_38987533, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberFiles_38987542 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoPullsNumberFiles_38987544(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/files")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberFiles_38987543(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List pull requests files.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987545 = path.getOrDefault("owner")
  valid_38987545 = validateParameter(valid_38987545, JString, required = true,
                                   default = nil)
  if valid_38987545 != nil:
    section.add "owner", valid_38987545
  var valid_38987546 = path.getOrDefault("number")
  valid_38987546 = validateParameter(valid_38987546, JInt, required = true,
                                   default = nil)
  if valid_38987546 != nil:
    section.add "number", valid_38987546
  var valid_38987547 = path.getOrDefault("repo")
  valid_38987547 = validateParameter(valid_38987547, JString, required = true,
                                   default = nil)
  if valid_38987547 != nil:
    section.add "repo", valid_38987547
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987548 = header.getOrDefault("Accept")
  valid_38987548 = validateParameter(valid_38987548, JString, required = false,
                                   default = nil)
  if valid_38987548 != nil:
    section.add "Accept", valid_38987548
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987549: Call_GetReposOwnerRepoPullsNumberFiles_38987542;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List pull requests files.
  ## 
  let valid = call_38987549.validator(path, query, header, formData, body, _)
  let scheme = call_38987549.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987549.url(scheme.get, call_38987549.host, call_38987549.base,
                           call_38987549.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987549, url, valid, _)

proc call*(call_38987550: Call_GetReposOwnerRepoPullsNumberFiles_38987542;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberFiles
  ## List pull requests files.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987551 = newJObject()
  var header_38987552 = newJObject()
  add(path_38987551, "owner", newJString(owner))
  add(path_38987551, "number", newJInt(number))
  add(header_38987552, "Accept", newJString(Accept))
  add(path_38987551, "repo", newJString(repo))
  result = call_38987550.call(path_38987551, nil, header_38987552, nil, nil)

var getReposOwnerRepoPullsNumberFiles* = Call_GetReposOwnerRepoPullsNumberFiles_38987542(
    name: "getReposOwnerRepoPullsNumberFiles", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/files",
    validator: validate_GetReposOwnerRepoPullsNumberFiles_38987543, base: "/",
    url: url_GetReposOwnerRepoPullsNumberFiles_38987544, schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoPullsNumberMerge_38987564 = ref object of OpenApiRestCall_38985352
proc url_PutReposOwnerRepoPullsNumberMerge_38987566(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/merge")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoPullsNumberMerge_38987565(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Merge a pull request (Merge Button's)
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987567 = path.getOrDefault("owner")
  valid_38987567 = validateParameter(valid_38987567, JString, required = true,
                                   default = nil)
  if valid_38987567 != nil:
    section.add "owner", valid_38987567
  var valid_38987568 = path.getOrDefault("number")
  valid_38987568 = validateParameter(valid_38987568, JInt, required = true,
                                   default = nil)
  if valid_38987568 != nil:
    section.add "number", valid_38987568
  var valid_38987569 = path.getOrDefault("repo")
  valid_38987569 = validateParameter(valid_38987569, JString, required = true,
                                   default = nil)
  if valid_38987569 != nil:
    section.add "repo", valid_38987569
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987570 = header.getOrDefault("Accept")
  valid_38987570 = validateParameter(valid_38987570, JString, required = false,
                                   default = nil)
  if valid_38987570 != nil:
    section.add "Accept", valid_38987570
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38987572: Call_PutReposOwnerRepoPullsNumberMerge_38987564;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Merge a pull request (Merge Button's)
  ## 
  let valid = call_38987572.validator(path, query, header, formData, body, _)
  let scheme = call_38987572.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987572.url(scheme.get, call_38987572.host, call_38987572.base,
                           call_38987572.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987572, url, valid, _)

proc call*(call_38987573: Call_PutReposOwnerRepoPullsNumberMerge_38987564;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoPullsNumberMerge
  ## Merge a pull request (Merge Button's)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987574 = newJObject()
  var header_38987575 = newJObject()
  var body_38987576 = newJObject()
  add(path_38987574, "owner", newJString(owner))
  add(path_38987574, "number", newJInt(number))
  add(header_38987575, "Accept", newJString(Accept))
  if body != nil:
    body_38987576 = body
  add(path_38987574, "repo", newJString(repo))
  result = call_38987573.call(path_38987574, nil, header_38987575, nil, body_38987576)

var putReposOwnerRepoPullsNumberMerge* = Call_PutReposOwnerRepoPullsNumberMerge_38987564(
    name: "putReposOwnerRepoPullsNumberMerge", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/merge",
    validator: validate_PutReposOwnerRepoPullsNumberMerge_38987565, base: "/",
    url: url_PutReposOwnerRepoPullsNumberMerge_38987566, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberMerge_38987553 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoPullsNumberMerge_38987555(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/merge")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberMerge_38987554(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get if a pull request has been merged.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987556 = path.getOrDefault("owner")
  valid_38987556 = validateParameter(valid_38987556, JString, required = true,
                                   default = nil)
  if valid_38987556 != nil:
    section.add "owner", valid_38987556
  var valid_38987557 = path.getOrDefault("number")
  valid_38987557 = validateParameter(valid_38987557, JInt, required = true,
                                   default = nil)
  if valid_38987557 != nil:
    section.add "number", valid_38987557
  var valid_38987558 = path.getOrDefault("repo")
  valid_38987558 = validateParameter(valid_38987558, JString, required = true,
                                   default = nil)
  if valid_38987558 != nil:
    section.add "repo", valid_38987558
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987559 = header.getOrDefault("Accept")
  valid_38987559 = validateParameter(valid_38987559, JString, required = false,
                                   default = nil)
  if valid_38987559 != nil:
    section.add "Accept", valid_38987559
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987560: Call_GetReposOwnerRepoPullsNumberMerge_38987553;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get if a pull request has been merged.
  ## 
  let valid = call_38987560.validator(path, query, header, formData, body, _)
  let scheme = call_38987560.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987560.url(scheme.get, call_38987560.host, call_38987560.base,
                           call_38987560.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987560, url, valid, _)

proc call*(call_38987561: Call_GetReposOwnerRepoPullsNumberMerge_38987553;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberMerge
  ## Get if a pull request has been merged.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987562 = newJObject()
  var header_38987563 = newJObject()
  add(path_38987562, "owner", newJString(owner))
  add(path_38987562, "number", newJInt(number))
  add(header_38987563, "Accept", newJString(Accept))
  add(path_38987562, "repo", newJString(repo))
  result = call_38987561.call(path_38987562, nil, header_38987563, nil, nil)

var getReposOwnerRepoPullsNumberMerge* = Call_GetReposOwnerRepoPullsNumberMerge_38987553(
    name: "getReposOwnerRepoPullsNumberMerge", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/merge",
    validator: validate_GetReposOwnerRepoPullsNumberMerge_38987554, base: "/",
    url: url_GetReposOwnerRepoPullsNumberMerge_38987555, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReadme_38987577 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoReadme_38987579(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/readme")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReadme_38987578(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get the README.
  ## This method returns the preferred README for a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987580 = path.getOrDefault("owner")
  valid_38987580 = validateParameter(valid_38987580, JString, required = true,
                                   default = nil)
  if valid_38987580 != nil:
    section.add "owner", valid_38987580
  var valid_38987581 = path.getOrDefault("repo")
  valid_38987581 = validateParameter(valid_38987581, JString, required = true,
                                   default = nil)
  if valid_38987581 != nil:
    section.add "repo", valid_38987581
  result.add "path", section
  ## parameters in `query` object:
  ##   ref: JString
  ##      : The String name of the Commit/Branch/Tag. Defaults to master.
  section = newJObject()
  var valid_38987582 = query.getOrDefault("ref")
  valid_38987582 = validateParameter(valid_38987582, JString, required = false,
                                   default = nil)
  if valid_38987582 != nil:
    section.add "ref", valid_38987582
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987583 = header.getOrDefault("Accept")
  valid_38987583 = validateParameter(valid_38987583, JString, required = false,
                                   default = nil)
  if valid_38987583 != nil:
    section.add "Accept", valid_38987583
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987584: Call_GetReposOwnerRepoReadme_38987577;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get the README.
  ## This method returns the preferred README for a repository.
  ## 
  ## 
  let valid = call_38987584.validator(path, query, header, formData, body, _)
  let scheme = call_38987584.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987584.url(scheme.get, call_38987584.host, call_38987584.base,
                           call_38987584.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987584, url, valid, _)

proc call*(call_38987585: Call_GetReposOwnerRepoReadme_38987577; owner: string;
          repo: string; Accept: string = ""; `ref`: string = ""): Recallable =
  ## getReposOwnerRepoReadme
  ## Get the README.
  ## This method returns the preferred README for a repository.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   ref: string
  ##      : The String name of the Commit/Branch/Tag. Defaults to master.
  var path_38987586 = newJObject()
  var query_38987587 = newJObject()
  var header_38987588 = newJObject()
  add(path_38987586, "owner", newJString(owner))
  add(header_38987588, "Accept", newJString(Accept))
  add(path_38987586, "repo", newJString(repo))
  add(query_38987587, "ref", newJString(`ref`))
  result = call_38987585.call(path_38987586, query_38987587, header_38987588, nil, nil)

var getReposOwnerRepoReadme* = Call_GetReposOwnerRepoReadme_38987577(
    name: "getReposOwnerRepoReadme", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/readme",
    validator: validate_GetReposOwnerRepoReadme_38987578, base: "/",
    url: url_GetReposOwnerRepoReadme_38987579, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoReleases_38987599 = ref object of OpenApiRestCall_38985352
proc url_PostReposOwnerRepoReleases_38987601(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoReleases_38987600(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a release
  ## Users with push access to the repository can create a release.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987602 = path.getOrDefault("owner")
  valid_38987602 = validateParameter(valid_38987602, JString, required = true,
                                   default = nil)
  if valid_38987602 != nil:
    section.add "owner", valid_38987602
  var valid_38987603 = path.getOrDefault("repo")
  valid_38987603 = validateParameter(valid_38987603, JString, required = true,
                                   default = nil)
  if valid_38987603 != nil:
    section.add "repo", valid_38987603
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987604 = header.getOrDefault("Accept")
  valid_38987604 = validateParameter(valid_38987604, JString, required = false,
                                   default = nil)
  if valid_38987604 != nil:
    section.add "Accept", valid_38987604
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38987606: Call_PostReposOwnerRepoReleases_38987599;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a release
  ## Users with push access to the repository can create a release.
  ## 
  ## 
  let valid = call_38987606.validator(path, query, header, formData, body, _)
  let scheme = call_38987606.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987606.url(scheme.get, call_38987606.host, call_38987606.base,
                           call_38987606.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987606, url, valid, _)

proc call*(call_38987607: Call_PostReposOwnerRepoReleases_38987599; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoReleases
  ## Create a release
  ## Users with push access to the repository can create a release.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987608 = newJObject()
  var header_38987609 = newJObject()
  var body_38987610 = newJObject()
  add(path_38987608, "owner", newJString(owner))
  add(header_38987609, "Accept", newJString(Accept))
  if body != nil:
    body_38987610 = body
  add(path_38987608, "repo", newJString(repo))
  result = call_38987607.call(path_38987608, nil, header_38987609, nil, body_38987610)

var postReposOwnerRepoReleases* = Call_PostReposOwnerRepoReleases_38987599(
    name: "postReposOwnerRepoReleases", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases",
    validator: validate_PostReposOwnerRepoReleases_38987600, base: "/",
    url: url_PostReposOwnerRepoReleases_38987601, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleases_38987589 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoReleases_38987591(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleases_38987590(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Users with push access to the repository will receive all releases (i.e., published releases and draft releases). Users with pull access will receive published releases only
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987592 = path.getOrDefault("owner")
  valid_38987592 = validateParameter(valid_38987592, JString, required = true,
                                   default = nil)
  if valid_38987592 != nil:
    section.add "owner", valid_38987592
  var valid_38987593 = path.getOrDefault("repo")
  valid_38987593 = validateParameter(valid_38987593, JString, required = true,
                                   default = nil)
  if valid_38987593 != nil:
    section.add "repo", valid_38987593
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987594 = header.getOrDefault("Accept")
  valid_38987594 = validateParameter(valid_38987594, JString, required = false,
                                   default = nil)
  if valid_38987594 != nil:
    section.add "Accept", valid_38987594
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987595: Call_GetReposOwnerRepoReleases_38987589;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Users with push access to the repository will receive all releases (i.e., published releases and draft releases). Users with pull access will receive published releases only
  ## 
  let valid = call_38987595.validator(path, query, header, formData, body, _)
  let scheme = call_38987595.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987595.url(scheme.get, call_38987595.host, call_38987595.base,
                           call_38987595.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987595, url, valid, _)

proc call*(call_38987596: Call_GetReposOwnerRepoReleases_38987589; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleases
  ## Users with push access to the repository will receive all releases (i.e., published releases and draft releases). Users with pull access will receive published releases only
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987597 = newJObject()
  var header_38987598 = newJObject()
  add(path_38987597, "owner", newJString(owner))
  add(header_38987598, "Accept", newJString(Accept))
  add(path_38987597, "repo", newJString(repo))
  result = call_38987596.call(path_38987597, nil, header_38987598, nil, nil)

var getReposOwnerRepoReleases* = Call_GetReposOwnerRepoReleases_38987589(
    name: "getReposOwnerRepoReleases", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases",
    validator: validate_GetReposOwnerRepoReleases_38987590, base: "/",
    url: url_GetReposOwnerRepoReleases_38987591, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleasesAssetsId_38987611 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoReleasesAssetsId_38987613(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/assets/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleasesAssetsId_38987612(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a single release asset
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987614 = path.getOrDefault("owner")
  valid_38987614 = validateParameter(valid_38987614, JString, required = true,
                                   default = nil)
  if valid_38987614 != nil:
    section.add "owner", valid_38987614
  var valid_38987615 = path.getOrDefault("id")
  valid_38987615 = validateParameter(valid_38987615, JString, required = true,
                                   default = nil)
  if valid_38987615 != nil:
    section.add "id", valid_38987615
  var valid_38987616 = path.getOrDefault("repo")
  valid_38987616 = validateParameter(valid_38987616, JString, required = true,
                                   default = nil)
  if valid_38987616 != nil:
    section.add "repo", valid_38987616
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987617 = header.getOrDefault("Accept")
  valid_38987617 = validateParameter(valid_38987617, JString, required = false,
                                   default = nil)
  if valid_38987617 != nil:
    section.add "Accept", valid_38987617
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987618: Call_GetReposOwnerRepoReleasesAssetsId_38987611;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single release asset
  ## 
  let valid = call_38987618.validator(path, query, header, formData, body, _)
  let scheme = call_38987618.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987618.url(scheme.get, call_38987618.host, call_38987618.base,
                           call_38987618.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987618, url, valid, _)

proc call*(call_38987619: Call_GetReposOwnerRepoReleasesAssetsId_38987611;
          owner: string; id: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleasesAssetsId
  ## Get a single release asset
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987620 = newJObject()
  var header_38987621 = newJObject()
  add(path_38987620, "owner", newJString(owner))
  add(path_38987620, "id", newJString(id))
  add(header_38987621, "Accept", newJString(Accept))
  add(path_38987620, "repo", newJString(repo))
  result = call_38987619.call(path_38987620, nil, header_38987621, nil, nil)

var getReposOwnerRepoReleasesAssetsId* = Call_GetReposOwnerRepoReleasesAssetsId_38987611(
    name: "getReposOwnerRepoReleasesAssetsId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/assets/{id}",
    validator: validate_GetReposOwnerRepoReleasesAssetsId_38987612, base: "/",
    url: url_GetReposOwnerRepoReleasesAssetsId_38987613, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoReleasesAssetsId_38987633 = ref object of OpenApiRestCall_38985352
proc url_PatchReposOwnerRepoReleasesAssetsId_38987635(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/assets/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoReleasesAssetsId_38987634(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Edit a release asset
  ## Users with push access to the repository can edit a release asset.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987636 = path.getOrDefault("owner")
  valid_38987636 = validateParameter(valid_38987636, JString, required = true,
                                   default = nil)
  if valid_38987636 != nil:
    section.add "owner", valid_38987636
  var valid_38987637 = path.getOrDefault("id")
  valid_38987637 = validateParameter(valid_38987637, JString, required = true,
                                   default = nil)
  if valid_38987637 != nil:
    section.add "id", valid_38987637
  var valid_38987638 = path.getOrDefault("repo")
  valid_38987638 = validateParameter(valid_38987638, JString, required = true,
                                   default = nil)
  if valid_38987638 != nil:
    section.add "repo", valid_38987638
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987639 = header.getOrDefault("Accept")
  valid_38987639 = validateParameter(valid_38987639, JString, required = false,
                                   default = nil)
  if valid_38987639 != nil:
    section.add "Accept", valid_38987639
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38987641: Call_PatchReposOwnerRepoReleasesAssetsId_38987633;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit a release asset
  ## Users with push access to the repository can edit a release asset.
  ## 
  ## 
  let valid = call_38987641.validator(path, query, header, formData, body, _)
  let scheme = call_38987641.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987641.url(scheme.get, call_38987641.host, call_38987641.base,
                           call_38987641.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987641, url, valid, _)

proc call*(call_38987642: Call_PatchReposOwnerRepoReleasesAssetsId_38987633;
          owner: string; id: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoReleasesAssetsId
  ## Edit a release asset
  ## Users with push access to the repository can edit a release asset.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987643 = newJObject()
  var header_38987644 = newJObject()
  var body_38987645 = newJObject()
  add(path_38987643, "owner", newJString(owner))
  add(path_38987643, "id", newJString(id))
  add(header_38987644, "Accept", newJString(Accept))
  if body != nil:
    body_38987645 = body
  add(path_38987643, "repo", newJString(repo))
  result = call_38987642.call(path_38987643, nil, header_38987644, nil, body_38987645)

var patchReposOwnerRepoReleasesAssetsId* = Call_PatchReposOwnerRepoReleasesAssetsId_38987633(
    name: "patchReposOwnerRepoReleasesAssetsId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/assets/{id}",
    validator: validate_PatchReposOwnerRepoReleasesAssetsId_38987634, base: "/",
    url: url_PatchReposOwnerRepoReleasesAssetsId_38987635, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoReleasesAssetsId_38987622 = ref object of OpenApiRestCall_38985352
proc url_DeleteReposOwnerRepoReleasesAssetsId_38987624(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/assets/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoReleasesAssetsId_38987623(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a release asset
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987625 = path.getOrDefault("owner")
  valid_38987625 = validateParameter(valid_38987625, JString, required = true,
                                   default = nil)
  if valid_38987625 != nil:
    section.add "owner", valid_38987625
  var valid_38987626 = path.getOrDefault("id")
  valid_38987626 = validateParameter(valid_38987626, JString, required = true,
                                   default = nil)
  if valid_38987626 != nil:
    section.add "id", valid_38987626
  var valid_38987627 = path.getOrDefault("repo")
  valid_38987627 = validateParameter(valid_38987627, JString, required = true,
                                   default = nil)
  if valid_38987627 != nil:
    section.add "repo", valid_38987627
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987628 = header.getOrDefault("Accept")
  valid_38987628 = validateParameter(valid_38987628, JString, required = false,
                                   default = nil)
  if valid_38987628 != nil:
    section.add "Accept", valid_38987628
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987629: Call_DeleteReposOwnerRepoReleasesAssetsId_38987622;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a release asset
  ## 
  let valid = call_38987629.validator(path, query, header, formData, body, _)
  let scheme = call_38987629.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987629.url(scheme.get, call_38987629.host, call_38987629.base,
                           call_38987629.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987629, url, valid, _)

proc call*(call_38987630: Call_DeleteReposOwnerRepoReleasesAssetsId_38987622;
          owner: string; id: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoReleasesAssetsId
  ## Delete a release asset
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987631 = newJObject()
  var header_38987632 = newJObject()
  add(path_38987631, "owner", newJString(owner))
  add(path_38987631, "id", newJString(id))
  add(header_38987632, "Accept", newJString(Accept))
  add(path_38987631, "repo", newJString(repo))
  result = call_38987630.call(path_38987631, nil, header_38987632, nil, nil)

var deleteReposOwnerRepoReleasesAssetsId* = Call_DeleteReposOwnerRepoReleasesAssetsId_38987622(
    name: "deleteReposOwnerRepoReleasesAssetsId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/assets/{id}",
    validator: validate_DeleteReposOwnerRepoReleasesAssetsId_38987623, base: "/",
    url: url_DeleteReposOwnerRepoReleasesAssetsId_38987624,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleasesId_38987646 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoReleasesId_38987648(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleasesId_38987647(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get a single release
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987649 = path.getOrDefault("owner")
  valid_38987649 = validateParameter(valid_38987649, JString, required = true,
                                   default = nil)
  if valid_38987649 != nil:
    section.add "owner", valid_38987649
  var valid_38987650 = path.getOrDefault("id")
  valid_38987650 = validateParameter(valid_38987650, JString, required = true,
                                   default = nil)
  if valid_38987650 != nil:
    section.add "id", valid_38987650
  var valid_38987651 = path.getOrDefault("repo")
  valid_38987651 = validateParameter(valid_38987651, JString, required = true,
                                   default = nil)
  if valid_38987651 != nil:
    section.add "repo", valid_38987651
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987652 = header.getOrDefault("Accept")
  valid_38987652 = validateParameter(valid_38987652, JString, required = false,
                                   default = nil)
  if valid_38987652 != nil:
    section.add "Accept", valid_38987652
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987653: Call_GetReposOwnerRepoReleasesId_38987646;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single release
  ## 
  let valid = call_38987653.validator(path, query, header, formData, body, _)
  let scheme = call_38987653.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987653.url(scheme.get, call_38987653.host, call_38987653.base,
                           call_38987653.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987653, url, valid, _)

proc call*(call_38987654: Call_GetReposOwnerRepoReleasesId_38987646; owner: string;
          id: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleasesId
  ## Get a single release
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987655 = newJObject()
  var header_38987656 = newJObject()
  add(path_38987655, "owner", newJString(owner))
  add(path_38987655, "id", newJString(id))
  add(header_38987656, "Accept", newJString(Accept))
  add(path_38987655, "repo", newJString(repo))
  result = call_38987654.call(path_38987655, nil, header_38987656, nil, nil)

var getReposOwnerRepoReleasesId* = Call_GetReposOwnerRepoReleasesId_38987646(
    name: "getReposOwnerRepoReleasesId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}",
    validator: validate_GetReposOwnerRepoReleasesId_38987647, base: "/",
    url: url_GetReposOwnerRepoReleasesId_38987648, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoReleasesId_38987668 = ref object of OpenApiRestCall_38985352
proc url_PatchReposOwnerRepoReleasesId_38987670(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoReleasesId_38987669(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Users with push access to the repository can edit a release
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987671 = path.getOrDefault("owner")
  valid_38987671 = validateParameter(valid_38987671, JString, required = true,
                                   default = nil)
  if valid_38987671 != nil:
    section.add "owner", valid_38987671
  var valid_38987672 = path.getOrDefault("id")
  valid_38987672 = validateParameter(valid_38987672, JString, required = true,
                                   default = nil)
  if valid_38987672 != nil:
    section.add "id", valid_38987672
  var valid_38987673 = path.getOrDefault("repo")
  valid_38987673 = validateParameter(valid_38987673, JString, required = true,
                                   default = nil)
  if valid_38987673 != nil:
    section.add "repo", valid_38987673
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987674 = header.getOrDefault("Accept")
  valid_38987674 = validateParameter(valid_38987674, JString, required = false,
                                   default = nil)
  if valid_38987674 != nil:
    section.add "Accept", valid_38987674
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38987676: Call_PatchReposOwnerRepoReleasesId_38987668;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Users with push access to the repository can edit a release
  ## 
  let valid = call_38987676.validator(path, query, header, formData, body, _)
  let scheme = call_38987676.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987676.url(scheme.get, call_38987676.host, call_38987676.base,
                           call_38987676.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987676, url, valid, _)

proc call*(call_38987677: Call_PatchReposOwnerRepoReleasesId_38987668;
          owner: string; id: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoReleasesId
  ## Users with push access to the repository can edit a release
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987678 = newJObject()
  var header_38987679 = newJObject()
  var body_38987680 = newJObject()
  add(path_38987678, "owner", newJString(owner))
  add(path_38987678, "id", newJString(id))
  add(header_38987679, "Accept", newJString(Accept))
  if body != nil:
    body_38987680 = body
  add(path_38987678, "repo", newJString(repo))
  result = call_38987677.call(path_38987678, nil, header_38987679, nil, body_38987680)

var patchReposOwnerRepoReleasesId* = Call_PatchReposOwnerRepoReleasesId_38987668(
    name: "patchReposOwnerRepoReleasesId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}",
    validator: validate_PatchReposOwnerRepoReleasesId_38987669, base: "/",
    url: url_PatchReposOwnerRepoReleasesId_38987670, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoReleasesId_38987657 = ref object of OpenApiRestCall_38985352
proc url_DeleteReposOwnerRepoReleasesId_38987659(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoReleasesId_38987658(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Users with push access to the repository can delete a release.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987660 = path.getOrDefault("owner")
  valid_38987660 = validateParameter(valid_38987660, JString, required = true,
                                   default = nil)
  if valid_38987660 != nil:
    section.add "owner", valid_38987660
  var valid_38987661 = path.getOrDefault("id")
  valid_38987661 = validateParameter(valid_38987661, JString, required = true,
                                   default = nil)
  if valid_38987661 != nil:
    section.add "id", valid_38987661
  var valid_38987662 = path.getOrDefault("repo")
  valid_38987662 = validateParameter(valid_38987662, JString, required = true,
                                   default = nil)
  if valid_38987662 != nil:
    section.add "repo", valid_38987662
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987663 = header.getOrDefault("Accept")
  valid_38987663 = validateParameter(valid_38987663, JString, required = false,
                                   default = nil)
  if valid_38987663 != nil:
    section.add "Accept", valid_38987663
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987664: Call_DeleteReposOwnerRepoReleasesId_38987657;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Users with push access to the repository can delete a release.
  ## 
  let valid = call_38987664.validator(path, query, header, formData, body, _)
  let scheme = call_38987664.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987664.url(scheme.get, call_38987664.host, call_38987664.base,
                           call_38987664.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987664, url, valid, _)

proc call*(call_38987665: Call_DeleteReposOwnerRepoReleasesId_38987657;
          owner: string; id: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoReleasesId
  ## Users with push access to the repository can delete a release.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987666 = newJObject()
  var header_38987667 = newJObject()
  add(path_38987666, "owner", newJString(owner))
  add(path_38987666, "id", newJString(id))
  add(header_38987667, "Accept", newJString(Accept))
  add(path_38987666, "repo", newJString(repo))
  result = call_38987665.call(path_38987666, nil, header_38987667, nil, nil)

var deleteReposOwnerRepoReleasesId* = Call_DeleteReposOwnerRepoReleasesId_38987657(
    name: "deleteReposOwnerRepoReleasesId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}",
    validator: validate_DeleteReposOwnerRepoReleasesId_38987658, base: "/",
    url: url_DeleteReposOwnerRepoReleasesId_38987659, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleasesIdAssets_38987681 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoReleasesIdAssets_38987683(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/assets")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleasesIdAssets_38987682(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List assets for a release
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987684 = path.getOrDefault("owner")
  valid_38987684 = validateParameter(valid_38987684, JString, required = true,
                                   default = nil)
  if valid_38987684 != nil:
    section.add "owner", valid_38987684
  var valid_38987685 = path.getOrDefault("id")
  valid_38987685 = validateParameter(valid_38987685, JString, required = true,
                                   default = nil)
  if valid_38987685 != nil:
    section.add "id", valid_38987685
  var valid_38987686 = path.getOrDefault("repo")
  valid_38987686 = validateParameter(valid_38987686, JString, required = true,
                                   default = nil)
  if valid_38987686 != nil:
    section.add "repo", valid_38987686
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987687 = header.getOrDefault("Accept")
  valid_38987687 = validateParameter(valid_38987687, JString, required = false,
                                   default = nil)
  if valid_38987687 != nil:
    section.add "Accept", valid_38987687
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987688: Call_GetReposOwnerRepoReleasesIdAssets_38987681;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List assets for a release
  ## 
  let valid = call_38987688.validator(path, query, header, formData, body, _)
  let scheme = call_38987688.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987688.url(scheme.get, call_38987688.host, call_38987688.base,
                           call_38987688.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987688, url, valid, _)

proc call*(call_38987689: Call_GetReposOwnerRepoReleasesIdAssets_38987681;
          owner: string; id: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleasesIdAssets
  ## List assets for a release
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987690 = newJObject()
  var header_38987691 = newJObject()
  add(path_38987690, "owner", newJString(owner))
  add(path_38987690, "id", newJString(id))
  add(header_38987691, "Accept", newJString(Accept))
  add(path_38987690, "repo", newJString(repo))
  result = call_38987689.call(path_38987690, nil, header_38987691, nil, nil)

var getReposOwnerRepoReleasesIdAssets* = Call_GetReposOwnerRepoReleasesIdAssets_38987681(
    name: "getReposOwnerRepoReleasesIdAssets", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}/assets",
    validator: validate_GetReposOwnerRepoReleasesIdAssets_38987682, base: "/",
    url: url_GetReposOwnerRepoReleasesIdAssets_38987683, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStargazers_38987692 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoStargazers_38987694(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stargazers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStargazers_38987693(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List Stargazers.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987695 = path.getOrDefault("owner")
  valid_38987695 = validateParameter(valid_38987695, JString, required = true,
                                   default = nil)
  if valid_38987695 != nil:
    section.add "owner", valid_38987695
  var valid_38987696 = path.getOrDefault("repo")
  valid_38987696 = validateParameter(valid_38987696, JString, required = true,
                                   default = nil)
  if valid_38987696 != nil:
    section.add "repo", valid_38987696
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987697 = header.getOrDefault("Accept")
  valid_38987697 = validateParameter(valid_38987697, JString, required = false,
                                   default = nil)
  if valid_38987697 != nil:
    section.add "Accept", valid_38987697
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987698: Call_GetReposOwnerRepoStargazers_38987692;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List Stargazers.
  ## 
  let valid = call_38987698.validator(path, query, header, formData, body, _)
  let scheme = call_38987698.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987698.url(scheme.get, call_38987698.host, call_38987698.base,
                           call_38987698.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987698, url, valid, _)

proc call*(call_38987699: Call_GetReposOwnerRepoStargazers_38987692; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStargazers
  ## List Stargazers.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987700 = newJObject()
  var header_38987701 = newJObject()
  add(path_38987700, "owner", newJString(owner))
  add(header_38987701, "Accept", newJString(Accept))
  add(path_38987700, "repo", newJString(repo))
  result = call_38987699.call(path_38987700, nil, header_38987701, nil, nil)

var getReposOwnerRepoStargazers* = Call_GetReposOwnerRepoStargazers_38987692(
    name: "getReposOwnerRepoStargazers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stargazers",
    validator: validate_GetReposOwnerRepoStargazers_38987693, base: "/",
    url: url_GetReposOwnerRepoStargazers_38987694, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsCodeFrequency_38987702 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoStatsCodeFrequency_38987704(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/code_frequency")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsCodeFrequency_38987703(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get the number of additions and deletions per week.
  ## Returns a weekly aggregate of the number of additions and deletions pushed
  ## to a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987705 = path.getOrDefault("owner")
  valid_38987705 = validateParameter(valid_38987705, JString, required = true,
                                   default = nil)
  if valid_38987705 != nil:
    section.add "owner", valid_38987705
  var valid_38987706 = path.getOrDefault("repo")
  valid_38987706 = validateParameter(valid_38987706, JString, required = true,
                                   default = nil)
  if valid_38987706 != nil:
    section.add "repo", valid_38987706
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987707 = header.getOrDefault("Accept")
  valid_38987707 = validateParameter(valid_38987707, JString, required = false,
                                   default = nil)
  if valid_38987707 != nil:
    section.add "Accept", valid_38987707
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987708: Call_GetReposOwnerRepoStatsCodeFrequency_38987702;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get the number of additions and deletions per week.
  ## Returns a weekly aggregate of the number of additions and deletions pushed
  ## to a repository.
  ## 
  ## 
  let valid = call_38987708.validator(path, query, header, formData, body, _)
  let scheme = call_38987708.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987708.url(scheme.get, call_38987708.host, call_38987708.base,
                           call_38987708.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987708, url, valid, _)

proc call*(call_38987709: Call_GetReposOwnerRepoStatsCodeFrequency_38987702;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsCodeFrequency
  ## Get the number of additions and deletions per week.
  ## Returns a weekly aggregate of the number of additions and deletions pushed
  ## to a repository.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987710 = newJObject()
  var header_38987711 = newJObject()
  add(path_38987710, "owner", newJString(owner))
  add(header_38987711, "Accept", newJString(Accept))
  add(path_38987710, "repo", newJString(repo))
  result = call_38987709.call(path_38987710, nil, header_38987711, nil, nil)

var getReposOwnerRepoStatsCodeFrequency* = Call_GetReposOwnerRepoStatsCodeFrequency_38987702(
    name: "getReposOwnerRepoStatsCodeFrequency", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/code_frequency",
    validator: validate_GetReposOwnerRepoStatsCodeFrequency_38987703, base: "/",
    url: url_GetReposOwnerRepoStatsCodeFrequency_38987704, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsCommitActivity_38987712 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoStatsCommitActivity_38987714(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/commit_activity")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsCommitActivity_38987713(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get the last year of commit activity data.
  ## Returns the last year of commit activity grouped by week. The days array
  ## is a group of commits per day, starting on Sunday.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987715 = path.getOrDefault("owner")
  valid_38987715 = validateParameter(valid_38987715, JString, required = true,
                                   default = nil)
  if valid_38987715 != nil:
    section.add "owner", valid_38987715
  var valid_38987716 = path.getOrDefault("repo")
  valid_38987716 = validateParameter(valid_38987716, JString, required = true,
                                   default = nil)
  if valid_38987716 != nil:
    section.add "repo", valid_38987716
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987717 = header.getOrDefault("Accept")
  valid_38987717 = validateParameter(valid_38987717, JString, required = false,
                                   default = nil)
  if valid_38987717 != nil:
    section.add "Accept", valid_38987717
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987718: Call_GetReposOwnerRepoStatsCommitActivity_38987712;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get the last year of commit activity data.
  ## Returns the last year of commit activity grouped by week. The days array
  ## is a group of commits per day, starting on Sunday.
  ## 
  ## 
  let valid = call_38987718.validator(path, query, header, formData, body, _)
  let scheme = call_38987718.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987718.url(scheme.get, call_38987718.host, call_38987718.base,
                           call_38987718.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987718, url, valid, _)

proc call*(call_38987719: Call_GetReposOwnerRepoStatsCommitActivity_38987712;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsCommitActivity
  ## Get the last year of commit activity data.
  ## Returns the last year of commit activity grouped by week. The days array
  ## is a group of commits per day, starting on Sunday.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987720 = newJObject()
  var header_38987721 = newJObject()
  add(path_38987720, "owner", newJString(owner))
  add(header_38987721, "Accept", newJString(Accept))
  add(path_38987720, "repo", newJString(repo))
  result = call_38987719.call(path_38987720, nil, header_38987721, nil, nil)

var getReposOwnerRepoStatsCommitActivity* = Call_GetReposOwnerRepoStatsCommitActivity_38987712(
    name: "getReposOwnerRepoStatsCommitActivity", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/commit_activity",
    validator: validate_GetReposOwnerRepoStatsCommitActivity_38987713, base: "/",
    url: url_GetReposOwnerRepoStatsCommitActivity_38987714,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsContributors_38987722 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoStatsContributors_38987724(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/contributors")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsContributors_38987723(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get contributors list with additions, deletions, and commit counts.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987725 = path.getOrDefault("owner")
  valid_38987725 = validateParameter(valid_38987725, JString, required = true,
                                   default = nil)
  if valid_38987725 != nil:
    section.add "owner", valid_38987725
  var valid_38987726 = path.getOrDefault("repo")
  valid_38987726 = validateParameter(valid_38987726, JString, required = true,
                                   default = nil)
  if valid_38987726 != nil:
    section.add "repo", valid_38987726
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987727 = header.getOrDefault("Accept")
  valid_38987727 = validateParameter(valid_38987727, JString, required = false,
                                   default = nil)
  if valid_38987727 != nil:
    section.add "Accept", valid_38987727
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987728: Call_GetReposOwnerRepoStatsContributors_38987722;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get contributors list with additions, deletions, and commit counts.
  ## 
  let valid = call_38987728.validator(path, query, header, formData, body, _)
  let scheme = call_38987728.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987728.url(scheme.get, call_38987728.host, call_38987728.base,
                           call_38987728.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987728, url, valid, _)

proc call*(call_38987729: Call_GetReposOwnerRepoStatsContributors_38987722;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsContributors
  ## Get contributors list with additions, deletions, and commit counts.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987730 = newJObject()
  var header_38987731 = newJObject()
  add(path_38987730, "owner", newJString(owner))
  add(header_38987731, "Accept", newJString(Accept))
  add(path_38987730, "repo", newJString(repo))
  result = call_38987729.call(path_38987730, nil, header_38987731, nil, nil)

var getReposOwnerRepoStatsContributors* = Call_GetReposOwnerRepoStatsContributors_38987722(
    name: "getReposOwnerRepoStatsContributors", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/contributors",
    validator: validate_GetReposOwnerRepoStatsContributors_38987723, base: "/",
    url: url_GetReposOwnerRepoStatsContributors_38987724, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsParticipation_38987732 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoStatsParticipation_38987734(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/participation")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsParticipation_38987733(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get the weekly commit count for the repo owner and everyone else.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987735 = path.getOrDefault("owner")
  valid_38987735 = validateParameter(valid_38987735, JString, required = true,
                                   default = nil)
  if valid_38987735 != nil:
    section.add "owner", valid_38987735
  var valid_38987736 = path.getOrDefault("repo")
  valid_38987736 = validateParameter(valid_38987736, JString, required = true,
                                   default = nil)
  if valid_38987736 != nil:
    section.add "repo", valid_38987736
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987737 = header.getOrDefault("Accept")
  valid_38987737 = validateParameter(valid_38987737, JString, required = false,
                                   default = nil)
  if valid_38987737 != nil:
    section.add "Accept", valid_38987737
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987738: Call_GetReposOwnerRepoStatsParticipation_38987732;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get the weekly commit count for the repo owner and everyone else.
  ## 
  let valid = call_38987738.validator(path, query, header, formData, body, _)
  let scheme = call_38987738.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987738.url(scheme.get, call_38987738.host, call_38987738.base,
                           call_38987738.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987738, url, valid, _)

proc call*(call_38987739: Call_GetReposOwnerRepoStatsParticipation_38987732;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsParticipation
  ## Get the weekly commit count for the repo owner and everyone else.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987740 = newJObject()
  var header_38987741 = newJObject()
  add(path_38987740, "owner", newJString(owner))
  add(header_38987741, "Accept", newJString(Accept))
  add(path_38987740, "repo", newJString(repo))
  result = call_38987739.call(path_38987740, nil, header_38987741, nil, nil)

var getReposOwnerRepoStatsParticipation* = Call_GetReposOwnerRepoStatsParticipation_38987732(
    name: "getReposOwnerRepoStatsParticipation", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/participation",
    validator: validate_GetReposOwnerRepoStatsParticipation_38987733, base: "/",
    url: url_GetReposOwnerRepoStatsParticipation_38987734, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsPunchCard_38987742 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoStatsPunchCard_38987744(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/punch_card")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsPunchCard_38987743(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get the number of commits per hour in each day.
  ## Each array contains the day number, hour number, and number of commits
  ## 0-6 Sunday - Saturday
  ## 0-23 Hour of day
  ## Number of commits
  ## 
  ## For example, [2, 14, 25] indicates that there were 25 total commits, during
  ## the 2.00pm hour on Tuesdays. All times are based on the time zone of
  ## individual commits.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987745 = path.getOrDefault("owner")
  valid_38987745 = validateParameter(valid_38987745, JString, required = true,
                                   default = nil)
  if valid_38987745 != nil:
    section.add "owner", valid_38987745
  var valid_38987746 = path.getOrDefault("repo")
  valid_38987746 = validateParameter(valid_38987746, JString, required = true,
                                   default = nil)
  if valid_38987746 != nil:
    section.add "repo", valid_38987746
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987747 = header.getOrDefault("Accept")
  valid_38987747 = validateParameter(valid_38987747, JString, required = false,
                                   default = nil)
  if valid_38987747 != nil:
    section.add "Accept", valid_38987747
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987748: Call_GetReposOwnerRepoStatsPunchCard_38987742;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get the number of commits per hour in each day.
  ## Each array contains the day number, hour number, and number of commits
  ## 0-6 Sunday - Saturday
  ## 0-23 Hour of day
  ## Number of commits
  ## 
  ## For example, [2, 14, 25] indicates that there were 25 total commits, during
  ## the 2.00pm hour on Tuesdays. All times are based on the time zone of
  ## individual commits.
  ## 
  ## 
  let valid = call_38987748.validator(path, query, header, formData, body, _)
  let scheme = call_38987748.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987748.url(scheme.get, call_38987748.host, call_38987748.base,
                           call_38987748.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987748, url, valid, _)

proc call*(call_38987749: Call_GetReposOwnerRepoStatsPunchCard_38987742;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsPunchCard
  ## Get the number of commits per hour in each day.
  ## Each array contains the day number, hour number, and number of commits
  ## 0-6 Sunday - Saturday
  ## 0-23 Hour of day
  ## Number of commits
  ## 
  ## For example, [2, 14, 25] indicates that there were 25 total commits, during
  ## the 2.00pm hour on Tuesdays. All times are based on the time zone of
  ## individual commits.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987750 = newJObject()
  var header_38987751 = newJObject()
  add(path_38987750, "owner", newJString(owner))
  add(header_38987751, "Accept", newJString(Accept))
  add(path_38987750, "repo", newJString(repo))
  result = call_38987749.call(path_38987750, nil, header_38987751, nil, nil)

var getReposOwnerRepoStatsPunchCard* = Call_GetReposOwnerRepoStatsPunchCard_38987742(
    name: "getReposOwnerRepoStatsPunchCard", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/punch_card",
    validator: validate_GetReposOwnerRepoStatsPunchCard_38987743, base: "/",
    url: url_GetReposOwnerRepoStatsPunchCard_38987744, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoStatusesRef_38987763 = ref object of OpenApiRestCall_38985352
proc url_PostReposOwnerRepoStatusesRef_38987765(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/statuses/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoStatusesRef_38987764(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Create a Status.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   ref: JString (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987766 = path.getOrDefault("owner")
  valid_38987766 = validateParameter(valid_38987766, JString, required = true,
                                   default = nil)
  if valid_38987766 != nil:
    section.add "owner", valid_38987766
  var valid_38987767 = path.getOrDefault("ref")
  valid_38987767 = validateParameter(valid_38987767, JString, required = true,
                                   default = nil)
  if valid_38987767 != nil:
    section.add "ref", valid_38987767
  var valid_38987768 = path.getOrDefault("repo")
  valid_38987768 = validateParameter(valid_38987768, JString, required = true,
                                   default = nil)
  if valid_38987768 != nil:
    section.add "repo", valid_38987768
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987769 = header.getOrDefault("Accept")
  valid_38987769 = validateParameter(valid_38987769, JString, required = false,
                                   default = nil)
  if valid_38987769 != nil:
    section.add "Accept", valid_38987769
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38987771: Call_PostReposOwnerRepoStatusesRef_38987763;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a Status.
  ## 
  let valid = call_38987771.validator(path, query, header, formData, body, _)
  let scheme = call_38987771.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987771.url(scheme.get, call_38987771.host, call_38987771.base,
                           call_38987771.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987771, url, valid, _)

proc call*(call_38987772: Call_PostReposOwnerRepoStatusesRef_38987763;
          owner: string; `ref`: string; body: JsonNode; repo: string;
          Accept: string = ""): Recallable =
  ## postReposOwnerRepoStatusesRef
  ## Create a Status.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   ref: string (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987773 = newJObject()
  var header_38987774 = newJObject()
  var body_38987775 = newJObject()
  add(path_38987773, "owner", newJString(owner))
  add(path_38987773, "ref", newJString(`ref`))
  add(header_38987774, "Accept", newJString(Accept))
  if body != nil:
    body_38987775 = body
  add(path_38987773, "repo", newJString(repo))
  result = call_38987772.call(path_38987773, nil, header_38987774, nil, body_38987775)

var postReposOwnerRepoStatusesRef* = Call_PostReposOwnerRepoStatusesRef_38987763(
    name: "postReposOwnerRepoStatusesRef", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/statuses/{ref}",
    validator: validate_PostReposOwnerRepoStatusesRef_38987764, base: "/",
    url: url_PostReposOwnerRepoStatusesRef_38987765, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatusesRef_38987752 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoStatusesRef_38987754(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/statuses/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatusesRef_38987753(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List Statuses for a specific Ref.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   ref: JString (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987755 = path.getOrDefault("owner")
  valid_38987755 = validateParameter(valid_38987755, JString, required = true,
                                   default = nil)
  if valid_38987755 != nil:
    section.add "owner", valid_38987755
  var valid_38987756 = path.getOrDefault("ref")
  valid_38987756 = validateParameter(valid_38987756, JString, required = true,
                                   default = nil)
  if valid_38987756 != nil:
    section.add "ref", valid_38987756
  var valid_38987757 = path.getOrDefault("repo")
  valid_38987757 = validateParameter(valid_38987757, JString, required = true,
                                   default = nil)
  if valid_38987757 != nil:
    section.add "repo", valid_38987757
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987758 = header.getOrDefault("Accept")
  valid_38987758 = validateParameter(valid_38987758, JString, required = false,
                                   default = nil)
  if valid_38987758 != nil:
    section.add "Accept", valid_38987758
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987759: Call_GetReposOwnerRepoStatusesRef_38987752;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List Statuses for a specific Ref.
  ## 
  let valid = call_38987759.validator(path, query, header, formData, body, _)
  let scheme = call_38987759.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987759.url(scheme.get, call_38987759.host, call_38987759.base,
                           call_38987759.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987759, url, valid, _)

proc call*(call_38987760: Call_GetReposOwnerRepoStatusesRef_38987752;
          owner: string; `ref`: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatusesRef
  ## List Statuses for a specific Ref.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   ref: string (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987761 = newJObject()
  var header_38987762 = newJObject()
  add(path_38987761, "owner", newJString(owner))
  add(path_38987761, "ref", newJString(`ref`))
  add(header_38987762, "Accept", newJString(Accept))
  add(path_38987761, "repo", newJString(repo))
  result = call_38987760.call(path_38987761, nil, header_38987762, nil, nil)

var getReposOwnerRepoStatusesRef* = Call_GetReposOwnerRepoStatusesRef_38987752(
    name: "getReposOwnerRepoStatusesRef", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/statuses/{ref}",
    validator: validate_GetReposOwnerRepoStatusesRef_38987753, base: "/",
    url: url_GetReposOwnerRepoStatusesRef_38987754, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoSubscribers_38987776 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoSubscribers_38987778(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/subscribers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoSubscribers_38987777(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List watchers.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987779 = path.getOrDefault("owner")
  valid_38987779 = validateParameter(valid_38987779, JString, required = true,
                                   default = nil)
  if valid_38987779 != nil:
    section.add "owner", valid_38987779
  var valid_38987780 = path.getOrDefault("repo")
  valid_38987780 = validateParameter(valid_38987780, JString, required = true,
                                   default = nil)
  if valid_38987780 != nil:
    section.add "repo", valid_38987780
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987781 = header.getOrDefault("Accept")
  valid_38987781 = validateParameter(valid_38987781, JString, required = false,
                                   default = nil)
  if valid_38987781 != nil:
    section.add "Accept", valid_38987781
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987782: Call_GetReposOwnerRepoSubscribers_38987776;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List watchers.
  ## 
  let valid = call_38987782.validator(path, query, header, formData, body, _)
  let scheme = call_38987782.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987782.url(scheme.get, call_38987782.host, call_38987782.base,
                           call_38987782.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987782, url, valid, _)

proc call*(call_38987783: Call_GetReposOwnerRepoSubscribers_38987776;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoSubscribers
  ## List watchers.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987784 = newJObject()
  var header_38987785 = newJObject()
  add(path_38987784, "owner", newJString(owner))
  add(header_38987785, "Accept", newJString(Accept))
  add(path_38987784, "repo", newJString(repo))
  result = call_38987783.call(path_38987784, nil, header_38987785, nil, nil)

var getReposOwnerRepoSubscribers* = Call_GetReposOwnerRepoSubscribers_38987776(
    name: "getReposOwnerRepoSubscribers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscribers",
    validator: validate_GetReposOwnerRepoSubscribers_38987777, base: "/",
    url: url_GetReposOwnerRepoSubscribers_38987778, schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoSubscription_38987796 = ref object of OpenApiRestCall_38985352
proc url_PutReposOwnerRepoSubscription_38987798(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoSubscription_38987797(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Set a Repository Subscription
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987799 = path.getOrDefault("owner")
  valid_38987799 = validateParameter(valid_38987799, JString, required = true,
                                   default = nil)
  if valid_38987799 != nil:
    section.add "owner", valid_38987799
  var valid_38987800 = path.getOrDefault("repo")
  valid_38987800 = validateParameter(valid_38987800, JString, required = true,
                                   default = nil)
  if valid_38987800 != nil:
    section.add "repo", valid_38987800
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987801 = header.getOrDefault("Accept")
  valid_38987801 = validateParameter(valid_38987801, JString, required = false,
                                   default = nil)
  if valid_38987801 != nil:
    section.add "Accept", valid_38987801
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38987803: Call_PutReposOwnerRepoSubscription_38987796;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Set a Repository Subscription
  ## 
  let valid = call_38987803.validator(path, query, header, formData, body, _)
  let scheme = call_38987803.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987803.url(scheme.get, call_38987803.host, call_38987803.base,
                           call_38987803.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987803, url, valid, _)

proc call*(call_38987804: Call_PutReposOwnerRepoSubscription_38987796;
          owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoSubscription
  ## Set a Repository Subscription
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987805 = newJObject()
  var header_38987806 = newJObject()
  var body_38987807 = newJObject()
  add(path_38987805, "owner", newJString(owner))
  add(header_38987806, "Accept", newJString(Accept))
  if body != nil:
    body_38987807 = body
  add(path_38987805, "repo", newJString(repo))
  result = call_38987804.call(path_38987805, nil, header_38987806, nil, body_38987807)

var putReposOwnerRepoSubscription* = Call_PutReposOwnerRepoSubscription_38987796(
    name: "putReposOwnerRepoSubscription", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscription",
    validator: validate_PutReposOwnerRepoSubscription_38987797, base: "/",
    url: url_PutReposOwnerRepoSubscription_38987798, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoSubscription_38987786 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoSubscription_38987788(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoSubscription_38987787(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a Repository Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987789 = path.getOrDefault("owner")
  valid_38987789 = validateParameter(valid_38987789, JString, required = true,
                                   default = nil)
  if valid_38987789 != nil:
    section.add "owner", valid_38987789
  var valid_38987790 = path.getOrDefault("repo")
  valid_38987790 = validateParameter(valid_38987790, JString, required = true,
                                   default = nil)
  if valid_38987790 != nil:
    section.add "repo", valid_38987790
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987791 = header.getOrDefault("Accept")
  valid_38987791 = validateParameter(valid_38987791, JString, required = false,
                                   default = nil)
  if valid_38987791 != nil:
    section.add "Accept", valid_38987791
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987792: Call_GetReposOwnerRepoSubscription_38987786;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a Repository Subscription.
  ## 
  let valid = call_38987792.validator(path, query, header, formData, body, _)
  let scheme = call_38987792.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987792.url(scheme.get, call_38987792.host, call_38987792.base,
                           call_38987792.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987792, url, valid, _)

proc call*(call_38987793: Call_GetReposOwnerRepoSubscription_38987786;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoSubscription
  ## Get a Repository Subscription.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987794 = newJObject()
  var header_38987795 = newJObject()
  add(path_38987794, "owner", newJString(owner))
  add(header_38987795, "Accept", newJString(Accept))
  add(path_38987794, "repo", newJString(repo))
  result = call_38987793.call(path_38987794, nil, header_38987795, nil, nil)

var getReposOwnerRepoSubscription* = Call_GetReposOwnerRepoSubscription_38987786(
    name: "getReposOwnerRepoSubscription", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscription",
    validator: validate_GetReposOwnerRepoSubscription_38987787, base: "/",
    url: url_GetReposOwnerRepoSubscription_38987788, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoSubscription_38987808 = ref object of OpenApiRestCall_38985352
proc url_DeleteReposOwnerRepoSubscription_38987810(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoSubscription_38987809(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a Repository Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987811 = path.getOrDefault("owner")
  valid_38987811 = validateParameter(valid_38987811, JString, required = true,
                                   default = nil)
  if valid_38987811 != nil:
    section.add "owner", valid_38987811
  var valid_38987812 = path.getOrDefault("repo")
  valid_38987812 = validateParameter(valid_38987812, JString, required = true,
                                   default = nil)
  if valid_38987812 != nil:
    section.add "repo", valid_38987812
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987813 = header.getOrDefault("Accept")
  valid_38987813 = validateParameter(valid_38987813, JString, required = false,
                                   default = nil)
  if valid_38987813 != nil:
    section.add "Accept", valid_38987813
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987814: Call_DeleteReposOwnerRepoSubscription_38987808;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a Repository Subscription.
  ## 
  let valid = call_38987814.validator(path, query, header, formData, body, _)
  let scheme = call_38987814.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987814.url(scheme.get, call_38987814.host, call_38987814.base,
                           call_38987814.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987814, url, valid, _)

proc call*(call_38987815: Call_DeleteReposOwnerRepoSubscription_38987808;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoSubscription
  ## Delete a Repository Subscription.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987816 = newJObject()
  var header_38987817 = newJObject()
  add(path_38987816, "owner", newJString(owner))
  add(header_38987817, "Accept", newJString(Accept))
  add(path_38987816, "repo", newJString(repo))
  result = call_38987815.call(path_38987816, nil, header_38987817, nil, nil)

var deleteReposOwnerRepoSubscription* = Call_DeleteReposOwnerRepoSubscription_38987808(
    name: "deleteReposOwnerRepoSubscription", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscription",
    validator: validate_DeleteReposOwnerRepoSubscription_38987809, base: "/",
    url: url_DeleteReposOwnerRepoSubscription_38987810, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoTags_38987818 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoTags_38987820(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/tags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoTags_38987819(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get list of tags.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987821 = path.getOrDefault("owner")
  valid_38987821 = validateParameter(valid_38987821, JString, required = true,
                                   default = nil)
  if valid_38987821 != nil:
    section.add "owner", valid_38987821
  var valid_38987822 = path.getOrDefault("repo")
  valid_38987822 = validateParameter(valid_38987822, JString, required = true,
                                   default = nil)
  if valid_38987822 != nil:
    section.add "repo", valid_38987822
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987823 = header.getOrDefault("Accept")
  valid_38987823 = validateParameter(valid_38987823, JString, required = false,
                                   default = nil)
  if valid_38987823 != nil:
    section.add "Accept", valid_38987823
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987824: Call_GetReposOwnerRepoTags_38987818;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get list of tags.
  ## 
  let valid = call_38987824.validator(path, query, header, formData, body, _)
  let scheme = call_38987824.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987824.url(scheme.get, call_38987824.host, call_38987824.base,
                           call_38987824.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987824, url, valid, _)

proc call*(call_38987825: Call_GetReposOwnerRepoTags_38987818; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoTags
  ## Get list of tags.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987826 = newJObject()
  var header_38987827 = newJObject()
  add(path_38987826, "owner", newJString(owner))
  add(header_38987827, "Accept", newJString(Accept))
  add(path_38987826, "repo", newJString(repo))
  result = call_38987825.call(path_38987826, nil, header_38987827, nil, nil)

var getReposOwnerRepoTags* = Call_GetReposOwnerRepoTags_38987818(
    name: "getReposOwnerRepoTags", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/repos/{owner}/{repo}/tags",
    validator: validate_GetReposOwnerRepoTags_38987819, base: "/",
    url: url_GetReposOwnerRepoTags_38987820, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoTeams_38987828 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoTeams_38987830(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/teams")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoTeams_38987829(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get list of teams
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987831 = path.getOrDefault("owner")
  valid_38987831 = validateParameter(valid_38987831, JString, required = true,
                                   default = nil)
  if valid_38987831 != nil:
    section.add "owner", valid_38987831
  var valid_38987832 = path.getOrDefault("repo")
  valid_38987832 = validateParameter(valid_38987832, JString, required = true,
                                   default = nil)
  if valid_38987832 != nil:
    section.add "repo", valid_38987832
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987833 = header.getOrDefault("Accept")
  valid_38987833 = validateParameter(valid_38987833, JString, required = false,
                                   default = nil)
  if valid_38987833 != nil:
    section.add "Accept", valid_38987833
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987834: Call_GetReposOwnerRepoTeams_38987828;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get list of teams
  ## 
  let valid = call_38987834.validator(path, query, header, formData, body, _)
  let scheme = call_38987834.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987834.url(scheme.get, call_38987834.host, call_38987834.base,
                           call_38987834.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987834, url, valid, _)

proc call*(call_38987835: Call_GetReposOwnerRepoTeams_38987828; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoTeams
  ## Get list of teams
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987836 = newJObject()
  var header_38987837 = newJObject()
  add(path_38987836, "owner", newJString(owner))
  add(header_38987837, "Accept", newJString(Accept))
  add(path_38987836, "repo", newJString(repo))
  result = call_38987835.call(path_38987836, nil, header_38987837, nil, nil)

var getReposOwnerRepoTeams* = Call_GetReposOwnerRepoTeams_38987828(
    name: "getReposOwnerRepoTeams", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/teams",
    validator: validate_GetReposOwnerRepoTeams_38987829, base: "/",
    url: url_GetReposOwnerRepoTeams_38987830, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoWatchers_38987838 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoWatchers_38987840(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/watchers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoWatchers_38987839(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List Stargazers. New implementation.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987841 = path.getOrDefault("owner")
  valid_38987841 = validateParameter(valid_38987841, JString, required = true,
                                   default = nil)
  if valid_38987841 != nil:
    section.add "owner", valid_38987841
  var valid_38987842 = path.getOrDefault("repo")
  valid_38987842 = validateParameter(valid_38987842, JString, required = true,
                                   default = nil)
  if valid_38987842 != nil:
    section.add "repo", valid_38987842
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987843 = header.getOrDefault("Accept")
  valid_38987843 = validateParameter(valid_38987843, JString, required = false,
                                   default = nil)
  if valid_38987843 != nil:
    section.add "Accept", valid_38987843
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987844: Call_GetReposOwnerRepoWatchers_38987838;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List Stargazers. New implementation.
  ## 
  let valid = call_38987844.validator(path, query, header, formData, body, _)
  let scheme = call_38987844.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987844.url(scheme.get, call_38987844.host, call_38987844.base,
                           call_38987844.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987844, url, valid, _)

proc call*(call_38987845: Call_GetReposOwnerRepoWatchers_38987838; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoWatchers
  ## List Stargazers. New implementation.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38987846 = newJObject()
  var header_38987847 = newJObject()
  add(path_38987846, "owner", newJString(owner))
  add(header_38987847, "Accept", newJString(Accept))
  add(path_38987846, "repo", newJString(repo))
  result = call_38987845.call(path_38987846, nil, header_38987847, nil, nil)

var getReposOwnerRepoWatchers* = Call_GetReposOwnerRepoWatchers_38987838(
    name: "getReposOwnerRepoWatchers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/watchers",
    validator: validate_GetReposOwnerRepoWatchers_38987839, base: "/",
    url: url_GetReposOwnerRepoWatchers_38987840, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoArchiveFormatPath_38987848 = ref object of OpenApiRestCall_38985352
proc url_GetReposOwnerRepoArchiveFormatPath_38987850(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "archive_format" in path, "`archive_format` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "archive_format"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoArchiveFormatPath_38987849(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get archive link.
  ## This method will return a 302 to a URL to download a tarball or zipball
  ## archive for a repository. Please make sure your HTTP framework is
  ## configured to follow redirects or you will need to use the Location header
  ## to make a second GET request.
  ## Note: For private repositories, these links are temporary and expire quickly.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   archive_format: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   path: JString (required)
  ##       : Valid Git reference, defaults to 'master'.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38987851 = path.getOrDefault("owner")
  valid_38987851 = validateParameter(valid_38987851, JString, required = true,
                                   default = nil)
  if valid_38987851 != nil:
    section.add "owner", valid_38987851
  var valid_38987852 = path.getOrDefault("archive_format")
  valid_38987852 = validateParameter(valid_38987852, JString, required = true,
                                   default = newJString("tarball"))
  if valid_38987852 != nil:
    section.add "archive_format", valid_38987852
  var valid_38987853 = path.getOrDefault("repo")
  valid_38987853 = validateParameter(valid_38987853, JString, required = true,
                                   default = nil)
  if valid_38987853 != nil:
    section.add "repo", valid_38987853
  var valid_38987854 = path.getOrDefault("path")
  valid_38987854 = validateParameter(valid_38987854, JString, required = true,
                                   default = nil)
  if valid_38987854 != nil:
    section.add "path", valid_38987854
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987855 = header.getOrDefault("Accept")
  valid_38987855 = validateParameter(valid_38987855, JString, required = false,
                                   default = nil)
  if valid_38987855 != nil:
    section.add "Accept", valid_38987855
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987856: Call_GetReposOwnerRepoArchiveFormatPath_38987848;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get archive link.
  ## This method will return a 302 to a URL to download a tarball or zipball
  ## archive for a repository. Please make sure your HTTP framework is
  ## configured to follow redirects or you will need to use the Location header
  ## to make a second GET request.
  ## Note: For private repositories, these links are temporary and expire quickly.
  ## 
  ## 
  let valid = call_38987856.validator(path, query, header, formData, body, _)
  let scheme = call_38987856.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987856.url(scheme.get, call_38987856.host, call_38987856.base,
                           call_38987856.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987856, url, valid, _)

proc call*(call_38987857: Call_GetReposOwnerRepoArchiveFormatPath_38987848;
          owner: string; repo: string; path: string;
          archiveFormat: string = "tarball"; Accept: string = ""): Recallable =
  ## getReposOwnerRepoArchiveFormatPath
  ## Get archive link.
  ## This method will return a 302 to a URL to download a tarball or zipball
  ## archive for a repository. Please make sure your HTTP framework is
  ## configured to follow redirects or you will need to use the Location header
  ## to make a second GET request.
  ## Note: For private repositories, these links are temporary and expire quickly.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   archiveFormat: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   path: string (required)
  ##       : Valid Git reference, defaults to 'master'.
  var path_38987858 = newJObject()
  var header_38987859 = newJObject()
  add(path_38987858, "owner", newJString(owner))
  add(path_38987858, "archive_format", newJString(archiveFormat))
  add(header_38987859, "Accept", newJString(Accept))
  add(path_38987858, "repo", newJString(repo))
  add(path_38987858, "path", newJString(path))
  result = call_38987857.call(path_38987858, nil, header_38987859, nil, nil)

var getReposOwnerRepoArchiveFormatPath* = Call_GetReposOwnerRepoArchiveFormatPath_38987848(
    name: "getReposOwnerRepoArchiveFormatPath", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/{archive_format}/{path}",
    validator: validate_GetReposOwnerRepoArchiveFormatPath_38987849, base: "/",
    url: url_GetReposOwnerRepoArchiveFormatPath_38987850, schemes: {Scheme.Https})
type
  Call_GetRepositories_38987860 = ref object of OpenApiRestCall_38985352
proc url_GetRepositories_38987862(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRepositories_38987861(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List all public repositories.
  ## This provides a dump of every public repository, in the order that they
  ## were created.
  ## Note: Pagination is powered exclusively by the since parameter. is the
  ## Link header to get the URL for the next page of repositories.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_38987863 = query.getOrDefault("since")
  valid_38987863 = validateParameter(valid_38987863, JString, required = false,
                                   default = nil)
  if valid_38987863 != nil:
    section.add "since", valid_38987863
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987864 = header.getOrDefault("Accept")
  valid_38987864 = validateParameter(valid_38987864, JString, required = false,
                                   default = nil)
  if valid_38987864 != nil:
    section.add "Accept", valid_38987864
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987865: Call_GetRepositories_38987860; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List all public repositories.
  ## This provides a dump of every public repository, in the order that they
  ## were created.
  ## Note: Pagination is powered exclusively by the since parameter. is the
  ## Link header to get the URL for the next page of repositories.
  ## 
  ## 
  let valid = call_38987865.validator(path, query, header, formData, body, _)
  let scheme = call_38987865.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987865.url(scheme.get, call_38987865.host, call_38987865.base,
                           call_38987865.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987865, url, valid, _)

proc call*(call_38987866: Call_GetRepositories_38987860; Accept: string = "";
          since: string = ""): Recallable =
  ## getRepositories
  ## List all public repositories.
  ## This provides a dump of every public repository, in the order that they
  ## were created.
  ## Note: Pagination is powered exclusively by the since parameter. is the
  ## Link header to get the URL for the next page of repositories.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var query_38987867 = newJObject()
  var header_38987868 = newJObject()
  add(header_38987868, "Accept", newJString(Accept))
  add(query_38987867, "since", newJString(since))
  result = call_38987866.call(nil, query_38987867, header_38987868, nil, nil)

var getRepositories* = Call_GetRepositories_38987860(name: "getRepositories",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/repositories",
    validator: validate_GetRepositories_38987861, base: "/",
    url: url_GetRepositories_38987862, schemes: {Scheme.Https})
type
  Call_GetSearchCode_38987869 = ref object of OpenApiRestCall_38985352
proc url_GetSearchCode_38987871(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchCode_38987870(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## Search code.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   sort: JString
  ##       : Can only be 'indexed', which indicates how recently a file has been indexed
  ## by the GitHub search infrastructure. If not provided, results are sorted
  ## by best match.
  ## 
  ##   q: JString (required)
  ##    : The search terms. This can be any combination of the supported code
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier
  ## you can restrict the search to just the file contents, the file path,
  ## or both.
  ## 'Languages' Searches code based on the language it's written in.
  ## 'Forks' Filters repositories based on the number of forks, and/or
  ## whether code from forked repositories should be included in the results
  ## at all.
  ## 'Size' Finds files that match a certain size (in bytes).
  ## 'Path' Specifies the path that the resulting file must be at.
  ## 'Extension' Matches files with a certain extension.
  ## 'Users' or 'Repositories' Limits searches to a specific user or repository.
  ## 
  section = newJObject()
  var valid_38987872 = query.getOrDefault("order")
  valid_38987872 = validateParameter(valid_38987872, JString, required = false,
                                   default = newJString("desc"))
  if valid_38987872 != nil:
    section.add "order", valid_38987872
  var valid_38987873 = query.getOrDefault("sort")
  valid_38987873 = validateParameter(valid_38987873, JString, required = false,
                                   default = newJString("indexed"))
  if valid_38987873 != nil:
    section.add "sort", valid_38987873
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_38987874 = query.getOrDefault("q")
  valid_38987874 = validateParameter(valid_38987874, JString, required = true,
                                   default = nil)
  if valid_38987874 != nil:
    section.add "q", valid_38987874
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987875 = header.getOrDefault("Accept")
  valid_38987875 = validateParameter(valid_38987875, JString, required = false,
                                   default = nil)
  if valid_38987875 != nil:
    section.add "Accept", valid_38987875
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987876: Call_GetSearchCode_38987869; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Search code.
  ## 
  let valid = call_38987876.validator(path, query, header, formData, body, _)
  let scheme = call_38987876.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987876.url(scheme.get, call_38987876.host, call_38987876.base,
                           call_38987876.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987876, url, valid, _)

proc call*(call_38987877: Call_GetSearchCode_38987869; q: string;
          order: string = "desc"; Accept: string = ""; sort: string = "indexed"): Recallable =
  ## getSearchCode
  ## Search code.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##       : Can only be 'indexed', which indicates how recently a file has been indexed
  ## by the GitHub search infrastructure. If not provided, results are sorted
  ## by best match.
  ## 
  ##   q: string (required)
  ##    : The search terms. This can be any combination of the supported code
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier
  ## you can restrict the search to just the file contents, the file path,
  ## or both.
  ## 'Languages' Searches code based on the language it's written in.
  ## 'Forks' Filters repositories based on the number of forks, and/or
  ## whether code from forked repositories should be included in the results
  ## at all.
  ## 'Size' Finds files that match a certain size (in bytes).
  ## 'Path' Specifies the path that the resulting file must be at.
  ## 'Extension' Matches files with a certain extension.
  ## 'Users' or 'Repositories' Limits searches to a specific user or repository.
  ## 
  var query_38987878 = newJObject()
  var header_38987879 = newJObject()
  add(query_38987878, "order", newJString(order))
  add(header_38987879, "Accept", newJString(Accept))
  add(query_38987878, "sort", newJString(sort))
  add(query_38987878, "q", newJString(q))
  result = call_38987877.call(nil, query_38987878, header_38987879, nil, nil)

var getSearchCode* = Call_GetSearchCode_38987869(name: "getSearchCode",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/search/code",
    validator: validate_GetSearchCode_38987870, base: "/", url: url_GetSearchCode_38987871,
    schemes: {Scheme.Https})
type
  Call_GetSearchIssues_38987880 = ref object of OpenApiRestCall_38985352
proc url_GetSearchIssues_38987882(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchIssues_38987881(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Find issues by state and keyword. (This method returns up to 100 results per page.)
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   sort: JString
  ##       : The sort field. Can be comments, created, or updated. Default: results are sorted by best match.
  ##   q: JString (required)
  ##    : The q search term can also contain any combination of the supported issue search qualifiers:
  section = newJObject()
  var valid_38987883 = query.getOrDefault("order")
  valid_38987883 = validateParameter(valid_38987883, JString, required = false,
                                   default = newJString("desc"))
  if valid_38987883 != nil:
    section.add "order", valid_38987883
  var valid_38987884 = query.getOrDefault("sort")
  valid_38987884 = validateParameter(valid_38987884, JString, required = false,
                                   default = newJString("updated"))
  if valid_38987884 != nil:
    section.add "sort", valid_38987884
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_38987885 = query.getOrDefault("q")
  valid_38987885 = validateParameter(valid_38987885, JString, required = true,
                                   default = nil)
  if valid_38987885 != nil:
    section.add "q", valid_38987885
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987886 = header.getOrDefault("Accept")
  valid_38987886 = validateParameter(valid_38987886, JString, required = false,
                                   default = nil)
  if valid_38987886 != nil:
    section.add "Accept", valid_38987886
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987887: Call_GetSearchIssues_38987880; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Find issues by state and keyword. (This method returns up to 100 results per page.)
  ## 
  let valid = call_38987887.validator(path, query, header, formData, body, _)
  let scheme = call_38987887.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987887.url(scheme.get, call_38987887.host, call_38987887.base,
                           call_38987887.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987887, url, valid, _)

proc call*(call_38987888: Call_GetSearchIssues_38987880; q: string;
          order: string = "desc"; Accept: string = ""; sort: string = "updated"): Recallable =
  ## getSearchIssues
  ## Find issues by state and keyword. (This method returns up to 100 results per page.)
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##       : The sort field. Can be comments, created, or updated. Default: results are sorted by best match.
  ##   q: string (required)
  ##    : The q search term can also contain any combination of the supported issue search qualifiers:
  var query_38987889 = newJObject()
  var header_38987890 = newJObject()
  add(query_38987889, "order", newJString(order))
  add(header_38987890, "Accept", newJString(Accept))
  add(query_38987889, "sort", newJString(sort))
  add(query_38987889, "q", newJString(q))
  result = call_38987888.call(nil, query_38987889, header_38987890, nil, nil)

var getSearchIssues* = Call_GetSearchIssues_38987880(name: "getSearchIssues",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/search/issues",
    validator: validate_GetSearchIssues_38987881, base: "/",
    url: url_GetSearchIssues_38987882, schemes: {Scheme.Https})
type
  Call_GetSearchRepositories_38987891 = ref object of OpenApiRestCall_38985352
proc url_GetSearchRepositories_38987893(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchRepositories_38987892(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Search repositories.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   sort: JString
  ##       : If not provided, results are sorted by best match.
  ##   q: JString (required)
  ##    : The search terms. This can be any combination of the supported repository
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the repository name, description, readme,
  ## or any combination of these.
  ## 'Size' Finds repositories that match a certain size (in kilobytes).
  ## 'Forks' Filters repositories based on the number of forks, and/or whether
  ## forked repositories should be included in the results at all.
  ## 'Created' and 'Last Updated' Filters repositories based on times of
  ## creation, or when they were last updated.
  ## 'Users or Repositories' Limits searches to a specific user or repository.
  ## 'Languages' Searches repositories based on the language they are written in.
  ## 'Stars' Searches repositories based on the number of stars.
  ## 
  section = newJObject()
  var valid_38987894 = query.getOrDefault("order")
  valid_38987894 = validateParameter(valid_38987894, JString, required = false,
                                   default = newJString("desc"))
  if valid_38987894 != nil:
    section.add "order", valid_38987894
  var valid_38987895 = query.getOrDefault("sort")
  valid_38987895 = validateParameter(valid_38987895, JString, required = false,
                                   default = newJString("stars"))
  if valid_38987895 != nil:
    section.add "sort", valid_38987895
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_38987896 = query.getOrDefault("q")
  valid_38987896 = validateParameter(valid_38987896, JString, required = true,
                                   default = nil)
  if valid_38987896 != nil:
    section.add "q", valid_38987896
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987897 = header.getOrDefault("Accept")
  valid_38987897 = validateParameter(valid_38987897, JString, required = false,
                                   default = nil)
  if valid_38987897 != nil:
    section.add "Accept", valid_38987897
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987898: Call_GetSearchRepositories_38987891;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Search repositories.
  ## 
  let valid = call_38987898.validator(path, query, header, formData, body, _)
  let scheme = call_38987898.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987898.url(scheme.get, call_38987898.host, call_38987898.base,
                           call_38987898.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987898, url, valid, _)

proc call*(call_38987899: Call_GetSearchRepositories_38987891; q: string;
          order: string = "desc"; Accept: string = ""; sort: string = "stars"): Recallable =
  ## getSearchRepositories
  ## Search repositories.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##       : If not provided, results are sorted by best match.
  ##   q: string (required)
  ##    : The search terms. This can be any combination of the supported repository
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the repository name, description, readme,
  ## or any combination of these.
  ## 'Size' Finds repositories that match a certain size (in kilobytes).
  ## 'Forks' Filters repositories based on the number of forks, and/or whether
  ## forked repositories should be included in the results at all.
  ## 'Created' and 'Last Updated' Filters repositories based on times of
  ## creation, or when they were last updated.
  ## 'Users or Repositories' Limits searches to a specific user or repository.
  ## 'Languages' Searches repositories based on the language they are written in.
  ## 'Stars' Searches repositories based on the number of stars.
  ## 
  var query_38987900 = newJObject()
  var header_38987901 = newJObject()
  add(query_38987900, "order", newJString(order))
  add(header_38987901, "Accept", newJString(Accept))
  add(query_38987900, "sort", newJString(sort))
  add(query_38987900, "q", newJString(q))
  result = call_38987899.call(nil, query_38987900, header_38987901, nil, nil)

var getSearchRepositories* = Call_GetSearchRepositories_38987891(
    name: "getSearchRepositories", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/search/repositories", validator: validate_GetSearchRepositories_38987892,
    base: "/", url: url_GetSearchRepositories_38987893, schemes: {Scheme.Https})
type
  Call_GetSearchUsers_38987902 = ref object of OpenApiRestCall_38985352
proc url_GetSearchUsers_38987904(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchUsers_38987903(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Search users.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   sort: JString
  ##       : If not provided, results are sorted by best match.
  ##   q: JString (required)
  ##    : The search terms. This can be any combination of the supported user
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the username, public email, full name,
  ## location, or any combination of these.
  ## 'Repository count' Filters users based on the number of repositories they
  ## have.
  ## 'Location' Filter users by the location indicated in their profile.
  ## 'Language' Search for users that have repositories that match a certain
  ## language.
  ## 'Created' Filter users based on when they joined.
  ## 'Followers' Filter users based on the number of followers they have.
  ## 
  section = newJObject()
  var valid_38987905 = query.getOrDefault("order")
  valid_38987905 = validateParameter(valid_38987905, JString, required = false,
                                   default = newJString("desc"))
  if valid_38987905 != nil:
    section.add "order", valid_38987905
  var valid_38987906 = query.getOrDefault("sort")
  valid_38987906 = validateParameter(valid_38987906, JString, required = false,
                                   default = newJString("followers"))
  if valid_38987906 != nil:
    section.add "sort", valid_38987906
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_38987907 = query.getOrDefault("q")
  valid_38987907 = validateParameter(valid_38987907, JString, required = true,
                                   default = nil)
  if valid_38987907 != nil:
    section.add "q", valid_38987907
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987908 = header.getOrDefault("Accept")
  valid_38987908 = validateParameter(valid_38987908, JString, required = false,
                                   default = nil)
  if valid_38987908 != nil:
    section.add "Accept", valid_38987908
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987909: Call_GetSearchUsers_38987902; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Search users.
  ## 
  let valid = call_38987909.validator(path, query, header, formData, body, _)
  let scheme = call_38987909.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987909.url(scheme.get, call_38987909.host, call_38987909.base,
                           call_38987909.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987909, url, valid, _)

proc call*(call_38987910: Call_GetSearchUsers_38987902; q: string;
          order: string = "desc"; Accept: string = ""; sort: string = "followers"): Recallable =
  ## getSearchUsers
  ## Search users.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##       : If not provided, results are sorted by best match.
  ##   q: string (required)
  ##    : The search terms. This can be any combination of the supported user
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the username, public email, full name,
  ## location, or any combination of these.
  ## 'Repository count' Filters users based on the number of repositories they
  ## have.
  ## 'Location' Filter users by the location indicated in their profile.
  ## 'Language' Search for users that have repositories that match a certain
  ## language.
  ## 'Created' Filter users based on when they joined.
  ## 'Followers' Filter users based on the number of followers they have.
  ## 
  var query_38987911 = newJObject()
  var header_38987912 = newJObject()
  add(query_38987911, "order", newJString(order))
  add(header_38987912, "Accept", newJString(Accept))
  add(query_38987911, "sort", newJString(sort))
  add(query_38987911, "q", newJString(q))
  result = call_38987910.call(nil, query_38987911, header_38987912, nil, nil)

var getSearchUsers* = Call_GetSearchUsers_38987902(name: "getSearchUsers",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/search/users",
    validator: validate_GetSearchUsers_38987903, base: "/", url: url_GetSearchUsers_38987904,
    schemes: {Scheme.Https})
type
  Call_GetTeamsTeamId_38987913 = ref object of OpenApiRestCall_38985352
proc url_GetTeamsTeamId_38987915(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamId_38987914(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get team.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_38987916 = path.getOrDefault("teamId")
  valid_38987916 = validateParameter(valid_38987916, JInt, required = true,
                                   default = nil)
  if valid_38987916 != nil:
    section.add "teamId", valid_38987916
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987917 = header.getOrDefault("Accept")
  valid_38987917 = validateParameter(valid_38987917, JString, required = false,
                                   default = nil)
  if valid_38987917 != nil:
    section.add "Accept", valid_38987917
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987918: Call_GetTeamsTeamId_38987913; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get team.
  ## 
  let valid = call_38987918.validator(path, query, header, formData, body, _)
  let scheme = call_38987918.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987918.url(scheme.get, call_38987918.host, call_38987918.base,
                           call_38987918.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987918, url, valid, _)

proc call*(call_38987919: Call_GetTeamsTeamId_38987913; teamId: int;
          Accept: string = ""): Recallable =
  ## getTeamsTeamId
  ## Get team.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_38987920 = newJObject()
  var header_38987921 = newJObject()
  add(header_38987921, "Accept", newJString(Accept))
  add(path_38987920, "teamId", newJInt(teamId))
  result = call_38987919.call(path_38987920, nil, header_38987921, nil, nil)

var getTeamsTeamId* = Call_GetTeamsTeamId_38987913(name: "getTeamsTeamId",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/teams/{teamId}",
    validator: validate_GetTeamsTeamId_38987914, base: "/", url: url_GetTeamsTeamId_38987915,
    schemes: {Scheme.Https})
type
  Call_PatchTeamsTeamId_38987931 = ref object of OpenApiRestCall_38985352
proc url_PatchTeamsTeamId_38987933(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchTeamsTeamId_38987932(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Edit team.
  ## In order to edit a team, the authenticated user must be an owner of the org
  ## that the team is associated with.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_38987934 = path.getOrDefault("teamId")
  valid_38987934 = validateParameter(valid_38987934, JInt, required = true,
                                   default = nil)
  if valid_38987934 != nil:
    section.add "teamId", valid_38987934
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987935 = header.getOrDefault("Accept")
  valid_38987935 = validateParameter(valid_38987935, JString, required = false,
                                   default = nil)
  if valid_38987935 != nil:
    section.add "Accept", valid_38987935
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38987937: Call_PatchTeamsTeamId_38987931; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit team.
  ## In order to edit a team, the authenticated user must be an owner of the org
  ## that the team is associated with.
  ## 
  ## 
  let valid = call_38987937.validator(path, query, header, formData, body, _)
  let scheme = call_38987937.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987937.url(scheme.get, call_38987937.host, call_38987937.base,
                           call_38987937.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987937, url, valid, _)

proc call*(call_38987938: Call_PatchTeamsTeamId_38987931; body: JsonNode;
          teamId: int; Accept: string = ""): Recallable =
  ## patchTeamsTeamId
  ## Edit team.
  ## In order to edit a team, the authenticated user must be an owner of the org
  ## that the team is associated with.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   teamId: int (required)
  ##         : Id of team.
  var path_38987939 = newJObject()
  var header_38987940 = newJObject()
  var body_38987941 = newJObject()
  add(header_38987940, "Accept", newJString(Accept))
  if body != nil:
    body_38987941 = body
  add(path_38987939, "teamId", newJInt(teamId))
  result = call_38987938.call(path_38987939, nil, header_38987940, nil, body_38987941)

var patchTeamsTeamId* = Call_PatchTeamsTeamId_38987931(name: "patchTeamsTeamId",
    meth: HttpMethod.HttpPatch, host: "api.github.com", route: "/teams/{teamId}",
    validator: validate_PatchTeamsTeamId_38987932, base: "/",
    url: url_PatchTeamsTeamId_38987933, schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamId_38987922 = ref object of OpenApiRestCall_38985352
proc url_DeleteTeamsTeamId_38987924(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamId_38987923(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Delete team.
  ## In order to delete a team, the authenticated user must be an owner of the
  ## org that the team is associated with.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_38987925 = path.getOrDefault("teamId")
  valid_38987925 = validateParameter(valid_38987925, JInt, required = true,
                                   default = nil)
  if valid_38987925 != nil:
    section.add "teamId", valid_38987925
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987926 = header.getOrDefault("Accept")
  valid_38987926 = validateParameter(valid_38987926, JString, required = false,
                                   default = nil)
  if valid_38987926 != nil:
    section.add "Accept", valid_38987926
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987927: Call_DeleteTeamsTeamId_38987922; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete team.
  ## In order to delete a team, the authenticated user must be an owner of the
  ## org that the team is associated with.
  ## 
  ## 
  let valid = call_38987927.validator(path, query, header, formData, body, _)
  let scheme = call_38987927.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987927.url(scheme.get, call_38987927.host, call_38987927.base,
                           call_38987927.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987927, url, valid, _)

proc call*(call_38987928: Call_DeleteTeamsTeamId_38987922; teamId: int;
          Accept: string = ""): Recallable =
  ## deleteTeamsTeamId
  ## Delete team.
  ## In order to delete a team, the authenticated user must be an owner of the
  ## org that the team is associated with.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_38987929 = newJObject()
  var header_38987930 = newJObject()
  add(header_38987930, "Accept", newJString(Accept))
  add(path_38987929, "teamId", newJInt(teamId))
  result = call_38987928.call(path_38987929, nil, header_38987930, nil, nil)

var deleteTeamsTeamId* = Call_DeleteTeamsTeamId_38987922(name: "deleteTeamsTeamId",
    meth: HttpMethod.HttpDelete, host: "api.github.com", route: "/teams/{teamId}",
    validator: validate_DeleteTeamsTeamId_38987923, base: "/",
    url: url_DeleteTeamsTeamId_38987924, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdMembers_38987942 = ref object of OpenApiRestCall_38985352
proc url_GetTeamsTeamIdMembers_38987944(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/members")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdMembers_38987943(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List team members.
  ## In order to list members in a team, the authenticated user must be a member
  ## of the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_38987945 = path.getOrDefault("teamId")
  valid_38987945 = validateParameter(valid_38987945, JInt, required = true,
                                   default = nil)
  if valid_38987945 != nil:
    section.add "teamId", valid_38987945
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987946 = header.getOrDefault("Accept")
  valid_38987946 = validateParameter(valid_38987946, JString, required = false,
                                   default = nil)
  if valid_38987946 != nil:
    section.add "Accept", valid_38987946
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987947: Call_GetTeamsTeamIdMembers_38987942;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List team members.
  ## In order to list members in a team, the authenticated user must be a member
  ## of the team.
  ## 
  ## 
  let valid = call_38987947.validator(path, query, header, formData, body, _)
  let scheme = call_38987947.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987947.url(scheme.get, call_38987947.host, call_38987947.base,
                           call_38987947.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987947, url, valid, _)

proc call*(call_38987948: Call_GetTeamsTeamIdMembers_38987942; teamId: int;
          Accept: string = ""): Recallable =
  ## getTeamsTeamIdMembers
  ## List team members.
  ## In order to list members in a team, the authenticated user must be a member
  ## of the team.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_38987949 = newJObject()
  var header_38987950 = newJObject()
  add(header_38987950, "Accept", newJString(Accept))
  add(path_38987949, "teamId", newJInt(teamId))
  result = call_38987948.call(path_38987949, nil, header_38987950, nil, nil)

var getTeamsTeamIdMembers* = Call_GetTeamsTeamIdMembers_38987942(
    name: "getTeamsTeamIdMembers", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/teams/{teamId}/members", validator: validate_GetTeamsTeamIdMembers_38987943,
    base: "/", url: url_GetTeamsTeamIdMembers_38987944, schemes: {Scheme.Https})
type
  Call_PutTeamsTeamIdMembersUsername_38987961 = ref object of OpenApiRestCall_38985352
proc url_PutTeamsTeamIdMembersUsername_38987963(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutTeamsTeamIdMembersUsername_38987962(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## The API (described below) is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Add team membership API instead. It allows you to invite new organization members to your teams.
  ## 
  ## Add team member.
  ## In order to add a user to a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_38987964 = path.getOrDefault("username")
  valid_38987964 = validateParameter(valid_38987964, JString, required = true,
                                   default = nil)
  if valid_38987964 != nil:
    section.add "username", valid_38987964
  var valid_38987965 = path.getOrDefault("teamId")
  valid_38987965 = validateParameter(valid_38987965, JInt, required = true,
                                   default = nil)
  if valid_38987965 != nil:
    section.add "teamId", valid_38987965
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987966 = header.getOrDefault("Accept")
  valid_38987966 = validateParameter(valid_38987966, JString, required = false,
                                   default = nil)
  if valid_38987966 != nil:
    section.add "Accept", valid_38987966
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987967: Call_PutTeamsTeamIdMembersUsername_38987961;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## The API (described below) is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Add team membership API instead. It allows you to invite new organization members to your teams.
  ## 
  ## Add team member.
  ## In order to add a user to a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## 
  ## 
  let valid = call_38987967.validator(path, query, header, formData, body, _)
  let scheme = call_38987967.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987967.url(scheme.get, call_38987967.host, call_38987967.base,
                           call_38987967.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987967, url, valid, _)

proc call*(call_38987968: Call_PutTeamsTeamIdMembersUsername_38987961;
          username: string; teamId: int; Accept: string = ""): Recallable =
  ## putTeamsTeamIdMembersUsername
  ## The API (described below) is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Add team membership API instead. It allows you to invite new organization members to your teams.
  ## 
  ## Add team member.
  ## In order to add a user to a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_38987969 = newJObject()
  var header_38987970 = newJObject()
  add(path_38987969, "username", newJString(username))
  add(header_38987970, "Accept", newJString(Accept))
  add(path_38987969, "teamId", newJInt(teamId))
  result = call_38987968.call(path_38987969, nil, header_38987970, nil, nil)

var putTeamsTeamIdMembersUsername* = Call_PutTeamsTeamIdMembersUsername_38987961(
    name: "putTeamsTeamIdMembersUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/teams/{teamId}/members/{username}",
    validator: validate_PutTeamsTeamIdMembersUsername_38987962, base: "/",
    url: url_PutTeamsTeamIdMembersUsername_38987963, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdMembersUsername_38987951 = ref object of OpenApiRestCall_38985352
proc url_GetTeamsTeamIdMembersUsername_38987953(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdMembersUsername_38987952(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## The "Get team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Get team membership API instead. It allows you to get both active and pending memberships.
  ## 
  ## Get team member.
  ## In order to get if a user is a member of a team, the authenticated user mus
  ## be a member of the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_38987954 = path.getOrDefault("username")
  valid_38987954 = validateParameter(valid_38987954, JString, required = true,
                                   default = nil)
  if valid_38987954 != nil:
    section.add "username", valid_38987954
  var valid_38987955 = path.getOrDefault("teamId")
  valid_38987955 = validateParameter(valid_38987955, JInt, required = true,
                                   default = nil)
  if valid_38987955 != nil:
    section.add "teamId", valid_38987955
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987956 = header.getOrDefault("Accept")
  valid_38987956 = validateParameter(valid_38987956, JString, required = false,
                                   default = nil)
  if valid_38987956 != nil:
    section.add "Accept", valid_38987956
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987957: Call_GetTeamsTeamIdMembersUsername_38987951;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## The "Get team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Get team membership API instead. It allows you to get both active and pending memberships.
  ## 
  ## Get team member.
  ## In order to get if a user is a member of a team, the authenticated user mus
  ## be a member of the team.
  ## 
  ## 
  let valid = call_38987957.validator(path, query, header, formData, body, _)
  let scheme = call_38987957.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987957.url(scheme.get, call_38987957.host, call_38987957.base,
                           call_38987957.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987957, url, valid, _)

proc call*(call_38987958: Call_GetTeamsTeamIdMembersUsername_38987951;
          username: string; teamId: int; Accept: string = ""): Recallable =
  ## getTeamsTeamIdMembersUsername
  ## The "Get team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Get team membership API instead. It allows you to get both active and pending memberships.
  ## 
  ## Get team member.
  ## In order to get if a user is a member of a team, the authenticated user mus
  ## be a member of the team.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_38987959 = newJObject()
  var header_38987960 = newJObject()
  add(path_38987959, "username", newJString(username))
  add(header_38987960, "Accept", newJString(Accept))
  add(path_38987959, "teamId", newJInt(teamId))
  result = call_38987958.call(path_38987959, nil, header_38987960, nil, nil)

var getTeamsTeamIdMembersUsername* = Call_GetTeamsTeamIdMembersUsername_38987951(
    name: "getTeamsTeamIdMembersUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/teams/{teamId}/members/{username}",
    validator: validate_GetTeamsTeamIdMembersUsername_38987952, base: "/",
    url: url_GetTeamsTeamIdMembersUsername_38987953, schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamIdMembersUsername_38987971 = ref object of OpenApiRestCall_38985352
proc url_DeleteTeamsTeamIdMembersUsername_38987973(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamIdMembersUsername_38987972(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## The "Remove team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Remove team membership API instead. It allows you to remove both active and pending memberships.
  ## 
  ## Remove team member.
  ## In order to remove a user from a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## NOTE This does not delete the user, it just remove them from the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_38987974 = path.getOrDefault("username")
  valid_38987974 = validateParameter(valid_38987974, JString, required = true,
                                   default = nil)
  if valid_38987974 != nil:
    section.add "username", valid_38987974
  var valid_38987975 = path.getOrDefault("teamId")
  valid_38987975 = validateParameter(valid_38987975, JInt, required = true,
                                   default = nil)
  if valid_38987975 != nil:
    section.add "teamId", valid_38987975
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987976 = header.getOrDefault("Accept")
  valid_38987976 = validateParameter(valid_38987976, JString, required = false,
                                   default = nil)
  if valid_38987976 != nil:
    section.add "Accept", valid_38987976
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987977: Call_DeleteTeamsTeamIdMembersUsername_38987971;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## The "Remove team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Remove team membership API instead. It allows you to remove both active and pending memberships.
  ## 
  ## Remove team member.
  ## In order to remove a user from a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## NOTE This does not delete the user, it just remove them from the team.
  ## 
  ## 
  let valid = call_38987977.validator(path, query, header, formData, body, _)
  let scheme = call_38987977.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987977.url(scheme.get, call_38987977.host, call_38987977.base,
                           call_38987977.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987977, url, valid, _)

proc call*(call_38987978: Call_DeleteTeamsTeamIdMembersUsername_38987971;
          username: string; teamId: int; Accept: string = ""): Recallable =
  ## deleteTeamsTeamIdMembersUsername
  ## The "Remove team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Remove team membership API instead. It allows you to remove both active and pending memberships.
  ## 
  ## Remove team member.
  ## In order to remove a user from a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## NOTE This does not delete the user, it just remove them from the team.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_38987979 = newJObject()
  var header_38987980 = newJObject()
  add(path_38987979, "username", newJString(username))
  add(header_38987980, "Accept", newJString(Accept))
  add(path_38987979, "teamId", newJInt(teamId))
  result = call_38987978.call(path_38987979, nil, header_38987980, nil, nil)

var deleteTeamsTeamIdMembersUsername* = Call_DeleteTeamsTeamIdMembersUsername_38987971(
    name: "deleteTeamsTeamIdMembersUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/teams/{teamId}/members/{username}",
    validator: validate_DeleteTeamsTeamIdMembersUsername_38987972, base: "/",
    url: url_DeleteTeamsTeamIdMembersUsername_38987973, schemes: {Scheme.Https})
type
  Call_PutTeamsTeamIdMembershipsUsername_38987991 = ref object of OpenApiRestCall_38985352
proc url_PutTeamsTeamIdMembershipsUsername_38987993(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/memberships/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutTeamsTeamIdMembershipsUsername_38987992(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Add team membership.
  ## In order to add a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with.
  ## 
  ## If the user is already a part of the team's organization (meaning they're on at least one other team in the organization), this endpoint will add the user to the team.
  ## 
  ## If the user is completely unaffiliated with the team's organization (meaning they're on none of the organization's teams), this endpoint will send an invitation to the user via email. This newly-created membership will be in the 'pending' state until the user accepts the invitation, at which point the membership will transition to the 'active' state and the user will be added as a member of the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_38987994 = path.getOrDefault("username")
  valid_38987994 = validateParameter(valid_38987994, JString, required = true,
                                   default = nil)
  if valid_38987994 != nil:
    section.add "username", valid_38987994
  var valid_38987995 = path.getOrDefault("teamId")
  valid_38987995 = validateParameter(valid_38987995, JInt, required = true,
                                   default = nil)
  if valid_38987995 != nil:
    section.add "teamId", valid_38987995
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987996 = header.getOrDefault("Accept")
  valid_38987996 = validateParameter(valid_38987996, JString, required = false,
                                   default = nil)
  if valid_38987996 != nil:
    section.add "Accept", valid_38987996
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987997: Call_PutTeamsTeamIdMembershipsUsername_38987991;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Add team membership.
  ## In order to add a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with.
  ## 
  ## If the user is already a part of the team's organization (meaning they're on at least one other team in the organization), this endpoint will add the user to the team.
  ## 
  ## If the user is completely unaffiliated with the team's organization (meaning they're on none of the organization's teams), this endpoint will send an invitation to the user via email. This newly-created membership will be in the 'pending' state until the user accepts the invitation, at which point the membership will transition to the 'active' state and the user will be added as a member of the team.
  ## 
  ## 
  let valid = call_38987997.validator(path, query, header, formData, body, _)
  let scheme = call_38987997.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987997.url(scheme.get, call_38987997.host, call_38987997.base,
                           call_38987997.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987997, url, valid, _)

proc call*(call_38987998: Call_PutTeamsTeamIdMembershipsUsername_38987991;
          username: string; teamId: int; Accept: string = ""): Recallable =
  ## putTeamsTeamIdMembershipsUsername
  ## Add team membership.
  ## In order to add a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with.
  ## 
  ## If the user is already a part of the team's organization (meaning they're on at least one other team in the organization), this endpoint will add the user to the team.
  ## 
  ## If the user is completely unaffiliated with the team's organization (meaning they're on none of the organization's teams), this endpoint will send an invitation to the user via email. This newly-created membership will be in the 'pending' state until the user accepts the invitation, at which point the membership will transition to the 'active' state and the user will be added as a member of the team.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_38987999 = newJObject()
  var header_38988000 = newJObject()
  add(path_38987999, "username", newJString(username))
  add(header_38988000, "Accept", newJString(Accept))
  add(path_38987999, "teamId", newJInt(teamId))
  result = call_38987998.call(path_38987999, nil, header_38988000, nil, nil)

var putTeamsTeamIdMembershipsUsername* = Call_PutTeamsTeamIdMembershipsUsername_38987991(
    name: "putTeamsTeamIdMembershipsUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/teams/{teamId}/memberships/{username}",
    validator: validate_PutTeamsTeamIdMembershipsUsername_38987992, base: "/",
    url: url_PutTeamsTeamIdMembershipsUsername_38987993, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdMembershipsUsername_38987981 = ref object of OpenApiRestCall_38985352
proc url_GetTeamsTeamIdMembershipsUsername_38987983(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/memberships/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdMembershipsUsername_38987982(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get team membership.
  ## In order to get a user's membership with a team, the authenticated user must be a member of the team or an owner of the team's organization.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_38987984 = path.getOrDefault("username")
  valid_38987984 = validateParameter(valid_38987984, JString, required = true,
                                   default = nil)
  if valid_38987984 != nil:
    section.add "username", valid_38987984
  var valid_38987985 = path.getOrDefault("teamId")
  valid_38987985 = validateParameter(valid_38987985, JInt, required = true,
                                   default = nil)
  if valid_38987985 != nil:
    section.add "teamId", valid_38987985
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38987986 = header.getOrDefault("Accept")
  valid_38987986 = validateParameter(valid_38987986, JString, required = false,
                                   default = nil)
  if valid_38987986 != nil:
    section.add "Accept", valid_38987986
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38987987: Call_GetTeamsTeamIdMembershipsUsername_38987981;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get team membership.
  ## In order to get a user's membership with a team, the authenticated user must be a member of the team or an owner of the team's organization.
  ## 
  ## 
  let valid = call_38987987.validator(path, query, header, formData, body, _)
  let scheme = call_38987987.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38987987.url(scheme.get, call_38987987.host, call_38987987.base,
                           call_38987987.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38987987, url, valid, _)

proc call*(call_38987988: Call_GetTeamsTeamIdMembershipsUsername_38987981;
          username: string; teamId: int; Accept: string = ""): Recallable =
  ## getTeamsTeamIdMembershipsUsername
  ## Get team membership.
  ## In order to get a user's membership with a team, the authenticated user must be a member of the team or an owner of the team's organization.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_38987989 = newJObject()
  var header_38987990 = newJObject()
  add(path_38987989, "username", newJString(username))
  add(header_38987990, "Accept", newJString(Accept))
  add(path_38987989, "teamId", newJInt(teamId))
  result = call_38987988.call(path_38987989, nil, header_38987990, nil, nil)

var getTeamsTeamIdMembershipsUsername* = Call_GetTeamsTeamIdMembershipsUsername_38987981(
    name: "getTeamsTeamIdMembershipsUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/teams/{teamId}/memberships/{username}",
    validator: validate_GetTeamsTeamIdMembershipsUsername_38987982, base: "/",
    url: url_GetTeamsTeamIdMembershipsUsername_38987983, schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamIdMembershipsUsername_38988001 = ref object of OpenApiRestCall_38985352
proc url_DeleteTeamsTeamIdMembershipsUsername_38988003(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/memberships/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamIdMembershipsUsername_38988002(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Remove team membership.
  ## In order to remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. NOTE: This does not delete the user, it just removes their membership from the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_38988004 = path.getOrDefault("username")
  valid_38988004 = validateParameter(valid_38988004, JString, required = true,
                                   default = nil)
  if valid_38988004 != nil:
    section.add "username", valid_38988004
  var valid_38988005 = path.getOrDefault("teamId")
  valid_38988005 = validateParameter(valid_38988005, JInt, required = true,
                                   default = nil)
  if valid_38988005 != nil:
    section.add "teamId", valid_38988005
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988006 = header.getOrDefault("Accept")
  valid_38988006 = validateParameter(valid_38988006, JString, required = false,
                                   default = nil)
  if valid_38988006 != nil:
    section.add "Accept", valid_38988006
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988007: Call_DeleteTeamsTeamIdMembershipsUsername_38988001;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Remove team membership.
  ## In order to remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. NOTE: This does not delete the user, it just removes their membership from the team.
  ## 
  ## 
  let valid = call_38988007.validator(path, query, header, formData, body, _)
  let scheme = call_38988007.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988007.url(scheme.get, call_38988007.host, call_38988007.base,
                           call_38988007.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988007, url, valid, _)

proc call*(call_38988008: Call_DeleteTeamsTeamIdMembershipsUsername_38988001;
          username: string; teamId: int; Accept: string = ""): Recallable =
  ## deleteTeamsTeamIdMembershipsUsername
  ## Remove team membership.
  ## In order to remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. NOTE: This does not delete the user, it just removes their membership from the team.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_38988009 = newJObject()
  var header_38988010 = newJObject()
  add(path_38988009, "username", newJString(username))
  add(header_38988010, "Accept", newJString(Accept))
  add(path_38988009, "teamId", newJInt(teamId))
  result = call_38988008.call(path_38988009, nil, header_38988010, nil, nil)

var deleteTeamsTeamIdMembershipsUsername* = Call_DeleteTeamsTeamIdMembershipsUsername_38988001(
    name: "deleteTeamsTeamIdMembershipsUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/teams/{teamId}/memberships/{username}",
    validator: validate_DeleteTeamsTeamIdMembershipsUsername_38988002, base: "/",
    url: url_DeleteTeamsTeamIdMembershipsUsername_38988003,
    schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdRepos_38988011 = ref object of OpenApiRestCall_38985352
proc url_GetTeamsTeamIdRepos_38988013(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdRepos_38988012(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List team repos
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_38988014 = path.getOrDefault("teamId")
  valid_38988014 = validateParameter(valid_38988014, JInt, required = true,
                                   default = nil)
  if valid_38988014 != nil:
    section.add "teamId", valid_38988014
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988015 = header.getOrDefault("Accept")
  valid_38988015 = validateParameter(valid_38988015, JString, required = false,
                                   default = nil)
  if valid_38988015 != nil:
    section.add "Accept", valid_38988015
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988016: Call_GetTeamsTeamIdRepos_38988011; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List team repos
  ## 
  let valid = call_38988016.validator(path, query, header, formData, body, _)
  let scheme = call_38988016.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988016.url(scheme.get, call_38988016.host, call_38988016.base,
                           call_38988016.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988016, url, valid, _)

proc call*(call_38988017: Call_GetTeamsTeamIdRepos_38988011; teamId: int;
          Accept: string = ""): Recallable =
  ## getTeamsTeamIdRepos
  ## List team repos
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_38988018 = newJObject()
  var header_38988019 = newJObject()
  add(header_38988019, "Accept", newJString(Accept))
  add(path_38988018, "teamId", newJInt(teamId))
  result = call_38988017.call(path_38988018, nil, header_38988019, nil, nil)

var getTeamsTeamIdRepos* = Call_GetTeamsTeamIdRepos_38988011(
    name: "getTeamsTeamIdRepos", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/teams/{teamId}/repos", validator: validate_GetTeamsTeamIdRepos_38988012,
    base: "/", url: url_GetTeamsTeamIdRepos_38988013, schemes: {Scheme.Https})
type
  Call_PutTeamsTeamIdReposOwnerRepo_38988031 = ref object of OpenApiRestCall_38985352
proc url_PutTeamsTeamIdReposOwnerRepo_38988033(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutTeamsTeamIdReposOwnerRepo_38988032(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## In order to add a repository to a team, the authenticated user must be an owner of the org that the team is associated with. Also, the repository must be owned by the organization, or a direct fork of a repository owned by the organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of a organization.
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38988034 = path.getOrDefault("owner")
  valid_38988034 = validateParameter(valid_38988034, JString, required = true,
                                   default = nil)
  if valid_38988034 != nil:
    section.add "owner", valid_38988034
  var valid_38988035 = path.getOrDefault("repo")
  valid_38988035 = validateParameter(valid_38988035, JString, required = true,
                                   default = nil)
  if valid_38988035 != nil:
    section.add "repo", valid_38988035
  var valid_38988036 = path.getOrDefault("teamId")
  valid_38988036 = validateParameter(valid_38988036, JInt, required = true,
                                   default = nil)
  if valid_38988036 != nil:
    section.add "teamId", valid_38988036
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988037 = header.getOrDefault("Accept")
  valid_38988037 = validateParameter(valid_38988037, JString, required = false,
                                   default = nil)
  if valid_38988037 != nil:
    section.add "Accept", valid_38988037
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988038: Call_PutTeamsTeamIdReposOwnerRepo_38988031;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## In order to add a repository to a team, the authenticated user must be an owner of the org that the team is associated with. Also, the repository must be owned by the organization, or a direct fork of a repository owned by the organization.
  ## 
  let valid = call_38988038.validator(path, query, header, formData, body, _)
  let scheme = call_38988038.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988038.url(scheme.get, call_38988038.host, call_38988038.base,
                           call_38988038.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988038, url, valid, _)

proc call*(call_38988039: Call_PutTeamsTeamIdReposOwnerRepo_38988031;
          owner: string; repo: string; teamId: int; Accept: string = ""): Recallable =
  ## putTeamsTeamIdReposOwnerRepo
  ## In order to add a repository to a team, the authenticated user must be an owner of the org that the team is associated with. Also, the repository must be owned by the organization, or a direct fork of a repository owned by the organization.
  ##   owner: string (required)
  ##        : Name of a organization.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_38988040 = newJObject()
  var header_38988041 = newJObject()
  add(path_38988040, "owner", newJString(owner))
  add(header_38988041, "Accept", newJString(Accept))
  add(path_38988040, "repo", newJString(repo))
  add(path_38988040, "teamId", newJInt(teamId))
  result = call_38988039.call(path_38988040, nil, header_38988041, nil, nil)

var putTeamsTeamIdReposOwnerRepo* = Call_PutTeamsTeamIdReposOwnerRepo_38988031(
    name: "putTeamsTeamIdReposOwnerRepo", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/teams/{teamId}/repos/{owner}/{repo}",
    validator: validate_PutTeamsTeamIdReposOwnerRepo_38988032, base: "/",
    url: url_PutTeamsTeamIdReposOwnerRepo_38988033, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdReposOwnerRepo_38988020 = ref object of OpenApiRestCall_38985352
proc url_GetTeamsTeamIdReposOwnerRepo_38988022(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdReposOwnerRepo_38988021(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Check if a team manages a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38988023 = path.getOrDefault("owner")
  valid_38988023 = validateParameter(valid_38988023, JString, required = true,
                                   default = nil)
  if valid_38988023 != nil:
    section.add "owner", valid_38988023
  var valid_38988024 = path.getOrDefault("repo")
  valid_38988024 = validateParameter(valid_38988024, JString, required = true,
                                   default = nil)
  if valid_38988024 != nil:
    section.add "repo", valid_38988024
  var valid_38988025 = path.getOrDefault("teamId")
  valid_38988025 = validateParameter(valid_38988025, JInt, required = true,
                                   default = nil)
  if valid_38988025 != nil:
    section.add "teamId", valid_38988025
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988026 = header.getOrDefault("Accept")
  valid_38988026 = validateParameter(valid_38988026, JString, required = false,
                                   default = nil)
  if valid_38988026 != nil:
    section.add "Accept", valid_38988026
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988027: Call_GetTeamsTeamIdReposOwnerRepo_38988020;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if a team manages a repository
  ## 
  let valid = call_38988027.validator(path, query, header, formData, body, _)
  let scheme = call_38988027.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988027.url(scheme.get, call_38988027.host, call_38988027.base,
                           call_38988027.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988027, url, valid, _)

proc call*(call_38988028: Call_GetTeamsTeamIdReposOwnerRepo_38988020;
          owner: string; repo: string; teamId: int; Accept: string = ""): Recallable =
  ## getTeamsTeamIdReposOwnerRepo
  ## Check if a team manages a repository
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_38988029 = newJObject()
  var header_38988030 = newJObject()
  add(path_38988029, "owner", newJString(owner))
  add(header_38988030, "Accept", newJString(Accept))
  add(path_38988029, "repo", newJString(repo))
  add(path_38988029, "teamId", newJInt(teamId))
  result = call_38988028.call(path_38988029, nil, header_38988030, nil, nil)

var getTeamsTeamIdReposOwnerRepo* = Call_GetTeamsTeamIdReposOwnerRepo_38988020(
    name: "getTeamsTeamIdReposOwnerRepo", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/teams/{teamId}/repos/{owner}/{repo}",
    validator: validate_GetTeamsTeamIdReposOwnerRepo_38988021, base: "/",
    url: url_GetTeamsTeamIdReposOwnerRepo_38988022, schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamIdReposOwnerRepo_38988042 = ref object of OpenApiRestCall_38985352
proc url_DeleteTeamsTeamIdReposOwnerRepo_38988044(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamIdReposOwnerRepo_38988043(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## In order to remove a repository from a team, the authenticated user must be an owner of the org that the team is associated with. NOTE: This does not delete the repository, it just removes it from the team.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38988045 = path.getOrDefault("owner")
  valid_38988045 = validateParameter(valid_38988045, JString, required = true,
                                   default = nil)
  if valid_38988045 != nil:
    section.add "owner", valid_38988045
  var valid_38988046 = path.getOrDefault("repo")
  valid_38988046 = validateParameter(valid_38988046, JString, required = true,
                                   default = nil)
  if valid_38988046 != nil:
    section.add "repo", valid_38988046
  var valid_38988047 = path.getOrDefault("teamId")
  valid_38988047 = validateParameter(valid_38988047, JInt, required = true,
                                   default = nil)
  if valid_38988047 != nil:
    section.add "teamId", valid_38988047
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988048 = header.getOrDefault("Accept")
  valid_38988048 = validateParameter(valid_38988048, JString, required = false,
                                   default = nil)
  if valid_38988048 != nil:
    section.add "Accept", valid_38988048
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988049: Call_DeleteTeamsTeamIdReposOwnerRepo_38988042;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## In order to remove a repository from a team, the authenticated user must be an owner of the org that the team is associated with. NOTE: This does not delete the repository, it just removes it from the team.
  ## 
  let valid = call_38988049.validator(path, query, header, formData, body, _)
  let scheme = call_38988049.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988049.url(scheme.get, call_38988049.host, call_38988049.base,
                           call_38988049.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988049, url, valid, _)

proc call*(call_38988050: Call_DeleteTeamsTeamIdReposOwnerRepo_38988042;
          owner: string; repo: string; teamId: int; Accept: string = ""): Recallable =
  ## deleteTeamsTeamIdReposOwnerRepo
  ## In order to remove a repository from a team, the authenticated user must be an owner of the org that the team is associated with. NOTE: This does not delete the repository, it just removes it from the team.
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_38988051 = newJObject()
  var header_38988052 = newJObject()
  add(path_38988051, "owner", newJString(owner))
  add(header_38988052, "Accept", newJString(Accept))
  add(path_38988051, "repo", newJString(repo))
  add(path_38988051, "teamId", newJInt(teamId))
  result = call_38988050.call(path_38988051, nil, header_38988052, nil, nil)

var deleteTeamsTeamIdReposOwnerRepo* = Call_DeleteTeamsTeamIdReposOwnerRepo_38988042(
    name: "deleteTeamsTeamIdReposOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/teams/{teamId}/repos/{owner}/{repo}",
    validator: validate_DeleteTeamsTeamIdReposOwnerRepo_38988043, base: "/",
    url: url_DeleteTeamsTeamIdReposOwnerRepo_38988044, schemes: {Scheme.Https})
type
  Call_GetUser_38988053 = ref object of OpenApiRestCall_38985352
proc url_GetUser_38988055(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUser_38988054(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988056 = header.getOrDefault("Accept")
  valid_38988056 = validateParameter(valid_38988056, JString, required = false,
                                   default = nil)
  if valid_38988056 != nil:
    section.add "Accept", valid_38988056
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988057: Call_GetUser_38988053; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get the authenticated user.
  ## 
  let valid = call_38988057.validator(path, query, header, formData, body, _)
  let scheme = call_38988057.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988057.url(scheme.get, call_38988057.host, call_38988057.base,
                           call_38988057.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988057, url, valid, _)

proc call*(call_38988058: Call_GetUser_38988053; Accept: string = ""): Recallable =
  ## getUser
  ## Get the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_38988059 = newJObject()
  add(header_38988059, "Accept", newJString(Accept))
  result = call_38988058.call(nil, nil, header_38988059, nil, nil)

var getUser* = Call_GetUser_38988053(name: "getUser", meth: HttpMethod.HttpGet,
                                  host: "api.github.com", route: "/user",
                                  validator: validate_GetUser_38988054, base: "/",
                                  url: url_GetUser_38988055,
                                  schemes: {Scheme.Https})
type
  Call_PatchUser_38988060 = ref object of OpenApiRestCall_38985352
proc url_PatchUser_38988062(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PatchUser_38988061(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Update the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988063 = header.getOrDefault("Accept")
  valid_38988063 = validateParameter(valid_38988063, JString, required = false,
                                   default = nil)
  if valid_38988063 != nil:
    section.add "Accept", valid_38988063
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38988065: Call_PatchUser_38988060; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Update the authenticated user.
  ## 
  let valid = call_38988065.validator(path, query, header, formData, body, _)
  let scheme = call_38988065.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988065.url(scheme.get, call_38988065.host, call_38988065.base,
                           call_38988065.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988065, url, valid, _)

proc call*(call_38988066: Call_PatchUser_38988060; body: JsonNode;
          Accept: string = ""): Recallable =
  ## patchUser
  ## Update the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_38988067 = newJObject()
  var body_38988068 = newJObject()
  add(header_38988067, "Accept", newJString(Accept))
  if body != nil:
    body_38988068 = body
  result = call_38988066.call(nil, nil, header_38988067, nil, body_38988068)

var patchUser* = Call_PatchUser_38988060(name: "patchUser",
                                      meth: HttpMethod.HttpPatch,
                                      host: "api.github.com", route: "/user",
                                      validator: validate_PatchUser_38988061,
                                      base: "/", url: url_PatchUser_38988062,
                                      schemes: {Scheme.Https})
type
  Call_PostUserEmails_38988076 = ref object of OpenApiRestCall_38985352
proc url_PostUserEmails_38988078(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostUserEmails_38988077(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Add email address(es).
  ## You can post a single email address or an array of addresses.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988079 = header.getOrDefault("Accept")
  valid_38988079 = validateParameter(valid_38988079, JString, required = false,
                                   default = nil)
  if valid_38988079 != nil:
    section.add "Accept", valid_38988079
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38988081: Call_PostUserEmails_38988076; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Add email address(es).
  ## You can post a single email address or an array of addresses.
  ## 
  ## 
  let valid = call_38988081.validator(path, query, header, formData, body, _)
  let scheme = call_38988081.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988081.url(scheme.get, call_38988081.host, call_38988081.base,
                           call_38988081.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988081, url, valid, _)

proc call*(call_38988082: Call_PostUserEmails_38988076; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postUserEmails
  ## Add email address(es).
  ## You can post a single email address or an array of addresses.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  var header_38988083 = newJObject()
  var body_38988084 = newJObject()
  add(header_38988083, "Accept", newJString(Accept))
  if body != nil:
    body_38988084 = body
  result = call_38988082.call(nil, nil, header_38988083, nil, body_38988084)

var postUserEmails* = Call_PostUserEmails_38988076(name: "postUserEmails",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/user/emails",
    validator: validate_PostUserEmails_38988077, base: "/", url: url_PostUserEmails_38988078,
    schemes: {Scheme.Https})
type
  Call_GetUserEmails_38988069 = ref object of OpenApiRestCall_38985352
proc url_GetUserEmails_38988071(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserEmails_38988070(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## List email addresses for a user.
  ## In the final version of the API, this method will return an array of hashes
  ## with extended information for each email address indicating if the address
  ## has been verified and if it's primary email address for GitHub.
  ## Until API v3 is finalized, use the application/vnd.github.v3 media type to
  ## get other response format.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988072 = header.getOrDefault("Accept")
  valid_38988072 = validateParameter(valid_38988072, JString, required = false,
                                   default = nil)
  if valid_38988072 != nil:
    section.add "Accept", valid_38988072
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988073: Call_GetUserEmails_38988069; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List email addresses for a user.
  ## In the final version of the API, this method will return an array of hashes
  ## with extended information for each email address indicating if the address
  ## has been verified and if it's primary email address for GitHub.
  ## Until API v3 is finalized, use the application/vnd.github.v3 media type to
  ## get other response format.
  ## 
  ## 
  let valid = call_38988073.validator(path, query, header, formData, body, _)
  let scheme = call_38988073.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988073.url(scheme.get, call_38988073.host, call_38988073.base,
                           call_38988073.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988073, url, valid, _)

proc call*(call_38988074: Call_GetUserEmails_38988069; Accept: string = ""): Recallable =
  ## getUserEmails
  ## List email addresses for a user.
  ## In the final version of the API, this method will return an array of hashes
  ## with extended information for each email address indicating if the address
  ## has been verified and if it's primary email address for GitHub.
  ## Until API v3 is finalized, use the application/vnd.github.v3 media type to
  ## get other response format.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_38988075 = newJObject()
  add(header_38988075, "Accept", newJString(Accept))
  result = call_38988074.call(nil, nil, header_38988075, nil, nil)

var getUserEmails* = Call_GetUserEmails_38988069(name: "getUserEmails",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/emails",
    validator: validate_GetUserEmails_38988070, base: "/", url: url_GetUserEmails_38988071,
    schemes: {Scheme.Https})
type
  Call_DeleteUserEmails_38988085 = ref object of OpenApiRestCall_38985352
proc url_DeleteUserEmails_38988087(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DeleteUserEmails_38988086(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Delete email address(es).
  ## You can include a single email address or an array of addresses.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988088 = header.getOrDefault("Accept")
  valid_38988088 = validateParameter(valid_38988088, JString, required = false,
                                   default = nil)
  if valid_38988088 != nil:
    section.add "Accept", valid_38988088
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38988090: Call_DeleteUserEmails_38988085; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete email address(es).
  ## You can include a single email address or an array of addresses.
  ## 
  ## 
  let valid = call_38988090.validator(path, query, header, formData, body, _)
  let scheme = call_38988090.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988090.url(scheme.get, call_38988090.host, call_38988090.base,
                           call_38988090.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988090, url, valid, _)

proc call*(call_38988091: Call_DeleteUserEmails_38988085; body: JsonNode;
          Accept: string = ""): Recallable =
  ## deleteUserEmails
  ## Delete email address(es).
  ## You can include a single email address or an array of addresses.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  var header_38988092 = newJObject()
  var body_38988093 = newJObject()
  add(header_38988092, "Accept", newJString(Accept))
  if body != nil:
    body_38988093 = body
  result = call_38988091.call(nil, nil, header_38988092, nil, body_38988093)

var deleteUserEmails* = Call_DeleteUserEmails_38988085(name: "deleteUserEmails",
    meth: HttpMethod.HttpDelete, host: "api.github.com", route: "/user/emails",
    validator: validate_DeleteUserEmails_38988086, base: "/",
    url: url_DeleteUserEmails_38988087, schemes: {Scheme.Https})
type
  Call_GetUserFollowers_38988094 = ref object of OpenApiRestCall_38985352
proc url_GetUserFollowers_38988096(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserFollowers_38988095(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List the authenticated user's followers
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988097 = header.getOrDefault("Accept")
  valid_38988097 = validateParameter(valid_38988097, JString, required = false,
                                   default = nil)
  if valid_38988097 != nil:
    section.add "Accept", valid_38988097
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988098: Call_GetUserFollowers_38988094; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List the authenticated user's followers
  ## 
  let valid = call_38988098.validator(path, query, header, formData, body, _)
  let scheme = call_38988098.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988098.url(scheme.get, call_38988098.host, call_38988098.base,
                           call_38988098.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988098, url, valid, _)

proc call*(call_38988099: Call_GetUserFollowers_38988094; Accept: string = ""): Recallable =
  ## getUserFollowers
  ## List the authenticated user's followers
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_38988100 = newJObject()
  add(header_38988100, "Accept", newJString(Accept))
  result = call_38988099.call(nil, nil, header_38988100, nil, nil)

var getUserFollowers* = Call_GetUserFollowers_38988094(name: "getUserFollowers",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/followers",
    validator: validate_GetUserFollowers_38988095, base: "/",
    url: url_GetUserFollowers_38988096, schemes: {Scheme.Https})
type
  Call_GetUserFollowing_38988101 = ref object of OpenApiRestCall_38985352
proc url_GetUserFollowing_38988103(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserFollowing_38988102(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List who the authenticated user is following.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988104 = header.getOrDefault("Accept")
  valid_38988104 = validateParameter(valid_38988104, JString, required = false,
                                   default = nil)
  if valid_38988104 != nil:
    section.add "Accept", valid_38988104
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988105: Call_GetUserFollowing_38988101; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List who the authenticated user is following.
  ## 
  let valid = call_38988105.validator(path, query, header, formData, body, _)
  let scheme = call_38988105.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988105.url(scheme.get, call_38988105.host, call_38988105.base,
                           call_38988105.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988105, url, valid, _)

proc call*(call_38988106: Call_GetUserFollowing_38988101; Accept: string = ""): Recallable =
  ## getUserFollowing
  ## List who the authenticated user is following.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_38988107 = newJObject()
  add(header_38988107, "Accept", newJString(Accept))
  result = call_38988106.call(nil, nil, header_38988107, nil, nil)

var getUserFollowing* = Call_GetUserFollowing_38988101(name: "getUserFollowing",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/following",
    validator: validate_GetUserFollowing_38988102, base: "/",
    url: url_GetUserFollowing_38988103, schemes: {Scheme.Https})
type
  Call_PutUserFollowingUsername_38988117 = ref object of OpenApiRestCall_38985352
proc url_PutUserFollowingUsername_38988119(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/following/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutUserFollowingUsername_38988118(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Follow a user.
  ## Following a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_38988120 = path.getOrDefault("username")
  valid_38988120 = validateParameter(valid_38988120, JString, required = true,
                                   default = nil)
  if valid_38988120 != nil:
    section.add "username", valid_38988120
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988121 = header.getOrDefault("Accept")
  valid_38988121 = validateParameter(valid_38988121, JString, required = false,
                                   default = nil)
  if valid_38988121 != nil:
    section.add "Accept", valid_38988121
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988122: Call_PutUserFollowingUsername_38988117;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Follow a user.
  ## Following a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  let valid = call_38988122.validator(path, query, header, formData, body, _)
  let scheme = call_38988122.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988122.url(scheme.get, call_38988122.host, call_38988122.base,
                           call_38988122.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988122, url, valid, _)

proc call*(call_38988123: Call_PutUserFollowingUsername_38988117; username: string;
          Accept: string = ""): Recallable =
  ## putUserFollowingUsername
  ## Follow a user.
  ## Following a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_38988124 = newJObject()
  var header_38988125 = newJObject()
  add(path_38988124, "username", newJString(username))
  add(header_38988125, "Accept", newJString(Accept))
  result = call_38988123.call(path_38988124, nil, header_38988125, nil, nil)

var putUserFollowingUsername* = Call_PutUserFollowingUsername_38988117(
    name: "putUserFollowingUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/user/following/{username}",
    validator: validate_PutUserFollowingUsername_38988118, base: "/",
    url: url_PutUserFollowingUsername_38988119, schemes: {Scheme.Https})
type
  Call_GetUserFollowingUsername_38988108 = ref object of OpenApiRestCall_38985352
proc url_GetUserFollowingUsername_38988110(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/following/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserFollowingUsername_38988109(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Check if you are following a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_38988111 = path.getOrDefault("username")
  valid_38988111 = validateParameter(valid_38988111, JString, required = true,
                                   default = nil)
  if valid_38988111 != nil:
    section.add "username", valid_38988111
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988112 = header.getOrDefault("Accept")
  valid_38988112 = validateParameter(valid_38988112, JString, required = false,
                                   default = nil)
  if valid_38988112 != nil:
    section.add "Accept", valid_38988112
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988113: Call_GetUserFollowingUsername_38988108;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if you are following a user.
  ## 
  let valid = call_38988113.validator(path, query, header, formData, body, _)
  let scheme = call_38988113.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988113.url(scheme.get, call_38988113.host, call_38988113.base,
                           call_38988113.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988113, url, valid, _)

proc call*(call_38988114: Call_GetUserFollowingUsername_38988108; username: string;
          Accept: string = ""): Recallable =
  ## getUserFollowingUsername
  ## Check if you are following a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_38988115 = newJObject()
  var header_38988116 = newJObject()
  add(path_38988115, "username", newJString(username))
  add(header_38988116, "Accept", newJString(Accept))
  result = call_38988114.call(path_38988115, nil, header_38988116, nil, nil)

var getUserFollowingUsername* = Call_GetUserFollowingUsername_38988108(
    name: "getUserFollowingUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/user/following/{username}",
    validator: validate_GetUserFollowingUsername_38988109, base: "/",
    url: url_GetUserFollowingUsername_38988110, schemes: {Scheme.Https})
type
  Call_DeleteUserFollowingUsername_38988126 = ref object of OpenApiRestCall_38985352
proc url_DeleteUserFollowingUsername_38988128(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/following/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserFollowingUsername_38988127(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Unfollow a user.
  ## Unfollowing a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_38988129 = path.getOrDefault("username")
  valid_38988129 = validateParameter(valid_38988129, JString, required = true,
                                   default = nil)
  if valid_38988129 != nil:
    section.add "username", valid_38988129
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988130 = header.getOrDefault("Accept")
  valid_38988130 = validateParameter(valid_38988130, JString, required = false,
                                   default = nil)
  if valid_38988130 != nil:
    section.add "Accept", valid_38988130
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988131: Call_DeleteUserFollowingUsername_38988126;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Unfollow a user.
  ## Unfollowing a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  let valid = call_38988131.validator(path, query, header, formData, body, _)
  let scheme = call_38988131.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988131.url(scheme.get, call_38988131.host, call_38988131.base,
                           call_38988131.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988131, url, valid, _)

proc call*(call_38988132: Call_DeleteUserFollowingUsername_38988126;
          username: string; Accept: string = ""): Recallable =
  ## deleteUserFollowingUsername
  ## Unfollow a user.
  ## Unfollowing a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_38988133 = newJObject()
  var header_38988134 = newJObject()
  add(path_38988133, "username", newJString(username))
  add(header_38988134, "Accept", newJString(Accept))
  result = call_38988132.call(path_38988133, nil, header_38988134, nil, nil)

var deleteUserFollowingUsername* = Call_DeleteUserFollowingUsername_38988126(
    name: "deleteUserFollowingUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/following/{username}",
    validator: validate_DeleteUserFollowingUsername_38988127, base: "/",
    url: url_DeleteUserFollowingUsername_38988128, schemes: {Scheme.Https})
type
  Call_GetUserIssues_38988135 = ref object of OpenApiRestCall_38985352
proc url_GetUserIssues_38988137(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserIssues_38988136(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## List issues.
  ## List all issues across owned and member repositories for the authenticated
  ## user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString (required)
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: JString (required)
  ##   direction: JString (required)
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_38988138 = query.getOrDefault("state")
  valid_38988138 = validateParameter(valid_38988138, JString, required = true,
                                   default = newJString("open"))
  if valid_38988138 != nil:
    section.add "state", valid_38988138
  var valid_38988139 = query.getOrDefault("labels")
  valid_38988139 = validateParameter(valid_38988139, JString, required = true,
                                   default = nil)
  if valid_38988139 != nil:
    section.add "labels", valid_38988139
  var valid_38988140 = query.getOrDefault("sort")
  valid_38988140 = validateParameter(valid_38988140, JString, required = true,
                                   default = newJString("created"))
  if valid_38988140 != nil:
    section.add "sort", valid_38988140
  var valid_38988141 = query.getOrDefault("direction")
  valid_38988141 = validateParameter(valid_38988141, JString, required = true,
                                   default = newJString("desc"))
  if valid_38988141 != nil:
    section.add "direction", valid_38988141
  var valid_38988142 = query.getOrDefault("filter")
  valid_38988142 = validateParameter(valid_38988142, JString, required = true,
                                   default = newJString("all"))
  if valid_38988142 != nil:
    section.add "filter", valid_38988142
  var valid_38988143 = query.getOrDefault("since")
  valid_38988143 = validateParameter(valid_38988143, JString, required = false,
                                   default = nil)
  if valid_38988143 != nil:
    section.add "since", valid_38988143
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988144 = header.getOrDefault("Accept")
  valid_38988144 = validateParameter(valid_38988144, JString, required = false,
                                   default = nil)
  if valid_38988144 != nil:
    section.add "Accept", valid_38988144
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988145: Call_GetUserIssues_38988135; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List issues.
  ## List all issues across owned and member repositories for the authenticated
  ## user.
  ## 
  ## 
  let valid = call_38988145.validator(path, query, header, formData, body, _)
  let scheme = call_38988145.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988145.url(scheme.get, call_38988145.host, call_38988145.base,
                           call_38988145.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988145, url, valid, _)

proc call*(call_38988146: Call_GetUserIssues_38988135; labels: string;
          state: string = "open"; Accept: string = ""; sort: string = "created";
          direction: string = "desc"; filter: string = "all"; since: string = ""): Recallable =
  ## getUserIssues
  ## List issues.
  ## List all issues across owned and member repositories for the authenticated
  ## user.
  ## 
  ##   state: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: string (required)
  ##   direction: string (required)
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  var query_38988147 = newJObject()
  var header_38988148 = newJObject()
  add(query_38988147, "state", newJString(state))
  add(header_38988148, "Accept", newJString(Accept))
  add(query_38988147, "labels", newJString(labels))
  add(query_38988147, "sort", newJString(sort))
  add(query_38988147, "direction", newJString(direction))
  add(query_38988147, "filter", newJString(filter))
  add(query_38988147, "since", newJString(since))
  result = call_38988146.call(nil, query_38988147, header_38988148, nil, nil)

var getUserIssues* = Call_GetUserIssues_38988135(name: "getUserIssues",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/issues",
    validator: validate_GetUserIssues_38988136, base: "/", url: url_GetUserIssues_38988137,
    schemes: {Scheme.Https})
type
  Call_PostUserKeys_38988156 = ref object of OpenApiRestCall_38985352
proc url_PostUserKeys_38988158(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostUserKeys_38988157(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## Create a public key.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988159 = header.getOrDefault("Accept")
  valid_38988159 = validateParameter(valid_38988159, JString, required = false,
                                   default = nil)
  if valid_38988159 != nil:
    section.add "Accept", valid_38988159
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38988161: Call_PostUserKeys_38988156; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a public key.
  ## 
  let valid = call_38988161.validator(path, query, header, formData, body, _)
  let scheme = call_38988161.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988161.url(scheme.get, call_38988161.host, call_38988161.base,
                           call_38988161.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988161, url, valid, _)

proc call*(call_38988162: Call_PostUserKeys_38988156; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postUserKeys
  ## Create a public key.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_38988163 = newJObject()
  var body_38988164 = newJObject()
  add(header_38988163, "Accept", newJString(Accept))
  if body != nil:
    body_38988164 = body
  result = call_38988162.call(nil, nil, header_38988163, nil, body_38988164)

var postUserKeys* = Call_PostUserKeys_38988156(name: "postUserKeys",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/user/keys",
    validator: validate_PostUserKeys_38988157, base: "/", url: url_PostUserKeys_38988158,
    schemes: {Scheme.Https})
type
  Call_GetUserKeys_38988149 = ref object of OpenApiRestCall_38985352
proc url_GetUserKeys_38988151(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserKeys_38988150(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List your public keys.
  ## Lists the current user's keys. Management of public keys via the API requires
  ## that you are authenticated through basic auth, or OAuth with the 'user', 'write:public_key' scopes.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988152 = header.getOrDefault("Accept")
  valid_38988152 = validateParameter(valid_38988152, JString, required = false,
                                   default = nil)
  if valid_38988152 != nil:
    section.add "Accept", valid_38988152
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988153: Call_GetUserKeys_38988149; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List your public keys.
  ## Lists the current user's keys. Management of public keys via the API requires
  ## that you are authenticated through basic auth, or OAuth with the 'user', 'write:public_key' scopes.
  ## 
  ## 
  let valid = call_38988153.validator(path, query, header, formData, body, _)
  let scheme = call_38988153.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988153.url(scheme.get, call_38988153.host, call_38988153.base,
                           call_38988153.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988153, url, valid, _)

proc call*(call_38988154: Call_GetUserKeys_38988149; Accept: string = ""): Recallable =
  ## getUserKeys
  ## List your public keys.
  ## Lists the current user's keys. Management of public keys via the API requires
  ## that you are authenticated through basic auth, or OAuth with the 'user', 'write:public_key' scopes.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_38988155 = newJObject()
  add(header_38988155, "Accept", newJString(Accept))
  result = call_38988154.call(nil, nil, header_38988155, nil, nil)

var getUserKeys* = Call_GetUserKeys_38988149(name: "getUserKeys",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/keys",
    validator: validate_GetUserKeys_38988150, base: "/", url: url_GetUserKeys_38988151,
    schemes: {Scheme.Https})
type
  Call_GetUserKeysKeyId_38988165 = ref object of OpenApiRestCall_38985352
proc url_GetUserKeysKeyId_38988167(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/keys/"),
               (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserKeysKeyId_38988166(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get a single public key.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyId: JInt (required)
  ##        : ID of key.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyId` field"
  var valid_38988168 = path.getOrDefault("keyId")
  valid_38988168 = validateParameter(valid_38988168, JInt, required = true,
                                   default = nil)
  if valid_38988168 != nil:
    section.add "keyId", valid_38988168
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988169 = header.getOrDefault("Accept")
  valid_38988169 = validateParameter(valid_38988169, JString, required = false,
                                   default = nil)
  if valid_38988169 != nil:
    section.add "Accept", valid_38988169
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988170: Call_GetUserKeysKeyId_38988165; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single public key.
  ## 
  let valid = call_38988170.validator(path, query, header, formData, body, _)
  let scheme = call_38988170.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988170.url(scheme.get, call_38988170.host, call_38988170.base,
                           call_38988170.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988170, url, valid, _)

proc call*(call_38988171: Call_GetUserKeysKeyId_38988165; keyId: int;
          Accept: string = ""): Recallable =
  ## getUserKeysKeyId
  ## Get a single public key.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   keyId: int (required)
  ##        : ID of key.
  var path_38988172 = newJObject()
  var header_38988173 = newJObject()
  add(header_38988173, "Accept", newJString(Accept))
  add(path_38988172, "keyId", newJInt(keyId))
  result = call_38988171.call(path_38988172, nil, header_38988173, nil, nil)

var getUserKeysKeyId* = Call_GetUserKeysKeyId_38988165(name: "getUserKeysKeyId",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/keys/{keyId}",
    validator: validate_GetUserKeysKeyId_38988166, base: "/",
    url: url_GetUserKeysKeyId_38988167, schemes: {Scheme.Https})
type
  Call_DeleteUserKeysKeyId_38988174 = ref object of OpenApiRestCall_38985352
proc url_DeleteUserKeysKeyId_38988176(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/keys/"),
               (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserKeysKeyId_38988175(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Delete a public key. Removes a public key. Requires that you are authenticated via Basic Auth or via OAuth with at least admin:public_key scope.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyId: JInt (required)
  ##        : ID of key.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyId` field"
  var valid_38988177 = path.getOrDefault("keyId")
  valid_38988177 = validateParameter(valid_38988177, JInt, required = true,
                                   default = nil)
  if valid_38988177 != nil:
    section.add "keyId", valid_38988177
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988178 = header.getOrDefault("Accept")
  valid_38988178 = validateParameter(valid_38988178, JString, required = false,
                                   default = nil)
  if valid_38988178 != nil:
    section.add "Accept", valid_38988178
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988179: Call_DeleteUserKeysKeyId_38988174; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a public key. Removes a public key. Requires that you are authenticated via Basic Auth or via OAuth with at least admin:public_key scope.
  ## 
  let valid = call_38988179.validator(path, query, header, formData, body, _)
  let scheme = call_38988179.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988179.url(scheme.get, call_38988179.host, call_38988179.base,
                           call_38988179.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988179, url, valid, _)

proc call*(call_38988180: Call_DeleteUserKeysKeyId_38988174; keyId: int;
          Accept: string = ""): Recallable =
  ## deleteUserKeysKeyId
  ## Delete a public key. Removes a public key. Requires that you are authenticated via Basic Auth or via OAuth with at least admin:public_key scope.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   keyId: int (required)
  ##        : ID of key.
  var path_38988181 = newJObject()
  var header_38988182 = newJObject()
  add(header_38988182, "Accept", newJString(Accept))
  add(path_38988181, "keyId", newJInt(keyId))
  result = call_38988180.call(path_38988181, nil, header_38988182, nil, nil)

var deleteUserKeysKeyId* = Call_DeleteUserKeysKeyId_38988174(
    name: "deleteUserKeysKeyId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/keys/{keyId}",
    validator: validate_DeleteUserKeysKeyId_38988175, base: "/",
    url: url_DeleteUserKeysKeyId_38988176, schemes: {Scheme.Https})
type
  Call_GetUserOrgs_38988183 = ref object of OpenApiRestCall_38985352
proc url_GetUserOrgs_38988185(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserOrgs_38988184(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List public and private organizations for the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988186 = header.getOrDefault("Accept")
  valid_38988186 = validateParameter(valid_38988186, JString, required = false,
                                   default = nil)
  if valid_38988186 != nil:
    section.add "Accept", valid_38988186
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988187: Call_GetUserOrgs_38988183; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List public and private organizations for the authenticated user.
  ## 
  let valid = call_38988187.validator(path, query, header, formData, body, _)
  let scheme = call_38988187.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988187.url(scheme.get, call_38988187.host, call_38988187.base,
                           call_38988187.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988187, url, valid, _)

proc call*(call_38988188: Call_GetUserOrgs_38988183; Accept: string = ""): Recallable =
  ## getUserOrgs
  ## List public and private organizations for the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_38988189 = newJObject()
  add(header_38988189, "Accept", newJString(Accept))
  result = call_38988188.call(nil, nil, header_38988189, nil, nil)

var getUserOrgs* = Call_GetUserOrgs_38988183(name: "getUserOrgs",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/orgs",
    validator: validate_GetUserOrgs_38988184, base: "/", url: url_GetUserOrgs_38988185,
    schemes: {Scheme.Https})
type
  Call_PostUserRepos_38988199 = ref object of OpenApiRestCall_38985352
proc url_PostUserRepos_38988201(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostUserRepos_38988200(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988202 = header.getOrDefault("Accept")
  valid_38988202 = validateParameter(valid_38988202, JString, required = false,
                                   default = nil)
  if valid_38988202 != nil:
    section.add "Accept", valid_38988202
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_38988204: Call_PostUserRepos_38988199; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  let valid = call_38988204.validator(path, query, header, formData, body, _)
  let scheme = call_38988204.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988204.url(scheme.get, call_38988204.host, call_38988204.base,
                           call_38988204.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988204, url, valid, _)

proc call*(call_38988205: Call_PostUserRepos_38988199; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postUserRepos
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_38988206 = newJObject()
  var body_38988207 = newJObject()
  add(header_38988206, "Accept", newJString(Accept))
  if body != nil:
    body_38988207 = body
  result = call_38988205.call(nil, nil, header_38988206, nil, body_38988207)

var postUserRepos* = Call_PostUserRepos_38988199(name: "postUserRepos",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/user/repos",
    validator: validate_PostUserRepos_38988200, base: "/", url: url_PostUserRepos_38988201,
    schemes: {Scheme.Https})
type
  Call_GetUserRepos_38988190 = ref object of OpenApiRestCall_38985352
proc url_GetUserRepos_38988192(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserRepos_38988191(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## List repositories for the authenticated user. Note that this does not include
  ## repositories owned by organizations which the user can access. You can lis
  ## user organizations and list organization repositories separately.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   type: JString
  section = newJObject()
  var valid_38988193 = query.getOrDefault("type")
  valid_38988193 = validateParameter(valid_38988193, JString, required = false,
                                   default = newJString("all"))
  if valid_38988193 != nil:
    section.add "type", valid_38988193
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988194 = header.getOrDefault("Accept")
  valid_38988194 = validateParameter(valid_38988194, JString, required = false,
                                   default = nil)
  if valid_38988194 != nil:
    section.add "Accept", valid_38988194
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988195: Call_GetUserRepos_38988190; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List repositories for the authenticated user. Note that this does not include
  ## repositories owned by organizations which the user can access. You can lis
  ## user organizations and list organization repositories separately.
  ## 
  ## 
  let valid = call_38988195.validator(path, query, header, formData, body, _)
  let scheme = call_38988195.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988195.url(scheme.get, call_38988195.host, call_38988195.base,
                           call_38988195.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988195, url, valid, _)

proc call*(call_38988196: Call_GetUserRepos_38988190; Accept: string = "";
          `type`: string = "all"): Recallable =
  ## getUserRepos
  ## List repositories for the authenticated user. Note that this does not include
  ## repositories owned by organizations which the user can access. You can lis
  ## user organizations and list organization repositories separately.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   type: string
  var query_38988197 = newJObject()
  var header_38988198 = newJObject()
  add(header_38988198, "Accept", newJString(Accept))
  add(query_38988197, "type", newJString(`type`))
  result = call_38988196.call(nil, query_38988197, header_38988198, nil, nil)

var getUserRepos* = Call_GetUserRepos_38988190(name: "getUserRepos",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/repos",
    validator: validate_GetUserRepos_38988191, base: "/", url: url_GetUserRepos_38988192,
    schemes: {Scheme.Https})
type
  Call_GetUserStarred_38988208 = ref object of OpenApiRestCall_38985352
proc url_GetUserStarred_38988210(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserStarred_38988209(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List repositories being starred by the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  section = newJObject()
  var valid_38988211 = query.getOrDefault("sort")
  valid_38988211 = validateParameter(valid_38988211, JString, required = false,
                                   default = newJString("created"))
  if valid_38988211 != nil:
    section.add "sort", valid_38988211
  var valid_38988212 = query.getOrDefault("direction")
  valid_38988212 = validateParameter(valid_38988212, JString, required = false,
                                   default = nil)
  if valid_38988212 != nil:
    section.add "direction", valid_38988212
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988213 = header.getOrDefault("Accept")
  valid_38988213 = validateParameter(valid_38988213, JString, required = false,
                                   default = nil)
  if valid_38988213 != nil:
    section.add "Accept", valid_38988213
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988214: Call_GetUserStarred_38988208; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List repositories being starred by the authenticated user.
  ## 
  let valid = call_38988214.validator(path, query, header, formData, body, _)
  let scheme = call_38988214.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988214.url(scheme.get, call_38988214.host, call_38988214.base,
                           call_38988214.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988214, url, valid, _)

proc call*(call_38988215: Call_GetUserStarred_38988208; Accept: string = "";
          sort: string = "created"; direction: string = ""): Recallable =
  ## getUserStarred
  ## List repositories being starred by the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  var query_38988216 = newJObject()
  var header_38988217 = newJObject()
  add(header_38988217, "Accept", newJString(Accept))
  add(query_38988216, "sort", newJString(sort))
  add(query_38988216, "direction", newJString(direction))
  result = call_38988215.call(nil, query_38988216, header_38988217, nil, nil)

var getUserStarred* = Call_GetUserStarred_38988208(name: "getUserStarred",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/starred",
    validator: validate_GetUserStarred_38988209, base: "/", url: url_GetUserStarred_38988210,
    schemes: {Scheme.Https})
type
  Call_PutUserStarredOwnerRepo_38988228 = ref object of OpenApiRestCall_38985352
proc url_PutUserStarredOwnerRepo_38988230(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/starred/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutUserStarredOwnerRepo_38988229(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Star a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  ##   repo: JString (required)
  ##       : Name of a repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38988231 = path.getOrDefault("owner")
  valid_38988231 = validateParameter(valid_38988231, JString, required = true,
                                   default = nil)
  if valid_38988231 != nil:
    section.add "owner", valid_38988231
  var valid_38988232 = path.getOrDefault("repo")
  valid_38988232 = validateParameter(valid_38988232, JString, required = true,
                                   default = nil)
  if valid_38988232 != nil:
    section.add "repo", valid_38988232
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988233 = header.getOrDefault("Accept")
  valid_38988233 = validateParameter(valid_38988233, JString, required = false,
                                   default = nil)
  if valid_38988233 != nil:
    section.add "Accept", valid_38988233
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988234: Call_PutUserStarredOwnerRepo_38988228;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Star a repository.
  ## 
  let valid = call_38988234.validator(path, query, header, formData, body, _)
  let scheme = call_38988234.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988234.url(scheme.get, call_38988234.host, call_38988234.base,
                           call_38988234.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988234, url, valid, _)

proc call*(call_38988235: Call_PutUserStarredOwnerRepo_38988228; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## putUserStarredOwnerRepo
  ## Star a repository.
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  var path_38988236 = newJObject()
  var header_38988237 = newJObject()
  add(path_38988236, "owner", newJString(owner))
  add(header_38988237, "Accept", newJString(Accept))
  add(path_38988236, "repo", newJString(repo))
  result = call_38988235.call(path_38988236, nil, header_38988237, nil, nil)

var putUserStarredOwnerRepo* = Call_PutUserStarredOwnerRepo_38988228(
    name: "putUserStarredOwnerRepo", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/user/starred/{owner}/{repo}",
    validator: validate_PutUserStarredOwnerRepo_38988229, base: "/",
    url: url_PutUserStarredOwnerRepo_38988230, schemes: {Scheme.Https})
type
  Call_GetUserStarredOwnerRepo_38988218 = ref object of OpenApiRestCall_38985352
proc url_GetUserStarredOwnerRepo_38988220(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/starred/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserStarredOwnerRepo_38988219(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Check if you are starring a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  ##   repo: JString (required)
  ##       : Name of a repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38988221 = path.getOrDefault("owner")
  valid_38988221 = validateParameter(valid_38988221, JString, required = true,
                                   default = nil)
  if valid_38988221 != nil:
    section.add "owner", valid_38988221
  var valid_38988222 = path.getOrDefault("repo")
  valid_38988222 = validateParameter(valid_38988222, JString, required = true,
                                   default = nil)
  if valid_38988222 != nil:
    section.add "repo", valid_38988222
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988223 = header.getOrDefault("Accept")
  valid_38988223 = validateParameter(valid_38988223, JString, required = false,
                                   default = nil)
  if valid_38988223 != nil:
    section.add "Accept", valid_38988223
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988224: Call_GetUserStarredOwnerRepo_38988218;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if you are starring a repository.
  ## 
  let valid = call_38988224.validator(path, query, header, formData, body, _)
  let scheme = call_38988224.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988224.url(scheme.get, call_38988224.host, call_38988224.base,
                           call_38988224.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988224, url, valid, _)

proc call*(call_38988225: Call_GetUserStarredOwnerRepo_38988218; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getUserStarredOwnerRepo
  ## Check if you are starring a repository.
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  var path_38988226 = newJObject()
  var header_38988227 = newJObject()
  add(path_38988226, "owner", newJString(owner))
  add(header_38988227, "Accept", newJString(Accept))
  add(path_38988226, "repo", newJString(repo))
  result = call_38988225.call(path_38988226, nil, header_38988227, nil, nil)

var getUserStarredOwnerRepo* = Call_GetUserStarredOwnerRepo_38988218(
    name: "getUserStarredOwnerRepo", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/user/starred/{owner}/{repo}",
    validator: validate_GetUserStarredOwnerRepo_38988219, base: "/",
    url: url_GetUserStarredOwnerRepo_38988220, schemes: {Scheme.Https})
type
  Call_DeleteUserStarredOwnerRepo_38988238 = ref object of OpenApiRestCall_38985352
proc url_DeleteUserStarredOwnerRepo_38988240(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/starred/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserStarredOwnerRepo_38988239(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Unstar a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  ##   repo: JString (required)
  ##       : Name of a repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38988241 = path.getOrDefault("owner")
  valid_38988241 = validateParameter(valid_38988241, JString, required = true,
                                   default = nil)
  if valid_38988241 != nil:
    section.add "owner", valid_38988241
  var valid_38988242 = path.getOrDefault("repo")
  valid_38988242 = validateParameter(valid_38988242, JString, required = true,
                                   default = nil)
  if valid_38988242 != nil:
    section.add "repo", valid_38988242
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988243 = header.getOrDefault("Accept")
  valid_38988243 = validateParameter(valid_38988243, JString, required = false,
                                   default = nil)
  if valid_38988243 != nil:
    section.add "Accept", valid_38988243
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988244: Call_DeleteUserStarredOwnerRepo_38988238;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Unstar a repository
  ## 
  let valid = call_38988244.validator(path, query, header, formData, body, _)
  let scheme = call_38988244.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988244.url(scheme.get, call_38988244.host, call_38988244.base,
                           call_38988244.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988244, url, valid, _)

proc call*(call_38988245: Call_DeleteUserStarredOwnerRepo_38988238; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## deleteUserStarredOwnerRepo
  ## Unstar a repository
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  var path_38988246 = newJObject()
  var header_38988247 = newJObject()
  add(path_38988246, "owner", newJString(owner))
  add(header_38988247, "Accept", newJString(Accept))
  add(path_38988246, "repo", newJString(repo))
  result = call_38988245.call(path_38988246, nil, header_38988247, nil, nil)

var deleteUserStarredOwnerRepo* = Call_DeleteUserStarredOwnerRepo_38988238(
    name: "deleteUserStarredOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/starred/{owner}/{repo}",
    validator: validate_DeleteUserStarredOwnerRepo_38988239, base: "/",
    url: url_DeleteUserStarredOwnerRepo_38988240, schemes: {Scheme.Https})
type
  Call_GetUserSubscriptions_38988248 = ref object of OpenApiRestCall_38985352
proc url_GetUserSubscriptions_38988250(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserSubscriptions_38988249(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List repositories being watched by the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988251 = header.getOrDefault("Accept")
  valid_38988251 = validateParameter(valid_38988251, JString, required = false,
                                   default = nil)
  if valid_38988251 != nil:
    section.add "Accept", valid_38988251
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988252: Call_GetUserSubscriptions_38988248; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List repositories being watched by the authenticated user.
  ## 
  let valid = call_38988252.validator(path, query, header, formData, body, _)
  let scheme = call_38988252.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988252.url(scheme.get, call_38988252.host, call_38988252.base,
                           call_38988252.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988252, url, valid, _)

proc call*(call_38988253: Call_GetUserSubscriptions_38988248; Accept: string = ""): Recallable =
  ## getUserSubscriptions
  ## List repositories being watched by the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_38988254 = newJObject()
  add(header_38988254, "Accept", newJString(Accept))
  result = call_38988253.call(nil, nil, header_38988254, nil, nil)

var getUserSubscriptions* = Call_GetUserSubscriptions_38988248(
    name: "getUserSubscriptions", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/user/subscriptions", validator: validate_GetUserSubscriptions_38988249,
    base: "/", url: url_GetUserSubscriptions_38988250, schemes: {Scheme.Https})
type
  Call_PutUserSubscriptionsOwnerRepo_38988265 = ref object of OpenApiRestCall_38985352
proc url_PutUserSubscriptionsOwnerRepo_38988267(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/subscriptions/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutUserSubscriptionsOwnerRepo_38988266(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Watch a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of the owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38988268 = path.getOrDefault("owner")
  valid_38988268 = validateParameter(valid_38988268, JString, required = true,
                                   default = nil)
  if valid_38988268 != nil:
    section.add "owner", valid_38988268
  var valid_38988269 = path.getOrDefault("repo")
  valid_38988269 = validateParameter(valid_38988269, JString, required = true,
                                   default = nil)
  if valid_38988269 != nil:
    section.add "repo", valid_38988269
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988270 = header.getOrDefault("Accept")
  valid_38988270 = validateParameter(valid_38988270, JString, required = false,
                                   default = nil)
  if valid_38988270 != nil:
    section.add "Accept", valid_38988270
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988271: Call_PutUserSubscriptionsOwnerRepo_38988265;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Watch a repository.
  ## 
  let valid = call_38988271.validator(path, query, header, formData, body, _)
  let scheme = call_38988271.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988271.url(scheme.get, call_38988271.host, call_38988271.base,
                           call_38988271.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988271, url, valid, _)

proc call*(call_38988272: Call_PutUserSubscriptionsOwnerRepo_38988265;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## putUserSubscriptionsOwnerRepo
  ## Watch a repository.
  ##   owner: string (required)
  ##        : Name of the owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38988273 = newJObject()
  var header_38988274 = newJObject()
  add(path_38988273, "owner", newJString(owner))
  add(header_38988274, "Accept", newJString(Accept))
  add(path_38988273, "repo", newJString(repo))
  result = call_38988272.call(path_38988273, nil, header_38988274, nil, nil)

var putUserSubscriptionsOwnerRepo* = Call_PutUserSubscriptionsOwnerRepo_38988265(
    name: "putUserSubscriptionsOwnerRepo", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/user/subscriptions/{owner}/{repo}",
    validator: validate_PutUserSubscriptionsOwnerRepo_38988266, base: "/",
    url: url_PutUserSubscriptionsOwnerRepo_38988267, schemes: {Scheme.Https})
type
  Call_GetUserSubscriptionsOwnerRepo_38988255 = ref object of OpenApiRestCall_38985352
proc url_GetUserSubscriptionsOwnerRepo_38988257(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/subscriptions/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserSubscriptionsOwnerRepo_38988256(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Check if you are watching a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of the owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38988258 = path.getOrDefault("owner")
  valid_38988258 = validateParameter(valid_38988258, JString, required = true,
                                   default = nil)
  if valid_38988258 != nil:
    section.add "owner", valid_38988258
  var valid_38988259 = path.getOrDefault("repo")
  valid_38988259 = validateParameter(valid_38988259, JString, required = true,
                                   default = nil)
  if valid_38988259 != nil:
    section.add "repo", valid_38988259
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988260 = header.getOrDefault("Accept")
  valid_38988260 = validateParameter(valid_38988260, JString, required = false,
                                   default = nil)
  if valid_38988260 != nil:
    section.add "Accept", valid_38988260
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988261: Call_GetUserSubscriptionsOwnerRepo_38988255;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if you are watching a repository.
  ## 
  let valid = call_38988261.validator(path, query, header, formData, body, _)
  let scheme = call_38988261.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988261.url(scheme.get, call_38988261.host, call_38988261.base,
                           call_38988261.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988261, url, valid, _)

proc call*(call_38988262: Call_GetUserSubscriptionsOwnerRepo_38988255;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getUserSubscriptionsOwnerRepo
  ## Check if you are watching a repository.
  ##   owner: string (required)
  ##        : Name of the owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38988263 = newJObject()
  var header_38988264 = newJObject()
  add(path_38988263, "owner", newJString(owner))
  add(header_38988264, "Accept", newJString(Accept))
  add(path_38988263, "repo", newJString(repo))
  result = call_38988262.call(path_38988263, nil, header_38988264, nil, nil)

var getUserSubscriptionsOwnerRepo* = Call_GetUserSubscriptionsOwnerRepo_38988255(
    name: "getUserSubscriptionsOwnerRepo", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/user/subscriptions/{owner}/{repo}",
    validator: validate_GetUserSubscriptionsOwnerRepo_38988256, base: "/",
    url: url_GetUserSubscriptionsOwnerRepo_38988257, schemes: {Scheme.Https})
type
  Call_DeleteUserSubscriptionsOwnerRepo_38988275 = ref object of OpenApiRestCall_38985352
proc url_DeleteUserSubscriptionsOwnerRepo_38988277(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/subscriptions/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserSubscriptionsOwnerRepo_38988276(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Stop watching a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of the owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_38988278 = path.getOrDefault("owner")
  valid_38988278 = validateParameter(valid_38988278, JString, required = true,
                                   default = nil)
  if valid_38988278 != nil:
    section.add "owner", valid_38988278
  var valid_38988279 = path.getOrDefault("repo")
  valid_38988279 = validateParameter(valid_38988279, JString, required = true,
                                   default = nil)
  if valid_38988279 != nil:
    section.add "repo", valid_38988279
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988280 = header.getOrDefault("Accept")
  valid_38988280 = validateParameter(valid_38988280, JString, required = false,
                                   default = nil)
  if valid_38988280 != nil:
    section.add "Accept", valid_38988280
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988281: Call_DeleteUserSubscriptionsOwnerRepo_38988275;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Stop watching a repository
  ## 
  let valid = call_38988281.validator(path, query, header, formData, body, _)
  let scheme = call_38988281.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988281.url(scheme.get, call_38988281.host, call_38988281.base,
                           call_38988281.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988281, url, valid, _)

proc call*(call_38988282: Call_DeleteUserSubscriptionsOwnerRepo_38988275;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## deleteUserSubscriptionsOwnerRepo
  ## Stop watching a repository
  ##   owner: string (required)
  ##        : Name of the owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_38988283 = newJObject()
  var header_38988284 = newJObject()
  add(path_38988283, "owner", newJString(owner))
  add(header_38988284, "Accept", newJString(Accept))
  add(path_38988283, "repo", newJString(repo))
  result = call_38988282.call(path_38988283, nil, header_38988284, nil, nil)

var deleteUserSubscriptionsOwnerRepo* = Call_DeleteUserSubscriptionsOwnerRepo_38988275(
    name: "deleteUserSubscriptionsOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/subscriptions/{owner}/{repo}",
    validator: validate_DeleteUserSubscriptionsOwnerRepo_38988276, base: "/",
    url: url_DeleteUserSubscriptionsOwnerRepo_38988277, schemes: {Scheme.Https})
type
  Call_GetUserTeams_38988285 = ref object of OpenApiRestCall_38985352
proc url_GetUserTeams_38988287(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserTeams_38988286(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## List all of the teams across all of the organizations to which the authenticated user belongs. This method requires user or repo scope when authenticating via OAuth.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988288 = header.getOrDefault("Accept")
  valid_38988288 = validateParameter(valid_38988288, JString, required = false,
                                   default = nil)
  if valid_38988288 != nil:
    section.add "Accept", valid_38988288
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988289: Call_GetUserTeams_38988285; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List all of the teams across all of the organizations to which the authenticated user belongs. This method requires user or repo scope when authenticating via OAuth.
  ## 
  let valid = call_38988289.validator(path, query, header, formData, body, _)
  let scheme = call_38988289.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988289.url(scheme.get, call_38988289.host, call_38988289.base,
                           call_38988289.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988289, url, valid, _)

proc call*(call_38988290: Call_GetUserTeams_38988285; Accept: string = ""): Recallable =
  ## getUserTeams
  ## List all of the teams across all of the organizations to which the authenticated user belongs. This method requires user or repo scope when authenticating via OAuth.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_38988291 = newJObject()
  add(header_38988291, "Accept", newJString(Accept))
  result = call_38988290.call(nil, nil, header_38988291, nil, nil)

var getUserTeams* = Call_GetUserTeams_38988285(name: "getUserTeams",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/teams",
    validator: validate_GetUserTeams_38988286, base: "/", url: url_GetUserTeams_38988287,
    schemes: {Scheme.Https})
type
  Call_GetUsers_38988292 = ref object of OpenApiRestCall_38985352
proc url_GetUsers_38988294(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUsers_38988293(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get all users.
  ## This provides a dump of every user, in the order that they signed up for GitHub.
  ## Note: Pagination is powered exclusively by the since parameter. Use the Link
  ## header to get the URL for the next page of users.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JInt
  ##        : The integer ID of the last user that you've seen.
  section = newJObject()
  var valid_38988295 = query.getOrDefault("since")
  valid_38988295 = validateParameter(valid_38988295, JInt, required = false,
                                   default = nil)
  if valid_38988295 != nil:
    section.add "since", valid_38988295
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988296 = header.getOrDefault("Accept")
  valid_38988296 = validateParameter(valid_38988296, JString, required = false,
                                   default = nil)
  if valid_38988296 != nil:
    section.add "Accept", valid_38988296
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988297: Call_GetUsers_38988292; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get all users.
  ## This provides a dump of every user, in the order that they signed up for GitHub.
  ## Note: Pagination is powered exclusively by the since parameter. Use the Link
  ## header to get the URL for the next page of users.
  ## 
  ## 
  let valid = call_38988297.validator(path, query, header, formData, body, _)
  let scheme = call_38988297.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988297.url(scheme.get, call_38988297.host, call_38988297.base,
                           call_38988297.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988297, url, valid, _)

proc call*(call_38988298: Call_GetUsers_38988292; Accept: string = ""; since: int = 0): Recallable =
  ## getUsers
  ## Get all users.
  ## This provides a dump of every user, in the order that they signed up for GitHub.
  ## Note: Pagination is powered exclusively by the since parameter. Use the Link
  ## header to get the URL for the next page of users.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: int
  ##        : The integer ID of the last user that you've seen.
  var query_38988299 = newJObject()
  var header_38988300 = newJObject()
  add(header_38988300, "Accept", newJString(Accept))
  add(query_38988299, "since", newJInt(since))
  result = call_38988298.call(nil, query_38988299, header_38988300, nil, nil)

var getUsers* = Call_GetUsers_38988292(name: "getUsers", meth: HttpMethod.HttpGet,
                                    host: "api.github.com", route: "/users",
                                    validator: validate_GetUsers_38988293,
                                    base: "/", url: url_GetUsers_38988294,
                                    schemes: {Scheme.Https})
type
  Call_GetUsersUsername_38988301 = ref object of OpenApiRestCall_38985352
proc url_GetUsersUsername_38988303(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsername_38988302(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get a single user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_38988304 = path.getOrDefault("username")
  valid_38988304 = validateParameter(valid_38988304, JString, required = true,
                                   default = nil)
  if valid_38988304 != nil:
    section.add "username", valid_38988304
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988305 = header.getOrDefault("Accept")
  valid_38988305 = validateParameter(valid_38988305, JString, required = false,
                                   default = nil)
  if valid_38988305 != nil:
    section.add "Accept", valid_38988305
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988306: Call_GetUsersUsername_38988301; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single user.
  ## 
  let valid = call_38988306.validator(path, query, header, formData, body, _)
  let scheme = call_38988306.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988306.url(scheme.get, call_38988306.host, call_38988306.base,
                           call_38988306.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988306, url, valid, _)

proc call*(call_38988307: Call_GetUsersUsername_38988301; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsername
  ## Get a single user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_38988308 = newJObject()
  var header_38988309 = newJObject()
  add(path_38988308, "username", newJString(username))
  add(header_38988309, "Accept", newJString(Accept))
  result = call_38988307.call(path_38988308, nil, header_38988309, nil, nil)

var getUsersUsername* = Call_GetUsersUsername_38988301(name: "getUsersUsername",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/users/{username}",
    validator: validate_GetUsersUsername_38988302, base: "/",
    url: url_GetUsersUsername_38988303, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameEvents_38988310 = ref object of OpenApiRestCall_38985352
proc url_GetUsersUsernameEvents_38988312(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameEvents_38988311(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_38988313 = path.getOrDefault("username")
  valid_38988313 = validateParameter(valid_38988313, JString, required = true,
                                   default = nil)
  if valid_38988313 != nil:
    section.add "username", valid_38988313
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988314 = header.getOrDefault("Accept")
  valid_38988314 = validateParameter(valid_38988314, JString, required = false,
                                   default = nil)
  if valid_38988314 != nil:
    section.add "Accept", valid_38988314
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988315: Call_GetUsersUsernameEvents_38988310;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
  ## 
  let valid = call_38988315.validator(path, query, header, formData, body, _)
  let scheme = call_38988315.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988315.url(scheme.get, call_38988315.host, call_38988315.base,
                           call_38988315.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988315, url, valid, _)

proc call*(call_38988316: Call_GetUsersUsernameEvents_38988310; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameEvents
  ## If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_38988317 = newJObject()
  var header_38988318 = newJObject()
  add(path_38988317, "username", newJString(username))
  add(header_38988318, "Accept", newJString(Accept))
  result = call_38988316.call(path_38988317, nil, header_38988318, nil, nil)

var getUsersUsernameEvents* = Call_GetUsersUsernameEvents_38988310(
    name: "getUsersUsernameEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/events",
    validator: validate_GetUsersUsernameEvents_38988311, base: "/",
    url: url_GetUsersUsernameEvents_38988312, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameEventsOrgsOrg_38988319 = ref object of OpenApiRestCall_38985352
proc url_GetUsersUsernameEventsOrgsOrg_38988321(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/events/orgs/"),
               (kind: VariableSegment, value: "org")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameEventsOrgsOrg_38988320(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## This is the user's organization dashboard. You must be authenticated as the user to view this.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  ##   org: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_38988322 = path.getOrDefault("username")
  valid_38988322 = validateParameter(valid_38988322, JString, required = true,
                                   default = nil)
  if valid_38988322 != nil:
    section.add "username", valid_38988322
  var valid_38988323 = path.getOrDefault("org")
  valid_38988323 = validateParameter(valid_38988323, JString, required = true,
                                   default = nil)
  if valid_38988323 != nil:
    section.add "org", valid_38988323
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988324 = header.getOrDefault("Accept")
  valid_38988324 = validateParameter(valid_38988324, JString, required = false,
                                   default = nil)
  if valid_38988324 != nil:
    section.add "Accept", valid_38988324
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988325: Call_GetUsersUsernameEventsOrgsOrg_38988319;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## This is the user's organization dashboard. You must be authenticated as the user to view this.
  ## 
  let valid = call_38988325.validator(path, query, header, formData, body, _)
  let scheme = call_38988325.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988325.url(scheme.get, call_38988325.host, call_38988325.base,
                           call_38988325.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988325, url, valid, _)

proc call*(call_38988326: Call_GetUsersUsernameEventsOrgsOrg_38988319;
          username: string; org: string; Accept: string = ""): Recallable =
  ## getUsersUsernameEventsOrgsOrg
  ## This is the user's organization dashboard. You must be authenticated as the user to view this.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  var path_38988327 = newJObject()
  var header_38988328 = newJObject()
  add(path_38988327, "username", newJString(username))
  add(header_38988328, "Accept", newJString(Accept))
  add(path_38988327, "org", newJString(org))
  result = call_38988326.call(path_38988327, nil, header_38988328, nil, nil)

var getUsersUsernameEventsOrgsOrg* = Call_GetUsersUsernameEventsOrgsOrg_38988319(
    name: "getUsersUsernameEventsOrgsOrg", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/events/orgs/{org}",
    validator: validate_GetUsersUsernameEventsOrgsOrg_38988320, base: "/",
    url: url_GetUsersUsernameEventsOrgsOrg_38988321, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameFollowers_38988329 = ref object of OpenApiRestCall_38985352
proc url_GetUsersUsernameFollowers_38988331(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/followers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameFollowers_38988330(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List a user's followers
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_38988332 = path.getOrDefault("username")
  valid_38988332 = validateParameter(valid_38988332, JString, required = true,
                                   default = nil)
  if valid_38988332 != nil:
    section.add "username", valid_38988332
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988333 = header.getOrDefault("Accept")
  valid_38988333 = validateParameter(valid_38988333, JString, required = false,
                                   default = nil)
  if valid_38988333 != nil:
    section.add "Accept", valid_38988333
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988334: Call_GetUsersUsernameFollowers_38988329;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List a user's followers
  ## 
  let valid = call_38988334.validator(path, query, header, formData, body, _)
  let scheme = call_38988334.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988334.url(scheme.get, call_38988334.host, call_38988334.base,
                           call_38988334.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988334, url, valid, _)

proc call*(call_38988335: Call_GetUsersUsernameFollowers_38988329;
          username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameFollowers
  ## List a user's followers
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_38988336 = newJObject()
  var header_38988337 = newJObject()
  add(path_38988336, "username", newJString(username))
  add(header_38988337, "Accept", newJString(Accept))
  result = call_38988335.call(path_38988336, nil, header_38988337, nil, nil)

var getUsersUsernameFollowers* = Call_GetUsersUsernameFollowers_38988329(
    name: "getUsersUsernameFollowers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/followers",
    validator: validate_GetUsersUsernameFollowers_38988330, base: "/",
    url: url_GetUsersUsernameFollowers_38988331, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameFollowingTargetUser_38988338 = ref object of OpenApiRestCall_38985352
proc url_GetUsersUsernameFollowingTargetUser_38988340(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  assert "targetUser" in path, "`targetUser` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/following/"),
               (kind: VariableSegment, value: "targetUser")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameFollowingTargetUser_38988339(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Check if one user follows another.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  ##   targetUser: JString (required)
  ##             : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_38988341 = path.getOrDefault("username")
  valid_38988341 = validateParameter(valid_38988341, JString, required = true,
                                   default = nil)
  if valid_38988341 != nil:
    section.add "username", valid_38988341
  var valid_38988342 = path.getOrDefault("targetUser")
  valid_38988342 = validateParameter(valid_38988342, JString, required = true,
                                   default = nil)
  if valid_38988342 != nil:
    section.add "targetUser", valid_38988342
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988343 = header.getOrDefault("Accept")
  valid_38988343 = validateParameter(valid_38988343, JString, required = false,
                                   default = nil)
  if valid_38988343 != nil:
    section.add "Accept", valid_38988343
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988344: Call_GetUsersUsernameFollowingTargetUser_38988338;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if one user follows another.
  ## 
  let valid = call_38988344.validator(path, query, header, formData, body, _)
  let scheme = call_38988344.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988344.url(scheme.get, call_38988344.host, call_38988344.base,
                           call_38988344.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988344, url, valid, _)

proc call*(call_38988345: Call_GetUsersUsernameFollowingTargetUser_38988338;
          username: string; targetUser: string; Accept: string = ""): Recallable =
  ## getUsersUsernameFollowingTargetUser
  ## Check if one user follows another.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   targetUser: string (required)
  ##             : Name of user.
  var path_38988346 = newJObject()
  var header_38988347 = newJObject()
  add(path_38988346, "username", newJString(username))
  add(header_38988347, "Accept", newJString(Accept))
  add(path_38988346, "targetUser", newJString(targetUser))
  result = call_38988345.call(path_38988346, nil, header_38988347, nil, nil)

var getUsersUsernameFollowingTargetUser* = Call_GetUsersUsernameFollowingTargetUser_38988338(
    name: "getUsersUsernameFollowingTargetUser", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/following/{targetUser}",
    validator: validate_GetUsersUsernameFollowingTargetUser_38988339, base: "/",
    url: url_GetUsersUsernameFollowingTargetUser_38988340, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameGists_38988348 = ref object of OpenApiRestCall_38985352
proc url_GetUsersUsernameGists_38988350(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/gists")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameGists_38988349(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List a users gists.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_38988351 = path.getOrDefault("username")
  valid_38988351 = validateParameter(valid_38988351, JString, required = true,
                                   default = nil)
  if valid_38988351 != nil:
    section.add "username", valid_38988351
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_38988352 = query.getOrDefault("since")
  valid_38988352 = validateParameter(valid_38988352, JString, required = false,
                                   default = nil)
  if valid_38988352 != nil:
    section.add "since", valid_38988352
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988353 = header.getOrDefault("Accept")
  valid_38988353 = validateParameter(valid_38988353, JString, required = false,
                                   default = nil)
  if valid_38988353 != nil:
    section.add "Accept", valid_38988353
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988354: Call_GetUsersUsernameGists_38988348;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List a users gists.
  ## 
  let valid = call_38988354.validator(path, query, header, formData, body, _)
  let scheme = call_38988354.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988354.url(scheme.get, call_38988354.host, call_38988354.base,
                           call_38988354.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988354, url, valid, _)

proc call*(call_38988355: Call_GetUsersUsernameGists_38988348; username: string;
          Accept: string = ""; since: string = ""): Recallable =
  ## getUsersUsernameGists
  ## List a users gists.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var path_38988356 = newJObject()
  var query_38988357 = newJObject()
  var header_38988358 = newJObject()
  add(path_38988356, "username", newJString(username))
  add(header_38988358, "Accept", newJString(Accept))
  add(query_38988357, "since", newJString(since))
  result = call_38988355.call(path_38988356, query_38988357, header_38988358, nil, nil)

var getUsersUsernameGists* = Call_GetUsersUsernameGists_38988348(
    name: "getUsersUsernameGists", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/users/{username}/gists", validator: validate_GetUsersUsernameGists_38988349,
    base: "/", url: url_GetUsersUsernameGists_38988350, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameKeys_38988359 = ref object of OpenApiRestCall_38985352
proc url_GetUsersUsernameKeys_38988361(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/keys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameKeys_38988360(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List public keys for a user.
  ## Lists the verified public keys for a user. This is accessible by anyone.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_38988362 = path.getOrDefault("username")
  valid_38988362 = validateParameter(valid_38988362, JString, required = true,
                                   default = nil)
  if valid_38988362 != nil:
    section.add "username", valid_38988362
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988363 = header.getOrDefault("Accept")
  valid_38988363 = validateParameter(valid_38988363, JString, required = false,
                                   default = nil)
  if valid_38988363 != nil:
    section.add "Accept", valid_38988363
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988364: Call_GetUsersUsernameKeys_38988359; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List public keys for a user.
  ## Lists the verified public keys for a user. This is accessible by anyone.
  ## 
  ## 
  let valid = call_38988364.validator(path, query, header, formData, body, _)
  let scheme = call_38988364.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988364.url(scheme.get, call_38988364.host, call_38988364.base,
                           call_38988364.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988364, url, valid, _)

proc call*(call_38988365: Call_GetUsersUsernameKeys_38988359; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameKeys
  ## List public keys for a user.
  ## Lists the verified public keys for a user. This is accessible by anyone.
  ## 
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_38988366 = newJObject()
  var header_38988367 = newJObject()
  add(path_38988366, "username", newJString(username))
  add(header_38988367, "Accept", newJString(Accept))
  result = call_38988365.call(path_38988366, nil, header_38988367, nil, nil)

var getUsersUsernameKeys* = Call_GetUsersUsernameKeys_38988359(
    name: "getUsersUsernameKeys", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/users/{username}/keys", validator: validate_GetUsersUsernameKeys_38988360,
    base: "/", url: url_GetUsersUsernameKeys_38988361, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameOrgs_38988368 = ref object of OpenApiRestCall_38985352
proc url_GetUsersUsernameOrgs_38988370(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/orgs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameOrgs_38988369(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List all public organizations for a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_38988371 = path.getOrDefault("username")
  valid_38988371 = validateParameter(valid_38988371, JString, required = true,
                                   default = nil)
  if valid_38988371 != nil:
    section.add "username", valid_38988371
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988372 = header.getOrDefault("Accept")
  valid_38988372 = validateParameter(valid_38988372, JString, required = false,
                                   default = nil)
  if valid_38988372 != nil:
    section.add "Accept", valid_38988372
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988373: Call_GetUsersUsernameOrgs_38988368; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List all public organizations for a user.
  ## 
  let valid = call_38988373.validator(path, query, header, formData, body, _)
  let scheme = call_38988373.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988373.url(scheme.get, call_38988373.host, call_38988373.base,
                           call_38988373.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988373, url, valid, _)

proc call*(call_38988374: Call_GetUsersUsernameOrgs_38988368; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameOrgs
  ## List all public organizations for a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_38988375 = newJObject()
  var header_38988376 = newJObject()
  add(path_38988375, "username", newJString(username))
  add(header_38988376, "Accept", newJString(Accept))
  result = call_38988374.call(path_38988375, nil, header_38988376, nil, nil)

var getUsersUsernameOrgs* = Call_GetUsersUsernameOrgs_38988368(
    name: "getUsersUsernameOrgs", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/users/{username}/orgs", validator: validate_GetUsersUsernameOrgs_38988369,
    base: "/", url: url_GetUsersUsernameOrgs_38988370, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameReceivedEvents_38988377 = ref object of OpenApiRestCall_38985352
proc url_GetUsersUsernameReceivedEvents_38988379(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/received_events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameReceivedEvents_38988378(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## These are events that you'll only see public events.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_38988380 = path.getOrDefault("username")
  valid_38988380 = validateParameter(valid_38988380, JString, required = true,
                                   default = nil)
  if valid_38988380 != nil:
    section.add "username", valid_38988380
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988381 = header.getOrDefault("Accept")
  valid_38988381 = validateParameter(valid_38988381, JString, required = false,
                                   default = nil)
  if valid_38988381 != nil:
    section.add "Accept", valid_38988381
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988382: Call_GetUsersUsernameReceivedEvents_38988377;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## These are events that you'll only see public events.
  ## 
  let valid = call_38988382.validator(path, query, header, formData, body, _)
  let scheme = call_38988382.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988382.url(scheme.get, call_38988382.host, call_38988382.base,
                           call_38988382.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988382, url, valid, _)

proc call*(call_38988383: Call_GetUsersUsernameReceivedEvents_38988377;
          username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameReceivedEvents
  ## These are events that you'll only see public events.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_38988384 = newJObject()
  var header_38988385 = newJObject()
  add(path_38988384, "username", newJString(username))
  add(header_38988385, "Accept", newJString(Accept))
  result = call_38988383.call(path_38988384, nil, header_38988385, nil, nil)

var getUsersUsernameReceivedEvents* = Call_GetUsersUsernameReceivedEvents_38988377(
    name: "getUsersUsernameReceivedEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/received_events",
    validator: validate_GetUsersUsernameReceivedEvents_38988378, base: "/",
    url: url_GetUsersUsernameReceivedEvents_38988379, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameReceivedEventsPublic_38988386 = ref object of OpenApiRestCall_38985352
proc url_GetUsersUsernameReceivedEventsPublic_38988388(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/received_events/public")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameReceivedEventsPublic_38988387(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List public events that a user has received
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_38988389 = path.getOrDefault("username")
  valid_38988389 = validateParameter(valid_38988389, JString, required = true,
                                   default = nil)
  if valid_38988389 != nil:
    section.add "username", valid_38988389
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988390 = header.getOrDefault("Accept")
  valid_38988390 = validateParameter(valid_38988390, JString, required = false,
                                   default = nil)
  if valid_38988390 != nil:
    section.add "Accept", valid_38988390
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988391: Call_GetUsersUsernameReceivedEventsPublic_38988386;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List public events that a user has received
  ## 
  let valid = call_38988391.validator(path, query, header, formData, body, _)
  let scheme = call_38988391.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988391.url(scheme.get, call_38988391.host, call_38988391.base,
                           call_38988391.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988391, url, valid, _)

proc call*(call_38988392: Call_GetUsersUsernameReceivedEventsPublic_38988386;
          username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameReceivedEventsPublic
  ## List public events that a user has received
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_38988393 = newJObject()
  var header_38988394 = newJObject()
  add(path_38988393, "username", newJString(username))
  add(header_38988394, "Accept", newJString(Accept))
  result = call_38988392.call(path_38988393, nil, header_38988394, nil, nil)

var getUsersUsernameReceivedEventsPublic* = Call_GetUsersUsernameReceivedEventsPublic_38988386(
    name: "getUsersUsernameReceivedEventsPublic", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/received_events/public",
    validator: validate_GetUsersUsernameReceivedEventsPublic_38988387, base: "/",
    url: url_GetUsersUsernameReceivedEventsPublic_38988388,
    schemes: {Scheme.Https})
type
  Call_GetUsersUsernameRepos_38988395 = ref object of OpenApiRestCall_38985352
proc url_GetUsersUsernameRepos_38988397(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameRepos_38988396(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List public repositories for the specified user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_38988398 = path.getOrDefault("username")
  valid_38988398 = validateParameter(valid_38988398, JString, required = true,
                                   default = nil)
  if valid_38988398 != nil:
    section.add "username", valid_38988398
  result.add "path", section
  ## parameters in `query` object:
  ##   type: JString
  section = newJObject()
  var valid_38988399 = query.getOrDefault("type")
  valid_38988399 = validateParameter(valid_38988399, JString, required = false,
                                   default = newJString("all"))
  if valid_38988399 != nil:
    section.add "type", valid_38988399
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988400 = header.getOrDefault("Accept")
  valid_38988400 = validateParameter(valid_38988400, JString, required = false,
                                   default = nil)
  if valid_38988400 != nil:
    section.add "Accept", valid_38988400
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988401: Call_GetUsersUsernameRepos_38988395;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List public repositories for the specified user.
  ## 
  let valid = call_38988401.validator(path, query, header, formData, body, _)
  let scheme = call_38988401.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988401.url(scheme.get, call_38988401.host, call_38988401.base,
                           call_38988401.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988401, url, valid, _)

proc call*(call_38988402: Call_GetUsersUsernameRepos_38988395; username: string;
          Accept: string = ""; `type`: string = "all"): Recallable =
  ## getUsersUsernameRepos
  ## List public repositories for the specified user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   type: string
  var path_38988403 = newJObject()
  var query_38988404 = newJObject()
  var header_38988405 = newJObject()
  add(path_38988403, "username", newJString(username))
  add(header_38988405, "Accept", newJString(Accept))
  add(query_38988404, "type", newJString(`type`))
  result = call_38988402.call(path_38988403, query_38988404, header_38988405, nil, nil)

var getUsersUsernameRepos* = Call_GetUsersUsernameRepos_38988395(
    name: "getUsersUsernameRepos", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/users/{username}/repos", validator: validate_GetUsersUsernameRepos_38988396,
    base: "/", url: url_GetUsersUsernameRepos_38988397, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameStarred_38988406 = ref object of OpenApiRestCall_38985352
proc url_GetUsersUsernameStarred_38988408(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/starred")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameStarred_38988407(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List repositories being starred by a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_38988409 = path.getOrDefault("username")
  valid_38988409 = validateParameter(valid_38988409, JString, required = true,
                                   default = nil)
  if valid_38988409 != nil:
    section.add "username", valid_38988409
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988410 = header.getOrDefault("Accept")
  valid_38988410 = validateParameter(valid_38988410, JString, required = false,
                                   default = nil)
  if valid_38988410 != nil:
    section.add "Accept", valid_38988410
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988411: Call_GetUsersUsernameStarred_38988406;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List repositories being starred by a user.
  ## 
  let valid = call_38988411.validator(path, query, header, formData, body, _)
  let scheme = call_38988411.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988411.url(scheme.get, call_38988411.host, call_38988411.base,
                           call_38988411.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988411, url, valid, _)

proc call*(call_38988412: Call_GetUsersUsernameStarred_38988406; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameStarred
  ## List repositories being starred by a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_38988413 = newJObject()
  var header_38988414 = newJObject()
  add(path_38988413, "username", newJString(username))
  add(header_38988414, "Accept", newJString(Accept))
  result = call_38988412.call(path_38988413, nil, header_38988414, nil, nil)

var getUsersUsernameStarred* = Call_GetUsersUsernameStarred_38988406(
    name: "getUsersUsernameStarred", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/starred",
    validator: validate_GetUsersUsernameStarred_38988407, base: "/",
    url: url_GetUsersUsernameStarred_38988408, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameSubscriptions_38988415 = ref object of OpenApiRestCall_38985352
proc url_GetUsersUsernameSubscriptions_38988417(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/subscriptions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameSubscriptions_38988416(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List repositories being watched by a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_38988418 = path.getOrDefault("username")
  valid_38988418 = validateParameter(valid_38988418, JString, required = true,
                                   default = nil)
  if valid_38988418 != nil:
    section.add "username", valid_38988418
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_38988419 = header.getOrDefault("Accept")
  valid_38988419 = validateParameter(valid_38988419, JString, required = false,
                                   default = nil)
  if valid_38988419 != nil:
    section.add "Accept", valid_38988419
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_38988420: Call_GetUsersUsernameSubscriptions_38988415;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List repositories being watched by a user.
  ## 
  let valid = call_38988420.validator(path, query, header, formData, body, _)
  let scheme = call_38988420.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_38988420.url(scheme.get, call_38988420.host, call_38988420.base,
                           call_38988420.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_38988420, url, valid, _)

proc call*(call_38988421: Call_GetUsersUsernameSubscriptions_38988415;
          username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameSubscriptions
  ## List repositories being watched by a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_38988422 = newJObject()
  var header_38988423 = newJObject()
  add(path_38988422, "username", newJString(username))
  add(header_38988423, "Accept", newJString(Accept))
  result = call_38988421.call(path_38988422, nil, header_38988423, nil, nil)

var getUsersUsernameSubscriptions* = Call_GetUsersUsernameSubscriptions_38988415(
    name: "getUsersUsernameSubscriptions", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/subscriptions",
    validator: validate_GetUsersUsernameSubscriptions_38988416, base: "/",
    url: url_GetUsersUsernameSubscriptions_38988417, schemes: {Scheme.Https})
export
  rest

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode; body: string): Recallable {.
    base.} =
  var headers = massageHeaders(input.getOrDefault("header")).newHttpHeaders
  let token = os.getEnv("GITHUB_TOKEN", "")
  if not headers.hasKey("Authorization") and token.len > 0:
    headers.add "Authorization", "token " & token
  if headers.hasKey "Accept":
    headers.del "Accept"
  headers.add "Accept", "application/vnd.github.v3+json"
  result = newRecallable(call, url, headers, body)
