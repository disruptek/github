
import
  json, options, hashes, uri, strutils, rest, os, uri, httpcore

## auto-generated via openapi macro
## title: GitHub
## version: v3
## termsOfService: https://help.github.com/articles/github-terms-of-service/#b-api-terms
## license: (not provided)
## 
## Powerful collaboration, code review, and code management for open source and private projects.
## 
## 
## https://developer.github.com/v3/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (path: JsonNode = nil; query: JsonNode = nil;
                          header: JsonNode = nil; formData: JsonNode = nil;
                          body: JsonNode = nil; _: string = ""): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    makeUrl*: proc (protocol: Scheme; host: string; base: string; route: string;
                  path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_753573 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_753573](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_753573): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low ..
      Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js ==
      nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result ==
      nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind ==
        kind, $kind & " expected; received " &
        $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string {.used.} =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] {.used.} =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    case js.kind
    of JInt, JFloat, JNull, JBool:
      head = $js
    of JString:
      head = js.getStr
    else:
      return
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode; body: string = ""): Recallable {.
    base.}
type
  Call_GetEmojis_753777 = ref object of OpenApiRestCall_753573
proc url_GetEmojis_753779(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEmojis_753778(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Lists all the emojis available to use on GitHub.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_753925 = header.getOrDefault("Accept")
  valid_753925 = validateParameter(valid_753925, JString, required = false,
                                 default = nil)
  if valid_753925 != nil:
    section.add "Accept", valid_753925
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_753949: Call_GetEmojis_753777; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Lists all the emojis available to use on GitHub.
  ## 
  let valid = call_753949.validator(path, query, header, formData, body, _)
  let scheme = call_753949.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_753949.makeUrl(scheme.get, call_753949.host, call_753949.base,
                             call_753949.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_753949, uri, valid, _)

proc call*(call_754020: Call_GetEmojis_753777; Accept: string = ""): Recallable =
  ## getEmojis
  ## Lists all the emojis available to use on GitHub.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_754021 = newJObject()
  add(header_754021, "Accept", newJString(Accept))
  result = call_754020.call(nil, nil, header_754021, nil, nil)

var getEmojis* = Call_GetEmojis_753777(name: "getEmojis", meth: HttpMethod.HttpGet,
                                    host: "api.github.com", route: "/emojis",
                                    validator: validate_GetEmojis_753778,
                                    base: "/", makeUrl: url_GetEmojis_753779,
                                    schemes: {Scheme.Https})
type
  Call_GetEvents_754061 = ref object of OpenApiRestCall_753573
proc url_GetEvents_754063(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEvents_754062(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List public events.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754064 = header.getOrDefault("Accept")
  valid_754064 = validateParameter(valid_754064, JString, required = false,
                                 default = nil)
  if valid_754064 != nil:
    section.add "Accept", valid_754064
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754065: Call_GetEvents_754061; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List public events.
  ## 
  let valid = call_754065.validator(path, query, header, formData, body, _)
  let scheme = call_754065.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754065.makeUrl(scheme.get, call_754065.host, call_754065.base,
                             call_754065.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754065, uri, valid, _)

proc call*(call_754066: Call_GetEvents_754061; Accept: string = ""): Recallable =
  ## getEvents
  ## List public events.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_754067 = newJObject()
  add(header_754067, "Accept", newJString(Accept))
  result = call_754066.call(nil, nil, header_754067, nil, nil)

var getEvents* = Call_GetEvents_754061(name: "getEvents", meth: HttpMethod.HttpGet,
                                    host: "api.github.com", route: "/events",
                                    validator: validate_GetEvents_754062,
                                    base: "/", makeUrl: url_GetEvents_754063,
                                    schemes: {Scheme.Https})
type
  Call_GetFeeds_754068 = ref object of OpenApiRestCall_753573
proc url_GetFeeds_754070(protocol: Scheme; host: string; base: string; route: string;
                        path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetFeeds_754069(path: JsonNode; query: JsonNode; header: JsonNode;
                             formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List Feeds.
  ## GitHub provides several timeline resources in Atom format. The Feeds API
  ##  lists all the feeds available to the authenticating user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754071 = header.getOrDefault("Accept")
  valid_754071 = validateParameter(valid_754071, JString, required = false,
                                 default = nil)
  if valid_754071 != nil:
    section.add "Accept", valid_754071
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754072: Call_GetFeeds_754068; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List Feeds.
  ## GitHub provides several timeline resources in Atom format. The Feeds API
  ##  lists all the feeds available to the authenticating user.
  ## 
  ## 
  let valid = call_754072.validator(path, query, header, formData, body, _)
  let scheme = call_754072.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754072.makeUrl(scheme.get, call_754072.host, call_754072.base,
                             call_754072.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754072, uri, valid, _)

proc call*(call_754073: Call_GetFeeds_754068; Accept: string = ""): Recallable =
  ## getFeeds
  ## List Feeds.
  ## GitHub provides several timeline resources in Atom format. The Feeds API
  ##  lists all the feeds available to the authenticating user.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_754074 = newJObject()
  add(header_754074, "Accept", newJString(Accept))
  result = call_754073.call(nil, nil, header_754074, nil, nil)

var getFeeds* = Call_GetFeeds_754068(name: "getFeeds", meth: HttpMethod.HttpGet,
                                  host: "api.github.com", route: "/feeds",
                                  validator: validate_GetFeeds_754069, base: "/",
                                  makeUrl: url_GetFeeds_754070,
                                  schemes: {Scheme.Https})
type
  Call_PostGists_754084 = ref object of OpenApiRestCall_753573
proc url_PostGists_754086(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostGists_754085(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Create a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754096 = header.getOrDefault("Accept")
  valid_754096 = validateParameter(valid_754096, JString, required = false,
                                 default = nil)
  if valid_754096 != nil:
    section.add "Accept", valid_754096
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_754098: Call_PostGists_754084; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a gist.
  ## 
  let valid = call_754098.validator(path, query, header, formData, body, _)
  let scheme = call_754098.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754098.makeUrl(scheme.get, call_754098.host, call_754098.base,
                             call_754098.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754098, uri, valid, _)

proc call*(call_754099: Call_PostGists_754084; body: JsonNode; Accept: string = ""): Recallable =
  ## postGists
  ## Create a gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_754100 = newJObject()
  var body_754101 = newJObject()
  add(header_754100, "Accept", newJString(Accept))
  if body != nil:
    body_754101 = body
  result = call_754099.call(nil, nil, header_754100, nil, body_754101)

var postGists* = Call_PostGists_754084(name: "postGists", meth: HttpMethod.HttpPost,
                                    host: "api.github.com", route: "/gists",
                                    validator: validate_PostGists_754085,
                                    base: "/", makeUrl: url_PostGists_754086,
                                    schemes: {Scheme.Https})
type
  Call_GetGists_754075 = ref object of OpenApiRestCall_753573
proc url_GetGists_754077(protocol: Scheme; host: string; base: string; route: string;
                        path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGists_754076(path: JsonNode; query: JsonNode; header: JsonNode;
                             formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List the authenticated user's gists or if called anonymously, this will
  ## return all public gists.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_754078 = query.getOrDefault("since")
  valid_754078 = validateParameter(valid_754078, JString, required = false,
                                 default = nil)
  if valid_754078 != nil:
    section.add "since", valid_754078
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754079 = header.getOrDefault("Accept")
  valid_754079 = validateParameter(valid_754079, JString, required = false,
                                 default = nil)
  if valid_754079 != nil:
    section.add "Accept", valid_754079
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754080: Call_GetGists_754075; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List the authenticated user's gists or if called anonymously, this will
  ## return all public gists.
  ## 
  ## 
  let valid = call_754080.validator(path, query, header, formData, body, _)
  let scheme = call_754080.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754080.makeUrl(scheme.get, call_754080.host, call_754080.base,
                             call_754080.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754080, uri, valid, _)

proc call*(call_754081: Call_GetGists_754075; since: string = ""; Accept: string = ""): Recallable =
  ## getGists
  ## List the authenticated user's gists or if called anonymously, this will
  ## return all public gists.
  ## 
  ##   since: string
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var query_754082 = newJObject()
  var header_754083 = newJObject()
  add(query_754082, "since", newJString(since))
  add(header_754083, "Accept", newJString(Accept))
  result = call_754081.call(nil, query_754082, header_754083, nil, nil)

var getGists* = Call_GetGists_754075(name: "getGists", meth: HttpMethod.HttpGet,
                                  host: "api.github.com", route: "/gists",
                                  validator: validate_GetGists_754076, base: "/",
                                  makeUrl: url_GetGists_754077,
                                  schemes: {Scheme.Https})
type
  Call_GetGistsPublic_754102 = ref object of OpenApiRestCall_753573
proc url_GetGistsPublic_754104(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGistsPublic_754103(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; _: string = ""): JsonNode =
  ## List all public gists.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_754105 = query.getOrDefault("since")
  valid_754105 = validateParameter(valid_754105, JString, required = false,
                                 default = nil)
  if valid_754105 != nil:
    section.add "since", valid_754105
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754106 = header.getOrDefault("Accept")
  valid_754106 = validateParameter(valid_754106, JString, required = false,
                                 default = nil)
  if valid_754106 != nil:
    section.add "Accept", valid_754106
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754107: Call_GetGistsPublic_754102; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List all public gists.
  ## 
  let valid = call_754107.validator(path, query, header, formData, body, _)
  let scheme = call_754107.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754107.makeUrl(scheme.get, call_754107.host, call_754107.base,
                             call_754107.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754107, uri, valid, _)

proc call*(call_754108: Call_GetGistsPublic_754102; since: string = "";
          Accept: string = ""): Recallable =
  ## getGistsPublic
  ## List all public gists.
  ##   since: string
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var query_754109 = newJObject()
  var header_754110 = newJObject()
  add(query_754109, "since", newJString(since))
  add(header_754110, "Accept", newJString(Accept))
  result = call_754108.call(nil, query_754109, header_754110, nil, nil)

var getGistsPublic* = Call_GetGistsPublic_754102(name: "getGistsPublic",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/gists/public",
    validator: validate_GetGistsPublic_754103, base: "/",
    makeUrl: url_GetGistsPublic_754104, schemes: {Scheme.Https})
type
  Call_GetGistsStarred_754111 = ref object of OpenApiRestCall_753573
proc url_GetGistsStarred_754113(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGistsStarred_754112(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode; _: string = ""): JsonNode =
  ## List the authenticated user's starred gists.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_754114 = query.getOrDefault("since")
  valid_754114 = validateParameter(valid_754114, JString, required = false,
                                 default = nil)
  if valid_754114 != nil:
    section.add "since", valid_754114
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754115 = header.getOrDefault("Accept")
  valid_754115 = validateParameter(valid_754115, JString, required = false,
                                 default = nil)
  if valid_754115 != nil:
    section.add "Accept", valid_754115
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754116: Call_GetGistsStarred_754111; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List the authenticated user's starred gists.
  ## 
  let valid = call_754116.validator(path, query, header, formData, body, _)
  let scheme = call_754116.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754116.makeUrl(scheme.get, call_754116.host, call_754116.base,
                             call_754116.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754116, uri, valid, _)

proc call*(call_754117: Call_GetGistsStarred_754111; since: string = "";
          Accept: string = ""): Recallable =
  ## getGistsStarred
  ## List the authenticated user's starred gists.
  ##   since: string
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var query_754118 = newJObject()
  var header_754119 = newJObject()
  add(query_754118, "since", newJString(since))
  add(header_754119, "Accept", newJString(Accept))
  result = call_754117.call(nil, query_754118, header_754119, nil, nil)

var getGistsStarred* = Call_GetGistsStarred_754111(name: "getGistsStarred",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/gists/starred",
    validator: validate_GetGistsStarred_754112, base: "/",
    makeUrl: url_GetGistsStarred_754113, schemes: {Scheme.Https})
type
  Call_GetGistsId_754120 = ref object of OpenApiRestCall_753573
proc url_GetGistsId_754122(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsId_754121(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Get a single gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_754137 = path.getOrDefault("id")
  valid_754137 = validateParameter(valid_754137, JInt, required = true, default = nil)
  if valid_754137 != nil:
    section.add "id", valid_754137
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754138 = header.getOrDefault("Accept")
  valid_754138 = validateParameter(valid_754138, JString, required = false,
                                 default = nil)
  if valid_754138 != nil:
    section.add "Accept", valid_754138
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754139: Call_GetGistsId_754120; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single gist.
  ## 
  let valid = call_754139.validator(path, query, header, formData, body, _)
  let scheme = call_754139.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754139.makeUrl(scheme.get, call_754139.host, call_754139.base,
                             call_754139.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754139, uri, valid, _)

proc call*(call_754140: Call_GetGistsId_754120; id: int; Accept: string = ""): Recallable =
  ## getGistsId
  ## Get a single gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_754141 = newJObject()
  var header_754142 = newJObject()
  add(path_754141, "id", newJInt(id))
  add(header_754142, "Accept", newJString(Accept))
  result = call_754140.call(path_754141, nil, header_754142, nil, nil)

var getGistsId* = Call_GetGistsId_754120(name: "getGistsId",
                                      meth: HttpMethod.HttpGet,
                                      host: "api.github.com",
                                      route: "/gists/{id}",
                                      validator: validate_GetGistsId_754121,
                                      base: "/", makeUrl: url_GetGistsId_754122,
                                      schemes: {Scheme.Https})
type
  Call_PatchGistsId_754152 = ref object of OpenApiRestCall_753573
proc url_PatchGistsId_754154(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchGistsId_754153(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Edit a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_754155 = path.getOrDefault("id")
  valid_754155 = validateParameter(valid_754155, JInt, required = true, default = nil)
  if valid_754155 != nil:
    section.add "id", valid_754155
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754156 = header.getOrDefault("Accept")
  valid_754156 = validateParameter(valid_754156, JString, required = false,
                                 default = nil)
  if valid_754156 != nil:
    section.add "Accept", valid_754156
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_754158: Call_PatchGistsId_754152; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit a gist.
  ## 
  let valid = call_754158.validator(path, query, header, formData, body, _)
  let scheme = call_754158.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754158.makeUrl(scheme.get, call_754158.host, call_754158.base,
                             call_754158.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754158, uri, valid, _)

proc call*(call_754159: Call_PatchGistsId_754152; id: int; body: JsonNode;
          Accept: string = ""): Recallable =
  ## patchGistsId
  ## Edit a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var path_754160 = newJObject()
  var header_754161 = newJObject()
  var body_754162 = newJObject()
  add(path_754160, "id", newJInt(id))
  add(header_754161, "Accept", newJString(Accept))
  if body != nil:
    body_754162 = body
  result = call_754159.call(path_754160, nil, header_754161, nil, body_754162)

var patchGistsId* = Call_PatchGistsId_754152(name: "patchGistsId",
    meth: HttpMethod.HttpPatch, host: "api.github.com", route: "/gists/{id}",
    validator: validate_PatchGistsId_754153, base: "/", makeUrl: url_PatchGistsId_754154,
    schemes: {Scheme.Https})
type
  Call_DeleteGistsId_754143 = ref object of OpenApiRestCall_753573
proc url_DeleteGistsId_754145(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteGistsId_754144(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Delete a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_754146 = path.getOrDefault("id")
  valid_754146 = validateParameter(valid_754146, JInt, required = true, default = nil)
  if valid_754146 != nil:
    section.add "id", valid_754146
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754147 = header.getOrDefault("Accept")
  valid_754147 = validateParameter(valid_754147, JString, required = false,
                                 default = nil)
  if valid_754147 != nil:
    section.add "Accept", valid_754147
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754148: Call_DeleteGistsId_754143; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a gist.
  ## 
  let valid = call_754148.validator(path, query, header, formData, body, _)
  let scheme = call_754148.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754148.makeUrl(scheme.get, call_754148.host, call_754148.base,
                             call_754148.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754148, uri, valid, _)

proc call*(call_754149: Call_DeleteGistsId_754143; id: int; Accept: string = ""): Recallable =
  ## deleteGistsId
  ## Delete a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_754150 = newJObject()
  var header_754151 = newJObject()
  add(path_754150, "id", newJInt(id))
  add(header_754151, "Accept", newJString(Accept))
  result = call_754149.call(path_754150, nil, header_754151, nil, nil)

var deleteGistsId* = Call_DeleteGistsId_754143(name: "deleteGistsId",
    meth: HttpMethod.HttpDelete, host: "api.github.com", route: "/gists/{id}",
    validator: validate_DeleteGistsId_754144, base: "/", makeUrl: url_DeleteGistsId_754145,
    schemes: {Scheme.Https})
type
  Call_PostGistsIdComments_754172 = ref object of OpenApiRestCall_753573
proc url_PostGistsIdComments_754174(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostGistsIdComments_754173(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode; _: string = ""): JsonNode =
  ## Create a commen
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_754175 = path.getOrDefault("id")
  valid_754175 = validateParameter(valid_754175, JInt, required = true, default = nil)
  if valid_754175 != nil:
    section.add "id", valid_754175
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754176 = header.getOrDefault("Accept")
  valid_754176 = validateParameter(valid_754176, JString, required = false,
                                 default = nil)
  if valid_754176 != nil:
    section.add "Accept", valid_754176
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_754178: Call_PostGistsIdComments_754172; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a commen
  ## 
  let valid = call_754178.validator(path, query, header, formData, body, _)
  let scheme = call_754178.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754178.makeUrl(scheme.get, call_754178.host, call_754178.base,
                             call_754178.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754178, uri, valid, _)

proc call*(call_754179: Call_PostGistsIdComments_754172; id: int; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postGistsIdComments
  ## Create a commen
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var path_754180 = newJObject()
  var header_754181 = newJObject()
  var body_754182 = newJObject()
  add(path_754180, "id", newJInt(id))
  add(header_754181, "Accept", newJString(Accept))
  if body != nil:
    body_754182 = body
  result = call_754179.call(path_754180, nil, header_754181, nil, body_754182)

var postGistsIdComments* = Call_PostGistsIdComments_754172(
    name: "postGistsIdComments", meth: HttpMethod.HttpPost, host: "api.github.com",
    route: "/gists/{id}/comments", validator: validate_PostGistsIdComments_754173,
    base: "/", makeUrl: url_PostGistsIdComments_754174, schemes: {Scheme.Https})
type
  Call_GetGistsIdComments_754163 = ref object of OpenApiRestCall_753573
proc url_GetGistsIdComments_754165(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsIdComments_754164(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode =
  ## List comments on a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_754166 = path.getOrDefault("id")
  valid_754166 = validateParameter(valid_754166, JInt, required = true, default = nil)
  if valid_754166 != nil:
    section.add "id", valid_754166
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754167 = header.getOrDefault("Accept")
  valid_754167 = validateParameter(valid_754167, JString, required = false,
                                 default = nil)
  if valid_754167 != nil:
    section.add "Accept", valid_754167
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754168: Call_GetGistsIdComments_754163; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List comments on a gist.
  ## 
  let valid = call_754168.validator(path, query, header, formData, body, _)
  let scheme = call_754168.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754168.makeUrl(scheme.get, call_754168.host, call_754168.base,
                             call_754168.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754168, uri, valid, _)

proc call*(call_754169: Call_GetGistsIdComments_754163; id: int; Accept: string = ""): Recallable =
  ## getGistsIdComments
  ## List comments on a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_754170 = newJObject()
  var header_754171 = newJObject()
  add(path_754170, "id", newJInt(id))
  add(header_754171, "Accept", newJString(Accept))
  result = call_754169.call(path_754170, nil, header_754171, nil, nil)

var getGistsIdComments* = Call_GetGistsIdComments_754163(
    name: "getGistsIdComments", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/gists/{id}/comments", validator: validate_GetGistsIdComments_754164,
    base: "/", makeUrl: url_GetGistsIdComments_754165, schemes: {Scheme.Https})
type
  Call_GetGistsIdCommentsCommentId_754183 = ref object of OpenApiRestCall_753573
proc url_GetGistsIdCommentsCommentId_754185(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsIdCommentsCommentId_754184(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Get a single comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_754186 = path.getOrDefault("id")
  valid_754186 = validateParameter(valid_754186, JInt, required = true, default = nil)
  if valid_754186 != nil:
    section.add "id", valid_754186
  var valid_754187 = path.getOrDefault("commentId")
  valid_754187 = validateParameter(valid_754187, JInt, required = true, default = nil)
  if valid_754187 != nil:
    section.add "commentId", valid_754187
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754188 = header.getOrDefault("Accept")
  valid_754188 = validateParameter(valid_754188, JString, required = false,
                                 default = nil)
  if valid_754188 != nil:
    section.add "Accept", valid_754188
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754189: Call_GetGistsIdCommentsCommentId_754183;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single comment.
  ## 
  let valid = call_754189.validator(path, query, header, formData, body, _)
  let scheme = call_754189.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754189.makeUrl(scheme.get, call_754189.host, call_754189.base,
                             call_754189.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754189, uri, valid, _)

proc call*(call_754190: Call_GetGistsIdCommentsCommentId_754183; id: int;
          commentId: int; Accept: string = ""): Recallable =
  ## getGistsIdCommentsCommentId
  ## Get a single comment.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_754191 = newJObject()
  var header_754192 = newJObject()
  add(path_754191, "id", newJInt(id))
  add(header_754192, "Accept", newJString(Accept))
  add(path_754191, "commentId", newJInt(commentId))
  result = call_754190.call(path_754191, nil, header_754192, nil, nil)

var getGistsIdCommentsCommentId* = Call_GetGistsIdCommentsCommentId_754183(
    name: "getGistsIdCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/gists/{id}/comments/{commentId}",
    validator: validate_GetGistsIdCommentsCommentId_754184, base: "/",
    makeUrl: url_GetGistsIdCommentsCommentId_754185, schemes: {Scheme.Https})
type
  Call_PatchGistsIdCommentsCommentId_754203 = ref object of OpenApiRestCall_753573
proc url_PatchGistsIdCommentsCommentId_754205(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchGistsIdCommentsCommentId_754204(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Edit a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_754206 = path.getOrDefault("id")
  valid_754206 = validateParameter(valid_754206, JInt, required = true, default = nil)
  if valid_754206 != nil:
    section.add "id", valid_754206
  var valid_754207 = path.getOrDefault("commentId")
  valid_754207 = validateParameter(valid_754207, JInt, required = true, default = nil)
  if valid_754207 != nil:
    section.add "commentId", valid_754207
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754208 = header.getOrDefault("Accept")
  valid_754208 = validateParameter(valid_754208, JString, required = false,
                                 default = nil)
  if valid_754208 != nil:
    section.add "Accept", valid_754208
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_754210: Call_PatchGistsIdCommentsCommentId_754203;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit a comment.
  ## 
  let valid = call_754210.validator(path, query, header, formData, body, _)
  let scheme = call_754210.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754210.makeUrl(scheme.get, call_754210.host, call_754210.base,
                             call_754210.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754210, uri, valid, _)

proc call*(call_754211: Call_PatchGistsIdCommentsCommentId_754203; id: int;
          commentId: int; body: JsonNode; Accept: string = ""): Recallable =
  ## patchGistsIdCommentsCommentId
  ## Edit a comment.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   commentId: int (required)
  ##            : Id of comment.
  ##   body: JObject (required)
  var path_754212 = newJObject()
  var header_754213 = newJObject()
  var body_754214 = newJObject()
  add(path_754212, "id", newJInt(id))
  add(header_754213, "Accept", newJString(Accept))
  add(path_754212, "commentId", newJInt(commentId))
  if body != nil:
    body_754214 = body
  result = call_754211.call(path_754212, nil, header_754213, nil, body_754214)

var patchGistsIdCommentsCommentId* = Call_PatchGistsIdCommentsCommentId_754203(
    name: "patchGistsIdCommentsCommentId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/gists/{id}/comments/{commentId}",
    validator: validate_PatchGistsIdCommentsCommentId_754204, base: "/",
    makeUrl: url_PatchGistsIdCommentsCommentId_754205, schemes: {Scheme.Https})
type
  Call_DeleteGistsIdCommentsCommentId_754193 = ref object of OpenApiRestCall_753573
proc url_DeleteGistsIdCommentsCommentId_754195(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteGistsIdCommentsCommentId_754194(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Delete a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_754196 = path.getOrDefault("id")
  valid_754196 = validateParameter(valid_754196, JInt, required = true, default = nil)
  if valid_754196 != nil:
    section.add "id", valid_754196
  var valid_754197 = path.getOrDefault("commentId")
  valid_754197 = validateParameter(valid_754197, JInt, required = true, default = nil)
  if valid_754197 != nil:
    section.add "commentId", valid_754197
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754198 = header.getOrDefault("Accept")
  valid_754198 = validateParameter(valid_754198, JString, required = false,
                                 default = nil)
  if valid_754198 != nil:
    section.add "Accept", valid_754198
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754199: Call_DeleteGistsIdCommentsCommentId_754193;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a comment.
  ## 
  let valid = call_754199.validator(path, query, header, formData, body, _)
  let scheme = call_754199.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754199.makeUrl(scheme.get, call_754199.host, call_754199.base,
                             call_754199.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754199, uri, valid, _)

proc call*(call_754200: Call_DeleteGistsIdCommentsCommentId_754193; id: int;
          commentId: int; Accept: string = ""): Recallable =
  ## deleteGistsIdCommentsCommentId
  ## Delete a comment.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_754201 = newJObject()
  var header_754202 = newJObject()
  add(path_754201, "id", newJInt(id))
  add(header_754202, "Accept", newJString(Accept))
  add(path_754201, "commentId", newJInt(commentId))
  result = call_754200.call(path_754201, nil, header_754202, nil, nil)

var deleteGistsIdCommentsCommentId* = Call_DeleteGistsIdCommentsCommentId_754193(
    name: "deleteGistsIdCommentsCommentId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/gists/{id}/comments/{commentId}",
    validator: validate_DeleteGistsIdCommentsCommentId_754194, base: "/",
    makeUrl: url_DeleteGistsIdCommentsCommentId_754195, schemes: {Scheme.Https})
type
  Call_PostGistsIdForks_754215 = ref object of OpenApiRestCall_753573
proc url_PostGistsIdForks_754217(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/forks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostGistsIdForks_754216(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode =
  ## Fork a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_754218 = path.getOrDefault("id")
  valid_754218 = validateParameter(valid_754218, JInt, required = true, default = nil)
  if valid_754218 != nil:
    section.add "id", valid_754218
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754219 = header.getOrDefault("Accept")
  valid_754219 = validateParameter(valid_754219, JString, required = false,
                                 default = nil)
  if valid_754219 != nil:
    section.add "Accept", valid_754219
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754220: Call_PostGistsIdForks_754215; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Fork a gist.
  ## 
  let valid = call_754220.validator(path, query, header, formData, body, _)
  let scheme = call_754220.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754220.makeUrl(scheme.get, call_754220.host, call_754220.base,
                             call_754220.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754220, uri, valid, _)

proc call*(call_754221: Call_PostGistsIdForks_754215; id: int; Accept: string = ""): Recallable =
  ## postGistsIdForks
  ## Fork a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_754222 = newJObject()
  var header_754223 = newJObject()
  add(path_754222, "id", newJInt(id))
  add(header_754223, "Accept", newJString(Accept))
  result = call_754221.call(path_754222, nil, header_754223, nil, nil)

var postGistsIdForks* = Call_PostGistsIdForks_754215(name: "postGistsIdForks",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/gists/{id}/forks",
    validator: validate_PostGistsIdForks_754216, base: "/",
    makeUrl: url_PostGistsIdForks_754217, schemes: {Scheme.Https})
type
  Call_PutGistsIdStar_754233 = ref object of OpenApiRestCall_753573
proc url_PutGistsIdStar_754235(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/star")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutGistsIdStar_754234(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; _: string = ""): JsonNode =
  ## Star a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_754236 = path.getOrDefault("id")
  valid_754236 = validateParameter(valid_754236, JInt, required = true, default = nil)
  if valid_754236 != nil:
    section.add "id", valid_754236
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754237 = header.getOrDefault("Accept")
  valid_754237 = validateParameter(valid_754237, JString, required = false,
                                 default = nil)
  if valid_754237 != nil:
    section.add "Accept", valid_754237
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754238: Call_PutGistsIdStar_754233; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Star a gist.
  ## 
  let valid = call_754238.validator(path, query, header, formData, body, _)
  let scheme = call_754238.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754238.makeUrl(scheme.get, call_754238.host, call_754238.base,
                             call_754238.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754238, uri, valid, _)

proc call*(call_754239: Call_PutGistsIdStar_754233; id: int; Accept: string = ""): Recallable =
  ## putGistsIdStar
  ## Star a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_754240 = newJObject()
  var header_754241 = newJObject()
  add(path_754240, "id", newJInt(id))
  add(header_754241, "Accept", newJString(Accept))
  result = call_754239.call(path_754240, nil, header_754241, nil, nil)

var putGistsIdStar* = Call_PutGistsIdStar_754233(name: "putGistsIdStar",
    meth: HttpMethod.HttpPut, host: "api.github.com", route: "/gists/{id}/star",
    validator: validate_PutGistsIdStar_754234, base: "/",
    makeUrl: url_PutGistsIdStar_754235, schemes: {Scheme.Https})
type
  Call_GetGistsIdStar_754224 = ref object of OpenApiRestCall_753573
proc url_GetGistsIdStar_754226(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/star")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsIdStar_754225(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; _: string = ""): JsonNode =
  ## Check if a gist is starred.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_754227 = path.getOrDefault("id")
  valid_754227 = validateParameter(valid_754227, JInt, required = true, default = nil)
  if valid_754227 != nil:
    section.add "id", valid_754227
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754228 = header.getOrDefault("Accept")
  valid_754228 = validateParameter(valid_754228, JString, required = false,
                                 default = nil)
  if valid_754228 != nil:
    section.add "Accept", valid_754228
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754229: Call_GetGistsIdStar_754224; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if a gist is starred.
  ## 
  let valid = call_754229.validator(path, query, header, formData, body, _)
  let scheme = call_754229.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754229.makeUrl(scheme.get, call_754229.host, call_754229.base,
                             call_754229.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754229, uri, valid, _)

proc call*(call_754230: Call_GetGistsIdStar_754224; id: int; Accept: string = ""): Recallable =
  ## getGistsIdStar
  ## Check if a gist is starred.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_754231 = newJObject()
  var header_754232 = newJObject()
  add(path_754231, "id", newJInt(id))
  add(header_754232, "Accept", newJString(Accept))
  result = call_754230.call(path_754231, nil, header_754232, nil, nil)

var getGistsIdStar* = Call_GetGistsIdStar_754224(name: "getGistsIdStar",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/gists/{id}/star",
    validator: validate_GetGistsIdStar_754225, base: "/",
    makeUrl: url_GetGistsIdStar_754226, schemes: {Scheme.Https})
type
  Call_DeleteGistsIdStar_754242 = ref object of OpenApiRestCall_753573
proc url_DeleteGistsIdStar_754244(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/star")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteGistsIdStar_754243(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode =
  ## Unstar a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_754245 = path.getOrDefault("id")
  valid_754245 = validateParameter(valid_754245, JInt, required = true, default = nil)
  if valid_754245 != nil:
    section.add "id", valid_754245
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754246 = header.getOrDefault("Accept")
  valid_754246 = validateParameter(valid_754246, JString, required = false,
                                 default = nil)
  if valid_754246 != nil:
    section.add "Accept", valid_754246
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754247: Call_DeleteGistsIdStar_754242; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Unstar a gist.
  ## 
  let valid = call_754247.validator(path, query, header, formData, body, _)
  let scheme = call_754247.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754247.makeUrl(scheme.get, call_754247.host, call_754247.base,
                             call_754247.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754247, uri, valid, _)

proc call*(call_754248: Call_DeleteGistsIdStar_754242; id: int; Accept: string = ""): Recallable =
  ## deleteGistsIdStar
  ## Unstar a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_754249 = newJObject()
  var header_754250 = newJObject()
  add(path_754249, "id", newJInt(id))
  add(header_754250, "Accept", newJString(Accept))
  result = call_754248.call(path_754249, nil, header_754250, nil, nil)

var deleteGistsIdStar* = Call_DeleteGistsIdStar_754242(name: "deleteGistsIdStar",
    meth: HttpMethod.HttpDelete, host: "api.github.com", route: "/gists/{id}/star",
    validator: validate_DeleteGistsIdStar_754243, base: "/",
    makeUrl: url_DeleteGistsIdStar_754244, schemes: {Scheme.Https})
type
  Call_GetGitignoreTemplates_754251 = ref object of OpenApiRestCall_753573
proc url_GetGitignoreTemplates_754253(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGitignoreTemplates_754252(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Listing available templates.
  ## List all templates available to pass as an option when creating a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754254 = header.getOrDefault("Accept")
  valid_754254 = validateParameter(valid_754254, JString, required = false,
                                 default = nil)
  if valid_754254 != nil:
    section.add "Accept", valid_754254
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754255: Call_GetGitignoreTemplates_754251; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Listing available templates.
  ## List all templates available to pass as an option when creating a repository.
  ## 
  ## 
  let valid = call_754255.validator(path, query, header, formData, body, _)
  let scheme = call_754255.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754255.makeUrl(scheme.get, call_754255.host, call_754255.base,
                             call_754255.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754255, uri, valid, _)

proc call*(call_754256: Call_GetGitignoreTemplates_754251; Accept: string = ""): Recallable =
  ## getGitignoreTemplates
  ## Listing available templates.
  ## List all templates available to pass as an option when creating a repository.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_754257 = newJObject()
  add(header_754257, "Accept", newJString(Accept))
  result = call_754256.call(nil, nil, header_754257, nil, nil)

var getGitignoreTemplates* = Call_GetGitignoreTemplates_754251(
    name: "getGitignoreTemplates", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/gitignore/templates", validator: validate_GetGitignoreTemplates_754252,
    base: "/", makeUrl: url_GetGitignoreTemplates_754253, schemes: {Scheme.Https})
type
  Call_GetGitignoreTemplatesLanguage_754258 = ref object of OpenApiRestCall_753573
proc url_GetGitignoreTemplatesLanguage_754260(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "language" in path, "`language` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gitignore/templates/"),
               (kind: VariableSegment, value: "language")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGitignoreTemplatesLanguage_754259(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Get a single template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   language: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `language` field"
  var valid_754261 = path.getOrDefault("language")
  valid_754261 = validateParameter(valid_754261, JString, required = true,
                                 default = nil)
  if valid_754261 != nil:
    section.add "language", valid_754261
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754262 = header.getOrDefault("Accept")
  valid_754262 = validateParameter(valid_754262, JString, required = false,
                                 default = nil)
  if valid_754262 != nil:
    section.add "Accept", valid_754262
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754263: Call_GetGitignoreTemplatesLanguage_754258;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single template.
  ## 
  let valid = call_754263.validator(path, query, header, formData, body, _)
  let scheme = call_754263.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754263.makeUrl(scheme.get, call_754263.host, call_754263.base,
                             call_754263.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754263, uri, valid, _)

proc call*(call_754264: Call_GetGitignoreTemplatesLanguage_754258;
          language: string; Accept: string = ""): Recallable =
  ## getGitignoreTemplatesLanguage
  ## Get a single template.
  ##   language: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_754265 = newJObject()
  var header_754266 = newJObject()
  add(path_754265, "language", newJString(language))
  add(header_754266, "Accept", newJString(Accept))
  result = call_754264.call(path_754265, nil, header_754266, nil, nil)

var getGitignoreTemplatesLanguage* = Call_GetGitignoreTemplatesLanguage_754258(
    name: "getGitignoreTemplatesLanguage", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/gitignore/templates/{language}",
    validator: validate_GetGitignoreTemplatesLanguage_754259, base: "/",
    makeUrl: url_GetGitignoreTemplatesLanguage_754260, schemes: {Scheme.Https})
type
  Call_GetIssues_754267 = ref object of OpenApiRestCall_753573
proc url_GetIssues_754269(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetIssues_754268(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List issues.
  ## List all issues across all the authenticated user's visible repositories.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString (required)
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  ##   direction: JString (required)
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   state: JString (required)
  section = newJObject()
  var valid_754283 = query.getOrDefault("sort")
  valid_754283 = validateParameter(valid_754283, JString, required = true,
                                 default = newJString("created"))
  if valid_754283 != nil:
    section.add "sort", valid_754283
  var valid_754284 = query.getOrDefault("since")
  valid_754284 = validateParameter(valid_754284, JString, required = false,
                                 default = nil)
  if valid_754284 != nil:
    section.add "since", valid_754284
  var valid_754285 = query.getOrDefault("direction")
  valid_754285 = validateParameter(valid_754285, JString, required = true,
                                 default = newJString("desc"))
  if valid_754285 != nil:
    section.add "direction", valid_754285
  var valid_754286 = query.getOrDefault("labels")
  valid_754286 = validateParameter(valid_754286, JString, required = true,
                                 default = nil)
  if valid_754286 != nil:
    section.add "labels", valid_754286
  var valid_754287 = query.getOrDefault("filter")
  valid_754287 = validateParameter(valid_754287, JString, required = true,
                                 default = newJString("all"))
  if valid_754287 != nil:
    section.add "filter", valid_754287
  var valid_754288 = query.getOrDefault("state")
  valid_754288 = validateParameter(valid_754288, JString, required = true,
                                 default = newJString("open"))
  if valid_754288 != nil:
    section.add "state", valid_754288
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754289 = header.getOrDefault("Accept")
  valid_754289 = validateParameter(valid_754289, JString, required = false,
                                 default = nil)
  if valid_754289 != nil:
    section.add "Accept", valid_754289
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754290: Call_GetIssues_754267; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List issues.
  ## List all issues across all the authenticated user's visible repositories.
  ## 
  ## 
  let valid = call_754290.validator(path, query, header, formData, body, _)
  let scheme = call_754290.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754290.makeUrl(scheme.get, call_754290.host, call_754290.base,
                             call_754290.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754290, uri, valid, _)

proc call*(call_754291: Call_GetIssues_754267; labels: string;
          sort: string = "created"; since: string = ""; direction: string = "desc";
          Accept: string = ""; filter: string = "all"; state: string = "open"): Recallable =
  ## getIssues
  ## List issues.
  ## List all issues across all the authenticated user's visible repositories.
  ## 
  ##   sort: string (required)
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  ##   direction: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   state: string (required)
  var query_754292 = newJObject()
  var header_754293 = newJObject()
  add(query_754292, "sort", newJString(sort))
  add(query_754292, "since", newJString(since))
  add(query_754292, "direction", newJString(direction))
  add(header_754293, "Accept", newJString(Accept))
  add(query_754292, "labels", newJString(labels))
  add(query_754292, "filter", newJString(filter))
  add(query_754292, "state", newJString(state))
  result = call_754291.call(nil, query_754292, header_754293, nil, nil)

var getIssues* = Call_GetIssues_754267(name: "getIssues", meth: HttpMethod.HttpGet,
                                    host: "api.github.com", route: "/issues",
                                    validator: validate_GetIssues_754268,
                                    base: "/", makeUrl: url_GetIssues_754269,
                                    schemes: {Scheme.Https})
type
  Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_754294 = ref object of OpenApiRestCall_753573
proc url_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_754296(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repository" in path, "`repository` is a required path parameter"
  assert "state" in path, "`state` is a required path parameter"
  assert "keyword" in path, "`keyword` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/issues/search/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repository"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "state"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "keyword")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_754295(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode; _: string = ""): JsonNode =
  ## Find issues by state and keyword.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repository: JString (required)
  ##   state: JString (required)
  ##        : Indicates the state of the issues to return. Can be either open or closed.
  ##   keyword: JString (required)
  ##          : The search term.
  ##   owner: JString (required)
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `repository` field"
  var valid_754297 = path.getOrDefault("repository")
  valid_754297 = validateParameter(valid_754297, JString, required = true,
                                 default = nil)
  if valid_754297 != nil:
    section.add "repository", valid_754297
  var valid_754298 = path.getOrDefault("state")
  valid_754298 = validateParameter(valid_754298, JString, required = true,
                                 default = newJString("open"))
  if valid_754298 != nil:
    section.add "state", valid_754298
  var valid_754299 = path.getOrDefault("keyword")
  valid_754299 = validateParameter(valid_754299, JString, required = true,
                                 default = nil)
  if valid_754299 != nil:
    section.add "keyword", valid_754299
  var valid_754300 = path.getOrDefault("owner")
  valid_754300 = validateParameter(valid_754300, JString, required = true,
                                 default = nil)
  if valid_754300 != nil:
    section.add "owner", valid_754300
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754301 = header.getOrDefault("Accept")
  valid_754301 = validateParameter(valid_754301, JString, required = false,
                                 default = nil)
  if valid_754301 != nil:
    section.add "Accept", valid_754301
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754302: Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_754294;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Find issues by state and keyword.
  ## 
  let valid = call_754302.validator(path, query, header, formData, body, _)
  let scheme = call_754302.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754302.makeUrl(scheme.get, call_754302.host, call_754302.base,
                             call_754302.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754302, uri, valid, _)

proc call*(call_754303: Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_754294;
          repository: string; keyword: string; owner: string; state: string = "open";
          Accept: string = ""): Recallable =
  ## getLegacyIssuesSearchOwnerRepositoryStateKeyword
  ## Find issues by state and keyword.
  ##   repository: string (required)
  ##   state: string (required)
  ##        : Indicates the state of the issues to return. Can be either open or closed.
  ##   keyword: string (required)
  ##          : The search term.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   owner: string (required)
  var path_754304 = newJObject()
  var header_754305 = newJObject()
  add(path_754304, "repository", newJString(repository))
  add(path_754304, "state", newJString(state))
  add(path_754304, "keyword", newJString(keyword))
  add(header_754305, "Accept", newJString(Accept))
  add(path_754304, "owner", newJString(owner))
  result = call_754303.call(path_754304, nil, header_754305, nil, nil)

var getLegacyIssuesSearchOwnerRepositoryStateKeyword* = Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_754294(
    name: "getLegacyIssuesSearchOwnerRepositoryStateKeyword",
    meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/legacy/issues/search/{owner}/{repository}/{state}/{keyword}",
    validator: validate_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_754295,
    base: "/", makeUrl: url_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_754296,
    schemes: {Scheme.Https})
type
  Call_GetLegacyReposSearchKeyword_754306 = ref object of OpenApiRestCall_753573
proc url_GetLegacyReposSearchKeyword_754308(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyword" in path, "`keyword` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/repos/search/"),
               (kind: VariableSegment, value: "keyword")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyReposSearchKeyword_754307(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Find repositories by keyword. Note, this legacy method does not follow the v3 pagination pattern. This method returns up to 100 results per page and pages can be fetched using the start_page parameter.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyword: JString (required)
  ##          : The search term
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyword` field"
  var valid_754309 = path.getOrDefault("keyword")
  valid_754309 = validateParameter(valid_754309, JString, required = true,
                                 default = nil)
  if valid_754309 != nil:
    section.add "keyword", valid_754309
  result.add "path", section
  ## parameters in `query` object:
  ##   language: JString
  ##           : Filter results by language
  ##   sort: JString
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   start_page: JString
  ##             : The page number to fetch
  section = newJObject()
  var valid_754310 = query.getOrDefault("language")
  valid_754310 = validateParameter(valid_754310, JString, required = false,
                                 default = nil)
  if valid_754310 != nil:
    section.add "language", valid_754310
  var valid_754311 = query.getOrDefault("sort")
  valid_754311 = validateParameter(valid_754311, JString, required = false,
                                 default = newJString("updated"))
  if valid_754311 != nil:
    section.add "sort", valid_754311
  var valid_754312 = query.getOrDefault("order")
  valid_754312 = validateParameter(valid_754312, JString, required = false,
                                 default = newJString("desc"))
  if valid_754312 != nil:
    section.add "order", valid_754312
  var valid_754313 = query.getOrDefault("start_page")
  valid_754313 = validateParameter(valid_754313, JString, required = false,
                                 default = nil)
  if valid_754313 != nil:
    section.add "start_page", valid_754313
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754314 = header.getOrDefault("Accept")
  valid_754314 = validateParameter(valid_754314, JString, required = false,
                                 default = nil)
  if valid_754314 != nil:
    section.add "Accept", valid_754314
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754315: Call_GetLegacyReposSearchKeyword_754306;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Find repositories by keyword. Note, this legacy method does not follow the v3 pagination pattern. This method returns up to 100 results per page and pages can be fetched using the start_page parameter.
  ## 
  let valid = call_754315.validator(path, query, header, formData, body, _)
  let scheme = call_754315.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754315.makeUrl(scheme.get, call_754315.host, call_754315.base,
                             call_754315.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754315, uri, valid, _)

proc call*(call_754316: Call_GetLegacyReposSearchKeyword_754306; keyword: string;
          language: string = ""; sort: string = "updated"; order: string = "desc";
          Accept: string = ""; startPage: string = ""): Recallable =
  ## getLegacyReposSearchKeyword
  ## Find repositories by keyword. Note, this legacy method does not follow the v3 pagination pattern. This method returns up to 100 results per page and pages can be fetched using the start_page parameter.
  ##   language: string
  ##           : Filter results by language
  ##   sort: string
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  ##   keyword: string (required)
  ##          : The search term
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   startPage: string
  ##            : The page number to fetch
  var path_754317 = newJObject()
  var query_754318 = newJObject()
  var header_754319 = newJObject()
  add(query_754318, "language", newJString(language))
  add(query_754318, "sort", newJString(sort))
  add(path_754317, "keyword", newJString(keyword))
  add(query_754318, "order", newJString(order))
  add(header_754319, "Accept", newJString(Accept))
  add(query_754318, "start_page", newJString(startPage))
  result = call_754316.call(path_754317, query_754318, header_754319, nil, nil)

var getLegacyReposSearchKeyword* = Call_GetLegacyReposSearchKeyword_754306(
    name: "getLegacyReposSearchKeyword", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/legacy/repos/search/{keyword}",
    validator: validate_GetLegacyReposSearchKeyword_754307, base: "/",
    makeUrl: url_GetLegacyReposSearchKeyword_754308, schemes: {Scheme.Https})
type
  Call_GetLegacyUserEmailEmail_754320 = ref object of OpenApiRestCall_753573
proc url_GetLegacyUserEmailEmail_754322(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "email" in path, "`email` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/user/email/"),
               (kind: VariableSegment, value: "email")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyUserEmailEmail_754321(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## This API call is added for compatibility reasons only.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   email: JString (required)
  ##        : The email address
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `email` field"
  var valid_754323 = path.getOrDefault("email")
  valid_754323 = validateParameter(valid_754323, JString, required = true,
                                 default = nil)
  if valid_754323 != nil:
    section.add "email", valid_754323
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754324 = header.getOrDefault("Accept")
  valid_754324 = validateParameter(valid_754324, JString, required = false,
                                 default = nil)
  if valid_754324 != nil:
    section.add "Accept", valid_754324
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754325: Call_GetLegacyUserEmailEmail_754320; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## This API call is added for compatibility reasons only.
  ## 
  let valid = call_754325.validator(path, query, header, formData, body, _)
  let scheme = call_754325.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754325.makeUrl(scheme.get, call_754325.host, call_754325.base,
                             call_754325.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754325, uri, valid, _)

proc call*(call_754326: Call_GetLegacyUserEmailEmail_754320; email: string;
          Accept: string = ""): Recallable =
  ## getLegacyUserEmailEmail
  ## This API call is added for compatibility reasons only.
  ##   email: string (required)
  ##        : The email address
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_754327 = newJObject()
  var header_754328 = newJObject()
  add(path_754327, "email", newJString(email))
  add(header_754328, "Accept", newJString(Accept))
  result = call_754326.call(path_754327, nil, header_754328, nil, nil)

var getLegacyUserEmailEmail* = Call_GetLegacyUserEmailEmail_754320(
    name: "getLegacyUserEmailEmail", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/legacy/user/email/{email}",
    validator: validate_GetLegacyUserEmailEmail_754321, base: "/",
    makeUrl: url_GetLegacyUserEmailEmail_754322, schemes: {Scheme.Https})
type
  Call_GetLegacyUserSearchKeyword_754329 = ref object of OpenApiRestCall_753573
proc url_GetLegacyUserSearchKeyword_754331(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyword" in path, "`keyword` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/user/search/"),
               (kind: VariableSegment, value: "keyword")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyUserSearchKeyword_754330(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Find users by keyword.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyword: JString (required)
  ##          : The search term
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyword` field"
  var valid_754332 = path.getOrDefault("keyword")
  valid_754332 = validateParameter(valid_754332, JString, required = true,
                                 default = nil)
  if valid_754332 != nil:
    section.add "keyword", valid_754332
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   start_page: JString
  ##             : The page number to fetch
  section = newJObject()
  var valid_754333 = query.getOrDefault("sort")
  valid_754333 = validateParameter(valid_754333, JString, required = false,
                                 default = newJString("updated"))
  if valid_754333 != nil:
    section.add "sort", valid_754333
  var valid_754334 = query.getOrDefault("order")
  valid_754334 = validateParameter(valid_754334, JString, required = false,
                                 default = newJString("desc"))
  if valid_754334 != nil:
    section.add "order", valid_754334
  var valid_754335 = query.getOrDefault("start_page")
  valid_754335 = validateParameter(valid_754335, JString, required = false,
                                 default = nil)
  if valid_754335 != nil:
    section.add "start_page", valid_754335
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754336 = header.getOrDefault("Accept")
  valid_754336 = validateParameter(valid_754336, JString, required = false,
                                 default = nil)
  if valid_754336 != nil:
    section.add "Accept", valid_754336
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754337: Call_GetLegacyUserSearchKeyword_754329;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Find users by keyword.
  ## 
  let valid = call_754337.validator(path, query, header, formData, body, _)
  let scheme = call_754337.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754337.makeUrl(scheme.get, call_754337.host, call_754337.base,
                             call_754337.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754337, uri, valid, _)

proc call*(call_754338: Call_GetLegacyUserSearchKeyword_754329; keyword: string;
          sort: string = "updated"; order: string = "desc"; Accept: string = "";
          startPage: string = ""): Recallable =
  ## getLegacyUserSearchKeyword
  ## Find users by keyword.
  ##   sort: string
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  ##   keyword: string (required)
  ##          : The search term
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   startPage: string
  ##            : The page number to fetch
  var path_754339 = newJObject()
  var query_754340 = newJObject()
  var header_754341 = newJObject()
  add(query_754340, "sort", newJString(sort))
  add(path_754339, "keyword", newJString(keyword))
  add(query_754340, "order", newJString(order))
  add(header_754341, "Accept", newJString(Accept))
  add(query_754340, "start_page", newJString(startPage))
  result = call_754338.call(path_754339, query_754340, header_754341, nil, nil)

var getLegacyUserSearchKeyword* = Call_GetLegacyUserSearchKeyword_754329(
    name: "getLegacyUserSearchKeyword", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/legacy/user/search/{keyword}",
    validator: validate_GetLegacyUserSearchKeyword_754330, base: "/",
    makeUrl: url_GetLegacyUserSearchKeyword_754331, schemes: {Scheme.Https})
type
  Call_PostMarkdown_754342 = ref object of OpenApiRestCall_753573
proc url_PostMarkdown_754344(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostMarkdown_754343(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Render an arbitrary Markdown document
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754345 = header.getOrDefault("Accept")
  valid_754345 = validateParameter(valid_754345, JString, required = false,
                                 default = nil)
  if valid_754345 != nil:
    section.add "Accept", valid_754345
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_754347: Call_PostMarkdown_754342; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Render an arbitrary Markdown document
  ## 
  let valid = call_754347.validator(path, query, header, formData, body, _)
  let scheme = call_754347.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754347.makeUrl(scheme.get, call_754347.host, call_754347.base,
                             call_754347.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754347, uri, valid, _)

proc call*(call_754348: Call_PostMarkdown_754342; body: JsonNode; Accept: string = ""): Recallable =
  ## postMarkdown
  ## Render an arbitrary Markdown document
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_754349 = newJObject()
  var body_754350 = newJObject()
  add(header_754349, "Accept", newJString(Accept))
  if body != nil:
    body_754350 = body
  result = call_754348.call(nil, nil, header_754349, nil, body_754350)

var postMarkdown* = Call_PostMarkdown_754342(name: "postMarkdown",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/markdown",
    validator: validate_PostMarkdown_754343, base: "/", makeUrl: url_PostMarkdown_754344,
    schemes: {Scheme.Https})
type
  Call_PostMarkdownRaw_754351 = ref object of OpenApiRestCall_753573
proc url_PostMarkdownRaw_754353(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostMarkdownRaw_754352(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode; _: string = ""): JsonNode =
  ## Render a Markdown document in raw mode
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754354 = header.getOrDefault("Accept")
  valid_754354 = validateParameter(valid_754354, JString, required = false,
                                 default = nil)
  if valid_754354 != nil:
    section.add "Accept", valid_754354
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754355: Call_PostMarkdownRaw_754351; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Render a Markdown document in raw mode
  ## 
  let valid = call_754355.validator(path, query, header, formData, body, _)
  let scheme = call_754355.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754355.makeUrl(scheme.get, call_754355.host, call_754355.base,
                             call_754355.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754355, uri, valid, _)

proc call*(call_754356: Call_PostMarkdownRaw_754351; Accept: string = ""): Recallable =
  ## postMarkdownRaw
  ## Render a Markdown document in raw mode
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_754357 = newJObject()
  add(header_754357, "Accept", newJString(Accept))
  result = call_754356.call(nil, nil, header_754357, nil, nil)

var postMarkdownRaw* = Call_PostMarkdownRaw_754351(name: "postMarkdownRaw",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/markdown/raw",
    validator: validate_PostMarkdownRaw_754352, base: "/",
    makeUrl: url_PostMarkdownRaw_754353, schemes: {Scheme.Https})
type
  Call_GetMeta_754358 = ref object of OpenApiRestCall_753573
proc url_GetMeta_754360(protocol: Scheme; host: string; base: string; route: string;
                       path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetMeta_754359(path: JsonNode; query: JsonNode; header: JsonNode;
                            formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## This gives some information about GitHub.com, the service.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754361 = header.getOrDefault("Accept")
  valid_754361 = validateParameter(valid_754361, JString, required = false,
                                 default = nil)
  if valid_754361 != nil:
    section.add "Accept", valid_754361
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754362: Call_GetMeta_754358; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## This gives some information about GitHub.com, the service.
  ## 
  let valid = call_754362.validator(path, query, header, formData, body, _)
  let scheme = call_754362.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754362.makeUrl(scheme.get, call_754362.host, call_754362.base,
                             call_754362.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754362, uri, valid, _)

proc call*(call_754363: Call_GetMeta_754358; Accept: string = ""): Recallable =
  ## getMeta
  ## This gives some information about GitHub.com, the service.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_754364 = newJObject()
  add(header_754364, "Accept", newJString(Accept))
  result = call_754363.call(nil, nil, header_754364, nil, nil)

var getMeta* = Call_GetMeta_754358(name: "getMeta", meth: HttpMethod.HttpGet,
                                host: "api.github.com", route: "/meta",
                                validator: validate_GetMeta_754359, base: "/",
                                makeUrl: url_GetMeta_754360,
                                schemes: {Scheme.Https})
type
  Call_GetNetworksOwnerRepoEvents_754365 = ref object of OpenApiRestCall_753573
proc url_GetNetworksOwnerRepoEvents_754367(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/networks/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetNetworksOwnerRepoEvents_754366(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List public events for a network of repositories.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of the owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_754368 = path.getOrDefault("repo")
  valid_754368 = validateParameter(valid_754368, JString, required = true,
                                 default = nil)
  if valid_754368 != nil:
    section.add "repo", valid_754368
  var valid_754369 = path.getOrDefault("owner")
  valid_754369 = validateParameter(valid_754369, JString, required = true,
                                 default = nil)
  if valid_754369 != nil:
    section.add "owner", valid_754369
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754370 = header.getOrDefault("Accept")
  valid_754370 = validateParameter(valid_754370, JString, required = false,
                                 default = nil)
  if valid_754370 != nil:
    section.add "Accept", valid_754370
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754371: Call_GetNetworksOwnerRepoEvents_754365;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List public events for a network of repositories.
  ## 
  let valid = call_754371.validator(path, query, header, formData, body, _)
  let scheme = call_754371.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754371.makeUrl(scheme.get, call_754371.host, call_754371.base,
                             call_754371.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754371, uri, valid, _)

proc call*(call_754372: Call_GetNetworksOwnerRepoEvents_754365; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getNetworksOwnerRepoEvents
  ## List public events for a network of repositories.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of the owner.
  var path_754373 = newJObject()
  var header_754374 = newJObject()
  add(header_754374, "Accept", newJString(Accept))
  add(path_754373, "repo", newJString(repo))
  add(path_754373, "owner", newJString(owner))
  result = call_754372.call(path_754373, nil, header_754374, nil, nil)

var getNetworksOwnerRepoEvents* = Call_GetNetworksOwnerRepoEvents_754365(
    name: "getNetworksOwnerRepoEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/networks/{owner}/{repo}/events",
    validator: validate_GetNetworksOwnerRepoEvents_754366, base: "/",
    makeUrl: url_GetNetworksOwnerRepoEvents_754367, schemes: {Scheme.Https})
type
  Call_PutNotifications_754386 = ref object of OpenApiRestCall_753573
proc url_PutNotifications_754388(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PutNotifications_754387(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode =
  ## Mark as read.
  ## Marking a notification as "read" removes it from the default view on GitHub.com.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754389 = header.getOrDefault("Accept")
  valid_754389 = validateParameter(valid_754389, JString, required = false,
                                 default = nil)
  if valid_754389 != nil:
    section.add "Accept", valid_754389
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_754391: Call_PutNotifications_754386; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Mark as read.
  ## Marking a notification as "read" removes it from the default view on GitHub.com.
  ## 
  ## 
  let valid = call_754391.validator(path, query, header, formData, body, _)
  let scheme = call_754391.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754391.makeUrl(scheme.get, call_754391.host, call_754391.base,
                             call_754391.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754391, uri, valid, _)

proc call*(call_754392: Call_PutNotifications_754386; body: JsonNode;
          Accept: string = ""): Recallable =
  ## putNotifications
  ## Mark as read.
  ## Marking a notification as "read" removes it from the default view on GitHub.com.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_754393 = newJObject()
  var body_754394 = newJObject()
  add(header_754393, "Accept", newJString(Accept))
  if body != nil:
    body_754394 = body
  result = call_754392.call(nil, nil, header_754393, nil, body_754394)

var putNotifications* = Call_PutNotifications_754386(name: "putNotifications",
    meth: HttpMethod.HttpPut, host: "api.github.com", route: "/notifications",
    validator: validate_PutNotifications_754387, base: "/",
    makeUrl: url_PutNotifications_754388, schemes: {Scheme.Https})
type
  Call_GetNotifications_754375 = ref object of OpenApiRestCall_753573
proc url_GetNotifications_754377(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetNotifications_754376(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode =
  ## List your notifications.
  ## List all notifications for the current user, grouped by repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   participating: JBool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   all: JBool
  ##      : True to show notifications marked as read.
  section = newJObject()
  var valid_754378 = query.getOrDefault("participating")
  valid_754378 = validateParameter(valid_754378, JBool, required = false, default = nil)
  if valid_754378 != nil:
    section.add "participating", valid_754378
  var valid_754379 = query.getOrDefault("since")
  valid_754379 = validateParameter(valid_754379, JString, required = false,
                                 default = nil)
  if valid_754379 != nil:
    section.add "since", valid_754379
  var valid_754380 = query.getOrDefault("all")
  valid_754380 = validateParameter(valid_754380, JBool, required = false, default = nil)
  if valid_754380 != nil:
    section.add "all", valid_754380
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754381 = header.getOrDefault("Accept")
  valid_754381 = validateParameter(valid_754381, JString, required = false,
                                 default = nil)
  if valid_754381 != nil:
    section.add "Accept", valid_754381
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754382: Call_GetNotifications_754375; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List your notifications.
  ## List all notifications for the current user, grouped by repository.
  ## 
  ## 
  let valid = call_754382.validator(path, query, header, formData, body, _)
  let scheme = call_754382.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754382.makeUrl(scheme.get, call_754382.host, call_754382.base,
                             call_754382.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754382, uri, valid, _)

proc call*(call_754383: Call_GetNotifications_754375; participating: bool = false;
          since: string = ""; all: bool = false; Accept: string = ""): Recallable =
  ## getNotifications
  ## List your notifications.
  ## List all notifications for the current user, grouped by repository.
  ## 
  ##   participating: bool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   all: bool
  ##      : True to show notifications marked as read.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var query_754384 = newJObject()
  var header_754385 = newJObject()
  add(query_754384, "participating", newJBool(participating))
  add(query_754384, "since", newJString(since))
  add(query_754384, "all", newJBool(all))
  add(header_754385, "Accept", newJString(Accept))
  result = call_754383.call(nil, query_754384, header_754385, nil, nil)

var getNotifications* = Call_GetNotifications_754375(name: "getNotifications",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/notifications",
    validator: validate_GetNotifications_754376, base: "/",
    makeUrl: url_GetNotifications_754377, schemes: {Scheme.Https})
type
  Call_GetNotificationsThreadsId_754395 = ref object of OpenApiRestCall_753573
proc url_GetNotificationsThreadsId_754397(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetNotificationsThreadsId_754396(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## View a single thread.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_754398 = path.getOrDefault("id")
  valid_754398 = validateParameter(valid_754398, JInt, required = true, default = nil)
  if valid_754398 != nil:
    section.add "id", valid_754398
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754399 = header.getOrDefault("Accept")
  valid_754399 = validateParameter(valid_754399, JString, required = false,
                                 default = nil)
  if valid_754399 != nil:
    section.add "Accept", valid_754399
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754400: Call_GetNotificationsThreadsId_754395;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## View a single thread.
  ## 
  let valid = call_754400.validator(path, query, header, formData, body, _)
  let scheme = call_754400.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754400.makeUrl(scheme.get, call_754400.host, call_754400.base,
                             call_754400.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754400, uri, valid, _)

proc call*(call_754401: Call_GetNotificationsThreadsId_754395; id: int;
          Accept: string = ""): Recallable =
  ## getNotificationsThreadsId
  ## View a single thread.
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_754402 = newJObject()
  var header_754403 = newJObject()
  add(path_754402, "id", newJInt(id))
  add(header_754403, "Accept", newJString(Accept))
  result = call_754401.call(path_754402, nil, header_754403, nil, nil)

var getNotificationsThreadsId* = Call_GetNotificationsThreadsId_754395(
    name: "getNotificationsThreadsId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/notifications/threads/{id}",
    validator: validate_GetNotificationsThreadsId_754396, base: "/",
    makeUrl: url_GetNotificationsThreadsId_754397, schemes: {Scheme.Https})
type
  Call_PatchNotificationsThreadsId_754404 = ref object of OpenApiRestCall_753573
proc url_PatchNotificationsThreadsId_754406(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchNotificationsThreadsId_754405(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Mark a thread as read
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_754407 = path.getOrDefault("id")
  valid_754407 = validateParameter(valid_754407, JInt, required = true, default = nil)
  if valid_754407 != nil:
    section.add "id", valid_754407
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754408 = header.getOrDefault("Accept")
  valid_754408 = validateParameter(valid_754408, JString, required = false,
                                 default = nil)
  if valid_754408 != nil:
    section.add "Accept", valid_754408
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754409: Call_PatchNotificationsThreadsId_754404;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Mark a thread as read
  ## 
  let valid = call_754409.validator(path, query, header, formData, body, _)
  let scheme = call_754409.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754409.makeUrl(scheme.get, call_754409.host, call_754409.base,
                             call_754409.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754409, uri, valid, _)

proc call*(call_754410: Call_PatchNotificationsThreadsId_754404; id: int;
          Accept: string = ""): Recallable =
  ## patchNotificationsThreadsId
  ## Mark a thread as read
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_754411 = newJObject()
  var header_754412 = newJObject()
  add(path_754411, "id", newJInt(id))
  add(header_754412, "Accept", newJString(Accept))
  result = call_754410.call(path_754411, nil, header_754412, nil, nil)

var patchNotificationsThreadsId* = Call_PatchNotificationsThreadsId_754404(
    name: "patchNotificationsThreadsId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/notifications/threads/{id}",
    validator: validate_PatchNotificationsThreadsId_754405, base: "/",
    makeUrl: url_PatchNotificationsThreadsId_754406, schemes: {Scheme.Https})
type
  Call_PutNotificationsThreadsIdSubscription_754422 = ref object of OpenApiRestCall_753573
proc url_PutNotificationsThreadsIdSubscription_754424(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutNotificationsThreadsIdSubscription_754423(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Set a Thread Subscription.
  ## This lets you subscribe to a thread, or ignore it. Subscribing to a thread
  ## is unnecessary if the user is already subscribed to the repository. Ignoring
  ## a thread will mute all future notifications (until you comment or get @mentioned).
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_754425 = path.getOrDefault("id")
  valid_754425 = validateParameter(valid_754425, JInt, required = true, default = nil)
  if valid_754425 != nil:
    section.add "id", valid_754425
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754426 = header.getOrDefault("Accept")
  valid_754426 = validateParameter(valid_754426, JString, required = false,
                                 default = nil)
  if valid_754426 != nil:
    section.add "Accept", valid_754426
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_754428: Call_PutNotificationsThreadsIdSubscription_754422;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Set a Thread Subscription.
  ## This lets you subscribe to a thread, or ignore it. Subscribing to a thread
  ## is unnecessary if the user is already subscribed to the repository. Ignoring
  ## a thread will mute all future notifications (until you comment or get @mentioned).
  ## 
  ## 
  let valid = call_754428.validator(path, query, header, formData, body, _)
  let scheme = call_754428.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754428.makeUrl(scheme.get, call_754428.host, call_754428.base,
                             call_754428.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754428, uri, valid, _)

proc call*(call_754429: Call_PutNotificationsThreadsIdSubscription_754422; id: int;
          body: JsonNode; Accept: string = ""): Recallable =
  ## putNotificationsThreadsIdSubscription
  ## Set a Thread Subscription.
  ## This lets you subscribe to a thread, or ignore it. Subscribing to a thread
  ## is unnecessary if the user is already subscribed to the repository. Ignoring
  ## a thread will mute all future notifications (until you comment or get @mentioned).
  ## 
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var path_754430 = newJObject()
  var header_754431 = newJObject()
  var body_754432 = newJObject()
  add(path_754430, "id", newJInt(id))
  add(header_754431, "Accept", newJString(Accept))
  if body != nil:
    body_754432 = body
  result = call_754429.call(path_754430, nil, header_754431, nil, body_754432)

var putNotificationsThreadsIdSubscription* = Call_PutNotificationsThreadsIdSubscription_754422(
    name: "putNotificationsThreadsIdSubscription", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/notifications/threads/{id}/subscription",
    validator: validate_PutNotificationsThreadsIdSubscription_754423, base: "/",
    makeUrl: url_PutNotificationsThreadsIdSubscription_754424,
    schemes: {Scheme.Https})
type
  Call_GetNotificationsThreadsIdSubscription_754413 = ref object of OpenApiRestCall_753573
proc url_GetNotificationsThreadsIdSubscription_754415(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetNotificationsThreadsIdSubscription_754414(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Get a Thread Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_754416 = path.getOrDefault("id")
  valid_754416 = validateParameter(valid_754416, JInt, required = true, default = nil)
  if valid_754416 != nil:
    section.add "id", valid_754416
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754417 = header.getOrDefault("Accept")
  valid_754417 = validateParameter(valid_754417, JString, required = false,
                                 default = nil)
  if valid_754417 != nil:
    section.add "Accept", valid_754417
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754418: Call_GetNotificationsThreadsIdSubscription_754413;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a Thread Subscription.
  ## 
  let valid = call_754418.validator(path, query, header, formData, body, _)
  let scheme = call_754418.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754418.makeUrl(scheme.get, call_754418.host, call_754418.base,
                             call_754418.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754418, uri, valid, _)

proc call*(call_754419: Call_GetNotificationsThreadsIdSubscription_754413; id: int;
          Accept: string = ""): Recallable =
  ## getNotificationsThreadsIdSubscription
  ## Get a Thread Subscription.
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_754420 = newJObject()
  var header_754421 = newJObject()
  add(path_754420, "id", newJInt(id))
  add(header_754421, "Accept", newJString(Accept))
  result = call_754419.call(path_754420, nil, header_754421, nil, nil)

var getNotificationsThreadsIdSubscription* = Call_GetNotificationsThreadsIdSubscription_754413(
    name: "getNotificationsThreadsIdSubscription", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/notifications/threads/{id}/subscription",
    validator: validate_GetNotificationsThreadsIdSubscription_754414, base: "/",
    makeUrl: url_GetNotificationsThreadsIdSubscription_754415,
    schemes: {Scheme.Https})
type
  Call_DeleteNotificationsThreadsIdSubscription_754433 = ref object of OpenApiRestCall_753573
proc url_DeleteNotificationsThreadsIdSubscription_754435(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteNotificationsThreadsIdSubscription_754434(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Delete a Thread Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_754436 = path.getOrDefault("id")
  valid_754436 = validateParameter(valid_754436, JInt, required = true, default = nil)
  if valid_754436 != nil:
    section.add "id", valid_754436
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754437 = header.getOrDefault("Accept")
  valid_754437 = validateParameter(valid_754437, JString, required = false,
                                 default = nil)
  if valid_754437 != nil:
    section.add "Accept", valid_754437
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754438: Call_DeleteNotificationsThreadsIdSubscription_754433;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a Thread Subscription.
  ## 
  let valid = call_754438.validator(path, query, header, formData, body, _)
  let scheme = call_754438.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754438.makeUrl(scheme.get, call_754438.host, call_754438.base,
                             call_754438.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754438, uri, valid, _)

proc call*(call_754439: Call_DeleteNotificationsThreadsIdSubscription_754433;
          id: int; Accept: string = ""): Recallable =
  ## deleteNotificationsThreadsIdSubscription
  ## Delete a Thread Subscription.
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_754440 = newJObject()
  var header_754441 = newJObject()
  add(path_754440, "id", newJInt(id))
  add(header_754441, "Accept", newJString(Accept))
  result = call_754439.call(path_754440, nil, header_754441, nil, nil)

var deleteNotificationsThreadsIdSubscription* = Call_DeleteNotificationsThreadsIdSubscription_754433(
    name: "deleteNotificationsThreadsIdSubscription", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/notifications/threads/{id}/subscription",
    validator: validate_DeleteNotificationsThreadsIdSubscription_754434,
    base: "/", makeUrl: url_DeleteNotificationsThreadsIdSubscription_754435,
    schemes: {Scheme.Https})
type
  Call_GetOrgsOrg_754442 = ref object of OpenApiRestCall_753573
proc url_GetOrgsOrg_754444(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrg_754443(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Get an Organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_754445 = path.getOrDefault("org")
  valid_754445 = validateParameter(valid_754445, JString, required = true,
                                 default = nil)
  if valid_754445 != nil:
    section.add "org", valid_754445
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754446 = header.getOrDefault("Accept")
  valid_754446 = validateParameter(valid_754446, JString, required = false,
                                 default = nil)
  if valid_754446 != nil:
    section.add "Accept", valid_754446
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754447: Call_GetOrgsOrg_754442; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get an Organization.
  ## 
  let valid = call_754447.validator(path, query, header, formData, body, _)
  let scheme = call_754447.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754447.makeUrl(scheme.get, call_754447.host, call_754447.base,
                             call_754447.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754447, uri, valid, _)

proc call*(call_754448: Call_GetOrgsOrg_754442; org: string; Accept: string = ""): Recallable =
  ## getOrgsOrg
  ## Get an Organization.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_754449 = newJObject()
  var header_754450 = newJObject()
  add(header_754450, "Accept", newJString(Accept))
  add(path_754449, "org", newJString(org))
  result = call_754448.call(path_754449, nil, header_754450, nil, nil)

var getOrgsOrg* = Call_GetOrgsOrg_754442(name: "getOrgsOrg",
                                      meth: HttpMethod.HttpGet,
                                      host: "api.github.com",
                                      route: "/orgs/{org}",
                                      validator: validate_GetOrgsOrg_754443,
                                      base: "/", makeUrl: url_GetOrgsOrg_754444,
                                      schemes: {Scheme.Https})
type
  Call_PatchOrgsOrg_754451 = ref object of OpenApiRestCall_753573
proc url_PatchOrgsOrg_754453(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchOrgsOrg_754452(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Edit an Organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_754454 = path.getOrDefault("org")
  valid_754454 = validateParameter(valid_754454, JString, required = true,
                                 default = nil)
  if valid_754454 != nil:
    section.add "org", valid_754454
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754455 = header.getOrDefault("Accept")
  valid_754455 = validateParameter(valid_754455, JString, required = false,
                                 default = nil)
  if valid_754455 != nil:
    section.add "Accept", valid_754455
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_754457: Call_PatchOrgsOrg_754451; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit an Organization.
  ## 
  let valid = call_754457.validator(path, query, header, formData, body, _)
  let scheme = call_754457.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754457.makeUrl(scheme.get, call_754457.host, call_754457.base,
                             call_754457.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754457, uri, valid, _)

proc call*(call_754458: Call_PatchOrgsOrg_754451; org: string; body: JsonNode;
          Accept: string = ""): Recallable =
  ## patchOrgsOrg
  ## Edit an Organization.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  ##   body: JObject (required)
  var path_754459 = newJObject()
  var header_754460 = newJObject()
  var body_754461 = newJObject()
  add(header_754460, "Accept", newJString(Accept))
  add(path_754459, "org", newJString(org))
  if body != nil:
    body_754461 = body
  result = call_754458.call(path_754459, nil, header_754460, nil, body_754461)

var patchOrgsOrg* = Call_PatchOrgsOrg_754451(name: "patchOrgsOrg",
    meth: HttpMethod.HttpPatch, host: "api.github.com", route: "/orgs/{org}",
    validator: validate_PatchOrgsOrg_754452, base: "/", makeUrl: url_PatchOrgsOrg_754453,
    schemes: {Scheme.Https})
type
  Call_GetOrgsOrgEvents_754462 = ref object of OpenApiRestCall_753573
proc url_GetOrgsOrgEvents_754464(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgEvents_754463(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode =
  ## List public events for an organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_754465 = path.getOrDefault("org")
  valid_754465 = validateParameter(valid_754465, JString, required = true,
                                 default = nil)
  if valid_754465 != nil:
    section.add "org", valid_754465
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754466 = header.getOrDefault("Accept")
  valid_754466 = validateParameter(valid_754466, JString, required = false,
                                 default = nil)
  if valid_754466 != nil:
    section.add "Accept", valid_754466
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754467: Call_GetOrgsOrgEvents_754462; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List public events for an organization.
  ## 
  let valid = call_754467.validator(path, query, header, formData, body, _)
  let scheme = call_754467.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754467.makeUrl(scheme.get, call_754467.host, call_754467.base,
                             call_754467.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754467, uri, valid, _)

proc call*(call_754468: Call_GetOrgsOrgEvents_754462; org: string;
          Accept: string = ""): Recallable =
  ## getOrgsOrgEvents
  ## List public events for an organization.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_754469 = newJObject()
  var header_754470 = newJObject()
  add(header_754470, "Accept", newJString(Accept))
  add(path_754469, "org", newJString(org))
  result = call_754468.call(path_754469, nil, header_754470, nil, nil)

var getOrgsOrgEvents* = Call_GetOrgsOrgEvents_754462(name: "getOrgsOrgEvents",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/events",
    validator: validate_GetOrgsOrgEvents_754463, base: "/",
    makeUrl: url_GetOrgsOrgEvents_754464, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgIssues_754471 = ref object of OpenApiRestCall_753573
proc url_GetOrgsOrgIssues_754473(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/issues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgIssues_754472(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode =
  ## List issues.
  ## List all issues for a given organization for the authenticated user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_754474 = path.getOrDefault("org")
  valid_754474 = validateParameter(valid_754474, JString, required = true,
                                 default = nil)
  if valid_754474 != nil:
    section.add "org", valid_754474
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString (required)
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  ##   direction: JString (required)
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   state: JString (required)
  section = newJObject()
  var valid_754475 = query.getOrDefault("sort")
  valid_754475 = validateParameter(valid_754475, JString, required = true,
                                 default = newJString("created"))
  if valid_754475 != nil:
    section.add "sort", valid_754475
  var valid_754476 = query.getOrDefault("since")
  valid_754476 = validateParameter(valid_754476, JString, required = false,
                                 default = nil)
  if valid_754476 != nil:
    section.add "since", valid_754476
  var valid_754477 = query.getOrDefault("direction")
  valid_754477 = validateParameter(valid_754477, JString, required = true,
                                 default = newJString("desc"))
  if valid_754477 != nil:
    section.add "direction", valid_754477
  var valid_754478 = query.getOrDefault("labels")
  valid_754478 = validateParameter(valid_754478, JString, required = true,
                                 default = nil)
  if valid_754478 != nil:
    section.add "labels", valid_754478
  var valid_754479 = query.getOrDefault("filter")
  valid_754479 = validateParameter(valid_754479, JString, required = true,
                                 default = newJString("all"))
  if valid_754479 != nil:
    section.add "filter", valid_754479
  var valid_754480 = query.getOrDefault("state")
  valid_754480 = validateParameter(valid_754480, JString, required = true,
                                 default = newJString("open"))
  if valid_754480 != nil:
    section.add "state", valid_754480
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754481 = header.getOrDefault("Accept")
  valid_754481 = validateParameter(valid_754481, JString, required = false,
                                 default = nil)
  if valid_754481 != nil:
    section.add "Accept", valid_754481
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754482: Call_GetOrgsOrgIssues_754471; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List issues.
  ## List all issues for a given organization for the authenticated user.
  ## 
  ## 
  let valid = call_754482.validator(path, query, header, formData, body, _)
  let scheme = call_754482.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754482.makeUrl(scheme.get, call_754482.host, call_754482.base,
                             call_754482.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754482, uri, valid, _)

proc call*(call_754483: Call_GetOrgsOrgIssues_754471; labels: string; org: string;
          sort: string = "created"; since: string = ""; direction: string = "desc";
          Accept: string = ""; filter: string = "all"; state: string = "open"): Recallable =
  ## getOrgsOrgIssues
  ## List issues.
  ## List all issues for a given organization for the authenticated user.
  ## 
  ##   sort: string (required)
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  ##   direction: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   org: string (required)
  ##      : Name of organisation.
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   state: string (required)
  var path_754484 = newJObject()
  var query_754485 = newJObject()
  var header_754486 = newJObject()
  add(query_754485, "sort", newJString(sort))
  add(query_754485, "since", newJString(since))
  add(query_754485, "direction", newJString(direction))
  add(header_754486, "Accept", newJString(Accept))
  add(query_754485, "labels", newJString(labels))
  add(path_754484, "org", newJString(org))
  add(query_754485, "filter", newJString(filter))
  add(query_754485, "state", newJString(state))
  result = call_754483.call(path_754484, query_754485, header_754486, nil, nil)

var getOrgsOrgIssues* = Call_GetOrgsOrgIssues_754471(name: "getOrgsOrgIssues",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/issues",
    validator: validate_GetOrgsOrgIssues_754472, base: "/",
    makeUrl: url_GetOrgsOrgIssues_754473, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgMembers_754487 = ref object of OpenApiRestCall_753573
proc url_GetOrgsOrgMembers_754489(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/members")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgMembers_754488(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode =
  ## Members list.
  ## List all users who are members of an organization. A member is a user tha
  ## belongs to at least 1 team in the organization. If the authenticated user
  ## is also an owner of this organization then both concealed and public members
  ## will be returned. If the requester is not an owner of the organization the
  ## query will be redirected to the public members list.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_754490 = path.getOrDefault("org")
  valid_754490 = validateParameter(valid_754490, JString, required = true,
                                 default = nil)
  if valid_754490 != nil:
    section.add "org", valid_754490
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754491 = header.getOrDefault("Accept")
  valid_754491 = validateParameter(valid_754491, JString, required = false,
                                 default = nil)
  if valid_754491 != nil:
    section.add "Accept", valid_754491
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754492: Call_GetOrgsOrgMembers_754487; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Members list.
  ## List all users who are members of an organization. A member is a user tha
  ## belongs to at least 1 team in the organization. If the authenticated user
  ## is also an owner of this organization then both concealed and public members
  ## will be returned. If the requester is not an owner of the organization the
  ## query will be redirected to the public members list.
  ## 
  ## 
  let valid = call_754492.validator(path, query, header, formData, body, _)
  let scheme = call_754492.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754492.makeUrl(scheme.get, call_754492.host, call_754492.base,
                             call_754492.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754492, uri, valid, _)

proc call*(call_754493: Call_GetOrgsOrgMembers_754487; org: string;
          Accept: string = ""): Recallable =
  ## getOrgsOrgMembers
  ## Members list.
  ## List all users who are members of an organization. A member is a user tha
  ## belongs to at least 1 team in the organization. If the authenticated user
  ## is also an owner of this organization then both concealed and public members
  ## will be returned. If the requester is not an owner of the organization the
  ## query will be redirected to the public members list.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_754494 = newJObject()
  var header_754495 = newJObject()
  add(header_754495, "Accept", newJString(Accept))
  add(path_754494, "org", newJString(org))
  result = call_754493.call(path_754494, nil, header_754495, nil, nil)

var getOrgsOrgMembers* = Call_GetOrgsOrgMembers_754487(name: "getOrgsOrgMembers",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/members",
    validator: validate_GetOrgsOrgMembers_754488, base: "/",
    makeUrl: url_GetOrgsOrgMembers_754489, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgMembersUsername_754496 = ref object of OpenApiRestCall_753573
proc url_GetOrgsOrgMembersUsername_754498(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgMembersUsername_754497(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Check if a user is, publicly or privately, a member of the organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of the user.
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_754499 = path.getOrDefault("username")
  valid_754499 = validateParameter(valid_754499, JString, required = true,
                                 default = nil)
  if valid_754499 != nil:
    section.add "username", valid_754499
  var valid_754500 = path.getOrDefault("org")
  valid_754500 = validateParameter(valid_754500, JString, required = true,
                                 default = nil)
  if valid_754500 != nil:
    section.add "org", valid_754500
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754501 = header.getOrDefault("Accept")
  valid_754501 = validateParameter(valid_754501, JString, required = false,
                                 default = nil)
  if valid_754501 != nil:
    section.add "Accept", valid_754501
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754502: Call_GetOrgsOrgMembersUsername_754496;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if a user is, publicly or privately, a member of the organization.
  ## 
  let valid = call_754502.validator(path, query, header, formData, body, _)
  let scheme = call_754502.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754502.makeUrl(scheme.get, call_754502.host, call_754502.base,
                             call_754502.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754502, uri, valid, _)

proc call*(call_754503: Call_GetOrgsOrgMembersUsername_754496; username: string;
          org: string; Accept: string = ""): Recallable =
  ## getOrgsOrgMembersUsername
  ## Check if a user is, publicly or privately, a member of the organization.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_754504 = newJObject()
  var header_754505 = newJObject()
  add(path_754504, "username", newJString(username))
  add(header_754505, "Accept", newJString(Accept))
  add(path_754504, "org", newJString(org))
  result = call_754503.call(path_754504, nil, header_754505, nil, nil)

var getOrgsOrgMembersUsername* = Call_GetOrgsOrgMembersUsername_754496(
    name: "getOrgsOrgMembersUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/orgs/{org}/members/{username}",
    validator: validate_GetOrgsOrgMembersUsername_754497, base: "/",
    makeUrl: url_GetOrgsOrgMembersUsername_754498, schemes: {Scheme.Https})
type
  Call_DeleteOrgsOrgMembersUsername_754506 = ref object of OpenApiRestCall_753573
proc url_DeleteOrgsOrgMembersUsername_754508(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteOrgsOrgMembersUsername_754507(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Remove a member.
  ## Removing a user from this list will remove them from all teams and they
  ## will no longer have any access to the organization's repositories.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of the user.
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_754509 = path.getOrDefault("username")
  valid_754509 = validateParameter(valid_754509, JString, required = true,
                                 default = nil)
  if valid_754509 != nil:
    section.add "username", valid_754509
  var valid_754510 = path.getOrDefault("org")
  valid_754510 = validateParameter(valid_754510, JString, required = true,
                                 default = nil)
  if valid_754510 != nil:
    section.add "org", valid_754510
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754511 = header.getOrDefault("Accept")
  valid_754511 = validateParameter(valid_754511, JString, required = false,
                                 default = nil)
  if valid_754511 != nil:
    section.add "Accept", valid_754511
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754512: Call_DeleteOrgsOrgMembersUsername_754506;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Remove a member.
  ## Removing a user from this list will remove them from all teams and they
  ## will no longer have any access to the organization's repositories.
  ## 
  ## 
  let valid = call_754512.validator(path, query, header, formData, body, _)
  let scheme = call_754512.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754512.makeUrl(scheme.get, call_754512.host, call_754512.base,
                             call_754512.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754512, uri, valid, _)

proc call*(call_754513: Call_DeleteOrgsOrgMembersUsername_754506; username: string;
          org: string; Accept: string = ""): Recallable =
  ## deleteOrgsOrgMembersUsername
  ## Remove a member.
  ## Removing a user from this list will remove them from all teams and they
  ## will no longer have any access to the organization's repositories.
  ## 
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_754514 = newJObject()
  var header_754515 = newJObject()
  add(path_754514, "username", newJString(username))
  add(header_754515, "Accept", newJString(Accept))
  add(path_754514, "org", newJString(org))
  result = call_754513.call(path_754514, nil, header_754515, nil, nil)

var deleteOrgsOrgMembersUsername* = Call_DeleteOrgsOrgMembersUsername_754506(
    name: "deleteOrgsOrgMembersUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/orgs/{org}/members/{username}",
    validator: validate_DeleteOrgsOrgMembersUsername_754507, base: "/",
    makeUrl: url_DeleteOrgsOrgMembersUsername_754508, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgPublicMembers_754516 = ref object of OpenApiRestCall_753573
proc url_GetOrgsOrgPublicMembers_754518(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/public_members")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgPublicMembers_754517(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Public members list.
  ## Members of an organization can choose to have their membership publicized
  ## or not.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_754519 = path.getOrDefault("org")
  valid_754519 = validateParameter(valid_754519, JString, required = true,
                                 default = nil)
  if valid_754519 != nil:
    section.add "org", valid_754519
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754520 = header.getOrDefault("Accept")
  valid_754520 = validateParameter(valid_754520, JString, required = false,
                                 default = nil)
  if valid_754520 != nil:
    section.add "Accept", valid_754520
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754521: Call_GetOrgsOrgPublicMembers_754516; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Public members list.
  ## Members of an organization can choose to have their membership publicized
  ## or not.
  ## 
  ## 
  let valid = call_754521.validator(path, query, header, formData, body, _)
  let scheme = call_754521.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754521.makeUrl(scheme.get, call_754521.host, call_754521.base,
                             call_754521.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754521, uri, valid, _)

proc call*(call_754522: Call_GetOrgsOrgPublicMembers_754516; org: string;
          Accept: string = ""): Recallable =
  ## getOrgsOrgPublicMembers
  ## Public members list.
  ## Members of an organization can choose to have their membership publicized
  ## or not.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_754523 = newJObject()
  var header_754524 = newJObject()
  add(header_754524, "Accept", newJString(Accept))
  add(path_754523, "org", newJString(org))
  result = call_754522.call(path_754523, nil, header_754524, nil, nil)

var getOrgsOrgPublicMembers* = Call_GetOrgsOrgPublicMembers_754516(
    name: "getOrgsOrgPublicMembers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/orgs/{org}/public_members",
    validator: validate_GetOrgsOrgPublicMembers_754517, base: "/",
    makeUrl: url_GetOrgsOrgPublicMembers_754518, schemes: {Scheme.Https})
type
  Call_PutOrgsOrgPublicMembersUsername_754535 = ref object of OpenApiRestCall_753573
proc url_PutOrgsOrgPublicMembersUsername_754537(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/public_members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutOrgsOrgPublicMembersUsername_754536(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Publicize a user's membership.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of the user.
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_754538 = path.getOrDefault("username")
  valid_754538 = validateParameter(valid_754538, JString, required = true,
                                 default = nil)
  if valid_754538 != nil:
    section.add "username", valid_754538
  var valid_754539 = path.getOrDefault("org")
  valid_754539 = validateParameter(valid_754539, JString, required = true,
                                 default = nil)
  if valid_754539 != nil:
    section.add "org", valid_754539
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754540 = header.getOrDefault("Accept")
  valid_754540 = validateParameter(valid_754540, JString, required = false,
                                 default = nil)
  if valid_754540 != nil:
    section.add "Accept", valid_754540
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754541: Call_PutOrgsOrgPublicMembersUsername_754535;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Publicize a user's membership.
  ## 
  let valid = call_754541.validator(path, query, header, formData, body, _)
  let scheme = call_754541.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754541.makeUrl(scheme.get, call_754541.host, call_754541.base,
                             call_754541.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754541, uri, valid, _)

proc call*(call_754542: Call_PutOrgsOrgPublicMembersUsername_754535;
          username: string; org: string; Accept: string = ""): Recallable =
  ## putOrgsOrgPublicMembersUsername
  ## Publicize a user's membership.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_754543 = newJObject()
  var header_754544 = newJObject()
  add(path_754543, "username", newJString(username))
  add(header_754544, "Accept", newJString(Accept))
  add(path_754543, "org", newJString(org))
  result = call_754542.call(path_754543, nil, header_754544, nil, nil)

var putOrgsOrgPublicMembersUsername* = Call_PutOrgsOrgPublicMembersUsername_754535(
    name: "putOrgsOrgPublicMembersUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/orgs/{org}/public_members/{username}",
    validator: validate_PutOrgsOrgPublicMembersUsername_754536, base: "/",
    makeUrl: url_PutOrgsOrgPublicMembersUsername_754537, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgPublicMembersUsername_754525 = ref object of OpenApiRestCall_753573
proc url_GetOrgsOrgPublicMembersUsername_754527(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/public_members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgPublicMembersUsername_754526(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Check public membership.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of the user.
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_754528 = path.getOrDefault("username")
  valid_754528 = validateParameter(valid_754528, JString, required = true,
                                 default = nil)
  if valid_754528 != nil:
    section.add "username", valid_754528
  var valid_754529 = path.getOrDefault("org")
  valid_754529 = validateParameter(valid_754529, JString, required = true,
                                 default = nil)
  if valid_754529 != nil:
    section.add "org", valid_754529
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754530 = header.getOrDefault("Accept")
  valid_754530 = validateParameter(valid_754530, JString, required = false,
                                 default = nil)
  if valid_754530 != nil:
    section.add "Accept", valid_754530
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754531: Call_GetOrgsOrgPublicMembersUsername_754525;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check public membership.
  ## 
  let valid = call_754531.validator(path, query, header, formData, body, _)
  let scheme = call_754531.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754531.makeUrl(scheme.get, call_754531.host, call_754531.base,
                             call_754531.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754531, uri, valid, _)

proc call*(call_754532: Call_GetOrgsOrgPublicMembersUsername_754525;
          username: string; org: string; Accept: string = ""): Recallable =
  ## getOrgsOrgPublicMembersUsername
  ## Check public membership.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_754533 = newJObject()
  var header_754534 = newJObject()
  add(path_754533, "username", newJString(username))
  add(header_754534, "Accept", newJString(Accept))
  add(path_754533, "org", newJString(org))
  result = call_754532.call(path_754533, nil, header_754534, nil, nil)

var getOrgsOrgPublicMembersUsername* = Call_GetOrgsOrgPublicMembersUsername_754525(
    name: "getOrgsOrgPublicMembersUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/orgs/{org}/public_members/{username}",
    validator: validate_GetOrgsOrgPublicMembersUsername_754526, base: "/",
    makeUrl: url_GetOrgsOrgPublicMembersUsername_754527, schemes: {Scheme.Https})
type
  Call_DeleteOrgsOrgPublicMembersUsername_754545 = ref object of OpenApiRestCall_753573
proc url_DeleteOrgsOrgPublicMembersUsername_754547(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/public_members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteOrgsOrgPublicMembersUsername_754546(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Conceal a user's membership.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of the user.
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_754548 = path.getOrDefault("username")
  valid_754548 = validateParameter(valid_754548, JString, required = true,
                                 default = nil)
  if valid_754548 != nil:
    section.add "username", valid_754548
  var valid_754549 = path.getOrDefault("org")
  valid_754549 = validateParameter(valid_754549, JString, required = true,
                                 default = nil)
  if valid_754549 != nil:
    section.add "org", valid_754549
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754550 = header.getOrDefault("Accept")
  valid_754550 = validateParameter(valid_754550, JString, required = false,
                                 default = nil)
  if valid_754550 != nil:
    section.add "Accept", valid_754550
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754551: Call_DeleteOrgsOrgPublicMembersUsername_754545;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Conceal a user's membership.
  ## 
  let valid = call_754551.validator(path, query, header, formData, body, _)
  let scheme = call_754551.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754551.makeUrl(scheme.get, call_754551.host, call_754551.base,
                             call_754551.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754551, uri, valid, _)

proc call*(call_754552: Call_DeleteOrgsOrgPublicMembersUsername_754545;
          username: string; org: string; Accept: string = ""): Recallable =
  ## deleteOrgsOrgPublicMembersUsername
  ## Conceal a user's membership.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_754553 = newJObject()
  var header_754554 = newJObject()
  add(path_754553, "username", newJString(username))
  add(header_754554, "Accept", newJString(Accept))
  add(path_754553, "org", newJString(org))
  result = call_754552.call(path_754553, nil, header_754554, nil, nil)

var deleteOrgsOrgPublicMembersUsername* = Call_DeleteOrgsOrgPublicMembersUsername_754545(
    name: "deleteOrgsOrgPublicMembersUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/orgs/{org}/public_members/{username}",
    validator: validate_DeleteOrgsOrgPublicMembersUsername_754546, base: "/",
    makeUrl: url_DeleteOrgsOrgPublicMembersUsername_754547,
    schemes: {Scheme.Https})
type
  Call_PostOrgsOrgRepos_754566 = ref object of OpenApiRestCall_753573
proc url_PostOrgsOrgRepos_754568(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostOrgsOrgRepos_754567(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_754569 = path.getOrDefault("org")
  valid_754569 = validateParameter(valid_754569, JString, required = true,
                                 default = nil)
  if valid_754569 != nil:
    section.add "org", valid_754569
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754570 = header.getOrDefault("Accept")
  valid_754570 = validateParameter(valid_754570, JString, required = false,
                                 default = nil)
  if valid_754570 != nil:
    section.add "Accept", valid_754570
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_754572: Call_PostOrgsOrgRepos_754566; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  let valid = call_754572.validator(path, query, header, formData, body, _)
  let scheme = call_754572.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754572.makeUrl(scheme.get, call_754572.host, call_754572.base,
                             call_754572.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754572, uri, valid, _)

proc call*(call_754573: Call_PostOrgsOrgRepos_754566; org: string; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postOrgsOrgRepos
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  ##   body: JObject (required)
  var path_754574 = newJObject()
  var header_754575 = newJObject()
  var body_754576 = newJObject()
  add(header_754575, "Accept", newJString(Accept))
  add(path_754574, "org", newJString(org))
  if body != nil:
    body_754576 = body
  result = call_754573.call(path_754574, nil, header_754575, nil, body_754576)

var postOrgsOrgRepos* = Call_PostOrgsOrgRepos_754566(name: "postOrgsOrgRepos",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/orgs/{org}/repos",
    validator: validate_PostOrgsOrgRepos_754567, base: "/",
    makeUrl: url_PostOrgsOrgRepos_754568, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgRepos_754555 = ref object of OpenApiRestCall_753573
proc url_GetOrgsOrgRepos_754557(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgRepos_754556(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode; _: string = ""): JsonNode =
  ## List repositories for the specified org.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_754558 = path.getOrDefault("org")
  valid_754558 = validateParameter(valid_754558, JString, required = true,
                                 default = nil)
  if valid_754558 != nil:
    section.add "org", valid_754558
  result.add "path", section
  ## parameters in `query` object:
  ##   type: JString
  section = newJObject()
  var valid_754559 = query.getOrDefault("type")
  valid_754559 = validateParameter(valid_754559, JString, required = false,
                                 default = newJString("all"))
  if valid_754559 != nil:
    section.add "type", valid_754559
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754560 = header.getOrDefault("Accept")
  valid_754560 = validateParameter(valid_754560, JString, required = false,
                                 default = nil)
  if valid_754560 != nil:
    section.add "Accept", valid_754560
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754561: Call_GetOrgsOrgRepos_754555; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List repositories for the specified org.
  ## 
  let valid = call_754561.validator(path, query, header, formData, body, _)
  let scheme = call_754561.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754561.makeUrl(scheme.get, call_754561.host, call_754561.base,
                             call_754561.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754561, uri, valid, _)

proc call*(call_754562: Call_GetOrgsOrgRepos_754555; org: string;
          `type`: string = "all"; Accept: string = ""): Recallable =
  ## getOrgsOrgRepos
  ## List repositories for the specified org.
  ##   type: string
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_754563 = newJObject()
  var query_754564 = newJObject()
  var header_754565 = newJObject()
  add(query_754564, "type", newJString(`type`))
  add(header_754565, "Accept", newJString(Accept))
  add(path_754563, "org", newJString(org))
  result = call_754562.call(path_754563, query_754564, header_754565, nil, nil)

var getOrgsOrgRepos* = Call_GetOrgsOrgRepos_754555(name: "getOrgsOrgRepos",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/repos",
    validator: validate_GetOrgsOrgRepos_754556, base: "/",
    makeUrl: url_GetOrgsOrgRepos_754557, schemes: {Scheme.Https})
type
  Call_PostOrgsOrgTeams_754586 = ref object of OpenApiRestCall_753573
proc url_PostOrgsOrgTeams_754588(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/teams")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostOrgsOrgTeams_754587(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode =
  ## Create team.
  ## In order to create a team, the authenticated user must be an owner of organization.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_754589 = path.getOrDefault("org")
  valid_754589 = validateParameter(valid_754589, JString, required = true,
                                 default = nil)
  if valid_754589 != nil:
    section.add "org", valid_754589
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754590 = header.getOrDefault("Accept")
  valid_754590 = validateParameter(valid_754590, JString, required = false,
                                 default = nil)
  if valid_754590 != nil:
    section.add "Accept", valid_754590
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_754592: Call_PostOrgsOrgTeams_754586; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Create team.
  ## In order to create a team, the authenticated user must be an owner of organization.
  ## 
  ## 
  let valid = call_754592.validator(path, query, header, formData, body, _)
  let scheme = call_754592.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754592.makeUrl(scheme.get, call_754592.host, call_754592.base,
                             call_754592.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754592, uri, valid, _)

proc call*(call_754593: Call_PostOrgsOrgTeams_754586; org: string; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postOrgsOrgTeams
  ## Create team.
  ## In order to create a team, the authenticated user must be an owner of organization.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  ##   body: JObject (required)
  var path_754594 = newJObject()
  var header_754595 = newJObject()
  var body_754596 = newJObject()
  add(header_754595, "Accept", newJString(Accept))
  add(path_754594, "org", newJString(org))
  if body != nil:
    body_754596 = body
  result = call_754593.call(path_754594, nil, header_754595, nil, body_754596)

var postOrgsOrgTeams* = Call_PostOrgsOrgTeams_754586(name: "postOrgsOrgTeams",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/orgs/{org}/teams",
    validator: validate_PostOrgsOrgTeams_754587, base: "/",
    makeUrl: url_PostOrgsOrgTeams_754588, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgTeams_754577 = ref object of OpenApiRestCall_753573
proc url_GetOrgsOrgTeams_754579(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/teams")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgTeams_754578(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode; _: string = ""): JsonNode =
  ## List teams.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_754580 = path.getOrDefault("org")
  valid_754580 = validateParameter(valid_754580, JString, required = true,
                                 default = nil)
  if valid_754580 != nil:
    section.add "org", valid_754580
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754581 = header.getOrDefault("Accept")
  valid_754581 = validateParameter(valid_754581, JString, required = false,
                                 default = nil)
  if valid_754581 != nil:
    section.add "Accept", valid_754581
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754582: Call_GetOrgsOrgTeams_754577; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List teams.
  ## 
  let valid = call_754582.validator(path, query, header, formData, body, _)
  let scheme = call_754582.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754582.makeUrl(scheme.get, call_754582.host, call_754582.base,
                             call_754582.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754582, uri, valid, _)

proc call*(call_754583: Call_GetOrgsOrgTeams_754577; org: string; Accept: string = ""): Recallable =
  ## getOrgsOrgTeams
  ## List teams.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_754584 = newJObject()
  var header_754585 = newJObject()
  add(header_754585, "Accept", newJString(Accept))
  add(path_754584, "org", newJString(org))
  result = call_754583.call(path_754584, nil, header_754585, nil, nil)

var getOrgsOrgTeams* = Call_GetOrgsOrgTeams_754577(name: "getOrgsOrgTeams",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/teams",
    validator: validate_GetOrgsOrgTeams_754578, base: "/",
    makeUrl: url_GetOrgsOrgTeams_754579, schemes: {Scheme.Https})
type
  Call_GetRateLimit_754597 = ref object of OpenApiRestCall_753573
proc url_GetRateLimit_754599(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRateLimit_754598(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Get your current rate limit status
  ## Note: Accessing this endpoint does not count against your rate limit.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754600 = header.getOrDefault("Accept")
  valid_754600 = validateParameter(valid_754600, JString, required = false,
                                 default = nil)
  if valid_754600 != nil:
    section.add "Accept", valid_754600
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754601: Call_GetRateLimit_754597; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get your current rate limit status
  ## Note: Accessing this endpoint does not count against your rate limit.
  ## 
  ## 
  let valid = call_754601.validator(path, query, header, formData, body, _)
  let scheme = call_754601.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754601.makeUrl(scheme.get, call_754601.host, call_754601.base,
                             call_754601.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754601, uri, valid, _)

proc call*(call_754602: Call_GetRateLimit_754597; Accept: string = ""): Recallable =
  ## getRateLimit
  ## Get your current rate limit status
  ## Note: Accessing this endpoint does not count against your rate limit.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_754603 = newJObject()
  add(header_754603, "Accept", newJString(Accept))
  result = call_754602.call(nil, nil, header_754603, nil, nil)

var getRateLimit* = Call_GetRateLimit_754597(name: "getRateLimit",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/rate_limit",
    validator: validate_GetRateLimit_754598, base: "/", makeUrl: url_GetRateLimit_754599,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepo_754604 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepo_754606(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepo_754605(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode =
  ## Get repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_754607 = path.getOrDefault("repo")
  valid_754607 = validateParameter(valid_754607, JString, required = true,
                                 default = nil)
  if valid_754607 != nil:
    section.add "repo", valid_754607
  var valid_754608 = path.getOrDefault("owner")
  valid_754608 = validateParameter(valid_754608, JString, required = true,
                                 default = nil)
  if valid_754608 != nil:
    section.add "owner", valid_754608
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754609 = header.getOrDefault("Accept")
  valid_754609 = validateParameter(valid_754609, JString, required = false,
                                 default = nil)
  if valid_754609 != nil:
    section.add "Accept", valid_754609
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754610: Call_GetReposOwnerRepo_754604; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get repository.
  ## 
  let valid = call_754610.validator(path, query, header, formData, body, _)
  let scheme = call_754610.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754610.makeUrl(scheme.get, call_754610.host, call_754610.base,
                             call_754610.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754610, uri, valid, _)

proc call*(call_754611: Call_GetReposOwnerRepo_754604; repo: string; owner: string;
          Accept: string = ""): Recallable =
  ## getReposOwnerRepo
  ## Get repository.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754612 = newJObject()
  var header_754613 = newJObject()
  add(header_754613, "Accept", newJString(Accept))
  add(path_754612, "repo", newJString(repo))
  add(path_754612, "owner", newJString(owner))
  result = call_754611.call(path_754612, nil, header_754613, nil, nil)

var getReposOwnerRepo* = Call_GetReposOwnerRepo_754604(name: "getReposOwnerRepo",
    meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/repos/{owner}/{repo}", validator: validate_GetReposOwnerRepo_754605,
    base: "/", makeUrl: url_GetReposOwnerRepo_754606, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepo_754624 = ref object of OpenApiRestCall_753573
proc url_PatchReposOwnerRepo_754626(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepo_754625(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode; _: string = ""): JsonNode =
  ## Edit repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_754627 = path.getOrDefault("repo")
  valid_754627 = validateParameter(valid_754627, JString, required = true,
                                 default = nil)
  if valid_754627 != nil:
    section.add "repo", valid_754627
  var valid_754628 = path.getOrDefault("owner")
  valid_754628 = validateParameter(valid_754628, JString, required = true,
                                 default = nil)
  if valid_754628 != nil:
    section.add "owner", valid_754628
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754629 = header.getOrDefault("Accept")
  valid_754629 = validateParameter(valid_754629, JString, required = false,
                                 default = nil)
  if valid_754629 != nil:
    section.add "Accept", valid_754629
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_754631: Call_PatchReposOwnerRepo_754624; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit repository.
  ## 
  let valid = call_754631.validator(path, query, header, formData, body, _)
  let scheme = call_754631.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754631.makeUrl(scheme.get, call_754631.host, call_754631.base,
                             call_754631.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754631, uri, valid, _)

proc call*(call_754632: Call_PatchReposOwnerRepo_754624; repo: string;
          body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepo
  ## Edit repository.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754633 = newJObject()
  var header_754634 = newJObject()
  var body_754635 = newJObject()
  add(header_754634, "Accept", newJString(Accept))
  add(path_754633, "repo", newJString(repo))
  if body != nil:
    body_754635 = body
  add(path_754633, "owner", newJString(owner))
  result = call_754632.call(path_754633, nil, header_754634, nil, body_754635)

var patchReposOwnerRepo* = Call_PatchReposOwnerRepo_754624(
    name: "patchReposOwnerRepo", meth: HttpMethod.HttpPatch, host: "api.github.com",
    route: "/repos/{owner}/{repo}", validator: validate_PatchReposOwnerRepo_754625,
    base: "/", makeUrl: url_PatchReposOwnerRepo_754626, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepo_754614 = ref object of OpenApiRestCall_753573
proc url_DeleteReposOwnerRepo_754616(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepo_754615(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Delete a Repository.
  ## Deleting a repository requires admin access. If OAuth is used, the delete_repo
  ## scope is required.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_754617 = path.getOrDefault("repo")
  valid_754617 = validateParameter(valid_754617, JString, required = true,
                                 default = nil)
  if valid_754617 != nil:
    section.add "repo", valid_754617
  var valid_754618 = path.getOrDefault("owner")
  valid_754618 = validateParameter(valid_754618, JString, required = true,
                                 default = nil)
  if valid_754618 != nil:
    section.add "owner", valid_754618
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754619 = header.getOrDefault("Accept")
  valid_754619 = validateParameter(valid_754619, JString, required = false,
                                 default = nil)
  if valid_754619 != nil:
    section.add "Accept", valid_754619
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754620: Call_DeleteReposOwnerRepo_754614; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a Repository.
  ## Deleting a repository requires admin access. If OAuth is used, the delete_repo
  ## scope is required.
  ## 
  ## 
  let valid = call_754620.validator(path, query, header, formData, body, _)
  let scheme = call_754620.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754620.makeUrl(scheme.get, call_754620.host, call_754620.base,
                             call_754620.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754620, uri, valid, _)

proc call*(call_754621: Call_DeleteReposOwnerRepo_754614; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepo
  ## Delete a Repository.
  ## Deleting a repository requires admin access. If OAuth is used, the delete_repo
  ## scope is required.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754622 = newJObject()
  var header_754623 = newJObject()
  add(header_754623, "Accept", newJString(Accept))
  add(path_754622, "repo", newJString(repo))
  add(path_754622, "owner", newJString(owner))
  result = call_754621.call(path_754622, nil, header_754623, nil, nil)

var deleteReposOwnerRepo* = Call_DeleteReposOwnerRepo_754614(
    name: "deleteReposOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}",
    validator: validate_DeleteReposOwnerRepo_754615, base: "/",
    makeUrl: url_DeleteReposOwnerRepo_754616, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoAssignees_754636 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoAssignees_754638(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/assignees")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoAssignees_754637(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List assignees.
  ## This call lists all the available assignees (owner + collaborators) to which
  ## issues may be assigned.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_754639 = path.getOrDefault("repo")
  valid_754639 = validateParameter(valid_754639, JString, required = true,
                                 default = nil)
  if valid_754639 != nil:
    section.add "repo", valid_754639
  var valid_754640 = path.getOrDefault("owner")
  valid_754640 = validateParameter(valid_754640, JString, required = true,
                                 default = nil)
  if valid_754640 != nil:
    section.add "owner", valid_754640
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754641 = header.getOrDefault("Accept")
  valid_754641 = validateParameter(valid_754641, JString, required = false,
                                 default = nil)
  if valid_754641 != nil:
    section.add "Accept", valid_754641
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754642: Call_GetReposOwnerRepoAssignees_754636;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List assignees.
  ## This call lists all the available assignees (owner + collaborators) to which
  ## issues may be assigned.
  ## 
  ## 
  let valid = call_754642.validator(path, query, header, formData, body, _)
  let scheme = call_754642.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754642.makeUrl(scheme.get, call_754642.host, call_754642.base,
                             call_754642.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754642, uri, valid, _)

proc call*(call_754643: Call_GetReposOwnerRepoAssignees_754636; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoAssignees
  ## List assignees.
  ## This call lists all the available assignees (owner + collaborators) to which
  ## issues may be assigned.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754644 = newJObject()
  var header_754645 = newJObject()
  add(header_754645, "Accept", newJString(Accept))
  add(path_754644, "repo", newJString(repo))
  add(path_754644, "owner", newJString(owner))
  result = call_754643.call(path_754644, nil, header_754645, nil, nil)

var getReposOwnerRepoAssignees* = Call_GetReposOwnerRepoAssignees_754636(
    name: "getReposOwnerRepoAssignees", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/assignees",
    validator: validate_GetReposOwnerRepoAssignees_754637, base: "/",
    makeUrl: url_GetReposOwnerRepoAssignees_754638, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoAssigneesAssignee_754646 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoAssigneesAssignee_754648(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "assignee" in path, "`assignee` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/assignees/"),
               (kind: VariableSegment, value: "assignee")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoAssigneesAssignee_754647(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Check assignee.
  ## You may also check to see if a particular user is an assignee for a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   assignee: JString (required)
  ##           : Login of the assignee.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `assignee` field"
  var valid_754649 = path.getOrDefault("assignee")
  valid_754649 = validateParameter(valid_754649, JString, required = true,
                                 default = nil)
  if valid_754649 != nil:
    section.add "assignee", valid_754649
  var valid_754650 = path.getOrDefault("repo")
  valid_754650 = validateParameter(valid_754650, JString, required = true,
                                 default = nil)
  if valid_754650 != nil:
    section.add "repo", valid_754650
  var valid_754651 = path.getOrDefault("owner")
  valid_754651 = validateParameter(valid_754651, JString, required = true,
                                 default = nil)
  if valid_754651 != nil:
    section.add "owner", valid_754651
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754652 = header.getOrDefault("Accept")
  valid_754652 = validateParameter(valid_754652, JString, required = false,
                                 default = nil)
  if valid_754652 != nil:
    section.add "Accept", valid_754652
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754653: Call_GetReposOwnerRepoAssigneesAssignee_754646;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check assignee.
  ## You may also check to see if a particular user is an assignee for a repository.
  ## 
  ## 
  let valid = call_754653.validator(path, query, header, formData, body, _)
  let scheme = call_754653.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754653.makeUrl(scheme.get, call_754653.host, call_754653.base,
                             call_754653.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754653, uri, valid, _)

proc call*(call_754654: Call_GetReposOwnerRepoAssigneesAssignee_754646;
          assignee: string; repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoAssigneesAssignee
  ## Check assignee.
  ## You may also check to see if a particular user is an assignee for a repository.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   assignee: string (required)
  ##           : Login of the assignee.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754655 = newJObject()
  var header_754656 = newJObject()
  add(header_754656, "Accept", newJString(Accept))
  add(path_754655, "assignee", newJString(assignee))
  add(path_754655, "repo", newJString(repo))
  add(path_754655, "owner", newJString(owner))
  result = call_754654.call(path_754655, nil, header_754656, nil, nil)

var getReposOwnerRepoAssigneesAssignee* = Call_GetReposOwnerRepoAssigneesAssignee_754646(
    name: "getReposOwnerRepoAssigneesAssignee", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/assignees/{assignee}",
    validator: validate_GetReposOwnerRepoAssigneesAssignee_754647, base: "/",
    makeUrl: url_GetReposOwnerRepoAssigneesAssignee_754648,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoBranches_754657 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoBranches_754659(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/branches")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoBranches_754658(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Get list of branches
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_754660 = path.getOrDefault("repo")
  valid_754660 = validateParameter(valid_754660, JString, required = true,
                                 default = nil)
  if valid_754660 != nil:
    section.add "repo", valid_754660
  var valid_754661 = path.getOrDefault("owner")
  valid_754661 = validateParameter(valid_754661, JString, required = true,
                                 default = nil)
  if valid_754661 != nil:
    section.add "owner", valid_754661
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754662 = header.getOrDefault("Accept")
  valid_754662 = validateParameter(valid_754662, JString, required = false,
                                 default = nil)
  if valid_754662 != nil:
    section.add "Accept", valid_754662
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754663: Call_GetReposOwnerRepoBranches_754657;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get list of branches
  ## 
  let valid = call_754663.validator(path, query, header, formData, body, _)
  let scheme = call_754663.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754663.makeUrl(scheme.get, call_754663.host, call_754663.base,
                             call_754663.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754663, uri, valid, _)

proc call*(call_754664: Call_GetReposOwnerRepoBranches_754657; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoBranches
  ## Get list of branches
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754665 = newJObject()
  var header_754666 = newJObject()
  add(header_754666, "Accept", newJString(Accept))
  add(path_754665, "repo", newJString(repo))
  add(path_754665, "owner", newJString(owner))
  result = call_754664.call(path_754665, nil, header_754666, nil, nil)

var getReposOwnerRepoBranches* = Call_GetReposOwnerRepoBranches_754657(
    name: "getReposOwnerRepoBranches", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/branches",
    validator: validate_GetReposOwnerRepoBranches_754658, base: "/",
    makeUrl: url_GetReposOwnerRepoBranches_754659, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoBranchesBranch_754667 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoBranchesBranch_754669(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "branch" in path, "`branch` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/branches/"),
               (kind: VariableSegment, value: "branch")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoBranchesBranch_754668(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Get Branch
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   branch: JString (required)
  ##         : Name of the branch.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `branch` field"
  var valid_754670 = path.getOrDefault("branch")
  valid_754670 = validateParameter(valid_754670, JString, required = true,
                                 default = nil)
  if valid_754670 != nil:
    section.add "branch", valid_754670
  var valid_754671 = path.getOrDefault("repo")
  valid_754671 = validateParameter(valid_754671, JString, required = true,
                                 default = nil)
  if valid_754671 != nil:
    section.add "repo", valid_754671
  var valid_754672 = path.getOrDefault("owner")
  valid_754672 = validateParameter(valid_754672, JString, required = true,
                                 default = nil)
  if valid_754672 != nil:
    section.add "owner", valid_754672
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754673 = header.getOrDefault("Accept")
  valid_754673 = validateParameter(valid_754673, JString, required = false,
                                 default = nil)
  if valid_754673 != nil:
    section.add "Accept", valid_754673
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754674: Call_GetReposOwnerRepoBranchesBranch_754667;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get Branch
  ## 
  let valid = call_754674.validator(path, query, header, formData, body, _)
  let scheme = call_754674.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754674.makeUrl(scheme.get, call_754674.host, call_754674.base,
                             call_754674.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754674, uri, valid, _)

proc call*(call_754675: Call_GetReposOwnerRepoBranchesBranch_754667;
          branch: string; repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoBranchesBranch
  ## Get Branch
  ##   branch: string (required)
  ##         : Name of the branch.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754676 = newJObject()
  var header_754677 = newJObject()
  add(path_754676, "branch", newJString(branch))
  add(header_754677, "Accept", newJString(Accept))
  add(path_754676, "repo", newJString(repo))
  add(path_754676, "owner", newJString(owner))
  result = call_754675.call(path_754676, nil, header_754677, nil, nil)

var getReposOwnerRepoBranchesBranch* = Call_GetReposOwnerRepoBranchesBranch_754667(
    name: "getReposOwnerRepoBranchesBranch", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/branches/{branch}",
    validator: validate_GetReposOwnerRepoBranchesBranch_754668, base: "/",
    makeUrl: url_GetReposOwnerRepoBranchesBranch_754669, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCollaborators_754678 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoCollaborators_754680(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/collaborators")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCollaborators_754679(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## List.
  ## When authenticating as an organization owner of an organization-owned
  ## repository, all organization owners are included in the list of
  ## collaborators. Otherwise, only users with access to the repository are
  ## returned in the collaborators list.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_754681 = path.getOrDefault("repo")
  valid_754681 = validateParameter(valid_754681, JString, required = true,
                                 default = nil)
  if valid_754681 != nil:
    section.add "repo", valid_754681
  var valid_754682 = path.getOrDefault("owner")
  valid_754682 = validateParameter(valid_754682, JString, required = true,
                                 default = nil)
  if valid_754682 != nil:
    section.add "owner", valid_754682
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754683 = header.getOrDefault("Accept")
  valid_754683 = validateParameter(valid_754683, JString, required = false,
                                 default = nil)
  if valid_754683 != nil:
    section.add "Accept", valid_754683
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754684: Call_GetReposOwnerRepoCollaborators_754678;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List.
  ## When authenticating as an organization owner of an organization-owned
  ## repository, all organization owners are included in the list of
  ## collaborators. Otherwise, only users with access to the repository are
  ## returned in the collaborators list.
  ## 
  ## 
  let valid = call_754684.validator(path, query, header, formData, body, _)
  let scheme = call_754684.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754684.makeUrl(scheme.get, call_754684.host, call_754684.base,
                             call_754684.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754684, uri, valid, _)

proc call*(call_754685: Call_GetReposOwnerRepoCollaborators_754678; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCollaborators
  ## List.
  ## When authenticating as an organization owner of an organization-owned
  ## repository, all organization owners are included in the list of
  ## collaborators. Otherwise, only users with access to the repository are
  ## returned in the collaborators list.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754686 = newJObject()
  var header_754687 = newJObject()
  add(header_754687, "Accept", newJString(Accept))
  add(path_754686, "repo", newJString(repo))
  add(path_754686, "owner", newJString(owner))
  result = call_754685.call(path_754686, nil, header_754687, nil, nil)

var getReposOwnerRepoCollaborators* = Call_GetReposOwnerRepoCollaborators_754678(
    name: "getReposOwnerRepoCollaborators", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators",
    validator: validate_GetReposOwnerRepoCollaborators_754679, base: "/",
    makeUrl: url_GetReposOwnerRepoCollaborators_754680, schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoCollaboratorsUser_754699 = ref object of OpenApiRestCall_753573
proc url_PutReposOwnerRepoCollaboratorsUser_754701(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "user" in path, "`user` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/collaborators/"),
               (kind: VariableSegment, value: "user")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoCollaboratorsUser_754700(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Add collaborator.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   user: JString (required)
  ##       : Login of the user.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `user` field"
  var valid_754702 = path.getOrDefault("user")
  valid_754702 = validateParameter(valid_754702, JString, required = true,
                                 default = nil)
  if valid_754702 != nil:
    section.add "user", valid_754702
  var valid_754703 = path.getOrDefault("repo")
  valid_754703 = validateParameter(valid_754703, JString, required = true,
                                 default = nil)
  if valid_754703 != nil:
    section.add "repo", valid_754703
  var valid_754704 = path.getOrDefault("owner")
  valid_754704 = validateParameter(valid_754704, JString, required = true,
                                 default = nil)
  if valid_754704 != nil:
    section.add "owner", valid_754704
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754705 = header.getOrDefault("Accept")
  valid_754705 = validateParameter(valid_754705, JString, required = false,
                                 default = nil)
  if valid_754705 != nil:
    section.add "Accept", valid_754705
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754706: Call_PutReposOwnerRepoCollaboratorsUser_754699;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Add collaborator.
  ## 
  let valid = call_754706.validator(path, query, header, formData, body, _)
  let scheme = call_754706.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754706.makeUrl(scheme.get, call_754706.host, call_754706.base,
                             call_754706.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754706, uri, valid, _)

proc call*(call_754707: Call_PutReposOwnerRepoCollaboratorsUser_754699;
          user: string; repo: string; owner: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoCollaboratorsUser
  ## Add collaborator.
  ##   user: string (required)
  ##       : Login of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754708 = newJObject()
  var header_754709 = newJObject()
  add(path_754708, "user", newJString(user))
  add(header_754709, "Accept", newJString(Accept))
  add(path_754708, "repo", newJString(repo))
  add(path_754708, "owner", newJString(owner))
  result = call_754707.call(path_754708, nil, header_754709, nil, nil)

var putReposOwnerRepoCollaboratorsUser* = Call_PutReposOwnerRepoCollaboratorsUser_754699(
    name: "putReposOwnerRepoCollaboratorsUser", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators/{user}",
    validator: validate_PutReposOwnerRepoCollaboratorsUser_754700, base: "/",
    makeUrl: url_PutReposOwnerRepoCollaboratorsUser_754701,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCollaboratorsUser_754688 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoCollaboratorsUser_754690(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "user" in path, "`user` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/collaborators/"),
               (kind: VariableSegment, value: "user")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCollaboratorsUser_754689(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Check if user is a collaborator
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   user: JString (required)
  ##       : Login of the user.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `user` field"
  var valid_754691 = path.getOrDefault("user")
  valid_754691 = validateParameter(valid_754691, JString, required = true,
                                 default = nil)
  if valid_754691 != nil:
    section.add "user", valid_754691
  var valid_754692 = path.getOrDefault("repo")
  valid_754692 = validateParameter(valid_754692, JString, required = true,
                                 default = nil)
  if valid_754692 != nil:
    section.add "repo", valid_754692
  var valid_754693 = path.getOrDefault("owner")
  valid_754693 = validateParameter(valid_754693, JString, required = true,
                                 default = nil)
  if valid_754693 != nil:
    section.add "owner", valid_754693
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754694 = header.getOrDefault("Accept")
  valid_754694 = validateParameter(valid_754694, JString, required = false,
                                 default = nil)
  if valid_754694 != nil:
    section.add "Accept", valid_754694
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754695: Call_GetReposOwnerRepoCollaboratorsUser_754688;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if user is a collaborator
  ## 
  let valid = call_754695.validator(path, query, header, formData, body, _)
  let scheme = call_754695.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754695.makeUrl(scheme.get, call_754695.host, call_754695.base,
                             call_754695.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754695, uri, valid, _)

proc call*(call_754696: Call_GetReposOwnerRepoCollaboratorsUser_754688;
          user: string; repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCollaboratorsUser
  ## Check if user is a collaborator
  ##   user: string (required)
  ##       : Login of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754697 = newJObject()
  var header_754698 = newJObject()
  add(path_754697, "user", newJString(user))
  add(header_754698, "Accept", newJString(Accept))
  add(path_754697, "repo", newJString(repo))
  add(path_754697, "owner", newJString(owner))
  result = call_754696.call(path_754697, nil, header_754698, nil, nil)

var getReposOwnerRepoCollaboratorsUser* = Call_GetReposOwnerRepoCollaboratorsUser_754688(
    name: "getReposOwnerRepoCollaboratorsUser", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators/{user}",
    validator: validate_GetReposOwnerRepoCollaboratorsUser_754689, base: "/",
    makeUrl: url_GetReposOwnerRepoCollaboratorsUser_754690,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoCollaboratorsUser_754710 = ref object of OpenApiRestCall_753573
proc url_DeleteReposOwnerRepoCollaboratorsUser_754712(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "user" in path, "`user` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/collaborators/"),
               (kind: VariableSegment, value: "user")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoCollaboratorsUser_754711(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Remove collaborator.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   user: JString (required)
  ##       : Login of the user.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `user` field"
  var valid_754713 = path.getOrDefault("user")
  valid_754713 = validateParameter(valid_754713, JString, required = true,
                                 default = nil)
  if valid_754713 != nil:
    section.add "user", valid_754713
  var valid_754714 = path.getOrDefault("repo")
  valid_754714 = validateParameter(valid_754714, JString, required = true,
                                 default = nil)
  if valid_754714 != nil:
    section.add "repo", valid_754714
  var valid_754715 = path.getOrDefault("owner")
  valid_754715 = validateParameter(valid_754715, JString, required = true,
                                 default = nil)
  if valid_754715 != nil:
    section.add "owner", valid_754715
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754716 = header.getOrDefault("Accept")
  valid_754716 = validateParameter(valid_754716, JString, required = false,
                                 default = nil)
  if valid_754716 != nil:
    section.add "Accept", valid_754716
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754717: Call_DeleteReposOwnerRepoCollaboratorsUser_754710;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Remove collaborator.
  ## 
  let valid = call_754717.validator(path, query, header, formData, body, _)
  let scheme = call_754717.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754717.makeUrl(scheme.get, call_754717.host, call_754717.base,
                             call_754717.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754717, uri, valid, _)

proc call*(call_754718: Call_DeleteReposOwnerRepoCollaboratorsUser_754710;
          user: string; repo: string; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoCollaboratorsUser
  ## Remove collaborator.
  ##   user: string (required)
  ##       : Login of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754719 = newJObject()
  var header_754720 = newJObject()
  add(path_754719, "user", newJString(user))
  add(header_754720, "Accept", newJString(Accept))
  add(path_754719, "repo", newJString(repo))
  add(path_754719, "owner", newJString(owner))
  result = call_754718.call(path_754719, nil, header_754720, nil, nil)

var deleteReposOwnerRepoCollaboratorsUser* = Call_DeleteReposOwnerRepoCollaboratorsUser_754710(
    name: "deleteReposOwnerRepoCollaboratorsUser", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators/{user}",
    validator: validate_DeleteReposOwnerRepoCollaboratorsUser_754711, base: "/",
    makeUrl: url_DeleteReposOwnerRepoCollaboratorsUser_754712,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoComments_754721 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoComments_754723(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoComments_754722(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List commit comments for a repository.
  ## Comments are ordered by ascending ID.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_754724 = path.getOrDefault("repo")
  valid_754724 = validateParameter(valid_754724, JString, required = true,
                                 default = nil)
  if valid_754724 != nil:
    section.add "repo", valid_754724
  var valid_754725 = path.getOrDefault("owner")
  valid_754725 = validateParameter(valid_754725, JString, required = true,
                                 default = nil)
  if valid_754725 != nil:
    section.add "owner", valid_754725
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754726 = header.getOrDefault("Accept")
  valid_754726 = validateParameter(valid_754726, JString, required = false,
                                 default = nil)
  if valid_754726 != nil:
    section.add "Accept", valid_754726
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754727: Call_GetReposOwnerRepoComments_754721;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List commit comments for a repository.
  ## Comments are ordered by ascending ID.
  ## 
  ## 
  let valid = call_754727.validator(path, query, header, formData, body, _)
  let scheme = call_754727.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754727.makeUrl(scheme.get, call_754727.host, call_754727.base,
                             call_754727.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754727, uri, valid, _)

proc call*(call_754728: Call_GetReposOwnerRepoComments_754721; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoComments
  ## List commit comments for a repository.
  ## Comments are ordered by ascending ID.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754729 = newJObject()
  var header_754730 = newJObject()
  add(header_754730, "Accept", newJString(Accept))
  add(path_754729, "repo", newJString(repo))
  add(path_754729, "owner", newJString(owner))
  result = call_754728.call(path_754729, nil, header_754730, nil, nil)

var getReposOwnerRepoComments* = Call_GetReposOwnerRepoComments_754721(
    name: "getReposOwnerRepoComments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments",
    validator: validate_GetReposOwnerRepoComments_754722, base: "/",
    makeUrl: url_GetReposOwnerRepoComments_754723, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommentsCommentId_754731 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoCommentsCommentId_754733(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommentsCommentId_754732(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Get a single commit comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   commentId: JInt (required)
  ##            : Id of comment.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `commentId` field"
  var valid_754734 = path.getOrDefault("commentId")
  valid_754734 = validateParameter(valid_754734, JInt, required = true, default = nil)
  if valid_754734 != nil:
    section.add "commentId", valid_754734
  var valid_754735 = path.getOrDefault("repo")
  valid_754735 = validateParameter(valid_754735, JString, required = true,
                                 default = nil)
  if valid_754735 != nil:
    section.add "repo", valid_754735
  var valid_754736 = path.getOrDefault("owner")
  valid_754736 = validateParameter(valid_754736, JString, required = true,
                                 default = nil)
  if valid_754736 != nil:
    section.add "owner", valid_754736
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754737 = header.getOrDefault("Accept")
  valid_754737 = validateParameter(valid_754737, JString, required = false,
                                 default = nil)
  if valid_754737 != nil:
    section.add "Accept", valid_754737
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754738: Call_GetReposOwnerRepoCommentsCommentId_754731;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single commit comment.
  ## 
  let valid = call_754738.validator(path, query, header, formData, body, _)
  let scheme = call_754738.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754738.makeUrl(scheme.get, call_754738.host, call_754738.base,
                             call_754738.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754738, uri, valid, _)

proc call*(call_754739: Call_GetReposOwnerRepoCommentsCommentId_754731;
          commentId: int; repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommentsCommentId
  ## Get a single commit comment.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   commentId: int (required)
  ##            : Id of comment.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754740 = newJObject()
  var header_754741 = newJObject()
  add(header_754741, "Accept", newJString(Accept))
  add(path_754740, "commentId", newJInt(commentId))
  add(path_754740, "repo", newJString(repo))
  add(path_754740, "owner", newJString(owner))
  result = call_754739.call(path_754740, nil, header_754741, nil, nil)

var getReposOwnerRepoCommentsCommentId* = Call_GetReposOwnerRepoCommentsCommentId_754731(
    name: "getReposOwnerRepoCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments/{commentId}",
    validator: validate_GetReposOwnerRepoCommentsCommentId_754732, base: "/",
    makeUrl: url_GetReposOwnerRepoCommentsCommentId_754733,
    schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoCommentsCommentId_754753 = ref object of OpenApiRestCall_753573
proc url_PatchReposOwnerRepoCommentsCommentId_754755(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoCommentsCommentId_754754(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Update a commit comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   commentId: JInt (required)
  ##            : Id of comment.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `commentId` field"
  var valid_754756 = path.getOrDefault("commentId")
  valid_754756 = validateParameter(valid_754756, JInt, required = true, default = nil)
  if valid_754756 != nil:
    section.add "commentId", valid_754756
  var valid_754757 = path.getOrDefault("repo")
  valid_754757 = validateParameter(valid_754757, JString, required = true,
                                 default = nil)
  if valid_754757 != nil:
    section.add "repo", valid_754757
  var valid_754758 = path.getOrDefault("owner")
  valid_754758 = validateParameter(valid_754758, JString, required = true,
                                 default = nil)
  if valid_754758 != nil:
    section.add "owner", valid_754758
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754759 = header.getOrDefault("Accept")
  valid_754759 = validateParameter(valid_754759, JString, required = false,
                                 default = nil)
  if valid_754759 != nil:
    section.add "Accept", valid_754759
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_754761: Call_PatchReposOwnerRepoCommentsCommentId_754753;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Update a commit comment.
  ## 
  let valid = call_754761.validator(path, query, header, formData, body, _)
  let scheme = call_754761.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754761.makeUrl(scheme.get, call_754761.host, call_754761.base,
                             call_754761.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754761, uri, valid, _)

proc call*(call_754762: Call_PatchReposOwnerRepoCommentsCommentId_754753;
          commentId: int; repo: string; body: JsonNode; owner: string;
          Accept: string = ""): Recallable =
  ## patchReposOwnerRepoCommentsCommentId
  ## Update a commit comment.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   commentId: int (required)
  ##            : Id of comment.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754763 = newJObject()
  var header_754764 = newJObject()
  var body_754765 = newJObject()
  add(header_754764, "Accept", newJString(Accept))
  add(path_754763, "commentId", newJInt(commentId))
  add(path_754763, "repo", newJString(repo))
  if body != nil:
    body_754765 = body
  add(path_754763, "owner", newJString(owner))
  result = call_754762.call(path_754763, nil, header_754764, nil, body_754765)

var patchReposOwnerRepoCommentsCommentId* = Call_PatchReposOwnerRepoCommentsCommentId_754753(
    name: "patchReposOwnerRepoCommentsCommentId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments/{commentId}",
    validator: validate_PatchReposOwnerRepoCommentsCommentId_754754, base: "/",
    makeUrl: url_PatchReposOwnerRepoCommentsCommentId_754755,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoCommentsCommentId_754742 = ref object of OpenApiRestCall_753573
proc url_DeleteReposOwnerRepoCommentsCommentId_754744(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoCommentsCommentId_754743(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Delete a commit comment
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   commentId: JInt (required)
  ##            : Id of comment.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `commentId` field"
  var valid_754745 = path.getOrDefault("commentId")
  valid_754745 = validateParameter(valid_754745, JInt, required = true, default = nil)
  if valid_754745 != nil:
    section.add "commentId", valid_754745
  var valid_754746 = path.getOrDefault("repo")
  valid_754746 = validateParameter(valid_754746, JString, required = true,
                                 default = nil)
  if valid_754746 != nil:
    section.add "repo", valid_754746
  var valid_754747 = path.getOrDefault("owner")
  valid_754747 = validateParameter(valid_754747, JString, required = true,
                                 default = nil)
  if valid_754747 != nil:
    section.add "owner", valid_754747
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754748 = header.getOrDefault("Accept")
  valid_754748 = validateParameter(valid_754748, JString, required = false,
                                 default = nil)
  if valid_754748 != nil:
    section.add "Accept", valid_754748
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754749: Call_DeleteReposOwnerRepoCommentsCommentId_754742;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a commit comment
  ## 
  let valid = call_754749.validator(path, query, header, formData, body, _)
  let scheme = call_754749.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754749.makeUrl(scheme.get, call_754749.host, call_754749.base,
                             call_754749.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754749, uri, valid, _)

proc call*(call_754750: Call_DeleteReposOwnerRepoCommentsCommentId_754742;
          commentId: int; repo: string; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoCommentsCommentId
  ## Delete a commit comment
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   commentId: int (required)
  ##            : Id of comment.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754751 = newJObject()
  var header_754752 = newJObject()
  add(header_754752, "Accept", newJString(Accept))
  add(path_754751, "commentId", newJInt(commentId))
  add(path_754751, "repo", newJString(repo))
  add(path_754751, "owner", newJString(owner))
  result = call_754750.call(path_754751, nil, header_754752, nil, nil)

var deleteReposOwnerRepoCommentsCommentId* = Call_DeleteReposOwnerRepoCommentsCommentId_754742(
    name: "deleteReposOwnerRepoCommentsCommentId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments/{commentId}",
    validator: validate_DeleteReposOwnerRepoCommentsCommentId_754743, base: "/",
    makeUrl: url_DeleteReposOwnerRepoCommentsCommentId_754744,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommits_754766 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoCommits_754768(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommits_754767(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List commits on a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_754769 = path.getOrDefault("repo")
  valid_754769 = validateParameter(valid_754769, JString, required = true,
                                 default = nil)
  if valid_754769 != nil:
    section.add "repo", valid_754769
  var valid_754770 = path.getOrDefault("owner")
  valid_754770 = validateParameter(valid_754770, JString, required = true,
                                 default = nil)
  if valid_754770 != nil:
    section.add "owner", valid_754770
  result.add "path", section
  ## parameters in `query` object:
  ##   author: JString
  ##         : GitHub login, name, or email by which to filter by commit author.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   until: JString
  ##        : ISO 8601 Date - Only commits before this date will be returned.
  ##   sha: JString
  ##      : Sha or branch to start listing commits from.
  ##   path: JString
  ##       : Only commits containing this file path will be returned.
  section = newJObject()
  var valid_754771 = query.getOrDefault("author")
  valid_754771 = validateParameter(valid_754771, JString, required = false,
                                 default = nil)
  if valid_754771 != nil:
    section.add "author", valid_754771
  var valid_754772 = query.getOrDefault("since")
  valid_754772 = validateParameter(valid_754772, JString, required = false,
                                 default = nil)
  if valid_754772 != nil:
    section.add "since", valid_754772
  var valid_754773 = query.getOrDefault("until")
  valid_754773 = validateParameter(valid_754773, JString, required = false,
                                 default = nil)
  if valid_754773 != nil:
    section.add "until", valid_754773
  var valid_754774 = query.getOrDefault("sha")
  valid_754774 = validateParameter(valid_754774, JString, required = false,
                                 default = nil)
  if valid_754774 != nil:
    section.add "sha", valid_754774
  var valid_754775 = query.getOrDefault("path")
  valid_754775 = validateParameter(valid_754775, JString, required = false,
                                 default = nil)
  if valid_754775 != nil:
    section.add "path", valid_754775
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754776 = header.getOrDefault("Accept")
  valid_754776 = validateParameter(valid_754776, JString, required = false,
                                 default = nil)
  if valid_754776 != nil:
    section.add "Accept", valid_754776
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754777: Call_GetReposOwnerRepoCommits_754766; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List commits on a repository.
  ## 
  let valid = call_754777.validator(path, query, header, formData, body, _)
  let scheme = call_754777.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754777.makeUrl(scheme.get, call_754777.host, call_754777.base,
                             call_754777.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754777, uri, valid, _)

proc call*(call_754778: Call_GetReposOwnerRepoCommits_754766; repo: string;
          owner: string; author: string = ""; since: string = ""; until: string = "";
          sha: string = ""; path: string = ""; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommits
  ## List commits on a repository.
  ##   author: string
  ##         : GitHub login, name, or email by which to filter by commit author.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   until: string
  ##        : ISO 8601 Date - Only commits before this date will be returned.
  ##   sha: string
  ##      : Sha or branch to start listing commits from.
  ##   path: string
  ##       : Only commits containing this file path will be returned.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754779 = newJObject()
  var query_754780 = newJObject()
  var header_754781 = newJObject()
  add(query_754780, "author", newJString(author))
  add(query_754780, "since", newJString(since))
  add(query_754780, "until", newJString(until))
  add(query_754780, "sha", newJString(sha))
  add(query_754780, "path", newJString(path))
  add(header_754781, "Accept", newJString(Accept))
  add(path_754779, "repo", newJString(repo))
  add(path_754779, "owner", newJString(owner))
  result = call_754778.call(path_754779, query_754780, header_754781, nil, nil)

var getReposOwnerRepoCommits* = Call_GetReposOwnerRepoCommits_754766(
    name: "getReposOwnerRepoCommits", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/commits",
    validator: validate_GetReposOwnerRepoCommits_754767, base: "/",
    makeUrl: url_GetReposOwnerRepoCommits_754768, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommitsRefStatus_754782 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoCommitsRefStatus_754784(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits/"),
               (kind: VariableSegment, value: "ref"),
               (kind: ConstantSegment, value: "/status")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommitsRefStatus_754783(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Get the combined Status for a specific Ref
  ## The Combined status endpoint is currently available for developers to preview. During the preview period, the API may change without advance notice. Please see the blog post for full details.
  ## To access this endpoint during the preview period, you must provide a custom media type in the Accept header:
  ## application/vnd.github.she-hulk-preview+json
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ref: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ref` field"
  var valid_754785 = path.getOrDefault("ref")
  valid_754785 = validateParameter(valid_754785, JString, required = true,
                                 default = nil)
  if valid_754785 != nil:
    section.add "ref", valid_754785
  var valid_754786 = path.getOrDefault("repo")
  valid_754786 = validateParameter(valid_754786, JString, required = true,
                                 default = nil)
  if valid_754786 != nil:
    section.add "repo", valid_754786
  var valid_754787 = path.getOrDefault("owner")
  valid_754787 = validateParameter(valid_754787, JString, required = true,
                                 default = nil)
  if valid_754787 != nil:
    section.add "owner", valid_754787
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754788 = header.getOrDefault("Accept")
  valid_754788 = validateParameter(valid_754788, JString, required = false,
                                 default = nil)
  if valid_754788 != nil:
    section.add "Accept", valid_754788
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754789: Call_GetReposOwnerRepoCommitsRefStatus_754782;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get the combined Status for a specific Ref
  ## The Combined status endpoint is currently available for developers to preview. During the preview period, the API may change without advance notice. Please see the blog post for full details.
  ## To access this endpoint during the preview period, you must provide a custom media type in the Accept header:
  ## application/vnd.github.she-hulk-preview+json
  ## 
  ## 
  let valid = call_754789.validator(path, query, header, formData, body, _)
  let scheme = call_754789.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754789.makeUrl(scheme.get, call_754789.host, call_754789.base,
                             call_754789.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754789, uri, valid, _)

proc call*(call_754790: Call_GetReposOwnerRepoCommitsRefStatus_754782;
          `ref`: string; repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommitsRefStatus
  ## Get the combined Status for a specific Ref
  ## The Combined status endpoint is currently available for developers to preview. During the preview period, the API may change without advance notice. Please see the blog post for full details.
  ## To access this endpoint during the preview period, you must provide a custom media type in the Accept header:
  ## application/vnd.github.she-hulk-preview+json
  ## 
  ##   ref: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754791 = newJObject()
  var header_754792 = newJObject()
  add(path_754791, "ref", newJString(`ref`))
  add(header_754792, "Accept", newJString(Accept))
  add(path_754791, "repo", newJString(repo))
  add(path_754791, "owner", newJString(owner))
  result = call_754790.call(path_754791, nil, header_754792, nil, nil)

var getReposOwnerRepoCommitsRefStatus* = Call_GetReposOwnerRepoCommitsRefStatus_754782(
    name: "getReposOwnerRepoCommitsRefStatus", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/commits/{ref}/status",
    validator: validate_GetReposOwnerRepoCommitsRefStatus_754783, base: "/",
    makeUrl: url_GetReposOwnerRepoCommitsRefStatus_754784, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommitsShaCode_754793 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoCommitsShaCode_754795(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommitsShaCode_754794(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Get a single commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   shaCode: JString (required)
  ##          : SHA-1 code of the commit.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `shaCode` field"
  var valid_754796 = path.getOrDefault("shaCode")
  valid_754796 = validateParameter(valid_754796, JString, required = true,
                                 default = nil)
  if valid_754796 != nil:
    section.add "shaCode", valid_754796
  var valid_754797 = path.getOrDefault("repo")
  valid_754797 = validateParameter(valid_754797, JString, required = true,
                                 default = nil)
  if valid_754797 != nil:
    section.add "repo", valid_754797
  var valid_754798 = path.getOrDefault("owner")
  valid_754798 = validateParameter(valid_754798, JString, required = true,
                                 default = nil)
  if valid_754798 != nil:
    section.add "owner", valid_754798
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754799 = header.getOrDefault("Accept")
  valid_754799 = validateParameter(valid_754799, JString, required = false,
                                 default = nil)
  if valid_754799 != nil:
    section.add "Accept", valid_754799
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754800: Call_GetReposOwnerRepoCommitsShaCode_754793;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single commit.
  ## 
  let valid = call_754800.validator(path, query, header, formData, body, _)
  let scheme = call_754800.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754800.makeUrl(scheme.get, call_754800.host, call_754800.base,
                             call_754800.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754800, uri, valid, _)

proc call*(call_754801: Call_GetReposOwnerRepoCommitsShaCode_754793;
          shaCode: string; repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommitsShaCode
  ## Get a single commit.
  ##   shaCode: string (required)
  ##          : SHA-1 code of the commit.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754802 = newJObject()
  var header_754803 = newJObject()
  add(path_754802, "shaCode", newJString(shaCode))
  add(header_754803, "Accept", newJString(Accept))
  add(path_754802, "repo", newJString(repo))
  add(path_754802, "owner", newJString(owner))
  result = call_754801.call(path_754802, nil, header_754803, nil, nil)

var getReposOwnerRepoCommitsShaCode* = Call_GetReposOwnerRepoCommitsShaCode_754793(
    name: "getReposOwnerRepoCommitsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/commits/{shaCode}",
    validator: validate_GetReposOwnerRepoCommitsShaCode_754794, base: "/",
    makeUrl: url_GetReposOwnerRepoCommitsShaCode_754795, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoCommitsShaCodeComments_754815 = ref object of OpenApiRestCall_753573
proc url_PostReposOwnerRepoCommitsShaCodeComments_754817(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits/"),
               (kind: VariableSegment, value: "shaCode"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoCommitsShaCodeComments_754816(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Create a commit comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   shaCode: JString (required)
  ##          : SHA-1 code of the commit.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `shaCode` field"
  var valid_754818 = path.getOrDefault("shaCode")
  valid_754818 = validateParameter(valid_754818, JString, required = true,
                                 default = nil)
  if valid_754818 != nil:
    section.add "shaCode", valid_754818
  var valid_754819 = path.getOrDefault("repo")
  valid_754819 = validateParameter(valid_754819, JString, required = true,
                                 default = nil)
  if valid_754819 != nil:
    section.add "repo", valid_754819
  var valid_754820 = path.getOrDefault("owner")
  valid_754820 = validateParameter(valid_754820, JString, required = true,
                                 default = nil)
  if valid_754820 != nil:
    section.add "owner", valid_754820
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754821 = header.getOrDefault("Accept")
  valid_754821 = validateParameter(valid_754821, JString, required = false,
                                 default = nil)
  if valid_754821 != nil:
    section.add "Accept", valid_754821
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_754823: Call_PostReposOwnerRepoCommitsShaCodeComments_754815;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a commit comment.
  ## 
  let valid = call_754823.validator(path, query, header, formData, body, _)
  let scheme = call_754823.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754823.makeUrl(scheme.get, call_754823.host, call_754823.base,
                             call_754823.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754823, uri, valid, _)

proc call*(call_754824: Call_PostReposOwnerRepoCommitsShaCodeComments_754815;
          shaCode: string; repo: string; body: JsonNode; owner: string;
          Accept: string = ""): Recallable =
  ## postReposOwnerRepoCommitsShaCodeComments
  ## Create a commit comment.
  ##   shaCode: string (required)
  ##          : SHA-1 code of the commit.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754825 = newJObject()
  var header_754826 = newJObject()
  var body_754827 = newJObject()
  add(path_754825, "shaCode", newJString(shaCode))
  add(header_754826, "Accept", newJString(Accept))
  add(path_754825, "repo", newJString(repo))
  if body != nil:
    body_754827 = body
  add(path_754825, "owner", newJString(owner))
  result = call_754824.call(path_754825, nil, header_754826, nil, body_754827)

var postReposOwnerRepoCommitsShaCodeComments* = Call_PostReposOwnerRepoCommitsShaCodeComments_754815(
    name: "postReposOwnerRepoCommitsShaCodeComments", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/commits/{shaCode}/comments",
    validator: validate_PostReposOwnerRepoCommitsShaCodeComments_754816,
    base: "/", makeUrl: url_PostReposOwnerRepoCommitsShaCodeComments_754817,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommitsShaCodeComments_754804 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoCommitsShaCodeComments_754806(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits/"),
               (kind: VariableSegment, value: "shaCode"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommitsShaCodeComments_754805(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## List comments for a single commitList comments for a single commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   shaCode: JString (required)
  ##          : SHA-1 code of the commit.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `shaCode` field"
  var valid_754807 = path.getOrDefault("shaCode")
  valid_754807 = validateParameter(valid_754807, JString, required = true,
                                 default = nil)
  if valid_754807 != nil:
    section.add "shaCode", valid_754807
  var valid_754808 = path.getOrDefault("repo")
  valid_754808 = validateParameter(valid_754808, JString, required = true,
                                 default = nil)
  if valid_754808 != nil:
    section.add "repo", valid_754808
  var valid_754809 = path.getOrDefault("owner")
  valid_754809 = validateParameter(valid_754809, JString, required = true,
                                 default = nil)
  if valid_754809 != nil:
    section.add "owner", valid_754809
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754810 = header.getOrDefault("Accept")
  valid_754810 = validateParameter(valid_754810, JString, required = false,
                                 default = nil)
  if valid_754810 != nil:
    section.add "Accept", valid_754810
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754811: Call_GetReposOwnerRepoCommitsShaCodeComments_754804;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List comments for a single commitList comments for a single commit.
  ## 
  let valid = call_754811.validator(path, query, header, formData, body, _)
  let scheme = call_754811.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754811.makeUrl(scheme.get, call_754811.host, call_754811.base,
                             call_754811.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754811, uri, valid, _)

proc call*(call_754812: Call_GetReposOwnerRepoCommitsShaCodeComments_754804;
          shaCode: string; repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommitsShaCodeComments
  ## List comments for a single commitList comments for a single commit.
  ##   shaCode: string (required)
  ##          : SHA-1 code of the commit.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754813 = newJObject()
  var header_754814 = newJObject()
  add(path_754813, "shaCode", newJString(shaCode))
  add(header_754814, "Accept", newJString(Accept))
  add(path_754813, "repo", newJString(repo))
  add(path_754813, "owner", newJString(owner))
  result = call_754812.call(path_754813, nil, header_754814, nil, nil)

var getReposOwnerRepoCommitsShaCodeComments* = Call_GetReposOwnerRepoCommitsShaCodeComments_754804(
    name: "getReposOwnerRepoCommitsShaCodeComments", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/commits/{shaCode}/comments",
    validator: validate_GetReposOwnerRepoCommitsShaCodeComments_754805, base: "/",
    makeUrl: url_GetReposOwnerRepoCommitsShaCodeComments_754806,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCompareBaseIdHeadId_754828 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoCompareBaseIdHeadId_754830(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "baseId" in path, "`baseId` is a required path parameter"
  assert "headId" in path, "`headId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/compare/"),
               (kind: VariableSegment, value: "baseId"),
               (kind: ConstantSegment, value: "..."),
               (kind: VariableSegment, value: "headId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCompareBaseIdHeadId_754829(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Compare two commits
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   baseId: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   headId: JString (required)
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `baseId` field"
  var valid_754831 = path.getOrDefault("baseId")
  valid_754831 = validateParameter(valid_754831, JString, required = true,
                                 default = nil)
  if valid_754831 != nil:
    section.add "baseId", valid_754831
  var valid_754832 = path.getOrDefault("repo")
  valid_754832 = validateParameter(valid_754832, JString, required = true,
                                 default = nil)
  if valid_754832 != nil:
    section.add "repo", valid_754832
  var valid_754833 = path.getOrDefault("headId")
  valid_754833 = validateParameter(valid_754833, JString, required = true,
                                 default = nil)
  if valid_754833 != nil:
    section.add "headId", valid_754833
  var valid_754834 = path.getOrDefault("owner")
  valid_754834 = validateParameter(valid_754834, JString, required = true,
                                 default = nil)
  if valid_754834 != nil:
    section.add "owner", valid_754834
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754835 = header.getOrDefault("Accept")
  valid_754835 = validateParameter(valid_754835, JString, required = false,
                                 default = nil)
  if valid_754835 != nil:
    section.add "Accept", valid_754835
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754836: Call_GetReposOwnerRepoCompareBaseIdHeadId_754828;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Compare two commits
  ## 
  let valid = call_754836.validator(path, query, header, formData, body, _)
  let scheme = call_754836.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754836.makeUrl(scheme.get, call_754836.host, call_754836.base,
                             call_754836.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754836, uri, valid, _)

proc call*(call_754837: Call_GetReposOwnerRepoCompareBaseIdHeadId_754828;
          baseId: string; repo: string; headId: string; owner: string;
          Accept: string = ""): Recallable =
  ## getReposOwnerRepoCompareBaseIdHeadId
  ## Compare two commits
  ##   baseId: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   headId: string (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754838 = newJObject()
  var header_754839 = newJObject()
  add(path_754838, "baseId", newJString(baseId))
  add(header_754839, "Accept", newJString(Accept))
  add(path_754838, "repo", newJString(repo))
  add(path_754838, "headId", newJString(headId))
  add(path_754838, "owner", newJString(owner))
  result = call_754837.call(path_754838, nil, header_754839, nil, nil)

var getReposOwnerRepoCompareBaseIdHeadId* = Call_GetReposOwnerRepoCompareBaseIdHeadId_754828(
    name: "getReposOwnerRepoCompareBaseIdHeadId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/compare/{baseId}...{headId}",
    validator: validate_GetReposOwnerRepoCompareBaseIdHeadId_754829, base: "/",
    makeUrl: url_GetReposOwnerRepoCompareBaseIdHeadId_754830,
    schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoContentsPath_754854 = ref object of OpenApiRestCall_753573
proc url_PutReposOwnerRepoContentsPath_754856(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/contents/"),
               (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoContentsPath_754855(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Create a file.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   path: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `path` field"
  var valid_754857 = path.getOrDefault("path")
  valid_754857 = validateParameter(valid_754857, JString, required = true,
                                 default = nil)
  if valid_754857 != nil:
    section.add "path", valid_754857
  var valid_754858 = path.getOrDefault("repo")
  valid_754858 = validateParameter(valid_754858, JString, required = true,
                                 default = nil)
  if valid_754858 != nil:
    section.add "repo", valid_754858
  var valid_754859 = path.getOrDefault("owner")
  valid_754859 = validateParameter(valid_754859, JString, required = true,
                                 default = nil)
  if valid_754859 != nil:
    section.add "owner", valid_754859
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754860 = header.getOrDefault("Accept")
  valid_754860 = validateParameter(valid_754860, JString, required = false,
                                 default = nil)
  if valid_754860 != nil:
    section.add "Accept", valid_754860
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_754862: Call_PutReposOwnerRepoContentsPath_754854;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a file.
  ## 
  let valid = call_754862.validator(path, query, header, formData, body, _)
  let scheme = call_754862.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754862.makeUrl(scheme.get, call_754862.host, call_754862.base,
                             call_754862.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754862, uri, valid, _)

proc call*(call_754863: Call_PutReposOwnerRepoContentsPath_754854; path: string;
          repo: string; body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoContentsPath
  ## Create a file.
  ##   path: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754864 = newJObject()
  var header_754865 = newJObject()
  var body_754866 = newJObject()
  add(path_754864, "path", newJString(path))
  add(header_754865, "Accept", newJString(Accept))
  add(path_754864, "repo", newJString(repo))
  if body != nil:
    body_754866 = body
  add(path_754864, "owner", newJString(owner))
  result = call_754863.call(path_754864, nil, header_754865, nil, body_754866)

var putReposOwnerRepoContentsPath* = Call_PutReposOwnerRepoContentsPath_754854(
    name: "putReposOwnerRepoContentsPath", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contents/{path}",
    validator: validate_PutReposOwnerRepoContentsPath_754855, base: "/",
    makeUrl: url_PutReposOwnerRepoContentsPath_754856, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoContentsPath_754840 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoContentsPath_754842(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/contents/"),
               (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoContentsPath_754841(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Get contents.
  ## This method returns the contents of a file or directory in a repository.
  ## Files and symlinks support a custom media type for getting the raw content.
  ## Directories and submodules do not support custom media types.
  ## Note: This API supports files up to 1 megabyte in size.
  ## Here can be many outcomes. For details see "http://developer.github.com/v3/repos/contents/"
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   path: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `path` field"
  var valid_754843 = path.getOrDefault("path")
  valid_754843 = validateParameter(valid_754843, JString, required = true,
                                 default = nil)
  if valid_754843 != nil:
    section.add "path", valid_754843
  var valid_754844 = path.getOrDefault("repo")
  valid_754844 = validateParameter(valid_754844, JString, required = true,
                                 default = nil)
  if valid_754844 != nil:
    section.add "repo", valid_754844
  var valid_754845 = path.getOrDefault("owner")
  valid_754845 = validateParameter(valid_754845, JString, required = true,
                                 default = nil)
  if valid_754845 != nil:
    section.add "owner", valid_754845
  result.add "path", section
  ## parameters in `query` object:
  ##   path: JString
  ##       : The content path.
  ##   ref: JString
  ##      : The String name of the Commit/Branch/Tag. Defaults to 'master'.
  section = newJObject()
  var valid_754846 = query.getOrDefault("path")
  valid_754846 = validateParameter(valid_754846, JString, required = false,
                                 default = nil)
  if valid_754846 != nil:
    section.add "path", valid_754846
  var valid_754847 = query.getOrDefault("ref")
  valid_754847 = validateParameter(valid_754847, JString, required = false,
                                 default = nil)
  if valid_754847 != nil:
    section.add "ref", valid_754847
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754848 = header.getOrDefault("Accept")
  valid_754848 = validateParameter(valid_754848, JString, required = false,
                                 default = nil)
  if valid_754848 != nil:
    section.add "Accept", valid_754848
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754849: Call_GetReposOwnerRepoContentsPath_754840;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get contents.
  ## This method returns the contents of a file or directory in a repository.
  ## Files and symlinks support a custom media type for getting the raw content.
  ## Directories and submodules do not support custom media types.
  ## Note: This API supports files up to 1 megabyte in size.
  ## Here can be many outcomes. For details see "http://developer.github.com/v3/repos/contents/"
  ## 
  ## 
  let valid = call_754849.validator(path, query, header, formData, body, _)
  let scheme = call_754849.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754849.makeUrl(scheme.get, call_754849.host, call_754849.base,
                             call_754849.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754849, uri, valid, _)

var getReposOwnerRepoContentsPath* = Call_GetReposOwnerRepoContentsPath_754840(
    name: "getReposOwnerRepoContentsPath", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contents/{path}",
    validator: validate_GetReposOwnerRepoContentsPath_754841, base: "/",
    makeUrl: url_GetReposOwnerRepoContentsPath_754842, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoContentsPath_754867 = ref object of OpenApiRestCall_753573
proc url_DeleteReposOwnerRepoContentsPath_754869(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/contents/"),
               (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoContentsPath_754868(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Delete a file.
  ## This method deletes a file in a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   path: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `path` field"
  var valid_754870 = path.getOrDefault("path")
  valid_754870 = validateParameter(valid_754870, JString, required = true,
                                 default = nil)
  if valid_754870 != nil:
    section.add "path", valid_754870
  var valid_754871 = path.getOrDefault("repo")
  valid_754871 = validateParameter(valid_754871, JString, required = true,
                                 default = nil)
  if valid_754871 != nil:
    section.add "repo", valid_754871
  var valid_754872 = path.getOrDefault("owner")
  valid_754872 = validateParameter(valid_754872, JString, required = true,
                                 default = nil)
  if valid_754872 != nil:
    section.add "owner", valid_754872
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754873 = header.getOrDefault("Accept")
  valid_754873 = validateParameter(valid_754873, JString, required = false,
                                 default = nil)
  if valid_754873 != nil:
    section.add "Accept", valid_754873
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_754875: Call_DeleteReposOwnerRepoContentsPath_754867;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a file.
  ## This method deletes a file in a repository.
  ## 
  ## 
  let valid = call_754875.validator(path, query, header, formData, body, _)
  let scheme = call_754875.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754875.makeUrl(scheme.get, call_754875.host, call_754875.base,
                             call_754875.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754875, uri, valid, _)

proc call*(call_754876: Call_DeleteReposOwnerRepoContentsPath_754867; path: string;
          repo: string; body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoContentsPath
  ## Delete a file.
  ## This method deletes a file in a repository.
  ## 
  ##   path: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754877 = newJObject()
  var header_754878 = newJObject()
  var body_754879 = newJObject()
  add(path_754877, "path", newJString(path))
  add(header_754878, "Accept", newJString(Accept))
  add(path_754877, "repo", newJString(repo))
  if body != nil:
    body_754879 = body
  add(path_754877, "owner", newJString(owner))
  result = call_754876.call(path_754877, nil, header_754878, nil, body_754879)

var deleteReposOwnerRepoContentsPath* = Call_DeleteReposOwnerRepoContentsPath_754867(
    name: "deleteReposOwnerRepoContentsPath", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contents/{path}",
    validator: validate_DeleteReposOwnerRepoContentsPath_754868, base: "/",
    makeUrl: url_DeleteReposOwnerRepoContentsPath_754869, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoContributors_754880 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoContributors_754882(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/contributors")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoContributors_754881(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Get list of contributors.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_754883 = path.getOrDefault("repo")
  valid_754883 = validateParameter(valid_754883, JString, required = true,
                                 default = nil)
  if valid_754883 != nil:
    section.add "repo", valid_754883
  var valid_754884 = path.getOrDefault("owner")
  valid_754884 = validateParameter(valid_754884, JString, required = true,
                                 default = nil)
  if valid_754884 != nil:
    section.add "owner", valid_754884
  result.add "path", section
  ## parameters in `query` object:
  ##   anon: JString (required)
  ##       : Set to 1 or true to include anonymous contributors in results.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `anon` field"
  var valid_754885 = query.getOrDefault("anon")
  valid_754885 = validateParameter(valid_754885, JString, required = true,
                                 default = nil)
  if valid_754885 != nil:
    section.add "anon", valid_754885
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754886 = header.getOrDefault("Accept")
  valid_754886 = validateParameter(valid_754886, JString, required = false,
                                 default = nil)
  if valid_754886 != nil:
    section.add "Accept", valid_754886
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754887: Call_GetReposOwnerRepoContributors_754880;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get list of contributors.
  ## 
  let valid = call_754887.validator(path, query, header, formData, body, _)
  let scheme = call_754887.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754887.makeUrl(scheme.get, call_754887.host, call_754887.base,
                             call_754887.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754887, uri, valid, _)

proc call*(call_754888: Call_GetReposOwnerRepoContributors_754880; repo: string;
          owner: string; anon: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoContributors
  ## Get list of contributors.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   anon: string (required)
  ##       : Set to 1 or true to include anonymous contributors in results.
  var path_754889 = newJObject()
  var query_754890 = newJObject()
  var header_754891 = newJObject()
  add(header_754891, "Accept", newJString(Accept))
  add(path_754889, "repo", newJString(repo))
  add(path_754889, "owner", newJString(owner))
  add(query_754890, "anon", newJString(anon))
  result = call_754888.call(path_754889, query_754890, header_754891, nil, nil)

var getReposOwnerRepoContributors* = Call_GetReposOwnerRepoContributors_754880(
    name: "getReposOwnerRepoContributors", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contributors",
    validator: validate_GetReposOwnerRepoContributors_754881, base: "/",
    makeUrl: url_GetReposOwnerRepoContributors_754882, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoDeployments_754902 = ref object of OpenApiRestCall_753573
proc url_PostReposOwnerRepoDeployments_754904(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/deployments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoDeployments_754903(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Users with push access can create a deployment for a given ref
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_754905 = path.getOrDefault("repo")
  valid_754905 = validateParameter(valid_754905, JString, required = true,
                                 default = nil)
  if valid_754905 != nil:
    section.add "repo", valid_754905
  var valid_754906 = path.getOrDefault("owner")
  valid_754906 = validateParameter(valid_754906, JString, required = true,
                                 default = nil)
  if valid_754906 != nil:
    section.add "owner", valid_754906
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754907 = header.getOrDefault("Accept")
  valid_754907 = validateParameter(valid_754907, JString, required = false,
                                 default = nil)
  if valid_754907 != nil:
    section.add "Accept", valid_754907
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_754909: Call_PostReposOwnerRepoDeployments_754902;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Users with push access can create a deployment for a given ref
  ## 
  let valid = call_754909.validator(path, query, header, formData, body, _)
  let scheme = call_754909.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754909.makeUrl(scheme.get, call_754909.host, call_754909.base,
                             call_754909.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754909, uri, valid, _)

proc call*(call_754910: Call_PostReposOwnerRepoDeployments_754902; repo: string;
          body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoDeployments
  ## Users with push access can create a deployment for a given ref
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754911 = newJObject()
  var header_754912 = newJObject()
  var body_754913 = newJObject()
  add(header_754912, "Accept", newJString(Accept))
  add(path_754911, "repo", newJString(repo))
  if body != nil:
    body_754913 = body
  add(path_754911, "owner", newJString(owner))
  result = call_754910.call(path_754911, nil, header_754912, nil, body_754913)

var postReposOwnerRepoDeployments* = Call_PostReposOwnerRepoDeployments_754902(
    name: "postReposOwnerRepoDeployments", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/deployments",
    validator: validate_PostReposOwnerRepoDeployments_754903, base: "/",
    makeUrl: url_PostReposOwnerRepoDeployments_754904, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDeployments_754892 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoDeployments_754894(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/deployments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDeployments_754893(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Users with pull access can view deployments for a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_754895 = path.getOrDefault("repo")
  valid_754895 = validateParameter(valid_754895, JString, required = true,
                                 default = nil)
  if valid_754895 != nil:
    section.add "repo", valid_754895
  var valid_754896 = path.getOrDefault("owner")
  valid_754896 = validateParameter(valid_754896, JString, required = true,
                                 default = nil)
  if valid_754896 != nil:
    section.add "owner", valid_754896
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754897 = header.getOrDefault("Accept")
  valid_754897 = validateParameter(valid_754897, JString, required = false,
                                 default = nil)
  if valid_754897 != nil:
    section.add "Accept", valid_754897
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754898: Call_GetReposOwnerRepoDeployments_754892;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Users with pull access can view deployments for a repository
  ## 
  let valid = call_754898.validator(path, query, header, formData, body, _)
  let scheme = call_754898.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754898.makeUrl(scheme.get, call_754898.host, call_754898.base,
                             call_754898.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754898, uri, valid, _)

proc call*(call_754899: Call_GetReposOwnerRepoDeployments_754892; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDeployments
  ## Users with pull access can view deployments for a repository
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754900 = newJObject()
  var header_754901 = newJObject()
  add(header_754901, "Accept", newJString(Accept))
  add(path_754900, "repo", newJString(repo))
  add(path_754900, "owner", newJString(owner))
  result = call_754899.call(path_754900, nil, header_754901, nil, nil)

var getReposOwnerRepoDeployments* = Call_GetReposOwnerRepoDeployments_754892(
    name: "getReposOwnerRepoDeployments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/deployments",
    validator: validate_GetReposOwnerRepoDeployments_754893, base: "/",
    makeUrl: url_GetReposOwnerRepoDeployments_754894, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoDeploymentsIdStatuses_754925 = ref object of OpenApiRestCall_753573
proc url_PostReposOwnerRepoDeploymentsIdStatuses_754927(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/deployments/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/statuses")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoDeploymentsIdStatuses_754926(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Create a Deployment Status
  ## Users with push access can create deployment statuses for a given deployment:
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : The Deployment ID to list the statuses from.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_754928 = path.getOrDefault("id")
  valid_754928 = validateParameter(valid_754928, JInt, required = true, default = nil)
  if valid_754928 != nil:
    section.add "id", valid_754928
  var valid_754929 = path.getOrDefault("repo")
  valid_754929 = validateParameter(valid_754929, JString, required = true,
                                 default = nil)
  if valid_754929 != nil:
    section.add "repo", valid_754929
  var valid_754930 = path.getOrDefault("owner")
  valid_754930 = validateParameter(valid_754930, JString, required = true,
                                 default = nil)
  if valid_754930 != nil:
    section.add "owner", valid_754930
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754931 = header.getOrDefault("Accept")
  valid_754931 = validateParameter(valid_754931, JString, required = false,
                                 default = nil)
  if valid_754931 != nil:
    section.add "Accept", valid_754931
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_754933: Call_PostReposOwnerRepoDeploymentsIdStatuses_754925;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a Deployment Status
  ## Users with push access can create deployment statuses for a given deployment:
  ## 
  ## 
  let valid = call_754933.validator(path, query, header, formData, body, _)
  let scheme = call_754933.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754933.makeUrl(scheme.get, call_754933.host, call_754933.base,
                             call_754933.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754933, uri, valid, _)

proc call*(call_754934: Call_PostReposOwnerRepoDeploymentsIdStatuses_754925;
          id: int; repo: string; body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoDeploymentsIdStatuses
  ## Create a Deployment Status
  ## Users with push access can create deployment statuses for a given deployment:
  ## 
  ##   id: int (required)
  ##     : The Deployment ID to list the statuses from.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754935 = newJObject()
  var header_754936 = newJObject()
  var body_754937 = newJObject()
  add(path_754935, "id", newJInt(id))
  add(header_754936, "Accept", newJString(Accept))
  add(path_754935, "repo", newJString(repo))
  if body != nil:
    body_754937 = body
  add(path_754935, "owner", newJString(owner))
  result = call_754934.call(path_754935, nil, header_754936, nil, body_754937)

var postReposOwnerRepoDeploymentsIdStatuses* = Call_PostReposOwnerRepoDeploymentsIdStatuses_754925(
    name: "postReposOwnerRepoDeploymentsIdStatuses", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/deployments/{id}/statuses",
    validator: validate_PostReposOwnerRepoDeploymentsIdStatuses_754926, base: "/",
    makeUrl: url_PostReposOwnerRepoDeploymentsIdStatuses_754927,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDeploymentsIdStatuses_754914 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoDeploymentsIdStatuses_754916(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/deployments/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/statuses")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDeploymentsIdStatuses_754915(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Users with pull access can view deployment statuses for a deployment
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : The Deployment ID to list the statuses from.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_754917 = path.getOrDefault("id")
  valid_754917 = validateParameter(valid_754917, JInt, required = true, default = nil)
  if valid_754917 != nil:
    section.add "id", valid_754917
  var valid_754918 = path.getOrDefault("repo")
  valid_754918 = validateParameter(valid_754918, JString, required = true,
                                 default = nil)
  if valid_754918 != nil:
    section.add "repo", valid_754918
  var valid_754919 = path.getOrDefault("owner")
  valid_754919 = validateParameter(valid_754919, JString, required = true,
                                 default = nil)
  if valid_754919 != nil:
    section.add "owner", valid_754919
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754920 = header.getOrDefault("Accept")
  valid_754920 = validateParameter(valid_754920, JString, required = false,
                                 default = nil)
  if valid_754920 != nil:
    section.add "Accept", valid_754920
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754921: Call_GetReposOwnerRepoDeploymentsIdStatuses_754914;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Users with pull access can view deployment statuses for a deployment
  ## 
  let valid = call_754921.validator(path, query, header, formData, body, _)
  let scheme = call_754921.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754921.makeUrl(scheme.get, call_754921.host, call_754921.base,
                             call_754921.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754921, uri, valid, _)

proc call*(call_754922: Call_GetReposOwnerRepoDeploymentsIdStatuses_754914;
          id: int; repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDeploymentsIdStatuses
  ## Users with pull access can view deployment statuses for a deployment
  ##   id: int (required)
  ##     : The Deployment ID to list the statuses from.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754923 = newJObject()
  var header_754924 = newJObject()
  add(path_754923, "id", newJInt(id))
  add(header_754924, "Accept", newJString(Accept))
  add(path_754923, "repo", newJString(repo))
  add(path_754923, "owner", newJString(owner))
  result = call_754922.call(path_754923, nil, header_754924, nil, nil)

var getReposOwnerRepoDeploymentsIdStatuses* = Call_GetReposOwnerRepoDeploymentsIdStatuses_754914(
    name: "getReposOwnerRepoDeploymentsIdStatuses", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/deployments/{id}/statuses",
    validator: validate_GetReposOwnerRepoDeploymentsIdStatuses_754915, base: "/",
    makeUrl: url_GetReposOwnerRepoDeploymentsIdStatuses_754916,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDownloads_754938 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoDownloads_754940(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/downloads")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDownloads_754939(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Deprecated. List downloads for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_754941 = path.getOrDefault("repo")
  valid_754941 = validateParameter(valid_754941, JString, required = true,
                                 default = nil)
  if valid_754941 != nil:
    section.add "repo", valid_754941
  var valid_754942 = path.getOrDefault("owner")
  valid_754942 = validateParameter(valid_754942, JString, required = true,
                                 default = nil)
  if valid_754942 != nil:
    section.add "owner", valid_754942
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754943 = header.getOrDefault("Accept")
  valid_754943 = validateParameter(valid_754943, JString, required = false,
                                 default = nil)
  if valid_754943 != nil:
    section.add "Accept", valid_754943
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754944: Call_GetReposOwnerRepoDownloads_754938;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Deprecated. List downloads for a repository.
  ## 
  let valid = call_754944.validator(path, query, header, formData, body, _)
  let scheme = call_754944.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754944.makeUrl(scheme.get, call_754944.host, call_754944.base,
                             call_754944.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754944, uri, valid, _)

proc call*(call_754945: Call_GetReposOwnerRepoDownloads_754938; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDownloads
  ## Deprecated. List downloads for a repository.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754946 = newJObject()
  var header_754947 = newJObject()
  add(header_754947, "Accept", newJString(Accept))
  add(path_754946, "repo", newJString(repo))
  add(path_754946, "owner", newJString(owner))
  result = call_754945.call(path_754946, nil, header_754947, nil, nil)

var getReposOwnerRepoDownloads* = Call_GetReposOwnerRepoDownloads_754938(
    name: "getReposOwnerRepoDownloads", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/downloads",
    validator: validate_GetReposOwnerRepoDownloads_754939, base: "/",
    makeUrl: url_GetReposOwnerRepoDownloads_754940, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDownloadsDownloadId_754948 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoDownloadsDownloadId_754950(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "downloadId" in path, "`downloadId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/downloads/"),
               (kind: VariableSegment, value: "downloadId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDownloadsDownloadId_754949(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Deprecated. Get a single download.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   downloadId: JInt (required)
  ##             : Id of download.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `downloadId` field"
  var valid_754951 = path.getOrDefault("downloadId")
  valid_754951 = validateParameter(valid_754951, JInt, required = true, default = nil)
  if valid_754951 != nil:
    section.add "downloadId", valid_754951
  var valid_754952 = path.getOrDefault("repo")
  valid_754952 = validateParameter(valid_754952, JString, required = true,
                                 default = nil)
  if valid_754952 != nil:
    section.add "repo", valid_754952
  var valid_754953 = path.getOrDefault("owner")
  valid_754953 = validateParameter(valid_754953, JString, required = true,
                                 default = nil)
  if valid_754953 != nil:
    section.add "owner", valid_754953
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754954 = header.getOrDefault("Accept")
  valid_754954 = validateParameter(valid_754954, JString, required = false,
                                 default = nil)
  if valid_754954 != nil:
    section.add "Accept", valid_754954
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754955: Call_GetReposOwnerRepoDownloadsDownloadId_754948;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Deprecated. Get a single download.
  ## 
  let valid = call_754955.validator(path, query, header, formData, body, _)
  let scheme = call_754955.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754955.makeUrl(scheme.get, call_754955.host, call_754955.base,
                             call_754955.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754955, uri, valid, _)

proc call*(call_754956: Call_GetReposOwnerRepoDownloadsDownloadId_754948;
          downloadId: int; repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDownloadsDownloadId
  ## Deprecated. Get a single download.
  ##   downloadId: int (required)
  ##             : Id of download.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754957 = newJObject()
  var header_754958 = newJObject()
  add(path_754957, "downloadId", newJInt(downloadId))
  add(header_754958, "Accept", newJString(Accept))
  add(path_754957, "repo", newJString(repo))
  add(path_754957, "owner", newJString(owner))
  result = call_754956.call(path_754957, nil, header_754958, nil, nil)

var getReposOwnerRepoDownloadsDownloadId* = Call_GetReposOwnerRepoDownloadsDownloadId_754948(
    name: "getReposOwnerRepoDownloadsDownloadId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/downloads/{downloadId}",
    validator: validate_GetReposOwnerRepoDownloadsDownloadId_754949, base: "/",
    makeUrl: url_GetReposOwnerRepoDownloadsDownloadId_754950,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoDownloadsDownloadId_754959 = ref object of OpenApiRestCall_753573
proc url_DeleteReposOwnerRepoDownloadsDownloadId_754961(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "downloadId" in path, "`downloadId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/downloads/"),
               (kind: VariableSegment, value: "downloadId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoDownloadsDownloadId_754960(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Deprecated. Delete a download.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   downloadId: JInt (required)
  ##             : Id of download.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil,
        "path argument is necessary due to required `downloadId` field"
  var valid_754962 = path.getOrDefault("downloadId")
  valid_754962 = validateParameter(valid_754962, JInt, required = true, default = nil)
  if valid_754962 != nil:
    section.add "downloadId", valid_754962
  var valid_754963 = path.getOrDefault("repo")
  valid_754963 = validateParameter(valid_754963, JString, required = true,
                                 default = nil)
  if valid_754963 != nil:
    section.add "repo", valid_754963
  var valid_754964 = path.getOrDefault("owner")
  valid_754964 = validateParameter(valid_754964, JString, required = true,
                                 default = nil)
  if valid_754964 != nil:
    section.add "owner", valid_754964
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754965 = header.getOrDefault("Accept")
  valid_754965 = validateParameter(valid_754965, JString, required = false,
                                 default = nil)
  if valid_754965 != nil:
    section.add "Accept", valid_754965
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754966: Call_DeleteReposOwnerRepoDownloadsDownloadId_754959;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Deprecated. Delete a download.
  ## 
  let valid = call_754966.validator(path, query, header, formData, body, _)
  let scheme = call_754966.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754966.makeUrl(scheme.get, call_754966.host, call_754966.base,
                             call_754966.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754966, uri, valid, _)

proc call*(call_754967: Call_DeleteReposOwnerRepoDownloadsDownloadId_754959;
          downloadId: int; repo: string; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoDownloadsDownloadId
  ## Deprecated. Delete a download.
  ##   downloadId: int (required)
  ##             : Id of download.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754968 = newJObject()
  var header_754969 = newJObject()
  add(path_754968, "downloadId", newJInt(downloadId))
  add(header_754969, "Accept", newJString(Accept))
  add(path_754968, "repo", newJString(repo))
  add(path_754968, "owner", newJString(owner))
  result = call_754967.call(path_754968, nil, header_754969, nil, nil)

var deleteReposOwnerRepoDownloadsDownloadId* = Call_DeleteReposOwnerRepoDownloadsDownloadId_754959(
    name: "deleteReposOwnerRepoDownloadsDownloadId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/downloads/{downloadId}",
    validator: validate_DeleteReposOwnerRepoDownloadsDownloadId_754960, base: "/",
    makeUrl: url_DeleteReposOwnerRepoDownloadsDownloadId_754961,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoEvents_754970 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoEvents_754972(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoEvents_754971(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Get list of repository events.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_754973 = path.getOrDefault("repo")
  valid_754973 = validateParameter(valid_754973, JString, required = true,
                                 default = nil)
  if valid_754973 != nil:
    section.add "repo", valid_754973
  var valid_754974 = path.getOrDefault("owner")
  valid_754974 = validateParameter(valid_754974, JString, required = true,
                                 default = nil)
  if valid_754974 != nil:
    section.add "owner", valid_754974
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754975 = header.getOrDefault("Accept")
  valid_754975 = validateParameter(valid_754975, JString, required = false,
                                 default = nil)
  if valid_754975 != nil:
    section.add "Accept", valid_754975
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754976: Call_GetReposOwnerRepoEvents_754970; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get list of repository events.
  ## 
  let valid = call_754976.validator(path, query, header, formData, body, _)
  let scheme = call_754976.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754976.makeUrl(scheme.get, call_754976.host, call_754976.base,
                             call_754976.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754976, uri, valid, _)

proc call*(call_754977: Call_GetReposOwnerRepoEvents_754970; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoEvents
  ## Get list of repository events.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754978 = newJObject()
  var header_754979 = newJObject()
  add(header_754979, "Accept", newJString(Accept))
  add(path_754978, "repo", newJString(repo))
  add(path_754978, "owner", newJString(owner))
  result = call_754977.call(path_754978, nil, header_754979, nil, nil)

var getReposOwnerRepoEvents* = Call_GetReposOwnerRepoEvents_754970(
    name: "getReposOwnerRepoEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/events",
    validator: validate_GetReposOwnerRepoEvents_754971, base: "/",
    makeUrl: url_GetReposOwnerRepoEvents_754972, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoForks_754992 = ref object of OpenApiRestCall_753573
proc url_PostReposOwnerRepoForks_754994(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/forks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoForks_754993(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Create a fork.
  ## Forking a Repository happens asynchronously. Therefore, you may have to wai
  ## a short period before accessing the git objects. If this takes longer than 5
  ## minutes, be sure to contact Support.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_754995 = path.getOrDefault("repo")
  valid_754995 = validateParameter(valid_754995, JString, required = true,
                                 default = nil)
  if valid_754995 != nil:
    section.add "repo", valid_754995
  var valid_754996 = path.getOrDefault("owner")
  valid_754996 = validateParameter(valid_754996, JString, required = true,
                                 default = nil)
  if valid_754996 != nil:
    section.add "owner", valid_754996
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754997 = header.getOrDefault("Accept")
  valid_754997 = validateParameter(valid_754997, JString, required = false,
                                 default = nil)
  if valid_754997 != nil:
    section.add "Accept", valid_754997
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_754999: Call_PostReposOwnerRepoForks_754992; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a fork.
  ## Forking a Repository happens asynchronously. Therefore, you may have to wai
  ## a short period before accessing the git objects. If this takes longer than 5
  ## minutes, be sure to contact Support.
  ## 
  ## 
  let valid = call_754999.validator(path, query, header, formData, body, _)
  let scheme = call_754999.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754999.makeUrl(scheme.get, call_754999.host, call_754999.base,
                             call_754999.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754999, uri, valid, _)

proc call*(call_755000: Call_PostReposOwnerRepoForks_754992; repo: string;
          body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoForks
  ## Create a fork.
  ## Forking a Repository happens asynchronously. Therefore, you may have to wai
  ## a short period before accessing the git objects. If this takes longer than 5
  ## minutes, be sure to contact Support.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755001 = newJObject()
  var header_755002 = newJObject()
  var body_755003 = newJObject()
  add(header_755002, "Accept", newJString(Accept))
  add(path_755001, "repo", newJString(repo))
  if body != nil:
    body_755003 = body
  add(path_755001, "owner", newJString(owner))
  result = call_755000.call(path_755001, nil, header_755002, nil, body_755003)

var postReposOwnerRepoForks* = Call_PostReposOwnerRepoForks_754992(
    name: "postReposOwnerRepoForks", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/forks",
    validator: validate_PostReposOwnerRepoForks_754993, base: "/",
    makeUrl: url_PostReposOwnerRepoForks_754994, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoForks_754980 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoForks_754982(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/forks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoForks_754981(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List forks.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_754983 = path.getOrDefault("repo")
  valid_754983 = validateParameter(valid_754983, JString, required = true,
                                 default = nil)
  if valid_754983 != nil:
    section.add "repo", valid_754983
  var valid_754984 = path.getOrDefault("owner")
  valid_754984 = validateParameter(valid_754984, JString, required = true,
                                 default = nil)
  if valid_754984 != nil:
    section.add "owner", valid_754984
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  section = newJObject()
  var valid_754985 = query.getOrDefault("sort")
  valid_754985 = validateParameter(valid_754985, JString, required = false,
                                 default = newJString("newes"))
  if valid_754985 != nil:
    section.add "sort", valid_754985
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_754986 = header.getOrDefault("Accept")
  valid_754986 = validateParameter(valid_754986, JString, required = false,
                                 default = nil)
  if valid_754986 != nil:
    section.add "Accept", valid_754986
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_754987: Call_GetReposOwnerRepoForks_754980; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List forks.
  ## 
  let valid = call_754987.validator(path, query, header, formData, body, _)
  let scheme = call_754987.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_754987.makeUrl(scheme.get, call_754987.host, call_754987.base,
                             call_754987.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_754987, uri, valid, _)

proc call*(call_754988: Call_GetReposOwnerRepoForks_754980; repo: string;
          owner: string; sort: string = "newes"; Accept: string = ""): Recallable =
  ## getReposOwnerRepoForks
  ## List forks.
  ##   sort: string
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_754989 = newJObject()
  var query_754990 = newJObject()
  var header_754991 = newJObject()
  add(query_754990, "sort", newJString(sort))
  add(header_754991, "Accept", newJString(Accept))
  add(path_754989, "repo", newJString(repo))
  add(path_754989, "owner", newJString(owner))
  result = call_754988.call(path_754989, query_754990, header_754991, nil, nil)

var getReposOwnerRepoForks* = Call_GetReposOwnerRepoForks_754980(
    name: "getReposOwnerRepoForks", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/forks",
    validator: validate_GetReposOwnerRepoForks_754981, base: "/",
    makeUrl: url_GetReposOwnerRepoForks_754982, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitBlobs_755004 = ref object of OpenApiRestCall_753573
proc url_PostReposOwnerRepoGitBlobs_755006(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/blobs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitBlobs_755005(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Create a Blob.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755007 = path.getOrDefault("repo")
  valid_755007 = validateParameter(valid_755007, JString, required = true,
                                 default = nil)
  if valid_755007 != nil:
    section.add "repo", valid_755007
  var valid_755008 = path.getOrDefault("owner")
  valid_755008 = validateParameter(valid_755008, JString, required = true,
                                 default = nil)
  if valid_755008 != nil:
    section.add "owner", valid_755008
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755009 = header.getOrDefault("Accept")
  valid_755009 = validateParameter(valid_755009, JString, required = false,
                                 default = nil)
  if valid_755009 != nil:
    section.add "Accept", valid_755009
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_755011: Call_PostReposOwnerRepoGitBlobs_755004;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a Blob.
  ## 
  let valid = call_755011.validator(path, query, header, formData, body, _)
  let scheme = call_755011.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755011.makeUrl(scheme.get, call_755011.host, call_755011.base,
                             call_755011.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755011, uri, valid, _)

proc call*(call_755012: Call_PostReposOwnerRepoGitBlobs_755004; repo: string;
          body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitBlobs
  ## Create a Blob.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755013 = newJObject()
  var header_755014 = newJObject()
  var body_755015 = newJObject()
  add(header_755014, "Accept", newJString(Accept))
  add(path_755013, "repo", newJString(repo))
  if body != nil:
    body_755015 = body
  add(path_755013, "owner", newJString(owner))
  result = call_755012.call(path_755013, nil, header_755014, nil, body_755015)

var postReposOwnerRepoGitBlobs* = Call_PostReposOwnerRepoGitBlobs_755004(
    name: "postReposOwnerRepoGitBlobs", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/blobs",
    validator: validate_PostReposOwnerRepoGitBlobs_755005, base: "/",
    makeUrl: url_PostReposOwnerRepoGitBlobs_755006, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitBlobsShaCode_755016 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoGitBlobsShaCode_755018(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/blobs/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitBlobsShaCode_755017(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Get a Blob.
  ## Since blobs can be any arbitrary binary data, the input and responses for
  ## the blob API takes an encoding parameter that can be either utf-8 or
  ## base64. If your data cannot be losslessly sent as a UTF-8 string, you can
  ## base64 encode it.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   shaCode: JString (required)
  ##          : SHA-1 code.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `shaCode` field"
  var valid_755019 = path.getOrDefault("shaCode")
  valid_755019 = validateParameter(valid_755019, JString, required = true,
                                 default = nil)
  if valid_755019 != nil:
    section.add "shaCode", valid_755019
  var valid_755020 = path.getOrDefault("repo")
  valid_755020 = validateParameter(valid_755020, JString, required = true,
                                 default = nil)
  if valid_755020 != nil:
    section.add "repo", valid_755020
  var valid_755021 = path.getOrDefault("owner")
  valid_755021 = validateParameter(valid_755021, JString, required = true,
                                 default = nil)
  if valid_755021 != nil:
    section.add "owner", valid_755021
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755022 = header.getOrDefault("Accept")
  valid_755022 = validateParameter(valid_755022, JString, required = false,
                                 default = nil)
  if valid_755022 != nil:
    section.add "Accept", valid_755022
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755023: Call_GetReposOwnerRepoGitBlobsShaCode_755016;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a Blob.
  ## Since blobs can be any arbitrary binary data, the input and responses for
  ## the blob API takes an encoding parameter that can be either utf-8 or
  ## base64. If your data cannot be losslessly sent as a UTF-8 string, you can
  ## base64 encode it.
  ## 
  ## 
  let valid = call_755023.validator(path, query, header, formData, body, _)
  let scheme = call_755023.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755023.makeUrl(scheme.get, call_755023.host, call_755023.base,
                             call_755023.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755023, uri, valid, _)

proc call*(call_755024: Call_GetReposOwnerRepoGitBlobsShaCode_755016;
          shaCode: string; repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitBlobsShaCode
  ## Get a Blob.
  ## Since blobs can be any arbitrary binary data, the input and responses for
  ## the blob API takes an encoding parameter that can be either utf-8 or
  ## base64. If your data cannot be losslessly sent as a UTF-8 string, you can
  ## base64 encode it.
  ## 
  ##   shaCode: string (required)
  ##          : SHA-1 code.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755025 = newJObject()
  var header_755026 = newJObject()
  add(path_755025, "shaCode", newJString(shaCode))
  add(header_755026, "Accept", newJString(Accept))
  add(path_755025, "repo", newJString(repo))
  add(path_755025, "owner", newJString(owner))
  result = call_755024.call(path_755025, nil, header_755026, nil, nil)

var getReposOwnerRepoGitBlobsShaCode* = Call_GetReposOwnerRepoGitBlobsShaCode_755016(
    name: "getReposOwnerRepoGitBlobsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/blobs/{shaCode}",
    validator: validate_GetReposOwnerRepoGitBlobsShaCode_755017, base: "/",
    makeUrl: url_GetReposOwnerRepoGitBlobsShaCode_755018, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitCommits_755027 = ref object of OpenApiRestCall_753573
proc url_PostReposOwnerRepoGitCommits_755029(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/commits")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitCommits_755028(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Create a Commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755030 = path.getOrDefault("repo")
  valid_755030 = validateParameter(valid_755030, JString, required = true,
                                 default = nil)
  if valid_755030 != nil:
    section.add "repo", valid_755030
  var valid_755031 = path.getOrDefault("owner")
  valid_755031 = validateParameter(valid_755031, JString, required = true,
                                 default = nil)
  if valid_755031 != nil:
    section.add "owner", valid_755031
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755032 = header.getOrDefault("Accept")
  valid_755032 = validateParameter(valid_755032, JString, required = false,
                                 default = nil)
  if valid_755032 != nil:
    section.add "Accept", valid_755032
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_755034: Call_PostReposOwnerRepoGitCommits_755027;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a Commit.
  ## 
  let valid = call_755034.validator(path, query, header, formData, body, _)
  let scheme = call_755034.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755034.makeUrl(scheme.get, call_755034.host, call_755034.base,
                             call_755034.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755034, uri, valid, _)

proc call*(call_755035: Call_PostReposOwnerRepoGitCommits_755027; repo: string;
          body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitCommits
  ## Create a Commit.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755036 = newJObject()
  var header_755037 = newJObject()
  var body_755038 = newJObject()
  add(header_755037, "Accept", newJString(Accept))
  add(path_755036, "repo", newJString(repo))
  if body != nil:
    body_755038 = body
  add(path_755036, "owner", newJString(owner))
  result = call_755035.call(path_755036, nil, header_755037, nil, body_755038)

var postReposOwnerRepoGitCommits* = Call_PostReposOwnerRepoGitCommits_755027(
    name: "postReposOwnerRepoGitCommits", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/commits",
    validator: validate_PostReposOwnerRepoGitCommits_755028, base: "/",
    makeUrl: url_PostReposOwnerRepoGitCommits_755029, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitCommitsShaCode_755039 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoGitCommitsShaCode_755041(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/commits/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitCommitsShaCode_755040(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Get a Commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   shaCode: JString (required)
  ##          : SHA-1 code.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `shaCode` field"
  var valid_755042 = path.getOrDefault("shaCode")
  valid_755042 = validateParameter(valid_755042, JString, required = true,
                                 default = nil)
  if valid_755042 != nil:
    section.add "shaCode", valid_755042
  var valid_755043 = path.getOrDefault("repo")
  valid_755043 = validateParameter(valid_755043, JString, required = true,
                                 default = nil)
  if valid_755043 != nil:
    section.add "repo", valid_755043
  var valid_755044 = path.getOrDefault("owner")
  valid_755044 = validateParameter(valid_755044, JString, required = true,
                                 default = nil)
  if valid_755044 != nil:
    section.add "owner", valid_755044
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755045 = header.getOrDefault("Accept")
  valid_755045 = validateParameter(valid_755045, JString, required = false,
                                 default = nil)
  if valid_755045 != nil:
    section.add "Accept", valid_755045
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755046: Call_GetReposOwnerRepoGitCommitsShaCode_755039;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a Commit.
  ## 
  let valid = call_755046.validator(path, query, header, formData, body, _)
  let scheme = call_755046.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755046.makeUrl(scheme.get, call_755046.host, call_755046.base,
                             call_755046.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755046, uri, valid, _)

proc call*(call_755047: Call_GetReposOwnerRepoGitCommitsShaCode_755039;
          shaCode: string; repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitCommitsShaCode
  ## Get a Commit.
  ##   shaCode: string (required)
  ##          : SHA-1 code.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755048 = newJObject()
  var header_755049 = newJObject()
  add(path_755048, "shaCode", newJString(shaCode))
  add(header_755049, "Accept", newJString(Accept))
  add(path_755048, "repo", newJString(repo))
  add(path_755048, "owner", newJString(owner))
  result = call_755047.call(path_755048, nil, header_755049, nil, nil)

var getReposOwnerRepoGitCommitsShaCode* = Call_GetReposOwnerRepoGitCommitsShaCode_755039(
    name: "getReposOwnerRepoGitCommitsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/commits/{shaCode}",
    validator: validate_GetReposOwnerRepoGitCommitsShaCode_755040, base: "/",
    makeUrl: url_GetReposOwnerRepoGitCommitsShaCode_755041,
    schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitRefs_755060 = ref object of OpenApiRestCall_753573
proc url_PostReposOwnerRepoGitRefs_755062(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitRefs_755061(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Create a Reference
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755063 = path.getOrDefault("repo")
  valid_755063 = validateParameter(valid_755063, JString, required = true,
                                 default = nil)
  if valid_755063 != nil:
    section.add "repo", valid_755063
  var valid_755064 = path.getOrDefault("owner")
  valid_755064 = validateParameter(valid_755064, JString, required = true,
                                 default = nil)
  if valid_755064 != nil:
    section.add "owner", valid_755064
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755065 = header.getOrDefault("Accept")
  valid_755065 = validateParameter(valid_755065, JString, required = false,
                                 default = nil)
  if valid_755065 != nil:
    section.add "Accept", valid_755065
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_755067: Call_PostReposOwnerRepoGitRefs_755060;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a Reference
  ## 
  let valid = call_755067.validator(path, query, header, formData, body, _)
  let scheme = call_755067.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755067.makeUrl(scheme.get, call_755067.host, call_755067.base,
                             call_755067.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755067, uri, valid, _)

proc call*(call_755068: Call_PostReposOwnerRepoGitRefs_755060; repo: string;
          body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitRefs
  ## Create a Reference
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755069 = newJObject()
  var header_755070 = newJObject()
  var body_755071 = newJObject()
  add(header_755070, "Accept", newJString(Accept))
  add(path_755069, "repo", newJString(repo))
  if body != nil:
    body_755071 = body
  add(path_755069, "owner", newJString(owner))
  result = call_755068.call(path_755069, nil, header_755070, nil, body_755071)

var postReposOwnerRepoGitRefs* = Call_PostReposOwnerRepoGitRefs_755060(
    name: "postReposOwnerRepoGitRefs", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs",
    validator: validate_PostReposOwnerRepoGitRefs_755061, base: "/",
    makeUrl: url_PostReposOwnerRepoGitRefs_755062, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitRefs_755050 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoGitRefs_755052(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitRefs_755051(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Get all References
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755053 = path.getOrDefault("repo")
  valid_755053 = validateParameter(valid_755053, JString, required = true,
                                 default = nil)
  if valid_755053 != nil:
    section.add "repo", valid_755053
  var valid_755054 = path.getOrDefault("owner")
  valid_755054 = validateParameter(valid_755054, JString, required = true,
                                 default = nil)
  if valid_755054 != nil:
    section.add "owner", valid_755054
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755055 = header.getOrDefault("Accept")
  valid_755055 = validateParameter(valid_755055, JString, required = false,
                                 default = nil)
  if valid_755055 != nil:
    section.add "Accept", valid_755055
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755056: Call_GetReposOwnerRepoGitRefs_755050; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get all References
  ## 
  let valid = call_755056.validator(path, query, header, formData, body, _)
  let scheme = call_755056.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755056.makeUrl(scheme.get, call_755056.host, call_755056.base,
                             call_755056.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755056, uri, valid, _)

proc call*(call_755057: Call_GetReposOwnerRepoGitRefs_755050; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitRefs
  ## Get all References
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755058 = newJObject()
  var header_755059 = newJObject()
  add(header_755059, "Accept", newJString(Accept))
  add(path_755058, "repo", newJString(repo))
  add(path_755058, "owner", newJString(owner))
  result = call_755057.call(path_755058, nil, header_755059, nil, nil)

var getReposOwnerRepoGitRefs* = Call_GetReposOwnerRepoGitRefs_755050(
    name: "getReposOwnerRepoGitRefs", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs",
    validator: validate_GetReposOwnerRepoGitRefs_755051, base: "/",
    makeUrl: url_GetReposOwnerRepoGitRefs_755052, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitRefsRef_755072 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoGitRefsRef_755074(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitRefsRef_755073(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Get a Reference
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ref: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ref` field"
  var valid_755075 = path.getOrDefault("ref")
  valid_755075 = validateParameter(valid_755075, JString, required = true,
                                 default = nil)
  if valid_755075 != nil:
    section.add "ref", valid_755075
  var valid_755076 = path.getOrDefault("repo")
  valid_755076 = validateParameter(valid_755076, JString, required = true,
                                 default = nil)
  if valid_755076 != nil:
    section.add "repo", valid_755076
  var valid_755077 = path.getOrDefault("owner")
  valid_755077 = validateParameter(valid_755077, JString, required = true,
                                 default = nil)
  if valid_755077 != nil:
    section.add "owner", valid_755077
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755078 = header.getOrDefault("Accept")
  valid_755078 = validateParameter(valid_755078, JString, required = false,
                                 default = nil)
  if valid_755078 != nil:
    section.add "Accept", valid_755078
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755079: Call_GetReposOwnerRepoGitRefsRef_755072;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a Reference
  ## 
  let valid = call_755079.validator(path, query, header, formData, body, _)
  let scheme = call_755079.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755079.makeUrl(scheme.get, call_755079.host, call_755079.base,
                             call_755079.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755079, uri, valid, _)

proc call*(call_755080: Call_GetReposOwnerRepoGitRefsRef_755072; `ref`: string;
          repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitRefsRef
  ## Get a Reference
  ##   ref: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755081 = newJObject()
  var header_755082 = newJObject()
  add(path_755081, "ref", newJString(`ref`))
  add(header_755082, "Accept", newJString(Accept))
  add(path_755081, "repo", newJString(repo))
  add(path_755081, "owner", newJString(owner))
  result = call_755080.call(path_755081, nil, header_755082, nil, nil)

var getReposOwnerRepoGitRefsRef* = Call_GetReposOwnerRepoGitRefsRef_755072(
    name: "getReposOwnerRepoGitRefsRef", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs/{ref}",
    validator: validate_GetReposOwnerRepoGitRefsRef_755073, base: "/",
    makeUrl: url_GetReposOwnerRepoGitRefsRef_755074, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoGitRefsRef_755094 = ref object of OpenApiRestCall_753573
proc url_PatchReposOwnerRepoGitRefsRef_755096(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoGitRefsRef_755095(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Update a Reference
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ref: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ref` field"
  var valid_755097 = path.getOrDefault("ref")
  valid_755097 = validateParameter(valid_755097, JString, required = true,
                                 default = nil)
  if valid_755097 != nil:
    section.add "ref", valid_755097
  var valid_755098 = path.getOrDefault("repo")
  valid_755098 = validateParameter(valid_755098, JString, required = true,
                                 default = nil)
  if valid_755098 != nil:
    section.add "repo", valid_755098
  var valid_755099 = path.getOrDefault("owner")
  valid_755099 = validateParameter(valid_755099, JString, required = true,
                                 default = nil)
  if valid_755099 != nil:
    section.add "owner", valid_755099
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755100 = header.getOrDefault("Accept")
  valid_755100 = validateParameter(valid_755100, JString, required = false,
                                 default = nil)
  if valid_755100 != nil:
    section.add "Accept", valid_755100
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_755102: Call_PatchReposOwnerRepoGitRefsRef_755094;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Update a Reference
  ## 
  let valid = call_755102.validator(path, query, header, formData, body, _)
  let scheme = call_755102.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755102.makeUrl(scheme.get, call_755102.host, call_755102.base,
                             call_755102.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755102, uri, valid, _)

proc call*(call_755103: Call_PatchReposOwnerRepoGitRefsRef_755094; `ref`: string;
          repo: string; body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoGitRefsRef
  ## Update a Reference
  ##   ref: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755104 = newJObject()
  var header_755105 = newJObject()
  var body_755106 = newJObject()
  add(path_755104, "ref", newJString(`ref`))
  add(header_755105, "Accept", newJString(Accept))
  add(path_755104, "repo", newJString(repo))
  if body != nil:
    body_755106 = body
  add(path_755104, "owner", newJString(owner))
  result = call_755103.call(path_755104, nil, header_755105, nil, body_755106)

var patchReposOwnerRepoGitRefsRef* = Call_PatchReposOwnerRepoGitRefsRef_755094(
    name: "patchReposOwnerRepoGitRefsRef", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs/{ref}",
    validator: validate_PatchReposOwnerRepoGitRefsRef_755095, base: "/",
    makeUrl: url_PatchReposOwnerRepoGitRefsRef_755096, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoGitRefsRef_755083 = ref object of OpenApiRestCall_753573
proc url_DeleteReposOwnerRepoGitRefsRef_755085(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoGitRefsRef_755084(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Delete a Reference
  ## Example: Deleting a branch: DELETE /repos/octocat/Hello-World/git/refs/heads/feature-a
  ## Example: Deleting a tag:        DELETE /repos/octocat/Hello-World/git/refs/tags/v1.0
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ref: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ref` field"
  var valid_755086 = path.getOrDefault("ref")
  valid_755086 = validateParameter(valid_755086, JString, required = true,
                                 default = nil)
  if valid_755086 != nil:
    section.add "ref", valid_755086
  var valid_755087 = path.getOrDefault("repo")
  valid_755087 = validateParameter(valid_755087, JString, required = true,
                                 default = nil)
  if valid_755087 != nil:
    section.add "repo", valid_755087
  var valid_755088 = path.getOrDefault("owner")
  valid_755088 = validateParameter(valid_755088, JString, required = true,
                                 default = nil)
  if valid_755088 != nil:
    section.add "owner", valid_755088
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755089 = header.getOrDefault("Accept")
  valid_755089 = validateParameter(valid_755089, JString, required = false,
                                 default = nil)
  if valid_755089 != nil:
    section.add "Accept", valid_755089
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755090: Call_DeleteReposOwnerRepoGitRefsRef_755083;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a Reference
  ## Example: Deleting a branch: DELETE /repos/octocat/Hello-World/git/refs/heads/feature-a
  ## Example: Deleting a tag:        DELETE /repos/octocat/Hello-World/git/refs/tags/v1.0
  ## 
  ## 
  let valid = call_755090.validator(path, query, header, formData, body, _)
  let scheme = call_755090.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755090.makeUrl(scheme.get, call_755090.host, call_755090.base,
                             call_755090.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755090, uri, valid, _)

proc call*(call_755091: Call_DeleteReposOwnerRepoGitRefsRef_755083; `ref`: string;
          repo: string; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoGitRefsRef
  ## Delete a Reference
  ## Example: Deleting a branch: DELETE /repos/octocat/Hello-World/git/refs/heads/feature-a
  ## Example: Deleting a tag:        DELETE /repos/octocat/Hello-World/git/refs/tags/v1.0
  ## 
  ##   ref: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755092 = newJObject()
  var header_755093 = newJObject()
  add(path_755092, "ref", newJString(`ref`))
  add(header_755093, "Accept", newJString(Accept))
  add(path_755092, "repo", newJString(repo))
  add(path_755092, "owner", newJString(owner))
  result = call_755091.call(path_755092, nil, header_755093, nil, nil)

var deleteReposOwnerRepoGitRefsRef* = Call_DeleteReposOwnerRepoGitRefsRef_755083(
    name: "deleteReposOwnerRepoGitRefsRef", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs/{ref}",
    validator: validate_DeleteReposOwnerRepoGitRefsRef_755084, base: "/",
    makeUrl: url_DeleteReposOwnerRepoGitRefsRef_755085, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitTags_755107 = ref object of OpenApiRestCall_753573
proc url_PostReposOwnerRepoGitTags_755109(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/tags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitTags_755108(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Create a Tag Object.
  ## Note that creating a tag object does not create the reference that makes a
  ## tag in Git. If you want to create an annotated tag in Git, you have to do
  ## this call to create the tag object, and then create the refs/tags/[tag]
  ## reference. If you want to create a lightweight tag, you only have to create
  ## the tag reference - this call would be unnecessary.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755110 = path.getOrDefault("repo")
  valid_755110 = validateParameter(valid_755110, JString, required = true,
                                 default = nil)
  if valid_755110 != nil:
    section.add "repo", valid_755110
  var valid_755111 = path.getOrDefault("owner")
  valid_755111 = validateParameter(valid_755111, JString, required = true,
                                 default = nil)
  if valid_755111 != nil:
    section.add "owner", valid_755111
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755112 = header.getOrDefault("Accept")
  valid_755112 = validateParameter(valid_755112, JString, required = false,
                                 default = nil)
  if valid_755112 != nil:
    section.add "Accept", valid_755112
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_755114: Call_PostReposOwnerRepoGitTags_755107;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a Tag Object.
  ## Note that creating a tag object does not create the reference that makes a
  ## tag in Git. If you want to create an annotated tag in Git, you have to do
  ## this call to create the tag object, and then create the refs/tags/[tag]
  ## reference. If you want to create a lightweight tag, you only have to create
  ## the tag reference - this call would be unnecessary.
  ## 
  ## 
  let valid = call_755114.validator(path, query, header, formData, body, _)
  let scheme = call_755114.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755114.makeUrl(scheme.get, call_755114.host, call_755114.base,
                             call_755114.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755114, uri, valid, _)

proc call*(call_755115: Call_PostReposOwnerRepoGitTags_755107; repo: string;
          body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitTags
  ## Create a Tag Object.
  ## Note that creating a tag object does not create the reference that makes a
  ## tag in Git. If you want to create an annotated tag in Git, you have to do
  ## this call to create the tag object, and then create the refs/tags/[tag]
  ## reference. If you want to create a lightweight tag, you only have to create
  ## the tag reference - this call would be unnecessary.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755116 = newJObject()
  var header_755117 = newJObject()
  var body_755118 = newJObject()
  add(header_755117, "Accept", newJString(Accept))
  add(path_755116, "repo", newJString(repo))
  if body != nil:
    body_755118 = body
  add(path_755116, "owner", newJString(owner))
  result = call_755115.call(path_755116, nil, header_755117, nil, body_755118)

var postReposOwnerRepoGitTags* = Call_PostReposOwnerRepoGitTags_755107(
    name: "postReposOwnerRepoGitTags", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/tags",
    validator: validate_PostReposOwnerRepoGitTags_755108, base: "/",
    makeUrl: url_PostReposOwnerRepoGitTags_755109, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitTagsShaCode_755119 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoGitTagsShaCode_755121(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/tags/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitTagsShaCode_755120(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Get a Tag.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   shaCode: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `shaCode` field"
  var valid_755122 = path.getOrDefault("shaCode")
  valid_755122 = validateParameter(valid_755122, JString, required = true,
                                 default = nil)
  if valid_755122 != nil:
    section.add "shaCode", valid_755122
  var valid_755123 = path.getOrDefault("repo")
  valid_755123 = validateParameter(valid_755123, JString, required = true,
                                 default = nil)
  if valid_755123 != nil:
    section.add "repo", valid_755123
  var valid_755124 = path.getOrDefault("owner")
  valid_755124 = validateParameter(valid_755124, JString, required = true,
                                 default = nil)
  if valid_755124 != nil:
    section.add "owner", valid_755124
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755125 = header.getOrDefault("Accept")
  valid_755125 = validateParameter(valid_755125, JString, required = false,
                                 default = nil)
  if valid_755125 != nil:
    section.add "Accept", valid_755125
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755126: Call_GetReposOwnerRepoGitTagsShaCode_755119;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a Tag.
  ## 
  let valid = call_755126.validator(path, query, header, formData, body, _)
  let scheme = call_755126.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755126.makeUrl(scheme.get, call_755126.host, call_755126.base,
                             call_755126.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755126, uri, valid, _)

proc call*(call_755127: Call_GetReposOwnerRepoGitTagsShaCode_755119;
          shaCode: string; repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitTagsShaCode
  ## Get a Tag.
  ##   shaCode: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755128 = newJObject()
  var header_755129 = newJObject()
  add(path_755128, "shaCode", newJString(shaCode))
  add(header_755129, "Accept", newJString(Accept))
  add(path_755128, "repo", newJString(repo))
  add(path_755128, "owner", newJString(owner))
  result = call_755127.call(path_755128, nil, header_755129, nil, nil)

var getReposOwnerRepoGitTagsShaCode* = Call_GetReposOwnerRepoGitTagsShaCode_755119(
    name: "getReposOwnerRepoGitTagsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/tags/{shaCode}",
    validator: validate_GetReposOwnerRepoGitTagsShaCode_755120, base: "/",
    makeUrl: url_GetReposOwnerRepoGitTagsShaCode_755121, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitTrees_755130 = ref object of OpenApiRestCall_753573
proc url_PostReposOwnerRepoGitTrees_755132(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/trees")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitTrees_755131(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Create a Tree.
  ## The tree creation API will take nested entries as well. If both a tree and
  ## a nested path modifying that tree are specified, it will overwrite the
  ## contents of that tree with the new path contents and write a new tree out.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755133 = path.getOrDefault("repo")
  valid_755133 = validateParameter(valid_755133, JString, required = true,
                                 default = nil)
  if valid_755133 != nil:
    section.add "repo", valid_755133
  var valid_755134 = path.getOrDefault("owner")
  valid_755134 = validateParameter(valid_755134, JString, required = true,
                                 default = nil)
  if valid_755134 != nil:
    section.add "owner", valid_755134
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755135 = header.getOrDefault("Accept")
  valid_755135 = validateParameter(valid_755135, JString, required = false,
                                 default = nil)
  if valid_755135 != nil:
    section.add "Accept", valid_755135
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_755137: Call_PostReposOwnerRepoGitTrees_755130;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a Tree.
  ## The tree creation API will take nested entries as well. If both a tree and
  ## a nested path modifying that tree are specified, it will overwrite the
  ## contents of that tree with the new path contents and write a new tree out.
  ## 
  ## 
  let valid = call_755137.validator(path, query, header, formData, body, _)
  let scheme = call_755137.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755137.makeUrl(scheme.get, call_755137.host, call_755137.base,
                             call_755137.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755137, uri, valid, _)

proc call*(call_755138: Call_PostReposOwnerRepoGitTrees_755130; repo: string;
          body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitTrees
  ## Create a Tree.
  ## The tree creation API will take nested entries as well. If both a tree and
  ## a nested path modifying that tree are specified, it will overwrite the
  ## contents of that tree with the new path contents and write a new tree out.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755139 = newJObject()
  var header_755140 = newJObject()
  var body_755141 = newJObject()
  add(header_755140, "Accept", newJString(Accept))
  add(path_755139, "repo", newJString(repo))
  if body != nil:
    body_755141 = body
  add(path_755139, "owner", newJString(owner))
  result = call_755138.call(path_755139, nil, header_755140, nil, body_755141)

var postReposOwnerRepoGitTrees* = Call_PostReposOwnerRepoGitTrees_755130(
    name: "postReposOwnerRepoGitTrees", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/trees",
    validator: validate_PostReposOwnerRepoGitTrees_755131, base: "/",
    makeUrl: url_PostReposOwnerRepoGitTrees_755132, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitTreesShaCode_755142 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoGitTreesShaCode_755144(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/trees/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitTreesShaCode_755143(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Get a Tree.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   shaCode: JString (required)
  ##          : Tree SHA.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `shaCode` field"
  var valid_755145 = path.getOrDefault("shaCode")
  valid_755145 = validateParameter(valid_755145, JString, required = true,
                                 default = nil)
  if valid_755145 != nil:
    section.add "shaCode", valid_755145
  var valid_755146 = path.getOrDefault("repo")
  valid_755146 = validateParameter(valid_755146, JString, required = true,
                                 default = nil)
  if valid_755146 != nil:
    section.add "repo", valid_755146
  var valid_755147 = path.getOrDefault("owner")
  valid_755147 = validateParameter(valid_755147, JString, required = true,
                                 default = nil)
  if valid_755147 != nil:
    section.add "owner", valid_755147
  result.add "path", section
  ## parameters in `query` object:
  ##   recursive: JInt
  ##            : Get a Tree Recursively. (0 or 1)
  section = newJObject()
  var valid_755148 = query.getOrDefault("recursive")
  valid_755148 = validateParameter(valid_755148, JInt, required = false, default = nil)
  if valid_755148 != nil:
    section.add "recursive", valid_755148
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755149 = header.getOrDefault("Accept")
  valid_755149 = validateParameter(valid_755149, JString, required = false,
                                 default = nil)
  if valid_755149 != nil:
    section.add "Accept", valid_755149
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755150: Call_GetReposOwnerRepoGitTreesShaCode_755142;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a Tree.
  ## 
  let valid = call_755150.validator(path, query, header, formData, body, _)
  let scheme = call_755150.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755150.makeUrl(scheme.get, call_755150.host, call_755150.base,
                             call_755150.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755150, uri, valid, _)

proc call*(call_755151: Call_GetReposOwnerRepoGitTreesShaCode_755142;
          shaCode: string; repo: string; owner: string; Accept: string = "";
          recursive: int = 0): Recallable =
  ## getReposOwnerRepoGitTreesShaCode
  ## Get a Tree.
  ##   shaCode: string (required)
  ##          : Tree SHA.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   recursive: int
  ##            : Get a Tree Recursively. (0 or 1)
  var path_755152 = newJObject()
  var query_755153 = newJObject()
  var header_755154 = newJObject()
  add(path_755152, "shaCode", newJString(shaCode))
  add(header_755154, "Accept", newJString(Accept))
  add(path_755152, "repo", newJString(repo))
  add(path_755152, "owner", newJString(owner))
  add(query_755153, "recursive", newJInt(recursive))
  result = call_755151.call(path_755152, query_755153, header_755154, nil, nil)

var getReposOwnerRepoGitTreesShaCode* = Call_GetReposOwnerRepoGitTreesShaCode_755142(
    name: "getReposOwnerRepoGitTreesShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/trees/{shaCode}",
    validator: validate_GetReposOwnerRepoGitTreesShaCode_755143, base: "/",
    makeUrl: url_GetReposOwnerRepoGitTreesShaCode_755144, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoHooks_755165 = ref object of OpenApiRestCall_753573
proc url_PostReposOwnerRepoHooks_755167(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoHooks_755166(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Create a hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755168 = path.getOrDefault("repo")
  valid_755168 = validateParameter(valid_755168, JString, required = true,
                                 default = nil)
  if valid_755168 != nil:
    section.add "repo", valid_755168
  var valid_755169 = path.getOrDefault("owner")
  valid_755169 = validateParameter(valid_755169, JString, required = true,
                                 default = nil)
  if valid_755169 != nil:
    section.add "owner", valid_755169
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755170 = header.getOrDefault("Accept")
  valid_755170 = validateParameter(valid_755170, JString, required = false,
                                 default = nil)
  if valid_755170 != nil:
    section.add "Accept", valid_755170
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_755172: Call_PostReposOwnerRepoHooks_755165; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a hook.
  ## 
  let valid = call_755172.validator(path, query, header, formData, body, _)
  let scheme = call_755172.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755172.makeUrl(scheme.get, call_755172.host, call_755172.base,
                             call_755172.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755172, uri, valid, _)

proc call*(call_755173: Call_PostReposOwnerRepoHooks_755165; repo: string;
          body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoHooks
  ## Create a hook.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755174 = newJObject()
  var header_755175 = newJObject()
  var body_755176 = newJObject()
  add(header_755175, "Accept", newJString(Accept))
  add(path_755174, "repo", newJString(repo))
  if body != nil:
    body_755176 = body
  add(path_755174, "owner", newJString(owner))
  result = call_755173.call(path_755174, nil, header_755175, nil, body_755176)

var postReposOwnerRepoHooks* = Call_PostReposOwnerRepoHooks_755165(
    name: "postReposOwnerRepoHooks", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks",
    validator: validate_PostReposOwnerRepoHooks_755166, base: "/",
    makeUrl: url_PostReposOwnerRepoHooks_755167, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoHooks_755155 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoHooks_755157(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoHooks_755156(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Get list of hooks.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755158 = path.getOrDefault("repo")
  valid_755158 = validateParameter(valid_755158, JString, required = true,
                                 default = nil)
  if valid_755158 != nil:
    section.add "repo", valid_755158
  var valid_755159 = path.getOrDefault("owner")
  valid_755159 = validateParameter(valid_755159, JString, required = true,
                                 default = nil)
  if valid_755159 != nil:
    section.add "owner", valid_755159
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755160 = header.getOrDefault("Accept")
  valid_755160 = validateParameter(valid_755160, JString, required = false,
                                 default = nil)
  if valid_755160 != nil:
    section.add "Accept", valid_755160
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755161: Call_GetReposOwnerRepoHooks_755155; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get list of hooks.
  ## 
  let valid = call_755161.validator(path, query, header, formData, body, _)
  let scheme = call_755161.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755161.makeUrl(scheme.get, call_755161.host, call_755161.base,
                             call_755161.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755161, uri, valid, _)

proc call*(call_755162: Call_GetReposOwnerRepoHooks_755155; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoHooks
  ## Get list of hooks.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755163 = newJObject()
  var header_755164 = newJObject()
  add(header_755164, "Accept", newJString(Accept))
  add(path_755163, "repo", newJString(repo))
  add(path_755163, "owner", newJString(owner))
  result = call_755162.call(path_755163, nil, header_755164, nil, nil)

var getReposOwnerRepoHooks* = Call_GetReposOwnerRepoHooks_755155(
    name: "getReposOwnerRepoHooks", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks",
    validator: validate_GetReposOwnerRepoHooks_755156, base: "/",
    makeUrl: url_GetReposOwnerRepoHooks_755157, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoHooksHookId_755177 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoHooksHookId_755179(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hookId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoHooksHookId_755178(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Get single hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   hookId: JInt (required)
  ##         : Id of hook.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `hookId` field"
  var valid_755180 = path.getOrDefault("hookId")
  valid_755180 = validateParameter(valid_755180, JInt, required = true, default = nil)
  if valid_755180 != nil:
    section.add "hookId", valid_755180
  var valid_755181 = path.getOrDefault("repo")
  valid_755181 = validateParameter(valid_755181, JString, required = true,
                                 default = nil)
  if valid_755181 != nil:
    section.add "repo", valid_755181
  var valid_755182 = path.getOrDefault("owner")
  valid_755182 = validateParameter(valid_755182, JString, required = true,
                                 default = nil)
  if valid_755182 != nil:
    section.add "owner", valid_755182
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755183 = header.getOrDefault("Accept")
  valid_755183 = validateParameter(valid_755183, JString, required = false,
                                 default = nil)
  if valid_755183 != nil:
    section.add "Accept", valid_755183
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755184: Call_GetReposOwnerRepoHooksHookId_755177;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get single hook.
  ## 
  let valid = call_755184.validator(path, query, header, formData, body, _)
  let scheme = call_755184.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755184.makeUrl(scheme.get, call_755184.host, call_755184.base,
                             call_755184.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755184, uri, valid, _)

proc call*(call_755185: Call_GetReposOwnerRepoHooksHookId_755177; hookId: int;
          repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoHooksHookId
  ## Get single hook.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   hookId: int (required)
  ##         : Id of hook.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755186 = newJObject()
  var header_755187 = newJObject()
  add(header_755187, "Accept", newJString(Accept))
  add(path_755186, "hookId", newJInt(hookId))
  add(path_755186, "repo", newJString(repo))
  add(path_755186, "owner", newJString(owner))
  result = call_755185.call(path_755186, nil, header_755187, nil, nil)

var getReposOwnerRepoHooksHookId* = Call_GetReposOwnerRepoHooksHookId_755177(
    name: "getReposOwnerRepoHooksHookId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}",
    validator: validate_GetReposOwnerRepoHooksHookId_755178, base: "/",
    makeUrl: url_GetReposOwnerRepoHooksHookId_755179, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoHooksHookId_755199 = ref object of OpenApiRestCall_753573
proc url_PatchReposOwnerRepoHooksHookId_755201(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hookId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoHooksHookId_755200(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Edit a hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   hookId: JInt (required)
  ##         : Id of hook.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `hookId` field"
  var valid_755202 = path.getOrDefault("hookId")
  valid_755202 = validateParameter(valid_755202, JInt, required = true, default = nil)
  if valid_755202 != nil:
    section.add "hookId", valid_755202
  var valid_755203 = path.getOrDefault("repo")
  valid_755203 = validateParameter(valid_755203, JString, required = true,
                                 default = nil)
  if valid_755203 != nil:
    section.add "repo", valid_755203
  var valid_755204 = path.getOrDefault("owner")
  valid_755204 = validateParameter(valid_755204, JString, required = true,
                                 default = nil)
  if valid_755204 != nil:
    section.add "owner", valid_755204
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755205 = header.getOrDefault("Accept")
  valid_755205 = validateParameter(valid_755205, JString, required = false,
                                 default = nil)
  if valid_755205 != nil:
    section.add "Accept", valid_755205
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_755207: Call_PatchReposOwnerRepoHooksHookId_755199;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit a hook.
  ## 
  let valid = call_755207.validator(path, query, header, formData, body, _)
  let scheme = call_755207.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755207.makeUrl(scheme.get, call_755207.host, call_755207.base,
                             call_755207.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755207, uri, valid, _)

proc call*(call_755208: Call_PatchReposOwnerRepoHooksHookId_755199; hookId: int;
          repo: string; body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoHooksHookId
  ## Edit a hook.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   hookId: int (required)
  ##         : Id of hook.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755209 = newJObject()
  var header_755210 = newJObject()
  var body_755211 = newJObject()
  add(header_755210, "Accept", newJString(Accept))
  add(path_755209, "hookId", newJInt(hookId))
  add(path_755209, "repo", newJString(repo))
  if body != nil:
    body_755211 = body
  add(path_755209, "owner", newJString(owner))
  result = call_755208.call(path_755209, nil, header_755210, nil, body_755211)

var patchReposOwnerRepoHooksHookId* = Call_PatchReposOwnerRepoHooksHookId_755199(
    name: "patchReposOwnerRepoHooksHookId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}",
    validator: validate_PatchReposOwnerRepoHooksHookId_755200, base: "/",
    makeUrl: url_PatchReposOwnerRepoHooksHookId_755201, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoHooksHookId_755188 = ref object of OpenApiRestCall_753573
proc url_DeleteReposOwnerRepoHooksHookId_755190(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hookId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoHooksHookId_755189(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Delete a hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   hookId: JInt (required)
  ##         : Id of hook.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `hookId` field"
  var valid_755191 = path.getOrDefault("hookId")
  valid_755191 = validateParameter(valid_755191, JInt, required = true, default = nil)
  if valid_755191 != nil:
    section.add "hookId", valid_755191
  var valid_755192 = path.getOrDefault("repo")
  valid_755192 = validateParameter(valid_755192, JString, required = true,
                                 default = nil)
  if valid_755192 != nil:
    section.add "repo", valid_755192
  var valid_755193 = path.getOrDefault("owner")
  valid_755193 = validateParameter(valid_755193, JString, required = true,
                                 default = nil)
  if valid_755193 != nil:
    section.add "owner", valid_755193
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755194 = header.getOrDefault("Accept")
  valid_755194 = validateParameter(valid_755194, JString, required = false,
                                 default = nil)
  if valid_755194 != nil:
    section.add "Accept", valid_755194
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755195: Call_DeleteReposOwnerRepoHooksHookId_755188;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a hook.
  ## 
  let valid = call_755195.validator(path, query, header, formData, body, _)
  let scheme = call_755195.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755195.makeUrl(scheme.get, call_755195.host, call_755195.base,
                             call_755195.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755195, uri, valid, _)

proc call*(call_755196: Call_DeleteReposOwnerRepoHooksHookId_755188; hookId: int;
          repo: string; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoHooksHookId
  ## Delete a hook.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   hookId: int (required)
  ##         : Id of hook.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755197 = newJObject()
  var header_755198 = newJObject()
  add(header_755198, "Accept", newJString(Accept))
  add(path_755197, "hookId", newJInt(hookId))
  add(path_755197, "repo", newJString(repo))
  add(path_755197, "owner", newJString(owner))
  result = call_755196.call(path_755197, nil, header_755198, nil, nil)

var deleteReposOwnerRepoHooksHookId* = Call_DeleteReposOwnerRepoHooksHookId_755188(
    name: "deleteReposOwnerRepoHooksHookId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}",
    validator: validate_DeleteReposOwnerRepoHooksHookId_755189, base: "/",
    makeUrl: url_DeleteReposOwnerRepoHooksHookId_755190, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoHooksHookIdTests_755212 = ref object of OpenApiRestCall_753573
proc url_PostReposOwnerRepoHooksHookIdTests_755214(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hookId"),
               (kind: ConstantSegment, value: "/tests")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoHooksHookIdTests_755213(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Test a push hook.
  ## This will trigger the hook with the latest push to the current repository
  ## if the hook is subscribed to push events. If the hook is not subscribed
  ## to push events, the server will respond with 204 but no test POST will
  ## be generated.
  ## Note: Previously /repos/:owner/:repo/hooks/:id/tes
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   hookId: JInt (required)
  ##         : Id of hook.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `hookId` field"
  var valid_755215 = path.getOrDefault("hookId")
  valid_755215 = validateParameter(valid_755215, JInt, required = true, default = nil)
  if valid_755215 != nil:
    section.add "hookId", valid_755215
  var valid_755216 = path.getOrDefault("repo")
  valid_755216 = validateParameter(valid_755216, JString, required = true,
                                 default = nil)
  if valid_755216 != nil:
    section.add "repo", valid_755216
  var valid_755217 = path.getOrDefault("owner")
  valid_755217 = validateParameter(valid_755217, JString, required = true,
                                 default = nil)
  if valid_755217 != nil:
    section.add "owner", valid_755217
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755218 = header.getOrDefault("Accept")
  valid_755218 = validateParameter(valid_755218, JString, required = false,
                                 default = nil)
  if valid_755218 != nil:
    section.add "Accept", valid_755218
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755219: Call_PostReposOwnerRepoHooksHookIdTests_755212;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Test a push hook.
  ## This will trigger the hook with the latest push to the current repository
  ## if the hook is subscribed to push events. If the hook is not subscribed
  ## to push events, the server will respond with 204 but no test POST will
  ## be generated.
  ## Note: Previously /repos/:owner/:repo/hooks/:id/tes
  ## 
  ## 
  let valid = call_755219.validator(path, query, header, formData, body, _)
  let scheme = call_755219.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755219.makeUrl(scheme.get, call_755219.host, call_755219.base,
                             call_755219.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755219, uri, valid, _)

proc call*(call_755220: Call_PostReposOwnerRepoHooksHookIdTests_755212;
          hookId: int; repo: string; owner: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoHooksHookIdTests
  ## Test a push hook.
  ## This will trigger the hook with the latest push to the current repository
  ## if the hook is subscribed to push events. If the hook is not subscribed
  ## to push events, the server will respond with 204 but no test POST will
  ## be generated.
  ## Note: Previously /repos/:owner/:repo/hooks/:id/tes
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   hookId: int (required)
  ##         : Id of hook.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755221 = newJObject()
  var header_755222 = newJObject()
  add(header_755222, "Accept", newJString(Accept))
  add(path_755221, "hookId", newJInt(hookId))
  add(path_755221, "repo", newJString(repo))
  add(path_755221, "owner", newJString(owner))
  result = call_755220.call(path_755221, nil, header_755222, nil, nil)

var postReposOwnerRepoHooksHookIdTests* = Call_PostReposOwnerRepoHooksHookIdTests_755212(
    name: "postReposOwnerRepoHooksHookIdTests", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}/tests",
    validator: validate_PostReposOwnerRepoHooksHookIdTests_755213, base: "/",
    makeUrl: url_PostReposOwnerRepoHooksHookIdTests_755214,
    schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoIssues_755240 = ref object of OpenApiRestCall_753573
proc url_PostReposOwnerRepoIssues_755242(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoIssues_755241(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Create an issue.
  ## Any user with pull access to a repository can create an issue.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755243 = path.getOrDefault("repo")
  valid_755243 = validateParameter(valid_755243, JString, required = true,
                                 default = nil)
  if valid_755243 != nil:
    section.add "repo", valid_755243
  var valid_755244 = path.getOrDefault("owner")
  valid_755244 = validateParameter(valid_755244, JString, required = true,
                                 default = nil)
  if valid_755244 != nil:
    section.add "owner", valid_755244
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755245 = header.getOrDefault("Accept")
  valid_755245 = validateParameter(valid_755245, JString, required = false,
                                 default = nil)
  if valid_755245 != nil:
    section.add "Accept", valid_755245
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_755247: Call_PostReposOwnerRepoIssues_755240; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Create an issue.
  ## Any user with pull access to a repository can create an issue.
  ## 
  ## 
  let valid = call_755247.validator(path, query, header, formData, body, _)
  let scheme = call_755247.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755247.makeUrl(scheme.get, call_755247.host, call_755247.base,
                             call_755247.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755247, uri, valid, _)

proc call*(call_755248: Call_PostReposOwnerRepoIssues_755240; repo: string;
          body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoIssues
  ## Create an issue.
  ## Any user with pull access to a repository can create an issue.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755249 = newJObject()
  var header_755250 = newJObject()
  var body_755251 = newJObject()
  add(header_755250, "Accept", newJString(Accept))
  add(path_755249, "repo", newJString(repo))
  if body != nil:
    body_755251 = body
  add(path_755249, "owner", newJString(owner))
  result = call_755248.call(path_755249, nil, header_755250, nil, body_755251)

var postReposOwnerRepoIssues* = Call_PostReposOwnerRepoIssues_755240(
    name: "postReposOwnerRepoIssues", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues",
    validator: validate_PostReposOwnerRepoIssues_755241, base: "/",
    makeUrl: url_PostReposOwnerRepoIssues_755242, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssues_755223 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoIssues_755225(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssues_755224(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List issues for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755226 = path.getOrDefault("repo")
  valid_755226 = validateParameter(valid_755226, JString, required = true,
                                 default = nil)
  if valid_755226 != nil:
    section.add "repo", valid_755226
  var valid_755227 = path.getOrDefault("owner")
  valid_755227 = validateParameter(valid_755227, JString, required = true,
                                 default = nil)
  if valid_755227 != nil:
    section.add "owner", valid_755227
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString (required)
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  ##   direction: JString (required)
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   state: JString (required)
  section = newJObject()
  var valid_755228 = query.getOrDefault("sort")
  valid_755228 = validateParameter(valid_755228, JString, required = true,
                                 default = newJString("created"))
  if valid_755228 != nil:
    section.add "sort", valid_755228
  var valid_755229 = query.getOrDefault("since")
  valid_755229 = validateParameter(valid_755229, JString, required = false,
                                 default = nil)
  if valid_755229 != nil:
    section.add "since", valid_755229
  var valid_755230 = query.getOrDefault("direction")
  valid_755230 = validateParameter(valid_755230, JString, required = true,
                                 default = newJString("desc"))
  if valid_755230 != nil:
    section.add "direction", valid_755230
  var valid_755231 = query.getOrDefault("labels")
  valid_755231 = validateParameter(valid_755231, JString, required = true,
                                 default = nil)
  if valid_755231 != nil:
    section.add "labels", valid_755231
  var valid_755232 = query.getOrDefault("filter")
  valid_755232 = validateParameter(valid_755232, JString, required = true,
                                 default = newJString("all"))
  if valid_755232 != nil:
    section.add "filter", valid_755232
  var valid_755233 = query.getOrDefault("state")
  valid_755233 = validateParameter(valid_755233, JString, required = true,
                                 default = newJString("open"))
  if valid_755233 != nil:
    section.add "state", valid_755233
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755234 = header.getOrDefault("Accept")
  valid_755234 = validateParameter(valid_755234, JString, required = false,
                                 default = nil)
  if valid_755234 != nil:
    section.add "Accept", valid_755234
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755235: Call_GetReposOwnerRepoIssues_755223; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List issues for a repository.
  ## 
  let valid = call_755235.validator(path, query, header, formData, body, _)
  let scheme = call_755235.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755235.makeUrl(scheme.get, call_755235.host, call_755235.base,
                             call_755235.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755235, uri, valid, _)

proc call*(call_755236: Call_GetReposOwnerRepoIssues_755223; labels: string;
          repo: string; owner: string; sort: string = "created"; since: string = "";
          direction: string = "desc"; Accept: string = ""; filter: string = "all";
          state: string = "open"): Recallable =
  ## getReposOwnerRepoIssues
  ## List issues for a repository.
  ##   sort: string (required)
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  ##   direction: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   state: string (required)
  var path_755237 = newJObject()
  var query_755238 = newJObject()
  var header_755239 = newJObject()
  add(query_755238, "sort", newJString(sort))
  add(query_755238, "since", newJString(since))
  add(query_755238, "direction", newJString(direction))
  add(header_755239, "Accept", newJString(Accept))
  add(query_755238, "labels", newJString(labels))
  add(path_755237, "repo", newJString(repo))
  add(path_755237, "owner", newJString(owner))
  add(query_755238, "filter", newJString(filter))
  add(query_755238, "state", newJString(state))
  result = call_755236.call(path_755237, query_755238, header_755239, nil, nil)

var getReposOwnerRepoIssues* = Call_GetReposOwnerRepoIssues_755223(
    name: "getReposOwnerRepoIssues", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues",
    validator: validate_GetReposOwnerRepoIssues_755224, base: "/",
    makeUrl: url_GetReposOwnerRepoIssues_755225, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesComments_755252 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoIssuesComments_755254(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesComments_755253(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## List comments in a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755255 = path.getOrDefault("repo")
  valid_755255 = validateParameter(valid_755255, JString, required = true,
                                 default = nil)
  if valid_755255 != nil:
    section.add "repo", valid_755255
  var valid_755256 = path.getOrDefault("owner")
  valid_755256 = validateParameter(valid_755256, JString, required = true,
                                 default = nil)
  if valid_755256 != nil:
    section.add "owner", valid_755256
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  section = newJObject()
  var valid_755257 = query.getOrDefault("sort")
  valid_755257 = validateParameter(valid_755257, JString, required = false,
                                 default = newJString("created"))
  if valid_755257 != nil:
    section.add "sort", valid_755257
  var valid_755258 = query.getOrDefault("since")
  valid_755258 = validateParameter(valid_755258, JString, required = false,
                                 default = nil)
  if valid_755258 != nil:
    section.add "since", valid_755258
  var valid_755259 = query.getOrDefault("direction")
  valid_755259 = validateParameter(valid_755259, JString, required = false,
                                 default = nil)
  if valid_755259 != nil:
    section.add "direction", valid_755259
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755260 = header.getOrDefault("Accept")
  valid_755260 = validateParameter(valid_755260, JString, required = false,
                                 default = nil)
  if valid_755260 != nil:
    section.add "Accept", valid_755260
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755261: Call_GetReposOwnerRepoIssuesComments_755252;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List comments in a repository.
  ## 
  let valid = call_755261.validator(path, query, header, formData, body, _)
  let scheme = call_755261.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755261.makeUrl(scheme.get, call_755261.host, call_755261.base,
                             call_755261.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755261, uri, valid, _)

proc call*(call_755262: Call_GetReposOwnerRepoIssuesComments_755252; repo: string;
          owner: string; sort: string = "created"; since: string = "";
          direction: string = ""; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesComments
  ## List comments in a repository.
  ##   sort: string
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755263 = newJObject()
  var query_755264 = newJObject()
  var header_755265 = newJObject()
  add(query_755264, "sort", newJString(sort))
  add(query_755264, "since", newJString(since))
  add(query_755264, "direction", newJString(direction))
  add(header_755265, "Accept", newJString(Accept))
  add(path_755263, "repo", newJString(repo))
  add(path_755263, "owner", newJString(owner))
  result = call_755262.call(path_755263, query_755264, header_755265, nil, nil)

var getReposOwnerRepoIssuesComments* = Call_GetReposOwnerRepoIssuesComments_755252(
    name: "getReposOwnerRepoIssuesComments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/comments",
    validator: validate_GetReposOwnerRepoIssuesComments_755253, base: "/",
    makeUrl: url_GetReposOwnerRepoIssuesComments_755254, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesCommentsCommentId_755266 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoIssuesCommentsCommentId_755268(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesCommentsCommentId_755267(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Get a single comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   commentId: JInt (required)
  ##            : ID of comment.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `commentId` field"
  var valid_755269 = path.getOrDefault("commentId")
  valid_755269 = validateParameter(valid_755269, JInt, required = true, default = nil)
  if valid_755269 != nil:
    section.add "commentId", valid_755269
  var valid_755270 = path.getOrDefault("repo")
  valid_755270 = validateParameter(valid_755270, JString, required = true,
                                 default = nil)
  if valid_755270 != nil:
    section.add "repo", valid_755270
  var valid_755271 = path.getOrDefault("owner")
  valid_755271 = validateParameter(valid_755271, JString, required = true,
                                 default = nil)
  if valid_755271 != nil:
    section.add "owner", valid_755271
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755272 = header.getOrDefault("Accept")
  valid_755272 = validateParameter(valid_755272, JString, required = false,
                                 default = nil)
  if valid_755272 != nil:
    section.add "Accept", valid_755272
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755273: Call_GetReposOwnerRepoIssuesCommentsCommentId_755266;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single comment.
  ## 
  let valid = call_755273.validator(path, query, header, formData, body, _)
  let scheme = call_755273.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755273.makeUrl(scheme.get, call_755273.host, call_755273.base,
                             call_755273.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755273, uri, valid, _)

proc call*(call_755274: Call_GetReposOwnerRepoIssuesCommentsCommentId_755266;
          commentId: int; repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesCommentsCommentId
  ## Get a single comment.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   commentId: int (required)
  ##            : ID of comment.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755275 = newJObject()
  var header_755276 = newJObject()
  add(header_755276, "Accept", newJString(Accept))
  add(path_755275, "commentId", newJInt(commentId))
  add(path_755275, "repo", newJString(repo))
  add(path_755275, "owner", newJString(owner))
  result = call_755274.call(path_755275, nil, header_755276, nil, nil)

var getReposOwnerRepoIssuesCommentsCommentId* = Call_GetReposOwnerRepoIssuesCommentsCommentId_755266(
    name: "getReposOwnerRepoIssuesCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/comments/{commentId}",
    validator: validate_GetReposOwnerRepoIssuesCommentsCommentId_755267,
    base: "/", makeUrl: url_GetReposOwnerRepoIssuesCommentsCommentId_755268,
    schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoIssuesCommentsCommentId_755288 = ref object of OpenApiRestCall_753573
proc url_PatchReposOwnerRepoIssuesCommentsCommentId_755290(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoIssuesCommentsCommentId_755289(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Edit a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   commentId: JInt (required)
  ##            : ID of comment.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `commentId` field"
  var valid_755291 = path.getOrDefault("commentId")
  valid_755291 = validateParameter(valid_755291, JInt, required = true, default = nil)
  if valid_755291 != nil:
    section.add "commentId", valid_755291
  var valid_755292 = path.getOrDefault("repo")
  valid_755292 = validateParameter(valid_755292, JString, required = true,
                                 default = nil)
  if valid_755292 != nil:
    section.add "repo", valid_755292
  var valid_755293 = path.getOrDefault("owner")
  valid_755293 = validateParameter(valid_755293, JString, required = true,
                                 default = nil)
  if valid_755293 != nil:
    section.add "owner", valid_755293
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755294 = header.getOrDefault("Accept")
  valid_755294 = validateParameter(valid_755294, JString, required = false,
                                 default = nil)
  if valid_755294 != nil:
    section.add "Accept", valid_755294
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_755296: Call_PatchReposOwnerRepoIssuesCommentsCommentId_755288;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit a comment.
  ## 
  let valid = call_755296.validator(path, query, header, formData, body, _)
  let scheme = call_755296.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755296.makeUrl(scheme.get, call_755296.host, call_755296.base,
                             call_755296.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755296, uri, valid, _)

proc call*(call_755297: Call_PatchReposOwnerRepoIssuesCommentsCommentId_755288;
          commentId: int; repo: string; body: JsonNode; owner: string;
          Accept: string = ""): Recallable =
  ## patchReposOwnerRepoIssuesCommentsCommentId
  ## Edit a comment.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   commentId: int (required)
  ##            : ID of comment.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755298 = newJObject()
  var header_755299 = newJObject()
  var body_755300 = newJObject()
  add(header_755299, "Accept", newJString(Accept))
  add(path_755298, "commentId", newJInt(commentId))
  add(path_755298, "repo", newJString(repo))
  if body != nil:
    body_755300 = body
  add(path_755298, "owner", newJString(owner))
  result = call_755297.call(path_755298, nil, header_755299, nil, body_755300)

var patchReposOwnerRepoIssuesCommentsCommentId* = Call_PatchReposOwnerRepoIssuesCommentsCommentId_755288(
    name: "patchReposOwnerRepoIssuesCommentsCommentId",
    meth: HttpMethod.HttpPatch, host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/comments/{commentId}",
    validator: validate_PatchReposOwnerRepoIssuesCommentsCommentId_755289,
    base: "/", makeUrl: url_PatchReposOwnerRepoIssuesCommentsCommentId_755290,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoIssuesCommentsCommentId_755277 = ref object of OpenApiRestCall_753573
proc url_DeleteReposOwnerRepoIssuesCommentsCommentId_755279(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoIssuesCommentsCommentId_755278(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Delete a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   commentId: JInt (required)
  ##            : ID of comment.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `commentId` field"
  var valid_755280 = path.getOrDefault("commentId")
  valid_755280 = validateParameter(valid_755280, JInt, required = true, default = nil)
  if valid_755280 != nil:
    section.add "commentId", valid_755280
  var valid_755281 = path.getOrDefault("repo")
  valid_755281 = validateParameter(valid_755281, JString, required = true,
                                 default = nil)
  if valid_755281 != nil:
    section.add "repo", valid_755281
  var valid_755282 = path.getOrDefault("owner")
  valid_755282 = validateParameter(valid_755282, JString, required = true,
                                 default = nil)
  if valid_755282 != nil:
    section.add "owner", valid_755282
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755283 = header.getOrDefault("Accept")
  valid_755283 = validateParameter(valid_755283, JString, required = false,
                                 default = nil)
  if valid_755283 != nil:
    section.add "Accept", valid_755283
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755284: Call_DeleteReposOwnerRepoIssuesCommentsCommentId_755277;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a comment.
  ## 
  let valid = call_755284.validator(path, query, header, formData, body, _)
  let scheme = call_755284.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755284.makeUrl(scheme.get, call_755284.host, call_755284.base,
                             call_755284.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755284, uri, valid, _)

proc call*(call_755285: Call_DeleteReposOwnerRepoIssuesCommentsCommentId_755277;
          commentId: int; repo: string; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoIssuesCommentsCommentId
  ## Delete a comment.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   commentId: int (required)
  ##            : ID of comment.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755286 = newJObject()
  var header_755287 = newJObject()
  add(header_755287, "Accept", newJString(Accept))
  add(path_755286, "commentId", newJInt(commentId))
  add(path_755286, "repo", newJString(repo))
  add(path_755286, "owner", newJString(owner))
  result = call_755285.call(path_755286, nil, header_755287, nil, nil)

var deleteReposOwnerRepoIssuesCommentsCommentId* = Call_DeleteReposOwnerRepoIssuesCommentsCommentId_755277(
    name: "deleteReposOwnerRepoIssuesCommentsCommentId",
    meth: HttpMethod.HttpDelete, host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/comments/{commentId}",
    validator: validate_DeleteReposOwnerRepoIssuesCommentsCommentId_755278,
    base: "/", makeUrl: url_DeleteReposOwnerRepoIssuesCommentsCommentId_755279,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesEvents_755301 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoIssuesEvents_755303(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesEvents_755302(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List issue events for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755304 = path.getOrDefault("repo")
  valid_755304 = validateParameter(valid_755304, JString, required = true,
                                 default = nil)
  if valid_755304 != nil:
    section.add "repo", valid_755304
  var valid_755305 = path.getOrDefault("owner")
  valid_755305 = validateParameter(valid_755305, JString, required = true,
                                 default = nil)
  if valid_755305 != nil:
    section.add "owner", valid_755305
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755306 = header.getOrDefault("Accept")
  valid_755306 = validateParameter(valid_755306, JString, required = false,
                                 default = nil)
  if valid_755306 != nil:
    section.add "Accept", valid_755306
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755307: Call_GetReposOwnerRepoIssuesEvents_755301;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List issue events for a repository.
  ## 
  let valid = call_755307.validator(path, query, header, formData, body, _)
  let scheme = call_755307.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755307.makeUrl(scheme.get, call_755307.host, call_755307.base,
                             call_755307.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755307, uri, valid, _)

proc call*(call_755308: Call_GetReposOwnerRepoIssuesEvents_755301; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesEvents
  ## List issue events for a repository.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755309 = newJObject()
  var header_755310 = newJObject()
  add(header_755310, "Accept", newJString(Accept))
  add(path_755309, "repo", newJString(repo))
  add(path_755309, "owner", newJString(owner))
  result = call_755308.call(path_755309, nil, header_755310, nil, nil)

var getReposOwnerRepoIssuesEvents* = Call_GetReposOwnerRepoIssuesEvents_755301(
    name: "getReposOwnerRepoIssuesEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/events",
    validator: validate_GetReposOwnerRepoIssuesEvents_755302, base: "/",
    makeUrl: url_GetReposOwnerRepoIssuesEvents_755303, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesEventsEventId_755311 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoIssuesEventsEventId_755313(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "eventId" in path, "`eventId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/events/"),
               (kind: VariableSegment, value: "eventId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesEventsEventId_755312(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Get a single event.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   eventId: JInt (required)
  ##          : Id of the event.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `eventId` field"
  var valid_755314 = path.getOrDefault("eventId")
  valid_755314 = validateParameter(valid_755314, JInt, required = true, default = nil)
  if valid_755314 != nil:
    section.add "eventId", valid_755314
  var valid_755315 = path.getOrDefault("repo")
  valid_755315 = validateParameter(valid_755315, JString, required = true,
                                 default = nil)
  if valid_755315 != nil:
    section.add "repo", valid_755315
  var valid_755316 = path.getOrDefault("owner")
  valid_755316 = validateParameter(valid_755316, JString, required = true,
                                 default = nil)
  if valid_755316 != nil:
    section.add "owner", valid_755316
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755317 = header.getOrDefault("Accept")
  valid_755317 = validateParameter(valid_755317, JString, required = false,
                                 default = nil)
  if valid_755317 != nil:
    section.add "Accept", valid_755317
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755318: Call_GetReposOwnerRepoIssuesEventsEventId_755311;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single event.
  ## 
  let valid = call_755318.validator(path, query, header, formData, body, _)
  let scheme = call_755318.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755318.makeUrl(scheme.get, call_755318.host, call_755318.base,
                             call_755318.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755318, uri, valid, _)

proc call*(call_755319: Call_GetReposOwnerRepoIssuesEventsEventId_755311;
          eventId: int; repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesEventsEventId
  ## Get a single event.
  ##   eventId: int (required)
  ##          : Id of the event.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755320 = newJObject()
  var header_755321 = newJObject()
  add(path_755320, "eventId", newJInt(eventId))
  add(header_755321, "Accept", newJString(Accept))
  add(path_755320, "repo", newJString(repo))
  add(path_755320, "owner", newJString(owner))
  result = call_755319.call(path_755320, nil, header_755321, nil, nil)

var getReposOwnerRepoIssuesEventsEventId* = Call_GetReposOwnerRepoIssuesEventsEventId_755311(
    name: "getReposOwnerRepoIssuesEventsEventId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/events/{eventId}",
    validator: validate_GetReposOwnerRepoIssuesEventsEventId_755312, base: "/",
    makeUrl: url_GetReposOwnerRepoIssuesEventsEventId_755313,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumber_755322 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoIssuesNumber_755324(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumber_755323(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Get a single issue
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `number` field"
  var valid_755325 = path.getOrDefault("number")
  valid_755325 = validateParameter(valid_755325, JInt, required = true, default = nil)
  if valid_755325 != nil:
    section.add "number", valid_755325
  var valid_755326 = path.getOrDefault("repo")
  valid_755326 = validateParameter(valid_755326, JString, required = true,
                                 default = nil)
  if valid_755326 != nil:
    section.add "repo", valid_755326
  var valid_755327 = path.getOrDefault("owner")
  valid_755327 = validateParameter(valid_755327, JString, required = true,
                                 default = nil)
  if valid_755327 != nil:
    section.add "owner", valid_755327
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755328 = header.getOrDefault("Accept")
  valid_755328 = validateParameter(valid_755328, JString, required = false,
                                 default = nil)
  if valid_755328 != nil:
    section.add "Accept", valid_755328
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755329: Call_GetReposOwnerRepoIssuesNumber_755322;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single issue
  ## 
  let valid = call_755329.validator(path, query, header, formData, body, _)
  let scheme = call_755329.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755329.makeUrl(scheme.get, call_755329.host, call_755329.base,
                             call_755329.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755329, uri, valid, _)

proc call*(call_755330: Call_GetReposOwnerRepoIssuesNumber_755322; number: int;
          repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumber
  ## Get a single issue
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   number: int (required)
  ##         : Number of issue.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755331 = newJObject()
  var header_755332 = newJObject()
  add(header_755332, "Accept", newJString(Accept))
  add(path_755331, "number", newJInt(number))
  add(path_755331, "repo", newJString(repo))
  add(path_755331, "owner", newJString(owner))
  result = call_755330.call(path_755331, nil, header_755332, nil, nil)

var getReposOwnerRepoIssuesNumber* = Call_GetReposOwnerRepoIssuesNumber_755322(
    name: "getReposOwnerRepoIssuesNumber", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}",
    validator: validate_GetReposOwnerRepoIssuesNumber_755323, base: "/",
    makeUrl: url_GetReposOwnerRepoIssuesNumber_755324, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoIssuesNumber_755333 = ref object of OpenApiRestCall_753573
proc url_PatchReposOwnerRepoIssuesNumber_755335(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoIssuesNumber_755334(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Edit an issue.
  ## Issue owners and users with push access can edit an issue.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `number` field"
  var valid_755336 = path.getOrDefault("number")
  valid_755336 = validateParameter(valid_755336, JInt, required = true, default = nil)
  if valid_755336 != nil:
    section.add "number", valid_755336
  var valid_755337 = path.getOrDefault("repo")
  valid_755337 = validateParameter(valid_755337, JString, required = true,
                                 default = nil)
  if valid_755337 != nil:
    section.add "repo", valid_755337
  var valid_755338 = path.getOrDefault("owner")
  valid_755338 = validateParameter(valid_755338, JString, required = true,
                                 default = nil)
  if valid_755338 != nil:
    section.add "owner", valid_755338
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755339 = header.getOrDefault("Accept")
  valid_755339 = validateParameter(valid_755339, JString, required = false,
                                 default = nil)
  if valid_755339 != nil:
    section.add "Accept", valid_755339
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_755341: Call_PatchReposOwnerRepoIssuesNumber_755333;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit an issue.
  ## Issue owners and users with push access can edit an issue.
  ## 
  ## 
  let valid = call_755341.validator(path, query, header, formData, body, _)
  let scheme = call_755341.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755341.makeUrl(scheme.get, call_755341.host, call_755341.base,
                             call_755341.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755341, uri, valid, _)

proc call*(call_755342: Call_PatchReposOwnerRepoIssuesNumber_755333; number: int;
          repo: string; body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoIssuesNumber
  ## Edit an issue.
  ## Issue owners and users with push access can edit an issue.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   number: int (required)
  ##         : Number of issue.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755343 = newJObject()
  var header_755344 = newJObject()
  var body_755345 = newJObject()
  add(header_755344, "Accept", newJString(Accept))
  add(path_755343, "number", newJInt(number))
  add(path_755343, "repo", newJString(repo))
  if body != nil:
    body_755345 = body
  add(path_755343, "owner", newJString(owner))
  result = call_755342.call(path_755343, nil, header_755344, nil, body_755345)

var patchReposOwnerRepoIssuesNumber* = Call_PatchReposOwnerRepoIssuesNumber_755333(
    name: "patchReposOwnerRepoIssuesNumber", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}",
    validator: validate_PatchReposOwnerRepoIssuesNumber_755334, base: "/",
    makeUrl: url_PatchReposOwnerRepoIssuesNumber_755335, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoIssuesNumberComments_755357 = ref object of OpenApiRestCall_753573
proc url_PostReposOwnerRepoIssuesNumberComments_755359(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoIssuesNumberComments_755358(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Create a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `number` field"
  var valid_755360 = path.getOrDefault("number")
  valid_755360 = validateParameter(valid_755360, JInt, required = true, default = nil)
  if valid_755360 != nil:
    section.add "number", valid_755360
  var valid_755361 = path.getOrDefault("repo")
  valid_755361 = validateParameter(valid_755361, JString, required = true,
                                 default = nil)
  if valid_755361 != nil:
    section.add "repo", valid_755361
  var valid_755362 = path.getOrDefault("owner")
  valid_755362 = validateParameter(valid_755362, JString, required = true,
                                 default = nil)
  if valid_755362 != nil:
    section.add "owner", valid_755362
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755363 = header.getOrDefault("Accept")
  valid_755363 = validateParameter(valid_755363, JString, required = false,
                                 default = nil)
  if valid_755363 != nil:
    section.add "Accept", valid_755363
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_755365: Call_PostReposOwnerRepoIssuesNumberComments_755357;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a comment.
  ## 
  let valid = call_755365.validator(path, query, header, formData, body, _)
  let scheme = call_755365.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755365.makeUrl(scheme.get, call_755365.host, call_755365.base,
                             call_755365.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755365, uri, valid, _)

proc call*(call_755366: Call_PostReposOwnerRepoIssuesNumberComments_755357;
          number: int; repo: string; body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoIssuesNumberComments
  ## Create a comment.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   number: int (required)
  ##         : Number of issue.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755367 = newJObject()
  var header_755368 = newJObject()
  var body_755369 = newJObject()
  add(header_755368, "Accept", newJString(Accept))
  add(path_755367, "number", newJInt(number))
  add(path_755367, "repo", newJString(repo))
  if body != nil:
    body_755369 = body
  add(path_755367, "owner", newJString(owner))
  result = call_755366.call(path_755367, nil, header_755368, nil, body_755369)

var postReposOwnerRepoIssuesNumberComments* = Call_PostReposOwnerRepoIssuesNumberComments_755357(
    name: "postReposOwnerRepoIssuesNumberComments", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/{number}/comments",
    validator: validate_PostReposOwnerRepoIssuesNumberComments_755358, base: "/",
    makeUrl: url_PostReposOwnerRepoIssuesNumberComments_755359,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumberComments_755346 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoIssuesNumberComments_755348(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumberComments_755347(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## List comments on an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `number` field"
  var valid_755349 = path.getOrDefault("number")
  valid_755349 = validateParameter(valid_755349, JInt, required = true, default = nil)
  if valid_755349 != nil:
    section.add "number", valid_755349
  var valid_755350 = path.getOrDefault("repo")
  valid_755350 = validateParameter(valid_755350, JString, required = true,
                                 default = nil)
  if valid_755350 != nil:
    section.add "repo", valid_755350
  var valid_755351 = path.getOrDefault("owner")
  valid_755351 = validateParameter(valid_755351, JString, required = true,
                                 default = nil)
  if valid_755351 != nil:
    section.add "owner", valid_755351
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755352 = header.getOrDefault("Accept")
  valid_755352 = validateParameter(valid_755352, JString, required = false,
                                 default = nil)
  if valid_755352 != nil:
    section.add "Accept", valid_755352
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755353: Call_GetReposOwnerRepoIssuesNumberComments_755346;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List comments on an issue.
  ## 
  let valid = call_755353.validator(path, query, header, formData, body, _)
  let scheme = call_755353.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755353.makeUrl(scheme.get, call_755353.host, call_755353.base,
                             call_755353.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755353, uri, valid, _)

proc call*(call_755354: Call_GetReposOwnerRepoIssuesNumberComments_755346;
          number: int; repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumberComments
  ## List comments on an issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   number: int (required)
  ##         : Number of issue.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755355 = newJObject()
  var header_755356 = newJObject()
  add(header_755356, "Accept", newJString(Accept))
  add(path_755355, "number", newJInt(number))
  add(path_755355, "repo", newJString(repo))
  add(path_755355, "owner", newJString(owner))
  result = call_755354.call(path_755355, nil, header_755356, nil, nil)

var getReposOwnerRepoIssuesNumberComments* = Call_GetReposOwnerRepoIssuesNumberComments_755346(
    name: "getReposOwnerRepoIssuesNumberComments", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/{number}/comments",
    validator: validate_GetReposOwnerRepoIssuesNumberComments_755347, base: "/",
    makeUrl: url_GetReposOwnerRepoIssuesNumberComments_755348,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumberEvents_755370 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoIssuesNumberEvents_755372(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumberEvents_755371(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## List events for an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `number` field"
  var valid_755373 = path.getOrDefault("number")
  valid_755373 = validateParameter(valid_755373, JInt, required = true, default = nil)
  if valid_755373 != nil:
    section.add "number", valid_755373
  var valid_755374 = path.getOrDefault("repo")
  valid_755374 = validateParameter(valid_755374, JString, required = true,
                                 default = nil)
  if valid_755374 != nil:
    section.add "repo", valid_755374
  var valid_755375 = path.getOrDefault("owner")
  valid_755375 = validateParameter(valid_755375, JString, required = true,
                                 default = nil)
  if valid_755375 != nil:
    section.add "owner", valid_755375
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755376 = header.getOrDefault("Accept")
  valid_755376 = validateParameter(valid_755376, JString, required = false,
                                 default = nil)
  if valid_755376 != nil:
    section.add "Accept", valid_755376
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755377: Call_GetReposOwnerRepoIssuesNumberEvents_755370;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List events for an issue.
  ## 
  let valid = call_755377.validator(path, query, header, formData, body, _)
  let scheme = call_755377.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755377.makeUrl(scheme.get, call_755377.host, call_755377.base,
                             call_755377.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755377, uri, valid, _)

proc call*(call_755378: Call_GetReposOwnerRepoIssuesNumberEvents_755370;
          number: int; repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumberEvents
  ## List events for an issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   number: int (required)
  ##         : Number of issue.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755379 = newJObject()
  var header_755380 = newJObject()
  add(header_755380, "Accept", newJString(Accept))
  add(path_755379, "number", newJInt(number))
  add(path_755379, "repo", newJString(repo))
  add(path_755379, "owner", newJString(owner))
  result = call_755378.call(path_755379, nil, header_755380, nil, nil)

var getReposOwnerRepoIssuesNumberEvents* = Call_GetReposOwnerRepoIssuesNumberEvents_755370(
    name: "getReposOwnerRepoIssuesNumberEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/events",
    validator: validate_GetReposOwnerRepoIssuesNumberEvents_755371, base: "/",
    makeUrl: url_GetReposOwnerRepoIssuesNumberEvents_755372,
    schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoIssuesNumberLabels_755392 = ref object of OpenApiRestCall_753573
proc url_PutReposOwnerRepoIssuesNumberLabels_755394(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoIssuesNumberLabels_755393(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Replace all labels for an issue.
  ## Sending an empty array ([]) will remove all Labels from the Issue.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `number` field"
  var valid_755395 = path.getOrDefault("number")
  valid_755395 = validateParameter(valid_755395, JInt, required = true, default = nil)
  if valid_755395 != nil:
    section.add "number", valid_755395
  var valid_755396 = path.getOrDefault("repo")
  valid_755396 = validateParameter(valid_755396, JString, required = true,
                                 default = nil)
  if valid_755396 != nil:
    section.add "repo", valid_755396
  var valid_755397 = path.getOrDefault("owner")
  valid_755397 = validateParameter(valid_755397, JString, required = true,
                                 default = nil)
  if valid_755397 != nil:
    section.add "owner", valid_755397
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755398 = header.getOrDefault("Accept")
  valid_755398 = validateParameter(valid_755398, JString, required = false,
                                 default = nil)
  if valid_755398 != nil:
    section.add "Accept", valid_755398
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_755400: Call_PutReposOwnerRepoIssuesNumberLabels_755392;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Replace all labels for an issue.
  ## Sending an empty array ([]) will remove all Labels from the Issue.
  ## 
  ## 
  let valid = call_755400.validator(path, query, header, formData, body, _)
  let scheme = call_755400.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755400.makeUrl(scheme.get, call_755400.host, call_755400.base,
                             call_755400.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755400, uri, valid, _)

proc call*(call_755401: Call_PutReposOwnerRepoIssuesNumberLabels_755392;
          number: int; repo: string; body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoIssuesNumberLabels
  ## Replace all labels for an issue.
  ## Sending an empty array ([]) will remove all Labels from the Issue.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   number: int (required)
  ##         : Number of issue.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JArray (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755402 = newJObject()
  var header_755403 = newJObject()
  var body_755404 = newJObject()
  add(header_755403, "Accept", newJString(Accept))
  add(path_755402, "number", newJInt(number))
  add(path_755402, "repo", newJString(repo))
  if body != nil:
    body_755404 = body
  add(path_755402, "owner", newJString(owner))
  result = call_755401.call(path_755402, nil, header_755403, nil, body_755404)

var putReposOwnerRepoIssuesNumberLabels* = Call_PutReposOwnerRepoIssuesNumberLabels_755392(
    name: "putReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_PutReposOwnerRepoIssuesNumberLabels_755393, base: "/",
    makeUrl: url_PutReposOwnerRepoIssuesNumberLabels_755394,
    schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoIssuesNumberLabels_755405 = ref object of OpenApiRestCall_753573
proc url_PostReposOwnerRepoIssuesNumberLabels_755407(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoIssuesNumberLabels_755406(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Add labels to an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `number` field"
  var valid_755408 = path.getOrDefault("number")
  valid_755408 = validateParameter(valid_755408, JInt, required = true, default = nil)
  if valid_755408 != nil:
    section.add "number", valid_755408
  var valid_755409 = path.getOrDefault("repo")
  valid_755409 = validateParameter(valid_755409, JString, required = true,
                                 default = nil)
  if valid_755409 != nil:
    section.add "repo", valid_755409
  var valid_755410 = path.getOrDefault("owner")
  valid_755410 = validateParameter(valid_755410, JString, required = true,
                                 default = nil)
  if valid_755410 != nil:
    section.add "owner", valid_755410
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755411 = header.getOrDefault("Accept")
  valid_755411 = validateParameter(valid_755411, JString, required = false,
                                 default = nil)
  if valid_755411 != nil:
    section.add "Accept", valid_755411
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_755413: Call_PostReposOwnerRepoIssuesNumberLabels_755405;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Add labels to an issue.
  ## 
  let valid = call_755413.validator(path, query, header, formData, body, _)
  let scheme = call_755413.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755413.makeUrl(scheme.get, call_755413.host, call_755413.base,
                             call_755413.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755413, uri, valid, _)

proc call*(call_755414: Call_PostReposOwnerRepoIssuesNumberLabels_755405;
          number: int; repo: string; body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoIssuesNumberLabels
  ## Add labels to an issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   number: int (required)
  ##         : Number of issue.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JArray (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755415 = newJObject()
  var header_755416 = newJObject()
  var body_755417 = newJObject()
  add(header_755416, "Accept", newJString(Accept))
  add(path_755415, "number", newJInt(number))
  add(path_755415, "repo", newJString(repo))
  if body != nil:
    body_755417 = body
  add(path_755415, "owner", newJString(owner))
  result = call_755414.call(path_755415, nil, header_755416, nil, body_755417)

var postReposOwnerRepoIssuesNumberLabels* = Call_PostReposOwnerRepoIssuesNumberLabels_755405(
    name: "postReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_PostReposOwnerRepoIssuesNumberLabels_755406, base: "/",
    makeUrl: url_PostReposOwnerRepoIssuesNumberLabels_755407,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumberLabels_755381 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoIssuesNumberLabels_755383(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumberLabels_755382(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## List labels on an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `number` field"
  var valid_755384 = path.getOrDefault("number")
  valid_755384 = validateParameter(valid_755384, JInt, required = true, default = nil)
  if valid_755384 != nil:
    section.add "number", valid_755384
  var valid_755385 = path.getOrDefault("repo")
  valid_755385 = validateParameter(valid_755385, JString, required = true,
                                 default = nil)
  if valid_755385 != nil:
    section.add "repo", valid_755385
  var valid_755386 = path.getOrDefault("owner")
  valid_755386 = validateParameter(valid_755386, JString, required = true,
                                 default = nil)
  if valid_755386 != nil:
    section.add "owner", valid_755386
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755387 = header.getOrDefault("Accept")
  valid_755387 = validateParameter(valid_755387, JString, required = false,
                                 default = nil)
  if valid_755387 != nil:
    section.add "Accept", valid_755387
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755388: Call_GetReposOwnerRepoIssuesNumberLabels_755381;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List labels on an issue.
  ## 
  let valid = call_755388.validator(path, query, header, formData, body, _)
  let scheme = call_755388.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755388.makeUrl(scheme.get, call_755388.host, call_755388.base,
                             call_755388.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755388, uri, valid, _)

proc call*(call_755389: Call_GetReposOwnerRepoIssuesNumberLabels_755381;
          number: int; repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumberLabels
  ## List labels on an issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   number: int (required)
  ##         : Number of issue.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755390 = newJObject()
  var header_755391 = newJObject()
  add(header_755391, "Accept", newJString(Accept))
  add(path_755390, "number", newJInt(number))
  add(path_755390, "repo", newJString(repo))
  add(path_755390, "owner", newJString(owner))
  result = call_755389.call(path_755390, nil, header_755391, nil, nil)

var getReposOwnerRepoIssuesNumberLabels* = Call_GetReposOwnerRepoIssuesNumberLabels_755381(
    name: "getReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_GetReposOwnerRepoIssuesNumberLabels_755382, base: "/",
    makeUrl: url_GetReposOwnerRepoIssuesNumberLabels_755383,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoIssuesNumberLabels_755418 = ref object of OpenApiRestCall_753573
proc url_DeleteReposOwnerRepoIssuesNumberLabels_755420(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoIssuesNumberLabels_755419(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Remove all labels from an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `number` field"
  var valid_755421 = path.getOrDefault("number")
  valid_755421 = validateParameter(valid_755421, JInt, required = true, default = nil)
  if valid_755421 != nil:
    section.add "number", valid_755421
  var valid_755422 = path.getOrDefault("repo")
  valid_755422 = validateParameter(valid_755422, JString, required = true,
                                 default = nil)
  if valid_755422 != nil:
    section.add "repo", valid_755422
  var valid_755423 = path.getOrDefault("owner")
  valid_755423 = validateParameter(valid_755423, JString, required = true,
                                 default = nil)
  if valid_755423 != nil:
    section.add "owner", valid_755423
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755424 = header.getOrDefault("Accept")
  valid_755424 = validateParameter(valid_755424, JString, required = false,
                                 default = nil)
  if valid_755424 != nil:
    section.add "Accept", valid_755424
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755425: Call_DeleteReposOwnerRepoIssuesNumberLabels_755418;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Remove all labels from an issue.
  ## 
  let valid = call_755425.validator(path, query, header, formData, body, _)
  let scheme = call_755425.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755425.makeUrl(scheme.get, call_755425.host, call_755425.base,
                             call_755425.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755425, uri, valid, _)

proc call*(call_755426: Call_DeleteReposOwnerRepoIssuesNumberLabels_755418;
          number: int; repo: string; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoIssuesNumberLabels
  ## Remove all labels from an issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   number: int (required)
  ##         : Number of issue.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755427 = newJObject()
  var header_755428 = newJObject()
  add(header_755428, "Accept", newJString(Accept))
  add(path_755427, "number", newJInt(number))
  add(path_755427, "repo", newJString(repo))
  add(path_755427, "owner", newJString(owner))
  result = call_755426.call(path_755427, nil, header_755428, nil, nil)

var deleteReposOwnerRepoIssuesNumberLabels* = Call_DeleteReposOwnerRepoIssuesNumberLabels_755418(
    name: "deleteReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_DeleteReposOwnerRepoIssuesNumberLabels_755419, base: "/",
    makeUrl: url_DeleteReposOwnerRepoIssuesNumberLabels_755420,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoIssuesNumberLabelsName_755429 = ref object of OpenApiRestCall_753573
proc url_DeleteReposOwnerRepoIssuesNumberLabelsName_755431(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoIssuesNumberLabelsName_755430(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Remove a label from an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   name: JString (required)
  ##       : Name of the label.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `name` field"
  var valid_755432 = path.getOrDefault("name")
  valid_755432 = validateParameter(valid_755432, JString, required = true,
                                 default = nil)
  if valid_755432 != nil:
    section.add "name", valid_755432
  var valid_755433 = path.getOrDefault("number")
  valid_755433 = validateParameter(valid_755433, JInt, required = true, default = nil)
  if valid_755433 != nil:
    section.add "number", valid_755433
  var valid_755434 = path.getOrDefault("repo")
  valid_755434 = validateParameter(valid_755434, JString, required = true,
                                 default = nil)
  if valid_755434 != nil:
    section.add "repo", valid_755434
  var valid_755435 = path.getOrDefault("owner")
  valid_755435 = validateParameter(valid_755435, JString, required = true,
                                 default = nil)
  if valid_755435 != nil:
    section.add "owner", valid_755435
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755436 = header.getOrDefault("Accept")
  valid_755436 = validateParameter(valid_755436, JString, required = false,
                                 default = nil)
  if valid_755436 != nil:
    section.add "Accept", valid_755436
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755437: Call_DeleteReposOwnerRepoIssuesNumberLabelsName_755429;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Remove a label from an issue.
  ## 
  let valid = call_755437.validator(path, query, header, formData, body, _)
  let scheme = call_755437.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755437.makeUrl(scheme.get, call_755437.host, call_755437.base,
                             call_755437.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755437, uri, valid, _)

proc call*(call_755438: Call_DeleteReposOwnerRepoIssuesNumberLabelsName_755429;
          name: string; number: int; repo: string; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoIssuesNumberLabelsName
  ## Remove a label from an issue.
  ##   name: string (required)
  ##       : Name of the label.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   number: int (required)
  ##         : Number of issue.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755439 = newJObject()
  var header_755440 = newJObject()
  add(path_755439, "name", newJString(name))
  add(header_755440, "Accept", newJString(Accept))
  add(path_755439, "number", newJInt(number))
  add(path_755439, "repo", newJString(repo))
  add(path_755439, "owner", newJString(owner))
  result = call_755438.call(path_755439, nil, header_755440, nil, nil)

var deleteReposOwnerRepoIssuesNumberLabelsName* = Call_DeleteReposOwnerRepoIssuesNumberLabelsName_755429(
    name: "deleteReposOwnerRepoIssuesNumberLabelsName",
    meth: HttpMethod.HttpDelete, host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/{number}/labels/{name}",
    validator: validate_DeleteReposOwnerRepoIssuesNumberLabelsName_755430,
    base: "/", makeUrl: url_DeleteReposOwnerRepoIssuesNumberLabelsName_755431,
    schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoKeys_755451 = ref object of OpenApiRestCall_753573
proc url_PostReposOwnerRepoKeys_755453(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/keys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoKeys_755452(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Create a key.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755454 = path.getOrDefault("repo")
  valid_755454 = validateParameter(valid_755454, JString, required = true,
                                 default = nil)
  if valid_755454 != nil:
    section.add "repo", valid_755454
  var valid_755455 = path.getOrDefault("owner")
  valid_755455 = validateParameter(valid_755455, JString, required = true,
                                 default = nil)
  if valid_755455 != nil:
    section.add "owner", valid_755455
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755456 = header.getOrDefault("Accept")
  valid_755456 = validateParameter(valid_755456, JString, required = false,
                                 default = nil)
  if valid_755456 != nil:
    section.add "Accept", valid_755456
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_755458: Call_PostReposOwnerRepoKeys_755451; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a key.
  ## 
  let valid = call_755458.validator(path, query, header, formData, body, _)
  let scheme = call_755458.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755458.makeUrl(scheme.get, call_755458.host, call_755458.base,
                             call_755458.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755458, uri, valid, _)

proc call*(call_755459: Call_PostReposOwnerRepoKeys_755451; repo: string;
          body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoKeys
  ## Create a key.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755460 = newJObject()
  var header_755461 = newJObject()
  var body_755462 = newJObject()
  add(header_755461, "Accept", newJString(Accept))
  add(path_755460, "repo", newJString(repo))
  if body != nil:
    body_755462 = body
  add(path_755460, "owner", newJString(owner))
  result = call_755459.call(path_755460, nil, header_755461, nil, body_755462)

var postReposOwnerRepoKeys* = Call_PostReposOwnerRepoKeys_755451(
    name: "postReposOwnerRepoKeys", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/keys",
    validator: validate_PostReposOwnerRepoKeys_755452, base: "/",
    makeUrl: url_PostReposOwnerRepoKeys_755453, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoKeys_755441 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoKeys_755443(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/keys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoKeys_755442(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Get list of keys.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755444 = path.getOrDefault("repo")
  valid_755444 = validateParameter(valid_755444, JString, required = true,
                                 default = nil)
  if valid_755444 != nil:
    section.add "repo", valid_755444
  var valid_755445 = path.getOrDefault("owner")
  valid_755445 = validateParameter(valid_755445, JString, required = true,
                                 default = nil)
  if valid_755445 != nil:
    section.add "owner", valid_755445
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755446 = header.getOrDefault("Accept")
  valid_755446 = validateParameter(valid_755446, JString, required = false,
                                 default = nil)
  if valid_755446 != nil:
    section.add "Accept", valid_755446
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755447: Call_GetReposOwnerRepoKeys_755441; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get list of keys.
  ## 
  let valid = call_755447.validator(path, query, header, formData, body, _)
  let scheme = call_755447.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755447.makeUrl(scheme.get, call_755447.host, call_755447.base,
                             call_755447.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755447, uri, valid, _)

proc call*(call_755448: Call_GetReposOwnerRepoKeys_755441; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoKeys
  ## Get list of keys.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755449 = newJObject()
  var header_755450 = newJObject()
  add(header_755450, "Accept", newJString(Accept))
  add(path_755449, "repo", newJString(repo))
  add(path_755449, "owner", newJString(owner))
  result = call_755448.call(path_755449, nil, header_755450, nil, nil)

var getReposOwnerRepoKeys* = Call_GetReposOwnerRepoKeys_755441(
    name: "getReposOwnerRepoKeys", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/repos/{owner}/{repo}/keys",
    validator: validate_GetReposOwnerRepoKeys_755442, base: "/",
    makeUrl: url_GetReposOwnerRepoKeys_755443, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoKeysKeyId_755463 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoKeysKeyId_755465(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/keys/"),
               (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoKeysKeyId_755464(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Get a key
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyId: JInt (required)
  ##        : Id of key.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyId` field"
  var valid_755466 = path.getOrDefault("keyId")
  valid_755466 = validateParameter(valid_755466, JInt, required = true, default = nil)
  if valid_755466 != nil:
    section.add "keyId", valid_755466
  var valid_755467 = path.getOrDefault("repo")
  valid_755467 = validateParameter(valid_755467, JString, required = true,
                                 default = nil)
  if valid_755467 != nil:
    section.add "repo", valid_755467
  var valid_755468 = path.getOrDefault("owner")
  valid_755468 = validateParameter(valid_755468, JString, required = true,
                                 default = nil)
  if valid_755468 != nil:
    section.add "owner", valid_755468
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755469 = header.getOrDefault("Accept")
  valid_755469 = validateParameter(valid_755469, JString, required = false,
                                 default = nil)
  if valid_755469 != nil:
    section.add "Accept", valid_755469
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755470: Call_GetReposOwnerRepoKeysKeyId_755463;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a key
  ## 
  let valid = call_755470.validator(path, query, header, formData, body, _)
  let scheme = call_755470.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755470.makeUrl(scheme.get, call_755470.host, call_755470.base,
                             call_755470.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755470, uri, valid, _)

proc call*(call_755471: Call_GetReposOwnerRepoKeysKeyId_755463; keyId: int;
          repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoKeysKeyId
  ## Get a key
  ##   keyId: int (required)
  ##        : Id of key.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755472 = newJObject()
  var header_755473 = newJObject()
  add(path_755472, "keyId", newJInt(keyId))
  add(header_755473, "Accept", newJString(Accept))
  add(path_755472, "repo", newJString(repo))
  add(path_755472, "owner", newJString(owner))
  result = call_755471.call(path_755472, nil, header_755473, nil, nil)

var getReposOwnerRepoKeysKeyId* = Call_GetReposOwnerRepoKeysKeyId_755463(
    name: "getReposOwnerRepoKeysKeyId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/keys/{keyId}",
    validator: validate_GetReposOwnerRepoKeysKeyId_755464, base: "/",
    makeUrl: url_GetReposOwnerRepoKeysKeyId_755465, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoKeysKeyId_755474 = ref object of OpenApiRestCall_753573
proc url_DeleteReposOwnerRepoKeysKeyId_755476(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/keys/"),
               (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoKeysKeyId_755475(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Delete a key.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyId: JInt (required)
  ##        : Id of key.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyId` field"
  var valid_755477 = path.getOrDefault("keyId")
  valid_755477 = validateParameter(valid_755477, JInt, required = true, default = nil)
  if valid_755477 != nil:
    section.add "keyId", valid_755477
  var valid_755478 = path.getOrDefault("repo")
  valid_755478 = validateParameter(valid_755478, JString, required = true,
                                 default = nil)
  if valid_755478 != nil:
    section.add "repo", valid_755478
  var valid_755479 = path.getOrDefault("owner")
  valid_755479 = validateParameter(valid_755479, JString, required = true,
                                 default = nil)
  if valid_755479 != nil:
    section.add "owner", valid_755479
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755480 = header.getOrDefault("Accept")
  valid_755480 = validateParameter(valid_755480, JString, required = false,
                                 default = nil)
  if valid_755480 != nil:
    section.add "Accept", valid_755480
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755481: Call_DeleteReposOwnerRepoKeysKeyId_755474;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a key.
  ## 
  let valid = call_755481.validator(path, query, header, formData, body, _)
  let scheme = call_755481.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755481.makeUrl(scheme.get, call_755481.host, call_755481.base,
                             call_755481.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755481, uri, valid, _)

proc call*(call_755482: Call_DeleteReposOwnerRepoKeysKeyId_755474; keyId: int;
          repo: string; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoKeysKeyId
  ## Delete a key.
  ##   keyId: int (required)
  ##        : Id of key.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755483 = newJObject()
  var header_755484 = newJObject()
  add(path_755483, "keyId", newJInt(keyId))
  add(header_755484, "Accept", newJString(Accept))
  add(path_755483, "repo", newJString(repo))
  add(path_755483, "owner", newJString(owner))
  result = call_755482.call(path_755483, nil, header_755484, nil, nil)

var deleteReposOwnerRepoKeysKeyId* = Call_DeleteReposOwnerRepoKeysKeyId_755474(
    name: "deleteReposOwnerRepoKeysKeyId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/keys/{keyId}",
    validator: validate_DeleteReposOwnerRepoKeysKeyId_755475, base: "/",
    makeUrl: url_DeleteReposOwnerRepoKeysKeyId_755476, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoLabels_755495 = ref object of OpenApiRestCall_753573
proc url_PostReposOwnerRepoLabels_755497(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoLabels_755496(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Create a label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755498 = path.getOrDefault("repo")
  valid_755498 = validateParameter(valid_755498, JString, required = true,
                                 default = nil)
  if valid_755498 != nil:
    section.add "repo", valid_755498
  var valid_755499 = path.getOrDefault("owner")
  valid_755499 = validateParameter(valid_755499, JString, required = true,
                                 default = nil)
  if valid_755499 != nil:
    section.add "owner", valid_755499
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755500 = header.getOrDefault("Accept")
  valid_755500 = validateParameter(valid_755500, JString, required = false,
                                 default = nil)
  if valid_755500 != nil:
    section.add "Accept", valid_755500
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_755502: Call_PostReposOwnerRepoLabels_755495; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a label.
  ## 
  let valid = call_755502.validator(path, query, header, formData, body, _)
  let scheme = call_755502.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755502.makeUrl(scheme.get, call_755502.host, call_755502.base,
                             call_755502.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755502, uri, valid, _)

proc call*(call_755503: Call_PostReposOwnerRepoLabels_755495; repo: string;
          body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoLabels
  ## Create a label.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JArray (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755504 = newJObject()
  var header_755505 = newJObject()
  var body_755506 = newJObject()
  add(header_755505, "Accept", newJString(Accept))
  add(path_755504, "repo", newJString(repo))
  if body != nil:
    body_755506 = body
  add(path_755504, "owner", newJString(owner))
  result = call_755503.call(path_755504, nil, header_755505, nil, body_755506)

var postReposOwnerRepoLabels* = Call_PostReposOwnerRepoLabels_755495(
    name: "postReposOwnerRepoLabels", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels",
    validator: validate_PostReposOwnerRepoLabels_755496, base: "/",
    makeUrl: url_PostReposOwnerRepoLabels_755497, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoLabels_755485 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoLabels_755487(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoLabels_755486(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List all labels for this repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755488 = path.getOrDefault("repo")
  valid_755488 = validateParameter(valid_755488, JString, required = true,
                                 default = nil)
  if valid_755488 != nil:
    section.add "repo", valid_755488
  var valid_755489 = path.getOrDefault("owner")
  valid_755489 = validateParameter(valid_755489, JString, required = true,
                                 default = nil)
  if valid_755489 != nil:
    section.add "owner", valid_755489
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755490 = header.getOrDefault("Accept")
  valid_755490 = validateParameter(valid_755490, JString, required = false,
                                 default = nil)
  if valid_755490 != nil:
    section.add "Accept", valid_755490
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755491: Call_GetReposOwnerRepoLabels_755485; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List all labels for this repository.
  ## 
  let valid = call_755491.validator(path, query, header, formData, body, _)
  let scheme = call_755491.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755491.makeUrl(scheme.get, call_755491.host, call_755491.base,
                             call_755491.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755491, uri, valid, _)

proc call*(call_755492: Call_GetReposOwnerRepoLabels_755485; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoLabels
  ## List all labels for this repository.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755493 = newJObject()
  var header_755494 = newJObject()
  add(header_755494, "Accept", newJString(Accept))
  add(path_755493, "repo", newJString(repo))
  add(path_755493, "owner", newJString(owner))
  result = call_755492.call(path_755493, nil, header_755494, nil, nil)

var getReposOwnerRepoLabels* = Call_GetReposOwnerRepoLabels_755485(
    name: "getReposOwnerRepoLabels", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels",
    validator: validate_GetReposOwnerRepoLabels_755486, base: "/",
    makeUrl: url_GetReposOwnerRepoLabels_755487, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoLabelsName_755507 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoLabelsName_755509(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoLabelsName_755508(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Get a single label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   name: JString (required)
  ##       : Name of the label.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `name` field"
  var valid_755510 = path.getOrDefault("name")
  valid_755510 = validateParameter(valid_755510, JString, required = true,
                                 default = nil)
  if valid_755510 != nil:
    section.add "name", valid_755510
  var valid_755511 = path.getOrDefault("repo")
  valid_755511 = validateParameter(valid_755511, JString, required = true,
                                 default = nil)
  if valid_755511 != nil:
    section.add "repo", valid_755511
  var valid_755512 = path.getOrDefault("owner")
  valid_755512 = validateParameter(valid_755512, JString, required = true,
                                 default = nil)
  if valid_755512 != nil:
    section.add "owner", valid_755512
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755513 = header.getOrDefault("Accept")
  valid_755513 = validateParameter(valid_755513, JString, required = false,
                                 default = nil)
  if valid_755513 != nil:
    section.add "Accept", valid_755513
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755514: Call_GetReposOwnerRepoLabelsName_755507;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single label.
  ## 
  let valid = call_755514.validator(path, query, header, formData, body, _)
  let scheme = call_755514.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755514.makeUrl(scheme.get, call_755514.host, call_755514.base,
                             call_755514.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755514, uri, valid, _)

proc call*(call_755515: Call_GetReposOwnerRepoLabelsName_755507; name: string;
          repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoLabelsName
  ## Get a single label.
  ##   name: string (required)
  ##       : Name of the label.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755516 = newJObject()
  var header_755517 = newJObject()
  add(path_755516, "name", newJString(name))
  add(header_755517, "Accept", newJString(Accept))
  add(path_755516, "repo", newJString(repo))
  add(path_755516, "owner", newJString(owner))
  result = call_755515.call(path_755516, nil, header_755517, nil, nil)

var getReposOwnerRepoLabelsName* = Call_GetReposOwnerRepoLabelsName_755507(
    name: "getReposOwnerRepoLabelsName", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels/{name}",
    validator: validate_GetReposOwnerRepoLabelsName_755508, base: "/",
    makeUrl: url_GetReposOwnerRepoLabelsName_755509, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoLabelsName_755529 = ref object of OpenApiRestCall_753573
proc url_PatchReposOwnerRepoLabelsName_755531(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoLabelsName_755530(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Update a label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   name: JString (required)
  ##       : Name of the label.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `name` field"
  var valid_755532 = path.getOrDefault("name")
  valid_755532 = validateParameter(valid_755532, JString, required = true,
                                 default = nil)
  if valid_755532 != nil:
    section.add "name", valid_755532
  var valid_755533 = path.getOrDefault("repo")
  valid_755533 = validateParameter(valid_755533, JString, required = true,
                                 default = nil)
  if valid_755533 != nil:
    section.add "repo", valid_755533
  var valid_755534 = path.getOrDefault("owner")
  valid_755534 = validateParameter(valid_755534, JString, required = true,
                                 default = nil)
  if valid_755534 != nil:
    section.add "owner", valid_755534
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755535 = header.getOrDefault("Accept")
  valid_755535 = validateParameter(valid_755535, JString, required = false,
                                 default = nil)
  if valid_755535 != nil:
    section.add "Accept", valid_755535
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_755537: Call_PatchReposOwnerRepoLabelsName_755529;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Update a label.
  ## 
  let valid = call_755537.validator(path, query, header, formData, body, _)
  let scheme = call_755537.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755537.makeUrl(scheme.get, call_755537.host, call_755537.base,
                             call_755537.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755537, uri, valid, _)

proc call*(call_755538: Call_PatchReposOwnerRepoLabelsName_755529; name: string;
          repo: string; body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoLabelsName
  ## Update a label.
  ##   name: string (required)
  ##       : Name of the label.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JArray (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755539 = newJObject()
  var header_755540 = newJObject()
  var body_755541 = newJObject()
  add(path_755539, "name", newJString(name))
  add(header_755540, "Accept", newJString(Accept))
  add(path_755539, "repo", newJString(repo))
  if body != nil:
    body_755541 = body
  add(path_755539, "owner", newJString(owner))
  result = call_755538.call(path_755539, nil, header_755540, nil, body_755541)

var patchReposOwnerRepoLabelsName* = Call_PatchReposOwnerRepoLabelsName_755529(
    name: "patchReposOwnerRepoLabelsName", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels/{name}",
    validator: validate_PatchReposOwnerRepoLabelsName_755530, base: "/",
    makeUrl: url_PatchReposOwnerRepoLabelsName_755531, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoLabelsName_755518 = ref object of OpenApiRestCall_753573
proc url_DeleteReposOwnerRepoLabelsName_755520(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoLabelsName_755519(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Delete a label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   name: JString (required)
  ##       : Name of the label.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `name` field"
  var valid_755521 = path.getOrDefault("name")
  valid_755521 = validateParameter(valid_755521, JString, required = true,
                                 default = nil)
  if valid_755521 != nil:
    section.add "name", valid_755521
  var valid_755522 = path.getOrDefault("repo")
  valid_755522 = validateParameter(valid_755522, JString, required = true,
                                 default = nil)
  if valid_755522 != nil:
    section.add "repo", valid_755522
  var valid_755523 = path.getOrDefault("owner")
  valid_755523 = validateParameter(valid_755523, JString, required = true,
                                 default = nil)
  if valid_755523 != nil:
    section.add "owner", valid_755523
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755524 = header.getOrDefault("Accept")
  valid_755524 = validateParameter(valid_755524, JString, required = false,
                                 default = nil)
  if valid_755524 != nil:
    section.add "Accept", valid_755524
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755525: Call_DeleteReposOwnerRepoLabelsName_755518;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a label.
  ## 
  let valid = call_755525.validator(path, query, header, formData, body, _)
  let scheme = call_755525.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755525.makeUrl(scheme.get, call_755525.host, call_755525.base,
                             call_755525.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755525, uri, valid, _)

proc call*(call_755526: Call_DeleteReposOwnerRepoLabelsName_755518; name: string;
          repo: string; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoLabelsName
  ## Delete a label.
  ##   name: string (required)
  ##       : Name of the label.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755527 = newJObject()
  var header_755528 = newJObject()
  add(path_755527, "name", newJString(name))
  add(header_755528, "Accept", newJString(Accept))
  add(path_755527, "repo", newJString(repo))
  add(path_755527, "owner", newJString(owner))
  result = call_755526.call(path_755527, nil, header_755528, nil, nil)

var deleteReposOwnerRepoLabelsName* = Call_DeleteReposOwnerRepoLabelsName_755518(
    name: "deleteReposOwnerRepoLabelsName", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels/{name}",
    validator: validate_DeleteReposOwnerRepoLabelsName_755519, base: "/",
    makeUrl: url_DeleteReposOwnerRepoLabelsName_755520, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoLanguages_755542 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoLanguages_755544(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/languages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoLanguages_755543(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List languages.
  ## List languages for the specified repository. The value on the right of a
  ## language is the number of bytes of code written in that language.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755545 = path.getOrDefault("repo")
  valid_755545 = validateParameter(valid_755545, JString, required = true,
                                 default = nil)
  if valid_755545 != nil:
    section.add "repo", valid_755545
  var valid_755546 = path.getOrDefault("owner")
  valid_755546 = validateParameter(valid_755546, JString, required = true,
                                 default = nil)
  if valid_755546 != nil:
    section.add "owner", valid_755546
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755547 = header.getOrDefault("Accept")
  valid_755547 = validateParameter(valid_755547, JString, required = false,
                                 default = nil)
  if valid_755547 != nil:
    section.add "Accept", valid_755547
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755548: Call_GetReposOwnerRepoLanguages_755542;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List languages.
  ## List languages for the specified repository. The value on the right of a
  ## language is the number of bytes of code written in that language.
  ## 
  ## 
  let valid = call_755548.validator(path, query, header, formData, body, _)
  let scheme = call_755548.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755548.makeUrl(scheme.get, call_755548.host, call_755548.base,
                             call_755548.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755548, uri, valid, _)

proc call*(call_755549: Call_GetReposOwnerRepoLanguages_755542; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoLanguages
  ## List languages.
  ## List languages for the specified repository. The value on the right of a
  ## language is the number of bytes of code written in that language.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755550 = newJObject()
  var header_755551 = newJObject()
  add(header_755551, "Accept", newJString(Accept))
  add(path_755550, "repo", newJString(repo))
  add(path_755550, "owner", newJString(owner))
  result = call_755549.call(path_755550, nil, header_755551, nil, nil)

var getReposOwnerRepoLanguages* = Call_GetReposOwnerRepoLanguages_755542(
    name: "getReposOwnerRepoLanguages", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/languages",
    validator: validate_GetReposOwnerRepoLanguages_755543, base: "/",
    makeUrl: url_GetReposOwnerRepoLanguages_755544, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoMerges_755552 = ref object of OpenApiRestCall_753573
proc url_PostReposOwnerRepoMerges_755554(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/merges")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoMerges_755553(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Perform a merge.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755555 = path.getOrDefault("repo")
  valid_755555 = validateParameter(valid_755555, JString, required = true,
                                 default = nil)
  if valid_755555 != nil:
    section.add "repo", valid_755555
  var valid_755556 = path.getOrDefault("owner")
  valid_755556 = validateParameter(valid_755556, JString, required = true,
                                 default = nil)
  if valid_755556 != nil:
    section.add "owner", valid_755556
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755557 = header.getOrDefault("Accept")
  valid_755557 = validateParameter(valid_755557, JString, required = false,
                                 default = nil)
  if valid_755557 != nil:
    section.add "Accept", valid_755557
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_755559: Call_PostReposOwnerRepoMerges_755552; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Perform a merge.
  ## 
  let valid = call_755559.validator(path, query, header, formData, body, _)
  let scheme = call_755559.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755559.makeUrl(scheme.get, call_755559.host, call_755559.base,
                             call_755559.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755559, uri, valid, _)

proc call*(call_755560: Call_PostReposOwnerRepoMerges_755552; repo: string;
          body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoMerges
  ## Perform a merge.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755561 = newJObject()
  var header_755562 = newJObject()
  var body_755563 = newJObject()
  add(header_755562, "Accept", newJString(Accept))
  add(path_755561, "repo", newJString(repo))
  if body != nil:
    body_755563 = body
  add(path_755561, "owner", newJString(owner))
  result = call_755560.call(path_755561, nil, header_755562, nil, body_755563)

var postReposOwnerRepoMerges* = Call_PostReposOwnerRepoMerges_755552(
    name: "postReposOwnerRepoMerges", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/merges",
    validator: validate_PostReposOwnerRepoMerges_755553, base: "/",
    makeUrl: url_PostReposOwnerRepoMerges_755554, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoMilestones_755578 = ref object of OpenApiRestCall_753573
proc url_PostReposOwnerRepoMilestones_755580(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoMilestones_755579(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Create a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755581 = path.getOrDefault("repo")
  valid_755581 = validateParameter(valid_755581, JString, required = true,
                                 default = nil)
  if valid_755581 != nil:
    section.add "repo", valid_755581
  var valid_755582 = path.getOrDefault("owner")
  valid_755582 = validateParameter(valid_755582, JString, required = true,
                                 default = nil)
  if valid_755582 != nil:
    section.add "owner", valid_755582
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755583 = header.getOrDefault("Accept")
  valid_755583 = validateParameter(valid_755583, JString, required = false,
                                 default = nil)
  if valid_755583 != nil:
    section.add "Accept", valid_755583
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_755585: Call_PostReposOwnerRepoMilestones_755578;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a milestone.
  ## 
  let valid = call_755585.validator(path, query, header, formData, body, _)
  let scheme = call_755585.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755585.makeUrl(scheme.get, call_755585.host, call_755585.base,
                             call_755585.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755585, uri, valid, _)

proc call*(call_755586: Call_PostReposOwnerRepoMilestones_755578; repo: string;
          body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoMilestones
  ## Create a milestone.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755587 = newJObject()
  var header_755588 = newJObject()
  var body_755589 = newJObject()
  add(header_755588, "Accept", newJString(Accept))
  add(path_755587, "repo", newJString(repo))
  if body != nil:
    body_755589 = body
  add(path_755587, "owner", newJString(owner))
  result = call_755586.call(path_755587, nil, header_755588, nil, body_755589)

var postReposOwnerRepoMilestones* = Call_PostReposOwnerRepoMilestones_755578(
    name: "postReposOwnerRepoMilestones", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones",
    validator: validate_PostReposOwnerRepoMilestones_755579, base: "/",
    makeUrl: url_PostReposOwnerRepoMilestones_755580, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoMilestones_755564 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoMilestones_755566(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoMilestones_755565(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List milestones for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755567 = path.getOrDefault("repo")
  valid_755567 = validateParameter(valid_755567, JString, required = true,
                                 default = nil)
  if valid_755567 != nil:
    section.add "repo", valid_755567
  var valid_755568 = path.getOrDefault("owner")
  valid_755568 = validateParameter(valid_755568, JString, required = true,
                                 default = nil)
  if valid_755568 != nil:
    section.add "owner", valid_755568
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  ##   state: JString
  ##        : String to filter by state.
  section = newJObject()
  var valid_755569 = query.getOrDefault("sort")
  valid_755569 = validateParameter(valid_755569, JString, required = false,
                                 default = newJString("due_date"))
  if valid_755569 != nil:
    section.add "sort", valid_755569
  var valid_755570 = query.getOrDefault("direction")
  valid_755570 = validateParameter(valid_755570, JString, required = false,
                                 default = nil)
  if valid_755570 != nil:
    section.add "direction", valid_755570
  var valid_755571 = query.getOrDefault("state")
  valid_755571 = validateParameter(valid_755571, JString, required = false,
                                 default = newJString("open"))
  if valid_755571 != nil:
    section.add "state", valid_755571
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755572 = header.getOrDefault("Accept")
  valid_755572 = validateParameter(valid_755572, JString, required = false,
                                 default = nil)
  if valid_755572 != nil:
    section.add "Accept", valid_755572
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755573: Call_GetReposOwnerRepoMilestones_755564;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List milestones for a repository.
  ## 
  let valid = call_755573.validator(path, query, header, formData, body, _)
  let scheme = call_755573.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755573.makeUrl(scheme.get, call_755573.host, call_755573.base,
                             call_755573.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755573, uri, valid, _)

proc call*(call_755574: Call_GetReposOwnerRepoMilestones_755564; repo: string;
          owner: string; sort: string = "due_date"; direction: string = "";
          Accept: string = ""; state: string = "open"): Recallable =
  ## getReposOwnerRepoMilestones
  ## List milestones for a repository.
  ##   sort: string
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   state: string
  ##        : String to filter by state.
  var path_755575 = newJObject()
  var query_755576 = newJObject()
  var header_755577 = newJObject()
  add(query_755576, "sort", newJString(sort))
  add(query_755576, "direction", newJString(direction))
  add(header_755577, "Accept", newJString(Accept))
  add(path_755575, "repo", newJString(repo))
  add(path_755575, "owner", newJString(owner))
  add(query_755576, "state", newJString(state))
  result = call_755574.call(path_755575, query_755576, header_755577, nil, nil)

var getReposOwnerRepoMilestones* = Call_GetReposOwnerRepoMilestones_755564(
    name: "getReposOwnerRepoMilestones", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones",
    validator: validate_GetReposOwnerRepoMilestones_755565, base: "/",
    makeUrl: url_GetReposOwnerRepoMilestones_755566, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoMilestonesNumber_755590 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoMilestonesNumber_755592(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoMilestonesNumber_755591(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Get a single milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `number` field"
  var valid_755593 = path.getOrDefault("number")
  valid_755593 = validateParameter(valid_755593, JInt, required = true, default = nil)
  if valid_755593 != nil:
    section.add "number", valid_755593
  var valid_755594 = path.getOrDefault("repo")
  valid_755594 = validateParameter(valid_755594, JString, required = true,
                                 default = nil)
  if valid_755594 != nil:
    section.add "repo", valid_755594
  var valid_755595 = path.getOrDefault("owner")
  valid_755595 = validateParameter(valid_755595, JString, required = true,
                                 default = nil)
  if valid_755595 != nil:
    section.add "owner", valid_755595
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755596 = header.getOrDefault("Accept")
  valid_755596 = validateParameter(valid_755596, JString, required = false,
                                 default = nil)
  if valid_755596 != nil:
    section.add "Accept", valid_755596
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755597: Call_GetReposOwnerRepoMilestonesNumber_755590;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single milestone.
  ## 
  let valid = call_755597.validator(path, query, header, formData, body, _)
  let scheme = call_755597.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755597.makeUrl(scheme.get, call_755597.host, call_755597.base,
                             call_755597.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755597, uri, valid, _)

proc call*(call_755598: Call_GetReposOwnerRepoMilestonesNumber_755590; number: int;
          repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoMilestonesNumber
  ## Get a single milestone.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755599 = newJObject()
  var header_755600 = newJObject()
  add(header_755600, "Accept", newJString(Accept))
  add(path_755599, "number", newJInt(number))
  add(path_755599, "repo", newJString(repo))
  add(path_755599, "owner", newJString(owner))
  result = call_755598.call(path_755599, nil, header_755600, nil, nil)

var getReposOwnerRepoMilestonesNumber* = Call_GetReposOwnerRepoMilestonesNumber_755590(
    name: "getReposOwnerRepoMilestonesNumber", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones/{number}",
    validator: validate_GetReposOwnerRepoMilestonesNumber_755591, base: "/",
    makeUrl: url_GetReposOwnerRepoMilestonesNumber_755592, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoMilestonesNumber_755612 = ref object of OpenApiRestCall_753573
proc url_PatchReposOwnerRepoMilestonesNumber_755614(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoMilestonesNumber_755613(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Update a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `number` field"
  var valid_755615 = path.getOrDefault("number")
  valid_755615 = validateParameter(valid_755615, JInt, required = true, default = nil)
  if valid_755615 != nil:
    section.add "number", valid_755615
  var valid_755616 = path.getOrDefault("repo")
  valid_755616 = validateParameter(valid_755616, JString, required = true,
                                 default = nil)
  if valid_755616 != nil:
    section.add "repo", valid_755616
  var valid_755617 = path.getOrDefault("owner")
  valid_755617 = validateParameter(valid_755617, JString, required = true,
                                 default = nil)
  if valid_755617 != nil:
    section.add "owner", valid_755617
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755618 = header.getOrDefault("Accept")
  valid_755618 = validateParameter(valid_755618, JString, required = false,
                                 default = nil)
  if valid_755618 != nil:
    section.add "Accept", valid_755618
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_755620: Call_PatchReposOwnerRepoMilestonesNumber_755612;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Update a milestone.
  ## 
  let valid = call_755620.validator(path, query, header, formData, body, _)
  let scheme = call_755620.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755620.makeUrl(scheme.get, call_755620.host, call_755620.base,
                             call_755620.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755620, uri, valid, _)

proc call*(call_755621: Call_PatchReposOwnerRepoMilestonesNumber_755612;
          number: int; repo: string; body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoMilestonesNumber
  ## Update a milestone.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755622 = newJObject()
  var header_755623 = newJObject()
  var body_755624 = newJObject()
  add(header_755623, "Accept", newJString(Accept))
  add(path_755622, "number", newJInt(number))
  add(path_755622, "repo", newJString(repo))
  if body != nil:
    body_755624 = body
  add(path_755622, "owner", newJString(owner))
  result = call_755621.call(path_755622, nil, header_755623, nil, body_755624)

var patchReposOwnerRepoMilestonesNumber* = Call_PatchReposOwnerRepoMilestonesNumber_755612(
    name: "patchReposOwnerRepoMilestonesNumber", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones/{number}",
    validator: validate_PatchReposOwnerRepoMilestonesNumber_755613, base: "/",
    makeUrl: url_PatchReposOwnerRepoMilestonesNumber_755614,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoMilestonesNumber_755601 = ref object of OpenApiRestCall_753573
proc url_DeleteReposOwnerRepoMilestonesNumber_755603(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoMilestonesNumber_755602(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Delete a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `number` field"
  var valid_755604 = path.getOrDefault("number")
  valid_755604 = validateParameter(valid_755604, JInt, required = true, default = nil)
  if valid_755604 != nil:
    section.add "number", valid_755604
  var valid_755605 = path.getOrDefault("repo")
  valid_755605 = validateParameter(valid_755605, JString, required = true,
                                 default = nil)
  if valid_755605 != nil:
    section.add "repo", valid_755605
  var valid_755606 = path.getOrDefault("owner")
  valid_755606 = validateParameter(valid_755606, JString, required = true,
                                 default = nil)
  if valid_755606 != nil:
    section.add "owner", valid_755606
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755607 = header.getOrDefault("Accept")
  valid_755607 = validateParameter(valid_755607, JString, required = false,
                                 default = nil)
  if valid_755607 != nil:
    section.add "Accept", valid_755607
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755608: Call_DeleteReposOwnerRepoMilestonesNumber_755601;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a milestone.
  ## 
  let valid = call_755608.validator(path, query, header, formData, body, _)
  let scheme = call_755608.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755608.makeUrl(scheme.get, call_755608.host, call_755608.base,
                             call_755608.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755608, uri, valid, _)

proc call*(call_755609: Call_DeleteReposOwnerRepoMilestonesNumber_755601;
          number: int; repo: string; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoMilestonesNumber
  ## Delete a milestone.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755610 = newJObject()
  var header_755611 = newJObject()
  add(header_755611, "Accept", newJString(Accept))
  add(path_755610, "number", newJInt(number))
  add(path_755610, "repo", newJString(repo))
  add(path_755610, "owner", newJString(owner))
  result = call_755609.call(path_755610, nil, header_755611, nil, nil)

var deleteReposOwnerRepoMilestonesNumber* = Call_DeleteReposOwnerRepoMilestonesNumber_755601(
    name: "deleteReposOwnerRepoMilestonesNumber", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones/{number}",
    validator: validate_DeleteReposOwnerRepoMilestonesNumber_755602, base: "/",
    makeUrl: url_DeleteReposOwnerRepoMilestonesNumber_755603,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoMilestonesNumberLabels_755625 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoMilestonesNumberLabels_755627(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoMilestonesNumberLabels_755626(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Get labels for every issue in a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `number` field"
  var valid_755628 = path.getOrDefault("number")
  valid_755628 = validateParameter(valid_755628, JInt, required = true, default = nil)
  if valid_755628 != nil:
    section.add "number", valid_755628
  var valid_755629 = path.getOrDefault("repo")
  valid_755629 = validateParameter(valid_755629, JString, required = true,
                                 default = nil)
  if valid_755629 != nil:
    section.add "repo", valid_755629
  var valid_755630 = path.getOrDefault("owner")
  valid_755630 = validateParameter(valid_755630, JString, required = true,
                                 default = nil)
  if valid_755630 != nil:
    section.add "owner", valid_755630
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755631 = header.getOrDefault("Accept")
  valid_755631 = validateParameter(valid_755631, JString, required = false,
                                 default = nil)
  if valid_755631 != nil:
    section.add "Accept", valid_755631
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755632: Call_GetReposOwnerRepoMilestonesNumberLabels_755625;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get labels for every issue in a milestone.
  ## 
  let valid = call_755632.validator(path, query, header, formData, body, _)
  let scheme = call_755632.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755632.makeUrl(scheme.get, call_755632.host, call_755632.base,
                             call_755632.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755632, uri, valid, _)

proc call*(call_755633: Call_GetReposOwnerRepoMilestonesNumberLabels_755625;
          number: int; repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoMilestonesNumberLabels
  ## Get labels for every issue in a milestone.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755634 = newJObject()
  var header_755635 = newJObject()
  add(header_755635, "Accept", newJString(Accept))
  add(path_755634, "number", newJInt(number))
  add(path_755634, "repo", newJString(repo))
  add(path_755634, "owner", newJString(owner))
  result = call_755633.call(path_755634, nil, header_755635, nil, nil)

var getReposOwnerRepoMilestonesNumberLabels* = Call_GetReposOwnerRepoMilestonesNumberLabels_755625(
    name: "getReposOwnerRepoMilestonesNumberLabels", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/milestones/{number}/labels",
    validator: validate_GetReposOwnerRepoMilestonesNumberLabels_755626, base: "/",
    makeUrl: url_GetReposOwnerRepoMilestonesNumberLabels_755627,
    schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoNotifications_755650 = ref object of OpenApiRestCall_753573
proc url_PutReposOwnerRepoNotifications_755652(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/notifications")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoNotifications_755651(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Mark notifications as read in a repository.
  ## Marking all notifications in a repository as "read" removes them from the
  ## default view on GitHub.com.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755653 = path.getOrDefault("repo")
  valid_755653 = validateParameter(valid_755653, JString, required = true,
                                 default = nil)
  if valid_755653 != nil:
    section.add "repo", valid_755653
  var valid_755654 = path.getOrDefault("owner")
  valid_755654 = validateParameter(valid_755654, JString, required = true,
                                 default = nil)
  if valid_755654 != nil:
    section.add "owner", valid_755654
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755655 = header.getOrDefault("Accept")
  valid_755655 = validateParameter(valid_755655, JString, required = false,
                                 default = nil)
  if valid_755655 != nil:
    section.add "Accept", valid_755655
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_755657: Call_PutReposOwnerRepoNotifications_755650;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Mark notifications as read in a repository.
  ## Marking all notifications in a repository as "read" removes them from the
  ## default view on GitHub.com.
  ## 
  ## 
  let valid = call_755657.validator(path, query, header, formData, body, _)
  let scheme = call_755657.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755657.makeUrl(scheme.get, call_755657.host, call_755657.base,
                             call_755657.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755657, uri, valid, _)

proc call*(call_755658: Call_PutReposOwnerRepoNotifications_755650; repo: string;
          body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoNotifications
  ## Mark notifications as read in a repository.
  ## Marking all notifications in a repository as "read" removes them from the
  ## default view on GitHub.com.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755659 = newJObject()
  var header_755660 = newJObject()
  var body_755661 = newJObject()
  add(header_755660, "Accept", newJString(Accept))
  add(path_755659, "repo", newJString(repo))
  if body != nil:
    body_755661 = body
  add(path_755659, "owner", newJString(owner))
  result = call_755658.call(path_755659, nil, header_755660, nil, body_755661)

var putReposOwnerRepoNotifications* = Call_PutReposOwnerRepoNotifications_755650(
    name: "putReposOwnerRepoNotifications", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/notifications",
    validator: validate_PutReposOwnerRepoNotifications_755651, base: "/",
    makeUrl: url_PutReposOwnerRepoNotifications_755652, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoNotifications_755636 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoNotifications_755638(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/notifications")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoNotifications_755637(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## List your notifications in a repository
  ## List all notifications for the current user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755639 = path.getOrDefault("repo")
  valid_755639 = validateParameter(valid_755639, JString, required = true,
                                 default = nil)
  if valid_755639 != nil:
    section.add "repo", valid_755639
  var valid_755640 = path.getOrDefault("owner")
  valid_755640 = validateParameter(valid_755640, JString, required = true,
                                 default = nil)
  if valid_755640 != nil:
    section.add "owner", valid_755640
  result.add "path", section
  ## parameters in `query` object:
  ##   participating: JBool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   all: JBool
  ##      : True to show notifications marked as read.
  section = newJObject()
  var valid_755641 = query.getOrDefault("participating")
  valid_755641 = validateParameter(valid_755641, JBool, required = false, default = nil)
  if valid_755641 != nil:
    section.add "participating", valid_755641
  var valid_755642 = query.getOrDefault("since")
  valid_755642 = validateParameter(valid_755642, JString, required = false,
                                 default = nil)
  if valid_755642 != nil:
    section.add "since", valid_755642
  var valid_755643 = query.getOrDefault("all")
  valid_755643 = validateParameter(valid_755643, JBool, required = false, default = nil)
  if valid_755643 != nil:
    section.add "all", valid_755643
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755644 = header.getOrDefault("Accept")
  valid_755644 = validateParameter(valid_755644, JString, required = false,
                                 default = nil)
  if valid_755644 != nil:
    section.add "Accept", valid_755644
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755645: Call_GetReposOwnerRepoNotifications_755636;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List your notifications in a repository
  ## List all notifications for the current user.
  ## 
  ## 
  let valid = call_755645.validator(path, query, header, formData, body, _)
  let scheme = call_755645.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755645.makeUrl(scheme.get, call_755645.host, call_755645.base,
                             call_755645.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755645, uri, valid, _)

proc call*(call_755646: Call_GetReposOwnerRepoNotifications_755636; repo: string;
          owner: string; participating: bool = false; since: string = "";
          all: bool = false; Accept: string = ""): Recallable =
  ## getReposOwnerRepoNotifications
  ## List your notifications in a repository
  ## List all notifications for the current user.
  ## 
  ##   participating: bool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   all: bool
  ##      : True to show notifications marked as read.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755647 = newJObject()
  var query_755648 = newJObject()
  var header_755649 = newJObject()
  add(query_755648, "participating", newJBool(participating))
  add(query_755648, "since", newJString(since))
  add(query_755648, "all", newJBool(all))
  add(header_755649, "Accept", newJString(Accept))
  add(path_755647, "repo", newJString(repo))
  add(path_755647, "owner", newJString(owner))
  result = call_755646.call(path_755647, query_755648, header_755649, nil, nil)

var getReposOwnerRepoNotifications* = Call_GetReposOwnerRepoNotifications_755636(
    name: "getReposOwnerRepoNotifications", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/notifications",
    validator: validate_GetReposOwnerRepoNotifications_755637, base: "/",
    makeUrl: url_GetReposOwnerRepoNotifications_755638, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoPulls_755676 = ref object of OpenApiRestCall_753573
proc url_PostReposOwnerRepoPulls_755678(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoPulls_755677(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Create a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755679 = path.getOrDefault("repo")
  valid_755679 = validateParameter(valid_755679, JString, required = true,
                                 default = nil)
  if valid_755679 != nil:
    section.add "repo", valid_755679
  var valid_755680 = path.getOrDefault("owner")
  valid_755680 = validateParameter(valid_755680, JString, required = true,
                                 default = nil)
  if valid_755680 != nil:
    section.add "owner", valid_755680
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755681 = header.getOrDefault("Accept")
  valid_755681 = validateParameter(valid_755681, JString, required = false,
                                 default = nil)
  if valid_755681 != nil:
    section.add "Accept", valid_755681
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_755683: Call_PostReposOwnerRepoPulls_755676; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a pull request.
  ## 
  let valid = call_755683.validator(path, query, header, formData, body, _)
  let scheme = call_755683.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755683.makeUrl(scheme.get, call_755683.host, call_755683.base,
                             call_755683.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755683, uri, valid, _)

proc call*(call_755684: Call_PostReposOwnerRepoPulls_755676; repo: string;
          body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoPulls
  ## Create a pull request.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755685 = newJObject()
  var header_755686 = newJObject()
  var body_755687 = newJObject()
  add(header_755686, "Accept", newJString(Accept))
  add(path_755685, "repo", newJString(repo))
  if body != nil:
    body_755687 = body
  add(path_755685, "owner", newJString(owner))
  result = call_755684.call(path_755685, nil, header_755686, nil, body_755687)

var postReposOwnerRepoPulls* = Call_PostReposOwnerRepoPulls_755676(
    name: "postReposOwnerRepoPulls", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls",
    validator: validate_PostReposOwnerRepoPulls_755677, base: "/",
    makeUrl: url_PostReposOwnerRepoPulls_755678, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPulls_755662 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoPulls_755664(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPulls_755663(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List pull requests.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755665 = path.getOrDefault("repo")
  valid_755665 = validateParameter(valid_755665, JString, required = true,
                                 default = nil)
  if valid_755665 != nil:
    section.add "repo", valid_755665
  var valid_755666 = path.getOrDefault("owner")
  valid_755666 = validateParameter(valid_755666, JString, required = true,
                                 default = nil)
  if valid_755666 != nil:
    section.add "owner", valid_755666
  result.add "path", section
  ## parameters in `query` object:
  ##   base: JString
  ##       : Filter pulls by base branch name. Example - gh-pages.
  ##   head: JString
  ##       : Filter pulls by head user and branch name in the format of 'user:ref-name'.
  ## Example: github:new-script-format.
  ## 
  ##   state: JString
  ##        : String to filter by state.
  section = newJObject()
  var valid_755667 = query.getOrDefault("base")
  valid_755667 = validateParameter(valid_755667, JString, required = false,
                                 default = nil)
  if valid_755667 != nil:
    section.add "base", valid_755667
  var valid_755668 = query.getOrDefault("head")
  valid_755668 = validateParameter(valid_755668, JString, required = false,
                                 default = nil)
  if valid_755668 != nil:
    section.add "head", valid_755668
  var valid_755669 = query.getOrDefault("state")
  valid_755669 = validateParameter(valid_755669, JString, required = false,
                                 default = newJString("open"))
  if valid_755669 != nil:
    section.add "state", valid_755669
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755670 = header.getOrDefault("Accept")
  valid_755670 = validateParameter(valid_755670, JString, required = false,
                                 default = nil)
  if valid_755670 != nil:
    section.add "Accept", valid_755670
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755671: Call_GetReposOwnerRepoPulls_755662; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List pull requests.
  ## 
  let valid = call_755671.validator(path, query, header, formData, body, _)
  let scheme = call_755671.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755671.makeUrl(scheme.get, call_755671.host, call_755671.base,
                             call_755671.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755671, uri, valid, _)

proc call*(call_755672: Call_GetReposOwnerRepoPulls_755662; repo: string;
          owner: string; base: string = ""; Accept: string = ""; head: string = "";
          state: string = "open"): Recallable =
  ## getReposOwnerRepoPulls
  ## List pull requests.
  ##   base: string
  ##       : Filter pulls by base branch name. Example - gh-pages.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   head: string
  ##       : Filter pulls by head user and branch name in the format of 'user:ref-name'.
  ## Example: github:new-script-format.
  ## 
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   state: string
  ##        : String to filter by state.
  var path_755673 = newJObject()
  var query_755674 = newJObject()
  var header_755675 = newJObject()
  add(query_755674, "base", newJString(base))
  add(header_755675, "Accept", newJString(Accept))
  add(query_755674, "head", newJString(head))
  add(path_755673, "repo", newJString(repo))
  add(path_755673, "owner", newJString(owner))
  add(query_755674, "state", newJString(state))
  result = call_755672.call(path_755673, query_755674, header_755675, nil, nil)

var getReposOwnerRepoPulls* = Call_GetReposOwnerRepoPulls_755662(
    name: "getReposOwnerRepoPulls", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls",
    validator: validate_GetReposOwnerRepoPulls_755663, base: "/",
    makeUrl: url_GetReposOwnerRepoPulls_755664, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsComments_755688 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoPullsComments_755690(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsComments_755689(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## List comments in a repository.
  ## By default, Review Comments are ordered by ascending ID.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755691 = path.getOrDefault("repo")
  valid_755691 = validateParameter(valid_755691, JString, required = true,
                                 default = nil)
  if valid_755691 != nil:
    section.add "repo", valid_755691
  var valid_755692 = path.getOrDefault("owner")
  valid_755692 = validateParameter(valid_755692, JString, required = true,
                                 default = nil)
  if valid_755692 != nil:
    section.add "owner", valid_755692
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  section = newJObject()
  var valid_755693 = query.getOrDefault("sort")
  valid_755693 = validateParameter(valid_755693, JString, required = false,
                                 default = newJString("created"))
  if valid_755693 != nil:
    section.add "sort", valid_755693
  var valid_755694 = query.getOrDefault("since")
  valid_755694 = validateParameter(valid_755694, JString, required = false,
                                 default = nil)
  if valid_755694 != nil:
    section.add "since", valid_755694
  var valid_755695 = query.getOrDefault("direction")
  valid_755695 = validateParameter(valid_755695, JString, required = false,
                                 default = nil)
  if valid_755695 != nil:
    section.add "direction", valid_755695
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755696 = header.getOrDefault("Accept")
  valid_755696 = validateParameter(valid_755696, JString, required = false,
                                 default = nil)
  if valid_755696 != nil:
    section.add "Accept", valid_755696
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755697: Call_GetReposOwnerRepoPullsComments_755688;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List comments in a repository.
  ## By default, Review Comments are ordered by ascending ID.
  ## 
  ## 
  let valid = call_755697.validator(path, query, header, formData, body, _)
  let scheme = call_755697.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755697.makeUrl(scheme.get, call_755697.host, call_755697.base,
                             call_755697.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755697, uri, valid, _)

proc call*(call_755698: Call_GetReposOwnerRepoPullsComments_755688; repo: string;
          owner: string; sort: string = "created"; since: string = "";
          direction: string = ""; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsComments
  ## List comments in a repository.
  ## By default, Review Comments are ordered by ascending ID.
  ## 
  ##   sort: string
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755699 = newJObject()
  var query_755700 = newJObject()
  var header_755701 = newJObject()
  add(query_755700, "sort", newJString(sort))
  add(query_755700, "since", newJString(since))
  add(query_755700, "direction", newJString(direction))
  add(header_755701, "Accept", newJString(Accept))
  add(path_755699, "repo", newJString(repo))
  add(path_755699, "owner", newJString(owner))
  result = call_755698.call(path_755699, query_755700, header_755701, nil, nil)

var getReposOwnerRepoPullsComments* = Call_GetReposOwnerRepoPullsComments_755688(
    name: "getReposOwnerRepoPullsComments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/comments",
    validator: validate_GetReposOwnerRepoPullsComments_755689, base: "/",
    makeUrl: url_GetReposOwnerRepoPullsComments_755690, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsCommentsCommentId_755702 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoPullsCommentsCommentId_755704(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsCommentsCommentId_755703(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Get a single comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   commentId: JInt (required)
  ##            : Id of comment.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `commentId` field"
  var valid_755705 = path.getOrDefault("commentId")
  valid_755705 = validateParameter(valid_755705, JInt, required = true, default = nil)
  if valid_755705 != nil:
    section.add "commentId", valid_755705
  var valid_755706 = path.getOrDefault("repo")
  valid_755706 = validateParameter(valid_755706, JString, required = true,
                                 default = nil)
  if valid_755706 != nil:
    section.add "repo", valid_755706
  var valid_755707 = path.getOrDefault("owner")
  valid_755707 = validateParameter(valid_755707, JString, required = true,
                                 default = nil)
  if valid_755707 != nil:
    section.add "owner", valid_755707
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755708 = header.getOrDefault("Accept")
  valid_755708 = validateParameter(valid_755708, JString, required = false,
                                 default = nil)
  if valid_755708 != nil:
    section.add "Accept", valid_755708
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755709: Call_GetReposOwnerRepoPullsCommentsCommentId_755702;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single comment.
  ## 
  let valid = call_755709.validator(path, query, header, formData, body, _)
  let scheme = call_755709.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755709.makeUrl(scheme.get, call_755709.host, call_755709.base,
                             call_755709.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755709, uri, valid, _)

proc call*(call_755710: Call_GetReposOwnerRepoPullsCommentsCommentId_755702;
          commentId: int; repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsCommentsCommentId
  ## Get a single comment.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   commentId: int (required)
  ##            : Id of comment.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755711 = newJObject()
  var header_755712 = newJObject()
  add(header_755712, "Accept", newJString(Accept))
  add(path_755711, "commentId", newJInt(commentId))
  add(path_755711, "repo", newJString(repo))
  add(path_755711, "owner", newJString(owner))
  result = call_755710.call(path_755711, nil, header_755712, nil, nil)

var getReposOwnerRepoPullsCommentsCommentId* = Call_GetReposOwnerRepoPullsCommentsCommentId_755702(
    name: "getReposOwnerRepoPullsCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/comments/{commentId}",
    validator: validate_GetReposOwnerRepoPullsCommentsCommentId_755703, base: "/",
    makeUrl: url_GetReposOwnerRepoPullsCommentsCommentId_755704,
    schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoPullsCommentsCommentId_755724 = ref object of OpenApiRestCall_753573
proc url_PatchReposOwnerRepoPullsCommentsCommentId_755726(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoPullsCommentsCommentId_755725(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Edit a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   commentId: JInt (required)
  ##            : Id of comment.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `commentId` field"
  var valid_755727 = path.getOrDefault("commentId")
  valid_755727 = validateParameter(valid_755727, JInt, required = true, default = nil)
  if valid_755727 != nil:
    section.add "commentId", valid_755727
  var valid_755728 = path.getOrDefault("repo")
  valid_755728 = validateParameter(valid_755728, JString, required = true,
                                 default = nil)
  if valid_755728 != nil:
    section.add "repo", valid_755728
  var valid_755729 = path.getOrDefault("owner")
  valid_755729 = validateParameter(valid_755729, JString, required = true,
                                 default = nil)
  if valid_755729 != nil:
    section.add "owner", valid_755729
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755730 = header.getOrDefault("Accept")
  valid_755730 = validateParameter(valid_755730, JString, required = false,
                                 default = nil)
  if valid_755730 != nil:
    section.add "Accept", valid_755730
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_755732: Call_PatchReposOwnerRepoPullsCommentsCommentId_755724;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit a comment.
  ## 
  let valid = call_755732.validator(path, query, header, formData, body, _)
  let scheme = call_755732.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755732.makeUrl(scheme.get, call_755732.host, call_755732.base,
                             call_755732.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755732, uri, valid, _)

proc call*(call_755733: Call_PatchReposOwnerRepoPullsCommentsCommentId_755724;
          commentId: int; repo: string; body: JsonNode; owner: string;
          Accept: string = ""): Recallable =
  ## patchReposOwnerRepoPullsCommentsCommentId
  ## Edit a comment.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   commentId: int (required)
  ##            : Id of comment.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755734 = newJObject()
  var header_755735 = newJObject()
  var body_755736 = newJObject()
  add(header_755735, "Accept", newJString(Accept))
  add(path_755734, "commentId", newJInt(commentId))
  add(path_755734, "repo", newJString(repo))
  if body != nil:
    body_755736 = body
  add(path_755734, "owner", newJString(owner))
  result = call_755733.call(path_755734, nil, header_755735, nil, body_755736)

var patchReposOwnerRepoPullsCommentsCommentId* = Call_PatchReposOwnerRepoPullsCommentsCommentId_755724(
    name: "patchReposOwnerRepoPullsCommentsCommentId", meth: HttpMethod.HttpPatch,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/comments/{commentId}",
    validator: validate_PatchReposOwnerRepoPullsCommentsCommentId_755725,
    base: "/", makeUrl: url_PatchReposOwnerRepoPullsCommentsCommentId_755726,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoPullsCommentsCommentId_755713 = ref object of OpenApiRestCall_753573
proc url_DeleteReposOwnerRepoPullsCommentsCommentId_755715(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoPullsCommentsCommentId_755714(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Delete a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   commentId: JInt (required)
  ##            : Id of comment.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `commentId` field"
  var valid_755716 = path.getOrDefault("commentId")
  valid_755716 = validateParameter(valid_755716, JInt, required = true, default = nil)
  if valid_755716 != nil:
    section.add "commentId", valid_755716
  var valid_755717 = path.getOrDefault("repo")
  valid_755717 = validateParameter(valid_755717, JString, required = true,
                                 default = nil)
  if valid_755717 != nil:
    section.add "repo", valid_755717
  var valid_755718 = path.getOrDefault("owner")
  valid_755718 = validateParameter(valid_755718, JString, required = true,
                                 default = nil)
  if valid_755718 != nil:
    section.add "owner", valid_755718
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755719 = header.getOrDefault("Accept")
  valid_755719 = validateParameter(valid_755719, JString, required = false,
                                 default = nil)
  if valid_755719 != nil:
    section.add "Accept", valid_755719
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755720: Call_DeleteReposOwnerRepoPullsCommentsCommentId_755713;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a comment.
  ## 
  let valid = call_755720.validator(path, query, header, formData, body, _)
  let scheme = call_755720.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755720.makeUrl(scheme.get, call_755720.host, call_755720.base,
                             call_755720.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755720, uri, valid, _)

proc call*(call_755721: Call_DeleteReposOwnerRepoPullsCommentsCommentId_755713;
          commentId: int; repo: string; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoPullsCommentsCommentId
  ## Delete a comment.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   commentId: int (required)
  ##            : Id of comment.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755722 = newJObject()
  var header_755723 = newJObject()
  add(header_755723, "Accept", newJString(Accept))
  add(path_755722, "commentId", newJInt(commentId))
  add(path_755722, "repo", newJString(repo))
  add(path_755722, "owner", newJString(owner))
  result = call_755721.call(path_755722, nil, header_755723, nil, nil)

var deleteReposOwnerRepoPullsCommentsCommentId* = Call_DeleteReposOwnerRepoPullsCommentsCommentId_755713(
    name: "deleteReposOwnerRepoPullsCommentsCommentId",
    meth: HttpMethod.HttpDelete, host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/comments/{commentId}",
    validator: validate_DeleteReposOwnerRepoPullsCommentsCommentId_755714,
    base: "/", makeUrl: url_DeleteReposOwnerRepoPullsCommentsCommentId_755715,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumber_755737 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoPullsNumber_755739(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumber_755738(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Get a single pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `number` field"
  var valid_755740 = path.getOrDefault("number")
  valid_755740 = validateParameter(valid_755740, JInt, required = true, default = nil)
  if valid_755740 != nil:
    section.add "number", valid_755740
  var valid_755741 = path.getOrDefault("repo")
  valid_755741 = validateParameter(valid_755741, JString, required = true,
                                 default = nil)
  if valid_755741 != nil:
    section.add "repo", valid_755741
  var valid_755742 = path.getOrDefault("owner")
  valid_755742 = validateParameter(valid_755742, JString, required = true,
                                 default = nil)
  if valid_755742 != nil:
    section.add "owner", valid_755742
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755743 = header.getOrDefault("Accept")
  valid_755743 = validateParameter(valid_755743, JString, required = false,
                                 default = nil)
  if valid_755743 != nil:
    section.add "Accept", valid_755743
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755744: Call_GetReposOwnerRepoPullsNumber_755737;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single pull request.
  ## 
  let valid = call_755744.validator(path, query, header, formData, body, _)
  let scheme = call_755744.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755744.makeUrl(scheme.get, call_755744.host, call_755744.base,
                             call_755744.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755744, uri, valid, _)

proc call*(call_755745: Call_GetReposOwnerRepoPullsNumber_755737; number: int;
          repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumber
  ## Get a single pull request.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   number: int (required)
  ##         : Id of pull.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755746 = newJObject()
  var header_755747 = newJObject()
  add(header_755747, "Accept", newJString(Accept))
  add(path_755746, "number", newJInt(number))
  add(path_755746, "repo", newJString(repo))
  add(path_755746, "owner", newJString(owner))
  result = call_755745.call(path_755746, nil, header_755747, nil, nil)

var getReposOwnerRepoPullsNumber* = Call_GetReposOwnerRepoPullsNumber_755737(
    name: "getReposOwnerRepoPullsNumber", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}",
    validator: validate_GetReposOwnerRepoPullsNumber_755738, base: "/",
    makeUrl: url_GetReposOwnerRepoPullsNumber_755739, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoPullsNumber_755748 = ref object of OpenApiRestCall_753573
proc url_PatchReposOwnerRepoPullsNumber_755750(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoPullsNumber_755749(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Update a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `number` field"
  var valid_755751 = path.getOrDefault("number")
  valid_755751 = validateParameter(valid_755751, JInt, required = true, default = nil)
  if valid_755751 != nil:
    section.add "number", valid_755751
  var valid_755752 = path.getOrDefault("repo")
  valid_755752 = validateParameter(valid_755752, JString, required = true,
                                 default = nil)
  if valid_755752 != nil:
    section.add "repo", valid_755752
  var valid_755753 = path.getOrDefault("owner")
  valid_755753 = validateParameter(valid_755753, JString, required = true,
                                 default = nil)
  if valid_755753 != nil:
    section.add "owner", valid_755753
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755754 = header.getOrDefault("Accept")
  valid_755754 = validateParameter(valid_755754, JString, required = false,
                                 default = nil)
  if valid_755754 != nil:
    section.add "Accept", valid_755754
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_755756: Call_PatchReposOwnerRepoPullsNumber_755748;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Update a pull request.
  ## 
  let valid = call_755756.validator(path, query, header, formData, body, _)
  let scheme = call_755756.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755756.makeUrl(scheme.get, call_755756.host, call_755756.base,
                             call_755756.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755756, uri, valid, _)

proc call*(call_755757: Call_PatchReposOwnerRepoPullsNumber_755748; number: int;
          repo: string; body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoPullsNumber
  ## Update a pull request.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   number: int (required)
  ##         : Id of pull.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755758 = newJObject()
  var header_755759 = newJObject()
  var body_755760 = newJObject()
  add(header_755759, "Accept", newJString(Accept))
  add(path_755758, "number", newJInt(number))
  add(path_755758, "repo", newJString(repo))
  if body != nil:
    body_755760 = body
  add(path_755758, "owner", newJString(owner))
  result = call_755757.call(path_755758, nil, header_755759, nil, body_755760)

var patchReposOwnerRepoPullsNumber* = Call_PatchReposOwnerRepoPullsNumber_755748(
    name: "patchReposOwnerRepoPullsNumber", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}",
    validator: validate_PatchReposOwnerRepoPullsNumber_755749, base: "/",
    makeUrl: url_PatchReposOwnerRepoPullsNumber_755750, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoPullsNumberComments_755772 = ref object of OpenApiRestCall_753573
proc url_PostReposOwnerRepoPullsNumberComments_755774(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoPullsNumberComments_755773(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Create a comment.
  ##   #TODO Alternative input ( http://developer.github.com/v3/pulls/comments/ )
  ##   description: |
  ##     Alternative Input.
  ##     Instead of passing commit_id, path, and position you can reply to an
  ##     existing Pull Request Comment like this:
  ## 
  ##         body
  ##            Required string
  ##         in_reply_to
  ##            Required number - Comment id to reply to.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `number` field"
  var valid_755775 = path.getOrDefault("number")
  valid_755775 = validateParameter(valid_755775, JInt, required = true, default = nil)
  if valid_755775 != nil:
    section.add "number", valid_755775
  var valid_755776 = path.getOrDefault("repo")
  valid_755776 = validateParameter(valid_755776, JString, required = true,
                                 default = nil)
  if valid_755776 != nil:
    section.add "repo", valid_755776
  var valid_755777 = path.getOrDefault("owner")
  valid_755777 = validateParameter(valid_755777, JString, required = true,
                                 default = nil)
  if valid_755777 != nil:
    section.add "owner", valid_755777
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755778 = header.getOrDefault("Accept")
  valid_755778 = validateParameter(valid_755778, JString, required = false,
                                 default = nil)
  if valid_755778 != nil:
    section.add "Accept", valid_755778
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_755780: Call_PostReposOwnerRepoPullsNumberComments_755772;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a comment.
  ##   #TODO Alternative input ( http://developer.github.com/v3/pulls/comments/ )
  ##   description: |
  ##     Alternative Input.
  ##     Instead of passing commit_id, path, and position you can reply to an
  ##     existing Pull Request Comment like this:
  ## 
  ##         body
  ##            Required string
  ##         in_reply_to
  ##            Required number - Comment id to reply to.
  ## 
  ## 
  let valid = call_755780.validator(path, query, header, formData, body, _)
  let scheme = call_755780.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755780.makeUrl(scheme.get, call_755780.host, call_755780.base,
                             call_755780.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755780, uri, valid, _)

proc call*(call_755781: Call_PostReposOwnerRepoPullsNumberComments_755772;
          number: int; repo: string; body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoPullsNumberComments
  ## Create a comment.
  ##   #TODO Alternative input ( http://developer.github.com/v3/pulls/comments/ )
  ##   description: |
  ##     Alternative Input.
  ##     Instead of passing commit_id, path, and position you can reply to an
  ##     existing Pull Request Comment like this:
  ## 
  ##         body
  ##            Required string
  ##         in_reply_to
  ##            Required number - Comment id to reply to.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   number: int (required)
  ##         : Id of pull.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755782 = newJObject()
  var header_755783 = newJObject()
  var body_755784 = newJObject()
  add(header_755783, "Accept", newJString(Accept))
  add(path_755782, "number", newJInt(number))
  add(path_755782, "repo", newJString(repo))
  if body != nil:
    body_755784 = body
  add(path_755782, "owner", newJString(owner))
  result = call_755781.call(path_755782, nil, header_755783, nil, body_755784)

var postReposOwnerRepoPullsNumberComments* = Call_PostReposOwnerRepoPullsNumberComments_755772(
    name: "postReposOwnerRepoPullsNumberComments", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/{number}/comments",
    validator: validate_PostReposOwnerRepoPullsNumberComments_755773, base: "/",
    makeUrl: url_PostReposOwnerRepoPullsNumberComments_755774,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberComments_755761 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoPullsNumberComments_755763(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberComments_755762(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## List comments on a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `number` field"
  var valid_755764 = path.getOrDefault("number")
  valid_755764 = validateParameter(valid_755764, JInt, required = true, default = nil)
  if valid_755764 != nil:
    section.add "number", valid_755764
  var valid_755765 = path.getOrDefault("repo")
  valid_755765 = validateParameter(valid_755765, JString, required = true,
                                 default = nil)
  if valid_755765 != nil:
    section.add "repo", valid_755765
  var valid_755766 = path.getOrDefault("owner")
  valid_755766 = validateParameter(valid_755766, JString, required = true,
                                 default = nil)
  if valid_755766 != nil:
    section.add "owner", valid_755766
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755767 = header.getOrDefault("Accept")
  valid_755767 = validateParameter(valid_755767, JString, required = false,
                                 default = nil)
  if valid_755767 != nil:
    section.add "Accept", valid_755767
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755768: Call_GetReposOwnerRepoPullsNumberComments_755761;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List comments on a pull request.
  ## 
  let valid = call_755768.validator(path, query, header, formData, body, _)
  let scheme = call_755768.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755768.makeUrl(scheme.get, call_755768.host, call_755768.base,
                             call_755768.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755768, uri, valid, _)

proc call*(call_755769: Call_GetReposOwnerRepoPullsNumberComments_755761;
          number: int; repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberComments
  ## List comments on a pull request.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   number: int (required)
  ##         : Id of pull.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755770 = newJObject()
  var header_755771 = newJObject()
  add(header_755771, "Accept", newJString(Accept))
  add(path_755770, "number", newJInt(number))
  add(path_755770, "repo", newJString(repo))
  add(path_755770, "owner", newJString(owner))
  result = call_755769.call(path_755770, nil, header_755771, nil, nil)

var getReposOwnerRepoPullsNumberComments* = Call_GetReposOwnerRepoPullsNumberComments_755761(
    name: "getReposOwnerRepoPullsNumberComments", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/{number}/comments",
    validator: validate_GetReposOwnerRepoPullsNumberComments_755762, base: "/",
    makeUrl: url_GetReposOwnerRepoPullsNumberComments_755763,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberCommits_755785 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoPullsNumberCommits_755787(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/commits")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberCommits_755786(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## List commits on a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `number` field"
  var valid_755788 = path.getOrDefault("number")
  valid_755788 = validateParameter(valid_755788, JInt, required = true, default = nil)
  if valid_755788 != nil:
    section.add "number", valid_755788
  var valid_755789 = path.getOrDefault("repo")
  valid_755789 = validateParameter(valid_755789, JString, required = true,
                                 default = nil)
  if valid_755789 != nil:
    section.add "repo", valid_755789
  var valid_755790 = path.getOrDefault("owner")
  valid_755790 = validateParameter(valid_755790, JString, required = true,
                                 default = nil)
  if valid_755790 != nil:
    section.add "owner", valid_755790
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755791 = header.getOrDefault("Accept")
  valid_755791 = validateParameter(valid_755791, JString, required = false,
                                 default = nil)
  if valid_755791 != nil:
    section.add "Accept", valid_755791
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755792: Call_GetReposOwnerRepoPullsNumberCommits_755785;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List commits on a pull request.
  ## 
  let valid = call_755792.validator(path, query, header, formData, body, _)
  let scheme = call_755792.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755792.makeUrl(scheme.get, call_755792.host, call_755792.base,
                             call_755792.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755792, uri, valid, _)

proc call*(call_755793: Call_GetReposOwnerRepoPullsNumberCommits_755785;
          number: int; repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberCommits
  ## List commits on a pull request.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   number: int (required)
  ##         : Id of pull.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755794 = newJObject()
  var header_755795 = newJObject()
  add(header_755795, "Accept", newJString(Accept))
  add(path_755794, "number", newJInt(number))
  add(path_755794, "repo", newJString(repo))
  add(path_755794, "owner", newJString(owner))
  result = call_755793.call(path_755794, nil, header_755795, nil, nil)

var getReposOwnerRepoPullsNumberCommits* = Call_GetReposOwnerRepoPullsNumberCommits_755785(
    name: "getReposOwnerRepoPullsNumberCommits", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/commits",
    validator: validate_GetReposOwnerRepoPullsNumberCommits_755786, base: "/",
    makeUrl: url_GetReposOwnerRepoPullsNumberCommits_755787,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberFiles_755796 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoPullsNumberFiles_755798(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/files")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberFiles_755797(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## List pull requests files.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `number` field"
  var valid_755799 = path.getOrDefault("number")
  valid_755799 = validateParameter(valid_755799, JInt, required = true, default = nil)
  if valid_755799 != nil:
    section.add "number", valid_755799
  var valid_755800 = path.getOrDefault("repo")
  valid_755800 = validateParameter(valid_755800, JString, required = true,
                                 default = nil)
  if valid_755800 != nil:
    section.add "repo", valid_755800
  var valid_755801 = path.getOrDefault("owner")
  valid_755801 = validateParameter(valid_755801, JString, required = true,
                                 default = nil)
  if valid_755801 != nil:
    section.add "owner", valid_755801
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755802 = header.getOrDefault("Accept")
  valid_755802 = validateParameter(valid_755802, JString, required = false,
                                 default = nil)
  if valid_755802 != nil:
    section.add "Accept", valid_755802
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755803: Call_GetReposOwnerRepoPullsNumberFiles_755796;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List pull requests files.
  ## 
  let valid = call_755803.validator(path, query, header, formData, body, _)
  let scheme = call_755803.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755803.makeUrl(scheme.get, call_755803.host, call_755803.base,
                             call_755803.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755803, uri, valid, _)

proc call*(call_755804: Call_GetReposOwnerRepoPullsNumberFiles_755796; number: int;
          repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberFiles
  ## List pull requests files.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   number: int (required)
  ##         : Id of pull.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755805 = newJObject()
  var header_755806 = newJObject()
  add(header_755806, "Accept", newJString(Accept))
  add(path_755805, "number", newJInt(number))
  add(path_755805, "repo", newJString(repo))
  add(path_755805, "owner", newJString(owner))
  result = call_755804.call(path_755805, nil, header_755806, nil, nil)

var getReposOwnerRepoPullsNumberFiles* = Call_GetReposOwnerRepoPullsNumberFiles_755796(
    name: "getReposOwnerRepoPullsNumberFiles", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/files",
    validator: validate_GetReposOwnerRepoPullsNumberFiles_755797, base: "/",
    makeUrl: url_GetReposOwnerRepoPullsNumberFiles_755798, schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoPullsNumberMerge_755818 = ref object of OpenApiRestCall_753573
proc url_PutReposOwnerRepoPullsNumberMerge_755820(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/merge")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoPullsNumberMerge_755819(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Merge a pull request (Merge Button's)
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `number` field"
  var valid_755821 = path.getOrDefault("number")
  valid_755821 = validateParameter(valid_755821, JInt, required = true, default = nil)
  if valid_755821 != nil:
    section.add "number", valid_755821
  var valid_755822 = path.getOrDefault("repo")
  valid_755822 = validateParameter(valid_755822, JString, required = true,
                                 default = nil)
  if valid_755822 != nil:
    section.add "repo", valid_755822
  var valid_755823 = path.getOrDefault("owner")
  valid_755823 = validateParameter(valid_755823, JString, required = true,
                                 default = nil)
  if valid_755823 != nil:
    section.add "owner", valid_755823
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755824 = header.getOrDefault("Accept")
  valid_755824 = validateParameter(valid_755824, JString, required = false,
                                 default = nil)
  if valid_755824 != nil:
    section.add "Accept", valid_755824
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_755826: Call_PutReposOwnerRepoPullsNumberMerge_755818;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Merge a pull request (Merge Button's)
  ## 
  let valid = call_755826.validator(path, query, header, formData, body, _)
  let scheme = call_755826.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755826.makeUrl(scheme.get, call_755826.host, call_755826.base,
                             call_755826.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755826, uri, valid, _)

proc call*(call_755827: Call_PutReposOwnerRepoPullsNumberMerge_755818; number: int;
          repo: string; body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoPullsNumberMerge
  ## Merge a pull request (Merge Button's)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   number: int (required)
  ##         : Id of pull.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755828 = newJObject()
  var header_755829 = newJObject()
  var body_755830 = newJObject()
  add(header_755829, "Accept", newJString(Accept))
  add(path_755828, "number", newJInt(number))
  add(path_755828, "repo", newJString(repo))
  if body != nil:
    body_755830 = body
  add(path_755828, "owner", newJString(owner))
  result = call_755827.call(path_755828, nil, header_755829, nil, body_755830)

var putReposOwnerRepoPullsNumberMerge* = Call_PutReposOwnerRepoPullsNumberMerge_755818(
    name: "putReposOwnerRepoPullsNumberMerge", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/merge",
    validator: validate_PutReposOwnerRepoPullsNumberMerge_755819, base: "/",
    makeUrl: url_PutReposOwnerRepoPullsNumberMerge_755820, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberMerge_755807 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoPullsNumberMerge_755809(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/merge")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberMerge_755808(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Get if a pull request has been merged.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `number` field"
  var valid_755810 = path.getOrDefault("number")
  valid_755810 = validateParameter(valid_755810, JInt, required = true, default = nil)
  if valid_755810 != nil:
    section.add "number", valid_755810
  var valid_755811 = path.getOrDefault("repo")
  valid_755811 = validateParameter(valid_755811, JString, required = true,
                                 default = nil)
  if valid_755811 != nil:
    section.add "repo", valid_755811
  var valid_755812 = path.getOrDefault("owner")
  valid_755812 = validateParameter(valid_755812, JString, required = true,
                                 default = nil)
  if valid_755812 != nil:
    section.add "owner", valid_755812
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755813 = header.getOrDefault("Accept")
  valid_755813 = validateParameter(valid_755813, JString, required = false,
                                 default = nil)
  if valid_755813 != nil:
    section.add "Accept", valid_755813
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755814: Call_GetReposOwnerRepoPullsNumberMerge_755807;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get if a pull request has been merged.
  ## 
  let valid = call_755814.validator(path, query, header, formData, body, _)
  let scheme = call_755814.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755814.makeUrl(scheme.get, call_755814.host, call_755814.base,
                             call_755814.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755814, uri, valid, _)

proc call*(call_755815: Call_GetReposOwnerRepoPullsNumberMerge_755807; number: int;
          repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberMerge
  ## Get if a pull request has been merged.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   number: int (required)
  ##         : Id of pull.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755816 = newJObject()
  var header_755817 = newJObject()
  add(header_755817, "Accept", newJString(Accept))
  add(path_755816, "number", newJInt(number))
  add(path_755816, "repo", newJString(repo))
  add(path_755816, "owner", newJString(owner))
  result = call_755815.call(path_755816, nil, header_755817, nil, nil)

var getReposOwnerRepoPullsNumberMerge* = Call_GetReposOwnerRepoPullsNumberMerge_755807(
    name: "getReposOwnerRepoPullsNumberMerge", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/merge",
    validator: validate_GetReposOwnerRepoPullsNumberMerge_755808, base: "/",
    makeUrl: url_GetReposOwnerRepoPullsNumberMerge_755809, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReadme_755831 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoReadme_755833(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/readme")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReadme_755832(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Get the README.
  ## This method returns the preferred README for a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755834 = path.getOrDefault("repo")
  valid_755834 = validateParameter(valid_755834, JString, required = true,
                                 default = nil)
  if valid_755834 != nil:
    section.add "repo", valid_755834
  var valid_755835 = path.getOrDefault("owner")
  valid_755835 = validateParameter(valid_755835, JString, required = true,
                                 default = nil)
  if valid_755835 != nil:
    section.add "owner", valid_755835
  result.add "path", section
  ## parameters in `query` object:
  ##   ref: JString
  ##      : The String name of the Commit/Branch/Tag. Defaults to master.
  section = newJObject()
  var valid_755836 = query.getOrDefault("ref")
  valid_755836 = validateParameter(valid_755836, JString, required = false,
                                 default = nil)
  if valid_755836 != nil:
    section.add "ref", valid_755836
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755837 = header.getOrDefault("Accept")
  valid_755837 = validateParameter(valid_755837, JString, required = false,
                                 default = nil)
  if valid_755837 != nil:
    section.add "Accept", valid_755837
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755838: Call_GetReposOwnerRepoReadme_755831; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get the README.
  ## This method returns the preferred README for a repository.
  ## 
  ## 
  let valid = call_755838.validator(path, query, header, formData, body, _)
  let scheme = call_755838.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755838.makeUrl(scheme.get, call_755838.host, call_755838.base,
                             call_755838.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755838, uri, valid, _)

proc call*(call_755839: Call_GetReposOwnerRepoReadme_755831; repo: string;
          owner: string; Accept: string = ""; `ref`: string = ""): Recallable =
  ## getReposOwnerRepoReadme
  ## Get the README.
  ## This method returns the preferred README for a repository.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   ref: string
  ##      : The String name of the Commit/Branch/Tag. Defaults to master.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755840 = newJObject()
  var query_755841 = newJObject()
  var header_755842 = newJObject()
  add(header_755842, "Accept", newJString(Accept))
  add(path_755840, "repo", newJString(repo))
  add(query_755841, "ref", newJString(`ref`))
  add(path_755840, "owner", newJString(owner))
  result = call_755839.call(path_755840, query_755841, header_755842, nil, nil)

var getReposOwnerRepoReadme* = Call_GetReposOwnerRepoReadme_755831(
    name: "getReposOwnerRepoReadme", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/readme",
    validator: validate_GetReposOwnerRepoReadme_755832, base: "/",
    makeUrl: url_GetReposOwnerRepoReadme_755833, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoReleases_755853 = ref object of OpenApiRestCall_753573
proc url_PostReposOwnerRepoReleases_755855(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoReleases_755854(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Create a release
  ## Users with push access to the repository can create a release.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755856 = path.getOrDefault("repo")
  valid_755856 = validateParameter(valid_755856, JString, required = true,
                                 default = nil)
  if valid_755856 != nil:
    section.add "repo", valid_755856
  var valid_755857 = path.getOrDefault("owner")
  valid_755857 = validateParameter(valid_755857, JString, required = true,
                                 default = nil)
  if valid_755857 != nil:
    section.add "owner", valid_755857
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755858 = header.getOrDefault("Accept")
  valid_755858 = validateParameter(valid_755858, JString, required = false,
                                 default = nil)
  if valid_755858 != nil:
    section.add "Accept", valid_755858
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_755860: Call_PostReposOwnerRepoReleases_755853;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a release
  ## Users with push access to the repository can create a release.
  ## 
  ## 
  let valid = call_755860.validator(path, query, header, formData, body, _)
  let scheme = call_755860.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755860.makeUrl(scheme.get, call_755860.host, call_755860.base,
                             call_755860.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755860, uri, valid, _)

proc call*(call_755861: Call_PostReposOwnerRepoReleases_755853; repo: string;
          body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoReleases
  ## Create a release
  ## Users with push access to the repository can create a release.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755862 = newJObject()
  var header_755863 = newJObject()
  var body_755864 = newJObject()
  add(header_755863, "Accept", newJString(Accept))
  add(path_755862, "repo", newJString(repo))
  if body != nil:
    body_755864 = body
  add(path_755862, "owner", newJString(owner))
  result = call_755861.call(path_755862, nil, header_755863, nil, body_755864)

var postReposOwnerRepoReleases* = Call_PostReposOwnerRepoReleases_755853(
    name: "postReposOwnerRepoReleases", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases",
    validator: validate_PostReposOwnerRepoReleases_755854, base: "/",
    makeUrl: url_PostReposOwnerRepoReleases_755855, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleases_755843 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoReleases_755845(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleases_755844(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Users with push access to the repository will receive all releases (i.e., published releases and draft releases). Users with pull access will receive published releases only
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755846 = path.getOrDefault("repo")
  valid_755846 = validateParameter(valid_755846, JString, required = true,
                                 default = nil)
  if valid_755846 != nil:
    section.add "repo", valid_755846
  var valid_755847 = path.getOrDefault("owner")
  valid_755847 = validateParameter(valid_755847, JString, required = true,
                                 default = nil)
  if valid_755847 != nil:
    section.add "owner", valid_755847
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755848 = header.getOrDefault("Accept")
  valid_755848 = validateParameter(valid_755848, JString, required = false,
                                 default = nil)
  if valid_755848 != nil:
    section.add "Accept", valid_755848
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755849: Call_GetReposOwnerRepoReleases_755843;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Users with push access to the repository will receive all releases (i.e., published releases and draft releases). Users with pull access will receive published releases only
  ## 
  let valid = call_755849.validator(path, query, header, formData, body, _)
  let scheme = call_755849.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755849.makeUrl(scheme.get, call_755849.host, call_755849.base,
                             call_755849.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755849, uri, valid, _)

proc call*(call_755850: Call_GetReposOwnerRepoReleases_755843; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleases
  ## Users with push access to the repository will receive all releases (i.e., published releases and draft releases). Users with pull access will receive published releases only
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755851 = newJObject()
  var header_755852 = newJObject()
  add(header_755852, "Accept", newJString(Accept))
  add(path_755851, "repo", newJString(repo))
  add(path_755851, "owner", newJString(owner))
  result = call_755850.call(path_755851, nil, header_755852, nil, nil)

var getReposOwnerRepoReleases* = Call_GetReposOwnerRepoReleases_755843(
    name: "getReposOwnerRepoReleases", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases",
    validator: validate_GetReposOwnerRepoReleases_755844, base: "/",
    makeUrl: url_GetReposOwnerRepoReleases_755845, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleasesAssetsId_755865 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoReleasesAssetsId_755867(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/assets/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleasesAssetsId_755866(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Get a single release asset
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_755868 = path.getOrDefault("id")
  valid_755868 = validateParameter(valid_755868, JString, required = true,
                                 default = nil)
  if valid_755868 != nil:
    section.add "id", valid_755868
  var valid_755869 = path.getOrDefault("repo")
  valid_755869 = validateParameter(valid_755869, JString, required = true,
                                 default = nil)
  if valid_755869 != nil:
    section.add "repo", valid_755869
  var valid_755870 = path.getOrDefault("owner")
  valid_755870 = validateParameter(valid_755870, JString, required = true,
                                 default = nil)
  if valid_755870 != nil:
    section.add "owner", valid_755870
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755871 = header.getOrDefault("Accept")
  valid_755871 = validateParameter(valid_755871, JString, required = false,
                                 default = nil)
  if valid_755871 != nil:
    section.add "Accept", valid_755871
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755872: Call_GetReposOwnerRepoReleasesAssetsId_755865;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single release asset
  ## 
  let valid = call_755872.validator(path, query, header, formData, body, _)
  let scheme = call_755872.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755872.makeUrl(scheme.get, call_755872.host, call_755872.base,
                             call_755872.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755872, uri, valid, _)

proc call*(call_755873: Call_GetReposOwnerRepoReleasesAssetsId_755865; id: string;
          repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleasesAssetsId
  ## Get a single release asset
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755874 = newJObject()
  var header_755875 = newJObject()
  add(path_755874, "id", newJString(id))
  add(header_755875, "Accept", newJString(Accept))
  add(path_755874, "repo", newJString(repo))
  add(path_755874, "owner", newJString(owner))
  result = call_755873.call(path_755874, nil, header_755875, nil, nil)

var getReposOwnerRepoReleasesAssetsId* = Call_GetReposOwnerRepoReleasesAssetsId_755865(
    name: "getReposOwnerRepoReleasesAssetsId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/assets/{id}",
    validator: validate_GetReposOwnerRepoReleasesAssetsId_755866, base: "/",
    makeUrl: url_GetReposOwnerRepoReleasesAssetsId_755867, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoReleasesAssetsId_755887 = ref object of OpenApiRestCall_753573
proc url_PatchReposOwnerRepoReleasesAssetsId_755889(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/assets/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoReleasesAssetsId_755888(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Edit a release asset
  ## Users with push access to the repository can edit a release asset.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_755890 = path.getOrDefault("id")
  valid_755890 = validateParameter(valid_755890, JString, required = true,
                                 default = nil)
  if valid_755890 != nil:
    section.add "id", valid_755890
  var valid_755891 = path.getOrDefault("repo")
  valid_755891 = validateParameter(valid_755891, JString, required = true,
                                 default = nil)
  if valid_755891 != nil:
    section.add "repo", valid_755891
  var valid_755892 = path.getOrDefault("owner")
  valid_755892 = validateParameter(valid_755892, JString, required = true,
                                 default = nil)
  if valid_755892 != nil:
    section.add "owner", valid_755892
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755893 = header.getOrDefault("Accept")
  valid_755893 = validateParameter(valid_755893, JString, required = false,
                                 default = nil)
  if valid_755893 != nil:
    section.add "Accept", valid_755893
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_755895: Call_PatchReposOwnerRepoReleasesAssetsId_755887;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit a release asset
  ## Users with push access to the repository can edit a release asset.
  ## 
  ## 
  let valid = call_755895.validator(path, query, header, formData, body, _)
  let scheme = call_755895.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755895.makeUrl(scheme.get, call_755895.host, call_755895.base,
                             call_755895.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755895, uri, valid, _)

proc call*(call_755896: Call_PatchReposOwnerRepoReleasesAssetsId_755887;
          id: string; repo: string; body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoReleasesAssetsId
  ## Edit a release asset
  ## Users with push access to the repository can edit a release asset.
  ## 
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755897 = newJObject()
  var header_755898 = newJObject()
  var body_755899 = newJObject()
  add(path_755897, "id", newJString(id))
  add(header_755898, "Accept", newJString(Accept))
  add(path_755897, "repo", newJString(repo))
  if body != nil:
    body_755899 = body
  add(path_755897, "owner", newJString(owner))
  result = call_755896.call(path_755897, nil, header_755898, nil, body_755899)

var patchReposOwnerRepoReleasesAssetsId* = Call_PatchReposOwnerRepoReleasesAssetsId_755887(
    name: "patchReposOwnerRepoReleasesAssetsId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/assets/{id}",
    validator: validate_PatchReposOwnerRepoReleasesAssetsId_755888, base: "/",
    makeUrl: url_PatchReposOwnerRepoReleasesAssetsId_755889,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoReleasesAssetsId_755876 = ref object of OpenApiRestCall_753573
proc url_DeleteReposOwnerRepoReleasesAssetsId_755878(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/assets/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoReleasesAssetsId_755877(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Delete a release asset
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_755879 = path.getOrDefault("id")
  valid_755879 = validateParameter(valid_755879, JString, required = true,
                                 default = nil)
  if valid_755879 != nil:
    section.add "id", valid_755879
  var valid_755880 = path.getOrDefault("repo")
  valid_755880 = validateParameter(valid_755880, JString, required = true,
                                 default = nil)
  if valid_755880 != nil:
    section.add "repo", valid_755880
  var valid_755881 = path.getOrDefault("owner")
  valid_755881 = validateParameter(valid_755881, JString, required = true,
                                 default = nil)
  if valid_755881 != nil:
    section.add "owner", valid_755881
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755882 = header.getOrDefault("Accept")
  valid_755882 = validateParameter(valid_755882, JString, required = false,
                                 default = nil)
  if valid_755882 != nil:
    section.add "Accept", valid_755882
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755883: Call_DeleteReposOwnerRepoReleasesAssetsId_755876;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a release asset
  ## 
  let valid = call_755883.validator(path, query, header, formData, body, _)
  let scheme = call_755883.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755883.makeUrl(scheme.get, call_755883.host, call_755883.base,
                             call_755883.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755883, uri, valid, _)

proc call*(call_755884: Call_DeleteReposOwnerRepoReleasesAssetsId_755876;
          id: string; repo: string; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoReleasesAssetsId
  ## Delete a release asset
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755885 = newJObject()
  var header_755886 = newJObject()
  add(path_755885, "id", newJString(id))
  add(header_755886, "Accept", newJString(Accept))
  add(path_755885, "repo", newJString(repo))
  add(path_755885, "owner", newJString(owner))
  result = call_755884.call(path_755885, nil, header_755886, nil, nil)

var deleteReposOwnerRepoReleasesAssetsId* = Call_DeleteReposOwnerRepoReleasesAssetsId_755876(
    name: "deleteReposOwnerRepoReleasesAssetsId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/assets/{id}",
    validator: validate_DeleteReposOwnerRepoReleasesAssetsId_755877, base: "/",
    makeUrl: url_DeleteReposOwnerRepoReleasesAssetsId_755878,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleasesId_755900 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoReleasesId_755902(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleasesId_755901(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Get a single release
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_755903 = path.getOrDefault("id")
  valid_755903 = validateParameter(valid_755903, JString, required = true,
                                 default = nil)
  if valid_755903 != nil:
    section.add "id", valid_755903
  var valid_755904 = path.getOrDefault("repo")
  valid_755904 = validateParameter(valid_755904, JString, required = true,
                                 default = nil)
  if valid_755904 != nil:
    section.add "repo", valid_755904
  var valid_755905 = path.getOrDefault("owner")
  valid_755905 = validateParameter(valid_755905, JString, required = true,
                                 default = nil)
  if valid_755905 != nil:
    section.add "owner", valid_755905
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755906 = header.getOrDefault("Accept")
  valid_755906 = validateParameter(valid_755906, JString, required = false,
                                 default = nil)
  if valid_755906 != nil:
    section.add "Accept", valid_755906
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755907: Call_GetReposOwnerRepoReleasesId_755900;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single release
  ## 
  let valid = call_755907.validator(path, query, header, formData, body, _)
  let scheme = call_755907.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755907.makeUrl(scheme.get, call_755907.host, call_755907.base,
                             call_755907.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755907, uri, valid, _)

proc call*(call_755908: Call_GetReposOwnerRepoReleasesId_755900; id: string;
          repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleasesId
  ## Get a single release
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755909 = newJObject()
  var header_755910 = newJObject()
  add(path_755909, "id", newJString(id))
  add(header_755910, "Accept", newJString(Accept))
  add(path_755909, "repo", newJString(repo))
  add(path_755909, "owner", newJString(owner))
  result = call_755908.call(path_755909, nil, header_755910, nil, nil)

var getReposOwnerRepoReleasesId* = Call_GetReposOwnerRepoReleasesId_755900(
    name: "getReposOwnerRepoReleasesId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}",
    validator: validate_GetReposOwnerRepoReleasesId_755901, base: "/",
    makeUrl: url_GetReposOwnerRepoReleasesId_755902, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoReleasesId_755922 = ref object of OpenApiRestCall_753573
proc url_PatchReposOwnerRepoReleasesId_755924(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoReleasesId_755923(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Users with push access to the repository can edit a release
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_755925 = path.getOrDefault("id")
  valid_755925 = validateParameter(valid_755925, JString, required = true,
                                 default = nil)
  if valid_755925 != nil:
    section.add "id", valid_755925
  var valid_755926 = path.getOrDefault("repo")
  valid_755926 = validateParameter(valid_755926, JString, required = true,
                                 default = nil)
  if valid_755926 != nil:
    section.add "repo", valid_755926
  var valid_755927 = path.getOrDefault("owner")
  valid_755927 = validateParameter(valid_755927, JString, required = true,
                                 default = nil)
  if valid_755927 != nil:
    section.add "owner", valid_755927
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755928 = header.getOrDefault("Accept")
  valid_755928 = validateParameter(valid_755928, JString, required = false,
                                 default = nil)
  if valid_755928 != nil:
    section.add "Accept", valid_755928
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_755930: Call_PatchReposOwnerRepoReleasesId_755922;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Users with push access to the repository can edit a release
  ## 
  let valid = call_755930.validator(path, query, header, formData, body, _)
  let scheme = call_755930.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755930.makeUrl(scheme.get, call_755930.host, call_755930.base,
                             call_755930.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755930, uri, valid, _)

proc call*(call_755931: Call_PatchReposOwnerRepoReleasesId_755922; id: string;
          repo: string; body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoReleasesId
  ## Users with push access to the repository can edit a release
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755932 = newJObject()
  var header_755933 = newJObject()
  var body_755934 = newJObject()
  add(path_755932, "id", newJString(id))
  add(header_755933, "Accept", newJString(Accept))
  add(path_755932, "repo", newJString(repo))
  if body != nil:
    body_755934 = body
  add(path_755932, "owner", newJString(owner))
  result = call_755931.call(path_755932, nil, header_755933, nil, body_755934)

var patchReposOwnerRepoReleasesId* = Call_PatchReposOwnerRepoReleasesId_755922(
    name: "patchReposOwnerRepoReleasesId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}",
    validator: validate_PatchReposOwnerRepoReleasesId_755923, base: "/",
    makeUrl: url_PatchReposOwnerRepoReleasesId_755924, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoReleasesId_755911 = ref object of OpenApiRestCall_753573
proc url_DeleteReposOwnerRepoReleasesId_755913(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoReleasesId_755912(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Users with push access to the repository can delete a release.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_755914 = path.getOrDefault("id")
  valid_755914 = validateParameter(valid_755914, JString, required = true,
                                 default = nil)
  if valid_755914 != nil:
    section.add "id", valid_755914
  var valid_755915 = path.getOrDefault("repo")
  valid_755915 = validateParameter(valid_755915, JString, required = true,
                                 default = nil)
  if valid_755915 != nil:
    section.add "repo", valid_755915
  var valid_755916 = path.getOrDefault("owner")
  valid_755916 = validateParameter(valid_755916, JString, required = true,
                                 default = nil)
  if valid_755916 != nil:
    section.add "owner", valid_755916
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755917 = header.getOrDefault("Accept")
  valid_755917 = validateParameter(valid_755917, JString, required = false,
                                 default = nil)
  if valid_755917 != nil:
    section.add "Accept", valid_755917
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755918: Call_DeleteReposOwnerRepoReleasesId_755911;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Users with push access to the repository can delete a release.
  ## 
  let valid = call_755918.validator(path, query, header, formData, body, _)
  let scheme = call_755918.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755918.makeUrl(scheme.get, call_755918.host, call_755918.base,
                             call_755918.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755918, uri, valid, _)

proc call*(call_755919: Call_DeleteReposOwnerRepoReleasesId_755911; id: string;
          repo: string; owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoReleasesId
  ## Users with push access to the repository can delete a release.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755920 = newJObject()
  var header_755921 = newJObject()
  add(path_755920, "id", newJString(id))
  add(header_755921, "Accept", newJString(Accept))
  add(path_755920, "repo", newJString(repo))
  add(path_755920, "owner", newJString(owner))
  result = call_755919.call(path_755920, nil, header_755921, nil, nil)

var deleteReposOwnerRepoReleasesId* = Call_DeleteReposOwnerRepoReleasesId_755911(
    name: "deleteReposOwnerRepoReleasesId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}",
    validator: validate_DeleteReposOwnerRepoReleasesId_755912, base: "/",
    makeUrl: url_DeleteReposOwnerRepoReleasesId_755913, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleasesIdAssets_755935 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoReleasesIdAssets_755937(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/assets")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleasesIdAssets_755936(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## List assets for a release
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_755938 = path.getOrDefault("id")
  valid_755938 = validateParameter(valid_755938, JString, required = true,
                                 default = nil)
  if valid_755938 != nil:
    section.add "id", valid_755938
  var valid_755939 = path.getOrDefault("repo")
  valid_755939 = validateParameter(valid_755939, JString, required = true,
                                 default = nil)
  if valid_755939 != nil:
    section.add "repo", valid_755939
  var valid_755940 = path.getOrDefault("owner")
  valid_755940 = validateParameter(valid_755940, JString, required = true,
                                 default = nil)
  if valid_755940 != nil:
    section.add "owner", valid_755940
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755941 = header.getOrDefault("Accept")
  valid_755941 = validateParameter(valid_755941, JString, required = false,
                                 default = nil)
  if valid_755941 != nil:
    section.add "Accept", valid_755941
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755942: Call_GetReposOwnerRepoReleasesIdAssets_755935;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List assets for a release
  ## 
  let valid = call_755942.validator(path, query, header, formData, body, _)
  let scheme = call_755942.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755942.makeUrl(scheme.get, call_755942.host, call_755942.base,
                             call_755942.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755942, uri, valid, _)

proc call*(call_755943: Call_GetReposOwnerRepoReleasesIdAssets_755935; id: string;
          repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleasesIdAssets
  ## List assets for a release
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755944 = newJObject()
  var header_755945 = newJObject()
  add(path_755944, "id", newJString(id))
  add(header_755945, "Accept", newJString(Accept))
  add(path_755944, "repo", newJString(repo))
  add(path_755944, "owner", newJString(owner))
  result = call_755943.call(path_755944, nil, header_755945, nil, nil)

var getReposOwnerRepoReleasesIdAssets* = Call_GetReposOwnerRepoReleasesIdAssets_755935(
    name: "getReposOwnerRepoReleasesIdAssets", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}/assets",
    validator: validate_GetReposOwnerRepoReleasesIdAssets_755936, base: "/",
    makeUrl: url_GetReposOwnerRepoReleasesIdAssets_755937, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStargazers_755946 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoStargazers_755948(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stargazers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStargazers_755947(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List Stargazers.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755949 = path.getOrDefault("repo")
  valid_755949 = validateParameter(valid_755949, JString, required = true,
                                 default = nil)
  if valid_755949 != nil:
    section.add "repo", valid_755949
  var valid_755950 = path.getOrDefault("owner")
  valid_755950 = validateParameter(valid_755950, JString, required = true,
                                 default = nil)
  if valid_755950 != nil:
    section.add "owner", valid_755950
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755951 = header.getOrDefault("Accept")
  valid_755951 = validateParameter(valid_755951, JString, required = false,
                                 default = nil)
  if valid_755951 != nil:
    section.add "Accept", valid_755951
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755952: Call_GetReposOwnerRepoStargazers_755946;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List Stargazers.
  ## 
  let valid = call_755952.validator(path, query, header, formData, body, _)
  let scheme = call_755952.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755952.makeUrl(scheme.get, call_755952.host, call_755952.base,
                             call_755952.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755952, uri, valid, _)

proc call*(call_755953: Call_GetReposOwnerRepoStargazers_755946; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStargazers
  ## List Stargazers.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755954 = newJObject()
  var header_755955 = newJObject()
  add(header_755955, "Accept", newJString(Accept))
  add(path_755954, "repo", newJString(repo))
  add(path_755954, "owner", newJString(owner))
  result = call_755953.call(path_755954, nil, header_755955, nil, nil)

var getReposOwnerRepoStargazers* = Call_GetReposOwnerRepoStargazers_755946(
    name: "getReposOwnerRepoStargazers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stargazers",
    validator: validate_GetReposOwnerRepoStargazers_755947, base: "/",
    makeUrl: url_GetReposOwnerRepoStargazers_755948, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsCodeFrequency_755956 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoStatsCodeFrequency_755958(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/code_frequency")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsCodeFrequency_755957(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Get the number of additions and deletions per week.
  ## Returns a weekly aggregate of the number of additions and deletions pushed
  ## to a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755959 = path.getOrDefault("repo")
  valid_755959 = validateParameter(valid_755959, JString, required = true,
                                 default = nil)
  if valid_755959 != nil:
    section.add "repo", valid_755959
  var valid_755960 = path.getOrDefault("owner")
  valid_755960 = validateParameter(valid_755960, JString, required = true,
                                 default = nil)
  if valid_755960 != nil:
    section.add "owner", valid_755960
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755961 = header.getOrDefault("Accept")
  valid_755961 = validateParameter(valid_755961, JString, required = false,
                                 default = nil)
  if valid_755961 != nil:
    section.add "Accept", valid_755961
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755962: Call_GetReposOwnerRepoStatsCodeFrequency_755956;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get the number of additions and deletions per week.
  ## Returns a weekly aggregate of the number of additions and deletions pushed
  ## to a repository.
  ## 
  ## 
  let valid = call_755962.validator(path, query, header, formData, body, _)
  let scheme = call_755962.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755962.makeUrl(scheme.get, call_755962.host, call_755962.base,
                             call_755962.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755962, uri, valid, _)

proc call*(call_755963: Call_GetReposOwnerRepoStatsCodeFrequency_755956;
          repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsCodeFrequency
  ## Get the number of additions and deletions per week.
  ## Returns a weekly aggregate of the number of additions and deletions pushed
  ## to a repository.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755964 = newJObject()
  var header_755965 = newJObject()
  add(header_755965, "Accept", newJString(Accept))
  add(path_755964, "repo", newJString(repo))
  add(path_755964, "owner", newJString(owner))
  result = call_755963.call(path_755964, nil, header_755965, nil, nil)

var getReposOwnerRepoStatsCodeFrequency* = Call_GetReposOwnerRepoStatsCodeFrequency_755956(
    name: "getReposOwnerRepoStatsCodeFrequency", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/code_frequency",
    validator: validate_GetReposOwnerRepoStatsCodeFrequency_755957, base: "/",
    makeUrl: url_GetReposOwnerRepoStatsCodeFrequency_755958,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsCommitActivity_755966 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoStatsCommitActivity_755968(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/commit_activity")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsCommitActivity_755967(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Get the last year of commit activity data.
  ## Returns the last year of commit activity grouped by week. The days array
  ## is a group of commits per day, starting on Sunday.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755969 = path.getOrDefault("repo")
  valid_755969 = validateParameter(valid_755969, JString, required = true,
                                 default = nil)
  if valid_755969 != nil:
    section.add "repo", valid_755969
  var valid_755970 = path.getOrDefault("owner")
  valid_755970 = validateParameter(valid_755970, JString, required = true,
                                 default = nil)
  if valid_755970 != nil:
    section.add "owner", valid_755970
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755971 = header.getOrDefault("Accept")
  valid_755971 = validateParameter(valid_755971, JString, required = false,
                                 default = nil)
  if valid_755971 != nil:
    section.add "Accept", valid_755971
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755972: Call_GetReposOwnerRepoStatsCommitActivity_755966;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get the last year of commit activity data.
  ## Returns the last year of commit activity grouped by week. The days array
  ## is a group of commits per day, starting on Sunday.
  ## 
  ## 
  let valid = call_755972.validator(path, query, header, formData, body, _)
  let scheme = call_755972.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755972.makeUrl(scheme.get, call_755972.host, call_755972.base,
                             call_755972.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755972, uri, valid, _)

proc call*(call_755973: Call_GetReposOwnerRepoStatsCommitActivity_755966;
          repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsCommitActivity
  ## Get the last year of commit activity data.
  ## Returns the last year of commit activity grouped by week. The days array
  ## is a group of commits per day, starting on Sunday.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755974 = newJObject()
  var header_755975 = newJObject()
  add(header_755975, "Accept", newJString(Accept))
  add(path_755974, "repo", newJString(repo))
  add(path_755974, "owner", newJString(owner))
  result = call_755973.call(path_755974, nil, header_755975, nil, nil)

var getReposOwnerRepoStatsCommitActivity* = Call_GetReposOwnerRepoStatsCommitActivity_755966(
    name: "getReposOwnerRepoStatsCommitActivity", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/commit_activity",
    validator: validate_GetReposOwnerRepoStatsCommitActivity_755967, base: "/",
    makeUrl: url_GetReposOwnerRepoStatsCommitActivity_755968,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsContributors_755976 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoStatsContributors_755978(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/contributors")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsContributors_755977(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Get contributors list with additions, deletions, and commit counts.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755979 = path.getOrDefault("repo")
  valid_755979 = validateParameter(valid_755979, JString, required = true,
                                 default = nil)
  if valid_755979 != nil:
    section.add "repo", valid_755979
  var valid_755980 = path.getOrDefault("owner")
  valid_755980 = validateParameter(valid_755980, JString, required = true,
                                 default = nil)
  if valid_755980 != nil:
    section.add "owner", valid_755980
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755981 = header.getOrDefault("Accept")
  valid_755981 = validateParameter(valid_755981, JString, required = false,
                                 default = nil)
  if valid_755981 != nil:
    section.add "Accept", valid_755981
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755982: Call_GetReposOwnerRepoStatsContributors_755976;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get contributors list with additions, deletions, and commit counts.
  ## 
  let valid = call_755982.validator(path, query, header, formData, body, _)
  let scheme = call_755982.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755982.makeUrl(scheme.get, call_755982.host, call_755982.base,
                             call_755982.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755982, uri, valid, _)

proc call*(call_755983: Call_GetReposOwnerRepoStatsContributors_755976;
          repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsContributors
  ## Get contributors list with additions, deletions, and commit counts.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755984 = newJObject()
  var header_755985 = newJObject()
  add(header_755985, "Accept", newJString(Accept))
  add(path_755984, "repo", newJString(repo))
  add(path_755984, "owner", newJString(owner))
  result = call_755983.call(path_755984, nil, header_755985, nil, nil)

var getReposOwnerRepoStatsContributors* = Call_GetReposOwnerRepoStatsContributors_755976(
    name: "getReposOwnerRepoStatsContributors", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/contributors",
    validator: validate_GetReposOwnerRepoStatsContributors_755977, base: "/",
    makeUrl: url_GetReposOwnerRepoStatsContributors_755978,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsParticipation_755986 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoStatsParticipation_755988(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/participation")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsParticipation_755987(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Get the weekly commit count for the repo owner and everyone else.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755989 = path.getOrDefault("repo")
  valid_755989 = validateParameter(valid_755989, JString, required = true,
                                 default = nil)
  if valid_755989 != nil:
    section.add "repo", valid_755989
  var valid_755990 = path.getOrDefault("owner")
  valid_755990 = validateParameter(valid_755990, JString, required = true,
                                 default = nil)
  if valid_755990 != nil:
    section.add "owner", valid_755990
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_755991 = header.getOrDefault("Accept")
  valid_755991 = validateParameter(valid_755991, JString, required = false,
                                 default = nil)
  if valid_755991 != nil:
    section.add "Accept", valid_755991
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_755992: Call_GetReposOwnerRepoStatsParticipation_755986;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get the weekly commit count for the repo owner and everyone else.
  ## 
  let valid = call_755992.validator(path, query, header, formData, body, _)
  let scheme = call_755992.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_755992.makeUrl(scheme.get, call_755992.host, call_755992.base,
                             call_755992.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_755992, uri, valid, _)

proc call*(call_755993: Call_GetReposOwnerRepoStatsParticipation_755986;
          repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsParticipation
  ## Get the weekly commit count for the repo owner and everyone else.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_755994 = newJObject()
  var header_755995 = newJObject()
  add(header_755995, "Accept", newJString(Accept))
  add(path_755994, "repo", newJString(repo))
  add(path_755994, "owner", newJString(owner))
  result = call_755993.call(path_755994, nil, header_755995, nil, nil)

var getReposOwnerRepoStatsParticipation* = Call_GetReposOwnerRepoStatsParticipation_755986(
    name: "getReposOwnerRepoStatsParticipation", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/participation",
    validator: validate_GetReposOwnerRepoStatsParticipation_755987, base: "/",
    makeUrl: url_GetReposOwnerRepoStatsParticipation_755988,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsPunchCard_755996 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoStatsPunchCard_755998(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/punch_card")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsPunchCard_755997(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Get the number of commits per hour in each day.
  ## Each array contains the day number, hour number, and number of commits
  ## 0-6 Sunday - Saturday
  ## 0-23 Hour of day
  ## Number of commits
  ## 
  ## For example, [2, 14, 25] indicates that there were 25 total commits, during
  ## the 2.00pm hour on Tuesdays. All times are based on the time zone of
  ## individual commits.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_755999 = path.getOrDefault("repo")
  valid_755999 = validateParameter(valid_755999, JString, required = true,
                                 default = nil)
  if valid_755999 != nil:
    section.add "repo", valid_755999
  var valid_756000 = path.getOrDefault("owner")
  valid_756000 = validateParameter(valid_756000, JString, required = true,
                                 default = nil)
  if valid_756000 != nil:
    section.add "owner", valid_756000
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756001 = header.getOrDefault("Accept")
  valid_756001 = validateParameter(valid_756001, JString, required = false,
                                 default = nil)
  if valid_756001 != nil:
    section.add "Accept", valid_756001
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756002: Call_GetReposOwnerRepoStatsPunchCard_755996;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get the number of commits per hour in each day.
  ## Each array contains the day number, hour number, and number of commits
  ## 0-6 Sunday - Saturday
  ## 0-23 Hour of day
  ## Number of commits
  ## 
  ## For example, [2, 14, 25] indicates that there were 25 total commits, during
  ## the 2.00pm hour on Tuesdays. All times are based on the time zone of
  ## individual commits.
  ## 
  ## 
  let valid = call_756002.validator(path, query, header, formData, body, _)
  let scheme = call_756002.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756002.makeUrl(scheme.get, call_756002.host, call_756002.base,
                             call_756002.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756002, uri, valid, _)

proc call*(call_756003: Call_GetReposOwnerRepoStatsPunchCard_755996; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsPunchCard
  ## Get the number of commits per hour in each day.
  ## Each array contains the day number, hour number, and number of commits
  ## 0-6 Sunday - Saturday
  ## 0-23 Hour of day
  ## Number of commits
  ## 
  ## For example, [2, 14, 25] indicates that there were 25 total commits, during
  ## the 2.00pm hour on Tuesdays. All times are based on the time zone of
  ## individual commits.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_756004 = newJObject()
  var header_756005 = newJObject()
  add(header_756005, "Accept", newJString(Accept))
  add(path_756004, "repo", newJString(repo))
  add(path_756004, "owner", newJString(owner))
  result = call_756003.call(path_756004, nil, header_756005, nil, nil)

var getReposOwnerRepoStatsPunchCard* = Call_GetReposOwnerRepoStatsPunchCard_755996(
    name: "getReposOwnerRepoStatsPunchCard", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/punch_card",
    validator: validate_GetReposOwnerRepoStatsPunchCard_755997, base: "/",
    makeUrl: url_GetReposOwnerRepoStatsPunchCard_755998, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoStatusesRef_756017 = ref object of OpenApiRestCall_753573
proc url_PostReposOwnerRepoStatusesRef_756019(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/statuses/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoStatusesRef_756018(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Create a Status.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ref: JString (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ref` field"
  var valid_756020 = path.getOrDefault("ref")
  valid_756020 = validateParameter(valid_756020, JString, required = true,
                                 default = nil)
  if valid_756020 != nil:
    section.add "ref", valid_756020
  var valid_756021 = path.getOrDefault("repo")
  valid_756021 = validateParameter(valid_756021, JString, required = true,
                                 default = nil)
  if valid_756021 != nil:
    section.add "repo", valid_756021
  var valid_756022 = path.getOrDefault("owner")
  valid_756022 = validateParameter(valid_756022, JString, required = true,
                                 default = nil)
  if valid_756022 != nil:
    section.add "owner", valid_756022
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756023 = header.getOrDefault("Accept")
  valid_756023 = validateParameter(valid_756023, JString, required = false,
                                 default = nil)
  if valid_756023 != nil:
    section.add "Accept", valid_756023
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_756025: Call_PostReposOwnerRepoStatusesRef_756017;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a Status.
  ## 
  let valid = call_756025.validator(path, query, header, formData, body, _)
  let scheme = call_756025.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756025.makeUrl(scheme.get, call_756025.host, call_756025.base,
                             call_756025.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756025, uri, valid, _)

proc call*(call_756026: Call_PostReposOwnerRepoStatusesRef_756017; `ref`: string;
          repo: string; body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoStatusesRef
  ## Create a Status.
  ##   ref: string (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_756027 = newJObject()
  var header_756028 = newJObject()
  var body_756029 = newJObject()
  add(path_756027, "ref", newJString(`ref`))
  add(header_756028, "Accept", newJString(Accept))
  add(path_756027, "repo", newJString(repo))
  if body != nil:
    body_756029 = body
  add(path_756027, "owner", newJString(owner))
  result = call_756026.call(path_756027, nil, header_756028, nil, body_756029)

var postReposOwnerRepoStatusesRef* = Call_PostReposOwnerRepoStatusesRef_756017(
    name: "postReposOwnerRepoStatusesRef", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/statuses/{ref}",
    validator: validate_PostReposOwnerRepoStatusesRef_756018, base: "/",
    makeUrl: url_PostReposOwnerRepoStatusesRef_756019, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatusesRef_756006 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoStatusesRef_756008(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/statuses/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatusesRef_756007(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List Statuses for a specific Ref.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   ref: JString (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `ref` field"
  var valid_756009 = path.getOrDefault("ref")
  valid_756009 = validateParameter(valid_756009, JString, required = true,
                                 default = nil)
  if valid_756009 != nil:
    section.add "ref", valid_756009
  var valid_756010 = path.getOrDefault("repo")
  valid_756010 = validateParameter(valid_756010, JString, required = true,
                                 default = nil)
  if valid_756010 != nil:
    section.add "repo", valid_756010
  var valid_756011 = path.getOrDefault("owner")
  valid_756011 = validateParameter(valid_756011, JString, required = true,
                                 default = nil)
  if valid_756011 != nil:
    section.add "owner", valid_756011
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756012 = header.getOrDefault("Accept")
  valid_756012 = validateParameter(valid_756012, JString, required = false,
                                 default = nil)
  if valid_756012 != nil:
    section.add "Accept", valid_756012
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756013: Call_GetReposOwnerRepoStatusesRef_756006;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List Statuses for a specific Ref.
  ## 
  let valid = call_756013.validator(path, query, header, formData, body, _)
  let scheme = call_756013.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756013.makeUrl(scheme.get, call_756013.host, call_756013.base,
                             call_756013.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756013, uri, valid, _)

proc call*(call_756014: Call_GetReposOwnerRepoStatusesRef_756006; `ref`: string;
          repo: string; owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatusesRef
  ## List Statuses for a specific Ref.
  ##   ref: string (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_756015 = newJObject()
  var header_756016 = newJObject()
  add(path_756015, "ref", newJString(`ref`))
  add(header_756016, "Accept", newJString(Accept))
  add(path_756015, "repo", newJString(repo))
  add(path_756015, "owner", newJString(owner))
  result = call_756014.call(path_756015, nil, header_756016, nil, nil)

var getReposOwnerRepoStatusesRef* = Call_GetReposOwnerRepoStatusesRef_756006(
    name: "getReposOwnerRepoStatusesRef", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/statuses/{ref}",
    validator: validate_GetReposOwnerRepoStatusesRef_756007, base: "/",
    makeUrl: url_GetReposOwnerRepoStatusesRef_756008, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoSubscribers_756030 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoSubscribers_756032(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/subscribers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoSubscribers_756031(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List watchers.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_756033 = path.getOrDefault("repo")
  valid_756033 = validateParameter(valid_756033, JString, required = true,
                                 default = nil)
  if valid_756033 != nil:
    section.add "repo", valid_756033
  var valid_756034 = path.getOrDefault("owner")
  valid_756034 = validateParameter(valid_756034, JString, required = true,
                                 default = nil)
  if valid_756034 != nil:
    section.add "owner", valid_756034
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756035 = header.getOrDefault("Accept")
  valid_756035 = validateParameter(valid_756035, JString, required = false,
                                 default = nil)
  if valid_756035 != nil:
    section.add "Accept", valid_756035
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756036: Call_GetReposOwnerRepoSubscribers_756030;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List watchers.
  ## 
  let valid = call_756036.validator(path, query, header, formData, body, _)
  let scheme = call_756036.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756036.makeUrl(scheme.get, call_756036.host, call_756036.base,
                             call_756036.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756036, uri, valid, _)

proc call*(call_756037: Call_GetReposOwnerRepoSubscribers_756030; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoSubscribers
  ## List watchers.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_756038 = newJObject()
  var header_756039 = newJObject()
  add(header_756039, "Accept", newJString(Accept))
  add(path_756038, "repo", newJString(repo))
  add(path_756038, "owner", newJString(owner))
  result = call_756037.call(path_756038, nil, header_756039, nil, nil)

var getReposOwnerRepoSubscribers* = Call_GetReposOwnerRepoSubscribers_756030(
    name: "getReposOwnerRepoSubscribers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscribers",
    validator: validate_GetReposOwnerRepoSubscribers_756031, base: "/",
    makeUrl: url_GetReposOwnerRepoSubscribers_756032, schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoSubscription_756050 = ref object of OpenApiRestCall_753573
proc url_PutReposOwnerRepoSubscription_756052(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoSubscription_756051(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Set a Repository Subscription
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_756053 = path.getOrDefault("repo")
  valid_756053 = validateParameter(valid_756053, JString, required = true,
                                 default = nil)
  if valid_756053 != nil:
    section.add "repo", valid_756053
  var valid_756054 = path.getOrDefault("owner")
  valid_756054 = validateParameter(valid_756054, JString, required = true,
                                 default = nil)
  if valid_756054 != nil:
    section.add "owner", valid_756054
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756055 = header.getOrDefault("Accept")
  valid_756055 = validateParameter(valid_756055, JString, required = false,
                                 default = nil)
  if valid_756055 != nil:
    section.add "Accept", valid_756055
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_756057: Call_PutReposOwnerRepoSubscription_756050;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Set a Repository Subscription
  ## 
  let valid = call_756057.validator(path, query, header, formData, body, _)
  let scheme = call_756057.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756057.makeUrl(scheme.get, call_756057.host, call_756057.base,
                             call_756057.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756057, uri, valid, _)

proc call*(call_756058: Call_PutReposOwnerRepoSubscription_756050; repo: string;
          body: JsonNode; owner: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoSubscription
  ## Set a Repository Subscription
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   body: JObject (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_756059 = newJObject()
  var header_756060 = newJObject()
  var body_756061 = newJObject()
  add(header_756060, "Accept", newJString(Accept))
  add(path_756059, "repo", newJString(repo))
  if body != nil:
    body_756061 = body
  add(path_756059, "owner", newJString(owner))
  result = call_756058.call(path_756059, nil, header_756060, nil, body_756061)

var putReposOwnerRepoSubscription* = Call_PutReposOwnerRepoSubscription_756050(
    name: "putReposOwnerRepoSubscription", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscription",
    validator: validate_PutReposOwnerRepoSubscription_756051, base: "/",
    makeUrl: url_PutReposOwnerRepoSubscription_756052, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoSubscription_756040 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoSubscription_756042(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoSubscription_756041(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Get a Repository Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_756043 = path.getOrDefault("repo")
  valid_756043 = validateParameter(valid_756043, JString, required = true,
                                 default = nil)
  if valid_756043 != nil:
    section.add "repo", valid_756043
  var valid_756044 = path.getOrDefault("owner")
  valid_756044 = validateParameter(valid_756044, JString, required = true,
                                 default = nil)
  if valid_756044 != nil:
    section.add "owner", valid_756044
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756045 = header.getOrDefault("Accept")
  valid_756045 = validateParameter(valid_756045, JString, required = false,
                                 default = nil)
  if valid_756045 != nil:
    section.add "Accept", valid_756045
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756046: Call_GetReposOwnerRepoSubscription_756040;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a Repository Subscription.
  ## 
  let valid = call_756046.validator(path, query, header, formData, body, _)
  let scheme = call_756046.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756046.makeUrl(scheme.get, call_756046.host, call_756046.base,
                             call_756046.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756046, uri, valid, _)

proc call*(call_756047: Call_GetReposOwnerRepoSubscription_756040; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoSubscription
  ## Get a Repository Subscription.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_756048 = newJObject()
  var header_756049 = newJObject()
  add(header_756049, "Accept", newJString(Accept))
  add(path_756048, "repo", newJString(repo))
  add(path_756048, "owner", newJString(owner))
  result = call_756047.call(path_756048, nil, header_756049, nil, nil)

var getReposOwnerRepoSubscription* = Call_GetReposOwnerRepoSubscription_756040(
    name: "getReposOwnerRepoSubscription", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscription",
    validator: validate_GetReposOwnerRepoSubscription_756041, base: "/",
    makeUrl: url_GetReposOwnerRepoSubscription_756042, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoSubscription_756062 = ref object of OpenApiRestCall_753573
proc url_DeleteReposOwnerRepoSubscription_756064(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoSubscription_756063(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Delete a Repository Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_756065 = path.getOrDefault("repo")
  valid_756065 = validateParameter(valid_756065, JString, required = true,
                                 default = nil)
  if valid_756065 != nil:
    section.add "repo", valid_756065
  var valid_756066 = path.getOrDefault("owner")
  valid_756066 = validateParameter(valid_756066, JString, required = true,
                                 default = nil)
  if valid_756066 != nil:
    section.add "owner", valid_756066
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756067 = header.getOrDefault("Accept")
  valid_756067 = validateParameter(valid_756067, JString, required = false,
                                 default = nil)
  if valid_756067 != nil:
    section.add "Accept", valid_756067
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756068: Call_DeleteReposOwnerRepoSubscription_756062;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a Repository Subscription.
  ## 
  let valid = call_756068.validator(path, query, header, formData, body, _)
  let scheme = call_756068.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756068.makeUrl(scheme.get, call_756068.host, call_756068.base,
                             call_756068.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756068, uri, valid, _)

proc call*(call_756069: Call_DeleteReposOwnerRepoSubscription_756062; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoSubscription
  ## Delete a Repository Subscription.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_756070 = newJObject()
  var header_756071 = newJObject()
  add(header_756071, "Accept", newJString(Accept))
  add(path_756070, "repo", newJString(repo))
  add(path_756070, "owner", newJString(owner))
  result = call_756069.call(path_756070, nil, header_756071, nil, nil)

var deleteReposOwnerRepoSubscription* = Call_DeleteReposOwnerRepoSubscription_756062(
    name: "deleteReposOwnerRepoSubscription", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscription",
    validator: validate_DeleteReposOwnerRepoSubscription_756063, base: "/",
    makeUrl: url_DeleteReposOwnerRepoSubscription_756064, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoTags_756072 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoTags_756074(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/tags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoTags_756073(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Get list of tags.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_756075 = path.getOrDefault("repo")
  valid_756075 = validateParameter(valid_756075, JString, required = true,
                                 default = nil)
  if valid_756075 != nil:
    section.add "repo", valid_756075
  var valid_756076 = path.getOrDefault("owner")
  valid_756076 = validateParameter(valid_756076, JString, required = true,
                                 default = nil)
  if valid_756076 != nil:
    section.add "owner", valid_756076
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756077 = header.getOrDefault("Accept")
  valid_756077 = validateParameter(valid_756077, JString, required = false,
                                 default = nil)
  if valid_756077 != nil:
    section.add "Accept", valid_756077
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756078: Call_GetReposOwnerRepoTags_756072; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get list of tags.
  ## 
  let valid = call_756078.validator(path, query, header, formData, body, _)
  let scheme = call_756078.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756078.makeUrl(scheme.get, call_756078.host, call_756078.base,
                             call_756078.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756078, uri, valid, _)

proc call*(call_756079: Call_GetReposOwnerRepoTags_756072; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoTags
  ## Get list of tags.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_756080 = newJObject()
  var header_756081 = newJObject()
  add(header_756081, "Accept", newJString(Accept))
  add(path_756080, "repo", newJString(repo))
  add(path_756080, "owner", newJString(owner))
  result = call_756079.call(path_756080, nil, header_756081, nil, nil)

var getReposOwnerRepoTags* = Call_GetReposOwnerRepoTags_756072(
    name: "getReposOwnerRepoTags", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/repos/{owner}/{repo}/tags",
    validator: validate_GetReposOwnerRepoTags_756073, base: "/",
    makeUrl: url_GetReposOwnerRepoTags_756074, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoTeams_756082 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoTeams_756084(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/teams")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoTeams_756083(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Get list of teams
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_756085 = path.getOrDefault("repo")
  valid_756085 = validateParameter(valid_756085, JString, required = true,
                                 default = nil)
  if valid_756085 != nil:
    section.add "repo", valid_756085
  var valid_756086 = path.getOrDefault("owner")
  valid_756086 = validateParameter(valid_756086, JString, required = true,
                                 default = nil)
  if valid_756086 != nil:
    section.add "owner", valid_756086
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756087 = header.getOrDefault("Accept")
  valid_756087 = validateParameter(valid_756087, JString, required = false,
                                 default = nil)
  if valid_756087 != nil:
    section.add "Accept", valid_756087
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756088: Call_GetReposOwnerRepoTeams_756082; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get list of teams
  ## 
  let valid = call_756088.validator(path, query, header, formData, body, _)
  let scheme = call_756088.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756088.makeUrl(scheme.get, call_756088.host, call_756088.base,
                             call_756088.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756088, uri, valid, _)

proc call*(call_756089: Call_GetReposOwnerRepoTeams_756082; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoTeams
  ## Get list of teams
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_756090 = newJObject()
  var header_756091 = newJObject()
  add(header_756091, "Accept", newJString(Accept))
  add(path_756090, "repo", newJString(repo))
  add(path_756090, "owner", newJString(owner))
  result = call_756089.call(path_756090, nil, header_756091, nil, nil)

var getReposOwnerRepoTeams* = Call_GetReposOwnerRepoTeams_756082(
    name: "getReposOwnerRepoTeams", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/teams",
    validator: validate_GetReposOwnerRepoTeams_756083, base: "/",
    makeUrl: url_GetReposOwnerRepoTeams_756084, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoWatchers_756092 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoWatchers_756094(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/watchers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoWatchers_756093(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List Stargazers. New implementation.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_756095 = path.getOrDefault("repo")
  valid_756095 = validateParameter(valid_756095, JString, required = true,
                                 default = nil)
  if valid_756095 != nil:
    section.add "repo", valid_756095
  var valid_756096 = path.getOrDefault("owner")
  valid_756096 = validateParameter(valid_756096, JString, required = true,
                                 default = nil)
  if valid_756096 != nil:
    section.add "owner", valid_756096
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756097 = header.getOrDefault("Accept")
  valid_756097 = validateParameter(valid_756097, JString, required = false,
                                 default = nil)
  if valid_756097 != nil:
    section.add "Accept", valid_756097
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756098: Call_GetReposOwnerRepoWatchers_756092;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List Stargazers. New implementation.
  ## 
  let valid = call_756098.validator(path, query, header, formData, body, _)
  let scheme = call_756098.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756098.makeUrl(scheme.get, call_756098.host, call_756098.base,
                             call_756098.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756098, uri, valid, _)

proc call*(call_756099: Call_GetReposOwnerRepoWatchers_756092; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoWatchers
  ## List Stargazers. New implementation.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_756100 = newJObject()
  var header_756101 = newJObject()
  add(header_756101, "Accept", newJString(Accept))
  add(path_756100, "repo", newJString(repo))
  add(path_756100, "owner", newJString(owner))
  result = call_756099.call(path_756100, nil, header_756101, nil, nil)

var getReposOwnerRepoWatchers* = Call_GetReposOwnerRepoWatchers_756092(
    name: "getReposOwnerRepoWatchers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/watchers",
    validator: validate_GetReposOwnerRepoWatchers_756093, base: "/",
    makeUrl: url_GetReposOwnerRepoWatchers_756094, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoArchiveFormatPath_756102 = ref object of OpenApiRestCall_753573
proc url_GetReposOwnerRepoArchiveFormatPath_756104(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "archive_format" in path, "`archive_format` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "archive_format"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoArchiveFormatPath_756103(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Get archive link.
  ## This method will return a 302 to a URL to download a tarball or zipball
  ## archive for a repository. Please make sure your HTTP framework is
  ## configured to follow redirects or you will need to use the Location header
  ## to make a second GET request.
  ## Note: For private repositories, these links are temporary and expire quickly.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   archive_format: JString (required)
  ##   path: JString (required)
  ##       : Valid Git reference, defaults to 'master'.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of repository owner.
  section = newJObject()
  var valid_756105 = path.getOrDefault("archive_format")
  valid_756105 = validateParameter(valid_756105, JString, required = true,
                                 default = newJString("tarball"))
  if valid_756105 != nil:
    section.add "archive_format", valid_756105
  var valid_756106 = path.getOrDefault("path")
  valid_756106 = validateParameter(valid_756106, JString, required = true,
                                 default = nil)
  if valid_756106 != nil:
    section.add "path", valid_756106
  var valid_756107 = path.getOrDefault("repo")
  valid_756107 = validateParameter(valid_756107, JString, required = true,
                                 default = nil)
  if valid_756107 != nil:
    section.add "repo", valid_756107
  var valid_756108 = path.getOrDefault("owner")
  valid_756108 = validateParameter(valid_756108, JString, required = true,
                                 default = nil)
  if valid_756108 != nil:
    section.add "owner", valid_756108
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756109 = header.getOrDefault("Accept")
  valid_756109 = validateParameter(valid_756109, JString, required = false,
                                 default = nil)
  if valid_756109 != nil:
    section.add "Accept", valid_756109
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756110: Call_GetReposOwnerRepoArchiveFormatPath_756102;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get archive link.
  ## This method will return a 302 to a URL to download a tarball or zipball
  ## archive for a repository. Please make sure your HTTP framework is
  ## configured to follow redirects or you will need to use the Location header
  ## to make a second GET request.
  ## Note: For private repositories, these links are temporary and expire quickly.
  ## 
  ## 
  let valid = call_756110.validator(path, query, header, formData, body, _)
  let scheme = call_756110.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756110.makeUrl(scheme.get, call_756110.host, call_756110.base,
                             call_756110.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756110, uri, valid, _)

proc call*(call_756111: Call_GetReposOwnerRepoArchiveFormatPath_756102;
          path: string; repo: string; owner: string;
          archiveFormat: string = "tarball"; Accept: string = ""): Recallable =
  ## getReposOwnerRepoArchiveFormatPath
  ## Get archive link.
  ## This method will return a 302 to a URL to download a tarball or zipball
  ## archive for a repository. Please make sure your HTTP framework is
  ## configured to follow redirects or you will need to use the Location header
  ## to make a second GET request.
  ## Note: For private repositories, these links are temporary and expire quickly.
  ## 
  ##   archiveFormat: string (required)
  ##   path: string (required)
  ##       : Valid Git reference, defaults to 'master'.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  var path_756112 = newJObject()
  var header_756113 = newJObject()
  add(path_756112, "archive_format", newJString(archiveFormat))
  add(path_756112, "path", newJString(path))
  add(header_756113, "Accept", newJString(Accept))
  add(path_756112, "repo", newJString(repo))
  add(path_756112, "owner", newJString(owner))
  result = call_756111.call(path_756112, nil, header_756113, nil, nil)

var getReposOwnerRepoArchiveFormatPath* = Call_GetReposOwnerRepoArchiveFormatPath_756102(
    name: "getReposOwnerRepoArchiveFormatPath", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/{archive_format}/{path}",
    validator: validate_GetReposOwnerRepoArchiveFormatPath_756103, base: "/",
    makeUrl: url_GetReposOwnerRepoArchiveFormatPath_756104,
    schemes: {Scheme.Https})
type
  Call_GetRepositories_756114 = ref object of OpenApiRestCall_753573
proc url_GetRepositories_756116(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRepositories_756115(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode; _: string = ""): JsonNode =
  ## List all public repositories.
  ## This provides a dump of every public repository, in the order that they
  ## were created.
  ## Note: Pagination is powered exclusively by the since parameter. is the
  ## Link header to get the URL for the next page of repositories.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_756117 = query.getOrDefault("since")
  valid_756117 = validateParameter(valid_756117, JString, required = false,
                                 default = nil)
  if valid_756117 != nil:
    section.add "since", valid_756117
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756118 = header.getOrDefault("Accept")
  valid_756118 = validateParameter(valid_756118, JString, required = false,
                                 default = nil)
  if valid_756118 != nil:
    section.add "Accept", valid_756118
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756119: Call_GetRepositories_756114; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List all public repositories.
  ## This provides a dump of every public repository, in the order that they
  ## were created.
  ## Note: Pagination is powered exclusively by the since parameter. is the
  ## Link header to get the URL for the next page of repositories.
  ## 
  ## 
  let valid = call_756119.validator(path, query, header, formData, body, _)
  let scheme = call_756119.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756119.makeUrl(scheme.get, call_756119.host, call_756119.base,
                             call_756119.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756119, uri, valid, _)

proc call*(call_756120: Call_GetRepositories_756114; since: string = "";
          Accept: string = ""): Recallable =
  ## getRepositories
  ## List all public repositories.
  ## This provides a dump of every public repository, in the order that they
  ## were created.
  ## Note: Pagination is powered exclusively by the since parameter. is the
  ## Link header to get the URL for the next page of repositories.
  ## 
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var query_756121 = newJObject()
  var header_756122 = newJObject()
  add(query_756121, "since", newJString(since))
  add(header_756122, "Accept", newJString(Accept))
  result = call_756120.call(nil, query_756121, header_756122, nil, nil)

var getRepositories* = Call_GetRepositories_756114(name: "getRepositories",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/repositories",
    validator: validate_GetRepositories_756115, base: "/",
    makeUrl: url_GetRepositories_756116, schemes: {Scheme.Https})
type
  Call_GetSearchCode_756123 = ref object of OpenApiRestCall_753573
proc url_GetSearchCode_756125(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchCode_756124(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Search code.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  ##       : Can only be 'indexed', which indicates how recently a file has been indexed
  ## by the GitHub search infrastructure. If not provided, results are sorted
  ## by best match.
  ## 
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   q: JString (required)
  ##    : The search terms. This can be any combination of the supported code
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier
  ## you can restrict the search to just the file contents, the file path,
  ## or both.
  ## 'Languages' Searches code based on the language it's written in.
  ## 'Forks' Filters repositories based on the number of forks, and/or
  ## whether code from forked repositories should be included in the results
  ## at all.
  ## 'Size' Finds files that match a certain size (in bytes).
  ## 'Path' Specifies the path that the resulting file must be at.
  ## 'Extension' Matches files with a certain extension.
  ## 'Users' or 'Repositories' Limits searches to a specific user or repository.
  ## 
  section = newJObject()
  var valid_756126 = query.getOrDefault("sort")
  valid_756126 = validateParameter(valid_756126, JString, required = false,
                                 default = newJString("indexed"))
  if valid_756126 != nil:
    section.add "sort", valid_756126
  var valid_756127 = query.getOrDefault("order")
  valid_756127 = validateParameter(valid_756127, JString, required = false,
                                 default = newJString("desc"))
  if valid_756127 != nil:
    section.add "order", valid_756127
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_756128 = query.getOrDefault("q")
  valid_756128 = validateParameter(valid_756128, JString, required = true,
                                 default = nil)
  if valid_756128 != nil:
    section.add "q", valid_756128
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756129 = header.getOrDefault("Accept")
  valid_756129 = validateParameter(valid_756129, JString, required = false,
                                 default = nil)
  if valid_756129 != nil:
    section.add "Accept", valid_756129
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756130: Call_GetSearchCode_756123; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Search code.
  ## 
  let valid = call_756130.validator(path, query, header, formData, body, _)
  let scheme = call_756130.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756130.makeUrl(scheme.get, call_756130.host, call_756130.base,
                             call_756130.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756130, uri, valid, _)

proc call*(call_756131: Call_GetSearchCode_756123; q: string;
          sort: string = "indexed"; order: string = "desc"; Accept: string = ""): Recallable =
  ## getSearchCode
  ## Search code.
  ##   sort: string
  ##       : Can only be 'indexed', which indicates how recently a file has been indexed
  ## by the GitHub search infrastructure. If not provided, results are sorted
  ## by best match.
  ## 
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   q: string (required)
  ##    : The search terms. This can be any combination of the supported code
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier
  ## you can restrict the search to just the file contents, the file path,
  ## or both.
  ## 'Languages' Searches code based on the language it's written in.
  ## 'Forks' Filters repositories based on the number of forks, and/or
  ## whether code from forked repositories should be included in the results
  ## at all.
  ## 'Size' Finds files that match a certain size (in bytes).
  ## 'Path' Specifies the path that the resulting file must be at.
  ## 'Extension' Matches files with a certain extension.
  ## 'Users' or 'Repositories' Limits searches to a specific user or repository.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var query_756132 = newJObject()
  var header_756133 = newJObject()
  add(query_756132, "sort", newJString(sort))
  add(query_756132, "order", newJString(order))
  add(query_756132, "q", newJString(q))
  add(header_756133, "Accept", newJString(Accept))
  result = call_756131.call(nil, query_756132, header_756133, nil, nil)

var getSearchCode* = Call_GetSearchCode_756123(name: "getSearchCode",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/search/code",
    validator: validate_GetSearchCode_756124, base: "/", makeUrl: url_GetSearchCode_756125,
    schemes: {Scheme.Https})
type
  Call_GetSearchIssues_756134 = ref object of OpenApiRestCall_753573
proc url_GetSearchIssues_756136(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchIssues_756135(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode; _: string = ""): JsonNode =
  ## Find issues by state and keyword. (This method returns up to 100 results per page.)
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  ##       : The sort field. Can be comments, created, or updated. Default: results are sorted by best match.
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   q: JString (required)
  ##    : The q search term can also contain any combination of the supported issue search qualifiers:
  section = newJObject()
  var valid_756137 = query.getOrDefault("sort")
  valid_756137 = validateParameter(valid_756137, JString, required = false,
                                 default = newJString("updated"))
  if valid_756137 != nil:
    section.add "sort", valid_756137
  var valid_756138 = query.getOrDefault("order")
  valid_756138 = validateParameter(valid_756138, JString, required = false,
                                 default = newJString("desc"))
  if valid_756138 != nil:
    section.add "order", valid_756138
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_756139 = query.getOrDefault("q")
  valid_756139 = validateParameter(valid_756139, JString, required = true,
                                 default = nil)
  if valid_756139 != nil:
    section.add "q", valid_756139
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756140 = header.getOrDefault("Accept")
  valid_756140 = validateParameter(valid_756140, JString, required = false,
                                 default = nil)
  if valid_756140 != nil:
    section.add "Accept", valid_756140
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756141: Call_GetSearchIssues_756134; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Find issues by state and keyword. (This method returns up to 100 results per page.)
  ## 
  let valid = call_756141.validator(path, query, header, formData, body, _)
  let scheme = call_756141.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756141.makeUrl(scheme.get, call_756141.host, call_756141.base,
                             call_756141.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756141, uri, valid, _)

proc call*(call_756142: Call_GetSearchIssues_756134; q: string;
          sort: string = "updated"; order: string = "desc"; Accept: string = ""): Recallable =
  ## getSearchIssues
  ## Find issues by state and keyword. (This method returns up to 100 results per page.)
  ##   sort: string
  ##       : The sort field. Can be comments, created, or updated. Default: results are sorted by best match.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   q: string (required)
  ##    : The q search term can also contain any combination of the supported issue search qualifiers:
  ##   Accept: string
  ##         : Is used to set specified media type.
  var query_756143 = newJObject()
  var header_756144 = newJObject()
  add(query_756143, "sort", newJString(sort))
  add(query_756143, "order", newJString(order))
  add(query_756143, "q", newJString(q))
  add(header_756144, "Accept", newJString(Accept))
  result = call_756142.call(nil, query_756143, header_756144, nil, nil)

var getSearchIssues* = Call_GetSearchIssues_756134(name: "getSearchIssues",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/search/issues",
    validator: validate_GetSearchIssues_756135, base: "/",
    makeUrl: url_GetSearchIssues_756136, schemes: {Scheme.Https})
type
  Call_GetSearchRepositories_756145 = ref object of OpenApiRestCall_753573
proc url_GetSearchRepositories_756147(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchRepositories_756146(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Search repositories.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  ##       : If not provided, results are sorted by best match.
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   q: JString (required)
  ##    : The search terms. This can be any combination of the supported repository
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the repository name, description, readme,
  ## or any combination of these.
  ## 'Size' Finds repositories that match a certain size (in kilobytes).
  ## 'Forks' Filters repositories based on the number of forks, and/or whether
  ## forked repositories should be included in the results at all.
  ## 'Created' and 'Last Updated' Filters repositories based on times of
  ## creation, or when they were last updated.
  ## 'Users or Repositories' Limits searches to a specific user or repository.
  ## 'Languages' Searches repositories based on the language they are written in.
  ## 'Stars' Searches repositories based on the number of stars.
  ## 
  section = newJObject()
  var valid_756148 = query.getOrDefault("sort")
  valid_756148 = validateParameter(valid_756148, JString, required = false,
                                 default = newJString("stars"))
  if valid_756148 != nil:
    section.add "sort", valid_756148
  var valid_756149 = query.getOrDefault("order")
  valid_756149 = validateParameter(valid_756149, JString, required = false,
                                 default = newJString("desc"))
  if valid_756149 != nil:
    section.add "order", valid_756149
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_756150 = query.getOrDefault("q")
  valid_756150 = validateParameter(valid_756150, JString, required = true,
                                 default = nil)
  if valid_756150 != nil:
    section.add "q", valid_756150
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756151 = header.getOrDefault("Accept")
  valid_756151 = validateParameter(valid_756151, JString, required = false,
                                 default = nil)
  if valid_756151 != nil:
    section.add "Accept", valid_756151
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756152: Call_GetSearchRepositories_756145; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Search repositories.
  ## 
  let valid = call_756152.validator(path, query, header, formData, body, _)
  let scheme = call_756152.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756152.makeUrl(scheme.get, call_756152.host, call_756152.base,
                             call_756152.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756152, uri, valid, _)

proc call*(call_756153: Call_GetSearchRepositories_756145; q: string;
          sort: string = "stars"; order: string = "desc"; Accept: string = ""): Recallable =
  ## getSearchRepositories
  ## Search repositories.
  ##   sort: string
  ##       : If not provided, results are sorted by best match.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   q: string (required)
  ##    : The search terms. This can be any combination of the supported repository
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the repository name, description, readme,
  ## or any combination of these.
  ## 'Size' Finds repositories that match a certain size (in kilobytes).
  ## 'Forks' Filters repositories based on the number of forks, and/or whether
  ## forked repositories should be included in the results at all.
  ## 'Created' and 'Last Updated' Filters repositories based on times of
  ## creation, or when they were last updated.
  ## 'Users or Repositories' Limits searches to a specific user or repository.
  ## 'Languages' Searches repositories based on the language they are written in.
  ## 'Stars' Searches repositories based on the number of stars.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var query_756154 = newJObject()
  var header_756155 = newJObject()
  add(query_756154, "sort", newJString(sort))
  add(query_756154, "order", newJString(order))
  add(query_756154, "q", newJString(q))
  add(header_756155, "Accept", newJString(Accept))
  result = call_756153.call(nil, query_756154, header_756155, nil, nil)

var getSearchRepositories* = Call_GetSearchRepositories_756145(
    name: "getSearchRepositories", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/search/repositories", validator: validate_GetSearchRepositories_756146,
    base: "/", makeUrl: url_GetSearchRepositories_756147, schemes: {Scheme.Https})
type
  Call_GetSearchUsers_756156 = ref object of OpenApiRestCall_753573
proc url_GetSearchUsers_756158(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchUsers_756157(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; _: string = ""): JsonNode =
  ## Search users.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  ##       : If not provided, results are sorted by best match.
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   q: JString (required)
  ##    : The search terms. This can be any combination of the supported user
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the username, public email, full name,
  ## location, or any combination of these.
  ## 'Repository count' Filters users based on the number of repositories they
  ## have.
  ## 'Location' Filter users by the location indicated in their profile.
  ## 'Language' Search for users that have repositories that match a certain
  ## language.
  ## 'Created' Filter users based on when they joined.
  ## 'Followers' Filter users based on the number of followers they have.
  ## 
  section = newJObject()
  var valid_756159 = query.getOrDefault("sort")
  valid_756159 = validateParameter(valid_756159, JString, required = false,
                                 default = newJString("followers"))
  if valid_756159 != nil:
    section.add "sort", valid_756159
  var valid_756160 = query.getOrDefault("order")
  valid_756160 = validateParameter(valid_756160, JString, required = false,
                                 default = newJString("desc"))
  if valid_756160 != nil:
    section.add "order", valid_756160
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_756161 = query.getOrDefault("q")
  valid_756161 = validateParameter(valid_756161, JString, required = true,
                                 default = nil)
  if valid_756161 != nil:
    section.add "q", valid_756161
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756162 = header.getOrDefault("Accept")
  valid_756162 = validateParameter(valid_756162, JString, required = false,
                                 default = nil)
  if valid_756162 != nil:
    section.add "Accept", valid_756162
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756163: Call_GetSearchUsers_756156; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Search users.
  ## 
  let valid = call_756163.validator(path, query, header, formData, body, _)
  let scheme = call_756163.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756163.makeUrl(scheme.get, call_756163.host, call_756163.base,
                             call_756163.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756163, uri, valid, _)

proc call*(call_756164: Call_GetSearchUsers_756156; q: string;
          sort: string = "followers"; order: string = "desc"; Accept: string = ""): Recallable =
  ## getSearchUsers
  ## Search users.
  ##   sort: string
  ##       : If not provided, results are sorted by best match.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   q: string (required)
  ##    : The search terms. This can be any combination of the supported user
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the username, public email, full name,
  ## location, or any combination of these.
  ## 'Repository count' Filters users based on the number of repositories they
  ## have.
  ## 'Location' Filter users by the location indicated in their profile.
  ## 'Language' Search for users that have repositories that match a certain
  ## language.
  ## 'Created' Filter users based on when they joined.
  ## 'Followers' Filter users based on the number of followers they have.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var query_756165 = newJObject()
  var header_756166 = newJObject()
  add(query_756165, "sort", newJString(sort))
  add(query_756165, "order", newJString(order))
  add(query_756165, "q", newJString(q))
  add(header_756166, "Accept", newJString(Accept))
  result = call_756164.call(nil, query_756165, header_756166, nil, nil)

var getSearchUsers* = Call_GetSearchUsers_756156(name: "getSearchUsers",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/search/users",
    validator: validate_GetSearchUsers_756157, base: "/",
    makeUrl: url_GetSearchUsers_756158, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamId_756167 = ref object of OpenApiRestCall_753573
proc url_GetTeamsTeamId_756169(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamId_756168(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; _: string = ""): JsonNode =
  ## Get team.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_756170 = path.getOrDefault("teamId")
  valid_756170 = validateParameter(valid_756170, JInt, required = true, default = nil)
  if valid_756170 != nil:
    section.add "teamId", valid_756170
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756171 = header.getOrDefault("Accept")
  valid_756171 = validateParameter(valid_756171, JString, required = false,
                                 default = nil)
  if valid_756171 != nil:
    section.add "Accept", valid_756171
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756172: Call_GetTeamsTeamId_756167; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get team.
  ## 
  let valid = call_756172.validator(path, query, header, formData, body, _)
  let scheme = call_756172.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756172.makeUrl(scheme.get, call_756172.host, call_756172.base,
                             call_756172.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756172, uri, valid, _)

proc call*(call_756173: Call_GetTeamsTeamId_756167; teamId: int; Accept: string = ""): Recallable =
  ## getTeamsTeamId
  ## Get team.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_756174 = newJObject()
  var header_756175 = newJObject()
  add(header_756175, "Accept", newJString(Accept))
  add(path_756174, "teamId", newJInt(teamId))
  result = call_756173.call(path_756174, nil, header_756175, nil, nil)

var getTeamsTeamId* = Call_GetTeamsTeamId_756167(name: "getTeamsTeamId",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/teams/{teamId}",
    validator: validate_GetTeamsTeamId_756168, base: "/",
    makeUrl: url_GetTeamsTeamId_756169, schemes: {Scheme.Https})
type
  Call_PatchTeamsTeamId_756185 = ref object of OpenApiRestCall_753573
proc url_PatchTeamsTeamId_756187(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchTeamsTeamId_756186(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode =
  ## Edit team.
  ## In order to edit a team, the authenticated user must be an owner of the org
  ## that the team is associated with.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_756188 = path.getOrDefault("teamId")
  valid_756188 = validateParameter(valid_756188, JInt, required = true, default = nil)
  if valid_756188 != nil:
    section.add "teamId", valid_756188
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756189 = header.getOrDefault("Accept")
  valid_756189 = validateParameter(valid_756189, JString, required = false,
                                 default = nil)
  if valid_756189 != nil:
    section.add "Accept", valid_756189
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_756191: Call_PatchTeamsTeamId_756185; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit team.
  ## In order to edit a team, the authenticated user must be an owner of the org
  ## that the team is associated with.
  ## 
  ## 
  let valid = call_756191.validator(path, query, header, formData, body, _)
  let scheme = call_756191.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756191.makeUrl(scheme.get, call_756191.host, call_756191.base,
                             call_756191.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756191, uri, valid, _)

proc call*(call_756192: Call_PatchTeamsTeamId_756185; teamId: int; body: JsonNode;
          Accept: string = ""): Recallable =
  ## patchTeamsTeamId
  ## Edit team.
  ## In order to edit a team, the authenticated user must be an owner of the org
  ## that the team is associated with.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  ##   body: JObject (required)
  var path_756193 = newJObject()
  var header_756194 = newJObject()
  var body_756195 = newJObject()
  add(header_756194, "Accept", newJString(Accept))
  add(path_756193, "teamId", newJInt(teamId))
  if body != nil:
    body_756195 = body
  result = call_756192.call(path_756193, nil, header_756194, nil, body_756195)

var patchTeamsTeamId* = Call_PatchTeamsTeamId_756185(name: "patchTeamsTeamId",
    meth: HttpMethod.HttpPatch, host: "api.github.com", route: "/teams/{teamId}",
    validator: validate_PatchTeamsTeamId_756186, base: "/",
    makeUrl: url_PatchTeamsTeamId_756187, schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamId_756176 = ref object of OpenApiRestCall_753573
proc url_DeleteTeamsTeamId_756178(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamId_756177(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode =
  ## Delete team.
  ## In order to delete a team, the authenticated user must be an owner of the
  ## org that the team is associated with.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_756179 = path.getOrDefault("teamId")
  valid_756179 = validateParameter(valid_756179, JInt, required = true, default = nil)
  if valid_756179 != nil:
    section.add "teamId", valid_756179
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756180 = header.getOrDefault("Accept")
  valid_756180 = validateParameter(valid_756180, JString, required = false,
                                 default = nil)
  if valid_756180 != nil:
    section.add "Accept", valid_756180
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756181: Call_DeleteTeamsTeamId_756176; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete team.
  ## In order to delete a team, the authenticated user must be an owner of the
  ## org that the team is associated with.
  ## 
  ## 
  let valid = call_756181.validator(path, query, header, formData, body, _)
  let scheme = call_756181.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756181.makeUrl(scheme.get, call_756181.host, call_756181.base,
                             call_756181.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756181, uri, valid, _)

proc call*(call_756182: Call_DeleteTeamsTeamId_756176; teamId: int;
          Accept: string = ""): Recallable =
  ## deleteTeamsTeamId
  ## Delete team.
  ## In order to delete a team, the authenticated user must be an owner of the
  ## org that the team is associated with.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_756183 = newJObject()
  var header_756184 = newJObject()
  add(header_756184, "Accept", newJString(Accept))
  add(path_756183, "teamId", newJInt(teamId))
  result = call_756182.call(path_756183, nil, header_756184, nil, nil)

var deleteTeamsTeamId* = Call_DeleteTeamsTeamId_756176(name: "deleteTeamsTeamId",
    meth: HttpMethod.HttpDelete, host: "api.github.com", route: "/teams/{teamId}",
    validator: validate_DeleteTeamsTeamId_756177, base: "/",
    makeUrl: url_DeleteTeamsTeamId_756178, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdMembers_756196 = ref object of OpenApiRestCall_753573
proc url_GetTeamsTeamIdMembers_756198(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/members")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdMembers_756197(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List team members.
  ## In order to list members in a team, the authenticated user must be a member
  ## of the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_756199 = path.getOrDefault("teamId")
  valid_756199 = validateParameter(valid_756199, JInt, required = true, default = nil)
  if valid_756199 != nil:
    section.add "teamId", valid_756199
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756200 = header.getOrDefault("Accept")
  valid_756200 = validateParameter(valid_756200, JString, required = false,
                                 default = nil)
  if valid_756200 != nil:
    section.add "Accept", valid_756200
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756201: Call_GetTeamsTeamIdMembers_756196; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List team members.
  ## In order to list members in a team, the authenticated user must be a member
  ## of the team.
  ## 
  ## 
  let valid = call_756201.validator(path, query, header, formData, body, _)
  let scheme = call_756201.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756201.makeUrl(scheme.get, call_756201.host, call_756201.base,
                             call_756201.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756201, uri, valid, _)

proc call*(call_756202: Call_GetTeamsTeamIdMembers_756196; teamId: int;
          Accept: string = ""): Recallable =
  ## getTeamsTeamIdMembers
  ## List team members.
  ## In order to list members in a team, the authenticated user must be a member
  ## of the team.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_756203 = newJObject()
  var header_756204 = newJObject()
  add(header_756204, "Accept", newJString(Accept))
  add(path_756203, "teamId", newJInt(teamId))
  result = call_756202.call(path_756203, nil, header_756204, nil, nil)

var getTeamsTeamIdMembers* = Call_GetTeamsTeamIdMembers_756196(
    name: "getTeamsTeamIdMembers", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/teams/{teamId}/members", validator: validate_GetTeamsTeamIdMembers_756197,
    base: "/", makeUrl: url_GetTeamsTeamIdMembers_756198, schemes: {Scheme.Https})
type
  Call_PutTeamsTeamIdMembersUsername_756215 = ref object of OpenApiRestCall_753573
proc url_PutTeamsTeamIdMembersUsername_756217(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutTeamsTeamIdMembersUsername_756216(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## The API (described below) is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Add team membership API instead. It allows you to invite new organization members to your teams.
  ## 
  ## Add team member.
  ## In order to add a user to a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_756218 = path.getOrDefault("username")
  valid_756218 = validateParameter(valid_756218, JString, required = true,
                                 default = nil)
  if valid_756218 != nil:
    section.add "username", valid_756218
  var valid_756219 = path.getOrDefault("teamId")
  valid_756219 = validateParameter(valid_756219, JInt, required = true, default = nil)
  if valid_756219 != nil:
    section.add "teamId", valid_756219
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756220 = header.getOrDefault("Accept")
  valid_756220 = validateParameter(valid_756220, JString, required = false,
                                 default = nil)
  if valid_756220 != nil:
    section.add "Accept", valid_756220
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756221: Call_PutTeamsTeamIdMembersUsername_756215;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## The API (described below) is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Add team membership API instead. It allows you to invite new organization members to your teams.
  ## 
  ## Add team member.
  ## In order to add a user to a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## 
  ## 
  let valid = call_756221.validator(path, query, header, formData, body, _)
  let scheme = call_756221.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756221.makeUrl(scheme.get, call_756221.host, call_756221.base,
                             call_756221.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756221, uri, valid, _)

proc call*(call_756222: Call_PutTeamsTeamIdMembersUsername_756215;
          username: string; teamId: int; Accept: string = ""): Recallable =
  ## putTeamsTeamIdMembersUsername
  ## The API (described below) is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Add team membership API instead. It allows you to invite new organization members to your teams.
  ## 
  ## Add team member.
  ## In order to add a user to a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_756223 = newJObject()
  var header_756224 = newJObject()
  add(path_756223, "username", newJString(username))
  add(header_756224, "Accept", newJString(Accept))
  add(path_756223, "teamId", newJInt(teamId))
  result = call_756222.call(path_756223, nil, header_756224, nil, nil)

var putTeamsTeamIdMembersUsername* = Call_PutTeamsTeamIdMembersUsername_756215(
    name: "putTeamsTeamIdMembersUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/teams/{teamId}/members/{username}",
    validator: validate_PutTeamsTeamIdMembersUsername_756216, base: "/",
    makeUrl: url_PutTeamsTeamIdMembersUsername_756217, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdMembersUsername_756205 = ref object of OpenApiRestCall_753573
proc url_GetTeamsTeamIdMembersUsername_756207(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdMembersUsername_756206(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## The "Get team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Get team membership API instead. It allows you to get both active and pending memberships.
  ## 
  ## Get team member.
  ## In order to get if a user is a member of a team, the authenticated user mus
  ## be a member of the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_756208 = path.getOrDefault("username")
  valid_756208 = validateParameter(valid_756208, JString, required = true,
                                 default = nil)
  if valid_756208 != nil:
    section.add "username", valid_756208
  var valid_756209 = path.getOrDefault("teamId")
  valid_756209 = validateParameter(valid_756209, JInt, required = true, default = nil)
  if valid_756209 != nil:
    section.add "teamId", valid_756209
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756210 = header.getOrDefault("Accept")
  valid_756210 = validateParameter(valid_756210, JString, required = false,
                                 default = nil)
  if valid_756210 != nil:
    section.add "Accept", valid_756210
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756211: Call_GetTeamsTeamIdMembersUsername_756205;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## The "Get team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Get team membership API instead. It allows you to get both active and pending memberships.
  ## 
  ## Get team member.
  ## In order to get if a user is a member of a team, the authenticated user mus
  ## be a member of the team.
  ## 
  ## 
  let valid = call_756211.validator(path, query, header, formData, body, _)
  let scheme = call_756211.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756211.makeUrl(scheme.get, call_756211.host, call_756211.base,
                             call_756211.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756211, uri, valid, _)

proc call*(call_756212: Call_GetTeamsTeamIdMembersUsername_756205;
          username: string; teamId: int; Accept: string = ""): Recallable =
  ## getTeamsTeamIdMembersUsername
  ## The "Get team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Get team membership API instead. It allows you to get both active and pending memberships.
  ## 
  ## Get team member.
  ## In order to get if a user is a member of a team, the authenticated user mus
  ## be a member of the team.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_756213 = newJObject()
  var header_756214 = newJObject()
  add(path_756213, "username", newJString(username))
  add(header_756214, "Accept", newJString(Accept))
  add(path_756213, "teamId", newJInt(teamId))
  result = call_756212.call(path_756213, nil, header_756214, nil, nil)

var getTeamsTeamIdMembersUsername* = Call_GetTeamsTeamIdMembersUsername_756205(
    name: "getTeamsTeamIdMembersUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/teams/{teamId}/members/{username}",
    validator: validate_GetTeamsTeamIdMembersUsername_756206, base: "/",
    makeUrl: url_GetTeamsTeamIdMembersUsername_756207, schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamIdMembersUsername_756225 = ref object of OpenApiRestCall_753573
proc url_DeleteTeamsTeamIdMembersUsername_756227(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamIdMembersUsername_756226(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## The "Remove team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Remove team membership API instead. It allows you to remove both active and pending memberships.
  ## 
  ## Remove team member.
  ## In order to remove a user from a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## NOTE This does not delete the user, it just remove them from the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_756228 = path.getOrDefault("username")
  valid_756228 = validateParameter(valid_756228, JString, required = true,
                                 default = nil)
  if valid_756228 != nil:
    section.add "username", valid_756228
  var valid_756229 = path.getOrDefault("teamId")
  valid_756229 = validateParameter(valid_756229, JInt, required = true, default = nil)
  if valid_756229 != nil:
    section.add "teamId", valid_756229
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756230 = header.getOrDefault("Accept")
  valid_756230 = validateParameter(valid_756230, JString, required = false,
                                 default = nil)
  if valid_756230 != nil:
    section.add "Accept", valid_756230
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756231: Call_DeleteTeamsTeamIdMembersUsername_756225;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## The "Remove team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Remove team membership API instead. It allows you to remove both active and pending memberships.
  ## 
  ## Remove team member.
  ## In order to remove a user from a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## NOTE This does not delete the user, it just remove them from the team.
  ## 
  ## 
  let valid = call_756231.validator(path, query, header, formData, body, _)
  let scheme = call_756231.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756231.makeUrl(scheme.get, call_756231.host, call_756231.base,
                             call_756231.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756231, uri, valid, _)

proc call*(call_756232: Call_DeleteTeamsTeamIdMembersUsername_756225;
          username: string; teamId: int; Accept: string = ""): Recallable =
  ## deleteTeamsTeamIdMembersUsername
  ## The "Remove team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Remove team membership API instead. It allows you to remove both active and pending memberships.
  ## 
  ## Remove team member.
  ## In order to remove a user from a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## NOTE This does not delete the user, it just remove them from the team.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_756233 = newJObject()
  var header_756234 = newJObject()
  add(path_756233, "username", newJString(username))
  add(header_756234, "Accept", newJString(Accept))
  add(path_756233, "teamId", newJInt(teamId))
  result = call_756232.call(path_756233, nil, header_756234, nil, nil)

var deleteTeamsTeamIdMembersUsername* = Call_DeleteTeamsTeamIdMembersUsername_756225(
    name: "deleteTeamsTeamIdMembersUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/teams/{teamId}/members/{username}",
    validator: validate_DeleteTeamsTeamIdMembersUsername_756226, base: "/",
    makeUrl: url_DeleteTeamsTeamIdMembersUsername_756227, schemes: {Scheme.Https})
type
  Call_PutTeamsTeamIdMembershipsUsername_756245 = ref object of OpenApiRestCall_753573
proc url_PutTeamsTeamIdMembershipsUsername_756247(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/memberships/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutTeamsTeamIdMembershipsUsername_756246(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Add team membership.
  ## In order to add a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with.
  ## 
  ## If the user is already a part of the team's organization (meaning they're on at least one other team in the organization), this endpoint will add the user to the team.
  ## 
  ## If the user is completely unaffiliated with the team's organization (meaning they're on none of the organization's teams), this endpoint will send an invitation to the user via email. This newly-created membership will be in the 'pending' state until the user accepts the invitation, at which point the membership will transition to the 'active' state and the user will be added as a member of the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_756248 = path.getOrDefault("username")
  valid_756248 = validateParameter(valid_756248, JString, required = true,
                                 default = nil)
  if valid_756248 != nil:
    section.add "username", valid_756248
  var valid_756249 = path.getOrDefault("teamId")
  valid_756249 = validateParameter(valid_756249, JInt, required = true, default = nil)
  if valid_756249 != nil:
    section.add "teamId", valid_756249
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756250 = header.getOrDefault("Accept")
  valid_756250 = validateParameter(valid_756250, JString, required = false,
                                 default = nil)
  if valid_756250 != nil:
    section.add "Accept", valid_756250
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756251: Call_PutTeamsTeamIdMembershipsUsername_756245;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Add team membership.
  ## In order to add a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with.
  ## 
  ## If the user is already a part of the team's organization (meaning they're on at least one other team in the organization), this endpoint will add the user to the team.
  ## 
  ## If the user is completely unaffiliated with the team's organization (meaning they're on none of the organization's teams), this endpoint will send an invitation to the user via email. This newly-created membership will be in the 'pending' state until the user accepts the invitation, at which point the membership will transition to the 'active' state and the user will be added as a member of the team.
  ## 
  ## 
  let valid = call_756251.validator(path, query, header, formData, body, _)
  let scheme = call_756251.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756251.makeUrl(scheme.get, call_756251.host, call_756251.base,
                             call_756251.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756251, uri, valid, _)

proc call*(call_756252: Call_PutTeamsTeamIdMembershipsUsername_756245;
          username: string; teamId: int; Accept: string = ""): Recallable =
  ## putTeamsTeamIdMembershipsUsername
  ## Add team membership.
  ## In order to add a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with.
  ## 
  ## If the user is already a part of the team's organization (meaning they're on at least one other team in the organization), this endpoint will add the user to the team.
  ## 
  ## If the user is completely unaffiliated with the team's organization (meaning they're on none of the organization's teams), this endpoint will send an invitation to the user via email. This newly-created membership will be in the 'pending' state until the user accepts the invitation, at which point the membership will transition to the 'active' state and the user will be added as a member of the team.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_756253 = newJObject()
  var header_756254 = newJObject()
  add(path_756253, "username", newJString(username))
  add(header_756254, "Accept", newJString(Accept))
  add(path_756253, "teamId", newJInt(teamId))
  result = call_756252.call(path_756253, nil, header_756254, nil, nil)

var putTeamsTeamIdMembershipsUsername* = Call_PutTeamsTeamIdMembershipsUsername_756245(
    name: "putTeamsTeamIdMembershipsUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/teams/{teamId}/memberships/{username}",
    validator: validate_PutTeamsTeamIdMembershipsUsername_756246, base: "/",
    makeUrl: url_PutTeamsTeamIdMembershipsUsername_756247, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdMembershipsUsername_756235 = ref object of OpenApiRestCall_753573
proc url_GetTeamsTeamIdMembershipsUsername_756237(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/memberships/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdMembershipsUsername_756236(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Get team membership.
  ## In order to get a user's membership with a team, the authenticated user must be a member of the team or an owner of the team's organization.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_756238 = path.getOrDefault("username")
  valid_756238 = validateParameter(valid_756238, JString, required = true,
                                 default = nil)
  if valid_756238 != nil:
    section.add "username", valid_756238
  var valid_756239 = path.getOrDefault("teamId")
  valid_756239 = validateParameter(valid_756239, JInt, required = true, default = nil)
  if valid_756239 != nil:
    section.add "teamId", valid_756239
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756240 = header.getOrDefault("Accept")
  valid_756240 = validateParameter(valid_756240, JString, required = false,
                                 default = nil)
  if valid_756240 != nil:
    section.add "Accept", valid_756240
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756241: Call_GetTeamsTeamIdMembershipsUsername_756235;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get team membership.
  ## In order to get a user's membership with a team, the authenticated user must be a member of the team or an owner of the team's organization.
  ## 
  ## 
  let valid = call_756241.validator(path, query, header, formData, body, _)
  let scheme = call_756241.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756241.makeUrl(scheme.get, call_756241.host, call_756241.base,
                             call_756241.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756241, uri, valid, _)

proc call*(call_756242: Call_GetTeamsTeamIdMembershipsUsername_756235;
          username: string; teamId: int; Accept: string = ""): Recallable =
  ## getTeamsTeamIdMembershipsUsername
  ## Get team membership.
  ## In order to get a user's membership with a team, the authenticated user must be a member of the team or an owner of the team's organization.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_756243 = newJObject()
  var header_756244 = newJObject()
  add(path_756243, "username", newJString(username))
  add(header_756244, "Accept", newJString(Accept))
  add(path_756243, "teamId", newJInt(teamId))
  result = call_756242.call(path_756243, nil, header_756244, nil, nil)

var getTeamsTeamIdMembershipsUsername* = Call_GetTeamsTeamIdMembershipsUsername_756235(
    name: "getTeamsTeamIdMembershipsUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/teams/{teamId}/memberships/{username}",
    validator: validate_GetTeamsTeamIdMembershipsUsername_756236, base: "/",
    makeUrl: url_GetTeamsTeamIdMembershipsUsername_756237, schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamIdMembershipsUsername_756255 = ref object of OpenApiRestCall_753573
proc url_DeleteTeamsTeamIdMembershipsUsername_756257(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/memberships/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamIdMembershipsUsername_756256(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Remove team membership.
  ## In order to remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. NOTE: This does not delete the user, it just removes their membership from the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_756258 = path.getOrDefault("username")
  valid_756258 = validateParameter(valid_756258, JString, required = true,
                                 default = nil)
  if valid_756258 != nil:
    section.add "username", valid_756258
  var valid_756259 = path.getOrDefault("teamId")
  valid_756259 = validateParameter(valid_756259, JInt, required = true, default = nil)
  if valid_756259 != nil:
    section.add "teamId", valid_756259
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756260 = header.getOrDefault("Accept")
  valid_756260 = validateParameter(valid_756260, JString, required = false,
                                 default = nil)
  if valid_756260 != nil:
    section.add "Accept", valid_756260
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756261: Call_DeleteTeamsTeamIdMembershipsUsername_756255;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Remove team membership.
  ## In order to remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. NOTE: This does not delete the user, it just removes their membership from the team.
  ## 
  ## 
  let valid = call_756261.validator(path, query, header, formData, body, _)
  let scheme = call_756261.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756261.makeUrl(scheme.get, call_756261.host, call_756261.base,
                             call_756261.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756261, uri, valid, _)

proc call*(call_756262: Call_DeleteTeamsTeamIdMembershipsUsername_756255;
          username: string; teamId: int; Accept: string = ""): Recallable =
  ## deleteTeamsTeamIdMembershipsUsername
  ## Remove team membership.
  ## In order to remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. NOTE: This does not delete the user, it just removes their membership from the team.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_756263 = newJObject()
  var header_756264 = newJObject()
  add(path_756263, "username", newJString(username))
  add(header_756264, "Accept", newJString(Accept))
  add(path_756263, "teamId", newJInt(teamId))
  result = call_756262.call(path_756263, nil, header_756264, nil, nil)

var deleteTeamsTeamIdMembershipsUsername* = Call_DeleteTeamsTeamIdMembershipsUsername_756255(
    name: "deleteTeamsTeamIdMembershipsUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/teams/{teamId}/memberships/{username}",
    validator: validate_DeleteTeamsTeamIdMembershipsUsername_756256, base: "/",
    makeUrl: url_DeleteTeamsTeamIdMembershipsUsername_756257,
    schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdRepos_756265 = ref object of OpenApiRestCall_753573
proc url_GetTeamsTeamIdRepos_756267(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdRepos_756266(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode; _: string = ""): JsonNode =
  ## List team repos
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_756268 = path.getOrDefault("teamId")
  valid_756268 = validateParameter(valid_756268, JInt, required = true, default = nil)
  if valid_756268 != nil:
    section.add "teamId", valid_756268
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756269 = header.getOrDefault("Accept")
  valid_756269 = validateParameter(valid_756269, JString, required = false,
                                 default = nil)
  if valid_756269 != nil:
    section.add "Accept", valid_756269
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756270: Call_GetTeamsTeamIdRepos_756265; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List team repos
  ## 
  let valid = call_756270.validator(path, query, header, formData, body, _)
  let scheme = call_756270.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756270.makeUrl(scheme.get, call_756270.host, call_756270.base,
                             call_756270.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756270, uri, valid, _)

proc call*(call_756271: Call_GetTeamsTeamIdRepos_756265; teamId: int;
          Accept: string = ""): Recallable =
  ## getTeamsTeamIdRepos
  ## List team repos
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_756272 = newJObject()
  var header_756273 = newJObject()
  add(header_756273, "Accept", newJString(Accept))
  add(path_756272, "teamId", newJInt(teamId))
  result = call_756271.call(path_756272, nil, header_756273, nil, nil)

var getTeamsTeamIdRepos* = Call_GetTeamsTeamIdRepos_756265(
    name: "getTeamsTeamIdRepos", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/teams/{teamId}/repos", validator: validate_GetTeamsTeamIdRepos_756266,
    base: "/", makeUrl: url_GetTeamsTeamIdRepos_756267, schemes: {Scheme.Https})
type
  Call_PutTeamsTeamIdReposOwnerRepo_756285 = ref object of OpenApiRestCall_753573
proc url_PutTeamsTeamIdReposOwnerRepo_756287(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutTeamsTeamIdReposOwnerRepo_756286(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## In order to add a repository to a team, the authenticated user must be an owner of the org that the team is associated with. Also, the repository must be owned by the organization, or a direct fork of a repository owned by the organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   teamId: JInt (required)
  ##         : Id of team.
  ##   owner: JString (required)
  ##        : Name of a organization.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_756288 = path.getOrDefault("repo")
  valid_756288 = validateParameter(valid_756288, JString, required = true,
                                 default = nil)
  if valid_756288 != nil:
    section.add "repo", valid_756288
  var valid_756289 = path.getOrDefault("teamId")
  valid_756289 = validateParameter(valid_756289, JInt, required = true, default = nil)
  if valid_756289 != nil:
    section.add "teamId", valid_756289
  var valid_756290 = path.getOrDefault("owner")
  valid_756290 = validateParameter(valid_756290, JString, required = true,
                                 default = nil)
  if valid_756290 != nil:
    section.add "owner", valid_756290
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756291 = header.getOrDefault("Accept")
  valid_756291 = validateParameter(valid_756291, JString, required = false,
                                 default = nil)
  if valid_756291 != nil:
    section.add "Accept", valid_756291
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756292: Call_PutTeamsTeamIdReposOwnerRepo_756285;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## In order to add a repository to a team, the authenticated user must be an owner of the org that the team is associated with. Also, the repository must be owned by the organization, or a direct fork of a repository owned by the organization.
  ## 
  let valid = call_756292.validator(path, query, header, formData, body, _)
  let scheme = call_756292.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756292.makeUrl(scheme.get, call_756292.host, call_756292.base,
                             call_756292.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756292, uri, valid, _)

proc call*(call_756293: Call_PutTeamsTeamIdReposOwnerRepo_756285; repo: string;
          teamId: int; owner: string; Accept: string = ""): Recallable =
  ## putTeamsTeamIdReposOwnerRepo
  ## In order to add a repository to a team, the authenticated user must be an owner of the org that the team is associated with. Also, the repository must be owned by the organization, or a direct fork of a repository owned by the organization.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   teamId: int (required)
  ##         : Id of team.
  ##   owner: string (required)
  ##        : Name of a organization.
  var path_756294 = newJObject()
  var header_756295 = newJObject()
  add(header_756295, "Accept", newJString(Accept))
  add(path_756294, "repo", newJString(repo))
  add(path_756294, "teamId", newJInt(teamId))
  add(path_756294, "owner", newJString(owner))
  result = call_756293.call(path_756294, nil, header_756295, nil, nil)

var putTeamsTeamIdReposOwnerRepo* = Call_PutTeamsTeamIdReposOwnerRepo_756285(
    name: "putTeamsTeamIdReposOwnerRepo", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/teams/{teamId}/repos/{owner}/{repo}",
    validator: validate_PutTeamsTeamIdReposOwnerRepo_756286, base: "/",
    makeUrl: url_PutTeamsTeamIdReposOwnerRepo_756287, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdReposOwnerRepo_756274 = ref object of OpenApiRestCall_753573
proc url_GetTeamsTeamIdReposOwnerRepo_756276(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdReposOwnerRepo_756275(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Check if a team manages a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   teamId: JInt (required)
  ##         : Id of team.
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_756277 = path.getOrDefault("repo")
  valid_756277 = validateParameter(valid_756277, JString, required = true,
                                 default = nil)
  if valid_756277 != nil:
    section.add "repo", valid_756277
  var valid_756278 = path.getOrDefault("teamId")
  valid_756278 = validateParameter(valid_756278, JInt, required = true, default = nil)
  if valid_756278 != nil:
    section.add "teamId", valid_756278
  var valid_756279 = path.getOrDefault("owner")
  valid_756279 = validateParameter(valid_756279, JString, required = true,
                                 default = nil)
  if valid_756279 != nil:
    section.add "owner", valid_756279
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756280 = header.getOrDefault("Accept")
  valid_756280 = validateParameter(valid_756280, JString, required = false,
                                 default = nil)
  if valid_756280 != nil:
    section.add "Accept", valid_756280
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756281: Call_GetTeamsTeamIdReposOwnerRepo_756274;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if a team manages a repository
  ## 
  let valid = call_756281.validator(path, query, header, formData, body, _)
  let scheme = call_756281.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756281.makeUrl(scheme.get, call_756281.host, call_756281.base,
                             call_756281.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756281, uri, valid, _)

proc call*(call_756282: Call_GetTeamsTeamIdReposOwnerRepo_756274; repo: string;
          teamId: int; owner: string; Accept: string = ""): Recallable =
  ## getTeamsTeamIdReposOwnerRepo
  ## Check if a team manages a repository
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   teamId: int (required)
  ##         : Id of team.
  ##   owner: string (required)
  ##        : Name of a repository owner.
  var path_756283 = newJObject()
  var header_756284 = newJObject()
  add(header_756284, "Accept", newJString(Accept))
  add(path_756283, "repo", newJString(repo))
  add(path_756283, "teamId", newJInt(teamId))
  add(path_756283, "owner", newJString(owner))
  result = call_756282.call(path_756283, nil, header_756284, nil, nil)

var getTeamsTeamIdReposOwnerRepo* = Call_GetTeamsTeamIdReposOwnerRepo_756274(
    name: "getTeamsTeamIdReposOwnerRepo", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/teams/{teamId}/repos/{owner}/{repo}",
    validator: validate_GetTeamsTeamIdReposOwnerRepo_756275, base: "/",
    makeUrl: url_GetTeamsTeamIdReposOwnerRepo_756276, schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamIdReposOwnerRepo_756296 = ref object of OpenApiRestCall_753573
proc url_DeleteTeamsTeamIdReposOwnerRepo_756298(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamIdReposOwnerRepo_756297(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## In order to remove a repository from a team, the authenticated user must be an owner of the org that the team is associated with. NOTE: This does not delete the repository, it just removes it from the team.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   teamId: JInt (required)
  ##         : Id of team.
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_756299 = path.getOrDefault("repo")
  valid_756299 = validateParameter(valid_756299, JString, required = true,
                                 default = nil)
  if valid_756299 != nil:
    section.add "repo", valid_756299
  var valid_756300 = path.getOrDefault("teamId")
  valid_756300 = validateParameter(valid_756300, JInt, required = true, default = nil)
  if valid_756300 != nil:
    section.add "teamId", valid_756300
  var valid_756301 = path.getOrDefault("owner")
  valid_756301 = validateParameter(valid_756301, JString, required = true,
                                 default = nil)
  if valid_756301 != nil:
    section.add "owner", valid_756301
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756302 = header.getOrDefault("Accept")
  valid_756302 = validateParameter(valid_756302, JString, required = false,
                                 default = nil)
  if valid_756302 != nil:
    section.add "Accept", valid_756302
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756303: Call_DeleteTeamsTeamIdReposOwnerRepo_756296;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## In order to remove a repository from a team, the authenticated user must be an owner of the org that the team is associated with. NOTE: This does not delete the repository, it just removes it from the team.
  ## 
  let valid = call_756303.validator(path, query, header, formData, body, _)
  let scheme = call_756303.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756303.makeUrl(scheme.get, call_756303.host, call_756303.base,
                             call_756303.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756303, uri, valid, _)

proc call*(call_756304: Call_DeleteTeamsTeamIdReposOwnerRepo_756296; repo: string;
          teamId: int; owner: string; Accept: string = ""): Recallable =
  ## deleteTeamsTeamIdReposOwnerRepo
  ## In order to remove a repository from a team, the authenticated user must be an owner of the org that the team is associated with. NOTE: This does not delete the repository, it just removes it from the team.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   teamId: int (required)
  ##         : Id of team.
  ##   owner: string (required)
  ##        : Name of a repository owner.
  var path_756305 = newJObject()
  var header_756306 = newJObject()
  add(header_756306, "Accept", newJString(Accept))
  add(path_756305, "repo", newJString(repo))
  add(path_756305, "teamId", newJInt(teamId))
  add(path_756305, "owner", newJString(owner))
  result = call_756304.call(path_756305, nil, header_756306, nil, nil)

var deleteTeamsTeamIdReposOwnerRepo* = Call_DeleteTeamsTeamIdReposOwnerRepo_756296(
    name: "deleteTeamsTeamIdReposOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/teams/{teamId}/repos/{owner}/{repo}",
    validator: validate_DeleteTeamsTeamIdReposOwnerRepo_756297, base: "/",
    makeUrl: url_DeleteTeamsTeamIdReposOwnerRepo_756298, schemes: {Scheme.Https})
type
  Call_GetUser_756307 = ref object of OpenApiRestCall_753573
proc url_GetUser_756309(protocol: Scheme; host: string; base: string; route: string;
                       path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUser_756308(path: JsonNode; query: JsonNode; header: JsonNode;
                            formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Get the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756310 = header.getOrDefault("Accept")
  valid_756310 = validateParameter(valid_756310, JString, required = false,
                                 default = nil)
  if valid_756310 != nil:
    section.add "Accept", valid_756310
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756311: Call_GetUser_756307; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get the authenticated user.
  ## 
  let valid = call_756311.validator(path, query, header, formData, body, _)
  let scheme = call_756311.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756311.makeUrl(scheme.get, call_756311.host, call_756311.base,
                             call_756311.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756311, uri, valid, _)

proc call*(call_756312: Call_GetUser_756307; Accept: string = ""): Recallable =
  ## getUser
  ## Get the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_756313 = newJObject()
  add(header_756313, "Accept", newJString(Accept))
  result = call_756312.call(nil, nil, header_756313, nil, nil)

var getUser* = Call_GetUser_756307(name: "getUser", meth: HttpMethod.HttpGet,
                                host: "api.github.com", route: "/user",
                                validator: validate_GetUser_756308, base: "/",
                                makeUrl: url_GetUser_756309,
                                schemes: {Scheme.Https})
type
  Call_PatchUser_756314 = ref object of OpenApiRestCall_753573
proc url_PatchUser_756316(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PatchUser_756315(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Update the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756317 = header.getOrDefault("Accept")
  valid_756317 = validateParameter(valid_756317, JString, required = false,
                                 default = nil)
  if valid_756317 != nil:
    section.add "Accept", valid_756317
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_756319: Call_PatchUser_756314; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Update the authenticated user.
  ## 
  let valid = call_756319.validator(path, query, header, formData, body, _)
  let scheme = call_756319.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756319.makeUrl(scheme.get, call_756319.host, call_756319.base,
                             call_756319.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756319, uri, valid, _)

proc call*(call_756320: Call_PatchUser_756314; body: JsonNode; Accept: string = ""): Recallable =
  ## patchUser
  ## Update the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_756321 = newJObject()
  var body_756322 = newJObject()
  add(header_756321, "Accept", newJString(Accept))
  if body != nil:
    body_756322 = body
  result = call_756320.call(nil, nil, header_756321, nil, body_756322)

var patchUser* = Call_PatchUser_756314(name: "patchUser", meth: HttpMethod.HttpPatch,
                                    host: "api.github.com", route: "/user",
                                    validator: validate_PatchUser_756315,
                                    base: "/", makeUrl: url_PatchUser_756316,
                                    schemes: {Scheme.Https})
type
  Call_PostUserEmails_756330 = ref object of OpenApiRestCall_753573
proc url_PostUserEmails_756332(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostUserEmails_756331(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; _: string = ""): JsonNode =
  ## Add email address(es).
  ## You can post a single email address or an array of addresses.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756333 = header.getOrDefault("Accept")
  valid_756333 = validateParameter(valid_756333, JString, required = false,
                                 default = nil)
  if valid_756333 != nil:
    section.add "Accept", valid_756333
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_756335: Call_PostUserEmails_756330; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Add email address(es).
  ## You can post a single email address or an array of addresses.
  ## 
  ## 
  let valid = call_756335.validator(path, query, header, formData, body, _)
  let scheme = call_756335.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756335.makeUrl(scheme.get, call_756335.host, call_756335.base,
                             call_756335.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756335, uri, valid, _)

proc call*(call_756336: Call_PostUserEmails_756330; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postUserEmails
  ## Add email address(es).
  ## You can post a single email address or an array of addresses.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  var header_756337 = newJObject()
  var body_756338 = newJObject()
  add(header_756337, "Accept", newJString(Accept))
  if body != nil:
    body_756338 = body
  result = call_756336.call(nil, nil, header_756337, nil, body_756338)

var postUserEmails* = Call_PostUserEmails_756330(name: "postUserEmails",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/user/emails",
    validator: validate_PostUserEmails_756331, base: "/",
    makeUrl: url_PostUserEmails_756332, schemes: {Scheme.Https})
type
  Call_GetUserEmails_756323 = ref object of OpenApiRestCall_753573
proc url_GetUserEmails_756325(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserEmails_756324(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List email addresses for a user.
  ## In the final version of the API, this method will return an array of hashes
  ## with extended information for each email address indicating if the address
  ## has been verified and if it's primary email address for GitHub.
  ## Until API v3 is finalized, use the application/vnd.github.v3 media type to
  ## get other response format.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756326 = header.getOrDefault("Accept")
  valid_756326 = validateParameter(valid_756326, JString, required = false,
                                 default = nil)
  if valid_756326 != nil:
    section.add "Accept", valid_756326
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756327: Call_GetUserEmails_756323; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List email addresses for a user.
  ## In the final version of the API, this method will return an array of hashes
  ## with extended information for each email address indicating if the address
  ## has been verified and if it's primary email address for GitHub.
  ## Until API v3 is finalized, use the application/vnd.github.v3 media type to
  ## get other response format.
  ## 
  ## 
  let valid = call_756327.validator(path, query, header, formData, body, _)
  let scheme = call_756327.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756327.makeUrl(scheme.get, call_756327.host, call_756327.base,
                             call_756327.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756327, uri, valid, _)

proc call*(call_756328: Call_GetUserEmails_756323; Accept: string = ""): Recallable =
  ## getUserEmails
  ## List email addresses for a user.
  ## In the final version of the API, this method will return an array of hashes
  ## with extended information for each email address indicating if the address
  ## has been verified and if it's primary email address for GitHub.
  ## Until API v3 is finalized, use the application/vnd.github.v3 media type to
  ## get other response format.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_756329 = newJObject()
  add(header_756329, "Accept", newJString(Accept))
  result = call_756328.call(nil, nil, header_756329, nil, nil)

var getUserEmails* = Call_GetUserEmails_756323(name: "getUserEmails",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/emails",
    validator: validate_GetUserEmails_756324, base: "/", makeUrl: url_GetUserEmails_756325,
    schemes: {Scheme.Https})
type
  Call_DeleteUserEmails_756339 = ref object of OpenApiRestCall_753573
proc url_DeleteUserEmails_756341(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DeleteUserEmails_756340(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode =
  ## Delete email address(es).
  ## You can include a single email address or an array of addresses.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756342 = header.getOrDefault("Accept")
  valid_756342 = validateParameter(valid_756342, JString, required = false,
                                 default = nil)
  if valid_756342 != nil:
    section.add "Accept", valid_756342
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_756344: Call_DeleteUserEmails_756339; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete email address(es).
  ## You can include a single email address or an array of addresses.
  ## 
  ## 
  let valid = call_756344.validator(path, query, header, formData, body, _)
  let scheme = call_756344.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756344.makeUrl(scheme.get, call_756344.host, call_756344.base,
                             call_756344.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756344, uri, valid, _)

proc call*(call_756345: Call_DeleteUserEmails_756339; body: JsonNode;
          Accept: string = ""): Recallable =
  ## deleteUserEmails
  ## Delete email address(es).
  ## You can include a single email address or an array of addresses.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  var header_756346 = newJObject()
  var body_756347 = newJObject()
  add(header_756346, "Accept", newJString(Accept))
  if body != nil:
    body_756347 = body
  result = call_756345.call(nil, nil, header_756346, nil, body_756347)

var deleteUserEmails* = Call_DeleteUserEmails_756339(name: "deleteUserEmails",
    meth: HttpMethod.HttpDelete, host: "api.github.com", route: "/user/emails",
    validator: validate_DeleteUserEmails_756340, base: "/",
    makeUrl: url_DeleteUserEmails_756341, schemes: {Scheme.Https})
type
  Call_GetUserFollowers_756348 = ref object of OpenApiRestCall_753573
proc url_GetUserFollowers_756350(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserFollowers_756349(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode =
  ## List the authenticated user's followers
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756351 = header.getOrDefault("Accept")
  valid_756351 = validateParameter(valid_756351, JString, required = false,
                                 default = nil)
  if valid_756351 != nil:
    section.add "Accept", valid_756351
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756352: Call_GetUserFollowers_756348; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List the authenticated user's followers
  ## 
  let valid = call_756352.validator(path, query, header, formData, body, _)
  let scheme = call_756352.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756352.makeUrl(scheme.get, call_756352.host, call_756352.base,
                             call_756352.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756352, uri, valid, _)

proc call*(call_756353: Call_GetUserFollowers_756348; Accept: string = ""): Recallable =
  ## getUserFollowers
  ## List the authenticated user's followers
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_756354 = newJObject()
  add(header_756354, "Accept", newJString(Accept))
  result = call_756353.call(nil, nil, header_756354, nil, nil)

var getUserFollowers* = Call_GetUserFollowers_756348(name: "getUserFollowers",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/followers",
    validator: validate_GetUserFollowers_756349, base: "/",
    makeUrl: url_GetUserFollowers_756350, schemes: {Scheme.Https})
type
  Call_GetUserFollowing_756355 = ref object of OpenApiRestCall_753573
proc url_GetUserFollowing_756357(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserFollowing_756356(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode =
  ## List who the authenticated user is following.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756358 = header.getOrDefault("Accept")
  valid_756358 = validateParameter(valid_756358, JString, required = false,
                                 default = nil)
  if valid_756358 != nil:
    section.add "Accept", valid_756358
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756359: Call_GetUserFollowing_756355; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List who the authenticated user is following.
  ## 
  let valid = call_756359.validator(path, query, header, formData, body, _)
  let scheme = call_756359.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756359.makeUrl(scheme.get, call_756359.host, call_756359.base,
                             call_756359.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756359, uri, valid, _)

proc call*(call_756360: Call_GetUserFollowing_756355; Accept: string = ""): Recallable =
  ## getUserFollowing
  ## List who the authenticated user is following.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_756361 = newJObject()
  add(header_756361, "Accept", newJString(Accept))
  result = call_756360.call(nil, nil, header_756361, nil, nil)

var getUserFollowing* = Call_GetUserFollowing_756355(name: "getUserFollowing",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/following",
    validator: validate_GetUserFollowing_756356, base: "/",
    makeUrl: url_GetUserFollowing_756357, schemes: {Scheme.Https})
type
  Call_PutUserFollowingUsername_756371 = ref object of OpenApiRestCall_753573
proc url_PutUserFollowingUsername_756373(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/following/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutUserFollowingUsername_756372(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Follow a user.
  ## Following a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_756374 = path.getOrDefault("username")
  valid_756374 = validateParameter(valid_756374, JString, required = true,
                                 default = nil)
  if valid_756374 != nil:
    section.add "username", valid_756374
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756375 = header.getOrDefault("Accept")
  valid_756375 = validateParameter(valid_756375, JString, required = false,
                                 default = nil)
  if valid_756375 != nil:
    section.add "Accept", valid_756375
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756376: Call_PutUserFollowingUsername_756371; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Follow a user.
  ## Following a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  let valid = call_756376.validator(path, query, header, formData, body, _)
  let scheme = call_756376.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756376.makeUrl(scheme.get, call_756376.host, call_756376.base,
                             call_756376.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756376, uri, valid, _)

proc call*(call_756377: Call_PutUserFollowingUsername_756371; username: string;
          Accept: string = ""): Recallable =
  ## putUserFollowingUsername
  ## Follow a user.
  ## Following a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_756378 = newJObject()
  var header_756379 = newJObject()
  add(path_756378, "username", newJString(username))
  add(header_756379, "Accept", newJString(Accept))
  result = call_756377.call(path_756378, nil, header_756379, nil, nil)

var putUserFollowingUsername* = Call_PutUserFollowingUsername_756371(
    name: "putUserFollowingUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/user/following/{username}",
    validator: validate_PutUserFollowingUsername_756372, base: "/",
    makeUrl: url_PutUserFollowingUsername_756373, schemes: {Scheme.Https})
type
  Call_GetUserFollowingUsername_756362 = ref object of OpenApiRestCall_753573
proc url_GetUserFollowingUsername_756364(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/following/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserFollowingUsername_756363(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Check if you are following a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_756365 = path.getOrDefault("username")
  valid_756365 = validateParameter(valid_756365, JString, required = true,
                                 default = nil)
  if valid_756365 != nil:
    section.add "username", valid_756365
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756366 = header.getOrDefault("Accept")
  valid_756366 = validateParameter(valid_756366, JString, required = false,
                                 default = nil)
  if valid_756366 != nil:
    section.add "Accept", valid_756366
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756367: Call_GetUserFollowingUsername_756362; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if you are following a user.
  ## 
  let valid = call_756367.validator(path, query, header, formData, body, _)
  let scheme = call_756367.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756367.makeUrl(scheme.get, call_756367.host, call_756367.base,
                             call_756367.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756367, uri, valid, _)

proc call*(call_756368: Call_GetUserFollowingUsername_756362; username: string;
          Accept: string = ""): Recallable =
  ## getUserFollowingUsername
  ## Check if you are following a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_756369 = newJObject()
  var header_756370 = newJObject()
  add(path_756369, "username", newJString(username))
  add(header_756370, "Accept", newJString(Accept))
  result = call_756368.call(path_756369, nil, header_756370, nil, nil)

var getUserFollowingUsername* = Call_GetUserFollowingUsername_756362(
    name: "getUserFollowingUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/user/following/{username}",
    validator: validate_GetUserFollowingUsername_756363, base: "/",
    makeUrl: url_GetUserFollowingUsername_756364, schemes: {Scheme.Https})
type
  Call_DeleteUserFollowingUsername_756380 = ref object of OpenApiRestCall_753573
proc url_DeleteUserFollowingUsername_756382(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/following/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserFollowingUsername_756381(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Unfollow a user.
  ## Unfollowing a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_756383 = path.getOrDefault("username")
  valid_756383 = validateParameter(valid_756383, JString, required = true,
                                 default = nil)
  if valid_756383 != nil:
    section.add "username", valid_756383
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756384 = header.getOrDefault("Accept")
  valid_756384 = validateParameter(valid_756384, JString, required = false,
                                 default = nil)
  if valid_756384 != nil:
    section.add "Accept", valid_756384
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756385: Call_DeleteUserFollowingUsername_756380;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Unfollow a user.
  ## Unfollowing a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  let valid = call_756385.validator(path, query, header, formData, body, _)
  let scheme = call_756385.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756385.makeUrl(scheme.get, call_756385.host, call_756385.base,
                             call_756385.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756385, uri, valid, _)

proc call*(call_756386: Call_DeleteUserFollowingUsername_756380; username: string;
          Accept: string = ""): Recallable =
  ## deleteUserFollowingUsername
  ## Unfollow a user.
  ## Unfollowing a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_756387 = newJObject()
  var header_756388 = newJObject()
  add(path_756387, "username", newJString(username))
  add(header_756388, "Accept", newJString(Accept))
  result = call_756386.call(path_756387, nil, header_756388, nil, nil)

var deleteUserFollowingUsername* = Call_DeleteUserFollowingUsername_756380(
    name: "deleteUserFollowingUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/following/{username}",
    validator: validate_DeleteUserFollowingUsername_756381, base: "/",
    makeUrl: url_DeleteUserFollowingUsername_756382, schemes: {Scheme.Https})
type
  Call_GetUserIssues_756389 = ref object of OpenApiRestCall_753573
proc url_GetUserIssues_756391(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserIssues_756390(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List issues.
  ## List all issues across owned and member repositories for the authenticated
  ## user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString (required)
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  ##   direction: JString (required)
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   state: JString (required)
  section = newJObject()
  var valid_756392 = query.getOrDefault("sort")
  valid_756392 = validateParameter(valid_756392, JString, required = true,
                                 default = newJString("created"))
  if valid_756392 != nil:
    section.add "sort", valid_756392
  var valid_756393 = query.getOrDefault("since")
  valid_756393 = validateParameter(valid_756393, JString, required = false,
                                 default = nil)
  if valid_756393 != nil:
    section.add "since", valid_756393
  var valid_756394 = query.getOrDefault("direction")
  valid_756394 = validateParameter(valid_756394, JString, required = true,
                                 default = newJString("desc"))
  if valid_756394 != nil:
    section.add "direction", valid_756394
  var valid_756395 = query.getOrDefault("labels")
  valid_756395 = validateParameter(valid_756395, JString, required = true,
                                 default = nil)
  if valid_756395 != nil:
    section.add "labels", valid_756395
  var valid_756396 = query.getOrDefault("filter")
  valid_756396 = validateParameter(valid_756396, JString, required = true,
                                 default = newJString("all"))
  if valid_756396 != nil:
    section.add "filter", valid_756396
  var valid_756397 = query.getOrDefault("state")
  valid_756397 = validateParameter(valid_756397, JString, required = true,
                                 default = newJString("open"))
  if valid_756397 != nil:
    section.add "state", valid_756397
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756398 = header.getOrDefault("Accept")
  valid_756398 = validateParameter(valid_756398, JString, required = false,
                                 default = nil)
  if valid_756398 != nil:
    section.add "Accept", valid_756398
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756399: Call_GetUserIssues_756389; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List issues.
  ## List all issues across owned and member repositories for the authenticated
  ## user.
  ## 
  ## 
  let valid = call_756399.validator(path, query, header, formData, body, _)
  let scheme = call_756399.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756399.makeUrl(scheme.get, call_756399.host, call_756399.base,
                             call_756399.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756399, uri, valid, _)

proc call*(call_756400: Call_GetUserIssues_756389; labels: string;
          sort: string = "created"; since: string = ""; direction: string = "desc";
          Accept: string = ""; filter: string = "all"; state: string = "open"): Recallable =
  ## getUserIssues
  ## List issues.
  ## List all issues across owned and member repositories for the authenticated
  ## user.
  ## 
  ##   sort: string (required)
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  ##   direction: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   state: string (required)
  var query_756401 = newJObject()
  var header_756402 = newJObject()
  add(query_756401, "sort", newJString(sort))
  add(query_756401, "since", newJString(since))
  add(query_756401, "direction", newJString(direction))
  add(header_756402, "Accept", newJString(Accept))
  add(query_756401, "labels", newJString(labels))
  add(query_756401, "filter", newJString(filter))
  add(query_756401, "state", newJString(state))
  result = call_756400.call(nil, query_756401, header_756402, nil, nil)

var getUserIssues* = Call_GetUserIssues_756389(name: "getUserIssues",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/issues",
    validator: validate_GetUserIssues_756390, base: "/", makeUrl: url_GetUserIssues_756391,
    schemes: {Scheme.Https})
type
  Call_PostUserKeys_756410 = ref object of OpenApiRestCall_753573
proc url_PostUserKeys_756412(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostUserKeys_756411(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Create a public key.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756413 = header.getOrDefault("Accept")
  valid_756413 = validateParameter(valid_756413, JString, required = false,
                                 default = nil)
  if valid_756413 != nil:
    section.add "Accept", valid_756413
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_756415: Call_PostUserKeys_756410; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a public key.
  ## 
  let valid = call_756415.validator(path, query, header, formData, body, _)
  let scheme = call_756415.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756415.makeUrl(scheme.get, call_756415.host, call_756415.base,
                             call_756415.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756415, uri, valid, _)

proc call*(call_756416: Call_PostUserKeys_756410; body: JsonNode; Accept: string = ""): Recallable =
  ## postUserKeys
  ## Create a public key.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_756417 = newJObject()
  var body_756418 = newJObject()
  add(header_756417, "Accept", newJString(Accept))
  if body != nil:
    body_756418 = body
  result = call_756416.call(nil, nil, header_756417, nil, body_756418)

var postUserKeys* = Call_PostUserKeys_756410(name: "postUserKeys",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/user/keys",
    validator: validate_PostUserKeys_756411, base: "/", makeUrl: url_PostUserKeys_756412,
    schemes: {Scheme.Https})
type
  Call_GetUserKeys_756403 = ref object of OpenApiRestCall_753573
proc url_GetUserKeys_756405(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserKeys_756404(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List your public keys.
  ## Lists the current user's keys. Management of public keys via the API requires
  ## that you are authenticated through basic auth, or OAuth with the 'user', 'write:public_key' scopes.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756406 = header.getOrDefault("Accept")
  valid_756406 = validateParameter(valid_756406, JString, required = false,
                                 default = nil)
  if valid_756406 != nil:
    section.add "Accept", valid_756406
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756407: Call_GetUserKeys_756403; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List your public keys.
  ## Lists the current user's keys. Management of public keys via the API requires
  ## that you are authenticated through basic auth, or OAuth with the 'user', 'write:public_key' scopes.
  ## 
  ## 
  let valid = call_756407.validator(path, query, header, formData, body, _)
  let scheme = call_756407.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756407.makeUrl(scheme.get, call_756407.host, call_756407.base,
                             call_756407.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756407, uri, valid, _)

proc call*(call_756408: Call_GetUserKeys_756403; Accept: string = ""): Recallable =
  ## getUserKeys
  ## List your public keys.
  ## Lists the current user's keys. Management of public keys via the API requires
  ## that you are authenticated through basic auth, or OAuth with the 'user', 'write:public_key' scopes.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_756409 = newJObject()
  add(header_756409, "Accept", newJString(Accept))
  result = call_756408.call(nil, nil, header_756409, nil, nil)

var getUserKeys* = Call_GetUserKeys_756403(name: "getUserKeys",
                                        meth: HttpMethod.HttpGet,
                                        host: "api.github.com",
                                        route: "/user/keys",
                                        validator: validate_GetUserKeys_756404,
                                        base: "/", makeUrl: url_GetUserKeys_756405,
                                        schemes: {Scheme.Https})
type
  Call_GetUserKeysKeyId_756419 = ref object of OpenApiRestCall_753573
proc url_GetUserKeysKeyId_756421(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/keys/"),
               (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserKeysKeyId_756420(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode =
  ## Get a single public key.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyId: JInt (required)
  ##        : ID of key.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyId` field"
  var valid_756422 = path.getOrDefault("keyId")
  valid_756422 = validateParameter(valid_756422, JInt, required = true, default = nil)
  if valid_756422 != nil:
    section.add "keyId", valid_756422
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756423 = header.getOrDefault("Accept")
  valid_756423 = validateParameter(valid_756423, JString, required = false,
                                 default = nil)
  if valid_756423 != nil:
    section.add "Accept", valid_756423
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756424: Call_GetUserKeysKeyId_756419; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single public key.
  ## 
  let valid = call_756424.validator(path, query, header, formData, body, _)
  let scheme = call_756424.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756424.makeUrl(scheme.get, call_756424.host, call_756424.base,
                             call_756424.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756424, uri, valid, _)

proc call*(call_756425: Call_GetUserKeysKeyId_756419; keyId: int; Accept: string = ""): Recallable =
  ## getUserKeysKeyId
  ## Get a single public key.
  ##   keyId: int (required)
  ##        : ID of key.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_756426 = newJObject()
  var header_756427 = newJObject()
  add(path_756426, "keyId", newJInt(keyId))
  add(header_756427, "Accept", newJString(Accept))
  result = call_756425.call(path_756426, nil, header_756427, nil, nil)

var getUserKeysKeyId* = Call_GetUserKeysKeyId_756419(name: "getUserKeysKeyId",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/keys/{keyId}",
    validator: validate_GetUserKeysKeyId_756420, base: "/",
    makeUrl: url_GetUserKeysKeyId_756421, schemes: {Scheme.Https})
type
  Call_DeleteUserKeysKeyId_756428 = ref object of OpenApiRestCall_753573
proc url_DeleteUserKeysKeyId_756430(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/keys/"),
               (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserKeysKeyId_756429(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode; _: string = ""): JsonNode =
  ## Delete a public key. Removes a public key. Requires that you are authenticated via Basic Auth or via OAuth with at least admin:public_key scope.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyId: JInt (required)
  ##        : ID of key.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyId` field"
  var valid_756431 = path.getOrDefault("keyId")
  valid_756431 = validateParameter(valid_756431, JInt, required = true, default = nil)
  if valid_756431 != nil:
    section.add "keyId", valid_756431
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756432 = header.getOrDefault("Accept")
  valid_756432 = validateParameter(valid_756432, JString, required = false,
                                 default = nil)
  if valid_756432 != nil:
    section.add "Accept", valid_756432
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756433: Call_DeleteUserKeysKeyId_756428; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a public key. Removes a public key. Requires that you are authenticated via Basic Auth or via OAuth with at least admin:public_key scope.
  ## 
  let valid = call_756433.validator(path, query, header, formData, body, _)
  let scheme = call_756433.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756433.makeUrl(scheme.get, call_756433.host, call_756433.base,
                             call_756433.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756433, uri, valid, _)

proc call*(call_756434: Call_DeleteUserKeysKeyId_756428; keyId: int;
          Accept: string = ""): Recallable =
  ## deleteUserKeysKeyId
  ## Delete a public key. Removes a public key. Requires that you are authenticated via Basic Auth or via OAuth with at least admin:public_key scope.
  ##   keyId: int (required)
  ##        : ID of key.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_756435 = newJObject()
  var header_756436 = newJObject()
  add(path_756435, "keyId", newJInt(keyId))
  add(header_756436, "Accept", newJString(Accept))
  result = call_756434.call(path_756435, nil, header_756436, nil, nil)

var deleteUserKeysKeyId* = Call_DeleteUserKeysKeyId_756428(
    name: "deleteUserKeysKeyId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/keys/{keyId}",
    validator: validate_DeleteUserKeysKeyId_756429, base: "/",
    makeUrl: url_DeleteUserKeysKeyId_756430, schemes: {Scheme.Https})
type
  Call_GetUserOrgs_756437 = ref object of OpenApiRestCall_753573
proc url_GetUserOrgs_756439(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserOrgs_756438(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List public and private organizations for the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756440 = header.getOrDefault("Accept")
  valid_756440 = validateParameter(valid_756440, JString, required = false,
                                 default = nil)
  if valid_756440 != nil:
    section.add "Accept", valid_756440
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756441: Call_GetUserOrgs_756437; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List public and private organizations for the authenticated user.
  ## 
  let valid = call_756441.validator(path, query, header, formData, body, _)
  let scheme = call_756441.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756441.makeUrl(scheme.get, call_756441.host, call_756441.base,
                             call_756441.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756441, uri, valid, _)

proc call*(call_756442: Call_GetUserOrgs_756437; Accept: string = ""): Recallable =
  ## getUserOrgs
  ## List public and private organizations for the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_756443 = newJObject()
  add(header_756443, "Accept", newJString(Accept))
  result = call_756442.call(nil, nil, header_756443, nil, nil)

var getUserOrgs* = Call_GetUserOrgs_756437(name: "getUserOrgs",
                                        meth: HttpMethod.HttpGet,
                                        host: "api.github.com",
                                        route: "/user/orgs",
                                        validator: validate_GetUserOrgs_756438,
                                        base: "/", makeUrl: url_GetUserOrgs_756439,
                                        schemes: {Scheme.Https})
type
  Call_PostUserRepos_756453 = ref object of OpenApiRestCall_753573
proc url_PostUserRepos_756455(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostUserRepos_756454(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756456 = header.getOrDefault("Accept")
  valid_756456 = validateParameter(valid_756456, JString, required = false,
                                 default = nil)
  if valid_756456 != nil:
    section.add "Accept", valid_756456
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_756458: Call_PostUserRepos_756453; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  let valid = call_756458.validator(path, query, header, formData, body, _)
  let scheme = call_756458.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756458.makeUrl(scheme.get, call_756458.host, call_756458.base,
                             call_756458.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756458, uri, valid, _)

proc call*(call_756459: Call_PostUserRepos_756453; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postUserRepos
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_756460 = newJObject()
  var body_756461 = newJObject()
  add(header_756460, "Accept", newJString(Accept))
  if body != nil:
    body_756461 = body
  result = call_756459.call(nil, nil, header_756460, nil, body_756461)

var postUserRepos* = Call_PostUserRepos_756453(name: "postUserRepos",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/user/repos",
    validator: validate_PostUserRepos_756454, base: "/", makeUrl: url_PostUserRepos_756455,
    schemes: {Scheme.Https})
type
  Call_GetUserRepos_756444 = ref object of OpenApiRestCall_753573
proc url_GetUserRepos_756446(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserRepos_756445(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List repositories for the authenticated user. Note that this does not include
  ## repositories owned by organizations which the user can access. You can lis
  ## user organizations and list organization repositories separately.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   type: JString
  section = newJObject()
  var valid_756447 = query.getOrDefault("type")
  valid_756447 = validateParameter(valid_756447, JString, required = false,
                                 default = newJString("all"))
  if valid_756447 != nil:
    section.add "type", valid_756447
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756448 = header.getOrDefault("Accept")
  valid_756448 = validateParameter(valid_756448, JString, required = false,
                                 default = nil)
  if valid_756448 != nil:
    section.add "Accept", valid_756448
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756449: Call_GetUserRepos_756444; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List repositories for the authenticated user. Note that this does not include
  ## repositories owned by organizations which the user can access. You can lis
  ## user organizations and list organization repositories separately.
  ## 
  ## 
  let valid = call_756449.validator(path, query, header, formData, body, _)
  let scheme = call_756449.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756449.makeUrl(scheme.get, call_756449.host, call_756449.base,
                             call_756449.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756449, uri, valid, _)

proc call*(call_756450: Call_GetUserRepos_756444; `type`: string = "all";
          Accept: string = ""): Recallable =
  ## getUserRepos
  ## List repositories for the authenticated user. Note that this does not include
  ## repositories owned by organizations which the user can access. You can lis
  ## user organizations and list organization repositories separately.
  ## 
  ##   type: string
  ##   Accept: string
  ##         : Is used to set specified media type.
  var query_756451 = newJObject()
  var header_756452 = newJObject()
  add(query_756451, "type", newJString(`type`))
  add(header_756452, "Accept", newJString(Accept))
  result = call_756450.call(nil, query_756451, header_756452, nil, nil)

var getUserRepos* = Call_GetUserRepos_756444(name: "getUserRepos",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/repos",
    validator: validate_GetUserRepos_756445, base: "/", makeUrl: url_GetUserRepos_756446,
    schemes: {Scheme.Https})
type
  Call_GetUserStarred_756462 = ref object of OpenApiRestCall_753573
proc url_GetUserStarred_756464(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserStarred_756463(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; _: string = ""): JsonNode =
  ## List repositories being starred by the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  section = newJObject()
  var valid_756465 = query.getOrDefault("sort")
  valid_756465 = validateParameter(valid_756465, JString, required = false,
                                 default = newJString("created"))
  if valid_756465 != nil:
    section.add "sort", valid_756465
  var valid_756466 = query.getOrDefault("direction")
  valid_756466 = validateParameter(valid_756466, JString, required = false,
                                 default = nil)
  if valid_756466 != nil:
    section.add "direction", valid_756466
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756467 = header.getOrDefault("Accept")
  valid_756467 = validateParameter(valid_756467, JString, required = false,
                                 default = nil)
  if valid_756467 != nil:
    section.add "Accept", valid_756467
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756468: Call_GetUserStarred_756462; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List repositories being starred by the authenticated user.
  ## 
  let valid = call_756468.validator(path, query, header, formData, body, _)
  let scheme = call_756468.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756468.makeUrl(scheme.get, call_756468.host, call_756468.base,
                             call_756468.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756468, uri, valid, _)

proc call*(call_756469: Call_GetUserStarred_756462; sort: string = "created";
          direction: string = ""; Accept: string = ""): Recallable =
  ## getUserStarred
  ## List repositories being starred by the authenticated user.
  ##   sort: string
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var query_756470 = newJObject()
  var header_756471 = newJObject()
  add(query_756470, "sort", newJString(sort))
  add(query_756470, "direction", newJString(direction))
  add(header_756471, "Accept", newJString(Accept))
  result = call_756469.call(nil, query_756470, header_756471, nil, nil)

var getUserStarred* = Call_GetUserStarred_756462(name: "getUserStarred",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/starred",
    validator: validate_GetUserStarred_756463, base: "/",
    makeUrl: url_GetUserStarred_756464, schemes: {Scheme.Https})
type
  Call_PutUserStarredOwnerRepo_756482 = ref object of OpenApiRestCall_753573
proc url_PutUserStarredOwnerRepo_756484(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/starred/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutUserStarredOwnerRepo_756483(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Star a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_756485 = path.getOrDefault("repo")
  valid_756485 = validateParameter(valid_756485, JString, required = true,
                                 default = nil)
  if valid_756485 != nil:
    section.add "repo", valid_756485
  var valid_756486 = path.getOrDefault("owner")
  valid_756486 = validateParameter(valid_756486, JString, required = true,
                                 default = nil)
  if valid_756486 != nil:
    section.add "owner", valid_756486
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756487 = header.getOrDefault("Accept")
  valid_756487 = validateParameter(valid_756487, JString, required = false,
                                 default = nil)
  if valid_756487 != nil:
    section.add "Accept", valid_756487
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756488: Call_PutUserStarredOwnerRepo_756482; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Star a repository.
  ## 
  let valid = call_756488.validator(path, query, header, formData, body, _)
  let scheme = call_756488.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756488.makeUrl(scheme.get, call_756488.host, call_756488.base,
                             call_756488.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756488, uri, valid, _)

proc call*(call_756489: Call_PutUserStarredOwnerRepo_756482; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## putUserStarredOwnerRepo
  ## Star a repository.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   owner: string (required)
  ##        : Name of a repository owner.
  var path_756490 = newJObject()
  var header_756491 = newJObject()
  add(header_756491, "Accept", newJString(Accept))
  add(path_756490, "repo", newJString(repo))
  add(path_756490, "owner", newJString(owner))
  result = call_756489.call(path_756490, nil, header_756491, nil, nil)

var putUserStarredOwnerRepo* = Call_PutUserStarredOwnerRepo_756482(
    name: "putUserStarredOwnerRepo", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/user/starred/{owner}/{repo}",
    validator: validate_PutUserStarredOwnerRepo_756483, base: "/",
    makeUrl: url_PutUserStarredOwnerRepo_756484, schemes: {Scheme.Https})
type
  Call_GetUserStarredOwnerRepo_756472 = ref object of OpenApiRestCall_753573
proc url_GetUserStarredOwnerRepo_756474(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/starred/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserStarredOwnerRepo_756473(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Check if you are starring a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_756475 = path.getOrDefault("repo")
  valid_756475 = validateParameter(valid_756475, JString, required = true,
                                 default = nil)
  if valid_756475 != nil:
    section.add "repo", valid_756475
  var valid_756476 = path.getOrDefault("owner")
  valid_756476 = validateParameter(valid_756476, JString, required = true,
                                 default = nil)
  if valid_756476 != nil:
    section.add "owner", valid_756476
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756477 = header.getOrDefault("Accept")
  valid_756477 = validateParameter(valid_756477, JString, required = false,
                                 default = nil)
  if valid_756477 != nil:
    section.add "Accept", valid_756477
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756478: Call_GetUserStarredOwnerRepo_756472; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if you are starring a repository.
  ## 
  let valid = call_756478.validator(path, query, header, formData, body, _)
  let scheme = call_756478.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756478.makeUrl(scheme.get, call_756478.host, call_756478.base,
                             call_756478.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756478, uri, valid, _)

proc call*(call_756479: Call_GetUserStarredOwnerRepo_756472; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getUserStarredOwnerRepo
  ## Check if you are starring a repository.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   owner: string (required)
  ##        : Name of a repository owner.
  var path_756480 = newJObject()
  var header_756481 = newJObject()
  add(header_756481, "Accept", newJString(Accept))
  add(path_756480, "repo", newJString(repo))
  add(path_756480, "owner", newJString(owner))
  result = call_756479.call(path_756480, nil, header_756481, nil, nil)

var getUserStarredOwnerRepo* = Call_GetUserStarredOwnerRepo_756472(
    name: "getUserStarredOwnerRepo", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/user/starred/{owner}/{repo}",
    validator: validate_GetUserStarredOwnerRepo_756473, base: "/",
    makeUrl: url_GetUserStarredOwnerRepo_756474, schemes: {Scheme.Https})
type
  Call_DeleteUserStarredOwnerRepo_756492 = ref object of OpenApiRestCall_753573
proc url_DeleteUserStarredOwnerRepo_756494(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/starred/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserStarredOwnerRepo_756493(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Unstar a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_756495 = path.getOrDefault("repo")
  valid_756495 = validateParameter(valid_756495, JString, required = true,
                                 default = nil)
  if valid_756495 != nil:
    section.add "repo", valid_756495
  var valid_756496 = path.getOrDefault("owner")
  valid_756496 = validateParameter(valid_756496, JString, required = true,
                                 default = nil)
  if valid_756496 != nil:
    section.add "owner", valid_756496
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756497 = header.getOrDefault("Accept")
  valid_756497 = validateParameter(valid_756497, JString, required = false,
                                 default = nil)
  if valid_756497 != nil:
    section.add "Accept", valid_756497
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756498: Call_DeleteUserStarredOwnerRepo_756492;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Unstar a repository
  ## 
  let valid = call_756498.validator(path, query, header, formData, body, _)
  let scheme = call_756498.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756498.makeUrl(scheme.get, call_756498.host, call_756498.base,
                             call_756498.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756498, uri, valid, _)

proc call*(call_756499: Call_DeleteUserStarredOwnerRepo_756492; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## deleteUserStarredOwnerRepo
  ## Unstar a repository
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   owner: string (required)
  ##        : Name of a repository owner.
  var path_756500 = newJObject()
  var header_756501 = newJObject()
  add(header_756501, "Accept", newJString(Accept))
  add(path_756500, "repo", newJString(repo))
  add(path_756500, "owner", newJString(owner))
  result = call_756499.call(path_756500, nil, header_756501, nil, nil)

var deleteUserStarredOwnerRepo* = Call_DeleteUserStarredOwnerRepo_756492(
    name: "deleteUserStarredOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/starred/{owner}/{repo}",
    validator: validate_DeleteUserStarredOwnerRepo_756493, base: "/",
    makeUrl: url_DeleteUserStarredOwnerRepo_756494, schemes: {Scheme.Https})
type
  Call_GetUserSubscriptions_756502 = ref object of OpenApiRestCall_753573
proc url_GetUserSubscriptions_756504(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserSubscriptions_756503(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List repositories being watched by the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756505 = header.getOrDefault("Accept")
  valid_756505 = validateParameter(valid_756505, JString, required = false,
                                 default = nil)
  if valid_756505 != nil:
    section.add "Accept", valid_756505
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756506: Call_GetUserSubscriptions_756502; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List repositories being watched by the authenticated user.
  ## 
  let valid = call_756506.validator(path, query, header, formData, body, _)
  let scheme = call_756506.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756506.makeUrl(scheme.get, call_756506.host, call_756506.base,
                             call_756506.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756506, uri, valid, _)

proc call*(call_756507: Call_GetUserSubscriptions_756502; Accept: string = ""): Recallable =
  ## getUserSubscriptions
  ## List repositories being watched by the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_756508 = newJObject()
  add(header_756508, "Accept", newJString(Accept))
  result = call_756507.call(nil, nil, header_756508, nil, nil)

var getUserSubscriptions* = Call_GetUserSubscriptions_756502(
    name: "getUserSubscriptions", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/user/subscriptions", validator: validate_GetUserSubscriptions_756503,
    base: "/", makeUrl: url_GetUserSubscriptions_756504, schemes: {Scheme.Https})
type
  Call_PutUserSubscriptionsOwnerRepo_756519 = ref object of OpenApiRestCall_753573
proc url_PutUserSubscriptionsOwnerRepo_756521(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/subscriptions/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutUserSubscriptionsOwnerRepo_756520(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Watch a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of the owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_756522 = path.getOrDefault("repo")
  valid_756522 = validateParameter(valid_756522, JString, required = true,
                                 default = nil)
  if valid_756522 != nil:
    section.add "repo", valid_756522
  var valid_756523 = path.getOrDefault("owner")
  valid_756523 = validateParameter(valid_756523, JString, required = true,
                                 default = nil)
  if valid_756523 != nil:
    section.add "owner", valid_756523
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756524 = header.getOrDefault("Accept")
  valid_756524 = validateParameter(valid_756524, JString, required = false,
                                 default = nil)
  if valid_756524 != nil:
    section.add "Accept", valid_756524
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756525: Call_PutUserSubscriptionsOwnerRepo_756519;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Watch a repository.
  ## 
  let valid = call_756525.validator(path, query, header, formData, body, _)
  let scheme = call_756525.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756525.makeUrl(scheme.get, call_756525.host, call_756525.base,
                             call_756525.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756525, uri, valid, _)

proc call*(call_756526: Call_PutUserSubscriptionsOwnerRepo_756519; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## putUserSubscriptionsOwnerRepo
  ## Watch a repository.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of the owner.
  var path_756527 = newJObject()
  var header_756528 = newJObject()
  add(header_756528, "Accept", newJString(Accept))
  add(path_756527, "repo", newJString(repo))
  add(path_756527, "owner", newJString(owner))
  result = call_756526.call(path_756527, nil, header_756528, nil, nil)

var putUserSubscriptionsOwnerRepo* = Call_PutUserSubscriptionsOwnerRepo_756519(
    name: "putUserSubscriptionsOwnerRepo", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/user/subscriptions/{owner}/{repo}",
    validator: validate_PutUserSubscriptionsOwnerRepo_756520, base: "/",
    makeUrl: url_PutUserSubscriptionsOwnerRepo_756521, schemes: {Scheme.Https})
type
  Call_GetUserSubscriptionsOwnerRepo_756509 = ref object of OpenApiRestCall_753573
proc url_GetUserSubscriptionsOwnerRepo_756511(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/subscriptions/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserSubscriptionsOwnerRepo_756510(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Check if you are watching a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of the owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_756512 = path.getOrDefault("repo")
  valid_756512 = validateParameter(valid_756512, JString, required = true,
                                 default = nil)
  if valid_756512 != nil:
    section.add "repo", valid_756512
  var valid_756513 = path.getOrDefault("owner")
  valid_756513 = validateParameter(valid_756513, JString, required = true,
                                 default = nil)
  if valid_756513 != nil:
    section.add "owner", valid_756513
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756514 = header.getOrDefault("Accept")
  valid_756514 = validateParameter(valid_756514, JString, required = false,
                                 default = nil)
  if valid_756514 != nil:
    section.add "Accept", valid_756514
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756515: Call_GetUserSubscriptionsOwnerRepo_756509;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if you are watching a repository.
  ## 
  let valid = call_756515.validator(path, query, header, formData, body, _)
  let scheme = call_756515.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756515.makeUrl(scheme.get, call_756515.host, call_756515.base,
                             call_756515.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756515, uri, valid, _)

proc call*(call_756516: Call_GetUserSubscriptionsOwnerRepo_756509; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## getUserSubscriptionsOwnerRepo
  ## Check if you are watching a repository.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of the owner.
  var path_756517 = newJObject()
  var header_756518 = newJObject()
  add(header_756518, "Accept", newJString(Accept))
  add(path_756517, "repo", newJString(repo))
  add(path_756517, "owner", newJString(owner))
  result = call_756516.call(path_756517, nil, header_756518, nil, nil)

var getUserSubscriptionsOwnerRepo* = Call_GetUserSubscriptionsOwnerRepo_756509(
    name: "getUserSubscriptionsOwnerRepo", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/user/subscriptions/{owner}/{repo}",
    validator: validate_GetUserSubscriptionsOwnerRepo_756510, base: "/",
    makeUrl: url_GetUserSubscriptionsOwnerRepo_756511, schemes: {Scheme.Https})
type
  Call_DeleteUserSubscriptionsOwnerRepo_756529 = ref object of OpenApiRestCall_753573
proc url_DeleteUserSubscriptionsOwnerRepo_756531(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/subscriptions/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserSubscriptionsOwnerRepo_756530(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Stop watching a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   owner: JString (required)
  ##        : Name of the owner.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `repo` field"
  var valid_756532 = path.getOrDefault("repo")
  valid_756532 = validateParameter(valid_756532, JString, required = true,
                                 default = nil)
  if valid_756532 != nil:
    section.add "repo", valid_756532
  var valid_756533 = path.getOrDefault("owner")
  valid_756533 = validateParameter(valid_756533, JString, required = true,
                                 default = nil)
  if valid_756533 != nil:
    section.add "owner", valid_756533
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756534 = header.getOrDefault("Accept")
  valid_756534 = validateParameter(valid_756534, JString, required = false,
                                 default = nil)
  if valid_756534 != nil:
    section.add "Accept", valid_756534
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756535: Call_DeleteUserSubscriptionsOwnerRepo_756529;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Stop watching a repository
  ## 
  let valid = call_756535.validator(path, query, header, formData, body, _)
  let scheme = call_756535.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756535.makeUrl(scheme.get, call_756535.host, call_756535.base,
                             call_756535.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756535, uri, valid, _)

proc call*(call_756536: Call_DeleteUserSubscriptionsOwnerRepo_756529; repo: string;
          owner: string; Accept: string = ""): Recallable =
  ## deleteUserSubscriptionsOwnerRepo
  ## Stop watching a repository
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   owner: string (required)
  ##        : Name of the owner.
  var path_756537 = newJObject()
  var header_756538 = newJObject()
  add(header_756538, "Accept", newJString(Accept))
  add(path_756537, "repo", newJString(repo))
  add(path_756537, "owner", newJString(owner))
  result = call_756536.call(path_756537, nil, header_756538, nil, nil)

var deleteUserSubscriptionsOwnerRepo* = Call_DeleteUserSubscriptionsOwnerRepo_756529(
    name: "deleteUserSubscriptionsOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/subscriptions/{owner}/{repo}",
    validator: validate_DeleteUserSubscriptionsOwnerRepo_756530, base: "/",
    makeUrl: url_DeleteUserSubscriptionsOwnerRepo_756531, schemes: {Scheme.Https})
type
  Call_GetUserTeams_756539 = ref object of OpenApiRestCall_753573
proc url_GetUserTeams_756541(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserTeams_756540(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List all of the teams across all of the organizations to which the authenticated user belongs. This method requires user or repo scope when authenticating via OAuth.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756542 = header.getOrDefault("Accept")
  valid_756542 = validateParameter(valid_756542, JString, required = false,
                                 default = nil)
  if valid_756542 != nil:
    section.add "Accept", valid_756542
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756543: Call_GetUserTeams_756539; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List all of the teams across all of the organizations to which the authenticated user belongs. This method requires user or repo scope when authenticating via OAuth.
  ## 
  let valid = call_756543.validator(path, query, header, formData, body, _)
  let scheme = call_756543.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756543.makeUrl(scheme.get, call_756543.host, call_756543.base,
                             call_756543.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756543, uri, valid, _)

proc call*(call_756544: Call_GetUserTeams_756539; Accept: string = ""): Recallable =
  ## getUserTeams
  ## List all of the teams across all of the organizations to which the authenticated user belongs. This method requires user or repo scope when authenticating via OAuth.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_756545 = newJObject()
  add(header_756545, "Accept", newJString(Accept))
  result = call_756544.call(nil, nil, header_756545, nil, nil)

var getUserTeams* = Call_GetUserTeams_756539(name: "getUserTeams",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/teams",
    validator: validate_GetUserTeams_756540, base: "/", makeUrl: url_GetUserTeams_756541,
    schemes: {Scheme.Https})
type
  Call_GetUsers_756546 = ref object of OpenApiRestCall_753573
proc url_GetUsers_756548(protocol: Scheme; host: string; base: string; route: string;
                        path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUsers_756547(path: JsonNode; query: JsonNode; header: JsonNode;
                             formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Get all users.
  ## This provides a dump of every user, in the order that they signed up for GitHub.
  ## Note: Pagination is powered exclusively by the since parameter. Use the Link
  ## header to get the URL for the next page of users.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JInt
  ##        : The integer ID of the last user that you've seen.
  section = newJObject()
  var valid_756549 = query.getOrDefault("since")
  valid_756549 = validateParameter(valid_756549, JInt, required = false, default = nil)
  if valid_756549 != nil:
    section.add "since", valid_756549
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756550 = header.getOrDefault("Accept")
  valid_756550 = validateParameter(valid_756550, JString, required = false,
                                 default = nil)
  if valid_756550 != nil:
    section.add "Accept", valid_756550
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756551: Call_GetUsers_756546; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get all users.
  ## This provides a dump of every user, in the order that they signed up for GitHub.
  ## Note: Pagination is powered exclusively by the since parameter. Use the Link
  ## header to get the URL for the next page of users.
  ## 
  ## 
  let valid = call_756551.validator(path, query, header, formData, body, _)
  let scheme = call_756551.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756551.makeUrl(scheme.get, call_756551.host, call_756551.base,
                             call_756551.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756551, uri, valid, _)

proc call*(call_756552: Call_GetUsers_756546; since: int = 0; Accept: string = ""): Recallable =
  ## getUsers
  ## Get all users.
  ## This provides a dump of every user, in the order that they signed up for GitHub.
  ## Note: Pagination is powered exclusively by the since parameter. Use the Link
  ## header to get the URL for the next page of users.
  ## 
  ##   since: int
  ##        : The integer ID of the last user that you've seen.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var query_756553 = newJObject()
  var header_756554 = newJObject()
  add(query_756553, "since", newJInt(since))
  add(header_756554, "Accept", newJString(Accept))
  result = call_756552.call(nil, query_756553, header_756554, nil, nil)

var getUsers* = Call_GetUsers_756546(name: "getUsers", meth: HttpMethod.HttpGet,
                                  host: "api.github.com", route: "/users",
                                  validator: validate_GetUsers_756547, base: "/",
                                  makeUrl: url_GetUsers_756548,
                                  schemes: {Scheme.Https})
type
  Call_GetUsersUsername_756555 = ref object of OpenApiRestCall_753573
proc url_GetUsersUsername_756557(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsername_756556(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode =
  ## Get a single user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_756558 = path.getOrDefault("username")
  valid_756558 = validateParameter(valid_756558, JString, required = true,
                                 default = nil)
  if valid_756558 != nil:
    section.add "username", valid_756558
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756559 = header.getOrDefault("Accept")
  valid_756559 = validateParameter(valid_756559, JString, required = false,
                                 default = nil)
  if valid_756559 != nil:
    section.add "Accept", valid_756559
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756560: Call_GetUsersUsername_756555; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single user.
  ## 
  let valid = call_756560.validator(path, query, header, formData, body, _)
  let scheme = call_756560.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756560.makeUrl(scheme.get, call_756560.host, call_756560.base,
                             call_756560.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756560, uri, valid, _)

proc call*(call_756561: Call_GetUsersUsername_756555; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsername
  ## Get a single user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_756562 = newJObject()
  var header_756563 = newJObject()
  add(path_756562, "username", newJString(username))
  add(header_756563, "Accept", newJString(Accept))
  result = call_756561.call(path_756562, nil, header_756563, nil, nil)

var getUsersUsername* = Call_GetUsersUsername_756555(name: "getUsersUsername",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/users/{username}",
    validator: validate_GetUsersUsername_756556, base: "/",
    makeUrl: url_GetUsersUsername_756557, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameEvents_756564 = ref object of OpenApiRestCall_753573
proc url_GetUsersUsernameEvents_756566(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameEvents_756565(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_756567 = path.getOrDefault("username")
  valid_756567 = validateParameter(valid_756567, JString, required = true,
                                 default = nil)
  if valid_756567 != nil:
    section.add "username", valid_756567
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756568 = header.getOrDefault("Accept")
  valid_756568 = validateParameter(valid_756568, JString, required = false,
                                 default = nil)
  if valid_756568 != nil:
    section.add "Accept", valid_756568
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756569: Call_GetUsersUsernameEvents_756564; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
  ## 
  let valid = call_756569.validator(path, query, header, formData, body, _)
  let scheme = call_756569.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756569.makeUrl(scheme.get, call_756569.host, call_756569.base,
                             call_756569.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756569, uri, valid, _)

proc call*(call_756570: Call_GetUsersUsernameEvents_756564; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameEvents
  ## If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_756571 = newJObject()
  var header_756572 = newJObject()
  add(path_756571, "username", newJString(username))
  add(header_756572, "Accept", newJString(Accept))
  result = call_756570.call(path_756571, nil, header_756572, nil, nil)

var getUsersUsernameEvents* = Call_GetUsersUsernameEvents_756564(
    name: "getUsersUsernameEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/events",
    validator: validate_GetUsersUsernameEvents_756565, base: "/",
    makeUrl: url_GetUsersUsernameEvents_756566, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameEventsOrgsOrg_756573 = ref object of OpenApiRestCall_753573
proc url_GetUsersUsernameEventsOrgsOrg_756575(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/events/orgs/"),
               (kind: VariableSegment, value: "org")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameEventsOrgsOrg_756574(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## This is the user's organization dashboard. You must be authenticated as the user to view this.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  ##   org: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_756576 = path.getOrDefault("username")
  valid_756576 = validateParameter(valid_756576, JString, required = true,
                                 default = nil)
  if valid_756576 != nil:
    section.add "username", valid_756576
  var valid_756577 = path.getOrDefault("org")
  valid_756577 = validateParameter(valid_756577, JString, required = true,
                                 default = nil)
  if valid_756577 != nil:
    section.add "org", valid_756577
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756578 = header.getOrDefault("Accept")
  valid_756578 = validateParameter(valid_756578, JString, required = false,
                                 default = nil)
  if valid_756578 != nil:
    section.add "Accept", valid_756578
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756579: Call_GetUsersUsernameEventsOrgsOrg_756573;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## This is the user's organization dashboard. You must be authenticated as the user to view this.
  ## 
  let valid = call_756579.validator(path, query, header, formData, body, _)
  let scheme = call_756579.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756579.makeUrl(scheme.get, call_756579.host, call_756579.base,
                             call_756579.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756579, uri, valid, _)

proc call*(call_756580: Call_GetUsersUsernameEventsOrgsOrg_756573;
          username: string; org: string; Accept: string = ""): Recallable =
  ## getUsersUsernameEventsOrgsOrg
  ## This is the user's organization dashboard. You must be authenticated as the user to view this.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  var path_756581 = newJObject()
  var header_756582 = newJObject()
  add(path_756581, "username", newJString(username))
  add(header_756582, "Accept", newJString(Accept))
  add(path_756581, "org", newJString(org))
  result = call_756580.call(path_756581, nil, header_756582, nil, nil)

var getUsersUsernameEventsOrgsOrg* = Call_GetUsersUsernameEventsOrgsOrg_756573(
    name: "getUsersUsernameEventsOrgsOrg", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/events/orgs/{org}",
    validator: validate_GetUsersUsernameEventsOrgsOrg_756574, base: "/",
    makeUrl: url_GetUsersUsernameEventsOrgsOrg_756575, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameFollowers_756583 = ref object of OpenApiRestCall_753573
proc url_GetUsersUsernameFollowers_756585(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/followers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameFollowers_756584(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List a user's followers
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_756586 = path.getOrDefault("username")
  valid_756586 = validateParameter(valid_756586, JString, required = true,
                                 default = nil)
  if valid_756586 != nil:
    section.add "username", valid_756586
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756587 = header.getOrDefault("Accept")
  valid_756587 = validateParameter(valid_756587, JString, required = false,
                                 default = nil)
  if valid_756587 != nil:
    section.add "Accept", valid_756587
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756588: Call_GetUsersUsernameFollowers_756583;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List a user's followers
  ## 
  let valid = call_756588.validator(path, query, header, formData, body, _)
  let scheme = call_756588.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756588.makeUrl(scheme.get, call_756588.host, call_756588.base,
                             call_756588.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756588, uri, valid, _)

proc call*(call_756589: Call_GetUsersUsernameFollowers_756583; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameFollowers
  ## List a user's followers
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_756590 = newJObject()
  var header_756591 = newJObject()
  add(path_756590, "username", newJString(username))
  add(header_756591, "Accept", newJString(Accept))
  result = call_756589.call(path_756590, nil, header_756591, nil, nil)

var getUsersUsernameFollowers* = Call_GetUsersUsernameFollowers_756583(
    name: "getUsersUsernameFollowers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/followers",
    validator: validate_GetUsersUsernameFollowers_756584, base: "/",
    makeUrl: url_GetUsersUsernameFollowers_756585, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameFollowingTargetUser_756592 = ref object of OpenApiRestCall_753573
proc url_GetUsersUsernameFollowingTargetUser_756594(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  assert "targetUser" in path, "`targetUser` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/following/"),
               (kind: VariableSegment, value: "targetUser")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameFollowingTargetUser_756593(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Check if one user follows another.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  ##   targetUser: JString (required)
  ##             : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_756595 = path.getOrDefault("username")
  valid_756595 = validateParameter(valid_756595, JString, required = true,
                                 default = nil)
  if valid_756595 != nil:
    section.add "username", valid_756595
  var valid_756596 = path.getOrDefault("targetUser")
  valid_756596 = validateParameter(valid_756596, JString, required = true,
                                 default = nil)
  if valid_756596 != nil:
    section.add "targetUser", valid_756596
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756597 = header.getOrDefault("Accept")
  valid_756597 = validateParameter(valid_756597, JString, required = false,
                                 default = nil)
  if valid_756597 != nil:
    section.add "Accept", valid_756597
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756598: Call_GetUsersUsernameFollowingTargetUser_756592;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if one user follows another.
  ## 
  let valid = call_756598.validator(path, query, header, formData, body, _)
  let scheme = call_756598.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756598.makeUrl(scheme.get, call_756598.host, call_756598.base,
                             call_756598.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756598, uri, valid, _)

proc call*(call_756599: Call_GetUsersUsernameFollowingTargetUser_756592;
          username: string; targetUser: string; Accept: string = ""): Recallable =
  ## getUsersUsernameFollowingTargetUser
  ## Check if one user follows another.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   targetUser: string (required)
  ##             : Name of user.
  var path_756600 = newJObject()
  var header_756601 = newJObject()
  add(path_756600, "username", newJString(username))
  add(header_756601, "Accept", newJString(Accept))
  add(path_756600, "targetUser", newJString(targetUser))
  result = call_756599.call(path_756600, nil, header_756601, nil, nil)

var getUsersUsernameFollowingTargetUser* = Call_GetUsersUsernameFollowingTargetUser_756592(
    name: "getUsersUsernameFollowingTargetUser", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/following/{targetUser}",
    validator: validate_GetUsersUsernameFollowingTargetUser_756593, base: "/",
    makeUrl: url_GetUsersUsernameFollowingTargetUser_756594,
    schemes: {Scheme.Https})
type
  Call_GetUsersUsernameGists_756602 = ref object of OpenApiRestCall_753573
proc url_GetUsersUsernameGists_756604(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/gists")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameGists_756603(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List a users gists.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_756605 = path.getOrDefault("username")
  valid_756605 = validateParameter(valid_756605, JString, required = true,
                                 default = nil)
  if valid_756605 != nil:
    section.add "username", valid_756605
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_756606 = query.getOrDefault("since")
  valid_756606 = validateParameter(valid_756606, JString, required = false,
                                 default = nil)
  if valid_756606 != nil:
    section.add "since", valid_756606
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756607 = header.getOrDefault("Accept")
  valid_756607 = validateParameter(valid_756607, JString, required = false,
                                 default = nil)
  if valid_756607 != nil:
    section.add "Accept", valid_756607
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756608: Call_GetUsersUsernameGists_756602; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List a users gists.
  ## 
  let valid = call_756608.validator(path, query, header, formData, body, _)
  let scheme = call_756608.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756608.makeUrl(scheme.get, call_756608.host, call_756608.base,
                             call_756608.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756608, uri, valid, _)

proc call*(call_756609: Call_GetUsersUsernameGists_756602; username: string;
          since: string = ""; Accept: string = ""): Recallable =
  ## getUsersUsernameGists
  ## List a users gists.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_756610 = newJObject()
  var query_756611 = newJObject()
  var header_756612 = newJObject()
  add(query_756611, "since", newJString(since))
  add(path_756610, "username", newJString(username))
  add(header_756612, "Accept", newJString(Accept))
  result = call_756609.call(path_756610, query_756611, header_756612, nil, nil)

var getUsersUsernameGists* = Call_GetUsersUsernameGists_756602(
    name: "getUsersUsernameGists", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/users/{username}/gists", validator: validate_GetUsersUsernameGists_756603,
    base: "/", makeUrl: url_GetUsersUsernameGists_756604, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameKeys_756613 = ref object of OpenApiRestCall_753573
proc url_GetUsersUsernameKeys_756615(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/keys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameKeys_756614(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List public keys for a user.
  ## Lists the verified public keys for a user. This is accessible by anyone.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_756616 = path.getOrDefault("username")
  valid_756616 = validateParameter(valid_756616, JString, required = true,
                                 default = nil)
  if valid_756616 != nil:
    section.add "username", valid_756616
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756617 = header.getOrDefault("Accept")
  valid_756617 = validateParameter(valid_756617, JString, required = false,
                                 default = nil)
  if valid_756617 != nil:
    section.add "Accept", valid_756617
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756618: Call_GetUsersUsernameKeys_756613; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List public keys for a user.
  ## Lists the verified public keys for a user. This is accessible by anyone.
  ## 
  ## 
  let valid = call_756618.validator(path, query, header, formData, body, _)
  let scheme = call_756618.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756618.makeUrl(scheme.get, call_756618.host, call_756618.base,
                             call_756618.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756618, uri, valid, _)

proc call*(call_756619: Call_GetUsersUsernameKeys_756613; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameKeys
  ## List public keys for a user.
  ## Lists the verified public keys for a user. This is accessible by anyone.
  ## 
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_756620 = newJObject()
  var header_756621 = newJObject()
  add(path_756620, "username", newJString(username))
  add(header_756621, "Accept", newJString(Accept))
  result = call_756619.call(path_756620, nil, header_756621, nil, nil)

var getUsersUsernameKeys* = Call_GetUsersUsernameKeys_756613(
    name: "getUsersUsernameKeys", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/users/{username}/keys", validator: validate_GetUsersUsernameKeys_756614,
    base: "/", makeUrl: url_GetUsersUsernameKeys_756615, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameOrgs_756622 = ref object of OpenApiRestCall_753573
proc url_GetUsersUsernameOrgs_756624(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/orgs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameOrgs_756623(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List all public organizations for a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_756625 = path.getOrDefault("username")
  valid_756625 = validateParameter(valid_756625, JString, required = true,
                                 default = nil)
  if valid_756625 != nil:
    section.add "username", valid_756625
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756626 = header.getOrDefault("Accept")
  valid_756626 = validateParameter(valid_756626, JString, required = false,
                                 default = nil)
  if valid_756626 != nil:
    section.add "Accept", valid_756626
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756627: Call_GetUsersUsernameOrgs_756622; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List all public organizations for a user.
  ## 
  let valid = call_756627.validator(path, query, header, formData, body, _)
  let scheme = call_756627.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756627.makeUrl(scheme.get, call_756627.host, call_756627.base,
                             call_756627.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756627, uri, valid, _)

proc call*(call_756628: Call_GetUsersUsernameOrgs_756622; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameOrgs
  ## List all public organizations for a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_756629 = newJObject()
  var header_756630 = newJObject()
  add(path_756629, "username", newJString(username))
  add(header_756630, "Accept", newJString(Accept))
  result = call_756628.call(path_756629, nil, header_756630, nil, nil)

var getUsersUsernameOrgs* = Call_GetUsersUsernameOrgs_756622(
    name: "getUsersUsernameOrgs", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/users/{username}/orgs", validator: validate_GetUsersUsernameOrgs_756623,
    base: "/", makeUrl: url_GetUsersUsernameOrgs_756624, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameReceivedEvents_756631 = ref object of OpenApiRestCall_753573
proc url_GetUsersUsernameReceivedEvents_756633(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/received_events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameReceivedEvents_756632(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## These are events that you'll only see public events.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_756634 = path.getOrDefault("username")
  valid_756634 = validateParameter(valid_756634, JString, required = true,
                                 default = nil)
  if valid_756634 != nil:
    section.add "username", valid_756634
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756635 = header.getOrDefault("Accept")
  valid_756635 = validateParameter(valid_756635, JString, required = false,
                                 default = nil)
  if valid_756635 != nil:
    section.add "Accept", valid_756635
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756636: Call_GetUsersUsernameReceivedEvents_756631;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## These are events that you'll only see public events.
  ## 
  let valid = call_756636.validator(path, query, header, formData, body, _)
  let scheme = call_756636.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756636.makeUrl(scheme.get, call_756636.host, call_756636.base,
                             call_756636.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756636, uri, valid, _)

proc call*(call_756637: Call_GetUsersUsernameReceivedEvents_756631;
          username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameReceivedEvents
  ## These are events that you'll only see public events.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_756638 = newJObject()
  var header_756639 = newJObject()
  add(path_756638, "username", newJString(username))
  add(header_756639, "Accept", newJString(Accept))
  result = call_756637.call(path_756638, nil, header_756639, nil, nil)

var getUsersUsernameReceivedEvents* = Call_GetUsersUsernameReceivedEvents_756631(
    name: "getUsersUsernameReceivedEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/received_events",
    validator: validate_GetUsersUsernameReceivedEvents_756632, base: "/",
    makeUrl: url_GetUsersUsernameReceivedEvents_756633, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameReceivedEventsPublic_756640 = ref object of OpenApiRestCall_753573
proc url_GetUsersUsernameReceivedEventsPublic_756642(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/received_events/public")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameReceivedEventsPublic_756641(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## List public events that a user has received
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_756643 = path.getOrDefault("username")
  valid_756643 = validateParameter(valid_756643, JString, required = true,
                                 default = nil)
  if valid_756643 != nil:
    section.add "username", valid_756643
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756644 = header.getOrDefault("Accept")
  valid_756644 = validateParameter(valid_756644, JString, required = false,
                                 default = nil)
  if valid_756644 != nil:
    section.add "Accept", valid_756644
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756645: Call_GetUsersUsernameReceivedEventsPublic_756640;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List public events that a user has received
  ## 
  let valid = call_756645.validator(path, query, header, formData, body, _)
  let scheme = call_756645.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756645.makeUrl(scheme.get, call_756645.host, call_756645.base,
                             call_756645.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756645, uri, valid, _)

proc call*(call_756646: Call_GetUsersUsernameReceivedEventsPublic_756640;
          username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameReceivedEventsPublic
  ## List public events that a user has received
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_756647 = newJObject()
  var header_756648 = newJObject()
  add(path_756647, "username", newJString(username))
  add(header_756648, "Accept", newJString(Accept))
  result = call_756646.call(path_756647, nil, header_756648, nil, nil)

var getUsersUsernameReceivedEventsPublic* = Call_GetUsersUsernameReceivedEventsPublic_756640(
    name: "getUsersUsernameReceivedEventsPublic", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/received_events/public",
    validator: validate_GetUsersUsernameReceivedEventsPublic_756641, base: "/",
    makeUrl: url_GetUsersUsernameReceivedEventsPublic_756642,
    schemes: {Scheme.Https})
type
  Call_GetUsersUsernameRepos_756649 = ref object of OpenApiRestCall_753573
proc url_GetUsersUsernameRepos_756651(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameRepos_756650(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List public repositories for the specified user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_756652 = path.getOrDefault("username")
  valid_756652 = validateParameter(valid_756652, JString, required = true,
                                 default = nil)
  if valid_756652 != nil:
    section.add "username", valid_756652
  result.add "path", section
  ## parameters in `query` object:
  ##   type: JString
  section = newJObject()
  var valid_756653 = query.getOrDefault("type")
  valid_756653 = validateParameter(valid_756653, JString, required = false,
                                 default = newJString("all"))
  if valid_756653 != nil:
    section.add "type", valid_756653
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756654 = header.getOrDefault("Accept")
  valid_756654 = validateParameter(valid_756654, JString, required = false,
                                 default = nil)
  if valid_756654 != nil:
    section.add "Accept", valid_756654
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756655: Call_GetUsersUsernameRepos_756649; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List public repositories for the specified user.
  ## 
  let valid = call_756655.validator(path, query, header, formData, body, _)
  let scheme = call_756655.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756655.makeUrl(scheme.get, call_756655.host, call_756655.base,
                             call_756655.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756655, uri, valid, _)

proc call*(call_756656: Call_GetUsersUsernameRepos_756649; username: string;
          `type`: string = "all"; Accept: string = ""): Recallable =
  ## getUsersUsernameRepos
  ## List public repositories for the specified user.
  ##   type: string
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_756657 = newJObject()
  var query_756658 = newJObject()
  var header_756659 = newJObject()
  add(query_756658, "type", newJString(`type`))
  add(path_756657, "username", newJString(username))
  add(header_756659, "Accept", newJString(Accept))
  result = call_756656.call(path_756657, query_756658, header_756659, nil, nil)

var getUsersUsernameRepos* = Call_GetUsersUsernameRepos_756649(
    name: "getUsersUsernameRepos", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/users/{username}/repos", validator: validate_GetUsersUsernameRepos_756650,
    base: "/", makeUrl: url_GetUsersUsernameRepos_756651, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameStarred_756660 = ref object of OpenApiRestCall_753573
proc url_GetUsersUsernameStarred_756662(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/starred")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameStarred_756661(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List repositories being starred by a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_756663 = path.getOrDefault("username")
  valid_756663 = validateParameter(valid_756663, JString, required = true,
                                 default = nil)
  if valid_756663 != nil:
    section.add "username", valid_756663
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756664 = header.getOrDefault("Accept")
  valid_756664 = validateParameter(valid_756664, JString, required = false,
                                 default = nil)
  if valid_756664 != nil:
    section.add "Accept", valid_756664
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756665: Call_GetUsersUsernameStarred_756660; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List repositories being starred by a user.
  ## 
  let valid = call_756665.validator(path, query, header, formData, body, _)
  let scheme = call_756665.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756665.makeUrl(scheme.get, call_756665.host, call_756665.base,
                             call_756665.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756665, uri, valid, _)

proc call*(call_756666: Call_GetUsersUsernameStarred_756660; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameStarred
  ## List repositories being starred by a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_756667 = newJObject()
  var header_756668 = newJObject()
  add(path_756667, "username", newJString(username))
  add(header_756668, "Accept", newJString(Accept))
  result = call_756666.call(path_756667, nil, header_756668, nil, nil)

var getUsersUsernameStarred* = Call_GetUsersUsernameStarred_756660(
    name: "getUsersUsernameStarred", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/starred",
    validator: validate_GetUsersUsernameStarred_756661, base: "/",
    makeUrl: url_GetUsersUsernameStarred_756662, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameSubscriptions_756669 = ref object of OpenApiRestCall_753573
proc url_GetUsersUsernameSubscriptions_756671(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/subscriptions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base ==
      "/" and
      hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameSubscriptions_756670(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## List repositories being watched by a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_756672 = path.getOrDefault("username")
  valid_756672 = validateParameter(valid_756672, JString, required = true,
                                 default = nil)
  if valid_756672 != nil:
    section.add "username", valid_756672
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_756673 = header.getOrDefault("Accept")
  valid_756673 = validateParameter(valid_756673, JString, required = false,
                                 default = nil)
  if valid_756673 != nil:
    section.add "Accept", valid_756673
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_756674: Call_GetUsersUsernameSubscriptions_756669;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List repositories being watched by a user.
  ## 
  let valid = call_756674.validator(path, query, header, formData, body, _)
  let scheme = call_756674.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_756674.makeUrl(scheme.get, call_756674.host, call_756674.base,
                             call_756674.route, valid.getOrDefault("path"),
                             valid.getOrDefault("query"))
  result = hook(call_756674, uri, valid, _)

proc call*(call_756675: Call_GetUsersUsernameSubscriptions_756669;
          username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameSubscriptions
  ## List repositories being watched by a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_756676 = newJObject()
  var header_756677 = newJObject()
  add(path_756676, "username", newJString(username))
  add(header_756677, "Accept", newJString(Accept))
  result = call_756675.call(path_756676, nil, header_756677, nil, nil)

var getUsersUsernameSubscriptions* = Call_GetUsersUsernameSubscriptions_756669(
    name: "getUsersUsernameSubscriptions", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/subscriptions",
    validator: validate_GetUsersUsernameSubscriptions_756670, base: "/",
    makeUrl: url_GetUsersUsernameSubscriptions_756671, schemes: {Scheme.Https})
export
  rest

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode; body: string): Recallable {.
    base.} =
  var headers = massageHeaders(input.getOrDefault("header")).newHttpHeaders
  let token = os.getEnv("GITHUB_TOKEN", "")
  if not headers.hasKey("Authorization") and token.len > 0:
    headers.add "Authorization", "token " & token
  if headers.hasKey "Accept":
    headers.del "Accept"
  headers.add "Accept", "application/vnd.github.v3+json"
  result = newRecallable(call, url, headers, body)
