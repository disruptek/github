
import
  json, options, hashes, uri, strutils, rest, os, uri, httpcore

## auto-generated via openapi macro
## title: GitHub
## version: v3
## termsOfService: https://help.github.com/articles/github-terms-of-service/#b-api-terms
## license: (not provided)
## 
## Powerful collaboration, code review, and code management for open source and private projects.
## 
## 
## https://developer.github.com/v3/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (path: JsonNode = nil; query: JsonNode = nil;
                          header: JsonNode = nil; formData: JsonNode = nil;
                          body: JsonNode = nil; _: string = ""): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_39460352 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_39460352](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_39460352): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low .. Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js == nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result == nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind == kind, $kind & " expected; received " & $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string {.used.} =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] {.used.} =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    case js.kind
    of JInt, JFloat, JNull, JBool:
      head = $js
    of JString:
      head = js.getStr
    else:
      return
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode; body: string = ""): Recallable {.
    base.}
type
  Call_GetEmojis_39460539 = ref object of OpenApiRestCall_39460352
proc url_GetEmojis_39460541(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEmojis_39460540(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Lists all the emojis available to use on GitHub.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39460674 = header.getOrDefault("Accept")
  valid_39460674 = validateParameter(valid_39460674, JString, required = false,
                                   default = nil)
  if valid_39460674 != nil:
    section.add "Accept", valid_39460674
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39460699: Call_GetEmojis_39460539; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Lists all the emojis available to use on GitHub.
  ## 
  let valid = call_39460699.validator(path, query, header, formData, body, _)
  let scheme = call_39460699.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39460699.url(scheme.get, call_39460699.host, call_39460699.base,
                           call_39460699.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39460699, uri, valid, _)

proc call*(call_39460762: Call_GetEmojis_39460539; Accept: string = ""): Recallable =
  ## getEmojis
  ## Lists all the emojis available to use on GitHub.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_39460764 = newJObject()
  add(header_39460764, "Accept", newJString(Accept))
  result = call_39460762.call(nil, nil, header_39460764, nil, nil)

var getEmojis* = Call_GetEmojis_39460539(name: "getEmojis", meth: HttpMethod.HttpGet,
                                      host: "api.github.com", route: "/emojis",
                                      validator: validate_GetEmojis_39460540,
                                      base: "/", url: url_GetEmojis_39460541,
                                      schemes: {Scheme.Https})
type
  Call_GetEvents_39460806 = ref object of OpenApiRestCall_39460352
proc url_GetEvents_39460808(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEvents_39460807(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List public events.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39460809 = header.getOrDefault("Accept")
  valid_39460809 = validateParameter(valid_39460809, JString, required = false,
                                   default = nil)
  if valid_39460809 != nil:
    section.add "Accept", valid_39460809
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39460810: Call_GetEvents_39460806; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List public events.
  ## 
  let valid = call_39460810.validator(path, query, header, formData, body, _)
  let scheme = call_39460810.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39460810.url(scheme.get, call_39460810.host, call_39460810.base,
                           call_39460810.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39460810, uri, valid, _)

proc call*(call_39460811: Call_GetEvents_39460806; Accept: string = ""): Recallable =
  ## getEvents
  ## List public events.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_39460812 = newJObject()
  add(header_39460812, "Accept", newJString(Accept))
  result = call_39460811.call(nil, nil, header_39460812, nil, nil)

var getEvents* = Call_GetEvents_39460806(name: "getEvents", meth: HttpMethod.HttpGet,
                                      host: "api.github.com", route: "/events",
                                      validator: validate_GetEvents_39460807,
                                      base: "/", url: url_GetEvents_39460808,
                                      schemes: {Scheme.Https})
type
  Call_GetFeeds_39460813 = ref object of OpenApiRestCall_39460352
proc url_GetFeeds_39460815(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetFeeds_39460814(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List Feeds.
  ## GitHub provides several timeline resources in Atom format. The Feeds API
  ##  lists all the feeds available to the authenticating user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39460816 = header.getOrDefault("Accept")
  valid_39460816 = validateParameter(valid_39460816, JString, required = false,
                                   default = nil)
  if valid_39460816 != nil:
    section.add "Accept", valid_39460816
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39460817: Call_GetFeeds_39460813; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List Feeds.
  ## GitHub provides several timeline resources in Atom format. The Feeds API
  ##  lists all the feeds available to the authenticating user.
  ## 
  ## 
  let valid = call_39460817.validator(path, query, header, formData, body, _)
  let scheme = call_39460817.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39460817.url(scheme.get, call_39460817.host, call_39460817.base,
                           call_39460817.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39460817, uri, valid, _)

proc call*(call_39460818: Call_GetFeeds_39460813; Accept: string = ""): Recallable =
  ## getFeeds
  ## List Feeds.
  ## GitHub provides several timeline resources in Atom format. The Feeds API
  ##  lists all the feeds available to the authenticating user.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_39460819 = newJObject()
  add(header_39460819, "Accept", newJString(Accept))
  result = call_39460818.call(nil, nil, header_39460819, nil, nil)

var getFeeds* = Call_GetFeeds_39460813(name: "getFeeds", meth: HttpMethod.HttpGet,
                                    host: "api.github.com", route: "/feeds",
                                    validator: validate_GetFeeds_39460814,
                                    base: "/", url: url_GetFeeds_39460815,
                                    schemes: {Scheme.Https})
type
  Call_PostGists_39460829 = ref object of OpenApiRestCall_39460352
proc url_PostGists_39460831(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostGists_39460830(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39460841 = header.getOrDefault("Accept")
  valid_39460841 = validateParameter(valid_39460841, JString, required = false,
                                   default = nil)
  if valid_39460841 != nil:
    section.add "Accept", valid_39460841
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39460843: Call_PostGists_39460829; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a gist.
  ## 
  let valid = call_39460843.validator(path, query, header, formData, body, _)
  let scheme = call_39460843.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39460843.url(scheme.get, call_39460843.host, call_39460843.base,
                           call_39460843.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39460843, uri, valid, _)

proc call*(call_39460844: Call_PostGists_39460829; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postGists
  ## Create a gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_39460845 = newJObject()
  var body_39460846 = newJObject()
  add(header_39460845, "Accept", newJString(Accept))
  if body != nil:
    body_39460846 = body
  result = call_39460844.call(nil, nil, header_39460845, nil, body_39460846)

var postGists* = Call_PostGists_39460829(name: "postGists",
                                      meth: HttpMethod.HttpPost,
                                      host: "api.github.com", route: "/gists",
                                      validator: validate_PostGists_39460830,
                                      base: "/", url: url_PostGists_39460831,
                                      schemes: {Scheme.Https})
type
  Call_GetGists_39460820 = ref object of OpenApiRestCall_39460352
proc url_GetGists_39460822(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGists_39460821(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List the authenticated user's gists or if called anonymously, this will
  ## return all public gists.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_39460823 = query.getOrDefault("since")
  valid_39460823 = validateParameter(valid_39460823, JString, required = false,
                                   default = nil)
  if valid_39460823 != nil:
    section.add "since", valid_39460823
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39460824 = header.getOrDefault("Accept")
  valid_39460824 = validateParameter(valid_39460824, JString, required = false,
                                   default = nil)
  if valid_39460824 != nil:
    section.add "Accept", valid_39460824
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39460825: Call_GetGists_39460820; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List the authenticated user's gists or if called anonymously, this will
  ## return all public gists.
  ## 
  ## 
  let valid = call_39460825.validator(path, query, header, formData, body, _)
  let scheme = call_39460825.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39460825.url(scheme.get, call_39460825.host, call_39460825.base,
                           call_39460825.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39460825, uri, valid, _)

proc call*(call_39460826: Call_GetGists_39460820; Accept: string = "";
          since: string = ""): Recallable =
  ## getGists
  ## List the authenticated user's gists or if called anonymously, this will
  ## return all public gists.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: string
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  var query_39460827 = newJObject()
  var header_39460828 = newJObject()
  add(header_39460828, "Accept", newJString(Accept))
  add(query_39460827, "since", newJString(since))
  result = call_39460826.call(nil, query_39460827, header_39460828, nil, nil)

var getGists* = Call_GetGists_39460820(name: "getGists", meth: HttpMethod.HttpGet,
                                    host: "api.github.com", route: "/gists",
                                    validator: validate_GetGists_39460821,
                                    base: "/", url: url_GetGists_39460822,
                                    schemes: {Scheme.Https})
type
  Call_GetGistsPublic_39460847 = ref object of OpenApiRestCall_39460352
proc url_GetGistsPublic_39460849(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGistsPublic_39460848(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List all public gists.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_39460850 = query.getOrDefault("since")
  valid_39460850 = validateParameter(valid_39460850, JString, required = false,
                                   default = nil)
  if valid_39460850 != nil:
    section.add "since", valid_39460850
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39460851 = header.getOrDefault("Accept")
  valid_39460851 = validateParameter(valid_39460851, JString, required = false,
                                   default = nil)
  if valid_39460851 != nil:
    section.add "Accept", valid_39460851
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39460852: Call_GetGistsPublic_39460847; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List all public gists.
  ## 
  let valid = call_39460852.validator(path, query, header, formData, body, _)
  let scheme = call_39460852.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39460852.url(scheme.get, call_39460852.host, call_39460852.base,
                           call_39460852.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39460852, uri, valid, _)

proc call*(call_39460853: Call_GetGistsPublic_39460847; Accept: string = "";
          since: string = ""): Recallable =
  ## getGistsPublic
  ## List all public gists.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: string
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  var query_39460854 = newJObject()
  var header_39460855 = newJObject()
  add(header_39460855, "Accept", newJString(Accept))
  add(query_39460854, "since", newJString(since))
  result = call_39460853.call(nil, query_39460854, header_39460855, nil, nil)

var getGistsPublic* = Call_GetGistsPublic_39460847(name: "getGistsPublic",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/gists/public",
    validator: validate_GetGistsPublic_39460848, base: "/", url: url_GetGistsPublic_39460849,
    schemes: {Scheme.Https})
type
  Call_GetGistsStarred_39460856 = ref object of OpenApiRestCall_39460352
proc url_GetGistsStarred_39460858(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGistsStarred_39460857(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List the authenticated user's starred gists.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_39460859 = query.getOrDefault("since")
  valid_39460859 = validateParameter(valid_39460859, JString, required = false,
                                   default = nil)
  if valid_39460859 != nil:
    section.add "since", valid_39460859
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39460860 = header.getOrDefault("Accept")
  valid_39460860 = validateParameter(valid_39460860, JString, required = false,
                                   default = nil)
  if valid_39460860 != nil:
    section.add "Accept", valid_39460860
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39460861: Call_GetGistsStarred_39460856; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List the authenticated user's starred gists.
  ## 
  let valid = call_39460861.validator(path, query, header, formData, body, _)
  let scheme = call_39460861.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39460861.url(scheme.get, call_39460861.host, call_39460861.base,
                           call_39460861.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39460861, uri, valid, _)

proc call*(call_39460862: Call_GetGistsStarred_39460856; Accept: string = "";
          since: string = ""): Recallable =
  ## getGistsStarred
  ## List the authenticated user's starred gists.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: string
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  var query_39460863 = newJObject()
  var header_39460864 = newJObject()
  add(header_39460864, "Accept", newJString(Accept))
  add(query_39460863, "since", newJString(since))
  result = call_39460862.call(nil, query_39460863, header_39460864, nil, nil)

var getGistsStarred* = Call_GetGistsStarred_39460856(name: "getGistsStarred",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/gists/starred",
    validator: validate_GetGistsStarred_39460857, base: "/",
    url: url_GetGistsStarred_39460858, schemes: {Scheme.Https})
type
  Call_GetGistsId_39460865 = ref object of OpenApiRestCall_39460352
proc url_GetGistsId_39460867(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsId_39460866(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get a single gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39460881 = path.getOrDefault("id")
  valid_39460881 = validateParameter(valid_39460881, JInt, required = true,
                                   default = nil)
  if valid_39460881 != nil:
    section.add "id", valid_39460881
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39460882 = header.getOrDefault("Accept")
  valid_39460882 = validateParameter(valid_39460882, JString, required = false,
                                   default = nil)
  if valid_39460882 != nil:
    section.add "Accept", valid_39460882
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39460883: Call_GetGistsId_39460865; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single gist.
  ## 
  let valid = call_39460883.validator(path, query, header, formData, body, _)
  let scheme = call_39460883.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39460883.url(scheme.get, call_39460883.host, call_39460883.base,
                           call_39460883.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39460883, uri, valid, _)

proc call*(call_39460884: Call_GetGistsId_39460865; id: int; Accept: string = ""): Recallable =
  ## getGistsId
  ## Get a single gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39460885 = newJObject()
  var header_39460886 = newJObject()
  add(path_39460885, "id", newJInt(id))
  add(header_39460886, "Accept", newJString(Accept))
  result = call_39460884.call(path_39460885, nil, header_39460886, nil, nil)

var getGistsId* = Call_GetGistsId_39460865(name: "getGistsId",
                                        meth: HttpMethod.HttpGet,
                                        host: "api.github.com",
                                        route: "/gists/{id}",
                                        validator: validate_GetGistsId_39460866,
                                        base: "/", url: url_GetGistsId_39460867,
                                        schemes: {Scheme.Https})
type
  Call_PatchGistsId_39460896 = ref object of OpenApiRestCall_39460352
proc url_PatchGistsId_39460898(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchGistsId_39460897(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## Edit a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39460899 = path.getOrDefault("id")
  valid_39460899 = validateParameter(valid_39460899, JInt, required = true,
                                   default = nil)
  if valid_39460899 != nil:
    section.add "id", valid_39460899
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39460900 = header.getOrDefault("Accept")
  valid_39460900 = validateParameter(valid_39460900, JString, required = false,
                                   default = nil)
  if valid_39460900 != nil:
    section.add "Accept", valid_39460900
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39460902: Call_PatchGistsId_39460896; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit a gist.
  ## 
  let valid = call_39460902.validator(path, query, header, formData, body, _)
  let scheme = call_39460902.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39460902.url(scheme.get, call_39460902.host, call_39460902.base,
                           call_39460902.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39460902, uri, valid, _)

proc call*(call_39460903: Call_PatchGistsId_39460896; id: int; body: JsonNode;
          Accept: string = ""): Recallable =
  ## patchGistsId
  ## Edit a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var path_39460904 = newJObject()
  var header_39460905 = newJObject()
  var body_39460906 = newJObject()
  add(path_39460904, "id", newJInt(id))
  add(header_39460905, "Accept", newJString(Accept))
  if body != nil:
    body_39460906 = body
  result = call_39460903.call(path_39460904, nil, header_39460905, nil, body_39460906)

var patchGistsId* = Call_PatchGistsId_39460896(name: "patchGistsId",
    meth: HttpMethod.HttpPatch, host: "api.github.com", route: "/gists/{id}",
    validator: validate_PatchGistsId_39460897, base: "/", url: url_PatchGistsId_39460898,
    schemes: {Scheme.Https})
type
  Call_DeleteGistsId_39460887 = ref object of OpenApiRestCall_39460352
proc url_DeleteGistsId_39460889(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteGistsId_39460888(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## Delete a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39460890 = path.getOrDefault("id")
  valid_39460890 = validateParameter(valid_39460890, JInt, required = true,
                                   default = nil)
  if valid_39460890 != nil:
    section.add "id", valid_39460890
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39460891 = header.getOrDefault("Accept")
  valid_39460891 = validateParameter(valid_39460891, JString, required = false,
                                   default = nil)
  if valid_39460891 != nil:
    section.add "Accept", valid_39460891
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39460892: Call_DeleteGistsId_39460887; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a gist.
  ## 
  let valid = call_39460892.validator(path, query, header, formData, body, _)
  let scheme = call_39460892.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39460892.url(scheme.get, call_39460892.host, call_39460892.base,
                           call_39460892.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39460892, uri, valid, _)

proc call*(call_39460893: Call_DeleteGistsId_39460887; id: int; Accept: string = ""): Recallable =
  ## deleteGistsId
  ## Delete a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39460894 = newJObject()
  var header_39460895 = newJObject()
  add(path_39460894, "id", newJInt(id))
  add(header_39460895, "Accept", newJString(Accept))
  result = call_39460893.call(path_39460894, nil, header_39460895, nil, nil)

var deleteGistsId* = Call_DeleteGistsId_39460887(name: "deleteGistsId",
    meth: HttpMethod.HttpDelete, host: "api.github.com", route: "/gists/{id}",
    validator: validate_DeleteGistsId_39460888, base: "/", url: url_DeleteGistsId_39460889,
    schemes: {Scheme.Https})
type
  Call_PostGistsIdComments_39460916 = ref object of OpenApiRestCall_39460352
proc url_PostGistsIdComments_39460918(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostGistsIdComments_39460917(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a commen
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39460919 = path.getOrDefault("id")
  valid_39460919 = validateParameter(valid_39460919, JInt, required = true,
                                   default = nil)
  if valid_39460919 != nil:
    section.add "id", valid_39460919
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39460920 = header.getOrDefault("Accept")
  valid_39460920 = validateParameter(valid_39460920, JString, required = false,
                                   default = nil)
  if valid_39460920 != nil:
    section.add "Accept", valid_39460920
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39460922: Call_PostGistsIdComments_39460916; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a commen
  ## 
  let valid = call_39460922.validator(path, query, header, formData, body, _)
  let scheme = call_39460922.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39460922.url(scheme.get, call_39460922.host, call_39460922.base,
                           call_39460922.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39460922, uri, valid, _)

proc call*(call_39460923: Call_PostGistsIdComments_39460916; id: int; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postGistsIdComments
  ## Create a commen
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var path_39460924 = newJObject()
  var header_39460925 = newJObject()
  var body_39460926 = newJObject()
  add(path_39460924, "id", newJInt(id))
  add(header_39460925, "Accept", newJString(Accept))
  if body != nil:
    body_39460926 = body
  result = call_39460923.call(path_39460924, nil, header_39460925, nil, body_39460926)

var postGistsIdComments* = Call_PostGistsIdComments_39460916(
    name: "postGistsIdComments", meth: HttpMethod.HttpPost, host: "api.github.com",
    route: "/gists/{id}/comments", validator: validate_PostGistsIdComments_39460917,
    base: "/", url: url_PostGistsIdComments_39460918, schemes: {Scheme.Https})
type
  Call_GetGistsIdComments_39460907 = ref object of OpenApiRestCall_39460352
proc url_GetGistsIdComments_39460909(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsIdComments_39460908(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List comments on a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39460910 = path.getOrDefault("id")
  valid_39460910 = validateParameter(valid_39460910, JInt, required = true,
                                   default = nil)
  if valid_39460910 != nil:
    section.add "id", valid_39460910
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39460911 = header.getOrDefault("Accept")
  valid_39460911 = validateParameter(valid_39460911, JString, required = false,
                                   default = nil)
  if valid_39460911 != nil:
    section.add "Accept", valid_39460911
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39460912: Call_GetGistsIdComments_39460907; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List comments on a gist.
  ## 
  let valid = call_39460912.validator(path, query, header, formData, body, _)
  let scheme = call_39460912.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39460912.url(scheme.get, call_39460912.host, call_39460912.base,
                           call_39460912.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39460912, uri, valid, _)

proc call*(call_39460913: Call_GetGistsIdComments_39460907; id: int;
          Accept: string = ""): Recallable =
  ## getGistsIdComments
  ## List comments on a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39460914 = newJObject()
  var header_39460915 = newJObject()
  add(path_39460914, "id", newJInt(id))
  add(header_39460915, "Accept", newJString(Accept))
  result = call_39460913.call(path_39460914, nil, header_39460915, nil, nil)

var getGistsIdComments* = Call_GetGistsIdComments_39460907(
    name: "getGistsIdComments", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/gists/{id}/comments", validator: validate_GetGistsIdComments_39460908,
    base: "/", url: url_GetGistsIdComments_39460909, schemes: {Scheme.Https})
type
  Call_GetGistsIdCommentsCommentId_39460927 = ref object of OpenApiRestCall_39460352
proc url_GetGistsIdCommentsCommentId_39460929(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsIdCommentsCommentId_39460928(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get a single comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39460930 = path.getOrDefault("id")
  valid_39460930 = validateParameter(valid_39460930, JInt, required = true,
                                   default = nil)
  if valid_39460930 != nil:
    section.add "id", valid_39460930
  var valid_39460931 = path.getOrDefault("commentId")
  valid_39460931 = validateParameter(valid_39460931, JInt, required = true,
                                   default = nil)
  if valid_39460931 != nil:
    section.add "commentId", valid_39460931
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39460932 = header.getOrDefault("Accept")
  valid_39460932 = validateParameter(valid_39460932, JString, required = false,
                                   default = nil)
  if valid_39460932 != nil:
    section.add "Accept", valid_39460932
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39460933: Call_GetGistsIdCommentsCommentId_39460927;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single comment.
  ## 
  let valid = call_39460933.validator(path, query, header, formData, body, _)
  let scheme = call_39460933.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39460933.url(scheme.get, call_39460933.host, call_39460933.base,
                           call_39460933.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39460933, uri, valid, _)

proc call*(call_39460934: Call_GetGistsIdCommentsCommentId_39460927; id: int;
          commentId: int; Accept: string = ""): Recallable =
  ## getGistsIdCommentsCommentId
  ## Get a single comment.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_39460935 = newJObject()
  var header_39460936 = newJObject()
  add(path_39460935, "id", newJInt(id))
  add(header_39460936, "Accept", newJString(Accept))
  add(path_39460935, "commentId", newJInt(commentId))
  result = call_39460934.call(path_39460935, nil, header_39460936, nil, nil)

var getGistsIdCommentsCommentId* = Call_GetGistsIdCommentsCommentId_39460927(
    name: "getGistsIdCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/gists/{id}/comments/{commentId}",
    validator: validate_GetGistsIdCommentsCommentId_39460928, base: "/",
    url: url_GetGistsIdCommentsCommentId_39460929, schemes: {Scheme.Https})
type
  Call_PatchGistsIdCommentsCommentId_39460947 = ref object of OpenApiRestCall_39460352
proc url_PatchGistsIdCommentsCommentId_39460949(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchGistsIdCommentsCommentId_39460948(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Edit a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39460950 = path.getOrDefault("id")
  valid_39460950 = validateParameter(valid_39460950, JInt, required = true,
                                   default = nil)
  if valid_39460950 != nil:
    section.add "id", valid_39460950
  var valid_39460951 = path.getOrDefault("commentId")
  valid_39460951 = validateParameter(valid_39460951, JInt, required = true,
                                   default = nil)
  if valid_39460951 != nil:
    section.add "commentId", valid_39460951
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39460952 = header.getOrDefault("Accept")
  valid_39460952 = validateParameter(valid_39460952, JString, required = false,
                                   default = nil)
  if valid_39460952 != nil:
    section.add "Accept", valid_39460952
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39460954: Call_PatchGistsIdCommentsCommentId_39460947;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit a comment.
  ## 
  let valid = call_39460954.validator(path, query, header, formData, body, _)
  let scheme = call_39460954.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39460954.url(scheme.get, call_39460954.host, call_39460954.base,
                           call_39460954.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39460954, uri, valid, _)

proc call*(call_39460955: Call_PatchGistsIdCommentsCommentId_39460947; id: int;
          body: JsonNode; commentId: int; Accept: string = ""): Recallable =
  ## patchGistsIdCommentsCommentId
  ## Edit a comment.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_39460956 = newJObject()
  var header_39460957 = newJObject()
  var body_39460958 = newJObject()
  add(path_39460956, "id", newJInt(id))
  add(header_39460957, "Accept", newJString(Accept))
  if body != nil:
    body_39460958 = body
  add(path_39460956, "commentId", newJInt(commentId))
  result = call_39460955.call(path_39460956, nil, header_39460957, nil, body_39460958)

var patchGistsIdCommentsCommentId* = Call_PatchGistsIdCommentsCommentId_39460947(
    name: "patchGistsIdCommentsCommentId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/gists/{id}/comments/{commentId}",
    validator: validate_PatchGistsIdCommentsCommentId_39460948, base: "/",
    url: url_PatchGistsIdCommentsCommentId_39460949, schemes: {Scheme.Https})
type
  Call_DeleteGistsIdCommentsCommentId_39460937 = ref object of OpenApiRestCall_39460352
proc url_DeleteGistsIdCommentsCommentId_39460939(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteGistsIdCommentsCommentId_39460938(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39460940 = path.getOrDefault("id")
  valid_39460940 = validateParameter(valid_39460940, JInt, required = true,
                                   default = nil)
  if valid_39460940 != nil:
    section.add "id", valid_39460940
  var valid_39460941 = path.getOrDefault("commentId")
  valid_39460941 = validateParameter(valid_39460941, JInt, required = true,
                                   default = nil)
  if valid_39460941 != nil:
    section.add "commentId", valid_39460941
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39460942 = header.getOrDefault("Accept")
  valid_39460942 = validateParameter(valid_39460942, JString, required = false,
                                   default = nil)
  if valid_39460942 != nil:
    section.add "Accept", valid_39460942
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39460943: Call_DeleteGistsIdCommentsCommentId_39460937;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a comment.
  ## 
  let valid = call_39460943.validator(path, query, header, formData, body, _)
  let scheme = call_39460943.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39460943.url(scheme.get, call_39460943.host, call_39460943.base,
                           call_39460943.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39460943, uri, valid, _)

proc call*(call_39460944: Call_DeleteGistsIdCommentsCommentId_39460937; id: int;
          commentId: int; Accept: string = ""): Recallable =
  ## deleteGistsIdCommentsCommentId
  ## Delete a comment.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_39460945 = newJObject()
  var header_39460946 = newJObject()
  add(path_39460945, "id", newJInt(id))
  add(header_39460946, "Accept", newJString(Accept))
  add(path_39460945, "commentId", newJInt(commentId))
  result = call_39460944.call(path_39460945, nil, header_39460946, nil, nil)

var deleteGistsIdCommentsCommentId* = Call_DeleteGistsIdCommentsCommentId_39460937(
    name: "deleteGistsIdCommentsCommentId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/gists/{id}/comments/{commentId}",
    validator: validate_DeleteGistsIdCommentsCommentId_39460938, base: "/",
    url: url_DeleteGistsIdCommentsCommentId_39460939, schemes: {Scheme.Https})
type
  Call_PostGistsIdForks_39460959 = ref object of OpenApiRestCall_39460352
proc url_PostGistsIdForks_39460961(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/forks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostGistsIdForks_39460960(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Fork a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39460962 = path.getOrDefault("id")
  valid_39460962 = validateParameter(valid_39460962, JInt, required = true,
                                   default = nil)
  if valid_39460962 != nil:
    section.add "id", valid_39460962
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39460963 = header.getOrDefault("Accept")
  valid_39460963 = validateParameter(valid_39460963, JString, required = false,
                                   default = nil)
  if valid_39460963 != nil:
    section.add "Accept", valid_39460963
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39460964: Call_PostGistsIdForks_39460959; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Fork a gist.
  ## 
  let valid = call_39460964.validator(path, query, header, formData, body, _)
  let scheme = call_39460964.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39460964.url(scheme.get, call_39460964.host, call_39460964.base,
                           call_39460964.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39460964, uri, valid, _)

proc call*(call_39460965: Call_PostGistsIdForks_39460959; id: int;
          Accept: string = ""): Recallable =
  ## postGistsIdForks
  ## Fork a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39460966 = newJObject()
  var header_39460967 = newJObject()
  add(path_39460966, "id", newJInt(id))
  add(header_39460967, "Accept", newJString(Accept))
  result = call_39460965.call(path_39460966, nil, header_39460967, nil, nil)

var postGistsIdForks* = Call_PostGistsIdForks_39460959(name: "postGistsIdForks",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/gists/{id}/forks",
    validator: validate_PostGistsIdForks_39460960, base: "/",
    url: url_PostGistsIdForks_39460961, schemes: {Scheme.Https})
type
  Call_PutGistsIdStar_39460977 = ref object of OpenApiRestCall_39460352
proc url_PutGistsIdStar_39460979(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/star")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutGistsIdStar_39460978(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Star a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39460980 = path.getOrDefault("id")
  valid_39460980 = validateParameter(valid_39460980, JInt, required = true,
                                   default = nil)
  if valid_39460980 != nil:
    section.add "id", valid_39460980
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39460981 = header.getOrDefault("Accept")
  valid_39460981 = validateParameter(valid_39460981, JString, required = false,
                                   default = nil)
  if valid_39460981 != nil:
    section.add "Accept", valid_39460981
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39460982: Call_PutGistsIdStar_39460977; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Star a gist.
  ## 
  let valid = call_39460982.validator(path, query, header, formData, body, _)
  let scheme = call_39460982.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39460982.url(scheme.get, call_39460982.host, call_39460982.base,
                           call_39460982.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39460982, uri, valid, _)

proc call*(call_39460983: Call_PutGistsIdStar_39460977; id: int; Accept: string = ""): Recallable =
  ## putGistsIdStar
  ## Star a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39460984 = newJObject()
  var header_39460985 = newJObject()
  add(path_39460984, "id", newJInt(id))
  add(header_39460985, "Accept", newJString(Accept))
  result = call_39460983.call(path_39460984, nil, header_39460985, nil, nil)

var putGistsIdStar* = Call_PutGistsIdStar_39460977(name: "putGistsIdStar",
    meth: HttpMethod.HttpPut, host: "api.github.com", route: "/gists/{id}/star",
    validator: validate_PutGistsIdStar_39460978, base: "/", url: url_PutGistsIdStar_39460979,
    schemes: {Scheme.Https})
type
  Call_GetGistsIdStar_39460968 = ref object of OpenApiRestCall_39460352
proc url_GetGistsIdStar_39460970(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/star")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsIdStar_39460969(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Check if a gist is starred.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39460971 = path.getOrDefault("id")
  valid_39460971 = validateParameter(valid_39460971, JInt, required = true,
                                   default = nil)
  if valid_39460971 != nil:
    section.add "id", valid_39460971
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39460972 = header.getOrDefault("Accept")
  valid_39460972 = validateParameter(valid_39460972, JString, required = false,
                                   default = nil)
  if valid_39460972 != nil:
    section.add "Accept", valid_39460972
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39460973: Call_GetGistsIdStar_39460968; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if a gist is starred.
  ## 
  let valid = call_39460973.validator(path, query, header, formData, body, _)
  let scheme = call_39460973.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39460973.url(scheme.get, call_39460973.host, call_39460973.base,
                           call_39460973.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39460973, uri, valid, _)

proc call*(call_39460974: Call_GetGistsIdStar_39460968; id: int; Accept: string = ""): Recallable =
  ## getGistsIdStar
  ## Check if a gist is starred.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39460975 = newJObject()
  var header_39460976 = newJObject()
  add(path_39460975, "id", newJInt(id))
  add(header_39460976, "Accept", newJString(Accept))
  result = call_39460974.call(path_39460975, nil, header_39460976, nil, nil)

var getGistsIdStar* = Call_GetGistsIdStar_39460968(name: "getGistsIdStar",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/gists/{id}/star",
    validator: validate_GetGistsIdStar_39460969, base: "/", url: url_GetGistsIdStar_39460970,
    schemes: {Scheme.Https})
type
  Call_DeleteGistsIdStar_39460986 = ref object of OpenApiRestCall_39460352
proc url_DeleteGistsIdStar_39460988(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/star")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteGistsIdStar_39460987(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Unstar a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39460989 = path.getOrDefault("id")
  valid_39460989 = validateParameter(valid_39460989, JInt, required = true,
                                   default = nil)
  if valid_39460989 != nil:
    section.add "id", valid_39460989
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39460990 = header.getOrDefault("Accept")
  valid_39460990 = validateParameter(valid_39460990, JString, required = false,
                                   default = nil)
  if valid_39460990 != nil:
    section.add "Accept", valid_39460990
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39460991: Call_DeleteGistsIdStar_39460986; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Unstar a gist.
  ## 
  let valid = call_39460991.validator(path, query, header, formData, body, _)
  let scheme = call_39460991.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39460991.url(scheme.get, call_39460991.host, call_39460991.base,
                           call_39460991.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39460991, uri, valid, _)

proc call*(call_39460992: Call_DeleteGistsIdStar_39460986; id: int;
          Accept: string = ""): Recallable =
  ## deleteGistsIdStar
  ## Unstar a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39460993 = newJObject()
  var header_39460994 = newJObject()
  add(path_39460993, "id", newJInt(id))
  add(header_39460994, "Accept", newJString(Accept))
  result = call_39460992.call(path_39460993, nil, header_39460994, nil, nil)

var deleteGistsIdStar* = Call_DeleteGistsIdStar_39460986(name: "deleteGistsIdStar",
    meth: HttpMethod.HttpDelete, host: "api.github.com", route: "/gists/{id}/star",
    validator: validate_DeleteGistsIdStar_39460987, base: "/",
    url: url_DeleteGistsIdStar_39460988, schemes: {Scheme.Https})
type
  Call_GetGitignoreTemplates_39460995 = ref object of OpenApiRestCall_39460352
proc url_GetGitignoreTemplates_39460997(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGitignoreTemplates_39460996(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Listing available templates.
  ## List all templates available to pass as an option when creating a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39460998 = header.getOrDefault("Accept")
  valid_39460998 = validateParameter(valid_39460998, JString, required = false,
                                   default = nil)
  if valid_39460998 != nil:
    section.add "Accept", valid_39460998
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39460999: Call_GetGitignoreTemplates_39460995;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Listing available templates.
  ## List all templates available to pass as an option when creating a repository.
  ## 
  ## 
  let valid = call_39460999.validator(path, query, header, formData, body, _)
  let scheme = call_39460999.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39460999.url(scheme.get, call_39460999.host, call_39460999.base,
                           call_39460999.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39460999, uri, valid, _)

proc call*(call_39461000: Call_GetGitignoreTemplates_39460995; Accept: string = ""): Recallable =
  ## getGitignoreTemplates
  ## Listing available templates.
  ## List all templates available to pass as an option when creating a repository.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_39461001 = newJObject()
  add(header_39461001, "Accept", newJString(Accept))
  result = call_39461000.call(nil, nil, header_39461001, nil, nil)

var getGitignoreTemplates* = Call_GetGitignoreTemplates_39460995(
    name: "getGitignoreTemplates", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/gitignore/templates", validator: validate_GetGitignoreTemplates_39460996,
    base: "/", url: url_GetGitignoreTemplates_39460997, schemes: {Scheme.Https})
type
  Call_GetGitignoreTemplatesLanguage_39461002 = ref object of OpenApiRestCall_39460352
proc url_GetGitignoreTemplatesLanguage_39461004(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "language" in path, "`language` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gitignore/templates/"),
               (kind: VariableSegment, value: "language")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGitignoreTemplatesLanguage_39461003(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a single template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   language: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `language` field"
  var valid_39461005 = path.getOrDefault("language")
  valid_39461005 = validateParameter(valid_39461005, JString, required = true,
                                   default = nil)
  if valid_39461005 != nil:
    section.add "language", valid_39461005
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461006 = header.getOrDefault("Accept")
  valid_39461006 = validateParameter(valid_39461006, JString, required = false,
                                   default = nil)
  if valid_39461006 != nil:
    section.add "Accept", valid_39461006
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461007: Call_GetGitignoreTemplatesLanguage_39461002;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single template.
  ## 
  let valid = call_39461007.validator(path, query, header, formData, body, _)
  let scheme = call_39461007.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461007.url(scheme.get, call_39461007.host, call_39461007.base,
                           call_39461007.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461007, uri, valid, _)

proc call*(call_39461008: Call_GetGitignoreTemplatesLanguage_39461002;
          language: string; Accept: string = ""): Recallable =
  ## getGitignoreTemplatesLanguage
  ## Get a single template.
  ##   language: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39461009 = newJObject()
  var header_39461010 = newJObject()
  add(path_39461009, "language", newJString(language))
  add(header_39461010, "Accept", newJString(Accept))
  result = call_39461008.call(path_39461009, nil, header_39461010, nil, nil)

var getGitignoreTemplatesLanguage* = Call_GetGitignoreTemplatesLanguage_39461002(
    name: "getGitignoreTemplatesLanguage", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/gitignore/templates/{language}",
    validator: validate_GetGitignoreTemplatesLanguage_39461003, base: "/",
    url: url_GetGitignoreTemplatesLanguage_39461004, schemes: {Scheme.Https})
type
  Call_GetIssues_39461011 = ref object of OpenApiRestCall_39460352
proc url_GetIssues_39461013(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetIssues_39461012(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List issues.
  ## List all issues across all the authenticated user's visible repositories.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString (required)
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: JString (required)
  ##   direction: JString (required)
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_39461028 = query.getOrDefault("state")
  valid_39461028 = validateParameter(valid_39461028, JString, required = true,
                                   default = newJString("open"))
  if valid_39461028 != nil:
    section.add "state", valid_39461028
  var valid_39461029 = query.getOrDefault("labels")
  valid_39461029 = validateParameter(valid_39461029, JString, required = true,
                                   default = nil)
  if valid_39461029 != nil:
    section.add "labels", valid_39461029
  var valid_39461030 = query.getOrDefault("sort")
  valid_39461030 = validateParameter(valid_39461030, JString, required = true,
                                   default = newJString("created"))
  if valid_39461030 != nil:
    section.add "sort", valid_39461030
  var valid_39461031 = query.getOrDefault("direction")
  valid_39461031 = validateParameter(valid_39461031, JString, required = true,
                                   default = newJString("desc"))
  if valid_39461031 != nil:
    section.add "direction", valid_39461031
  var valid_39461032 = query.getOrDefault("filter")
  valid_39461032 = validateParameter(valid_39461032, JString, required = true,
                                   default = newJString("all"))
  if valid_39461032 != nil:
    section.add "filter", valid_39461032
  var valid_39461033 = query.getOrDefault("since")
  valid_39461033 = validateParameter(valid_39461033, JString, required = false,
                                   default = nil)
  if valid_39461033 != nil:
    section.add "since", valid_39461033
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461034 = header.getOrDefault("Accept")
  valid_39461034 = validateParameter(valid_39461034, JString, required = false,
                                   default = nil)
  if valid_39461034 != nil:
    section.add "Accept", valid_39461034
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461035: Call_GetIssues_39461011; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List issues.
  ## List all issues across all the authenticated user's visible repositories.
  ## 
  ## 
  let valid = call_39461035.validator(path, query, header, formData, body, _)
  let scheme = call_39461035.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461035.url(scheme.get, call_39461035.host, call_39461035.base,
                           call_39461035.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461035, uri, valid, _)

proc call*(call_39461036: Call_GetIssues_39461011; labels: string;
          state: string = "open"; Accept: string = ""; sort: string = "created";
          direction: string = "desc"; filter: string = "all"; since: string = ""): Recallable =
  ## getIssues
  ## List issues.
  ## List all issues across all the authenticated user's visible repositories.
  ## 
  ##   state: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: string (required)
  ##   direction: string (required)
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  var query_39461037 = newJObject()
  var header_39461038 = newJObject()
  add(query_39461037, "state", newJString(state))
  add(header_39461038, "Accept", newJString(Accept))
  add(query_39461037, "labels", newJString(labels))
  add(query_39461037, "sort", newJString(sort))
  add(query_39461037, "direction", newJString(direction))
  add(query_39461037, "filter", newJString(filter))
  add(query_39461037, "since", newJString(since))
  result = call_39461036.call(nil, query_39461037, header_39461038, nil, nil)

var getIssues* = Call_GetIssues_39461011(name: "getIssues", meth: HttpMethod.HttpGet,
                                      host: "api.github.com", route: "/issues",
                                      validator: validate_GetIssues_39461012,
                                      base: "/", url: url_GetIssues_39461013,
                                      schemes: {Scheme.Https})
type
  Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_39461040 = ref object of OpenApiRestCall_39460352
proc url_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_39461042(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repository" in path, "`repository` is a required path parameter"
  assert "state" in path, "`state` is a required path parameter"
  assert "keyword" in path, "`keyword` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/issues/search/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repository"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "state"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "keyword")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_39461041(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## Find issues by state and keyword.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##   repository: JString (required)
  ##   keyword: JString (required)
  ##          : The search term.
  ##   state: JString (required)
  ##        : Indicates the state of the issues to return. Can be either open or closed.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461043 = path.getOrDefault("owner")
  valid_39461043 = validateParameter(valid_39461043, JString, required = true,
                                   default = nil)
  if valid_39461043 != nil:
    section.add "owner", valid_39461043
  var valid_39461044 = path.getOrDefault("repository")
  valid_39461044 = validateParameter(valid_39461044, JString, required = true,
                                   default = nil)
  if valid_39461044 != nil:
    section.add "repository", valid_39461044
  var valid_39461045 = path.getOrDefault("keyword")
  valid_39461045 = validateParameter(valid_39461045, JString, required = true,
                                   default = nil)
  if valid_39461045 != nil:
    section.add "keyword", valid_39461045
  var valid_39461046 = path.getOrDefault("state")
  valid_39461046 = validateParameter(valid_39461046, JString, required = true,
                                   default = newJString("open"))
  if valid_39461046 != nil:
    section.add "state", valid_39461046
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461047 = header.getOrDefault("Accept")
  valid_39461047 = validateParameter(valid_39461047, JString, required = false,
                                   default = nil)
  if valid_39461047 != nil:
    section.add "Accept", valid_39461047
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461048: Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_39461040;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Find issues by state and keyword.
  ## 
  let valid = call_39461048.validator(path, query, header, formData, body, _)
  let scheme = call_39461048.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461048.url(scheme.get, call_39461048.host, call_39461048.base,
                           call_39461048.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461048, uri, valid, _)

proc call*(call_39461049: Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_39461040;
          owner: string; repository: string; keyword: string; Accept: string = "";
          state: string = "open"): Recallable =
  ## getLegacyIssuesSearchOwnerRepositoryStateKeyword
  ## Find issues by state and keyword.
  ##   owner: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repository: string (required)
  ##   keyword: string (required)
  ##          : The search term.
  ##   state: string (required)
  ##        : Indicates the state of the issues to return. Can be either open or closed.
  var path_39461050 = newJObject()
  var header_39461051 = newJObject()
  add(path_39461050, "owner", newJString(owner))
  add(header_39461051, "Accept", newJString(Accept))
  add(path_39461050, "repository", newJString(repository))
  add(path_39461050, "keyword", newJString(keyword))
  add(path_39461050, "state", newJString(state))
  result = call_39461049.call(path_39461050, nil, header_39461051, nil, nil)

var getLegacyIssuesSearchOwnerRepositoryStateKeyword* = Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_39461040(
    name: "getLegacyIssuesSearchOwnerRepositoryStateKeyword",
    meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/legacy/issues/search/{owner}/{repository}/{state}/{keyword}",
    validator: validate_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_39461041,
    base: "/", url: url_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_39461042,
    schemes: {Scheme.Https})
type
  Call_GetLegacyReposSearchKeyword_39461052 = ref object of OpenApiRestCall_39460352
proc url_GetLegacyReposSearchKeyword_39461054(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyword" in path, "`keyword` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/repos/search/"),
               (kind: VariableSegment, value: "keyword")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyReposSearchKeyword_39461053(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Find repositories by keyword. Note, this legacy method does not follow the v3 pagination pattern. This method returns up to 100 results per page and pages can be fetched using the start_page parameter.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyword: JString (required)
  ##          : The search term
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyword` field"
  var valid_39461055 = path.getOrDefault("keyword")
  valid_39461055 = validateParameter(valid_39461055, JString, required = true,
                                   default = nil)
  if valid_39461055 != nil:
    section.add "keyword", valid_39461055
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   language: JString
  ##           : Filter results by language
  ##   start_page: JString
  ##             : The page number to fetch
  ##   sort: JString
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  section = newJObject()
  var valid_39461056 = query.getOrDefault("order")
  valid_39461056 = validateParameter(valid_39461056, JString, required = false,
                                   default = newJString("desc"))
  if valid_39461056 != nil:
    section.add "order", valid_39461056
  var valid_39461057 = query.getOrDefault("language")
  valid_39461057 = validateParameter(valid_39461057, JString, required = false,
                                   default = nil)
  if valid_39461057 != nil:
    section.add "language", valid_39461057
  var valid_39461058 = query.getOrDefault("start_page")
  valid_39461058 = validateParameter(valid_39461058, JString, required = false,
                                   default = nil)
  if valid_39461058 != nil:
    section.add "start_page", valid_39461058
  var valid_39461059 = query.getOrDefault("sort")
  valid_39461059 = validateParameter(valid_39461059, JString, required = false,
                                   default = newJString("updated"))
  if valid_39461059 != nil:
    section.add "sort", valid_39461059
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461060 = header.getOrDefault("Accept")
  valid_39461060 = validateParameter(valid_39461060, JString, required = false,
                                   default = nil)
  if valid_39461060 != nil:
    section.add "Accept", valid_39461060
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461061: Call_GetLegacyReposSearchKeyword_39461052;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Find repositories by keyword. Note, this legacy method does not follow the v3 pagination pattern. This method returns up to 100 results per page and pages can be fetched using the start_page parameter.
  ## 
  let valid = call_39461061.validator(path, query, header, formData, body, _)
  let scheme = call_39461061.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461061.url(scheme.get, call_39461061.host, call_39461061.base,
                           call_39461061.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461061, uri, valid, _)

proc call*(call_39461062: Call_GetLegacyReposSearchKeyword_39461052;
          keyword: string; order: string = "desc"; language: string = "";
          Accept: string = ""; startPage: string = ""; sort: string = "updated"): Recallable =
  ## getLegacyReposSearchKeyword
  ## Find repositories by keyword. Note, this legacy method does not follow the v3 pagination pattern. This method returns up to 100 results per page and pages can be fetched using the start_page parameter.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   language: string
  ##           : Filter results by language
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   startPage: string
  ##            : The page number to fetch
  ##   sort: string
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  ##   keyword: string (required)
  ##          : The search term
  var path_39461063 = newJObject()
  var query_39461064 = newJObject()
  var header_39461065 = newJObject()
  add(query_39461064, "order", newJString(order))
  add(query_39461064, "language", newJString(language))
  add(header_39461065, "Accept", newJString(Accept))
  add(query_39461064, "start_page", newJString(startPage))
  add(query_39461064, "sort", newJString(sort))
  add(path_39461063, "keyword", newJString(keyword))
  result = call_39461062.call(path_39461063, query_39461064, header_39461065, nil, nil)

var getLegacyReposSearchKeyword* = Call_GetLegacyReposSearchKeyword_39461052(
    name: "getLegacyReposSearchKeyword", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/legacy/repos/search/{keyword}",
    validator: validate_GetLegacyReposSearchKeyword_39461053, base: "/",
    url: url_GetLegacyReposSearchKeyword_39461054, schemes: {Scheme.Https})
type
  Call_GetLegacyUserEmailEmail_39461066 = ref object of OpenApiRestCall_39460352
proc url_GetLegacyUserEmailEmail_39461068(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "email" in path, "`email` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/user/email/"),
               (kind: VariableSegment, value: "email")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyUserEmailEmail_39461067(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## This API call is added for compatibility reasons only.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   email: JString (required)
  ##        : The email address
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `email` field"
  var valid_39461069 = path.getOrDefault("email")
  valid_39461069 = validateParameter(valid_39461069, JString, required = true,
                                   default = nil)
  if valid_39461069 != nil:
    section.add "email", valid_39461069
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461070 = header.getOrDefault("Accept")
  valid_39461070 = validateParameter(valid_39461070, JString, required = false,
                                   default = nil)
  if valid_39461070 != nil:
    section.add "Accept", valid_39461070
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461071: Call_GetLegacyUserEmailEmail_39461066;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## This API call is added for compatibility reasons only.
  ## 
  let valid = call_39461071.validator(path, query, header, formData, body, _)
  let scheme = call_39461071.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461071.url(scheme.get, call_39461071.host, call_39461071.base,
                           call_39461071.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461071, uri, valid, _)

proc call*(call_39461072: Call_GetLegacyUserEmailEmail_39461066; email: string;
          Accept: string = ""): Recallable =
  ## getLegacyUserEmailEmail
  ## This API call is added for compatibility reasons only.
  ##   email: string (required)
  ##        : The email address
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39461073 = newJObject()
  var header_39461074 = newJObject()
  add(path_39461073, "email", newJString(email))
  add(header_39461074, "Accept", newJString(Accept))
  result = call_39461072.call(path_39461073, nil, header_39461074, nil, nil)

var getLegacyUserEmailEmail* = Call_GetLegacyUserEmailEmail_39461066(
    name: "getLegacyUserEmailEmail", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/legacy/user/email/{email}",
    validator: validate_GetLegacyUserEmailEmail_39461067, base: "/",
    url: url_GetLegacyUserEmailEmail_39461068, schemes: {Scheme.Https})
type
  Call_GetLegacyUserSearchKeyword_39461075 = ref object of OpenApiRestCall_39460352
proc url_GetLegacyUserSearchKeyword_39461077(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyword" in path, "`keyword` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/user/search/"),
               (kind: VariableSegment, value: "keyword")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyUserSearchKeyword_39461076(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Find users by keyword.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyword: JString (required)
  ##          : The search term
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyword` field"
  var valid_39461078 = path.getOrDefault("keyword")
  valid_39461078 = validateParameter(valid_39461078, JString, required = true,
                                   default = nil)
  if valid_39461078 != nil:
    section.add "keyword", valid_39461078
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   start_page: JString
  ##             : The page number to fetch
  ##   sort: JString
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  section = newJObject()
  var valid_39461079 = query.getOrDefault("order")
  valid_39461079 = validateParameter(valid_39461079, JString, required = false,
                                   default = newJString("desc"))
  if valid_39461079 != nil:
    section.add "order", valid_39461079
  var valid_39461080 = query.getOrDefault("start_page")
  valid_39461080 = validateParameter(valid_39461080, JString, required = false,
                                   default = nil)
  if valid_39461080 != nil:
    section.add "start_page", valid_39461080
  var valid_39461081 = query.getOrDefault("sort")
  valid_39461081 = validateParameter(valid_39461081, JString, required = false,
                                   default = newJString("updated"))
  if valid_39461081 != nil:
    section.add "sort", valid_39461081
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461082 = header.getOrDefault("Accept")
  valid_39461082 = validateParameter(valid_39461082, JString, required = false,
                                   default = nil)
  if valid_39461082 != nil:
    section.add "Accept", valid_39461082
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461083: Call_GetLegacyUserSearchKeyword_39461075;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Find users by keyword.
  ## 
  let valid = call_39461083.validator(path, query, header, formData, body, _)
  let scheme = call_39461083.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461083.url(scheme.get, call_39461083.host, call_39461083.base,
                           call_39461083.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461083, uri, valid, _)

proc call*(call_39461084: Call_GetLegacyUserSearchKeyword_39461075;
          keyword: string; order: string = "desc"; Accept: string = "";
          startPage: string = ""; sort: string = "updated"): Recallable =
  ## getLegacyUserSearchKeyword
  ## Find users by keyword.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   startPage: string
  ##            : The page number to fetch
  ##   sort: string
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  ##   keyword: string (required)
  ##          : The search term
  var path_39461085 = newJObject()
  var query_39461086 = newJObject()
  var header_39461087 = newJObject()
  add(query_39461086, "order", newJString(order))
  add(header_39461087, "Accept", newJString(Accept))
  add(query_39461086, "start_page", newJString(startPage))
  add(query_39461086, "sort", newJString(sort))
  add(path_39461085, "keyword", newJString(keyword))
  result = call_39461084.call(path_39461085, query_39461086, header_39461087, nil, nil)

var getLegacyUserSearchKeyword* = Call_GetLegacyUserSearchKeyword_39461075(
    name: "getLegacyUserSearchKeyword", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/legacy/user/search/{keyword}",
    validator: validate_GetLegacyUserSearchKeyword_39461076, base: "/",
    url: url_GetLegacyUserSearchKeyword_39461077, schemes: {Scheme.Https})
type
  Call_PostMarkdown_39461088 = ref object of OpenApiRestCall_39460352
proc url_PostMarkdown_39461090(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostMarkdown_39461089(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## Render an arbitrary Markdown document
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461091 = header.getOrDefault("Accept")
  valid_39461091 = validateParameter(valid_39461091, JString, required = false,
                                   default = nil)
  if valid_39461091 != nil:
    section.add "Accept", valid_39461091
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39461093: Call_PostMarkdown_39461088; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Render an arbitrary Markdown document
  ## 
  let valid = call_39461093.validator(path, query, header, formData, body, _)
  let scheme = call_39461093.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461093.url(scheme.get, call_39461093.host, call_39461093.base,
                           call_39461093.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461093, uri, valid, _)

proc call*(call_39461094: Call_PostMarkdown_39461088; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postMarkdown
  ## Render an arbitrary Markdown document
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_39461095 = newJObject()
  var body_39461096 = newJObject()
  add(header_39461095, "Accept", newJString(Accept))
  if body != nil:
    body_39461096 = body
  result = call_39461094.call(nil, nil, header_39461095, nil, body_39461096)

var postMarkdown* = Call_PostMarkdown_39461088(name: "postMarkdown",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/markdown",
    validator: validate_PostMarkdown_39461089, base: "/", url: url_PostMarkdown_39461090,
    schemes: {Scheme.Https})
type
  Call_PostMarkdownRaw_39461097 = ref object of OpenApiRestCall_39460352
proc url_PostMarkdownRaw_39461099(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostMarkdownRaw_39461098(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Render a Markdown document in raw mode
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461100 = header.getOrDefault("Accept")
  valid_39461100 = validateParameter(valid_39461100, JString, required = false,
                                   default = nil)
  if valid_39461100 != nil:
    section.add "Accept", valid_39461100
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461101: Call_PostMarkdownRaw_39461097; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Render a Markdown document in raw mode
  ## 
  let valid = call_39461101.validator(path, query, header, formData, body, _)
  let scheme = call_39461101.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461101.url(scheme.get, call_39461101.host, call_39461101.base,
                           call_39461101.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461101, uri, valid, _)

proc call*(call_39461102: Call_PostMarkdownRaw_39461097; Accept: string = ""): Recallable =
  ## postMarkdownRaw
  ## Render a Markdown document in raw mode
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_39461103 = newJObject()
  add(header_39461103, "Accept", newJString(Accept))
  result = call_39461102.call(nil, nil, header_39461103, nil, nil)

var postMarkdownRaw* = Call_PostMarkdownRaw_39461097(name: "postMarkdownRaw",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/markdown/raw",
    validator: validate_PostMarkdownRaw_39461098, base: "/",
    url: url_PostMarkdownRaw_39461099, schemes: {Scheme.Https})
type
  Call_GetMeta_39461104 = ref object of OpenApiRestCall_39460352
proc url_GetMeta_39461106(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetMeta_39461105(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## This gives some information about GitHub.com, the service.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461107 = header.getOrDefault("Accept")
  valid_39461107 = validateParameter(valid_39461107, JString, required = false,
                                   default = nil)
  if valid_39461107 != nil:
    section.add "Accept", valid_39461107
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461108: Call_GetMeta_39461104; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## This gives some information about GitHub.com, the service.
  ## 
  let valid = call_39461108.validator(path, query, header, formData, body, _)
  let scheme = call_39461108.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461108.url(scheme.get, call_39461108.host, call_39461108.base,
                           call_39461108.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461108, uri, valid, _)

proc call*(call_39461109: Call_GetMeta_39461104; Accept: string = ""): Recallable =
  ## getMeta
  ## This gives some information about GitHub.com, the service.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_39461110 = newJObject()
  add(header_39461110, "Accept", newJString(Accept))
  result = call_39461109.call(nil, nil, header_39461110, nil, nil)

var getMeta* = Call_GetMeta_39461104(name: "getMeta", meth: HttpMethod.HttpGet,
                                  host: "api.github.com", route: "/meta",
                                  validator: validate_GetMeta_39461105, base: "/",
                                  url: url_GetMeta_39461106,
                                  schemes: {Scheme.Https})
type
  Call_GetNetworksOwnerRepoEvents_39461111 = ref object of OpenApiRestCall_39460352
proc url_GetNetworksOwnerRepoEvents_39461113(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/networks/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetNetworksOwnerRepoEvents_39461112(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List public events for a network of repositories.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of the owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461114 = path.getOrDefault("owner")
  valid_39461114 = validateParameter(valid_39461114, JString, required = true,
                                   default = nil)
  if valid_39461114 != nil:
    section.add "owner", valid_39461114
  var valid_39461115 = path.getOrDefault("repo")
  valid_39461115 = validateParameter(valid_39461115, JString, required = true,
                                   default = nil)
  if valid_39461115 != nil:
    section.add "repo", valid_39461115
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461116 = header.getOrDefault("Accept")
  valid_39461116 = validateParameter(valid_39461116, JString, required = false,
                                   default = nil)
  if valid_39461116 != nil:
    section.add "Accept", valid_39461116
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461117: Call_GetNetworksOwnerRepoEvents_39461111;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List public events for a network of repositories.
  ## 
  let valid = call_39461117.validator(path, query, header, formData, body, _)
  let scheme = call_39461117.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461117.url(scheme.get, call_39461117.host, call_39461117.base,
                           call_39461117.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461117, uri, valid, _)

proc call*(call_39461118: Call_GetNetworksOwnerRepoEvents_39461111; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getNetworksOwnerRepoEvents
  ## List public events for a network of repositories.
  ##   owner: string (required)
  ##        : Name of the owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461119 = newJObject()
  var header_39461120 = newJObject()
  add(path_39461119, "owner", newJString(owner))
  add(header_39461120, "Accept", newJString(Accept))
  add(path_39461119, "repo", newJString(repo))
  result = call_39461118.call(path_39461119, nil, header_39461120, nil, nil)

var getNetworksOwnerRepoEvents* = Call_GetNetworksOwnerRepoEvents_39461111(
    name: "getNetworksOwnerRepoEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/networks/{owner}/{repo}/events",
    validator: validate_GetNetworksOwnerRepoEvents_39461112, base: "/",
    url: url_GetNetworksOwnerRepoEvents_39461113, schemes: {Scheme.Https})
type
  Call_PutNotifications_39461132 = ref object of OpenApiRestCall_39460352
proc url_PutNotifications_39461134(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PutNotifications_39461133(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Mark as read.
  ## Marking a notification as "read" removes it from the default view on GitHub.com.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461135 = header.getOrDefault("Accept")
  valid_39461135 = validateParameter(valid_39461135, JString, required = false,
                                   default = nil)
  if valid_39461135 != nil:
    section.add "Accept", valid_39461135
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39461137: Call_PutNotifications_39461132; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Mark as read.
  ## Marking a notification as "read" removes it from the default view on GitHub.com.
  ## 
  ## 
  let valid = call_39461137.validator(path, query, header, formData, body, _)
  let scheme = call_39461137.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461137.url(scheme.get, call_39461137.host, call_39461137.base,
                           call_39461137.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461137, uri, valid, _)

proc call*(call_39461138: Call_PutNotifications_39461132; body: JsonNode;
          Accept: string = ""): Recallable =
  ## putNotifications
  ## Mark as read.
  ## Marking a notification as "read" removes it from the default view on GitHub.com.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_39461139 = newJObject()
  var body_39461140 = newJObject()
  add(header_39461139, "Accept", newJString(Accept))
  if body != nil:
    body_39461140 = body
  result = call_39461138.call(nil, nil, header_39461139, nil, body_39461140)

var putNotifications* = Call_PutNotifications_39461132(name: "putNotifications",
    meth: HttpMethod.HttpPut, host: "api.github.com", route: "/notifications",
    validator: validate_PutNotifications_39461133, base: "/",
    url: url_PutNotifications_39461134, schemes: {Scheme.Https})
type
  Call_GetNotifications_39461121 = ref object of OpenApiRestCall_39460352
proc url_GetNotifications_39461123(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetNotifications_39461122(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List your notifications.
  ## List all notifications for the current user, grouped by repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   participating: JBool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  ##   all: JBool
  ##      : True to show notifications marked as read.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_39461124 = query.getOrDefault("participating")
  valid_39461124 = validateParameter(valid_39461124, JBool, required = false,
                                   default = nil)
  if valid_39461124 != nil:
    section.add "participating", valid_39461124
  var valid_39461125 = query.getOrDefault("all")
  valid_39461125 = validateParameter(valid_39461125, JBool, required = false,
                                   default = nil)
  if valid_39461125 != nil:
    section.add "all", valid_39461125
  var valid_39461126 = query.getOrDefault("since")
  valid_39461126 = validateParameter(valid_39461126, JString, required = false,
                                   default = nil)
  if valid_39461126 != nil:
    section.add "since", valid_39461126
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461127 = header.getOrDefault("Accept")
  valid_39461127 = validateParameter(valid_39461127, JString, required = false,
                                   default = nil)
  if valid_39461127 != nil:
    section.add "Accept", valid_39461127
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461128: Call_GetNotifications_39461121; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List your notifications.
  ## List all notifications for the current user, grouped by repository.
  ## 
  ## 
  let valid = call_39461128.validator(path, query, header, formData, body, _)
  let scheme = call_39461128.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461128.url(scheme.get, call_39461128.host, call_39461128.base,
                           call_39461128.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461128, uri, valid, _)

proc call*(call_39461129: Call_GetNotifications_39461121;
          participating: bool = false; all: bool = false; Accept: string = "";
          since: string = ""): Recallable =
  ## getNotifications
  ## List your notifications.
  ## List all notifications for the current user, grouped by repository.
  ## 
  ##   participating: bool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  ##   all: bool
  ##      : True to show notifications marked as read.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var query_39461130 = newJObject()
  var header_39461131 = newJObject()
  add(query_39461130, "participating", newJBool(participating))
  add(query_39461130, "all", newJBool(all))
  add(header_39461131, "Accept", newJString(Accept))
  add(query_39461130, "since", newJString(since))
  result = call_39461129.call(nil, query_39461130, header_39461131, nil, nil)

var getNotifications* = Call_GetNotifications_39461121(name: "getNotifications",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/notifications",
    validator: validate_GetNotifications_39461122, base: "/",
    url: url_GetNotifications_39461123, schemes: {Scheme.Https})
type
  Call_GetNotificationsThreadsId_39461141 = ref object of OpenApiRestCall_39460352
proc url_GetNotificationsThreadsId_39461143(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetNotificationsThreadsId_39461142(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## View a single thread.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39461144 = path.getOrDefault("id")
  valid_39461144 = validateParameter(valid_39461144, JInt, required = true,
                                   default = nil)
  if valid_39461144 != nil:
    section.add "id", valid_39461144
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461145 = header.getOrDefault("Accept")
  valid_39461145 = validateParameter(valid_39461145, JString, required = false,
                                   default = nil)
  if valid_39461145 != nil:
    section.add "Accept", valid_39461145
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461146: Call_GetNotificationsThreadsId_39461141;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## View a single thread.
  ## 
  let valid = call_39461146.validator(path, query, header, formData, body, _)
  let scheme = call_39461146.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461146.url(scheme.get, call_39461146.host, call_39461146.base,
                           call_39461146.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461146, uri, valid, _)

proc call*(call_39461147: Call_GetNotificationsThreadsId_39461141; id: int;
          Accept: string = ""): Recallable =
  ## getNotificationsThreadsId
  ## View a single thread.
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39461148 = newJObject()
  var header_39461149 = newJObject()
  add(path_39461148, "id", newJInt(id))
  add(header_39461149, "Accept", newJString(Accept))
  result = call_39461147.call(path_39461148, nil, header_39461149, nil, nil)

var getNotificationsThreadsId* = Call_GetNotificationsThreadsId_39461141(
    name: "getNotificationsThreadsId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/notifications/threads/{id}",
    validator: validate_GetNotificationsThreadsId_39461142, base: "/",
    url: url_GetNotificationsThreadsId_39461143, schemes: {Scheme.Https})
type
  Call_PatchNotificationsThreadsId_39461150 = ref object of OpenApiRestCall_39460352
proc url_PatchNotificationsThreadsId_39461152(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchNotificationsThreadsId_39461151(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Mark a thread as read
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39461153 = path.getOrDefault("id")
  valid_39461153 = validateParameter(valid_39461153, JInt, required = true,
                                   default = nil)
  if valid_39461153 != nil:
    section.add "id", valid_39461153
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461154 = header.getOrDefault("Accept")
  valid_39461154 = validateParameter(valid_39461154, JString, required = false,
                                   default = nil)
  if valid_39461154 != nil:
    section.add "Accept", valid_39461154
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461155: Call_PatchNotificationsThreadsId_39461150;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Mark a thread as read
  ## 
  let valid = call_39461155.validator(path, query, header, formData, body, _)
  let scheme = call_39461155.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461155.url(scheme.get, call_39461155.host, call_39461155.base,
                           call_39461155.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461155, uri, valid, _)

proc call*(call_39461156: Call_PatchNotificationsThreadsId_39461150; id: int;
          Accept: string = ""): Recallable =
  ## patchNotificationsThreadsId
  ## Mark a thread as read
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39461157 = newJObject()
  var header_39461158 = newJObject()
  add(path_39461157, "id", newJInt(id))
  add(header_39461158, "Accept", newJString(Accept))
  result = call_39461156.call(path_39461157, nil, header_39461158, nil, nil)

var patchNotificationsThreadsId* = Call_PatchNotificationsThreadsId_39461150(
    name: "patchNotificationsThreadsId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/notifications/threads/{id}",
    validator: validate_PatchNotificationsThreadsId_39461151, base: "/",
    url: url_PatchNotificationsThreadsId_39461152, schemes: {Scheme.Https})
type
  Call_PutNotificationsThreadsIdSubscription_39461168 = ref object of OpenApiRestCall_39460352
proc url_PutNotificationsThreadsIdSubscription_39461170(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutNotificationsThreadsIdSubscription_39461169(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Set a Thread Subscription.
  ## This lets you subscribe to a thread, or ignore it. Subscribing to a thread
  ## is unnecessary if the user is already subscribed to the repository. Ignoring
  ## a thread will mute all future notifications (until you comment or get @mentioned).
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39461171 = path.getOrDefault("id")
  valid_39461171 = validateParameter(valid_39461171, JInt, required = true,
                                   default = nil)
  if valid_39461171 != nil:
    section.add "id", valid_39461171
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461172 = header.getOrDefault("Accept")
  valid_39461172 = validateParameter(valid_39461172, JString, required = false,
                                   default = nil)
  if valid_39461172 != nil:
    section.add "Accept", valid_39461172
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39461174: Call_PutNotificationsThreadsIdSubscription_39461168;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Set a Thread Subscription.
  ## This lets you subscribe to a thread, or ignore it. Subscribing to a thread
  ## is unnecessary if the user is already subscribed to the repository. Ignoring
  ## a thread will mute all future notifications (until you comment or get @mentioned).
  ## 
  ## 
  let valid = call_39461174.validator(path, query, header, formData, body, _)
  let scheme = call_39461174.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461174.url(scheme.get, call_39461174.host, call_39461174.base,
                           call_39461174.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461174, uri, valid, _)

proc call*(call_39461175: Call_PutNotificationsThreadsIdSubscription_39461168;
          id: int; body: JsonNode; Accept: string = ""): Recallable =
  ## putNotificationsThreadsIdSubscription
  ## Set a Thread Subscription.
  ## This lets you subscribe to a thread, or ignore it. Subscribing to a thread
  ## is unnecessary if the user is already subscribed to the repository. Ignoring
  ## a thread will mute all future notifications (until you comment or get @mentioned).
  ## 
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var path_39461176 = newJObject()
  var header_39461177 = newJObject()
  var body_39461178 = newJObject()
  add(path_39461176, "id", newJInt(id))
  add(header_39461177, "Accept", newJString(Accept))
  if body != nil:
    body_39461178 = body
  result = call_39461175.call(path_39461176, nil, header_39461177, nil, body_39461178)

var putNotificationsThreadsIdSubscription* = Call_PutNotificationsThreadsIdSubscription_39461168(
    name: "putNotificationsThreadsIdSubscription", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/notifications/threads/{id}/subscription",
    validator: validate_PutNotificationsThreadsIdSubscription_39461169, base: "/",
    url: url_PutNotificationsThreadsIdSubscription_39461170,
    schemes: {Scheme.Https})
type
  Call_GetNotificationsThreadsIdSubscription_39461159 = ref object of OpenApiRestCall_39460352
proc url_GetNotificationsThreadsIdSubscription_39461161(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetNotificationsThreadsIdSubscription_39461160(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a Thread Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39461162 = path.getOrDefault("id")
  valid_39461162 = validateParameter(valid_39461162, JInt, required = true,
                                   default = nil)
  if valid_39461162 != nil:
    section.add "id", valid_39461162
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461163 = header.getOrDefault("Accept")
  valid_39461163 = validateParameter(valid_39461163, JString, required = false,
                                   default = nil)
  if valid_39461163 != nil:
    section.add "Accept", valid_39461163
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461164: Call_GetNotificationsThreadsIdSubscription_39461159;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a Thread Subscription.
  ## 
  let valid = call_39461164.validator(path, query, header, formData, body, _)
  let scheme = call_39461164.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461164.url(scheme.get, call_39461164.host, call_39461164.base,
                           call_39461164.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461164, uri, valid, _)

proc call*(call_39461165: Call_GetNotificationsThreadsIdSubscription_39461159;
          id: int; Accept: string = ""): Recallable =
  ## getNotificationsThreadsIdSubscription
  ## Get a Thread Subscription.
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39461166 = newJObject()
  var header_39461167 = newJObject()
  add(path_39461166, "id", newJInt(id))
  add(header_39461167, "Accept", newJString(Accept))
  result = call_39461165.call(path_39461166, nil, header_39461167, nil, nil)

var getNotificationsThreadsIdSubscription* = Call_GetNotificationsThreadsIdSubscription_39461159(
    name: "getNotificationsThreadsIdSubscription", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/notifications/threads/{id}/subscription",
    validator: validate_GetNotificationsThreadsIdSubscription_39461160, base: "/",
    url: url_GetNotificationsThreadsIdSubscription_39461161,
    schemes: {Scheme.Https})
type
  Call_DeleteNotificationsThreadsIdSubscription_39461179 = ref object of OpenApiRestCall_39460352
proc url_DeleteNotificationsThreadsIdSubscription_39461181(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteNotificationsThreadsIdSubscription_39461180(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a Thread Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39461182 = path.getOrDefault("id")
  valid_39461182 = validateParameter(valid_39461182, JInt, required = true,
                                   default = nil)
  if valid_39461182 != nil:
    section.add "id", valid_39461182
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461183 = header.getOrDefault("Accept")
  valid_39461183 = validateParameter(valid_39461183, JString, required = false,
                                   default = nil)
  if valid_39461183 != nil:
    section.add "Accept", valid_39461183
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461184: Call_DeleteNotificationsThreadsIdSubscription_39461179;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a Thread Subscription.
  ## 
  let valid = call_39461184.validator(path, query, header, formData, body, _)
  let scheme = call_39461184.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461184.url(scheme.get, call_39461184.host, call_39461184.base,
                           call_39461184.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461184, uri, valid, _)

proc call*(call_39461185: Call_DeleteNotificationsThreadsIdSubscription_39461179;
          id: int; Accept: string = ""): Recallable =
  ## deleteNotificationsThreadsIdSubscription
  ## Delete a Thread Subscription.
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39461186 = newJObject()
  var header_39461187 = newJObject()
  add(path_39461186, "id", newJInt(id))
  add(header_39461187, "Accept", newJString(Accept))
  result = call_39461185.call(path_39461186, nil, header_39461187, nil, nil)

var deleteNotificationsThreadsIdSubscription* = Call_DeleteNotificationsThreadsIdSubscription_39461179(
    name: "deleteNotificationsThreadsIdSubscription", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/notifications/threads/{id}/subscription",
    validator: validate_DeleteNotificationsThreadsIdSubscription_39461180,
    base: "/", url: url_DeleteNotificationsThreadsIdSubscription_39461181,
    schemes: {Scheme.Https})
type
  Call_GetOrgsOrg_39461188 = ref object of OpenApiRestCall_39460352
proc url_GetOrgsOrg_39461190(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrg_39461189(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get an Organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_39461191 = path.getOrDefault("org")
  valid_39461191 = validateParameter(valid_39461191, JString, required = true,
                                   default = nil)
  if valid_39461191 != nil:
    section.add "org", valid_39461191
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461192 = header.getOrDefault("Accept")
  valid_39461192 = validateParameter(valid_39461192, JString, required = false,
                                   default = nil)
  if valid_39461192 != nil:
    section.add "Accept", valid_39461192
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461193: Call_GetOrgsOrg_39461188; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get an Organization.
  ## 
  let valid = call_39461193.validator(path, query, header, formData, body, _)
  let scheme = call_39461193.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461193.url(scheme.get, call_39461193.host, call_39461193.base,
                           call_39461193.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461193, uri, valid, _)

proc call*(call_39461194: Call_GetOrgsOrg_39461188; org: string; Accept: string = ""): Recallable =
  ## getOrgsOrg
  ## Get an Organization.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_39461195 = newJObject()
  var header_39461196 = newJObject()
  add(header_39461196, "Accept", newJString(Accept))
  add(path_39461195, "org", newJString(org))
  result = call_39461194.call(path_39461195, nil, header_39461196, nil, nil)

var getOrgsOrg* = Call_GetOrgsOrg_39461188(name: "getOrgsOrg",
                                        meth: HttpMethod.HttpGet,
                                        host: "api.github.com",
                                        route: "/orgs/{org}",
                                        validator: validate_GetOrgsOrg_39461189,
                                        base: "/", url: url_GetOrgsOrg_39461190,
                                        schemes: {Scheme.Https})
type
  Call_PatchOrgsOrg_39461197 = ref object of OpenApiRestCall_39460352
proc url_PatchOrgsOrg_39461199(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchOrgsOrg_39461198(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## Edit an Organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_39461200 = path.getOrDefault("org")
  valid_39461200 = validateParameter(valid_39461200, JString, required = true,
                                   default = nil)
  if valid_39461200 != nil:
    section.add "org", valid_39461200
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461201 = header.getOrDefault("Accept")
  valid_39461201 = validateParameter(valid_39461201, JString, required = false,
                                   default = nil)
  if valid_39461201 != nil:
    section.add "Accept", valid_39461201
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39461203: Call_PatchOrgsOrg_39461197; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit an Organization.
  ## 
  let valid = call_39461203.validator(path, query, header, formData, body, _)
  let scheme = call_39461203.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461203.url(scheme.get, call_39461203.host, call_39461203.base,
                           call_39461203.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461203, uri, valid, _)

proc call*(call_39461204: Call_PatchOrgsOrg_39461197; body: JsonNode; org: string;
          Accept: string = ""): Recallable =
  ## patchOrgsOrg
  ## Edit an Organization.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   org: string (required)
  ##      : Name of organisation.
  var path_39461205 = newJObject()
  var header_39461206 = newJObject()
  var body_39461207 = newJObject()
  add(header_39461206, "Accept", newJString(Accept))
  if body != nil:
    body_39461207 = body
  add(path_39461205, "org", newJString(org))
  result = call_39461204.call(path_39461205, nil, header_39461206, nil, body_39461207)

var patchOrgsOrg* = Call_PatchOrgsOrg_39461197(name: "patchOrgsOrg",
    meth: HttpMethod.HttpPatch, host: "api.github.com", route: "/orgs/{org}",
    validator: validate_PatchOrgsOrg_39461198, base: "/", url: url_PatchOrgsOrg_39461199,
    schemes: {Scheme.Https})
type
  Call_GetOrgsOrgEvents_39461208 = ref object of OpenApiRestCall_39460352
proc url_GetOrgsOrgEvents_39461210(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgEvents_39461209(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List public events for an organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_39461211 = path.getOrDefault("org")
  valid_39461211 = validateParameter(valid_39461211, JString, required = true,
                                   default = nil)
  if valid_39461211 != nil:
    section.add "org", valid_39461211
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461212 = header.getOrDefault("Accept")
  valid_39461212 = validateParameter(valid_39461212, JString, required = false,
                                   default = nil)
  if valid_39461212 != nil:
    section.add "Accept", valid_39461212
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461213: Call_GetOrgsOrgEvents_39461208; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List public events for an organization.
  ## 
  let valid = call_39461213.validator(path, query, header, formData, body, _)
  let scheme = call_39461213.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461213.url(scheme.get, call_39461213.host, call_39461213.base,
                           call_39461213.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461213, uri, valid, _)

proc call*(call_39461214: Call_GetOrgsOrgEvents_39461208; org: string;
          Accept: string = ""): Recallable =
  ## getOrgsOrgEvents
  ## List public events for an organization.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_39461215 = newJObject()
  var header_39461216 = newJObject()
  add(header_39461216, "Accept", newJString(Accept))
  add(path_39461215, "org", newJString(org))
  result = call_39461214.call(path_39461215, nil, header_39461216, nil, nil)

var getOrgsOrgEvents* = Call_GetOrgsOrgEvents_39461208(name: "getOrgsOrgEvents",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/events",
    validator: validate_GetOrgsOrgEvents_39461209, base: "/",
    url: url_GetOrgsOrgEvents_39461210, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgIssues_39461217 = ref object of OpenApiRestCall_39460352
proc url_GetOrgsOrgIssues_39461219(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/issues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgIssues_39461218(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List issues.
  ## List all issues for a given organization for the authenticated user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_39461220 = path.getOrDefault("org")
  valid_39461220 = validateParameter(valid_39461220, JString, required = true,
                                   default = nil)
  if valid_39461220 != nil:
    section.add "org", valid_39461220
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString (required)
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: JString (required)
  ##   direction: JString (required)
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_39461221 = query.getOrDefault("state")
  valid_39461221 = validateParameter(valid_39461221, JString, required = true,
                                   default = newJString("open"))
  if valid_39461221 != nil:
    section.add "state", valid_39461221
  var valid_39461222 = query.getOrDefault("labels")
  valid_39461222 = validateParameter(valid_39461222, JString, required = true,
                                   default = nil)
  if valid_39461222 != nil:
    section.add "labels", valid_39461222
  var valid_39461223 = query.getOrDefault("sort")
  valid_39461223 = validateParameter(valid_39461223, JString, required = true,
                                   default = newJString("created"))
  if valid_39461223 != nil:
    section.add "sort", valid_39461223
  var valid_39461224 = query.getOrDefault("direction")
  valid_39461224 = validateParameter(valid_39461224, JString, required = true,
                                   default = newJString("desc"))
  if valid_39461224 != nil:
    section.add "direction", valid_39461224
  var valid_39461225 = query.getOrDefault("filter")
  valid_39461225 = validateParameter(valid_39461225, JString, required = true,
                                   default = newJString("all"))
  if valid_39461225 != nil:
    section.add "filter", valid_39461225
  var valid_39461226 = query.getOrDefault("since")
  valid_39461226 = validateParameter(valid_39461226, JString, required = false,
                                   default = nil)
  if valid_39461226 != nil:
    section.add "since", valid_39461226
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461227 = header.getOrDefault("Accept")
  valid_39461227 = validateParameter(valid_39461227, JString, required = false,
                                   default = nil)
  if valid_39461227 != nil:
    section.add "Accept", valid_39461227
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461228: Call_GetOrgsOrgIssues_39461217; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List issues.
  ## List all issues for a given organization for the authenticated user.
  ## 
  ## 
  let valid = call_39461228.validator(path, query, header, formData, body, _)
  let scheme = call_39461228.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461228.url(scheme.get, call_39461228.host, call_39461228.base,
                           call_39461228.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461228, uri, valid, _)

proc call*(call_39461229: Call_GetOrgsOrgIssues_39461217; labels: string;
          org: string; state: string = "open"; Accept: string = "";
          sort: string = "created"; direction: string = "desc"; filter: string = "all";
          since: string = ""): Recallable =
  ## getOrgsOrgIssues
  ## List issues.
  ## List all issues for a given organization for the authenticated user.
  ## 
  ##   state: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: string (required)
  ##   direction: string (required)
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   org: string (required)
  ##      : Name of organisation.
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  var path_39461230 = newJObject()
  var query_39461231 = newJObject()
  var header_39461232 = newJObject()
  add(query_39461231, "state", newJString(state))
  add(header_39461232, "Accept", newJString(Accept))
  add(query_39461231, "labels", newJString(labels))
  add(query_39461231, "sort", newJString(sort))
  add(query_39461231, "direction", newJString(direction))
  add(query_39461231, "filter", newJString(filter))
  add(path_39461230, "org", newJString(org))
  add(query_39461231, "since", newJString(since))
  result = call_39461229.call(path_39461230, query_39461231, header_39461232, nil, nil)

var getOrgsOrgIssues* = Call_GetOrgsOrgIssues_39461217(name: "getOrgsOrgIssues",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/issues",
    validator: validate_GetOrgsOrgIssues_39461218, base: "/",
    url: url_GetOrgsOrgIssues_39461219, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgMembers_39461233 = ref object of OpenApiRestCall_39460352
proc url_GetOrgsOrgMembers_39461235(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/members")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgMembers_39461234(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Members list.
  ## List all users who are members of an organization. A member is a user tha
  ## belongs to at least 1 team in the organization. If the authenticated user
  ## is also an owner of this organization then both concealed and public members
  ## will be returned. If the requester is not an owner of the organization the
  ## query will be redirected to the public members list.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_39461236 = path.getOrDefault("org")
  valid_39461236 = validateParameter(valid_39461236, JString, required = true,
                                   default = nil)
  if valid_39461236 != nil:
    section.add "org", valid_39461236
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461237 = header.getOrDefault("Accept")
  valid_39461237 = validateParameter(valid_39461237, JString, required = false,
                                   default = nil)
  if valid_39461237 != nil:
    section.add "Accept", valid_39461237
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461238: Call_GetOrgsOrgMembers_39461233; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Members list.
  ## List all users who are members of an organization. A member is a user tha
  ## belongs to at least 1 team in the organization. If the authenticated user
  ## is also an owner of this organization then both concealed and public members
  ## will be returned. If the requester is not an owner of the organization the
  ## query will be redirected to the public members list.
  ## 
  ## 
  let valid = call_39461238.validator(path, query, header, formData, body, _)
  let scheme = call_39461238.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461238.url(scheme.get, call_39461238.host, call_39461238.base,
                           call_39461238.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461238, uri, valid, _)

proc call*(call_39461239: Call_GetOrgsOrgMembers_39461233; org: string;
          Accept: string = ""): Recallable =
  ## getOrgsOrgMembers
  ## Members list.
  ## List all users who are members of an organization. A member is a user tha
  ## belongs to at least 1 team in the organization. If the authenticated user
  ## is also an owner of this organization then both concealed and public members
  ## will be returned. If the requester is not an owner of the organization the
  ## query will be redirected to the public members list.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_39461240 = newJObject()
  var header_39461241 = newJObject()
  add(header_39461241, "Accept", newJString(Accept))
  add(path_39461240, "org", newJString(org))
  result = call_39461239.call(path_39461240, nil, header_39461241, nil, nil)

var getOrgsOrgMembers* = Call_GetOrgsOrgMembers_39461233(name: "getOrgsOrgMembers",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/members",
    validator: validate_GetOrgsOrgMembers_39461234, base: "/",
    url: url_GetOrgsOrgMembers_39461235, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgMembersUsername_39461242 = ref object of OpenApiRestCall_39460352
proc url_GetOrgsOrgMembersUsername_39461244(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgMembersUsername_39461243(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Check if a user is, publicly or privately, a member of the organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of the user.
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39461245 = path.getOrDefault("username")
  valid_39461245 = validateParameter(valid_39461245, JString, required = true,
                                   default = nil)
  if valid_39461245 != nil:
    section.add "username", valid_39461245
  var valid_39461246 = path.getOrDefault("org")
  valid_39461246 = validateParameter(valid_39461246, JString, required = true,
                                   default = nil)
  if valid_39461246 != nil:
    section.add "org", valid_39461246
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461247 = header.getOrDefault("Accept")
  valid_39461247 = validateParameter(valid_39461247, JString, required = false,
                                   default = nil)
  if valid_39461247 != nil:
    section.add "Accept", valid_39461247
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461248: Call_GetOrgsOrgMembersUsername_39461242;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if a user is, publicly or privately, a member of the organization.
  ## 
  let valid = call_39461248.validator(path, query, header, formData, body, _)
  let scheme = call_39461248.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461248.url(scheme.get, call_39461248.host, call_39461248.base,
                           call_39461248.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461248, uri, valid, _)

proc call*(call_39461249: Call_GetOrgsOrgMembersUsername_39461242;
          username: string; org: string; Accept: string = ""): Recallable =
  ## getOrgsOrgMembersUsername
  ## Check if a user is, publicly or privately, a member of the organization.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_39461250 = newJObject()
  var header_39461251 = newJObject()
  add(path_39461250, "username", newJString(username))
  add(header_39461251, "Accept", newJString(Accept))
  add(path_39461250, "org", newJString(org))
  result = call_39461249.call(path_39461250, nil, header_39461251, nil, nil)

var getOrgsOrgMembersUsername* = Call_GetOrgsOrgMembersUsername_39461242(
    name: "getOrgsOrgMembersUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/orgs/{org}/members/{username}",
    validator: validate_GetOrgsOrgMembersUsername_39461243, base: "/",
    url: url_GetOrgsOrgMembersUsername_39461244, schemes: {Scheme.Https})
type
  Call_DeleteOrgsOrgMembersUsername_39461252 = ref object of OpenApiRestCall_39460352
proc url_DeleteOrgsOrgMembersUsername_39461254(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteOrgsOrgMembersUsername_39461253(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Remove a member.
  ## Removing a user from this list will remove them from all teams and they
  ## will no longer have any access to the organization's repositories.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of the user.
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39461255 = path.getOrDefault("username")
  valid_39461255 = validateParameter(valid_39461255, JString, required = true,
                                   default = nil)
  if valid_39461255 != nil:
    section.add "username", valid_39461255
  var valid_39461256 = path.getOrDefault("org")
  valid_39461256 = validateParameter(valid_39461256, JString, required = true,
                                   default = nil)
  if valid_39461256 != nil:
    section.add "org", valid_39461256
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461257 = header.getOrDefault("Accept")
  valid_39461257 = validateParameter(valid_39461257, JString, required = false,
                                   default = nil)
  if valid_39461257 != nil:
    section.add "Accept", valid_39461257
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461258: Call_DeleteOrgsOrgMembersUsername_39461252;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Remove a member.
  ## Removing a user from this list will remove them from all teams and they
  ## will no longer have any access to the organization's repositories.
  ## 
  ## 
  let valid = call_39461258.validator(path, query, header, formData, body, _)
  let scheme = call_39461258.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461258.url(scheme.get, call_39461258.host, call_39461258.base,
                           call_39461258.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461258, uri, valid, _)

proc call*(call_39461259: Call_DeleteOrgsOrgMembersUsername_39461252;
          username: string; org: string; Accept: string = ""): Recallable =
  ## deleteOrgsOrgMembersUsername
  ## Remove a member.
  ## Removing a user from this list will remove them from all teams and they
  ## will no longer have any access to the organization's repositories.
  ## 
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_39461260 = newJObject()
  var header_39461261 = newJObject()
  add(path_39461260, "username", newJString(username))
  add(header_39461261, "Accept", newJString(Accept))
  add(path_39461260, "org", newJString(org))
  result = call_39461259.call(path_39461260, nil, header_39461261, nil, nil)

var deleteOrgsOrgMembersUsername* = Call_DeleteOrgsOrgMembersUsername_39461252(
    name: "deleteOrgsOrgMembersUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/orgs/{org}/members/{username}",
    validator: validate_DeleteOrgsOrgMembersUsername_39461253, base: "/",
    url: url_DeleteOrgsOrgMembersUsername_39461254, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgPublicMembers_39461262 = ref object of OpenApiRestCall_39460352
proc url_GetOrgsOrgPublicMembers_39461264(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/public_members")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgPublicMembers_39461263(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Public members list.
  ## Members of an organization can choose to have their membership publicized
  ## or not.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_39461265 = path.getOrDefault("org")
  valid_39461265 = validateParameter(valid_39461265, JString, required = true,
                                   default = nil)
  if valid_39461265 != nil:
    section.add "org", valid_39461265
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461266 = header.getOrDefault("Accept")
  valid_39461266 = validateParameter(valid_39461266, JString, required = false,
                                   default = nil)
  if valid_39461266 != nil:
    section.add "Accept", valid_39461266
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461267: Call_GetOrgsOrgPublicMembers_39461262;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Public members list.
  ## Members of an organization can choose to have their membership publicized
  ## or not.
  ## 
  ## 
  let valid = call_39461267.validator(path, query, header, formData, body, _)
  let scheme = call_39461267.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461267.url(scheme.get, call_39461267.host, call_39461267.base,
                           call_39461267.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461267, uri, valid, _)

proc call*(call_39461268: Call_GetOrgsOrgPublicMembers_39461262; org: string;
          Accept: string = ""): Recallable =
  ## getOrgsOrgPublicMembers
  ## Public members list.
  ## Members of an organization can choose to have their membership publicized
  ## or not.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_39461269 = newJObject()
  var header_39461270 = newJObject()
  add(header_39461270, "Accept", newJString(Accept))
  add(path_39461269, "org", newJString(org))
  result = call_39461268.call(path_39461269, nil, header_39461270, nil, nil)

var getOrgsOrgPublicMembers* = Call_GetOrgsOrgPublicMembers_39461262(
    name: "getOrgsOrgPublicMembers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/orgs/{org}/public_members",
    validator: validate_GetOrgsOrgPublicMembers_39461263, base: "/",
    url: url_GetOrgsOrgPublicMembers_39461264, schemes: {Scheme.Https})
type
  Call_PutOrgsOrgPublicMembersUsername_39461281 = ref object of OpenApiRestCall_39460352
proc url_PutOrgsOrgPublicMembersUsername_39461283(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/public_members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutOrgsOrgPublicMembersUsername_39461282(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Publicize a user's membership.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of the user.
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39461284 = path.getOrDefault("username")
  valid_39461284 = validateParameter(valid_39461284, JString, required = true,
                                   default = nil)
  if valid_39461284 != nil:
    section.add "username", valid_39461284
  var valid_39461285 = path.getOrDefault("org")
  valid_39461285 = validateParameter(valid_39461285, JString, required = true,
                                   default = nil)
  if valid_39461285 != nil:
    section.add "org", valid_39461285
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461286 = header.getOrDefault("Accept")
  valid_39461286 = validateParameter(valid_39461286, JString, required = false,
                                   default = nil)
  if valid_39461286 != nil:
    section.add "Accept", valid_39461286
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461287: Call_PutOrgsOrgPublicMembersUsername_39461281;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Publicize a user's membership.
  ## 
  let valid = call_39461287.validator(path, query, header, formData, body, _)
  let scheme = call_39461287.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461287.url(scheme.get, call_39461287.host, call_39461287.base,
                           call_39461287.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461287, uri, valid, _)

proc call*(call_39461288: Call_PutOrgsOrgPublicMembersUsername_39461281;
          username: string; org: string; Accept: string = ""): Recallable =
  ## putOrgsOrgPublicMembersUsername
  ## Publicize a user's membership.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_39461289 = newJObject()
  var header_39461290 = newJObject()
  add(path_39461289, "username", newJString(username))
  add(header_39461290, "Accept", newJString(Accept))
  add(path_39461289, "org", newJString(org))
  result = call_39461288.call(path_39461289, nil, header_39461290, nil, nil)

var putOrgsOrgPublicMembersUsername* = Call_PutOrgsOrgPublicMembersUsername_39461281(
    name: "putOrgsOrgPublicMembersUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/orgs/{org}/public_members/{username}",
    validator: validate_PutOrgsOrgPublicMembersUsername_39461282, base: "/",
    url: url_PutOrgsOrgPublicMembersUsername_39461283, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgPublicMembersUsername_39461271 = ref object of OpenApiRestCall_39460352
proc url_GetOrgsOrgPublicMembersUsername_39461273(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/public_members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgPublicMembersUsername_39461272(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Check public membership.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of the user.
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39461274 = path.getOrDefault("username")
  valid_39461274 = validateParameter(valid_39461274, JString, required = true,
                                   default = nil)
  if valid_39461274 != nil:
    section.add "username", valid_39461274
  var valid_39461275 = path.getOrDefault("org")
  valid_39461275 = validateParameter(valid_39461275, JString, required = true,
                                   default = nil)
  if valid_39461275 != nil:
    section.add "org", valid_39461275
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461276 = header.getOrDefault("Accept")
  valid_39461276 = validateParameter(valid_39461276, JString, required = false,
                                   default = nil)
  if valid_39461276 != nil:
    section.add "Accept", valid_39461276
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461277: Call_GetOrgsOrgPublicMembersUsername_39461271;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check public membership.
  ## 
  let valid = call_39461277.validator(path, query, header, formData, body, _)
  let scheme = call_39461277.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461277.url(scheme.get, call_39461277.host, call_39461277.base,
                           call_39461277.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461277, uri, valid, _)

proc call*(call_39461278: Call_GetOrgsOrgPublicMembersUsername_39461271;
          username: string; org: string; Accept: string = ""): Recallable =
  ## getOrgsOrgPublicMembersUsername
  ## Check public membership.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_39461279 = newJObject()
  var header_39461280 = newJObject()
  add(path_39461279, "username", newJString(username))
  add(header_39461280, "Accept", newJString(Accept))
  add(path_39461279, "org", newJString(org))
  result = call_39461278.call(path_39461279, nil, header_39461280, nil, nil)

var getOrgsOrgPublicMembersUsername* = Call_GetOrgsOrgPublicMembersUsername_39461271(
    name: "getOrgsOrgPublicMembersUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/orgs/{org}/public_members/{username}",
    validator: validate_GetOrgsOrgPublicMembersUsername_39461272, base: "/",
    url: url_GetOrgsOrgPublicMembersUsername_39461273, schemes: {Scheme.Https})
type
  Call_DeleteOrgsOrgPublicMembersUsername_39461291 = ref object of OpenApiRestCall_39460352
proc url_DeleteOrgsOrgPublicMembersUsername_39461293(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/public_members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteOrgsOrgPublicMembersUsername_39461292(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Conceal a user's membership.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of the user.
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39461294 = path.getOrDefault("username")
  valid_39461294 = validateParameter(valid_39461294, JString, required = true,
                                   default = nil)
  if valid_39461294 != nil:
    section.add "username", valid_39461294
  var valid_39461295 = path.getOrDefault("org")
  valid_39461295 = validateParameter(valid_39461295, JString, required = true,
                                   default = nil)
  if valid_39461295 != nil:
    section.add "org", valid_39461295
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461296 = header.getOrDefault("Accept")
  valid_39461296 = validateParameter(valid_39461296, JString, required = false,
                                   default = nil)
  if valid_39461296 != nil:
    section.add "Accept", valid_39461296
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461297: Call_DeleteOrgsOrgPublicMembersUsername_39461291;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Conceal a user's membership.
  ## 
  let valid = call_39461297.validator(path, query, header, formData, body, _)
  let scheme = call_39461297.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461297.url(scheme.get, call_39461297.host, call_39461297.base,
                           call_39461297.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461297, uri, valid, _)

proc call*(call_39461298: Call_DeleteOrgsOrgPublicMembersUsername_39461291;
          username: string; org: string; Accept: string = ""): Recallable =
  ## deleteOrgsOrgPublicMembersUsername
  ## Conceal a user's membership.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_39461299 = newJObject()
  var header_39461300 = newJObject()
  add(path_39461299, "username", newJString(username))
  add(header_39461300, "Accept", newJString(Accept))
  add(path_39461299, "org", newJString(org))
  result = call_39461298.call(path_39461299, nil, header_39461300, nil, nil)

var deleteOrgsOrgPublicMembersUsername* = Call_DeleteOrgsOrgPublicMembersUsername_39461291(
    name: "deleteOrgsOrgPublicMembersUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/orgs/{org}/public_members/{username}",
    validator: validate_DeleteOrgsOrgPublicMembersUsername_39461292, base: "/",
    url: url_DeleteOrgsOrgPublicMembersUsername_39461293, schemes: {Scheme.Https})
type
  Call_PostOrgsOrgRepos_39461312 = ref object of OpenApiRestCall_39460352
proc url_PostOrgsOrgRepos_39461314(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostOrgsOrgRepos_39461313(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_39461315 = path.getOrDefault("org")
  valid_39461315 = validateParameter(valid_39461315, JString, required = true,
                                   default = nil)
  if valid_39461315 != nil:
    section.add "org", valid_39461315
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461316 = header.getOrDefault("Accept")
  valid_39461316 = validateParameter(valid_39461316, JString, required = false,
                                   default = nil)
  if valid_39461316 != nil:
    section.add "Accept", valid_39461316
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39461318: Call_PostOrgsOrgRepos_39461312; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  let valid = call_39461318.validator(path, query, header, formData, body, _)
  let scheme = call_39461318.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461318.url(scheme.get, call_39461318.host, call_39461318.base,
                           call_39461318.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461318, uri, valid, _)

proc call*(call_39461319: Call_PostOrgsOrgRepos_39461312; body: JsonNode;
          org: string; Accept: string = ""): Recallable =
  ## postOrgsOrgRepos
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   org: string (required)
  ##      : Name of organisation.
  var path_39461320 = newJObject()
  var header_39461321 = newJObject()
  var body_39461322 = newJObject()
  add(header_39461321, "Accept", newJString(Accept))
  if body != nil:
    body_39461322 = body
  add(path_39461320, "org", newJString(org))
  result = call_39461319.call(path_39461320, nil, header_39461321, nil, body_39461322)

var postOrgsOrgRepos* = Call_PostOrgsOrgRepos_39461312(name: "postOrgsOrgRepos",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/orgs/{org}/repos",
    validator: validate_PostOrgsOrgRepos_39461313, base: "/",
    url: url_PostOrgsOrgRepos_39461314, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgRepos_39461301 = ref object of OpenApiRestCall_39460352
proc url_GetOrgsOrgRepos_39461303(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgRepos_39461302(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List repositories for the specified org.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_39461304 = path.getOrDefault("org")
  valid_39461304 = validateParameter(valid_39461304, JString, required = true,
                                   default = nil)
  if valid_39461304 != nil:
    section.add "org", valid_39461304
  result.add "path", section
  ## parameters in `query` object:
  ##   type: JString
  section = newJObject()
  var valid_39461305 = query.getOrDefault("type")
  valid_39461305 = validateParameter(valid_39461305, JString, required = false,
                                   default = newJString("all"))
  if valid_39461305 != nil:
    section.add "type", valid_39461305
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461306 = header.getOrDefault("Accept")
  valid_39461306 = validateParameter(valid_39461306, JString, required = false,
                                   default = nil)
  if valid_39461306 != nil:
    section.add "Accept", valid_39461306
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461307: Call_GetOrgsOrgRepos_39461301; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List repositories for the specified org.
  ## 
  let valid = call_39461307.validator(path, query, header, formData, body, _)
  let scheme = call_39461307.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461307.url(scheme.get, call_39461307.host, call_39461307.base,
                           call_39461307.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461307, uri, valid, _)

proc call*(call_39461308: Call_GetOrgsOrgRepos_39461301; org: string;
          Accept: string = ""; `type`: string = "all"): Recallable =
  ## getOrgsOrgRepos
  ## List repositories for the specified org.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   type: string
  ##   org: string (required)
  ##      : Name of organisation.
  var path_39461309 = newJObject()
  var query_39461310 = newJObject()
  var header_39461311 = newJObject()
  add(header_39461311, "Accept", newJString(Accept))
  add(query_39461310, "type", newJString(`type`))
  add(path_39461309, "org", newJString(org))
  result = call_39461308.call(path_39461309, query_39461310, header_39461311, nil, nil)

var getOrgsOrgRepos* = Call_GetOrgsOrgRepos_39461301(name: "getOrgsOrgRepos",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/repos",
    validator: validate_GetOrgsOrgRepos_39461302, base: "/",
    url: url_GetOrgsOrgRepos_39461303, schemes: {Scheme.Https})
type
  Call_PostOrgsOrgTeams_39461332 = ref object of OpenApiRestCall_39460352
proc url_PostOrgsOrgTeams_39461334(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/teams")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostOrgsOrgTeams_39461333(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create team.
  ## In order to create a team, the authenticated user must be an owner of organization.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_39461335 = path.getOrDefault("org")
  valid_39461335 = validateParameter(valid_39461335, JString, required = true,
                                   default = nil)
  if valid_39461335 != nil:
    section.add "org", valid_39461335
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461336 = header.getOrDefault("Accept")
  valid_39461336 = validateParameter(valid_39461336, JString, required = false,
                                   default = nil)
  if valid_39461336 != nil:
    section.add "Accept", valid_39461336
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39461338: Call_PostOrgsOrgTeams_39461332; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Create team.
  ## In order to create a team, the authenticated user must be an owner of organization.
  ## 
  ## 
  let valid = call_39461338.validator(path, query, header, formData, body, _)
  let scheme = call_39461338.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461338.url(scheme.get, call_39461338.host, call_39461338.base,
                           call_39461338.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461338, uri, valid, _)

proc call*(call_39461339: Call_PostOrgsOrgTeams_39461332; body: JsonNode;
          org: string; Accept: string = ""): Recallable =
  ## postOrgsOrgTeams
  ## Create team.
  ## In order to create a team, the authenticated user must be an owner of organization.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   org: string (required)
  ##      : Name of organisation.
  var path_39461340 = newJObject()
  var header_39461341 = newJObject()
  var body_39461342 = newJObject()
  add(header_39461341, "Accept", newJString(Accept))
  if body != nil:
    body_39461342 = body
  add(path_39461340, "org", newJString(org))
  result = call_39461339.call(path_39461340, nil, header_39461341, nil, body_39461342)

var postOrgsOrgTeams* = Call_PostOrgsOrgTeams_39461332(name: "postOrgsOrgTeams",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/orgs/{org}/teams",
    validator: validate_PostOrgsOrgTeams_39461333, base: "/",
    url: url_PostOrgsOrgTeams_39461334, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgTeams_39461323 = ref object of OpenApiRestCall_39460352
proc url_GetOrgsOrgTeams_39461325(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/teams")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgTeams_39461324(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List teams.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_39461326 = path.getOrDefault("org")
  valid_39461326 = validateParameter(valid_39461326, JString, required = true,
                                   default = nil)
  if valid_39461326 != nil:
    section.add "org", valid_39461326
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461327 = header.getOrDefault("Accept")
  valid_39461327 = validateParameter(valid_39461327, JString, required = false,
                                   default = nil)
  if valid_39461327 != nil:
    section.add "Accept", valid_39461327
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461328: Call_GetOrgsOrgTeams_39461323; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List teams.
  ## 
  let valid = call_39461328.validator(path, query, header, formData, body, _)
  let scheme = call_39461328.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461328.url(scheme.get, call_39461328.host, call_39461328.base,
                           call_39461328.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461328, uri, valid, _)

proc call*(call_39461329: Call_GetOrgsOrgTeams_39461323; org: string;
          Accept: string = ""): Recallable =
  ## getOrgsOrgTeams
  ## List teams.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_39461330 = newJObject()
  var header_39461331 = newJObject()
  add(header_39461331, "Accept", newJString(Accept))
  add(path_39461330, "org", newJString(org))
  result = call_39461329.call(path_39461330, nil, header_39461331, nil, nil)

var getOrgsOrgTeams* = Call_GetOrgsOrgTeams_39461323(name: "getOrgsOrgTeams",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/teams",
    validator: validate_GetOrgsOrgTeams_39461324, base: "/",
    url: url_GetOrgsOrgTeams_39461325, schemes: {Scheme.Https})
type
  Call_GetRateLimit_39461343 = ref object of OpenApiRestCall_39460352
proc url_GetRateLimit_39461345(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRateLimit_39461344(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## Get your current rate limit status
  ## Note: Accessing this endpoint does not count against your rate limit.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461346 = header.getOrDefault("Accept")
  valid_39461346 = validateParameter(valid_39461346, JString, required = false,
                                   default = nil)
  if valid_39461346 != nil:
    section.add "Accept", valid_39461346
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461347: Call_GetRateLimit_39461343; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get your current rate limit status
  ## Note: Accessing this endpoint does not count against your rate limit.
  ## 
  ## 
  let valid = call_39461347.validator(path, query, header, formData, body, _)
  let scheme = call_39461347.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461347.url(scheme.get, call_39461347.host, call_39461347.base,
                           call_39461347.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461347, uri, valid, _)

proc call*(call_39461348: Call_GetRateLimit_39461343; Accept: string = ""): Recallable =
  ## getRateLimit
  ## Get your current rate limit status
  ## Note: Accessing this endpoint does not count against your rate limit.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_39461349 = newJObject()
  add(header_39461349, "Accept", newJString(Accept))
  result = call_39461348.call(nil, nil, header_39461349, nil, nil)

var getRateLimit* = Call_GetRateLimit_39461343(name: "getRateLimit",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/rate_limit",
    validator: validate_GetRateLimit_39461344, base: "/", url: url_GetRateLimit_39461345,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepo_39461350 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepo_39461352(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepo_39461351(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461353 = path.getOrDefault("owner")
  valid_39461353 = validateParameter(valid_39461353, JString, required = true,
                                   default = nil)
  if valid_39461353 != nil:
    section.add "owner", valid_39461353
  var valid_39461354 = path.getOrDefault("repo")
  valid_39461354 = validateParameter(valid_39461354, JString, required = true,
                                   default = nil)
  if valid_39461354 != nil:
    section.add "repo", valid_39461354
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461355 = header.getOrDefault("Accept")
  valid_39461355 = validateParameter(valid_39461355, JString, required = false,
                                   default = nil)
  if valid_39461355 != nil:
    section.add "Accept", valid_39461355
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461356: Call_GetReposOwnerRepo_39461350; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get repository.
  ## 
  let valid = call_39461356.validator(path, query, header, formData, body, _)
  let scheme = call_39461356.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461356.url(scheme.get, call_39461356.host, call_39461356.base,
                           call_39461356.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461356, uri, valid, _)

proc call*(call_39461357: Call_GetReposOwnerRepo_39461350; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepo
  ## Get repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461358 = newJObject()
  var header_39461359 = newJObject()
  add(path_39461358, "owner", newJString(owner))
  add(header_39461359, "Accept", newJString(Accept))
  add(path_39461358, "repo", newJString(repo))
  result = call_39461357.call(path_39461358, nil, header_39461359, nil, nil)

var getReposOwnerRepo* = Call_GetReposOwnerRepo_39461350(name: "getReposOwnerRepo",
    meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/repos/{owner}/{repo}", validator: validate_GetReposOwnerRepo_39461351,
    base: "/", url: url_GetReposOwnerRepo_39461352, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepo_39461370 = ref object of OpenApiRestCall_39460352
proc url_PatchReposOwnerRepo_39461372(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepo_39461371(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Edit repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461373 = path.getOrDefault("owner")
  valid_39461373 = validateParameter(valid_39461373, JString, required = true,
                                   default = nil)
  if valid_39461373 != nil:
    section.add "owner", valid_39461373
  var valid_39461374 = path.getOrDefault("repo")
  valid_39461374 = validateParameter(valid_39461374, JString, required = true,
                                   default = nil)
  if valid_39461374 != nil:
    section.add "repo", valid_39461374
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461375 = header.getOrDefault("Accept")
  valid_39461375 = validateParameter(valid_39461375, JString, required = false,
                                   default = nil)
  if valid_39461375 != nil:
    section.add "Accept", valid_39461375
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39461377: Call_PatchReposOwnerRepo_39461370; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit repository.
  ## 
  let valid = call_39461377.validator(path, query, header, formData, body, _)
  let scheme = call_39461377.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461377.url(scheme.get, call_39461377.host, call_39461377.base,
                           call_39461377.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461377, uri, valid, _)

proc call*(call_39461378: Call_PatchReposOwnerRepo_39461370; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepo
  ## Edit repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461379 = newJObject()
  var header_39461380 = newJObject()
  var body_39461381 = newJObject()
  add(path_39461379, "owner", newJString(owner))
  add(header_39461380, "Accept", newJString(Accept))
  if body != nil:
    body_39461381 = body
  add(path_39461379, "repo", newJString(repo))
  result = call_39461378.call(path_39461379, nil, header_39461380, nil, body_39461381)

var patchReposOwnerRepo* = Call_PatchReposOwnerRepo_39461370(
    name: "patchReposOwnerRepo", meth: HttpMethod.HttpPatch, host: "api.github.com",
    route: "/repos/{owner}/{repo}", validator: validate_PatchReposOwnerRepo_39461371,
    base: "/", url: url_PatchReposOwnerRepo_39461372, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepo_39461360 = ref object of OpenApiRestCall_39460352
proc url_DeleteReposOwnerRepo_39461362(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepo_39461361(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Delete a Repository.
  ## Deleting a repository requires admin access. If OAuth is used, the delete_repo
  ## scope is required.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461363 = path.getOrDefault("owner")
  valid_39461363 = validateParameter(valid_39461363, JString, required = true,
                                   default = nil)
  if valid_39461363 != nil:
    section.add "owner", valid_39461363
  var valid_39461364 = path.getOrDefault("repo")
  valid_39461364 = validateParameter(valid_39461364, JString, required = true,
                                   default = nil)
  if valid_39461364 != nil:
    section.add "repo", valid_39461364
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461365 = header.getOrDefault("Accept")
  valid_39461365 = validateParameter(valid_39461365, JString, required = false,
                                   default = nil)
  if valid_39461365 != nil:
    section.add "Accept", valid_39461365
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461366: Call_DeleteReposOwnerRepo_39461360; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a Repository.
  ## Deleting a repository requires admin access. If OAuth is used, the delete_repo
  ## scope is required.
  ## 
  ## 
  let valid = call_39461366.validator(path, query, header, formData, body, _)
  let scheme = call_39461366.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461366.url(scheme.get, call_39461366.host, call_39461366.base,
                           call_39461366.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461366, uri, valid, _)

proc call*(call_39461367: Call_DeleteReposOwnerRepo_39461360; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepo
  ## Delete a Repository.
  ## Deleting a repository requires admin access. If OAuth is used, the delete_repo
  ## scope is required.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461368 = newJObject()
  var header_39461369 = newJObject()
  add(path_39461368, "owner", newJString(owner))
  add(header_39461369, "Accept", newJString(Accept))
  add(path_39461368, "repo", newJString(repo))
  result = call_39461367.call(path_39461368, nil, header_39461369, nil, nil)

var deleteReposOwnerRepo* = Call_DeleteReposOwnerRepo_39461360(
    name: "deleteReposOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}",
    validator: validate_DeleteReposOwnerRepo_39461361, base: "/",
    url: url_DeleteReposOwnerRepo_39461362, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoAssignees_39461382 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoAssignees_39461384(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/assignees")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoAssignees_39461383(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List assignees.
  ## This call lists all the available assignees (owner + collaborators) to which
  ## issues may be assigned.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461385 = path.getOrDefault("owner")
  valid_39461385 = validateParameter(valid_39461385, JString, required = true,
                                   default = nil)
  if valid_39461385 != nil:
    section.add "owner", valid_39461385
  var valid_39461386 = path.getOrDefault("repo")
  valid_39461386 = validateParameter(valid_39461386, JString, required = true,
                                   default = nil)
  if valid_39461386 != nil:
    section.add "repo", valid_39461386
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461387 = header.getOrDefault("Accept")
  valid_39461387 = validateParameter(valid_39461387, JString, required = false,
                                   default = nil)
  if valid_39461387 != nil:
    section.add "Accept", valid_39461387
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461388: Call_GetReposOwnerRepoAssignees_39461382;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List assignees.
  ## This call lists all the available assignees (owner + collaborators) to which
  ## issues may be assigned.
  ## 
  ## 
  let valid = call_39461388.validator(path, query, header, formData, body, _)
  let scheme = call_39461388.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461388.url(scheme.get, call_39461388.host, call_39461388.base,
                           call_39461388.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461388, uri, valid, _)

proc call*(call_39461389: Call_GetReposOwnerRepoAssignees_39461382; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoAssignees
  ## List assignees.
  ## This call lists all the available assignees (owner + collaborators) to which
  ## issues may be assigned.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461390 = newJObject()
  var header_39461391 = newJObject()
  add(path_39461390, "owner", newJString(owner))
  add(header_39461391, "Accept", newJString(Accept))
  add(path_39461390, "repo", newJString(repo))
  result = call_39461389.call(path_39461390, nil, header_39461391, nil, nil)

var getReposOwnerRepoAssignees* = Call_GetReposOwnerRepoAssignees_39461382(
    name: "getReposOwnerRepoAssignees", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/assignees",
    validator: validate_GetReposOwnerRepoAssignees_39461383, base: "/",
    url: url_GetReposOwnerRepoAssignees_39461384, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoAssigneesAssignee_39461392 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoAssigneesAssignee_39461394(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "assignee" in path, "`assignee` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/assignees/"),
               (kind: VariableSegment, value: "assignee")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoAssigneesAssignee_39461393(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Check assignee.
  ## You may also check to see if a particular user is an assignee for a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   assignee: JString (required)
  ##           : Login of the assignee.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461395 = path.getOrDefault("owner")
  valid_39461395 = validateParameter(valid_39461395, JString, required = true,
                                   default = nil)
  if valid_39461395 != nil:
    section.add "owner", valid_39461395
  var valid_39461396 = path.getOrDefault("assignee")
  valid_39461396 = validateParameter(valid_39461396, JString, required = true,
                                   default = nil)
  if valid_39461396 != nil:
    section.add "assignee", valid_39461396
  var valid_39461397 = path.getOrDefault("repo")
  valid_39461397 = validateParameter(valid_39461397, JString, required = true,
                                   default = nil)
  if valid_39461397 != nil:
    section.add "repo", valid_39461397
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461398 = header.getOrDefault("Accept")
  valid_39461398 = validateParameter(valid_39461398, JString, required = false,
                                   default = nil)
  if valid_39461398 != nil:
    section.add "Accept", valid_39461398
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461399: Call_GetReposOwnerRepoAssigneesAssignee_39461392;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check assignee.
  ## You may also check to see if a particular user is an assignee for a repository.
  ## 
  ## 
  let valid = call_39461399.validator(path, query, header, formData, body, _)
  let scheme = call_39461399.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461399.url(scheme.get, call_39461399.host, call_39461399.base,
                           call_39461399.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461399, uri, valid, _)

proc call*(call_39461400: Call_GetReposOwnerRepoAssigneesAssignee_39461392;
          owner: string; assignee: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoAssigneesAssignee
  ## Check assignee.
  ## You may also check to see if a particular user is an assignee for a repository.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   assignee: string (required)
  ##           : Login of the assignee.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461401 = newJObject()
  var header_39461402 = newJObject()
  add(path_39461401, "owner", newJString(owner))
  add(path_39461401, "assignee", newJString(assignee))
  add(header_39461402, "Accept", newJString(Accept))
  add(path_39461401, "repo", newJString(repo))
  result = call_39461400.call(path_39461401, nil, header_39461402, nil, nil)

var getReposOwnerRepoAssigneesAssignee* = Call_GetReposOwnerRepoAssigneesAssignee_39461392(
    name: "getReposOwnerRepoAssigneesAssignee", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/assignees/{assignee}",
    validator: validate_GetReposOwnerRepoAssigneesAssignee_39461393, base: "/",
    url: url_GetReposOwnerRepoAssigneesAssignee_39461394, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoBranches_39461403 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoBranches_39461405(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/branches")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoBranches_39461404(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get list of branches
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461406 = path.getOrDefault("owner")
  valid_39461406 = validateParameter(valid_39461406, JString, required = true,
                                   default = nil)
  if valid_39461406 != nil:
    section.add "owner", valid_39461406
  var valid_39461407 = path.getOrDefault("repo")
  valid_39461407 = validateParameter(valid_39461407, JString, required = true,
                                   default = nil)
  if valid_39461407 != nil:
    section.add "repo", valid_39461407
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461408 = header.getOrDefault("Accept")
  valid_39461408 = validateParameter(valid_39461408, JString, required = false,
                                   default = nil)
  if valid_39461408 != nil:
    section.add "Accept", valid_39461408
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461409: Call_GetReposOwnerRepoBranches_39461403;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get list of branches
  ## 
  let valid = call_39461409.validator(path, query, header, formData, body, _)
  let scheme = call_39461409.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461409.url(scheme.get, call_39461409.host, call_39461409.base,
                           call_39461409.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461409, uri, valid, _)

proc call*(call_39461410: Call_GetReposOwnerRepoBranches_39461403; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoBranches
  ## Get list of branches
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461411 = newJObject()
  var header_39461412 = newJObject()
  add(path_39461411, "owner", newJString(owner))
  add(header_39461412, "Accept", newJString(Accept))
  add(path_39461411, "repo", newJString(repo))
  result = call_39461410.call(path_39461411, nil, header_39461412, nil, nil)

var getReposOwnerRepoBranches* = Call_GetReposOwnerRepoBranches_39461403(
    name: "getReposOwnerRepoBranches", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/branches",
    validator: validate_GetReposOwnerRepoBranches_39461404, base: "/",
    url: url_GetReposOwnerRepoBranches_39461405, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoBranchesBranch_39461413 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoBranchesBranch_39461415(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "branch" in path, "`branch` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/branches/"),
               (kind: VariableSegment, value: "branch")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoBranchesBranch_39461414(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get Branch
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   branch: JString (required)
  ##         : Name of the branch.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461416 = path.getOrDefault("owner")
  valid_39461416 = validateParameter(valid_39461416, JString, required = true,
                                   default = nil)
  if valid_39461416 != nil:
    section.add "owner", valid_39461416
  var valid_39461417 = path.getOrDefault("branch")
  valid_39461417 = validateParameter(valid_39461417, JString, required = true,
                                   default = nil)
  if valid_39461417 != nil:
    section.add "branch", valid_39461417
  var valid_39461418 = path.getOrDefault("repo")
  valid_39461418 = validateParameter(valid_39461418, JString, required = true,
                                   default = nil)
  if valid_39461418 != nil:
    section.add "repo", valid_39461418
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461419 = header.getOrDefault("Accept")
  valid_39461419 = validateParameter(valid_39461419, JString, required = false,
                                   default = nil)
  if valid_39461419 != nil:
    section.add "Accept", valid_39461419
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461420: Call_GetReposOwnerRepoBranchesBranch_39461413;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get Branch
  ## 
  let valid = call_39461420.validator(path, query, header, formData, body, _)
  let scheme = call_39461420.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461420.url(scheme.get, call_39461420.host, call_39461420.base,
                           call_39461420.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461420, uri, valid, _)

proc call*(call_39461421: Call_GetReposOwnerRepoBranchesBranch_39461413;
          owner: string; branch: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoBranchesBranch
  ## Get Branch
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   branch: string (required)
  ##         : Name of the branch.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461422 = newJObject()
  var header_39461423 = newJObject()
  add(path_39461422, "owner", newJString(owner))
  add(path_39461422, "branch", newJString(branch))
  add(header_39461423, "Accept", newJString(Accept))
  add(path_39461422, "repo", newJString(repo))
  result = call_39461421.call(path_39461422, nil, header_39461423, nil, nil)

var getReposOwnerRepoBranchesBranch* = Call_GetReposOwnerRepoBranchesBranch_39461413(
    name: "getReposOwnerRepoBranchesBranch", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/branches/{branch}",
    validator: validate_GetReposOwnerRepoBranchesBranch_39461414, base: "/",
    url: url_GetReposOwnerRepoBranchesBranch_39461415, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCollaborators_39461424 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoCollaborators_39461426(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/collaborators")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCollaborators_39461425(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List.
  ## When authenticating as an organization owner of an organization-owned
  ## repository, all organization owners are included in the list of
  ## collaborators. Otherwise, only users with access to the repository are
  ## returned in the collaborators list.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461427 = path.getOrDefault("owner")
  valid_39461427 = validateParameter(valid_39461427, JString, required = true,
                                   default = nil)
  if valid_39461427 != nil:
    section.add "owner", valid_39461427
  var valid_39461428 = path.getOrDefault("repo")
  valid_39461428 = validateParameter(valid_39461428, JString, required = true,
                                   default = nil)
  if valid_39461428 != nil:
    section.add "repo", valid_39461428
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461429 = header.getOrDefault("Accept")
  valid_39461429 = validateParameter(valid_39461429, JString, required = false,
                                   default = nil)
  if valid_39461429 != nil:
    section.add "Accept", valid_39461429
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461430: Call_GetReposOwnerRepoCollaborators_39461424;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List.
  ## When authenticating as an organization owner of an organization-owned
  ## repository, all organization owners are included in the list of
  ## collaborators. Otherwise, only users with access to the repository are
  ## returned in the collaborators list.
  ## 
  ## 
  let valid = call_39461430.validator(path, query, header, formData, body, _)
  let scheme = call_39461430.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461430.url(scheme.get, call_39461430.host, call_39461430.base,
                           call_39461430.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461430, uri, valid, _)

proc call*(call_39461431: Call_GetReposOwnerRepoCollaborators_39461424;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCollaborators
  ## List.
  ## When authenticating as an organization owner of an organization-owned
  ## repository, all organization owners are included in the list of
  ## collaborators. Otherwise, only users with access to the repository are
  ## returned in the collaborators list.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461432 = newJObject()
  var header_39461433 = newJObject()
  add(path_39461432, "owner", newJString(owner))
  add(header_39461433, "Accept", newJString(Accept))
  add(path_39461432, "repo", newJString(repo))
  result = call_39461431.call(path_39461432, nil, header_39461433, nil, nil)

var getReposOwnerRepoCollaborators* = Call_GetReposOwnerRepoCollaborators_39461424(
    name: "getReposOwnerRepoCollaborators", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators",
    validator: validate_GetReposOwnerRepoCollaborators_39461425, base: "/",
    url: url_GetReposOwnerRepoCollaborators_39461426, schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoCollaboratorsUser_39461445 = ref object of OpenApiRestCall_39460352
proc url_PutReposOwnerRepoCollaboratorsUser_39461447(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "user" in path, "`user` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/collaborators/"),
               (kind: VariableSegment, value: "user")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoCollaboratorsUser_39461446(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Add collaborator.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   user: JString (required)
  ##       : Login of the user.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461448 = path.getOrDefault("owner")
  valid_39461448 = validateParameter(valid_39461448, JString, required = true,
                                   default = nil)
  if valid_39461448 != nil:
    section.add "owner", valid_39461448
  var valid_39461449 = path.getOrDefault("user")
  valid_39461449 = validateParameter(valid_39461449, JString, required = true,
                                   default = nil)
  if valid_39461449 != nil:
    section.add "user", valid_39461449
  var valid_39461450 = path.getOrDefault("repo")
  valid_39461450 = validateParameter(valid_39461450, JString, required = true,
                                   default = nil)
  if valid_39461450 != nil:
    section.add "repo", valid_39461450
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461451 = header.getOrDefault("Accept")
  valid_39461451 = validateParameter(valid_39461451, JString, required = false,
                                   default = nil)
  if valid_39461451 != nil:
    section.add "Accept", valid_39461451
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461452: Call_PutReposOwnerRepoCollaboratorsUser_39461445;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Add collaborator.
  ## 
  let valid = call_39461452.validator(path, query, header, formData, body, _)
  let scheme = call_39461452.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461452.url(scheme.get, call_39461452.host, call_39461452.base,
                           call_39461452.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461452, uri, valid, _)

proc call*(call_39461453: Call_PutReposOwnerRepoCollaboratorsUser_39461445;
          owner: string; user: string; repo: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoCollaboratorsUser
  ## Add collaborator.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   user: string (required)
  ##       : Login of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461454 = newJObject()
  var header_39461455 = newJObject()
  add(path_39461454, "owner", newJString(owner))
  add(path_39461454, "user", newJString(user))
  add(header_39461455, "Accept", newJString(Accept))
  add(path_39461454, "repo", newJString(repo))
  result = call_39461453.call(path_39461454, nil, header_39461455, nil, nil)

var putReposOwnerRepoCollaboratorsUser* = Call_PutReposOwnerRepoCollaboratorsUser_39461445(
    name: "putReposOwnerRepoCollaboratorsUser", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators/{user}",
    validator: validate_PutReposOwnerRepoCollaboratorsUser_39461446, base: "/",
    url: url_PutReposOwnerRepoCollaboratorsUser_39461447, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCollaboratorsUser_39461434 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoCollaboratorsUser_39461436(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "user" in path, "`user` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/collaborators/"),
               (kind: VariableSegment, value: "user")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCollaboratorsUser_39461435(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Check if user is a collaborator
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   user: JString (required)
  ##       : Login of the user.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461437 = path.getOrDefault("owner")
  valid_39461437 = validateParameter(valid_39461437, JString, required = true,
                                   default = nil)
  if valid_39461437 != nil:
    section.add "owner", valid_39461437
  var valid_39461438 = path.getOrDefault("user")
  valid_39461438 = validateParameter(valid_39461438, JString, required = true,
                                   default = nil)
  if valid_39461438 != nil:
    section.add "user", valid_39461438
  var valid_39461439 = path.getOrDefault("repo")
  valid_39461439 = validateParameter(valid_39461439, JString, required = true,
                                   default = nil)
  if valid_39461439 != nil:
    section.add "repo", valid_39461439
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461440 = header.getOrDefault("Accept")
  valid_39461440 = validateParameter(valid_39461440, JString, required = false,
                                   default = nil)
  if valid_39461440 != nil:
    section.add "Accept", valid_39461440
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461441: Call_GetReposOwnerRepoCollaboratorsUser_39461434;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if user is a collaborator
  ## 
  let valid = call_39461441.validator(path, query, header, formData, body, _)
  let scheme = call_39461441.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461441.url(scheme.get, call_39461441.host, call_39461441.base,
                           call_39461441.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461441, uri, valid, _)

proc call*(call_39461442: Call_GetReposOwnerRepoCollaboratorsUser_39461434;
          owner: string; user: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCollaboratorsUser
  ## Check if user is a collaborator
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   user: string (required)
  ##       : Login of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461443 = newJObject()
  var header_39461444 = newJObject()
  add(path_39461443, "owner", newJString(owner))
  add(path_39461443, "user", newJString(user))
  add(header_39461444, "Accept", newJString(Accept))
  add(path_39461443, "repo", newJString(repo))
  result = call_39461442.call(path_39461443, nil, header_39461444, nil, nil)

var getReposOwnerRepoCollaboratorsUser* = Call_GetReposOwnerRepoCollaboratorsUser_39461434(
    name: "getReposOwnerRepoCollaboratorsUser", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators/{user}",
    validator: validate_GetReposOwnerRepoCollaboratorsUser_39461435, base: "/",
    url: url_GetReposOwnerRepoCollaboratorsUser_39461436, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoCollaboratorsUser_39461456 = ref object of OpenApiRestCall_39460352
proc url_DeleteReposOwnerRepoCollaboratorsUser_39461458(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "user" in path, "`user` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/collaborators/"),
               (kind: VariableSegment, value: "user")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoCollaboratorsUser_39461457(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Remove collaborator.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   user: JString (required)
  ##       : Login of the user.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461459 = path.getOrDefault("owner")
  valid_39461459 = validateParameter(valid_39461459, JString, required = true,
                                   default = nil)
  if valid_39461459 != nil:
    section.add "owner", valid_39461459
  var valid_39461460 = path.getOrDefault("user")
  valid_39461460 = validateParameter(valid_39461460, JString, required = true,
                                   default = nil)
  if valid_39461460 != nil:
    section.add "user", valid_39461460
  var valid_39461461 = path.getOrDefault("repo")
  valid_39461461 = validateParameter(valid_39461461, JString, required = true,
                                   default = nil)
  if valid_39461461 != nil:
    section.add "repo", valid_39461461
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461462 = header.getOrDefault("Accept")
  valid_39461462 = validateParameter(valid_39461462, JString, required = false,
                                   default = nil)
  if valid_39461462 != nil:
    section.add "Accept", valid_39461462
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461463: Call_DeleteReposOwnerRepoCollaboratorsUser_39461456;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Remove collaborator.
  ## 
  let valid = call_39461463.validator(path, query, header, formData, body, _)
  let scheme = call_39461463.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461463.url(scheme.get, call_39461463.host, call_39461463.base,
                           call_39461463.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461463, uri, valid, _)

proc call*(call_39461464: Call_DeleteReposOwnerRepoCollaboratorsUser_39461456;
          owner: string; user: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoCollaboratorsUser
  ## Remove collaborator.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   user: string (required)
  ##       : Login of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461465 = newJObject()
  var header_39461466 = newJObject()
  add(path_39461465, "owner", newJString(owner))
  add(path_39461465, "user", newJString(user))
  add(header_39461466, "Accept", newJString(Accept))
  add(path_39461465, "repo", newJString(repo))
  result = call_39461464.call(path_39461465, nil, header_39461466, nil, nil)

var deleteReposOwnerRepoCollaboratorsUser* = Call_DeleteReposOwnerRepoCollaboratorsUser_39461456(
    name: "deleteReposOwnerRepoCollaboratorsUser", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators/{user}",
    validator: validate_DeleteReposOwnerRepoCollaboratorsUser_39461457, base: "/",
    url: url_DeleteReposOwnerRepoCollaboratorsUser_39461458,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoComments_39461467 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoComments_39461469(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoComments_39461468(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List commit comments for a repository.
  ## Comments are ordered by ascending ID.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461470 = path.getOrDefault("owner")
  valid_39461470 = validateParameter(valid_39461470, JString, required = true,
                                   default = nil)
  if valid_39461470 != nil:
    section.add "owner", valid_39461470
  var valid_39461471 = path.getOrDefault("repo")
  valid_39461471 = validateParameter(valid_39461471, JString, required = true,
                                   default = nil)
  if valid_39461471 != nil:
    section.add "repo", valid_39461471
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461472 = header.getOrDefault("Accept")
  valid_39461472 = validateParameter(valid_39461472, JString, required = false,
                                   default = nil)
  if valid_39461472 != nil:
    section.add "Accept", valid_39461472
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461473: Call_GetReposOwnerRepoComments_39461467;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List commit comments for a repository.
  ## Comments are ordered by ascending ID.
  ## 
  ## 
  let valid = call_39461473.validator(path, query, header, formData, body, _)
  let scheme = call_39461473.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461473.url(scheme.get, call_39461473.host, call_39461473.base,
                           call_39461473.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461473, uri, valid, _)

proc call*(call_39461474: Call_GetReposOwnerRepoComments_39461467; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoComments
  ## List commit comments for a repository.
  ## Comments are ordered by ascending ID.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461475 = newJObject()
  var header_39461476 = newJObject()
  add(path_39461475, "owner", newJString(owner))
  add(header_39461476, "Accept", newJString(Accept))
  add(path_39461475, "repo", newJString(repo))
  result = call_39461474.call(path_39461475, nil, header_39461476, nil, nil)

var getReposOwnerRepoComments* = Call_GetReposOwnerRepoComments_39461467(
    name: "getReposOwnerRepoComments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments",
    validator: validate_GetReposOwnerRepoComments_39461468, base: "/",
    url: url_GetReposOwnerRepoComments_39461469, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommentsCommentId_39461477 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoCommentsCommentId_39461479(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommentsCommentId_39461478(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a single commit comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461480 = path.getOrDefault("owner")
  valid_39461480 = validateParameter(valid_39461480, JString, required = true,
                                   default = nil)
  if valid_39461480 != nil:
    section.add "owner", valid_39461480
  var valid_39461481 = path.getOrDefault("repo")
  valid_39461481 = validateParameter(valid_39461481, JString, required = true,
                                   default = nil)
  if valid_39461481 != nil:
    section.add "repo", valid_39461481
  var valid_39461482 = path.getOrDefault("commentId")
  valid_39461482 = validateParameter(valid_39461482, JInt, required = true,
                                   default = nil)
  if valid_39461482 != nil:
    section.add "commentId", valid_39461482
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461483 = header.getOrDefault("Accept")
  valid_39461483 = validateParameter(valid_39461483, JString, required = false,
                                   default = nil)
  if valid_39461483 != nil:
    section.add "Accept", valid_39461483
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461484: Call_GetReposOwnerRepoCommentsCommentId_39461477;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single commit comment.
  ## 
  let valid = call_39461484.validator(path, query, header, formData, body, _)
  let scheme = call_39461484.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461484.url(scheme.get, call_39461484.host, call_39461484.base,
                           call_39461484.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461484, uri, valid, _)

proc call*(call_39461485: Call_GetReposOwnerRepoCommentsCommentId_39461477;
          owner: string; repo: string; commentId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommentsCommentId
  ## Get a single commit comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_39461486 = newJObject()
  var header_39461487 = newJObject()
  add(path_39461486, "owner", newJString(owner))
  add(header_39461487, "Accept", newJString(Accept))
  add(path_39461486, "repo", newJString(repo))
  add(path_39461486, "commentId", newJInt(commentId))
  result = call_39461485.call(path_39461486, nil, header_39461487, nil, nil)

var getReposOwnerRepoCommentsCommentId* = Call_GetReposOwnerRepoCommentsCommentId_39461477(
    name: "getReposOwnerRepoCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments/{commentId}",
    validator: validate_GetReposOwnerRepoCommentsCommentId_39461478, base: "/",
    url: url_GetReposOwnerRepoCommentsCommentId_39461479, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoCommentsCommentId_39461499 = ref object of OpenApiRestCall_39460352
proc url_PatchReposOwnerRepoCommentsCommentId_39461501(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoCommentsCommentId_39461500(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Update a commit comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461502 = path.getOrDefault("owner")
  valid_39461502 = validateParameter(valid_39461502, JString, required = true,
                                   default = nil)
  if valid_39461502 != nil:
    section.add "owner", valid_39461502
  var valid_39461503 = path.getOrDefault("repo")
  valid_39461503 = validateParameter(valid_39461503, JString, required = true,
                                   default = nil)
  if valid_39461503 != nil:
    section.add "repo", valid_39461503
  var valid_39461504 = path.getOrDefault("commentId")
  valid_39461504 = validateParameter(valid_39461504, JInt, required = true,
                                   default = nil)
  if valid_39461504 != nil:
    section.add "commentId", valid_39461504
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461505 = header.getOrDefault("Accept")
  valid_39461505 = validateParameter(valid_39461505, JString, required = false,
                                   default = nil)
  if valid_39461505 != nil:
    section.add "Accept", valid_39461505
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39461507: Call_PatchReposOwnerRepoCommentsCommentId_39461499;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Update a commit comment.
  ## 
  let valid = call_39461507.validator(path, query, header, formData, body, _)
  let scheme = call_39461507.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461507.url(scheme.get, call_39461507.host, call_39461507.base,
                           call_39461507.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461507, uri, valid, _)

proc call*(call_39461508: Call_PatchReposOwnerRepoCommentsCommentId_39461499;
          owner: string; body: JsonNode; repo: string; commentId: int;
          Accept: string = ""): Recallable =
  ## patchReposOwnerRepoCommentsCommentId
  ## Update a commit comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_39461509 = newJObject()
  var header_39461510 = newJObject()
  var body_39461511 = newJObject()
  add(path_39461509, "owner", newJString(owner))
  add(header_39461510, "Accept", newJString(Accept))
  if body != nil:
    body_39461511 = body
  add(path_39461509, "repo", newJString(repo))
  add(path_39461509, "commentId", newJInt(commentId))
  result = call_39461508.call(path_39461509, nil, header_39461510, nil, body_39461511)

var patchReposOwnerRepoCommentsCommentId* = Call_PatchReposOwnerRepoCommentsCommentId_39461499(
    name: "patchReposOwnerRepoCommentsCommentId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments/{commentId}",
    validator: validate_PatchReposOwnerRepoCommentsCommentId_39461500, base: "/",
    url: url_PatchReposOwnerRepoCommentsCommentId_39461501,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoCommentsCommentId_39461488 = ref object of OpenApiRestCall_39460352
proc url_DeleteReposOwnerRepoCommentsCommentId_39461490(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoCommentsCommentId_39461489(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a commit comment
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461491 = path.getOrDefault("owner")
  valid_39461491 = validateParameter(valid_39461491, JString, required = true,
                                   default = nil)
  if valid_39461491 != nil:
    section.add "owner", valid_39461491
  var valid_39461492 = path.getOrDefault("repo")
  valid_39461492 = validateParameter(valid_39461492, JString, required = true,
                                   default = nil)
  if valid_39461492 != nil:
    section.add "repo", valid_39461492
  var valid_39461493 = path.getOrDefault("commentId")
  valid_39461493 = validateParameter(valid_39461493, JInt, required = true,
                                   default = nil)
  if valid_39461493 != nil:
    section.add "commentId", valid_39461493
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461494 = header.getOrDefault("Accept")
  valid_39461494 = validateParameter(valid_39461494, JString, required = false,
                                   default = nil)
  if valid_39461494 != nil:
    section.add "Accept", valid_39461494
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461495: Call_DeleteReposOwnerRepoCommentsCommentId_39461488;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a commit comment
  ## 
  let valid = call_39461495.validator(path, query, header, formData, body, _)
  let scheme = call_39461495.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461495.url(scheme.get, call_39461495.host, call_39461495.base,
                           call_39461495.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461495, uri, valid, _)

proc call*(call_39461496: Call_DeleteReposOwnerRepoCommentsCommentId_39461488;
          owner: string; repo: string; commentId: int; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoCommentsCommentId
  ## Delete a commit comment
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_39461497 = newJObject()
  var header_39461498 = newJObject()
  add(path_39461497, "owner", newJString(owner))
  add(header_39461498, "Accept", newJString(Accept))
  add(path_39461497, "repo", newJString(repo))
  add(path_39461497, "commentId", newJInt(commentId))
  result = call_39461496.call(path_39461497, nil, header_39461498, nil, nil)

var deleteReposOwnerRepoCommentsCommentId* = Call_DeleteReposOwnerRepoCommentsCommentId_39461488(
    name: "deleteReposOwnerRepoCommentsCommentId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments/{commentId}",
    validator: validate_DeleteReposOwnerRepoCommentsCommentId_39461489, base: "/",
    url: url_DeleteReposOwnerRepoCommentsCommentId_39461490,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommits_39461512 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoCommits_39461514(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommits_39461513(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List commits on a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461515 = path.getOrDefault("owner")
  valid_39461515 = validateParameter(valid_39461515, JString, required = true,
                                   default = nil)
  if valid_39461515 != nil:
    section.add "owner", valid_39461515
  var valid_39461516 = path.getOrDefault("repo")
  valid_39461516 = validateParameter(valid_39461516, JString, required = true,
                                   default = nil)
  if valid_39461516 != nil:
    section.add "repo", valid_39461516
  result.add "path", section
  ## parameters in `query` object:
  ##   path: JString
  ##       : Only commits containing this file path will be returned.
  ##   sha: JString
  ##      : Sha or branch to start listing commits from.
  ##   author: JString
  ##         : GitHub login, name, or email by which to filter by commit author.
  ##   until: JString
  ##        : ISO 8601 Date - Only commits before this date will be returned.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_39461517 = query.getOrDefault("path")
  valid_39461517 = validateParameter(valid_39461517, JString, required = false,
                                   default = nil)
  if valid_39461517 != nil:
    section.add "path", valid_39461517
  var valid_39461518 = query.getOrDefault("sha")
  valid_39461518 = validateParameter(valid_39461518, JString, required = false,
                                   default = nil)
  if valid_39461518 != nil:
    section.add "sha", valid_39461518
  var valid_39461519 = query.getOrDefault("author")
  valid_39461519 = validateParameter(valid_39461519, JString, required = false,
                                   default = nil)
  if valid_39461519 != nil:
    section.add "author", valid_39461519
  var valid_39461520 = query.getOrDefault("until")
  valid_39461520 = validateParameter(valid_39461520, JString, required = false,
                                   default = nil)
  if valid_39461520 != nil:
    section.add "until", valid_39461520
  var valid_39461521 = query.getOrDefault("since")
  valid_39461521 = validateParameter(valid_39461521, JString, required = false,
                                   default = nil)
  if valid_39461521 != nil:
    section.add "since", valid_39461521
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461522 = header.getOrDefault("Accept")
  valid_39461522 = validateParameter(valid_39461522, JString, required = false,
                                   default = nil)
  if valid_39461522 != nil:
    section.add "Accept", valid_39461522
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461523: Call_GetReposOwnerRepoCommits_39461512;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List commits on a repository.
  ## 
  let valid = call_39461523.validator(path, query, header, formData, body, _)
  let scheme = call_39461523.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461523.url(scheme.get, call_39461523.host, call_39461523.base,
                           call_39461523.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461523, uri, valid, _)

proc call*(call_39461524: Call_GetReposOwnerRepoCommits_39461512; owner: string;
          repo: string; path: string = ""; Accept: string = ""; sha: string = "";
          author: string = ""; until: string = ""; since: string = ""): Recallable =
  ## getReposOwnerRepoCommits
  ## List commits on a repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   path: string
  ##       : Only commits containing this file path will be returned.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   sha: string
  ##      : Sha or branch to start listing commits from.
  ##   author: string
  ##         : GitHub login, name, or email by which to filter by commit author.
  ##   until: string
  ##        : ISO 8601 Date - Only commits before this date will be returned.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var path_39461525 = newJObject()
  var query_39461526 = newJObject()
  var header_39461527 = newJObject()
  add(path_39461525, "owner", newJString(owner))
  add(query_39461526, "path", newJString(path))
  add(header_39461527, "Accept", newJString(Accept))
  add(path_39461525, "repo", newJString(repo))
  add(query_39461526, "sha", newJString(sha))
  add(query_39461526, "author", newJString(author))
  add(query_39461526, "until", newJString(until))
  add(query_39461526, "since", newJString(since))
  result = call_39461524.call(path_39461525, query_39461526, header_39461527, nil, nil)

var getReposOwnerRepoCommits* = Call_GetReposOwnerRepoCommits_39461512(
    name: "getReposOwnerRepoCommits", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/commits",
    validator: validate_GetReposOwnerRepoCommits_39461513, base: "/",
    url: url_GetReposOwnerRepoCommits_39461514, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommitsRefStatus_39461528 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoCommitsRefStatus_39461530(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits/"),
               (kind: VariableSegment, value: "ref"),
               (kind: ConstantSegment, value: "/status")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommitsRefStatus_39461529(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get the combined Status for a specific Ref
  ## The Combined status endpoint is currently available for developers to preview. During the preview period, the API may change without advance notice. Please see the blog post for full details.
  ## To access this endpoint during the preview period, you must provide a custom media type in the Accept header:
  ## application/vnd.github.she-hulk-preview+json
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   ref: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461531 = path.getOrDefault("owner")
  valid_39461531 = validateParameter(valid_39461531, JString, required = true,
                                   default = nil)
  if valid_39461531 != nil:
    section.add "owner", valid_39461531
  var valid_39461532 = path.getOrDefault("ref")
  valid_39461532 = validateParameter(valid_39461532, JString, required = true,
                                   default = nil)
  if valid_39461532 != nil:
    section.add "ref", valid_39461532
  var valid_39461533 = path.getOrDefault("repo")
  valid_39461533 = validateParameter(valid_39461533, JString, required = true,
                                   default = nil)
  if valid_39461533 != nil:
    section.add "repo", valid_39461533
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461534 = header.getOrDefault("Accept")
  valid_39461534 = validateParameter(valid_39461534, JString, required = false,
                                   default = nil)
  if valid_39461534 != nil:
    section.add "Accept", valid_39461534
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461535: Call_GetReposOwnerRepoCommitsRefStatus_39461528;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get the combined Status for a specific Ref
  ## The Combined status endpoint is currently available for developers to preview. During the preview period, the API may change without advance notice. Please see the blog post for full details.
  ## To access this endpoint during the preview period, you must provide a custom media type in the Accept header:
  ## application/vnd.github.she-hulk-preview+json
  ## 
  ## 
  let valid = call_39461535.validator(path, query, header, formData, body, _)
  let scheme = call_39461535.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461535.url(scheme.get, call_39461535.host, call_39461535.base,
                           call_39461535.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461535, uri, valid, _)

proc call*(call_39461536: Call_GetReposOwnerRepoCommitsRefStatus_39461528;
          owner: string; `ref`: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommitsRefStatus
  ## Get the combined Status for a specific Ref
  ## The Combined status endpoint is currently available for developers to preview. During the preview period, the API may change without advance notice. Please see the blog post for full details.
  ## To access this endpoint during the preview period, you must provide a custom media type in the Accept header:
  ## application/vnd.github.she-hulk-preview+json
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   ref: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461537 = newJObject()
  var header_39461538 = newJObject()
  add(path_39461537, "owner", newJString(owner))
  add(path_39461537, "ref", newJString(`ref`))
  add(header_39461538, "Accept", newJString(Accept))
  add(path_39461537, "repo", newJString(repo))
  result = call_39461536.call(path_39461537, nil, header_39461538, nil, nil)

var getReposOwnerRepoCommitsRefStatus* = Call_GetReposOwnerRepoCommitsRefStatus_39461528(
    name: "getReposOwnerRepoCommitsRefStatus", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/commits/{ref}/status",
    validator: validate_GetReposOwnerRepoCommitsRefStatus_39461529, base: "/",
    url: url_GetReposOwnerRepoCommitsRefStatus_39461530, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommitsShaCode_39461539 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoCommitsShaCode_39461541(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommitsShaCode_39461540(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a single commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  ##          : SHA-1 code of the commit.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461542 = path.getOrDefault("owner")
  valid_39461542 = validateParameter(valid_39461542, JString, required = true,
                                   default = nil)
  if valid_39461542 != nil:
    section.add "owner", valid_39461542
  var valid_39461543 = path.getOrDefault("repo")
  valid_39461543 = validateParameter(valid_39461543, JString, required = true,
                                   default = nil)
  if valid_39461543 != nil:
    section.add "repo", valid_39461543
  var valid_39461544 = path.getOrDefault("shaCode")
  valid_39461544 = validateParameter(valid_39461544, JString, required = true,
                                   default = nil)
  if valid_39461544 != nil:
    section.add "shaCode", valid_39461544
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461545 = header.getOrDefault("Accept")
  valid_39461545 = validateParameter(valid_39461545, JString, required = false,
                                   default = nil)
  if valid_39461545 != nil:
    section.add "Accept", valid_39461545
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461546: Call_GetReposOwnerRepoCommitsShaCode_39461539;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single commit.
  ## 
  let valid = call_39461546.validator(path, query, header, formData, body, _)
  let scheme = call_39461546.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461546.url(scheme.get, call_39461546.host, call_39461546.base,
                           call_39461546.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461546, uri, valid, _)

proc call*(call_39461547: Call_GetReposOwnerRepoCommitsShaCode_39461539;
          owner: string; repo: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommitsShaCode
  ## Get a single commit.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  ##          : SHA-1 code of the commit.
  var path_39461548 = newJObject()
  var header_39461549 = newJObject()
  add(path_39461548, "owner", newJString(owner))
  add(header_39461549, "Accept", newJString(Accept))
  add(path_39461548, "repo", newJString(repo))
  add(path_39461548, "shaCode", newJString(shaCode))
  result = call_39461547.call(path_39461548, nil, header_39461549, nil, nil)

var getReposOwnerRepoCommitsShaCode* = Call_GetReposOwnerRepoCommitsShaCode_39461539(
    name: "getReposOwnerRepoCommitsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/commits/{shaCode}",
    validator: validate_GetReposOwnerRepoCommitsShaCode_39461540, base: "/",
    url: url_GetReposOwnerRepoCommitsShaCode_39461541, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoCommitsShaCodeComments_39461561 = ref object of OpenApiRestCall_39460352
proc url_PostReposOwnerRepoCommitsShaCodeComments_39461563(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits/"),
               (kind: VariableSegment, value: "shaCode"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoCommitsShaCodeComments_39461562(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Create a commit comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  ##          : SHA-1 code of the commit.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461564 = path.getOrDefault("owner")
  valid_39461564 = validateParameter(valid_39461564, JString, required = true,
                                   default = nil)
  if valid_39461564 != nil:
    section.add "owner", valid_39461564
  var valid_39461565 = path.getOrDefault("repo")
  valid_39461565 = validateParameter(valid_39461565, JString, required = true,
                                   default = nil)
  if valid_39461565 != nil:
    section.add "repo", valid_39461565
  var valid_39461566 = path.getOrDefault("shaCode")
  valid_39461566 = validateParameter(valid_39461566, JString, required = true,
                                   default = nil)
  if valid_39461566 != nil:
    section.add "shaCode", valid_39461566
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461567 = header.getOrDefault("Accept")
  valid_39461567 = validateParameter(valid_39461567, JString, required = false,
                                   default = nil)
  if valid_39461567 != nil:
    section.add "Accept", valid_39461567
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39461569: Call_PostReposOwnerRepoCommitsShaCodeComments_39461561;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a commit comment.
  ## 
  let valid = call_39461569.validator(path, query, header, formData, body, _)
  let scheme = call_39461569.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461569.url(scheme.get, call_39461569.host, call_39461569.base,
                           call_39461569.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461569, uri, valid, _)

proc call*(call_39461570: Call_PostReposOwnerRepoCommitsShaCodeComments_39461561;
          owner: string; body: JsonNode; repo: string; shaCode: string;
          Accept: string = ""): Recallable =
  ## postReposOwnerRepoCommitsShaCodeComments
  ## Create a commit comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  ##          : SHA-1 code of the commit.
  var path_39461571 = newJObject()
  var header_39461572 = newJObject()
  var body_39461573 = newJObject()
  add(path_39461571, "owner", newJString(owner))
  add(header_39461572, "Accept", newJString(Accept))
  if body != nil:
    body_39461573 = body
  add(path_39461571, "repo", newJString(repo))
  add(path_39461571, "shaCode", newJString(shaCode))
  result = call_39461570.call(path_39461571, nil, header_39461572, nil, body_39461573)

var postReposOwnerRepoCommitsShaCodeComments* = Call_PostReposOwnerRepoCommitsShaCodeComments_39461561(
    name: "postReposOwnerRepoCommitsShaCodeComments", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/commits/{shaCode}/comments",
    validator: validate_PostReposOwnerRepoCommitsShaCodeComments_39461562,
    base: "/", url: url_PostReposOwnerRepoCommitsShaCodeComments_39461563,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommitsShaCodeComments_39461550 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoCommitsShaCodeComments_39461552(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits/"),
               (kind: VariableSegment, value: "shaCode"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommitsShaCodeComments_39461551(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List comments for a single commitList comments for a single commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  ##          : SHA-1 code of the commit.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461553 = path.getOrDefault("owner")
  valid_39461553 = validateParameter(valid_39461553, JString, required = true,
                                   default = nil)
  if valid_39461553 != nil:
    section.add "owner", valid_39461553
  var valid_39461554 = path.getOrDefault("repo")
  valid_39461554 = validateParameter(valid_39461554, JString, required = true,
                                   default = nil)
  if valid_39461554 != nil:
    section.add "repo", valid_39461554
  var valid_39461555 = path.getOrDefault("shaCode")
  valid_39461555 = validateParameter(valid_39461555, JString, required = true,
                                   default = nil)
  if valid_39461555 != nil:
    section.add "shaCode", valid_39461555
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461556 = header.getOrDefault("Accept")
  valid_39461556 = validateParameter(valid_39461556, JString, required = false,
                                   default = nil)
  if valid_39461556 != nil:
    section.add "Accept", valid_39461556
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461557: Call_GetReposOwnerRepoCommitsShaCodeComments_39461550;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List comments for a single commitList comments for a single commit.
  ## 
  let valid = call_39461557.validator(path, query, header, formData, body, _)
  let scheme = call_39461557.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461557.url(scheme.get, call_39461557.host, call_39461557.base,
                           call_39461557.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461557, uri, valid, _)

proc call*(call_39461558: Call_GetReposOwnerRepoCommitsShaCodeComments_39461550;
          owner: string; repo: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommitsShaCodeComments
  ## List comments for a single commitList comments for a single commit.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  ##          : SHA-1 code of the commit.
  var path_39461559 = newJObject()
  var header_39461560 = newJObject()
  add(path_39461559, "owner", newJString(owner))
  add(header_39461560, "Accept", newJString(Accept))
  add(path_39461559, "repo", newJString(repo))
  add(path_39461559, "shaCode", newJString(shaCode))
  result = call_39461558.call(path_39461559, nil, header_39461560, nil, nil)

var getReposOwnerRepoCommitsShaCodeComments* = Call_GetReposOwnerRepoCommitsShaCodeComments_39461550(
    name: "getReposOwnerRepoCommitsShaCodeComments", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/commits/{shaCode}/comments",
    validator: validate_GetReposOwnerRepoCommitsShaCodeComments_39461551,
    base: "/", url: url_GetReposOwnerRepoCommitsShaCodeComments_39461552,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCompareBaseIdHeadId_39461574 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoCompareBaseIdHeadId_39461576(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "baseId" in path, "`baseId` is a required path parameter"
  assert "headId" in path, "`headId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/compare/"),
               (kind: VariableSegment, value: "baseId"),
               (kind: ConstantSegment, value: "..."),
               (kind: VariableSegment, value: "headId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCompareBaseIdHeadId_39461575(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Compare two commits
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   baseId: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   headId: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461577 = path.getOrDefault("owner")
  valid_39461577 = validateParameter(valid_39461577, JString, required = true,
                                   default = nil)
  if valid_39461577 != nil:
    section.add "owner", valid_39461577
  var valid_39461578 = path.getOrDefault("baseId")
  valid_39461578 = validateParameter(valid_39461578, JString, required = true,
                                   default = nil)
  if valid_39461578 != nil:
    section.add "baseId", valid_39461578
  var valid_39461579 = path.getOrDefault("repo")
  valid_39461579 = validateParameter(valid_39461579, JString, required = true,
                                   default = nil)
  if valid_39461579 != nil:
    section.add "repo", valid_39461579
  var valid_39461580 = path.getOrDefault("headId")
  valid_39461580 = validateParameter(valid_39461580, JString, required = true,
                                   default = nil)
  if valid_39461580 != nil:
    section.add "headId", valid_39461580
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461581 = header.getOrDefault("Accept")
  valid_39461581 = validateParameter(valid_39461581, JString, required = false,
                                   default = nil)
  if valid_39461581 != nil:
    section.add "Accept", valid_39461581
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461582: Call_GetReposOwnerRepoCompareBaseIdHeadId_39461574;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Compare two commits
  ## 
  let valid = call_39461582.validator(path, query, header, formData, body, _)
  let scheme = call_39461582.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461582.url(scheme.get, call_39461582.host, call_39461582.base,
                           call_39461582.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461582, uri, valid, _)

proc call*(call_39461583: Call_GetReposOwnerRepoCompareBaseIdHeadId_39461574;
          owner: string; baseId: string; repo: string; headId: string;
          Accept: string = ""): Recallable =
  ## getReposOwnerRepoCompareBaseIdHeadId
  ## Compare two commits
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   baseId: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   headId: string (required)
  var path_39461584 = newJObject()
  var header_39461585 = newJObject()
  add(path_39461584, "owner", newJString(owner))
  add(path_39461584, "baseId", newJString(baseId))
  add(header_39461585, "Accept", newJString(Accept))
  add(path_39461584, "repo", newJString(repo))
  add(path_39461584, "headId", newJString(headId))
  result = call_39461583.call(path_39461584, nil, header_39461585, nil, nil)

var getReposOwnerRepoCompareBaseIdHeadId* = Call_GetReposOwnerRepoCompareBaseIdHeadId_39461574(
    name: "getReposOwnerRepoCompareBaseIdHeadId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/compare/{baseId}...{headId}",
    validator: validate_GetReposOwnerRepoCompareBaseIdHeadId_39461575, base: "/",
    url: url_GetReposOwnerRepoCompareBaseIdHeadId_39461576,
    schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoContentsPath_39461600 = ref object of OpenApiRestCall_39460352
proc url_PutReposOwnerRepoContentsPath_39461602(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/contents/"),
               (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoContentsPath_39461601(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Create a file.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   path: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461603 = path.getOrDefault("owner")
  valid_39461603 = validateParameter(valid_39461603, JString, required = true,
                                   default = nil)
  if valid_39461603 != nil:
    section.add "owner", valid_39461603
  var valid_39461604 = path.getOrDefault("repo")
  valid_39461604 = validateParameter(valid_39461604, JString, required = true,
                                   default = nil)
  if valid_39461604 != nil:
    section.add "repo", valid_39461604
  var valid_39461605 = path.getOrDefault("path")
  valid_39461605 = validateParameter(valid_39461605, JString, required = true,
                                   default = nil)
  if valid_39461605 != nil:
    section.add "path", valid_39461605
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461606 = header.getOrDefault("Accept")
  valid_39461606 = validateParameter(valid_39461606, JString, required = false,
                                   default = nil)
  if valid_39461606 != nil:
    section.add "Accept", valid_39461606
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39461608: Call_PutReposOwnerRepoContentsPath_39461600;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a file.
  ## 
  let valid = call_39461608.validator(path, query, header, formData, body, _)
  let scheme = call_39461608.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461608.url(scheme.get, call_39461608.host, call_39461608.base,
                           call_39461608.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461608, uri, valid, _)

proc call*(call_39461609: Call_PutReposOwnerRepoContentsPath_39461600;
          owner: string; body: JsonNode; repo: string; path: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoContentsPath
  ## Create a file.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   path: string (required)
  var path_39461610 = newJObject()
  var header_39461611 = newJObject()
  var body_39461612 = newJObject()
  add(path_39461610, "owner", newJString(owner))
  add(header_39461611, "Accept", newJString(Accept))
  if body != nil:
    body_39461612 = body
  add(path_39461610, "repo", newJString(repo))
  add(path_39461610, "path", newJString(path))
  result = call_39461609.call(path_39461610, nil, header_39461611, nil, body_39461612)

var putReposOwnerRepoContentsPath* = Call_PutReposOwnerRepoContentsPath_39461600(
    name: "putReposOwnerRepoContentsPath", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contents/{path}",
    validator: validate_PutReposOwnerRepoContentsPath_39461601, base: "/",
    url: url_PutReposOwnerRepoContentsPath_39461602, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoContentsPath_39461586 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoContentsPath_39461588(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/contents/"),
               (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoContentsPath_39461587(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get contents.
  ## This method returns the contents of a file or directory in a repository.
  ## Files and symlinks support a custom media type for getting the raw content.
  ## Directories and submodules do not support custom media types.
  ## Note: This API supports files up to 1 megabyte in size.
  ## Here can be many outcomes. For details see "http://developer.github.com/v3/repos/contents/"
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   path: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461589 = path.getOrDefault("owner")
  valid_39461589 = validateParameter(valid_39461589, JString, required = true,
                                   default = nil)
  if valid_39461589 != nil:
    section.add "owner", valid_39461589
  var valid_39461590 = path.getOrDefault("repo")
  valid_39461590 = validateParameter(valid_39461590, JString, required = true,
                                   default = nil)
  if valid_39461590 != nil:
    section.add "repo", valid_39461590
  var valid_39461591 = path.getOrDefault("path")
  valid_39461591 = validateParameter(valid_39461591, JString, required = true,
                                   default = nil)
  if valid_39461591 != nil:
    section.add "path", valid_39461591
  result.add "path", section
  ## parameters in `query` object:
  ##   path: JString
  ##       : The content path.
  ##   ref: JString
  ##      : The String name of the Commit/Branch/Tag. Defaults to 'master'.
  section = newJObject()
  var valid_39461592 = query.getOrDefault("path")
  valid_39461592 = validateParameter(valid_39461592, JString, required = false,
                                   default = nil)
  if valid_39461592 != nil:
    section.add "path", valid_39461592
  var valid_39461593 = query.getOrDefault("ref")
  valid_39461593 = validateParameter(valid_39461593, JString, required = false,
                                   default = nil)
  if valid_39461593 != nil:
    section.add "ref", valid_39461593
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461594 = header.getOrDefault("Accept")
  valid_39461594 = validateParameter(valid_39461594, JString, required = false,
                                   default = nil)
  if valid_39461594 != nil:
    section.add "Accept", valid_39461594
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461595: Call_GetReposOwnerRepoContentsPath_39461586;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get contents.
  ## This method returns the contents of a file or directory in a repository.
  ## Files and symlinks support a custom media type for getting the raw content.
  ## Directories and submodules do not support custom media types.
  ## Note: This API supports files up to 1 megabyte in size.
  ## Here can be many outcomes. For details see "http://developer.github.com/v3/repos/contents/"
  ## 
  ## 
  let valid = call_39461595.validator(path, query, header, formData, body, _)
  let scheme = call_39461595.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461595.url(scheme.get, call_39461595.host, call_39461595.base,
                           call_39461595.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461595, uri, valid, _)

var getReposOwnerRepoContentsPath* = Call_GetReposOwnerRepoContentsPath_39461586(
    name: "getReposOwnerRepoContentsPath", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contents/{path}",
    validator: validate_GetReposOwnerRepoContentsPath_39461587, base: "/",
    url: url_GetReposOwnerRepoContentsPath_39461588, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoContentsPath_39461613 = ref object of OpenApiRestCall_39460352
proc url_DeleteReposOwnerRepoContentsPath_39461615(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/contents/"),
               (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoContentsPath_39461614(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a file.
  ## This method deletes a file in a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   path: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461616 = path.getOrDefault("owner")
  valid_39461616 = validateParameter(valid_39461616, JString, required = true,
                                   default = nil)
  if valid_39461616 != nil:
    section.add "owner", valid_39461616
  var valid_39461617 = path.getOrDefault("repo")
  valid_39461617 = validateParameter(valid_39461617, JString, required = true,
                                   default = nil)
  if valid_39461617 != nil:
    section.add "repo", valid_39461617
  var valid_39461618 = path.getOrDefault("path")
  valid_39461618 = validateParameter(valid_39461618, JString, required = true,
                                   default = nil)
  if valid_39461618 != nil:
    section.add "path", valid_39461618
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461619 = header.getOrDefault("Accept")
  valid_39461619 = validateParameter(valid_39461619, JString, required = false,
                                   default = nil)
  if valid_39461619 != nil:
    section.add "Accept", valid_39461619
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39461621: Call_DeleteReposOwnerRepoContentsPath_39461613;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a file.
  ## This method deletes a file in a repository.
  ## 
  ## 
  let valid = call_39461621.validator(path, query, header, formData, body, _)
  let scheme = call_39461621.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461621.url(scheme.get, call_39461621.host, call_39461621.base,
                           call_39461621.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461621, uri, valid, _)

proc call*(call_39461622: Call_DeleteReposOwnerRepoContentsPath_39461613;
          owner: string; body: JsonNode; repo: string; path: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoContentsPath
  ## Delete a file.
  ## This method deletes a file in a repository.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   path: string (required)
  var path_39461623 = newJObject()
  var header_39461624 = newJObject()
  var body_39461625 = newJObject()
  add(path_39461623, "owner", newJString(owner))
  add(header_39461624, "Accept", newJString(Accept))
  if body != nil:
    body_39461625 = body
  add(path_39461623, "repo", newJString(repo))
  add(path_39461623, "path", newJString(path))
  result = call_39461622.call(path_39461623, nil, header_39461624, nil, body_39461625)

var deleteReposOwnerRepoContentsPath* = Call_DeleteReposOwnerRepoContentsPath_39461613(
    name: "deleteReposOwnerRepoContentsPath", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contents/{path}",
    validator: validate_DeleteReposOwnerRepoContentsPath_39461614, base: "/",
    url: url_DeleteReposOwnerRepoContentsPath_39461615, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoContributors_39461626 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoContributors_39461628(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/contributors")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoContributors_39461627(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get list of contributors.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461629 = path.getOrDefault("owner")
  valid_39461629 = validateParameter(valid_39461629, JString, required = true,
                                   default = nil)
  if valid_39461629 != nil:
    section.add "owner", valid_39461629
  var valid_39461630 = path.getOrDefault("repo")
  valid_39461630 = validateParameter(valid_39461630, JString, required = true,
                                   default = nil)
  if valid_39461630 != nil:
    section.add "repo", valid_39461630
  result.add "path", section
  ## parameters in `query` object:
  ##   anon: JString (required)
  ##       : Set to 1 or true to include anonymous contributors in results.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `anon` field"
  var valid_39461631 = query.getOrDefault("anon")
  valid_39461631 = validateParameter(valid_39461631, JString, required = true,
                                   default = nil)
  if valid_39461631 != nil:
    section.add "anon", valid_39461631
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461632 = header.getOrDefault("Accept")
  valid_39461632 = validateParameter(valid_39461632, JString, required = false,
                                   default = nil)
  if valid_39461632 != nil:
    section.add "Accept", valid_39461632
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461633: Call_GetReposOwnerRepoContributors_39461626;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get list of contributors.
  ## 
  let valid = call_39461633.validator(path, query, header, formData, body, _)
  let scheme = call_39461633.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461633.url(scheme.get, call_39461633.host, call_39461633.base,
                           call_39461633.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461633, uri, valid, _)

proc call*(call_39461634: Call_GetReposOwnerRepoContributors_39461626;
          owner: string; repo: string; anon: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoContributors
  ## Get list of contributors.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   anon: string (required)
  ##       : Set to 1 or true to include anonymous contributors in results.
  var path_39461635 = newJObject()
  var query_39461636 = newJObject()
  var header_39461637 = newJObject()
  add(path_39461635, "owner", newJString(owner))
  add(header_39461637, "Accept", newJString(Accept))
  add(path_39461635, "repo", newJString(repo))
  add(query_39461636, "anon", newJString(anon))
  result = call_39461634.call(path_39461635, query_39461636, header_39461637, nil, nil)

var getReposOwnerRepoContributors* = Call_GetReposOwnerRepoContributors_39461626(
    name: "getReposOwnerRepoContributors", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contributors",
    validator: validate_GetReposOwnerRepoContributors_39461627, base: "/",
    url: url_GetReposOwnerRepoContributors_39461628, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoDeployments_39461648 = ref object of OpenApiRestCall_39460352
proc url_PostReposOwnerRepoDeployments_39461650(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/deployments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoDeployments_39461649(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Users with push access can create a deployment for a given ref
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461651 = path.getOrDefault("owner")
  valid_39461651 = validateParameter(valid_39461651, JString, required = true,
                                   default = nil)
  if valid_39461651 != nil:
    section.add "owner", valid_39461651
  var valid_39461652 = path.getOrDefault("repo")
  valid_39461652 = validateParameter(valid_39461652, JString, required = true,
                                   default = nil)
  if valid_39461652 != nil:
    section.add "repo", valid_39461652
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461653 = header.getOrDefault("Accept")
  valid_39461653 = validateParameter(valid_39461653, JString, required = false,
                                   default = nil)
  if valid_39461653 != nil:
    section.add "Accept", valid_39461653
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39461655: Call_PostReposOwnerRepoDeployments_39461648;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Users with push access can create a deployment for a given ref
  ## 
  let valid = call_39461655.validator(path, query, header, formData, body, _)
  let scheme = call_39461655.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461655.url(scheme.get, call_39461655.host, call_39461655.base,
                           call_39461655.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461655, uri, valid, _)

proc call*(call_39461656: Call_PostReposOwnerRepoDeployments_39461648;
          owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoDeployments
  ## Users with push access can create a deployment for a given ref
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461657 = newJObject()
  var header_39461658 = newJObject()
  var body_39461659 = newJObject()
  add(path_39461657, "owner", newJString(owner))
  add(header_39461658, "Accept", newJString(Accept))
  if body != nil:
    body_39461659 = body
  add(path_39461657, "repo", newJString(repo))
  result = call_39461656.call(path_39461657, nil, header_39461658, nil, body_39461659)

var postReposOwnerRepoDeployments* = Call_PostReposOwnerRepoDeployments_39461648(
    name: "postReposOwnerRepoDeployments", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/deployments",
    validator: validate_PostReposOwnerRepoDeployments_39461649, base: "/",
    url: url_PostReposOwnerRepoDeployments_39461650, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDeployments_39461638 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoDeployments_39461640(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/deployments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDeployments_39461639(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Users with pull access can view deployments for a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461641 = path.getOrDefault("owner")
  valid_39461641 = validateParameter(valid_39461641, JString, required = true,
                                   default = nil)
  if valid_39461641 != nil:
    section.add "owner", valid_39461641
  var valid_39461642 = path.getOrDefault("repo")
  valid_39461642 = validateParameter(valid_39461642, JString, required = true,
                                   default = nil)
  if valid_39461642 != nil:
    section.add "repo", valid_39461642
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461643 = header.getOrDefault("Accept")
  valid_39461643 = validateParameter(valid_39461643, JString, required = false,
                                   default = nil)
  if valid_39461643 != nil:
    section.add "Accept", valid_39461643
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461644: Call_GetReposOwnerRepoDeployments_39461638;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Users with pull access can view deployments for a repository
  ## 
  let valid = call_39461644.validator(path, query, header, formData, body, _)
  let scheme = call_39461644.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461644.url(scheme.get, call_39461644.host, call_39461644.base,
                           call_39461644.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461644, uri, valid, _)

proc call*(call_39461645: Call_GetReposOwnerRepoDeployments_39461638;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDeployments
  ## Users with pull access can view deployments for a repository
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461646 = newJObject()
  var header_39461647 = newJObject()
  add(path_39461646, "owner", newJString(owner))
  add(header_39461647, "Accept", newJString(Accept))
  add(path_39461646, "repo", newJString(repo))
  result = call_39461645.call(path_39461646, nil, header_39461647, nil, nil)

var getReposOwnerRepoDeployments* = Call_GetReposOwnerRepoDeployments_39461638(
    name: "getReposOwnerRepoDeployments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/deployments",
    validator: validate_GetReposOwnerRepoDeployments_39461639, base: "/",
    url: url_GetReposOwnerRepoDeployments_39461640, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoDeploymentsIdStatuses_39461671 = ref object of OpenApiRestCall_39460352
proc url_PostReposOwnerRepoDeploymentsIdStatuses_39461673(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/deployments/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/statuses")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoDeploymentsIdStatuses_39461672(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Create a Deployment Status
  ## Users with push access can create deployment statuses for a given deployment:
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JInt (required)
  ##     : The Deployment ID to list the statuses from.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461674 = path.getOrDefault("owner")
  valid_39461674 = validateParameter(valid_39461674, JString, required = true,
                                   default = nil)
  if valid_39461674 != nil:
    section.add "owner", valid_39461674
  var valid_39461675 = path.getOrDefault("id")
  valid_39461675 = validateParameter(valid_39461675, JInt, required = true,
                                   default = nil)
  if valid_39461675 != nil:
    section.add "id", valid_39461675
  var valid_39461676 = path.getOrDefault("repo")
  valid_39461676 = validateParameter(valid_39461676, JString, required = true,
                                   default = nil)
  if valid_39461676 != nil:
    section.add "repo", valid_39461676
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461677 = header.getOrDefault("Accept")
  valid_39461677 = validateParameter(valid_39461677, JString, required = false,
                                   default = nil)
  if valid_39461677 != nil:
    section.add "Accept", valid_39461677
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39461679: Call_PostReposOwnerRepoDeploymentsIdStatuses_39461671;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a Deployment Status
  ## Users with push access can create deployment statuses for a given deployment:
  ## 
  ## 
  let valid = call_39461679.validator(path, query, header, formData, body, _)
  let scheme = call_39461679.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461679.url(scheme.get, call_39461679.host, call_39461679.base,
                           call_39461679.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461679, uri, valid, _)

proc call*(call_39461680: Call_PostReposOwnerRepoDeploymentsIdStatuses_39461671;
          owner: string; id: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoDeploymentsIdStatuses
  ## Create a Deployment Status
  ## Users with push access can create deployment statuses for a given deployment:
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: int (required)
  ##     : The Deployment ID to list the statuses from.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461681 = newJObject()
  var header_39461682 = newJObject()
  var body_39461683 = newJObject()
  add(path_39461681, "owner", newJString(owner))
  add(path_39461681, "id", newJInt(id))
  add(header_39461682, "Accept", newJString(Accept))
  if body != nil:
    body_39461683 = body
  add(path_39461681, "repo", newJString(repo))
  result = call_39461680.call(path_39461681, nil, header_39461682, nil, body_39461683)

var postReposOwnerRepoDeploymentsIdStatuses* = Call_PostReposOwnerRepoDeploymentsIdStatuses_39461671(
    name: "postReposOwnerRepoDeploymentsIdStatuses", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/deployments/{id}/statuses",
    validator: validate_PostReposOwnerRepoDeploymentsIdStatuses_39461672,
    base: "/", url: url_PostReposOwnerRepoDeploymentsIdStatuses_39461673,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDeploymentsIdStatuses_39461660 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoDeploymentsIdStatuses_39461662(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/deployments/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/statuses")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDeploymentsIdStatuses_39461661(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Users with pull access can view deployment statuses for a deployment
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JInt (required)
  ##     : The Deployment ID to list the statuses from.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461663 = path.getOrDefault("owner")
  valid_39461663 = validateParameter(valid_39461663, JString, required = true,
                                   default = nil)
  if valid_39461663 != nil:
    section.add "owner", valid_39461663
  var valid_39461664 = path.getOrDefault("id")
  valid_39461664 = validateParameter(valid_39461664, JInt, required = true,
                                   default = nil)
  if valid_39461664 != nil:
    section.add "id", valid_39461664
  var valid_39461665 = path.getOrDefault("repo")
  valid_39461665 = validateParameter(valid_39461665, JString, required = true,
                                   default = nil)
  if valid_39461665 != nil:
    section.add "repo", valid_39461665
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461666 = header.getOrDefault("Accept")
  valid_39461666 = validateParameter(valid_39461666, JString, required = false,
                                   default = nil)
  if valid_39461666 != nil:
    section.add "Accept", valid_39461666
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461667: Call_GetReposOwnerRepoDeploymentsIdStatuses_39461660;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Users with pull access can view deployment statuses for a deployment
  ## 
  let valid = call_39461667.validator(path, query, header, formData, body, _)
  let scheme = call_39461667.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461667.url(scheme.get, call_39461667.host, call_39461667.base,
                           call_39461667.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461667, uri, valid, _)

proc call*(call_39461668: Call_GetReposOwnerRepoDeploymentsIdStatuses_39461660;
          owner: string; id: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDeploymentsIdStatuses
  ## Users with pull access can view deployment statuses for a deployment
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: int (required)
  ##     : The Deployment ID to list the statuses from.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461669 = newJObject()
  var header_39461670 = newJObject()
  add(path_39461669, "owner", newJString(owner))
  add(path_39461669, "id", newJInt(id))
  add(header_39461670, "Accept", newJString(Accept))
  add(path_39461669, "repo", newJString(repo))
  result = call_39461668.call(path_39461669, nil, header_39461670, nil, nil)

var getReposOwnerRepoDeploymentsIdStatuses* = Call_GetReposOwnerRepoDeploymentsIdStatuses_39461660(
    name: "getReposOwnerRepoDeploymentsIdStatuses", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/deployments/{id}/statuses",
    validator: validate_GetReposOwnerRepoDeploymentsIdStatuses_39461661,
    base: "/", url: url_GetReposOwnerRepoDeploymentsIdStatuses_39461662,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDownloads_39461684 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoDownloads_39461686(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/downloads")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDownloads_39461685(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Deprecated. List downloads for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461687 = path.getOrDefault("owner")
  valid_39461687 = validateParameter(valid_39461687, JString, required = true,
                                   default = nil)
  if valid_39461687 != nil:
    section.add "owner", valid_39461687
  var valid_39461688 = path.getOrDefault("repo")
  valid_39461688 = validateParameter(valid_39461688, JString, required = true,
                                   default = nil)
  if valid_39461688 != nil:
    section.add "repo", valid_39461688
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461689 = header.getOrDefault("Accept")
  valid_39461689 = validateParameter(valid_39461689, JString, required = false,
                                   default = nil)
  if valid_39461689 != nil:
    section.add "Accept", valid_39461689
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461690: Call_GetReposOwnerRepoDownloads_39461684;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Deprecated. List downloads for a repository.
  ## 
  let valid = call_39461690.validator(path, query, header, formData, body, _)
  let scheme = call_39461690.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461690.url(scheme.get, call_39461690.host, call_39461690.base,
                           call_39461690.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461690, uri, valid, _)

proc call*(call_39461691: Call_GetReposOwnerRepoDownloads_39461684; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDownloads
  ## Deprecated. List downloads for a repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461692 = newJObject()
  var header_39461693 = newJObject()
  add(path_39461692, "owner", newJString(owner))
  add(header_39461693, "Accept", newJString(Accept))
  add(path_39461692, "repo", newJString(repo))
  result = call_39461691.call(path_39461692, nil, header_39461693, nil, nil)

var getReposOwnerRepoDownloads* = Call_GetReposOwnerRepoDownloads_39461684(
    name: "getReposOwnerRepoDownloads", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/downloads",
    validator: validate_GetReposOwnerRepoDownloads_39461685, base: "/",
    url: url_GetReposOwnerRepoDownloads_39461686, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDownloadsDownloadId_39461694 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoDownloadsDownloadId_39461696(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "downloadId" in path, "`downloadId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/downloads/"),
               (kind: VariableSegment, value: "downloadId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDownloadsDownloadId_39461695(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Deprecated. Get a single download.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   downloadId: JInt (required)
  ##             : Id of download.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461697 = path.getOrDefault("owner")
  valid_39461697 = validateParameter(valid_39461697, JString, required = true,
                                   default = nil)
  if valid_39461697 != nil:
    section.add "owner", valid_39461697
  var valid_39461698 = path.getOrDefault("repo")
  valid_39461698 = validateParameter(valid_39461698, JString, required = true,
                                   default = nil)
  if valid_39461698 != nil:
    section.add "repo", valid_39461698
  var valid_39461699 = path.getOrDefault("downloadId")
  valid_39461699 = validateParameter(valid_39461699, JInt, required = true,
                                   default = nil)
  if valid_39461699 != nil:
    section.add "downloadId", valid_39461699
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461700 = header.getOrDefault("Accept")
  valid_39461700 = validateParameter(valid_39461700, JString, required = false,
                                   default = nil)
  if valid_39461700 != nil:
    section.add "Accept", valid_39461700
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461701: Call_GetReposOwnerRepoDownloadsDownloadId_39461694;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Deprecated. Get a single download.
  ## 
  let valid = call_39461701.validator(path, query, header, formData, body, _)
  let scheme = call_39461701.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461701.url(scheme.get, call_39461701.host, call_39461701.base,
                           call_39461701.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461701, uri, valid, _)

proc call*(call_39461702: Call_GetReposOwnerRepoDownloadsDownloadId_39461694;
          owner: string; repo: string; downloadId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDownloadsDownloadId
  ## Deprecated. Get a single download.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   downloadId: int (required)
  ##             : Id of download.
  var path_39461703 = newJObject()
  var header_39461704 = newJObject()
  add(path_39461703, "owner", newJString(owner))
  add(header_39461704, "Accept", newJString(Accept))
  add(path_39461703, "repo", newJString(repo))
  add(path_39461703, "downloadId", newJInt(downloadId))
  result = call_39461702.call(path_39461703, nil, header_39461704, nil, nil)

var getReposOwnerRepoDownloadsDownloadId* = Call_GetReposOwnerRepoDownloadsDownloadId_39461694(
    name: "getReposOwnerRepoDownloadsDownloadId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/downloads/{downloadId}",
    validator: validate_GetReposOwnerRepoDownloadsDownloadId_39461695, base: "/",
    url: url_GetReposOwnerRepoDownloadsDownloadId_39461696,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoDownloadsDownloadId_39461705 = ref object of OpenApiRestCall_39460352
proc url_DeleteReposOwnerRepoDownloadsDownloadId_39461707(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "downloadId" in path, "`downloadId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/downloads/"),
               (kind: VariableSegment, value: "downloadId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoDownloadsDownloadId_39461706(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Deprecated. Delete a download.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   downloadId: JInt (required)
  ##             : Id of download.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461708 = path.getOrDefault("owner")
  valid_39461708 = validateParameter(valid_39461708, JString, required = true,
                                   default = nil)
  if valid_39461708 != nil:
    section.add "owner", valid_39461708
  var valid_39461709 = path.getOrDefault("repo")
  valid_39461709 = validateParameter(valid_39461709, JString, required = true,
                                   default = nil)
  if valid_39461709 != nil:
    section.add "repo", valid_39461709
  var valid_39461710 = path.getOrDefault("downloadId")
  valid_39461710 = validateParameter(valid_39461710, JInt, required = true,
                                   default = nil)
  if valid_39461710 != nil:
    section.add "downloadId", valid_39461710
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461711 = header.getOrDefault("Accept")
  valid_39461711 = validateParameter(valid_39461711, JString, required = false,
                                   default = nil)
  if valid_39461711 != nil:
    section.add "Accept", valid_39461711
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461712: Call_DeleteReposOwnerRepoDownloadsDownloadId_39461705;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Deprecated. Delete a download.
  ## 
  let valid = call_39461712.validator(path, query, header, formData, body, _)
  let scheme = call_39461712.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461712.url(scheme.get, call_39461712.host, call_39461712.base,
                           call_39461712.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461712, uri, valid, _)

proc call*(call_39461713: Call_DeleteReposOwnerRepoDownloadsDownloadId_39461705;
          owner: string; repo: string; downloadId: int; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoDownloadsDownloadId
  ## Deprecated. Delete a download.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   downloadId: int (required)
  ##             : Id of download.
  var path_39461714 = newJObject()
  var header_39461715 = newJObject()
  add(path_39461714, "owner", newJString(owner))
  add(header_39461715, "Accept", newJString(Accept))
  add(path_39461714, "repo", newJString(repo))
  add(path_39461714, "downloadId", newJInt(downloadId))
  result = call_39461713.call(path_39461714, nil, header_39461715, nil, nil)

var deleteReposOwnerRepoDownloadsDownloadId* = Call_DeleteReposOwnerRepoDownloadsDownloadId_39461705(
    name: "deleteReposOwnerRepoDownloadsDownloadId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/downloads/{downloadId}",
    validator: validate_DeleteReposOwnerRepoDownloadsDownloadId_39461706,
    base: "/", url: url_DeleteReposOwnerRepoDownloadsDownloadId_39461707,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoEvents_39461716 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoEvents_39461718(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoEvents_39461717(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get list of repository events.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461719 = path.getOrDefault("owner")
  valid_39461719 = validateParameter(valid_39461719, JString, required = true,
                                   default = nil)
  if valid_39461719 != nil:
    section.add "owner", valid_39461719
  var valid_39461720 = path.getOrDefault("repo")
  valid_39461720 = validateParameter(valid_39461720, JString, required = true,
                                   default = nil)
  if valid_39461720 != nil:
    section.add "repo", valid_39461720
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461721 = header.getOrDefault("Accept")
  valid_39461721 = validateParameter(valid_39461721, JString, required = false,
                                   default = nil)
  if valid_39461721 != nil:
    section.add "Accept", valid_39461721
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461722: Call_GetReposOwnerRepoEvents_39461716;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get list of repository events.
  ## 
  let valid = call_39461722.validator(path, query, header, formData, body, _)
  let scheme = call_39461722.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461722.url(scheme.get, call_39461722.host, call_39461722.base,
                           call_39461722.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461722, uri, valid, _)

proc call*(call_39461723: Call_GetReposOwnerRepoEvents_39461716; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoEvents
  ## Get list of repository events.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461724 = newJObject()
  var header_39461725 = newJObject()
  add(path_39461724, "owner", newJString(owner))
  add(header_39461725, "Accept", newJString(Accept))
  add(path_39461724, "repo", newJString(repo))
  result = call_39461723.call(path_39461724, nil, header_39461725, nil, nil)

var getReposOwnerRepoEvents* = Call_GetReposOwnerRepoEvents_39461716(
    name: "getReposOwnerRepoEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/events",
    validator: validate_GetReposOwnerRepoEvents_39461717, base: "/",
    url: url_GetReposOwnerRepoEvents_39461718, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoForks_39461738 = ref object of OpenApiRestCall_39460352
proc url_PostReposOwnerRepoForks_39461740(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/forks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoForks_39461739(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a fork.
  ## Forking a Repository happens asynchronously. Therefore, you may have to wai
  ## a short period before accessing the git objects. If this takes longer than 5
  ## minutes, be sure to contact Support.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461741 = path.getOrDefault("owner")
  valid_39461741 = validateParameter(valid_39461741, JString, required = true,
                                   default = nil)
  if valid_39461741 != nil:
    section.add "owner", valid_39461741
  var valid_39461742 = path.getOrDefault("repo")
  valid_39461742 = validateParameter(valid_39461742, JString, required = true,
                                   default = nil)
  if valid_39461742 != nil:
    section.add "repo", valid_39461742
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461743 = header.getOrDefault("Accept")
  valid_39461743 = validateParameter(valid_39461743, JString, required = false,
                                   default = nil)
  if valid_39461743 != nil:
    section.add "Accept", valid_39461743
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39461745: Call_PostReposOwnerRepoForks_39461738;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a fork.
  ## Forking a Repository happens asynchronously. Therefore, you may have to wai
  ## a short period before accessing the git objects. If this takes longer than 5
  ## minutes, be sure to contact Support.
  ## 
  ## 
  let valid = call_39461745.validator(path, query, header, formData, body, _)
  let scheme = call_39461745.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461745.url(scheme.get, call_39461745.host, call_39461745.base,
                           call_39461745.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461745, uri, valid, _)

proc call*(call_39461746: Call_PostReposOwnerRepoForks_39461738; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoForks
  ## Create a fork.
  ## Forking a Repository happens asynchronously. Therefore, you may have to wai
  ## a short period before accessing the git objects. If this takes longer than 5
  ## minutes, be sure to contact Support.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461747 = newJObject()
  var header_39461748 = newJObject()
  var body_39461749 = newJObject()
  add(path_39461747, "owner", newJString(owner))
  add(header_39461748, "Accept", newJString(Accept))
  if body != nil:
    body_39461749 = body
  add(path_39461747, "repo", newJString(repo))
  result = call_39461746.call(path_39461747, nil, header_39461748, nil, body_39461749)

var postReposOwnerRepoForks* = Call_PostReposOwnerRepoForks_39461738(
    name: "postReposOwnerRepoForks", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/forks",
    validator: validate_PostReposOwnerRepoForks_39461739, base: "/",
    url: url_PostReposOwnerRepoForks_39461740, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoForks_39461726 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoForks_39461728(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/forks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoForks_39461727(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List forks.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461729 = path.getOrDefault("owner")
  valid_39461729 = validateParameter(valid_39461729, JString, required = true,
                                   default = nil)
  if valid_39461729 != nil:
    section.add "owner", valid_39461729
  var valid_39461730 = path.getOrDefault("repo")
  valid_39461730 = validateParameter(valid_39461730, JString, required = true,
                                   default = nil)
  if valid_39461730 != nil:
    section.add "repo", valid_39461730
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  section = newJObject()
  var valid_39461731 = query.getOrDefault("sort")
  valid_39461731 = validateParameter(valid_39461731, JString, required = false,
                                   default = newJString("newes"))
  if valid_39461731 != nil:
    section.add "sort", valid_39461731
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461732 = header.getOrDefault("Accept")
  valid_39461732 = validateParameter(valid_39461732, JString, required = false,
                                   default = nil)
  if valid_39461732 != nil:
    section.add "Accept", valid_39461732
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461733: Call_GetReposOwnerRepoForks_39461726;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List forks.
  ## 
  let valid = call_39461733.validator(path, query, header, formData, body, _)
  let scheme = call_39461733.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461733.url(scheme.get, call_39461733.host, call_39461733.base,
                           call_39461733.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461733, uri, valid, _)

proc call*(call_39461734: Call_GetReposOwnerRepoForks_39461726; owner: string;
          repo: string; Accept: string = ""; sort: string = "newes"): Recallable =
  ## getReposOwnerRepoForks
  ## List forks.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   sort: string
  var path_39461735 = newJObject()
  var query_39461736 = newJObject()
  var header_39461737 = newJObject()
  add(path_39461735, "owner", newJString(owner))
  add(header_39461737, "Accept", newJString(Accept))
  add(path_39461735, "repo", newJString(repo))
  add(query_39461736, "sort", newJString(sort))
  result = call_39461734.call(path_39461735, query_39461736, header_39461737, nil, nil)

var getReposOwnerRepoForks* = Call_GetReposOwnerRepoForks_39461726(
    name: "getReposOwnerRepoForks", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/forks",
    validator: validate_GetReposOwnerRepoForks_39461727, base: "/",
    url: url_GetReposOwnerRepoForks_39461728, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitBlobs_39461750 = ref object of OpenApiRestCall_39460352
proc url_PostReposOwnerRepoGitBlobs_39461752(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/blobs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitBlobs_39461751(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a Blob.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461753 = path.getOrDefault("owner")
  valid_39461753 = validateParameter(valid_39461753, JString, required = true,
                                   default = nil)
  if valid_39461753 != nil:
    section.add "owner", valid_39461753
  var valid_39461754 = path.getOrDefault("repo")
  valid_39461754 = validateParameter(valid_39461754, JString, required = true,
                                   default = nil)
  if valid_39461754 != nil:
    section.add "repo", valid_39461754
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461755 = header.getOrDefault("Accept")
  valid_39461755 = validateParameter(valid_39461755, JString, required = false,
                                   default = nil)
  if valid_39461755 != nil:
    section.add "Accept", valid_39461755
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39461757: Call_PostReposOwnerRepoGitBlobs_39461750;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a Blob.
  ## 
  let valid = call_39461757.validator(path, query, header, formData, body, _)
  let scheme = call_39461757.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461757.url(scheme.get, call_39461757.host, call_39461757.base,
                           call_39461757.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461757, uri, valid, _)

proc call*(call_39461758: Call_PostReposOwnerRepoGitBlobs_39461750; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitBlobs
  ## Create a Blob.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461759 = newJObject()
  var header_39461760 = newJObject()
  var body_39461761 = newJObject()
  add(path_39461759, "owner", newJString(owner))
  add(header_39461760, "Accept", newJString(Accept))
  if body != nil:
    body_39461761 = body
  add(path_39461759, "repo", newJString(repo))
  result = call_39461758.call(path_39461759, nil, header_39461760, nil, body_39461761)

var postReposOwnerRepoGitBlobs* = Call_PostReposOwnerRepoGitBlobs_39461750(
    name: "postReposOwnerRepoGitBlobs", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/blobs",
    validator: validate_PostReposOwnerRepoGitBlobs_39461751, base: "/",
    url: url_PostReposOwnerRepoGitBlobs_39461752, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitBlobsShaCode_39461762 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoGitBlobsShaCode_39461764(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/blobs/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitBlobsShaCode_39461763(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a Blob.
  ## Since blobs can be any arbitrary binary data, the input and responses for
  ## the blob API takes an encoding parameter that can be either utf-8 or
  ## base64. If your data cannot be losslessly sent as a UTF-8 string, you can
  ## base64 encode it.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  ##          : SHA-1 code.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461765 = path.getOrDefault("owner")
  valid_39461765 = validateParameter(valid_39461765, JString, required = true,
                                   default = nil)
  if valid_39461765 != nil:
    section.add "owner", valid_39461765
  var valid_39461766 = path.getOrDefault("repo")
  valid_39461766 = validateParameter(valid_39461766, JString, required = true,
                                   default = nil)
  if valid_39461766 != nil:
    section.add "repo", valid_39461766
  var valid_39461767 = path.getOrDefault("shaCode")
  valid_39461767 = validateParameter(valid_39461767, JString, required = true,
                                   default = nil)
  if valid_39461767 != nil:
    section.add "shaCode", valid_39461767
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461768 = header.getOrDefault("Accept")
  valid_39461768 = validateParameter(valid_39461768, JString, required = false,
                                   default = nil)
  if valid_39461768 != nil:
    section.add "Accept", valid_39461768
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461769: Call_GetReposOwnerRepoGitBlobsShaCode_39461762;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a Blob.
  ## Since blobs can be any arbitrary binary data, the input and responses for
  ## the blob API takes an encoding parameter that can be either utf-8 or
  ## base64. If your data cannot be losslessly sent as a UTF-8 string, you can
  ## base64 encode it.
  ## 
  ## 
  let valid = call_39461769.validator(path, query, header, formData, body, _)
  let scheme = call_39461769.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461769.url(scheme.get, call_39461769.host, call_39461769.base,
                           call_39461769.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461769, uri, valid, _)

proc call*(call_39461770: Call_GetReposOwnerRepoGitBlobsShaCode_39461762;
          owner: string; repo: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitBlobsShaCode
  ## Get a Blob.
  ## Since blobs can be any arbitrary binary data, the input and responses for
  ## the blob API takes an encoding parameter that can be either utf-8 or
  ## base64. If your data cannot be losslessly sent as a UTF-8 string, you can
  ## base64 encode it.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  ##          : SHA-1 code.
  var path_39461771 = newJObject()
  var header_39461772 = newJObject()
  add(path_39461771, "owner", newJString(owner))
  add(header_39461772, "Accept", newJString(Accept))
  add(path_39461771, "repo", newJString(repo))
  add(path_39461771, "shaCode", newJString(shaCode))
  result = call_39461770.call(path_39461771, nil, header_39461772, nil, nil)

var getReposOwnerRepoGitBlobsShaCode* = Call_GetReposOwnerRepoGitBlobsShaCode_39461762(
    name: "getReposOwnerRepoGitBlobsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/blobs/{shaCode}",
    validator: validate_GetReposOwnerRepoGitBlobsShaCode_39461763, base: "/",
    url: url_GetReposOwnerRepoGitBlobsShaCode_39461764, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitCommits_39461773 = ref object of OpenApiRestCall_39460352
proc url_PostReposOwnerRepoGitCommits_39461775(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/commits")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitCommits_39461774(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Create a Commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461776 = path.getOrDefault("owner")
  valid_39461776 = validateParameter(valid_39461776, JString, required = true,
                                   default = nil)
  if valid_39461776 != nil:
    section.add "owner", valid_39461776
  var valid_39461777 = path.getOrDefault("repo")
  valid_39461777 = validateParameter(valid_39461777, JString, required = true,
                                   default = nil)
  if valid_39461777 != nil:
    section.add "repo", valid_39461777
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461778 = header.getOrDefault("Accept")
  valid_39461778 = validateParameter(valid_39461778, JString, required = false,
                                   default = nil)
  if valid_39461778 != nil:
    section.add "Accept", valid_39461778
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39461780: Call_PostReposOwnerRepoGitCommits_39461773;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a Commit.
  ## 
  let valid = call_39461780.validator(path, query, header, formData, body, _)
  let scheme = call_39461780.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461780.url(scheme.get, call_39461780.host, call_39461780.base,
                           call_39461780.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461780, uri, valid, _)

proc call*(call_39461781: Call_PostReposOwnerRepoGitCommits_39461773;
          owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitCommits
  ## Create a Commit.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461782 = newJObject()
  var header_39461783 = newJObject()
  var body_39461784 = newJObject()
  add(path_39461782, "owner", newJString(owner))
  add(header_39461783, "Accept", newJString(Accept))
  if body != nil:
    body_39461784 = body
  add(path_39461782, "repo", newJString(repo))
  result = call_39461781.call(path_39461782, nil, header_39461783, nil, body_39461784)

var postReposOwnerRepoGitCommits* = Call_PostReposOwnerRepoGitCommits_39461773(
    name: "postReposOwnerRepoGitCommits", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/commits",
    validator: validate_PostReposOwnerRepoGitCommits_39461774, base: "/",
    url: url_PostReposOwnerRepoGitCommits_39461775, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitCommitsShaCode_39461785 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoGitCommitsShaCode_39461787(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/commits/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitCommitsShaCode_39461786(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a Commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  ##          : SHA-1 code.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461788 = path.getOrDefault("owner")
  valid_39461788 = validateParameter(valid_39461788, JString, required = true,
                                   default = nil)
  if valid_39461788 != nil:
    section.add "owner", valid_39461788
  var valid_39461789 = path.getOrDefault("repo")
  valid_39461789 = validateParameter(valid_39461789, JString, required = true,
                                   default = nil)
  if valid_39461789 != nil:
    section.add "repo", valid_39461789
  var valid_39461790 = path.getOrDefault("shaCode")
  valid_39461790 = validateParameter(valid_39461790, JString, required = true,
                                   default = nil)
  if valid_39461790 != nil:
    section.add "shaCode", valid_39461790
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461791 = header.getOrDefault("Accept")
  valid_39461791 = validateParameter(valid_39461791, JString, required = false,
                                   default = nil)
  if valid_39461791 != nil:
    section.add "Accept", valid_39461791
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461792: Call_GetReposOwnerRepoGitCommitsShaCode_39461785;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a Commit.
  ## 
  let valid = call_39461792.validator(path, query, header, formData, body, _)
  let scheme = call_39461792.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461792.url(scheme.get, call_39461792.host, call_39461792.base,
                           call_39461792.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461792, uri, valid, _)

proc call*(call_39461793: Call_GetReposOwnerRepoGitCommitsShaCode_39461785;
          owner: string; repo: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitCommitsShaCode
  ## Get a Commit.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  ##          : SHA-1 code.
  var path_39461794 = newJObject()
  var header_39461795 = newJObject()
  add(path_39461794, "owner", newJString(owner))
  add(header_39461795, "Accept", newJString(Accept))
  add(path_39461794, "repo", newJString(repo))
  add(path_39461794, "shaCode", newJString(shaCode))
  result = call_39461793.call(path_39461794, nil, header_39461795, nil, nil)

var getReposOwnerRepoGitCommitsShaCode* = Call_GetReposOwnerRepoGitCommitsShaCode_39461785(
    name: "getReposOwnerRepoGitCommitsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/commits/{shaCode}",
    validator: validate_GetReposOwnerRepoGitCommitsShaCode_39461786, base: "/",
    url: url_GetReposOwnerRepoGitCommitsShaCode_39461787, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitRefs_39461806 = ref object of OpenApiRestCall_39460352
proc url_PostReposOwnerRepoGitRefs_39461808(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitRefs_39461807(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a Reference
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461809 = path.getOrDefault("owner")
  valid_39461809 = validateParameter(valid_39461809, JString, required = true,
                                   default = nil)
  if valid_39461809 != nil:
    section.add "owner", valid_39461809
  var valid_39461810 = path.getOrDefault("repo")
  valid_39461810 = validateParameter(valid_39461810, JString, required = true,
                                   default = nil)
  if valid_39461810 != nil:
    section.add "repo", valid_39461810
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461811 = header.getOrDefault("Accept")
  valid_39461811 = validateParameter(valid_39461811, JString, required = false,
                                   default = nil)
  if valid_39461811 != nil:
    section.add "Accept", valid_39461811
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39461813: Call_PostReposOwnerRepoGitRefs_39461806;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a Reference
  ## 
  let valid = call_39461813.validator(path, query, header, formData, body, _)
  let scheme = call_39461813.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461813.url(scheme.get, call_39461813.host, call_39461813.base,
                           call_39461813.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461813, uri, valid, _)

proc call*(call_39461814: Call_PostReposOwnerRepoGitRefs_39461806; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitRefs
  ## Create a Reference
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461815 = newJObject()
  var header_39461816 = newJObject()
  var body_39461817 = newJObject()
  add(path_39461815, "owner", newJString(owner))
  add(header_39461816, "Accept", newJString(Accept))
  if body != nil:
    body_39461817 = body
  add(path_39461815, "repo", newJString(repo))
  result = call_39461814.call(path_39461815, nil, header_39461816, nil, body_39461817)

var postReposOwnerRepoGitRefs* = Call_PostReposOwnerRepoGitRefs_39461806(
    name: "postReposOwnerRepoGitRefs", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs",
    validator: validate_PostReposOwnerRepoGitRefs_39461807, base: "/",
    url: url_PostReposOwnerRepoGitRefs_39461808, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitRefs_39461796 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoGitRefs_39461798(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitRefs_39461797(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get all References
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461799 = path.getOrDefault("owner")
  valid_39461799 = validateParameter(valid_39461799, JString, required = true,
                                   default = nil)
  if valid_39461799 != nil:
    section.add "owner", valid_39461799
  var valid_39461800 = path.getOrDefault("repo")
  valid_39461800 = validateParameter(valid_39461800, JString, required = true,
                                   default = nil)
  if valid_39461800 != nil:
    section.add "repo", valid_39461800
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461801 = header.getOrDefault("Accept")
  valid_39461801 = validateParameter(valid_39461801, JString, required = false,
                                   default = nil)
  if valid_39461801 != nil:
    section.add "Accept", valid_39461801
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461802: Call_GetReposOwnerRepoGitRefs_39461796;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get all References
  ## 
  let valid = call_39461802.validator(path, query, header, formData, body, _)
  let scheme = call_39461802.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461802.url(scheme.get, call_39461802.host, call_39461802.base,
                           call_39461802.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461802, uri, valid, _)

proc call*(call_39461803: Call_GetReposOwnerRepoGitRefs_39461796; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitRefs
  ## Get all References
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461804 = newJObject()
  var header_39461805 = newJObject()
  add(path_39461804, "owner", newJString(owner))
  add(header_39461805, "Accept", newJString(Accept))
  add(path_39461804, "repo", newJString(repo))
  result = call_39461803.call(path_39461804, nil, header_39461805, nil, nil)

var getReposOwnerRepoGitRefs* = Call_GetReposOwnerRepoGitRefs_39461796(
    name: "getReposOwnerRepoGitRefs", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs",
    validator: validate_GetReposOwnerRepoGitRefs_39461797, base: "/",
    url: url_GetReposOwnerRepoGitRefs_39461798, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitRefsRef_39461818 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoGitRefsRef_39461820(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitRefsRef_39461819(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get a Reference
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   ref: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461821 = path.getOrDefault("owner")
  valid_39461821 = validateParameter(valid_39461821, JString, required = true,
                                   default = nil)
  if valid_39461821 != nil:
    section.add "owner", valid_39461821
  var valid_39461822 = path.getOrDefault("ref")
  valid_39461822 = validateParameter(valid_39461822, JString, required = true,
                                   default = nil)
  if valid_39461822 != nil:
    section.add "ref", valid_39461822
  var valid_39461823 = path.getOrDefault("repo")
  valid_39461823 = validateParameter(valid_39461823, JString, required = true,
                                   default = nil)
  if valid_39461823 != nil:
    section.add "repo", valid_39461823
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461824 = header.getOrDefault("Accept")
  valid_39461824 = validateParameter(valid_39461824, JString, required = false,
                                   default = nil)
  if valid_39461824 != nil:
    section.add "Accept", valid_39461824
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461825: Call_GetReposOwnerRepoGitRefsRef_39461818;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a Reference
  ## 
  let valid = call_39461825.validator(path, query, header, formData, body, _)
  let scheme = call_39461825.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461825.url(scheme.get, call_39461825.host, call_39461825.base,
                           call_39461825.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461825, uri, valid, _)

proc call*(call_39461826: Call_GetReposOwnerRepoGitRefsRef_39461818; owner: string;
          `ref`: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitRefsRef
  ## Get a Reference
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   ref: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461827 = newJObject()
  var header_39461828 = newJObject()
  add(path_39461827, "owner", newJString(owner))
  add(path_39461827, "ref", newJString(`ref`))
  add(header_39461828, "Accept", newJString(Accept))
  add(path_39461827, "repo", newJString(repo))
  result = call_39461826.call(path_39461827, nil, header_39461828, nil, nil)

var getReposOwnerRepoGitRefsRef* = Call_GetReposOwnerRepoGitRefsRef_39461818(
    name: "getReposOwnerRepoGitRefsRef", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs/{ref}",
    validator: validate_GetReposOwnerRepoGitRefsRef_39461819, base: "/",
    url: url_GetReposOwnerRepoGitRefsRef_39461820, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoGitRefsRef_39461840 = ref object of OpenApiRestCall_39460352
proc url_PatchReposOwnerRepoGitRefsRef_39461842(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoGitRefsRef_39461841(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Update a Reference
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   ref: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461843 = path.getOrDefault("owner")
  valid_39461843 = validateParameter(valid_39461843, JString, required = true,
                                   default = nil)
  if valid_39461843 != nil:
    section.add "owner", valid_39461843
  var valid_39461844 = path.getOrDefault("ref")
  valid_39461844 = validateParameter(valid_39461844, JString, required = true,
                                   default = nil)
  if valid_39461844 != nil:
    section.add "ref", valid_39461844
  var valid_39461845 = path.getOrDefault("repo")
  valid_39461845 = validateParameter(valid_39461845, JString, required = true,
                                   default = nil)
  if valid_39461845 != nil:
    section.add "repo", valid_39461845
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461846 = header.getOrDefault("Accept")
  valid_39461846 = validateParameter(valid_39461846, JString, required = false,
                                   default = nil)
  if valid_39461846 != nil:
    section.add "Accept", valid_39461846
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39461848: Call_PatchReposOwnerRepoGitRefsRef_39461840;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Update a Reference
  ## 
  let valid = call_39461848.validator(path, query, header, formData, body, _)
  let scheme = call_39461848.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461848.url(scheme.get, call_39461848.host, call_39461848.base,
                           call_39461848.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461848, uri, valid, _)

proc call*(call_39461849: Call_PatchReposOwnerRepoGitRefsRef_39461840;
          owner: string; `ref`: string; body: JsonNode; repo: string;
          Accept: string = ""): Recallable =
  ## patchReposOwnerRepoGitRefsRef
  ## Update a Reference
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   ref: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461850 = newJObject()
  var header_39461851 = newJObject()
  var body_39461852 = newJObject()
  add(path_39461850, "owner", newJString(owner))
  add(path_39461850, "ref", newJString(`ref`))
  add(header_39461851, "Accept", newJString(Accept))
  if body != nil:
    body_39461852 = body
  add(path_39461850, "repo", newJString(repo))
  result = call_39461849.call(path_39461850, nil, header_39461851, nil, body_39461852)

var patchReposOwnerRepoGitRefsRef* = Call_PatchReposOwnerRepoGitRefsRef_39461840(
    name: "patchReposOwnerRepoGitRefsRef", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs/{ref}",
    validator: validate_PatchReposOwnerRepoGitRefsRef_39461841, base: "/",
    url: url_PatchReposOwnerRepoGitRefsRef_39461842, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoGitRefsRef_39461829 = ref object of OpenApiRestCall_39460352
proc url_DeleteReposOwnerRepoGitRefsRef_39461831(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoGitRefsRef_39461830(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a Reference
  ## Example: Deleting a branch: DELETE /repos/octocat/Hello-World/git/refs/heads/feature-a
  ## Example: Deleting a tag:        DELETE /repos/octocat/Hello-World/git/refs/tags/v1.0
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   ref: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461832 = path.getOrDefault("owner")
  valid_39461832 = validateParameter(valid_39461832, JString, required = true,
                                   default = nil)
  if valid_39461832 != nil:
    section.add "owner", valid_39461832
  var valid_39461833 = path.getOrDefault("ref")
  valid_39461833 = validateParameter(valid_39461833, JString, required = true,
                                   default = nil)
  if valid_39461833 != nil:
    section.add "ref", valid_39461833
  var valid_39461834 = path.getOrDefault("repo")
  valid_39461834 = validateParameter(valid_39461834, JString, required = true,
                                   default = nil)
  if valid_39461834 != nil:
    section.add "repo", valid_39461834
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461835 = header.getOrDefault("Accept")
  valid_39461835 = validateParameter(valid_39461835, JString, required = false,
                                   default = nil)
  if valid_39461835 != nil:
    section.add "Accept", valid_39461835
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461836: Call_DeleteReposOwnerRepoGitRefsRef_39461829;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a Reference
  ## Example: Deleting a branch: DELETE /repos/octocat/Hello-World/git/refs/heads/feature-a
  ## Example: Deleting a tag:        DELETE /repos/octocat/Hello-World/git/refs/tags/v1.0
  ## 
  ## 
  let valid = call_39461836.validator(path, query, header, formData, body, _)
  let scheme = call_39461836.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461836.url(scheme.get, call_39461836.host, call_39461836.base,
                           call_39461836.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461836, uri, valid, _)

proc call*(call_39461837: Call_DeleteReposOwnerRepoGitRefsRef_39461829;
          owner: string; `ref`: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoGitRefsRef
  ## Delete a Reference
  ## Example: Deleting a branch: DELETE /repos/octocat/Hello-World/git/refs/heads/feature-a
  ## Example: Deleting a tag:        DELETE /repos/octocat/Hello-World/git/refs/tags/v1.0
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   ref: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461838 = newJObject()
  var header_39461839 = newJObject()
  add(path_39461838, "owner", newJString(owner))
  add(path_39461838, "ref", newJString(`ref`))
  add(header_39461839, "Accept", newJString(Accept))
  add(path_39461838, "repo", newJString(repo))
  result = call_39461837.call(path_39461838, nil, header_39461839, nil, nil)

var deleteReposOwnerRepoGitRefsRef* = Call_DeleteReposOwnerRepoGitRefsRef_39461829(
    name: "deleteReposOwnerRepoGitRefsRef", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs/{ref}",
    validator: validate_DeleteReposOwnerRepoGitRefsRef_39461830, base: "/",
    url: url_DeleteReposOwnerRepoGitRefsRef_39461831, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitTags_39461853 = ref object of OpenApiRestCall_39460352
proc url_PostReposOwnerRepoGitTags_39461855(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/tags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitTags_39461854(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a Tag Object.
  ## Note that creating a tag object does not create the reference that makes a
  ## tag in Git. If you want to create an annotated tag in Git, you have to do
  ## this call to create the tag object, and then create the refs/tags/[tag]
  ## reference. If you want to create a lightweight tag, you only have to create
  ## the tag reference - this call would be unnecessary.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461856 = path.getOrDefault("owner")
  valid_39461856 = validateParameter(valid_39461856, JString, required = true,
                                   default = nil)
  if valid_39461856 != nil:
    section.add "owner", valid_39461856
  var valid_39461857 = path.getOrDefault("repo")
  valid_39461857 = validateParameter(valid_39461857, JString, required = true,
                                   default = nil)
  if valid_39461857 != nil:
    section.add "repo", valid_39461857
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461858 = header.getOrDefault("Accept")
  valid_39461858 = validateParameter(valid_39461858, JString, required = false,
                                   default = nil)
  if valid_39461858 != nil:
    section.add "Accept", valid_39461858
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39461860: Call_PostReposOwnerRepoGitTags_39461853;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a Tag Object.
  ## Note that creating a tag object does not create the reference that makes a
  ## tag in Git. If you want to create an annotated tag in Git, you have to do
  ## this call to create the tag object, and then create the refs/tags/[tag]
  ## reference. If you want to create a lightweight tag, you only have to create
  ## the tag reference - this call would be unnecessary.
  ## 
  ## 
  let valid = call_39461860.validator(path, query, header, formData, body, _)
  let scheme = call_39461860.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461860.url(scheme.get, call_39461860.host, call_39461860.base,
                           call_39461860.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461860, uri, valid, _)

proc call*(call_39461861: Call_PostReposOwnerRepoGitTags_39461853; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitTags
  ## Create a Tag Object.
  ## Note that creating a tag object does not create the reference that makes a
  ## tag in Git. If you want to create an annotated tag in Git, you have to do
  ## this call to create the tag object, and then create the refs/tags/[tag]
  ## reference. If you want to create a lightweight tag, you only have to create
  ## the tag reference - this call would be unnecessary.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461862 = newJObject()
  var header_39461863 = newJObject()
  var body_39461864 = newJObject()
  add(path_39461862, "owner", newJString(owner))
  add(header_39461863, "Accept", newJString(Accept))
  if body != nil:
    body_39461864 = body
  add(path_39461862, "repo", newJString(repo))
  result = call_39461861.call(path_39461862, nil, header_39461863, nil, body_39461864)

var postReposOwnerRepoGitTags* = Call_PostReposOwnerRepoGitTags_39461853(
    name: "postReposOwnerRepoGitTags", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/tags",
    validator: validate_PostReposOwnerRepoGitTags_39461854, base: "/",
    url: url_PostReposOwnerRepoGitTags_39461855, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitTagsShaCode_39461865 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoGitTagsShaCode_39461867(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/tags/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitTagsShaCode_39461866(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a Tag.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461868 = path.getOrDefault("owner")
  valid_39461868 = validateParameter(valid_39461868, JString, required = true,
                                   default = nil)
  if valid_39461868 != nil:
    section.add "owner", valid_39461868
  var valid_39461869 = path.getOrDefault("repo")
  valid_39461869 = validateParameter(valid_39461869, JString, required = true,
                                   default = nil)
  if valid_39461869 != nil:
    section.add "repo", valid_39461869
  var valid_39461870 = path.getOrDefault("shaCode")
  valid_39461870 = validateParameter(valid_39461870, JString, required = true,
                                   default = nil)
  if valid_39461870 != nil:
    section.add "shaCode", valid_39461870
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461871 = header.getOrDefault("Accept")
  valid_39461871 = validateParameter(valid_39461871, JString, required = false,
                                   default = nil)
  if valid_39461871 != nil:
    section.add "Accept", valid_39461871
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461872: Call_GetReposOwnerRepoGitTagsShaCode_39461865;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a Tag.
  ## 
  let valid = call_39461872.validator(path, query, header, formData, body, _)
  let scheme = call_39461872.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461872.url(scheme.get, call_39461872.host, call_39461872.base,
                           call_39461872.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461872, uri, valid, _)

proc call*(call_39461873: Call_GetReposOwnerRepoGitTagsShaCode_39461865;
          owner: string; repo: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitTagsShaCode
  ## Get a Tag.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  var path_39461874 = newJObject()
  var header_39461875 = newJObject()
  add(path_39461874, "owner", newJString(owner))
  add(header_39461875, "Accept", newJString(Accept))
  add(path_39461874, "repo", newJString(repo))
  add(path_39461874, "shaCode", newJString(shaCode))
  result = call_39461873.call(path_39461874, nil, header_39461875, nil, nil)

var getReposOwnerRepoGitTagsShaCode* = Call_GetReposOwnerRepoGitTagsShaCode_39461865(
    name: "getReposOwnerRepoGitTagsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/tags/{shaCode}",
    validator: validate_GetReposOwnerRepoGitTagsShaCode_39461866, base: "/",
    url: url_GetReposOwnerRepoGitTagsShaCode_39461867, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitTrees_39461876 = ref object of OpenApiRestCall_39460352
proc url_PostReposOwnerRepoGitTrees_39461878(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/trees")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitTrees_39461877(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a Tree.
  ## The tree creation API will take nested entries as well. If both a tree and
  ## a nested path modifying that tree are specified, it will overwrite the
  ## contents of that tree with the new path contents and write a new tree out.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461879 = path.getOrDefault("owner")
  valid_39461879 = validateParameter(valid_39461879, JString, required = true,
                                   default = nil)
  if valid_39461879 != nil:
    section.add "owner", valid_39461879
  var valid_39461880 = path.getOrDefault("repo")
  valid_39461880 = validateParameter(valid_39461880, JString, required = true,
                                   default = nil)
  if valid_39461880 != nil:
    section.add "repo", valid_39461880
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461881 = header.getOrDefault("Accept")
  valid_39461881 = validateParameter(valid_39461881, JString, required = false,
                                   default = nil)
  if valid_39461881 != nil:
    section.add "Accept", valid_39461881
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39461883: Call_PostReposOwnerRepoGitTrees_39461876;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a Tree.
  ## The tree creation API will take nested entries as well. If both a tree and
  ## a nested path modifying that tree are specified, it will overwrite the
  ## contents of that tree with the new path contents and write a new tree out.
  ## 
  ## 
  let valid = call_39461883.validator(path, query, header, formData, body, _)
  let scheme = call_39461883.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461883.url(scheme.get, call_39461883.host, call_39461883.base,
                           call_39461883.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461883, uri, valid, _)

proc call*(call_39461884: Call_PostReposOwnerRepoGitTrees_39461876; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitTrees
  ## Create a Tree.
  ## The tree creation API will take nested entries as well. If both a tree and
  ## a nested path modifying that tree are specified, it will overwrite the
  ## contents of that tree with the new path contents and write a new tree out.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461885 = newJObject()
  var header_39461886 = newJObject()
  var body_39461887 = newJObject()
  add(path_39461885, "owner", newJString(owner))
  add(header_39461886, "Accept", newJString(Accept))
  if body != nil:
    body_39461887 = body
  add(path_39461885, "repo", newJString(repo))
  result = call_39461884.call(path_39461885, nil, header_39461886, nil, body_39461887)

var postReposOwnerRepoGitTrees* = Call_PostReposOwnerRepoGitTrees_39461876(
    name: "postReposOwnerRepoGitTrees", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/trees",
    validator: validate_PostReposOwnerRepoGitTrees_39461877, base: "/",
    url: url_PostReposOwnerRepoGitTrees_39461878, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitTreesShaCode_39461888 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoGitTreesShaCode_39461890(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/trees/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitTreesShaCode_39461889(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a Tree.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  ##          : Tree SHA.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461891 = path.getOrDefault("owner")
  valid_39461891 = validateParameter(valid_39461891, JString, required = true,
                                   default = nil)
  if valid_39461891 != nil:
    section.add "owner", valid_39461891
  var valid_39461892 = path.getOrDefault("repo")
  valid_39461892 = validateParameter(valid_39461892, JString, required = true,
                                   default = nil)
  if valid_39461892 != nil:
    section.add "repo", valid_39461892
  var valid_39461893 = path.getOrDefault("shaCode")
  valid_39461893 = validateParameter(valid_39461893, JString, required = true,
                                   default = nil)
  if valid_39461893 != nil:
    section.add "shaCode", valid_39461893
  result.add "path", section
  ## parameters in `query` object:
  ##   recursive: JInt
  ##            : Get a Tree Recursively. (0 or 1)
  section = newJObject()
  var valid_39461894 = query.getOrDefault("recursive")
  valid_39461894 = validateParameter(valid_39461894, JInt, required = false,
                                   default = nil)
  if valid_39461894 != nil:
    section.add "recursive", valid_39461894
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461895 = header.getOrDefault("Accept")
  valid_39461895 = validateParameter(valid_39461895, JString, required = false,
                                   default = nil)
  if valid_39461895 != nil:
    section.add "Accept", valid_39461895
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461896: Call_GetReposOwnerRepoGitTreesShaCode_39461888;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a Tree.
  ## 
  let valid = call_39461896.validator(path, query, header, formData, body, _)
  let scheme = call_39461896.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461896.url(scheme.get, call_39461896.host, call_39461896.base,
                           call_39461896.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461896, uri, valid, _)

proc call*(call_39461897: Call_GetReposOwnerRepoGitTreesShaCode_39461888;
          owner: string; repo: string; shaCode: string; recursive: int = 0;
          Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitTreesShaCode
  ## Get a Tree.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   recursive: int
  ##            : Get a Tree Recursively. (0 or 1)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  ##          : Tree SHA.
  var path_39461898 = newJObject()
  var query_39461899 = newJObject()
  var header_39461900 = newJObject()
  add(path_39461898, "owner", newJString(owner))
  add(query_39461899, "recursive", newJInt(recursive))
  add(header_39461900, "Accept", newJString(Accept))
  add(path_39461898, "repo", newJString(repo))
  add(path_39461898, "shaCode", newJString(shaCode))
  result = call_39461897.call(path_39461898, query_39461899, header_39461900, nil, nil)

var getReposOwnerRepoGitTreesShaCode* = Call_GetReposOwnerRepoGitTreesShaCode_39461888(
    name: "getReposOwnerRepoGitTreesShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/trees/{shaCode}",
    validator: validate_GetReposOwnerRepoGitTreesShaCode_39461889, base: "/",
    url: url_GetReposOwnerRepoGitTreesShaCode_39461890, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoHooks_39461911 = ref object of OpenApiRestCall_39460352
proc url_PostReposOwnerRepoHooks_39461913(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoHooks_39461912(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461914 = path.getOrDefault("owner")
  valid_39461914 = validateParameter(valid_39461914, JString, required = true,
                                   default = nil)
  if valid_39461914 != nil:
    section.add "owner", valid_39461914
  var valid_39461915 = path.getOrDefault("repo")
  valid_39461915 = validateParameter(valid_39461915, JString, required = true,
                                   default = nil)
  if valid_39461915 != nil:
    section.add "repo", valid_39461915
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461916 = header.getOrDefault("Accept")
  valid_39461916 = validateParameter(valid_39461916, JString, required = false,
                                   default = nil)
  if valid_39461916 != nil:
    section.add "Accept", valid_39461916
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39461918: Call_PostReposOwnerRepoHooks_39461911;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a hook.
  ## 
  let valid = call_39461918.validator(path, query, header, formData, body, _)
  let scheme = call_39461918.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461918.url(scheme.get, call_39461918.host, call_39461918.base,
                           call_39461918.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461918, uri, valid, _)

proc call*(call_39461919: Call_PostReposOwnerRepoHooks_39461911; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoHooks
  ## Create a hook.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461920 = newJObject()
  var header_39461921 = newJObject()
  var body_39461922 = newJObject()
  add(path_39461920, "owner", newJString(owner))
  add(header_39461921, "Accept", newJString(Accept))
  if body != nil:
    body_39461922 = body
  add(path_39461920, "repo", newJString(repo))
  result = call_39461919.call(path_39461920, nil, header_39461921, nil, body_39461922)

var postReposOwnerRepoHooks* = Call_PostReposOwnerRepoHooks_39461911(
    name: "postReposOwnerRepoHooks", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks",
    validator: validate_PostReposOwnerRepoHooks_39461912, base: "/",
    url: url_PostReposOwnerRepoHooks_39461913, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoHooks_39461901 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoHooks_39461903(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoHooks_39461902(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get list of hooks.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461904 = path.getOrDefault("owner")
  valid_39461904 = validateParameter(valid_39461904, JString, required = true,
                                   default = nil)
  if valid_39461904 != nil:
    section.add "owner", valid_39461904
  var valid_39461905 = path.getOrDefault("repo")
  valid_39461905 = validateParameter(valid_39461905, JString, required = true,
                                   default = nil)
  if valid_39461905 != nil:
    section.add "repo", valid_39461905
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461906 = header.getOrDefault("Accept")
  valid_39461906 = validateParameter(valid_39461906, JString, required = false,
                                   default = nil)
  if valid_39461906 != nil:
    section.add "Accept", valid_39461906
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461907: Call_GetReposOwnerRepoHooks_39461901;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get list of hooks.
  ## 
  let valid = call_39461907.validator(path, query, header, formData, body, _)
  let scheme = call_39461907.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461907.url(scheme.get, call_39461907.host, call_39461907.base,
                           call_39461907.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461907, uri, valid, _)

proc call*(call_39461908: Call_GetReposOwnerRepoHooks_39461901; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoHooks
  ## Get list of hooks.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461909 = newJObject()
  var header_39461910 = newJObject()
  add(path_39461909, "owner", newJString(owner))
  add(header_39461910, "Accept", newJString(Accept))
  add(path_39461909, "repo", newJString(repo))
  result = call_39461908.call(path_39461909, nil, header_39461910, nil, nil)

var getReposOwnerRepoHooks* = Call_GetReposOwnerRepoHooks_39461901(
    name: "getReposOwnerRepoHooks", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks",
    validator: validate_GetReposOwnerRepoHooks_39461902, base: "/",
    url: url_GetReposOwnerRepoHooks_39461903, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoHooksHookId_39461923 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoHooksHookId_39461925(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hookId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoHooksHookId_39461924(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get single hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   hookId: JInt (required)
  ##         : Id of hook.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461926 = path.getOrDefault("owner")
  valid_39461926 = validateParameter(valid_39461926, JString, required = true,
                                   default = nil)
  if valid_39461926 != nil:
    section.add "owner", valid_39461926
  var valid_39461927 = path.getOrDefault("repo")
  valid_39461927 = validateParameter(valid_39461927, JString, required = true,
                                   default = nil)
  if valid_39461927 != nil:
    section.add "repo", valid_39461927
  var valid_39461928 = path.getOrDefault("hookId")
  valid_39461928 = validateParameter(valid_39461928, JInt, required = true,
                                   default = nil)
  if valid_39461928 != nil:
    section.add "hookId", valid_39461928
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461929 = header.getOrDefault("Accept")
  valid_39461929 = validateParameter(valid_39461929, JString, required = false,
                                   default = nil)
  if valid_39461929 != nil:
    section.add "Accept", valid_39461929
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461930: Call_GetReposOwnerRepoHooksHookId_39461923;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get single hook.
  ## 
  let valid = call_39461930.validator(path, query, header, formData, body, _)
  let scheme = call_39461930.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461930.url(scheme.get, call_39461930.host, call_39461930.base,
                           call_39461930.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461930, uri, valid, _)

proc call*(call_39461931: Call_GetReposOwnerRepoHooksHookId_39461923;
          owner: string; repo: string; hookId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoHooksHookId
  ## Get single hook.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   hookId: int (required)
  ##         : Id of hook.
  var path_39461932 = newJObject()
  var header_39461933 = newJObject()
  add(path_39461932, "owner", newJString(owner))
  add(header_39461933, "Accept", newJString(Accept))
  add(path_39461932, "repo", newJString(repo))
  add(path_39461932, "hookId", newJInt(hookId))
  result = call_39461931.call(path_39461932, nil, header_39461933, nil, nil)

var getReposOwnerRepoHooksHookId* = Call_GetReposOwnerRepoHooksHookId_39461923(
    name: "getReposOwnerRepoHooksHookId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}",
    validator: validate_GetReposOwnerRepoHooksHookId_39461924, base: "/",
    url: url_GetReposOwnerRepoHooksHookId_39461925, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoHooksHookId_39461945 = ref object of OpenApiRestCall_39460352
proc url_PatchReposOwnerRepoHooksHookId_39461947(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hookId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoHooksHookId_39461946(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Edit a hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   hookId: JInt (required)
  ##         : Id of hook.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461948 = path.getOrDefault("owner")
  valid_39461948 = validateParameter(valid_39461948, JString, required = true,
                                   default = nil)
  if valid_39461948 != nil:
    section.add "owner", valid_39461948
  var valid_39461949 = path.getOrDefault("repo")
  valid_39461949 = validateParameter(valid_39461949, JString, required = true,
                                   default = nil)
  if valid_39461949 != nil:
    section.add "repo", valid_39461949
  var valid_39461950 = path.getOrDefault("hookId")
  valid_39461950 = validateParameter(valid_39461950, JInt, required = true,
                                   default = nil)
  if valid_39461950 != nil:
    section.add "hookId", valid_39461950
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461951 = header.getOrDefault("Accept")
  valid_39461951 = validateParameter(valid_39461951, JString, required = false,
                                   default = nil)
  if valid_39461951 != nil:
    section.add "Accept", valid_39461951
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39461953: Call_PatchReposOwnerRepoHooksHookId_39461945;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit a hook.
  ## 
  let valid = call_39461953.validator(path, query, header, formData, body, _)
  let scheme = call_39461953.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461953.url(scheme.get, call_39461953.host, call_39461953.base,
                           call_39461953.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461953, uri, valid, _)

proc call*(call_39461954: Call_PatchReposOwnerRepoHooksHookId_39461945;
          owner: string; body: JsonNode; repo: string; hookId: int; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoHooksHookId
  ## Edit a hook.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   hookId: int (required)
  ##         : Id of hook.
  var path_39461955 = newJObject()
  var header_39461956 = newJObject()
  var body_39461957 = newJObject()
  add(path_39461955, "owner", newJString(owner))
  add(header_39461956, "Accept", newJString(Accept))
  if body != nil:
    body_39461957 = body
  add(path_39461955, "repo", newJString(repo))
  add(path_39461955, "hookId", newJInt(hookId))
  result = call_39461954.call(path_39461955, nil, header_39461956, nil, body_39461957)

var patchReposOwnerRepoHooksHookId* = Call_PatchReposOwnerRepoHooksHookId_39461945(
    name: "patchReposOwnerRepoHooksHookId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}",
    validator: validate_PatchReposOwnerRepoHooksHookId_39461946, base: "/",
    url: url_PatchReposOwnerRepoHooksHookId_39461947, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoHooksHookId_39461934 = ref object of OpenApiRestCall_39460352
proc url_DeleteReposOwnerRepoHooksHookId_39461936(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hookId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoHooksHookId_39461935(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   hookId: JInt (required)
  ##         : Id of hook.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461937 = path.getOrDefault("owner")
  valid_39461937 = validateParameter(valid_39461937, JString, required = true,
                                   default = nil)
  if valid_39461937 != nil:
    section.add "owner", valid_39461937
  var valid_39461938 = path.getOrDefault("repo")
  valid_39461938 = validateParameter(valid_39461938, JString, required = true,
                                   default = nil)
  if valid_39461938 != nil:
    section.add "repo", valid_39461938
  var valid_39461939 = path.getOrDefault("hookId")
  valid_39461939 = validateParameter(valid_39461939, JInt, required = true,
                                   default = nil)
  if valid_39461939 != nil:
    section.add "hookId", valid_39461939
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461940 = header.getOrDefault("Accept")
  valid_39461940 = validateParameter(valid_39461940, JString, required = false,
                                   default = nil)
  if valid_39461940 != nil:
    section.add "Accept", valid_39461940
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461941: Call_DeleteReposOwnerRepoHooksHookId_39461934;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a hook.
  ## 
  let valid = call_39461941.validator(path, query, header, formData, body, _)
  let scheme = call_39461941.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461941.url(scheme.get, call_39461941.host, call_39461941.base,
                           call_39461941.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461941, uri, valid, _)

proc call*(call_39461942: Call_DeleteReposOwnerRepoHooksHookId_39461934;
          owner: string; repo: string; hookId: int; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoHooksHookId
  ## Delete a hook.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   hookId: int (required)
  ##         : Id of hook.
  var path_39461943 = newJObject()
  var header_39461944 = newJObject()
  add(path_39461943, "owner", newJString(owner))
  add(header_39461944, "Accept", newJString(Accept))
  add(path_39461943, "repo", newJString(repo))
  add(path_39461943, "hookId", newJInt(hookId))
  result = call_39461942.call(path_39461943, nil, header_39461944, nil, nil)

var deleteReposOwnerRepoHooksHookId* = Call_DeleteReposOwnerRepoHooksHookId_39461934(
    name: "deleteReposOwnerRepoHooksHookId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}",
    validator: validate_DeleteReposOwnerRepoHooksHookId_39461935, base: "/",
    url: url_DeleteReposOwnerRepoHooksHookId_39461936, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoHooksHookIdTests_39461958 = ref object of OpenApiRestCall_39460352
proc url_PostReposOwnerRepoHooksHookIdTests_39461960(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hookId"),
               (kind: ConstantSegment, value: "/tests")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoHooksHookIdTests_39461959(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Test a push hook.
  ## This will trigger the hook with the latest push to the current repository
  ## if the hook is subscribed to push events. If the hook is not subscribed
  ## to push events, the server will respond with 204 but no test POST will
  ## be generated.
  ## Note: Previously /repos/:owner/:repo/hooks/:id/tes
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   hookId: JInt (required)
  ##         : Id of hook.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461961 = path.getOrDefault("owner")
  valid_39461961 = validateParameter(valid_39461961, JString, required = true,
                                   default = nil)
  if valid_39461961 != nil:
    section.add "owner", valid_39461961
  var valid_39461962 = path.getOrDefault("repo")
  valid_39461962 = validateParameter(valid_39461962, JString, required = true,
                                   default = nil)
  if valid_39461962 != nil:
    section.add "repo", valid_39461962
  var valid_39461963 = path.getOrDefault("hookId")
  valid_39461963 = validateParameter(valid_39461963, JInt, required = true,
                                   default = nil)
  if valid_39461963 != nil:
    section.add "hookId", valid_39461963
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461964 = header.getOrDefault("Accept")
  valid_39461964 = validateParameter(valid_39461964, JString, required = false,
                                   default = nil)
  if valid_39461964 != nil:
    section.add "Accept", valid_39461964
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461965: Call_PostReposOwnerRepoHooksHookIdTests_39461958;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Test a push hook.
  ## This will trigger the hook with the latest push to the current repository
  ## if the hook is subscribed to push events. If the hook is not subscribed
  ## to push events, the server will respond with 204 but no test POST will
  ## be generated.
  ## Note: Previously /repos/:owner/:repo/hooks/:id/tes
  ## 
  ## 
  let valid = call_39461965.validator(path, query, header, formData, body, _)
  let scheme = call_39461965.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461965.url(scheme.get, call_39461965.host, call_39461965.base,
                           call_39461965.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461965, uri, valid, _)

proc call*(call_39461966: Call_PostReposOwnerRepoHooksHookIdTests_39461958;
          owner: string; repo: string; hookId: int; Accept: string = ""): Recallable =
  ## postReposOwnerRepoHooksHookIdTests
  ## Test a push hook.
  ## This will trigger the hook with the latest push to the current repository
  ## if the hook is subscribed to push events. If the hook is not subscribed
  ## to push events, the server will respond with 204 but no test POST will
  ## be generated.
  ## Note: Previously /repos/:owner/:repo/hooks/:id/tes
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   hookId: int (required)
  ##         : Id of hook.
  var path_39461967 = newJObject()
  var header_39461968 = newJObject()
  add(path_39461967, "owner", newJString(owner))
  add(header_39461968, "Accept", newJString(Accept))
  add(path_39461967, "repo", newJString(repo))
  add(path_39461967, "hookId", newJInt(hookId))
  result = call_39461966.call(path_39461967, nil, header_39461968, nil, nil)

var postReposOwnerRepoHooksHookIdTests* = Call_PostReposOwnerRepoHooksHookIdTests_39461958(
    name: "postReposOwnerRepoHooksHookIdTests", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}/tests",
    validator: validate_PostReposOwnerRepoHooksHookIdTests_39461959, base: "/",
    url: url_PostReposOwnerRepoHooksHookIdTests_39461960, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoIssues_39461986 = ref object of OpenApiRestCall_39460352
proc url_PostReposOwnerRepoIssues_39461988(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoIssues_39461987(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create an issue.
  ## Any user with pull access to a repository can create an issue.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461989 = path.getOrDefault("owner")
  valid_39461989 = validateParameter(valid_39461989, JString, required = true,
                                   default = nil)
  if valid_39461989 != nil:
    section.add "owner", valid_39461989
  var valid_39461990 = path.getOrDefault("repo")
  valid_39461990 = validateParameter(valid_39461990, JString, required = true,
                                   default = nil)
  if valid_39461990 != nil:
    section.add "repo", valid_39461990
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461991 = header.getOrDefault("Accept")
  valid_39461991 = validateParameter(valid_39461991, JString, required = false,
                                   default = nil)
  if valid_39461991 != nil:
    section.add "Accept", valid_39461991
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39461993: Call_PostReposOwnerRepoIssues_39461986;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create an issue.
  ## Any user with pull access to a repository can create an issue.
  ## 
  ## 
  let valid = call_39461993.validator(path, query, header, formData, body, _)
  let scheme = call_39461993.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461993.url(scheme.get, call_39461993.host, call_39461993.base,
                           call_39461993.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461993, uri, valid, _)

proc call*(call_39461994: Call_PostReposOwnerRepoIssues_39461986; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoIssues
  ## Create an issue.
  ## Any user with pull access to a repository can create an issue.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39461995 = newJObject()
  var header_39461996 = newJObject()
  var body_39461997 = newJObject()
  add(path_39461995, "owner", newJString(owner))
  add(header_39461996, "Accept", newJString(Accept))
  if body != nil:
    body_39461997 = body
  add(path_39461995, "repo", newJString(repo))
  result = call_39461994.call(path_39461995, nil, header_39461996, nil, body_39461997)

var postReposOwnerRepoIssues* = Call_PostReposOwnerRepoIssues_39461986(
    name: "postReposOwnerRepoIssues", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues",
    validator: validate_PostReposOwnerRepoIssues_39461987, base: "/",
    url: url_PostReposOwnerRepoIssues_39461988, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssues_39461969 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoIssues_39461971(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssues_39461970(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List issues for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39461972 = path.getOrDefault("owner")
  valid_39461972 = validateParameter(valid_39461972, JString, required = true,
                                   default = nil)
  if valid_39461972 != nil:
    section.add "owner", valid_39461972
  var valid_39461973 = path.getOrDefault("repo")
  valid_39461973 = validateParameter(valid_39461973, JString, required = true,
                                   default = nil)
  if valid_39461973 != nil:
    section.add "repo", valid_39461973
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString (required)
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: JString (required)
  ##   direction: JString (required)
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_39461974 = query.getOrDefault("state")
  valid_39461974 = validateParameter(valid_39461974, JString, required = true,
                                   default = newJString("open"))
  if valid_39461974 != nil:
    section.add "state", valid_39461974
  var valid_39461975 = query.getOrDefault("labels")
  valid_39461975 = validateParameter(valid_39461975, JString, required = true,
                                   default = nil)
  if valid_39461975 != nil:
    section.add "labels", valid_39461975
  var valid_39461976 = query.getOrDefault("sort")
  valid_39461976 = validateParameter(valid_39461976, JString, required = true,
                                   default = newJString("created"))
  if valid_39461976 != nil:
    section.add "sort", valid_39461976
  var valid_39461977 = query.getOrDefault("direction")
  valid_39461977 = validateParameter(valid_39461977, JString, required = true,
                                   default = newJString("desc"))
  if valid_39461977 != nil:
    section.add "direction", valid_39461977
  var valid_39461978 = query.getOrDefault("filter")
  valid_39461978 = validateParameter(valid_39461978, JString, required = true,
                                   default = newJString("all"))
  if valid_39461978 != nil:
    section.add "filter", valid_39461978
  var valid_39461979 = query.getOrDefault("since")
  valid_39461979 = validateParameter(valid_39461979, JString, required = false,
                                   default = nil)
  if valid_39461979 != nil:
    section.add "since", valid_39461979
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39461980 = header.getOrDefault("Accept")
  valid_39461980 = validateParameter(valid_39461980, JString, required = false,
                                   default = nil)
  if valid_39461980 != nil:
    section.add "Accept", valid_39461980
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39461981: Call_GetReposOwnerRepoIssues_39461969;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List issues for a repository.
  ## 
  let valid = call_39461981.validator(path, query, header, formData, body, _)
  let scheme = call_39461981.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39461981.url(scheme.get, call_39461981.host, call_39461981.base,
                           call_39461981.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39461981, uri, valid, _)

proc call*(call_39461982: Call_GetReposOwnerRepoIssues_39461969; owner: string;
          repo: string; labels: string; state: string = "open"; Accept: string = "";
          sort: string = "created"; direction: string = "desc"; filter: string = "all";
          since: string = ""): Recallable =
  ## getReposOwnerRepoIssues
  ## List issues for a repository.
  ##   state: string (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: string (required)
  ##   direction: string (required)
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  var path_39461983 = newJObject()
  var query_39461984 = newJObject()
  var header_39461985 = newJObject()
  add(query_39461984, "state", newJString(state))
  add(path_39461983, "owner", newJString(owner))
  add(header_39461985, "Accept", newJString(Accept))
  add(path_39461983, "repo", newJString(repo))
  add(query_39461984, "labels", newJString(labels))
  add(query_39461984, "sort", newJString(sort))
  add(query_39461984, "direction", newJString(direction))
  add(query_39461984, "filter", newJString(filter))
  add(query_39461984, "since", newJString(since))
  result = call_39461982.call(path_39461983, query_39461984, header_39461985, nil, nil)

var getReposOwnerRepoIssues* = Call_GetReposOwnerRepoIssues_39461969(
    name: "getReposOwnerRepoIssues", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues",
    validator: validate_GetReposOwnerRepoIssues_39461970, base: "/",
    url: url_GetReposOwnerRepoIssues_39461971, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesComments_39461998 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoIssuesComments_39462000(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesComments_39461999(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List comments in a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462001 = path.getOrDefault("owner")
  valid_39462001 = validateParameter(valid_39462001, JString, required = true,
                                   default = nil)
  if valid_39462001 != nil:
    section.add "owner", valid_39462001
  var valid_39462002 = path.getOrDefault("repo")
  valid_39462002 = validateParameter(valid_39462002, JString, required = true,
                                   default = nil)
  if valid_39462002 != nil:
    section.add "repo", valid_39462002
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_39462003 = query.getOrDefault("sort")
  valid_39462003 = validateParameter(valid_39462003, JString, required = false,
                                   default = newJString("created"))
  if valid_39462003 != nil:
    section.add "sort", valid_39462003
  var valid_39462004 = query.getOrDefault("direction")
  valid_39462004 = validateParameter(valid_39462004, JString, required = false,
                                   default = nil)
  if valid_39462004 != nil:
    section.add "direction", valid_39462004
  var valid_39462005 = query.getOrDefault("since")
  valid_39462005 = validateParameter(valid_39462005, JString, required = false,
                                   default = nil)
  if valid_39462005 != nil:
    section.add "since", valid_39462005
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462006 = header.getOrDefault("Accept")
  valid_39462006 = validateParameter(valid_39462006, JString, required = false,
                                   default = nil)
  if valid_39462006 != nil:
    section.add "Accept", valid_39462006
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462007: Call_GetReposOwnerRepoIssuesComments_39461998;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List comments in a repository.
  ## 
  let valid = call_39462007.validator(path, query, header, formData, body, _)
  let scheme = call_39462007.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462007.url(scheme.get, call_39462007.host, call_39462007.base,
                           call_39462007.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462007, uri, valid, _)

proc call*(call_39462008: Call_GetReposOwnerRepoIssuesComments_39461998;
          owner: string; repo: string; Accept: string = ""; sort: string = "created";
          direction: string = ""; since: string = ""): Recallable =
  ## getReposOwnerRepoIssuesComments
  ## List comments in a repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   sort: string
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var path_39462009 = newJObject()
  var query_39462010 = newJObject()
  var header_39462011 = newJObject()
  add(path_39462009, "owner", newJString(owner))
  add(header_39462011, "Accept", newJString(Accept))
  add(path_39462009, "repo", newJString(repo))
  add(query_39462010, "sort", newJString(sort))
  add(query_39462010, "direction", newJString(direction))
  add(query_39462010, "since", newJString(since))
  result = call_39462008.call(path_39462009, query_39462010, header_39462011, nil, nil)

var getReposOwnerRepoIssuesComments* = Call_GetReposOwnerRepoIssuesComments_39461998(
    name: "getReposOwnerRepoIssuesComments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/comments",
    validator: validate_GetReposOwnerRepoIssuesComments_39461999, base: "/",
    url: url_GetReposOwnerRepoIssuesComments_39462000, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesCommentsCommentId_39462012 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoIssuesCommentsCommentId_39462014(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesCommentsCommentId_39462013(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a single comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : ID of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462015 = path.getOrDefault("owner")
  valid_39462015 = validateParameter(valid_39462015, JString, required = true,
                                   default = nil)
  if valid_39462015 != nil:
    section.add "owner", valid_39462015
  var valid_39462016 = path.getOrDefault("repo")
  valid_39462016 = validateParameter(valid_39462016, JString, required = true,
                                   default = nil)
  if valid_39462016 != nil:
    section.add "repo", valid_39462016
  var valid_39462017 = path.getOrDefault("commentId")
  valid_39462017 = validateParameter(valid_39462017, JInt, required = true,
                                   default = nil)
  if valid_39462017 != nil:
    section.add "commentId", valid_39462017
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462018 = header.getOrDefault("Accept")
  valid_39462018 = validateParameter(valid_39462018, JString, required = false,
                                   default = nil)
  if valid_39462018 != nil:
    section.add "Accept", valid_39462018
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462019: Call_GetReposOwnerRepoIssuesCommentsCommentId_39462012;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single comment.
  ## 
  let valid = call_39462019.validator(path, query, header, formData, body, _)
  let scheme = call_39462019.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462019.url(scheme.get, call_39462019.host, call_39462019.base,
                           call_39462019.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462019, uri, valid, _)

proc call*(call_39462020: Call_GetReposOwnerRepoIssuesCommentsCommentId_39462012;
          owner: string; repo: string; commentId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesCommentsCommentId
  ## Get a single comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : ID of comment.
  var path_39462021 = newJObject()
  var header_39462022 = newJObject()
  add(path_39462021, "owner", newJString(owner))
  add(header_39462022, "Accept", newJString(Accept))
  add(path_39462021, "repo", newJString(repo))
  add(path_39462021, "commentId", newJInt(commentId))
  result = call_39462020.call(path_39462021, nil, header_39462022, nil, nil)

var getReposOwnerRepoIssuesCommentsCommentId* = Call_GetReposOwnerRepoIssuesCommentsCommentId_39462012(
    name: "getReposOwnerRepoIssuesCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/comments/{commentId}",
    validator: validate_GetReposOwnerRepoIssuesCommentsCommentId_39462013,
    base: "/", url: url_GetReposOwnerRepoIssuesCommentsCommentId_39462014,
    schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoIssuesCommentsCommentId_39462034 = ref object of OpenApiRestCall_39460352
proc url_PatchReposOwnerRepoIssuesCommentsCommentId_39462036(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoIssuesCommentsCommentId_39462035(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Edit a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : ID of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462037 = path.getOrDefault("owner")
  valid_39462037 = validateParameter(valid_39462037, JString, required = true,
                                   default = nil)
  if valid_39462037 != nil:
    section.add "owner", valid_39462037
  var valid_39462038 = path.getOrDefault("repo")
  valid_39462038 = validateParameter(valid_39462038, JString, required = true,
                                   default = nil)
  if valid_39462038 != nil:
    section.add "repo", valid_39462038
  var valid_39462039 = path.getOrDefault("commentId")
  valid_39462039 = validateParameter(valid_39462039, JInt, required = true,
                                   default = nil)
  if valid_39462039 != nil:
    section.add "commentId", valid_39462039
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462040 = header.getOrDefault("Accept")
  valid_39462040 = validateParameter(valid_39462040, JString, required = false,
                                   default = nil)
  if valid_39462040 != nil:
    section.add "Accept", valid_39462040
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39462042: Call_PatchReposOwnerRepoIssuesCommentsCommentId_39462034;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit a comment.
  ## 
  let valid = call_39462042.validator(path, query, header, formData, body, _)
  let scheme = call_39462042.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462042.url(scheme.get, call_39462042.host, call_39462042.base,
                           call_39462042.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462042, uri, valid, _)

proc call*(call_39462043: Call_PatchReposOwnerRepoIssuesCommentsCommentId_39462034;
          owner: string; body: JsonNode; repo: string; commentId: int;
          Accept: string = ""): Recallable =
  ## patchReposOwnerRepoIssuesCommentsCommentId
  ## Edit a comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : ID of comment.
  var path_39462044 = newJObject()
  var header_39462045 = newJObject()
  var body_39462046 = newJObject()
  add(path_39462044, "owner", newJString(owner))
  add(header_39462045, "Accept", newJString(Accept))
  if body != nil:
    body_39462046 = body
  add(path_39462044, "repo", newJString(repo))
  add(path_39462044, "commentId", newJInt(commentId))
  result = call_39462043.call(path_39462044, nil, header_39462045, nil, body_39462046)

var patchReposOwnerRepoIssuesCommentsCommentId* = Call_PatchReposOwnerRepoIssuesCommentsCommentId_39462034(
    name: "patchReposOwnerRepoIssuesCommentsCommentId",
    meth: HttpMethod.HttpPatch, host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/comments/{commentId}",
    validator: validate_PatchReposOwnerRepoIssuesCommentsCommentId_39462035,
    base: "/", url: url_PatchReposOwnerRepoIssuesCommentsCommentId_39462036,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoIssuesCommentsCommentId_39462023 = ref object of OpenApiRestCall_39460352
proc url_DeleteReposOwnerRepoIssuesCommentsCommentId_39462025(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoIssuesCommentsCommentId_39462024(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## Delete a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : ID of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462026 = path.getOrDefault("owner")
  valid_39462026 = validateParameter(valid_39462026, JString, required = true,
                                   default = nil)
  if valid_39462026 != nil:
    section.add "owner", valid_39462026
  var valid_39462027 = path.getOrDefault("repo")
  valid_39462027 = validateParameter(valid_39462027, JString, required = true,
                                   default = nil)
  if valid_39462027 != nil:
    section.add "repo", valid_39462027
  var valid_39462028 = path.getOrDefault("commentId")
  valid_39462028 = validateParameter(valid_39462028, JInt, required = true,
                                   default = nil)
  if valid_39462028 != nil:
    section.add "commentId", valid_39462028
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462029 = header.getOrDefault("Accept")
  valid_39462029 = validateParameter(valid_39462029, JString, required = false,
                                   default = nil)
  if valid_39462029 != nil:
    section.add "Accept", valid_39462029
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462030: Call_DeleteReposOwnerRepoIssuesCommentsCommentId_39462023;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a comment.
  ## 
  let valid = call_39462030.validator(path, query, header, formData, body, _)
  let scheme = call_39462030.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462030.url(scheme.get, call_39462030.host, call_39462030.base,
                           call_39462030.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462030, uri, valid, _)

proc call*(call_39462031: Call_DeleteReposOwnerRepoIssuesCommentsCommentId_39462023;
          owner: string; repo: string; commentId: int; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoIssuesCommentsCommentId
  ## Delete a comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : ID of comment.
  var path_39462032 = newJObject()
  var header_39462033 = newJObject()
  add(path_39462032, "owner", newJString(owner))
  add(header_39462033, "Accept", newJString(Accept))
  add(path_39462032, "repo", newJString(repo))
  add(path_39462032, "commentId", newJInt(commentId))
  result = call_39462031.call(path_39462032, nil, header_39462033, nil, nil)

var deleteReposOwnerRepoIssuesCommentsCommentId* = Call_DeleteReposOwnerRepoIssuesCommentsCommentId_39462023(
    name: "deleteReposOwnerRepoIssuesCommentsCommentId",
    meth: HttpMethod.HttpDelete, host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/comments/{commentId}",
    validator: validate_DeleteReposOwnerRepoIssuesCommentsCommentId_39462024,
    base: "/", url: url_DeleteReposOwnerRepoIssuesCommentsCommentId_39462025,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesEvents_39462047 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoIssuesEvents_39462049(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesEvents_39462048(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List issue events for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462050 = path.getOrDefault("owner")
  valid_39462050 = validateParameter(valid_39462050, JString, required = true,
                                   default = nil)
  if valid_39462050 != nil:
    section.add "owner", valid_39462050
  var valid_39462051 = path.getOrDefault("repo")
  valid_39462051 = validateParameter(valid_39462051, JString, required = true,
                                   default = nil)
  if valid_39462051 != nil:
    section.add "repo", valid_39462051
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462052 = header.getOrDefault("Accept")
  valid_39462052 = validateParameter(valid_39462052, JString, required = false,
                                   default = nil)
  if valid_39462052 != nil:
    section.add "Accept", valid_39462052
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462053: Call_GetReposOwnerRepoIssuesEvents_39462047;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List issue events for a repository.
  ## 
  let valid = call_39462053.validator(path, query, header, formData, body, _)
  let scheme = call_39462053.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462053.url(scheme.get, call_39462053.host, call_39462053.base,
                           call_39462053.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462053, uri, valid, _)

proc call*(call_39462054: Call_GetReposOwnerRepoIssuesEvents_39462047;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesEvents
  ## List issue events for a repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462055 = newJObject()
  var header_39462056 = newJObject()
  add(path_39462055, "owner", newJString(owner))
  add(header_39462056, "Accept", newJString(Accept))
  add(path_39462055, "repo", newJString(repo))
  result = call_39462054.call(path_39462055, nil, header_39462056, nil, nil)

var getReposOwnerRepoIssuesEvents* = Call_GetReposOwnerRepoIssuesEvents_39462047(
    name: "getReposOwnerRepoIssuesEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/events",
    validator: validate_GetReposOwnerRepoIssuesEvents_39462048, base: "/",
    url: url_GetReposOwnerRepoIssuesEvents_39462049, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesEventsEventId_39462057 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoIssuesEventsEventId_39462059(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "eventId" in path, "`eventId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/events/"),
               (kind: VariableSegment, value: "eventId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesEventsEventId_39462058(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a single event.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   eventId: JInt (required)
  ##          : Id of the event.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462060 = path.getOrDefault("owner")
  valid_39462060 = validateParameter(valid_39462060, JString, required = true,
                                   default = nil)
  if valid_39462060 != nil:
    section.add "owner", valid_39462060
  var valid_39462061 = path.getOrDefault("repo")
  valid_39462061 = validateParameter(valid_39462061, JString, required = true,
                                   default = nil)
  if valid_39462061 != nil:
    section.add "repo", valid_39462061
  var valid_39462062 = path.getOrDefault("eventId")
  valid_39462062 = validateParameter(valid_39462062, JInt, required = true,
                                   default = nil)
  if valid_39462062 != nil:
    section.add "eventId", valid_39462062
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462063 = header.getOrDefault("Accept")
  valid_39462063 = validateParameter(valid_39462063, JString, required = false,
                                   default = nil)
  if valid_39462063 != nil:
    section.add "Accept", valid_39462063
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462064: Call_GetReposOwnerRepoIssuesEventsEventId_39462057;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single event.
  ## 
  let valid = call_39462064.validator(path, query, header, formData, body, _)
  let scheme = call_39462064.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462064.url(scheme.get, call_39462064.host, call_39462064.base,
                           call_39462064.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462064, uri, valid, _)

proc call*(call_39462065: Call_GetReposOwnerRepoIssuesEventsEventId_39462057;
          owner: string; repo: string; eventId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesEventsEventId
  ## Get a single event.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   eventId: int (required)
  ##          : Id of the event.
  var path_39462066 = newJObject()
  var header_39462067 = newJObject()
  add(path_39462066, "owner", newJString(owner))
  add(header_39462067, "Accept", newJString(Accept))
  add(path_39462066, "repo", newJString(repo))
  add(path_39462066, "eventId", newJInt(eventId))
  result = call_39462065.call(path_39462066, nil, header_39462067, nil, nil)

var getReposOwnerRepoIssuesEventsEventId* = Call_GetReposOwnerRepoIssuesEventsEventId_39462057(
    name: "getReposOwnerRepoIssuesEventsEventId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/events/{eventId}",
    validator: validate_GetReposOwnerRepoIssuesEventsEventId_39462058, base: "/",
    url: url_GetReposOwnerRepoIssuesEventsEventId_39462059,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumber_39462068 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoIssuesNumber_39462070(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumber_39462069(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a single issue
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462071 = path.getOrDefault("owner")
  valid_39462071 = validateParameter(valid_39462071, JString, required = true,
                                   default = nil)
  if valid_39462071 != nil:
    section.add "owner", valid_39462071
  var valid_39462072 = path.getOrDefault("number")
  valid_39462072 = validateParameter(valid_39462072, JInt, required = true,
                                   default = nil)
  if valid_39462072 != nil:
    section.add "number", valid_39462072
  var valid_39462073 = path.getOrDefault("repo")
  valid_39462073 = validateParameter(valid_39462073, JString, required = true,
                                   default = nil)
  if valid_39462073 != nil:
    section.add "repo", valid_39462073
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462074 = header.getOrDefault("Accept")
  valid_39462074 = validateParameter(valid_39462074, JString, required = false,
                                   default = nil)
  if valid_39462074 != nil:
    section.add "Accept", valid_39462074
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462075: Call_GetReposOwnerRepoIssuesNumber_39462068;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single issue
  ## 
  let valid = call_39462075.validator(path, query, header, formData, body, _)
  let scheme = call_39462075.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462075.url(scheme.get, call_39462075.host, call_39462075.base,
                           call_39462075.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462075, uri, valid, _)

proc call*(call_39462076: Call_GetReposOwnerRepoIssuesNumber_39462068;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumber
  ## Get a single issue
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462077 = newJObject()
  var header_39462078 = newJObject()
  add(path_39462077, "owner", newJString(owner))
  add(path_39462077, "number", newJInt(number))
  add(header_39462078, "Accept", newJString(Accept))
  add(path_39462077, "repo", newJString(repo))
  result = call_39462076.call(path_39462077, nil, header_39462078, nil, nil)

var getReposOwnerRepoIssuesNumber* = Call_GetReposOwnerRepoIssuesNumber_39462068(
    name: "getReposOwnerRepoIssuesNumber", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}",
    validator: validate_GetReposOwnerRepoIssuesNumber_39462069, base: "/",
    url: url_GetReposOwnerRepoIssuesNumber_39462070, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoIssuesNumber_39462079 = ref object of OpenApiRestCall_39460352
proc url_PatchReposOwnerRepoIssuesNumber_39462081(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoIssuesNumber_39462080(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Edit an issue.
  ## Issue owners and users with push access can edit an issue.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462082 = path.getOrDefault("owner")
  valid_39462082 = validateParameter(valid_39462082, JString, required = true,
                                   default = nil)
  if valid_39462082 != nil:
    section.add "owner", valid_39462082
  var valid_39462083 = path.getOrDefault("number")
  valid_39462083 = validateParameter(valid_39462083, JInt, required = true,
                                   default = nil)
  if valid_39462083 != nil:
    section.add "number", valid_39462083
  var valid_39462084 = path.getOrDefault("repo")
  valid_39462084 = validateParameter(valid_39462084, JString, required = true,
                                   default = nil)
  if valid_39462084 != nil:
    section.add "repo", valid_39462084
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462085 = header.getOrDefault("Accept")
  valid_39462085 = validateParameter(valid_39462085, JString, required = false,
                                   default = nil)
  if valid_39462085 != nil:
    section.add "Accept", valid_39462085
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39462087: Call_PatchReposOwnerRepoIssuesNumber_39462079;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit an issue.
  ## Issue owners and users with push access can edit an issue.
  ## 
  ## 
  let valid = call_39462087.validator(path, query, header, formData, body, _)
  let scheme = call_39462087.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462087.url(scheme.get, call_39462087.host, call_39462087.base,
                           call_39462087.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462087, uri, valid, _)

proc call*(call_39462088: Call_PatchReposOwnerRepoIssuesNumber_39462079;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoIssuesNumber
  ## Edit an issue.
  ## Issue owners and users with push access can edit an issue.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462089 = newJObject()
  var header_39462090 = newJObject()
  var body_39462091 = newJObject()
  add(path_39462089, "owner", newJString(owner))
  add(path_39462089, "number", newJInt(number))
  add(header_39462090, "Accept", newJString(Accept))
  if body != nil:
    body_39462091 = body
  add(path_39462089, "repo", newJString(repo))
  result = call_39462088.call(path_39462089, nil, header_39462090, nil, body_39462091)

var patchReposOwnerRepoIssuesNumber* = Call_PatchReposOwnerRepoIssuesNumber_39462079(
    name: "patchReposOwnerRepoIssuesNumber", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}",
    validator: validate_PatchReposOwnerRepoIssuesNumber_39462080, base: "/",
    url: url_PatchReposOwnerRepoIssuesNumber_39462081, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoIssuesNumberComments_39462103 = ref object of OpenApiRestCall_39460352
proc url_PostReposOwnerRepoIssuesNumberComments_39462105(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoIssuesNumberComments_39462104(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Create a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462106 = path.getOrDefault("owner")
  valid_39462106 = validateParameter(valid_39462106, JString, required = true,
                                   default = nil)
  if valid_39462106 != nil:
    section.add "owner", valid_39462106
  var valid_39462107 = path.getOrDefault("number")
  valid_39462107 = validateParameter(valid_39462107, JInt, required = true,
                                   default = nil)
  if valid_39462107 != nil:
    section.add "number", valid_39462107
  var valid_39462108 = path.getOrDefault("repo")
  valid_39462108 = validateParameter(valid_39462108, JString, required = true,
                                   default = nil)
  if valid_39462108 != nil:
    section.add "repo", valid_39462108
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462109 = header.getOrDefault("Accept")
  valid_39462109 = validateParameter(valid_39462109, JString, required = false,
                                   default = nil)
  if valid_39462109 != nil:
    section.add "Accept", valid_39462109
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39462111: Call_PostReposOwnerRepoIssuesNumberComments_39462103;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a comment.
  ## 
  let valid = call_39462111.validator(path, query, header, formData, body, _)
  let scheme = call_39462111.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462111.url(scheme.get, call_39462111.host, call_39462111.base,
                           call_39462111.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462111, uri, valid, _)

proc call*(call_39462112: Call_PostReposOwnerRepoIssuesNumberComments_39462103;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoIssuesNumberComments
  ## Create a comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462113 = newJObject()
  var header_39462114 = newJObject()
  var body_39462115 = newJObject()
  add(path_39462113, "owner", newJString(owner))
  add(path_39462113, "number", newJInt(number))
  add(header_39462114, "Accept", newJString(Accept))
  if body != nil:
    body_39462115 = body
  add(path_39462113, "repo", newJString(repo))
  result = call_39462112.call(path_39462113, nil, header_39462114, nil, body_39462115)

var postReposOwnerRepoIssuesNumberComments* = Call_PostReposOwnerRepoIssuesNumberComments_39462103(
    name: "postReposOwnerRepoIssuesNumberComments", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/{number}/comments",
    validator: validate_PostReposOwnerRepoIssuesNumberComments_39462104,
    base: "/", url: url_PostReposOwnerRepoIssuesNumberComments_39462105,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumberComments_39462092 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoIssuesNumberComments_39462094(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumberComments_39462093(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List comments on an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462095 = path.getOrDefault("owner")
  valid_39462095 = validateParameter(valid_39462095, JString, required = true,
                                   default = nil)
  if valid_39462095 != nil:
    section.add "owner", valid_39462095
  var valid_39462096 = path.getOrDefault("number")
  valid_39462096 = validateParameter(valid_39462096, JInt, required = true,
                                   default = nil)
  if valid_39462096 != nil:
    section.add "number", valid_39462096
  var valid_39462097 = path.getOrDefault("repo")
  valid_39462097 = validateParameter(valid_39462097, JString, required = true,
                                   default = nil)
  if valid_39462097 != nil:
    section.add "repo", valid_39462097
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462098 = header.getOrDefault("Accept")
  valid_39462098 = validateParameter(valid_39462098, JString, required = false,
                                   default = nil)
  if valid_39462098 != nil:
    section.add "Accept", valid_39462098
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462099: Call_GetReposOwnerRepoIssuesNumberComments_39462092;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List comments on an issue.
  ## 
  let valid = call_39462099.validator(path, query, header, formData, body, _)
  let scheme = call_39462099.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462099.url(scheme.get, call_39462099.host, call_39462099.base,
                           call_39462099.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462099, uri, valid, _)

proc call*(call_39462100: Call_GetReposOwnerRepoIssuesNumberComments_39462092;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumberComments
  ## List comments on an issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462101 = newJObject()
  var header_39462102 = newJObject()
  add(path_39462101, "owner", newJString(owner))
  add(path_39462101, "number", newJInt(number))
  add(header_39462102, "Accept", newJString(Accept))
  add(path_39462101, "repo", newJString(repo))
  result = call_39462100.call(path_39462101, nil, header_39462102, nil, nil)

var getReposOwnerRepoIssuesNumberComments* = Call_GetReposOwnerRepoIssuesNumberComments_39462092(
    name: "getReposOwnerRepoIssuesNumberComments", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/{number}/comments",
    validator: validate_GetReposOwnerRepoIssuesNumberComments_39462093, base: "/",
    url: url_GetReposOwnerRepoIssuesNumberComments_39462094,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumberEvents_39462116 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoIssuesNumberEvents_39462118(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumberEvents_39462117(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List events for an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462119 = path.getOrDefault("owner")
  valid_39462119 = validateParameter(valid_39462119, JString, required = true,
                                   default = nil)
  if valid_39462119 != nil:
    section.add "owner", valid_39462119
  var valid_39462120 = path.getOrDefault("number")
  valid_39462120 = validateParameter(valid_39462120, JInt, required = true,
                                   default = nil)
  if valid_39462120 != nil:
    section.add "number", valid_39462120
  var valid_39462121 = path.getOrDefault("repo")
  valid_39462121 = validateParameter(valid_39462121, JString, required = true,
                                   default = nil)
  if valid_39462121 != nil:
    section.add "repo", valid_39462121
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462122 = header.getOrDefault("Accept")
  valid_39462122 = validateParameter(valid_39462122, JString, required = false,
                                   default = nil)
  if valid_39462122 != nil:
    section.add "Accept", valid_39462122
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462123: Call_GetReposOwnerRepoIssuesNumberEvents_39462116;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List events for an issue.
  ## 
  let valid = call_39462123.validator(path, query, header, formData, body, _)
  let scheme = call_39462123.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462123.url(scheme.get, call_39462123.host, call_39462123.base,
                           call_39462123.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462123, uri, valid, _)

proc call*(call_39462124: Call_GetReposOwnerRepoIssuesNumberEvents_39462116;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumberEvents
  ## List events for an issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462125 = newJObject()
  var header_39462126 = newJObject()
  add(path_39462125, "owner", newJString(owner))
  add(path_39462125, "number", newJInt(number))
  add(header_39462126, "Accept", newJString(Accept))
  add(path_39462125, "repo", newJString(repo))
  result = call_39462124.call(path_39462125, nil, header_39462126, nil, nil)

var getReposOwnerRepoIssuesNumberEvents* = Call_GetReposOwnerRepoIssuesNumberEvents_39462116(
    name: "getReposOwnerRepoIssuesNumberEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/events",
    validator: validate_GetReposOwnerRepoIssuesNumberEvents_39462117, base: "/",
    url: url_GetReposOwnerRepoIssuesNumberEvents_39462118, schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoIssuesNumberLabels_39462138 = ref object of OpenApiRestCall_39460352
proc url_PutReposOwnerRepoIssuesNumberLabels_39462140(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoIssuesNumberLabels_39462139(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Replace all labels for an issue.
  ## Sending an empty array ([]) will remove all Labels from the Issue.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462141 = path.getOrDefault("owner")
  valid_39462141 = validateParameter(valid_39462141, JString, required = true,
                                   default = nil)
  if valid_39462141 != nil:
    section.add "owner", valid_39462141
  var valid_39462142 = path.getOrDefault("number")
  valid_39462142 = validateParameter(valid_39462142, JInt, required = true,
                                   default = nil)
  if valid_39462142 != nil:
    section.add "number", valid_39462142
  var valid_39462143 = path.getOrDefault("repo")
  valid_39462143 = validateParameter(valid_39462143, JString, required = true,
                                   default = nil)
  if valid_39462143 != nil:
    section.add "repo", valid_39462143
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462144 = header.getOrDefault("Accept")
  valid_39462144 = validateParameter(valid_39462144, JString, required = false,
                                   default = nil)
  if valid_39462144 != nil:
    section.add "Accept", valid_39462144
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39462146: Call_PutReposOwnerRepoIssuesNumberLabels_39462138;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Replace all labels for an issue.
  ## Sending an empty array ([]) will remove all Labels from the Issue.
  ## 
  ## 
  let valid = call_39462146.validator(path, query, header, formData, body, _)
  let scheme = call_39462146.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462146.url(scheme.get, call_39462146.host, call_39462146.base,
                           call_39462146.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462146, uri, valid, _)

proc call*(call_39462147: Call_PutReposOwnerRepoIssuesNumberLabels_39462138;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoIssuesNumberLabels
  ## Replace all labels for an issue.
  ## Sending an empty array ([]) will remove all Labels from the Issue.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462148 = newJObject()
  var header_39462149 = newJObject()
  var body_39462150 = newJObject()
  add(path_39462148, "owner", newJString(owner))
  add(path_39462148, "number", newJInt(number))
  add(header_39462149, "Accept", newJString(Accept))
  if body != nil:
    body_39462150 = body
  add(path_39462148, "repo", newJString(repo))
  result = call_39462147.call(path_39462148, nil, header_39462149, nil, body_39462150)

var putReposOwnerRepoIssuesNumberLabels* = Call_PutReposOwnerRepoIssuesNumberLabels_39462138(
    name: "putReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_PutReposOwnerRepoIssuesNumberLabels_39462139, base: "/",
    url: url_PutReposOwnerRepoIssuesNumberLabels_39462140, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoIssuesNumberLabels_39462151 = ref object of OpenApiRestCall_39460352
proc url_PostReposOwnerRepoIssuesNumberLabels_39462153(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoIssuesNumberLabels_39462152(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Add labels to an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462154 = path.getOrDefault("owner")
  valid_39462154 = validateParameter(valid_39462154, JString, required = true,
                                   default = nil)
  if valid_39462154 != nil:
    section.add "owner", valid_39462154
  var valid_39462155 = path.getOrDefault("number")
  valid_39462155 = validateParameter(valid_39462155, JInt, required = true,
                                   default = nil)
  if valid_39462155 != nil:
    section.add "number", valid_39462155
  var valid_39462156 = path.getOrDefault("repo")
  valid_39462156 = validateParameter(valid_39462156, JString, required = true,
                                   default = nil)
  if valid_39462156 != nil:
    section.add "repo", valid_39462156
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462157 = header.getOrDefault("Accept")
  valid_39462157 = validateParameter(valid_39462157, JString, required = false,
                                   default = nil)
  if valid_39462157 != nil:
    section.add "Accept", valid_39462157
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39462159: Call_PostReposOwnerRepoIssuesNumberLabels_39462151;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Add labels to an issue.
  ## 
  let valid = call_39462159.validator(path, query, header, formData, body, _)
  let scheme = call_39462159.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462159.url(scheme.get, call_39462159.host, call_39462159.base,
                           call_39462159.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462159, uri, valid, _)

proc call*(call_39462160: Call_PostReposOwnerRepoIssuesNumberLabels_39462151;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoIssuesNumberLabels
  ## Add labels to an issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462161 = newJObject()
  var header_39462162 = newJObject()
  var body_39462163 = newJObject()
  add(path_39462161, "owner", newJString(owner))
  add(path_39462161, "number", newJInt(number))
  add(header_39462162, "Accept", newJString(Accept))
  if body != nil:
    body_39462163 = body
  add(path_39462161, "repo", newJString(repo))
  result = call_39462160.call(path_39462161, nil, header_39462162, nil, body_39462163)

var postReposOwnerRepoIssuesNumberLabels* = Call_PostReposOwnerRepoIssuesNumberLabels_39462151(
    name: "postReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_PostReposOwnerRepoIssuesNumberLabels_39462152, base: "/",
    url: url_PostReposOwnerRepoIssuesNumberLabels_39462153,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumberLabels_39462127 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoIssuesNumberLabels_39462129(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumberLabels_39462128(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List labels on an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462130 = path.getOrDefault("owner")
  valid_39462130 = validateParameter(valid_39462130, JString, required = true,
                                   default = nil)
  if valid_39462130 != nil:
    section.add "owner", valid_39462130
  var valid_39462131 = path.getOrDefault("number")
  valid_39462131 = validateParameter(valid_39462131, JInt, required = true,
                                   default = nil)
  if valid_39462131 != nil:
    section.add "number", valid_39462131
  var valid_39462132 = path.getOrDefault("repo")
  valid_39462132 = validateParameter(valid_39462132, JString, required = true,
                                   default = nil)
  if valid_39462132 != nil:
    section.add "repo", valid_39462132
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462133 = header.getOrDefault("Accept")
  valid_39462133 = validateParameter(valid_39462133, JString, required = false,
                                   default = nil)
  if valid_39462133 != nil:
    section.add "Accept", valid_39462133
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462134: Call_GetReposOwnerRepoIssuesNumberLabels_39462127;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List labels on an issue.
  ## 
  let valid = call_39462134.validator(path, query, header, formData, body, _)
  let scheme = call_39462134.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462134.url(scheme.get, call_39462134.host, call_39462134.base,
                           call_39462134.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462134, uri, valid, _)

proc call*(call_39462135: Call_GetReposOwnerRepoIssuesNumberLabels_39462127;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumberLabels
  ## List labels on an issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462136 = newJObject()
  var header_39462137 = newJObject()
  add(path_39462136, "owner", newJString(owner))
  add(path_39462136, "number", newJInt(number))
  add(header_39462137, "Accept", newJString(Accept))
  add(path_39462136, "repo", newJString(repo))
  result = call_39462135.call(path_39462136, nil, header_39462137, nil, nil)

var getReposOwnerRepoIssuesNumberLabels* = Call_GetReposOwnerRepoIssuesNumberLabels_39462127(
    name: "getReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_GetReposOwnerRepoIssuesNumberLabels_39462128, base: "/",
    url: url_GetReposOwnerRepoIssuesNumberLabels_39462129, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoIssuesNumberLabels_39462164 = ref object of OpenApiRestCall_39460352
proc url_DeleteReposOwnerRepoIssuesNumberLabels_39462166(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoIssuesNumberLabels_39462165(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Remove all labels from an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462167 = path.getOrDefault("owner")
  valid_39462167 = validateParameter(valid_39462167, JString, required = true,
                                   default = nil)
  if valid_39462167 != nil:
    section.add "owner", valid_39462167
  var valid_39462168 = path.getOrDefault("number")
  valid_39462168 = validateParameter(valid_39462168, JInt, required = true,
                                   default = nil)
  if valid_39462168 != nil:
    section.add "number", valid_39462168
  var valid_39462169 = path.getOrDefault("repo")
  valid_39462169 = validateParameter(valid_39462169, JString, required = true,
                                   default = nil)
  if valid_39462169 != nil:
    section.add "repo", valid_39462169
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462170 = header.getOrDefault("Accept")
  valid_39462170 = validateParameter(valid_39462170, JString, required = false,
                                   default = nil)
  if valid_39462170 != nil:
    section.add "Accept", valid_39462170
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462171: Call_DeleteReposOwnerRepoIssuesNumberLabels_39462164;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Remove all labels from an issue.
  ## 
  let valid = call_39462171.validator(path, query, header, formData, body, _)
  let scheme = call_39462171.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462171.url(scheme.get, call_39462171.host, call_39462171.base,
                           call_39462171.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462171, uri, valid, _)

proc call*(call_39462172: Call_DeleteReposOwnerRepoIssuesNumberLabels_39462164;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoIssuesNumberLabels
  ## Remove all labels from an issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462173 = newJObject()
  var header_39462174 = newJObject()
  add(path_39462173, "owner", newJString(owner))
  add(path_39462173, "number", newJInt(number))
  add(header_39462174, "Accept", newJString(Accept))
  add(path_39462173, "repo", newJString(repo))
  result = call_39462172.call(path_39462173, nil, header_39462174, nil, nil)

var deleteReposOwnerRepoIssuesNumberLabels* = Call_DeleteReposOwnerRepoIssuesNumberLabels_39462164(
    name: "deleteReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_DeleteReposOwnerRepoIssuesNumberLabels_39462165,
    base: "/", url: url_DeleteReposOwnerRepoIssuesNumberLabels_39462166,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoIssuesNumberLabelsName_39462175 = ref object of OpenApiRestCall_39460352
proc url_DeleteReposOwnerRepoIssuesNumberLabelsName_39462177(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoIssuesNumberLabelsName_39462176(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Remove a label from an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   name: JString (required)
  ##       : Name of the label.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462178 = path.getOrDefault("owner")
  valid_39462178 = validateParameter(valid_39462178, JString, required = true,
                                   default = nil)
  if valid_39462178 != nil:
    section.add "owner", valid_39462178
  var valid_39462179 = path.getOrDefault("number")
  valid_39462179 = validateParameter(valid_39462179, JInt, required = true,
                                   default = nil)
  if valid_39462179 != nil:
    section.add "number", valid_39462179
  var valid_39462180 = path.getOrDefault("name")
  valid_39462180 = validateParameter(valid_39462180, JString, required = true,
                                   default = nil)
  if valid_39462180 != nil:
    section.add "name", valid_39462180
  var valid_39462181 = path.getOrDefault("repo")
  valid_39462181 = validateParameter(valid_39462181, JString, required = true,
                                   default = nil)
  if valid_39462181 != nil:
    section.add "repo", valid_39462181
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462182 = header.getOrDefault("Accept")
  valid_39462182 = validateParameter(valid_39462182, JString, required = false,
                                   default = nil)
  if valid_39462182 != nil:
    section.add "Accept", valid_39462182
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462183: Call_DeleteReposOwnerRepoIssuesNumberLabelsName_39462175;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Remove a label from an issue.
  ## 
  let valid = call_39462183.validator(path, query, header, formData, body, _)
  let scheme = call_39462183.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462183.url(scheme.get, call_39462183.host, call_39462183.base,
                           call_39462183.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462183, uri, valid, _)

proc call*(call_39462184: Call_DeleteReposOwnerRepoIssuesNumberLabelsName_39462175;
          owner: string; number: int; name: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoIssuesNumberLabelsName
  ## Remove a label from an issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   name: string (required)
  ##       : Name of the label.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462185 = newJObject()
  var header_39462186 = newJObject()
  add(path_39462185, "owner", newJString(owner))
  add(path_39462185, "number", newJInt(number))
  add(path_39462185, "name", newJString(name))
  add(header_39462186, "Accept", newJString(Accept))
  add(path_39462185, "repo", newJString(repo))
  result = call_39462184.call(path_39462185, nil, header_39462186, nil, nil)

var deleteReposOwnerRepoIssuesNumberLabelsName* = Call_DeleteReposOwnerRepoIssuesNumberLabelsName_39462175(
    name: "deleteReposOwnerRepoIssuesNumberLabelsName",
    meth: HttpMethod.HttpDelete, host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/{number}/labels/{name}",
    validator: validate_DeleteReposOwnerRepoIssuesNumberLabelsName_39462176,
    base: "/", url: url_DeleteReposOwnerRepoIssuesNumberLabelsName_39462177,
    schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoKeys_39462197 = ref object of OpenApiRestCall_39460352
proc url_PostReposOwnerRepoKeys_39462199(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/keys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoKeys_39462198(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a key.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462200 = path.getOrDefault("owner")
  valid_39462200 = validateParameter(valid_39462200, JString, required = true,
                                   default = nil)
  if valid_39462200 != nil:
    section.add "owner", valid_39462200
  var valid_39462201 = path.getOrDefault("repo")
  valid_39462201 = validateParameter(valid_39462201, JString, required = true,
                                   default = nil)
  if valid_39462201 != nil:
    section.add "repo", valid_39462201
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462202 = header.getOrDefault("Accept")
  valid_39462202 = validateParameter(valid_39462202, JString, required = false,
                                   default = nil)
  if valid_39462202 != nil:
    section.add "Accept", valid_39462202
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39462204: Call_PostReposOwnerRepoKeys_39462197;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a key.
  ## 
  let valid = call_39462204.validator(path, query, header, formData, body, _)
  let scheme = call_39462204.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462204.url(scheme.get, call_39462204.host, call_39462204.base,
                           call_39462204.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462204, uri, valid, _)

proc call*(call_39462205: Call_PostReposOwnerRepoKeys_39462197; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoKeys
  ## Create a key.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462206 = newJObject()
  var header_39462207 = newJObject()
  var body_39462208 = newJObject()
  add(path_39462206, "owner", newJString(owner))
  add(header_39462207, "Accept", newJString(Accept))
  if body != nil:
    body_39462208 = body
  add(path_39462206, "repo", newJString(repo))
  result = call_39462205.call(path_39462206, nil, header_39462207, nil, body_39462208)

var postReposOwnerRepoKeys* = Call_PostReposOwnerRepoKeys_39462197(
    name: "postReposOwnerRepoKeys", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/keys",
    validator: validate_PostReposOwnerRepoKeys_39462198, base: "/",
    url: url_PostReposOwnerRepoKeys_39462199, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoKeys_39462187 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoKeys_39462189(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/keys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoKeys_39462188(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get list of keys.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462190 = path.getOrDefault("owner")
  valid_39462190 = validateParameter(valid_39462190, JString, required = true,
                                   default = nil)
  if valid_39462190 != nil:
    section.add "owner", valid_39462190
  var valid_39462191 = path.getOrDefault("repo")
  valid_39462191 = validateParameter(valid_39462191, JString, required = true,
                                   default = nil)
  if valid_39462191 != nil:
    section.add "repo", valid_39462191
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462192 = header.getOrDefault("Accept")
  valid_39462192 = validateParameter(valid_39462192, JString, required = false,
                                   default = nil)
  if valid_39462192 != nil:
    section.add "Accept", valid_39462192
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462193: Call_GetReposOwnerRepoKeys_39462187;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get list of keys.
  ## 
  let valid = call_39462193.validator(path, query, header, formData, body, _)
  let scheme = call_39462193.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462193.url(scheme.get, call_39462193.host, call_39462193.base,
                           call_39462193.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462193, uri, valid, _)

proc call*(call_39462194: Call_GetReposOwnerRepoKeys_39462187; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoKeys
  ## Get list of keys.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462195 = newJObject()
  var header_39462196 = newJObject()
  add(path_39462195, "owner", newJString(owner))
  add(header_39462196, "Accept", newJString(Accept))
  add(path_39462195, "repo", newJString(repo))
  result = call_39462194.call(path_39462195, nil, header_39462196, nil, nil)

var getReposOwnerRepoKeys* = Call_GetReposOwnerRepoKeys_39462187(
    name: "getReposOwnerRepoKeys", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/repos/{owner}/{repo}/keys",
    validator: validate_GetReposOwnerRepoKeys_39462188, base: "/",
    url: url_GetReposOwnerRepoKeys_39462189, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoKeysKeyId_39462209 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoKeysKeyId_39462211(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/keys/"),
               (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoKeysKeyId_39462210(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get a key
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   keyId: JInt (required)
  ##        : Id of key.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462212 = path.getOrDefault("owner")
  valid_39462212 = validateParameter(valid_39462212, JString, required = true,
                                   default = nil)
  if valid_39462212 != nil:
    section.add "owner", valid_39462212
  var valid_39462213 = path.getOrDefault("keyId")
  valid_39462213 = validateParameter(valid_39462213, JInt, required = true,
                                   default = nil)
  if valid_39462213 != nil:
    section.add "keyId", valid_39462213
  var valid_39462214 = path.getOrDefault("repo")
  valid_39462214 = validateParameter(valid_39462214, JString, required = true,
                                   default = nil)
  if valid_39462214 != nil:
    section.add "repo", valid_39462214
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462215 = header.getOrDefault("Accept")
  valid_39462215 = validateParameter(valid_39462215, JString, required = false,
                                   default = nil)
  if valid_39462215 != nil:
    section.add "Accept", valid_39462215
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462216: Call_GetReposOwnerRepoKeysKeyId_39462209;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a key
  ## 
  let valid = call_39462216.validator(path, query, header, formData, body, _)
  let scheme = call_39462216.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462216.url(scheme.get, call_39462216.host, call_39462216.base,
                           call_39462216.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462216, uri, valid, _)

proc call*(call_39462217: Call_GetReposOwnerRepoKeysKeyId_39462209; owner: string;
          keyId: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoKeysKeyId
  ## Get a key
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   keyId: int (required)
  ##        : Id of key.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462218 = newJObject()
  var header_39462219 = newJObject()
  add(path_39462218, "owner", newJString(owner))
  add(header_39462219, "Accept", newJString(Accept))
  add(path_39462218, "keyId", newJInt(keyId))
  add(path_39462218, "repo", newJString(repo))
  result = call_39462217.call(path_39462218, nil, header_39462219, nil, nil)

var getReposOwnerRepoKeysKeyId* = Call_GetReposOwnerRepoKeysKeyId_39462209(
    name: "getReposOwnerRepoKeysKeyId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/keys/{keyId}",
    validator: validate_GetReposOwnerRepoKeysKeyId_39462210, base: "/",
    url: url_GetReposOwnerRepoKeysKeyId_39462211, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoKeysKeyId_39462220 = ref object of OpenApiRestCall_39460352
proc url_DeleteReposOwnerRepoKeysKeyId_39462222(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/keys/"),
               (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoKeysKeyId_39462221(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a key.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   keyId: JInt (required)
  ##        : Id of key.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462223 = path.getOrDefault("owner")
  valid_39462223 = validateParameter(valid_39462223, JString, required = true,
                                   default = nil)
  if valid_39462223 != nil:
    section.add "owner", valid_39462223
  var valid_39462224 = path.getOrDefault("keyId")
  valid_39462224 = validateParameter(valid_39462224, JInt, required = true,
                                   default = nil)
  if valid_39462224 != nil:
    section.add "keyId", valid_39462224
  var valid_39462225 = path.getOrDefault("repo")
  valid_39462225 = validateParameter(valid_39462225, JString, required = true,
                                   default = nil)
  if valid_39462225 != nil:
    section.add "repo", valid_39462225
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462226 = header.getOrDefault("Accept")
  valid_39462226 = validateParameter(valid_39462226, JString, required = false,
                                   default = nil)
  if valid_39462226 != nil:
    section.add "Accept", valid_39462226
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462227: Call_DeleteReposOwnerRepoKeysKeyId_39462220;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a key.
  ## 
  let valid = call_39462227.validator(path, query, header, formData, body, _)
  let scheme = call_39462227.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462227.url(scheme.get, call_39462227.host, call_39462227.base,
                           call_39462227.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462227, uri, valid, _)

proc call*(call_39462228: Call_DeleteReposOwnerRepoKeysKeyId_39462220;
          owner: string; keyId: int; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoKeysKeyId
  ## Delete a key.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   keyId: int (required)
  ##        : Id of key.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462229 = newJObject()
  var header_39462230 = newJObject()
  add(path_39462229, "owner", newJString(owner))
  add(header_39462230, "Accept", newJString(Accept))
  add(path_39462229, "keyId", newJInt(keyId))
  add(path_39462229, "repo", newJString(repo))
  result = call_39462228.call(path_39462229, nil, header_39462230, nil, nil)

var deleteReposOwnerRepoKeysKeyId* = Call_DeleteReposOwnerRepoKeysKeyId_39462220(
    name: "deleteReposOwnerRepoKeysKeyId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/keys/{keyId}",
    validator: validate_DeleteReposOwnerRepoKeysKeyId_39462221, base: "/",
    url: url_DeleteReposOwnerRepoKeysKeyId_39462222, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoLabels_39462241 = ref object of OpenApiRestCall_39460352
proc url_PostReposOwnerRepoLabels_39462243(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoLabels_39462242(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462244 = path.getOrDefault("owner")
  valid_39462244 = validateParameter(valid_39462244, JString, required = true,
                                   default = nil)
  if valid_39462244 != nil:
    section.add "owner", valid_39462244
  var valid_39462245 = path.getOrDefault("repo")
  valid_39462245 = validateParameter(valid_39462245, JString, required = true,
                                   default = nil)
  if valid_39462245 != nil:
    section.add "repo", valid_39462245
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462246 = header.getOrDefault("Accept")
  valid_39462246 = validateParameter(valid_39462246, JString, required = false,
                                   default = nil)
  if valid_39462246 != nil:
    section.add "Accept", valid_39462246
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39462248: Call_PostReposOwnerRepoLabels_39462241;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a label.
  ## 
  let valid = call_39462248.validator(path, query, header, formData, body, _)
  let scheme = call_39462248.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462248.url(scheme.get, call_39462248.host, call_39462248.base,
                           call_39462248.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462248, uri, valid, _)

proc call*(call_39462249: Call_PostReposOwnerRepoLabels_39462241; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoLabels
  ## Create a label.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462250 = newJObject()
  var header_39462251 = newJObject()
  var body_39462252 = newJObject()
  add(path_39462250, "owner", newJString(owner))
  add(header_39462251, "Accept", newJString(Accept))
  if body != nil:
    body_39462252 = body
  add(path_39462250, "repo", newJString(repo))
  result = call_39462249.call(path_39462250, nil, header_39462251, nil, body_39462252)

var postReposOwnerRepoLabels* = Call_PostReposOwnerRepoLabels_39462241(
    name: "postReposOwnerRepoLabels", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels",
    validator: validate_PostReposOwnerRepoLabels_39462242, base: "/",
    url: url_PostReposOwnerRepoLabels_39462243, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoLabels_39462231 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoLabels_39462233(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoLabels_39462232(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List all labels for this repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462234 = path.getOrDefault("owner")
  valid_39462234 = validateParameter(valid_39462234, JString, required = true,
                                   default = nil)
  if valid_39462234 != nil:
    section.add "owner", valid_39462234
  var valid_39462235 = path.getOrDefault("repo")
  valid_39462235 = validateParameter(valid_39462235, JString, required = true,
                                   default = nil)
  if valid_39462235 != nil:
    section.add "repo", valid_39462235
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462236 = header.getOrDefault("Accept")
  valid_39462236 = validateParameter(valid_39462236, JString, required = false,
                                   default = nil)
  if valid_39462236 != nil:
    section.add "Accept", valid_39462236
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462237: Call_GetReposOwnerRepoLabels_39462231;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List all labels for this repository.
  ## 
  let valid = call_39462237.validator(path, query, header, formData, body, _)
  let scheme = call_39462237.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462237.url(scheme.get, call_39462237.host, call_39462237.base,
                           call_39462237.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462237, uri, valid, _)

proc call*(call_39462238: Call_GetReposOwnerRepoLabels_39462231; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoLabels
  ## List all labels for this repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462239 = newJObject()
  var header_39462240 = newJObject()
  add(path_39462239, "owner", newJString(owner))
  add(header_39462240, "Accept", newJString(Accept))
  add(path_39462239, "repo", newJString(repo))
  result = call_39462238.call(path_39462239, nil, header_39462240, nil, nil)

var getReposOwnerRepoLabels* = Call_GetReposOwnerRepoLabels_39462231(
    name: "getReposOwnerRepoLabels", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels",
    validator: validate_GetReposOwnerRepoLabels_39462232, base: "/",
    url: url_GetReposOwnerRepoLabels_39462233, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoLabelsName_39462253 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoLabelsName_39462255(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoLabelsName_39462254(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get a single label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   name: JString (required)
  ##       : Name of the label.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462256 = path.getOrDefault("owner")
  valid_39462256 = validateParameter(valid_39462256, JString, required = true,
                                   default = nil)
  if valid_39462256 != nil:
    section.add "owner", valid_39462256
  var valid_39462257 = path.getOrDefault("name")
  valid_39462257 = validateParameter(valid_39462257, JString, required = true,
                                   default = nil)
  if valid_39462257 != nil:
    section.add "name", valid_39462257
  var valid_39462258 = path.getOrDefault("repo")
  valid_39462258 = validateParameter(valid_39462258, JString, required = true,
                                   default = nil)
  if valid_39462258 != nil:
    section.add "repo", valid_39462258
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462259 = header.getOrDefault("Accept")
  valid_39462259 = validateParameter(valid_39462259, JString, required = false,
                                   default = nil)
  if valid_39462259 != nil:
    section.add "Accept", valid_39462259
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462260: Call_GetReposOwnerRepoLabelsName_39462253;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single label.
  ## 
  let valid = call_39462260.validator(path, query, header, formData, body, _)
  let scheme = call_39462260.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462260.url(scheme.get, call_39462260.host, call_39462260.base,
                           call_39462260.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462260, uri, valid, _)

proc call*(call_39462261: Call_GetReposOwnerRepoLabelsName_39462253; owner: string;
          name: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoLabelsName
  ## Get a single label.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   name: string (required)
  ##       : Name of the label.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462262 = newJObject()
  var header_39462263 = newJObject()
  add(path_39462262, "owner", newJString(owner))
  add(path_39462262, "name", newJString(name))
  add(header_39462263, "Accept", newJString(Accept))
  add(path_39462262, "repo", newJString(repo))
  result = call_39462261.call(path_39462262, nil, header_39462263, nil, nil)

var getReposOwnerRepoLabelsName* = Call_GetReposOwnerRepoLabelsName_39462253(
    name: "getReposOwnerRepoLabelsName", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels/{name}",
    validator: validate_GetReposOwnerRepoLabelsName_39462254, base: "/",
    url: url_GetReposOwnerRepoLabelsName_39462255, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoLabelsName_39462275 = ref object of OpenApiRestCall_39460352
proc url_PatchReposOwnerRepoLabelsName_39462277(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoLabelsName_39462276(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Update a label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   name: JString (required)
  ##       : Name of the label.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462278 = path.getOrDefault("owner")
  valid_39462278 = validateParameter(valid_39462278, JString, required = true,
                                   default = nil)
  if valid_39462278 != nil:
    section.add "owner", valid_39462278
  var valid_39462279 = path.getOrDefault("name")
  valid_39462279 = validateParameter(valid_39462279, JString, required = true,
                                   default = nil)
  if valid_39462279 != nil:
    section.add "name", valid_39462279
  var valid_39462280 = path.getOrDefault("repo")
  valid_39462280 = validateParameter(valid_39462280, JString, required = true,
                                   default = nil)
  if valid_39462280 != nil:
    section.add "repo", valid_39462280
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462281 = header.getOrDefault("Accept")
  valid_39462281 = validateParameter(valid_39462281, JString, required = false,
                                   default = nil)
  if valid_39462281 != nil:
    section.add "Accept", valid_39462281
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39462283: Call_PatchReposOwnerRepoLabelsName_39462275;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Update a label.
  ## 
  let valid = call_39462283.validator(path, query, header, formData, body, _)
  let scheme = call_39462283.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462283.url(scheme.get, call_39462283.host, call_39462283.base,
                           call_39462283.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462283, uri, valid, _)

proc call*(call_39462284: Call_PatchReposOwnerRepoLabelsName_39462275;
          owner: string; name: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoLabelsName
  ## Update a label.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   name: string (required)
  ##       : Name of the label.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462285 = newJObject()
  var header_39462286 = newJObject()
  var body_39462287 = newJObject()
  add(path_39462285, "owner", newJString(owner))
  add(path_39462285, "name", newJString(name))
  add(header_39462286, "Accept", newJString(Accept))
  if body != nil:
    body_39462287 = body
  add(path_39462285, "repo", newJString(repo))
  result = call_39462284.call(path_39462285, nil, header_39462286, nil, body_39462287)

var patchReposOwnerRepoLabelsName* = Call_PatchReposOwnerRepoLabelsName_39462275(
    name: "patchReposOwnerRepoLabelsName", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels/{name}",
    validator: validate_PatchReposOwnerRepoLabelsName_39462276, base: "/",
    url: url_PatchReposOwnerRepoLabelsName_39462277, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoLabelsName_39462264 = ref object of OpenApiRestCall_39460352
proc url_DeleteReposOwnerRepoLabelsName_39462266(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoLabelsName_39462265(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   name: JString (required)
  ##       : Name of the label.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462267 = path.getOrDefault("owner")
  valid_39462267 = validateParameter(valid_39462267, JString, required = true,
                                   default = nil)
  if valid_39462267 != nil:
    section.add "owner", valid_39462267
  var valid_39462268 = path.getOrDefault("name")
  valid_39462268 = validateParameter(valid_39462268, JString, required = true,
                                   default = nil)
  if valid_39462268 != nil:
    section.add "name", valid_39462268
  var valid_39462269 = path.getOrDefault("repo")
  valid_39462269 = validateParameter(valid_39462269, JString, required = true,
                                   default = nil)
  if valid_39462269 != nil:
    section.add "repo", valid_39462269
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462270 = header.getOrDefault("Accept")
  valid_39462270 = validateParameter(valid_39462270, JString, required = false,
                                   default = nil)
  if valid_39462270 != nil:
    section.add "Accept", valid_39462270
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462271: Call_DeleteReposOwnerRepoLabelsName_39462264;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a label.
  ## 
  let valid = call_39462271.validator(path, query, header, formData, body, _)
  let scheme = call_39462271.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462271.url(scheme.get, call_39462271.host, call_39462271.base,
                           call_39462271.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462271, uri, valid, _)

proc call*(call_39462272: Call_DeleteReposOwnerRepoLabelsName_39462264;
          owner: string; name: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoLabelsName
  ## Delete a label.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   name: string (required)
  ##       : Name of the label.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462273 = newJObject()
  var header_39462274 = newJObject()
  add(path_39462273, "owner", newJString(owner))
  add(path_39462273, "name", newJString(name))
  add(header_39462274, "Accept", newJString(Accept))
  add(path_39462273, "repo", newJString(repo))
  result = call_39462272.call(path_39462273, nil, header_39462274, nil, nil)

var deleteReposOwnerRepoLabelsName* = Call_DeleteReposOwnerRepoLabelsName_39462264(
    name: "deleteReposOwnerRepoLabelsName", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels/{name}",
    validator: validate_DeleteReposOwnerRepoLabelsName_39462265, base: "/",
    url: url_DeleteReposOwnerRepoLabelsName_39462266, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoLanguages_39462288 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoLanguages_39462290(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/languages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoLanguages_39462289(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List languages.
  ## List languages for the specified repository. The value on the right of a
  ## language is the number of bytes of code written in that language.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462291 = path.getOrDefault("owner")
  valid_39462291 = validateParameter(valid_39462291, JString, required = true,
                                   default = nil)
  if valid_39462291 != nil:
    section.add "owner", valid_39462291
  var valid_39462292 = path.getOrDefault("repo")
  valid_39462292 = validateParameter(valid_39462292, JString, required = true,
                                   default = nil)
  if valid_39462292 != nil:
    section.add "repo", valid_39462292
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462293 = header.getOrDefault("Accept")
  valid_39462293 = validateParameter(valid_39462293, JString, required = false,
                                   default = nil)
  if valid_39462293 != nil:
    section.add "Accept", valid_39462293
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462294: Call_GetReposOwnerRepoLanguages_39462288;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List languages.
  ## List languages for the specified repository. The value on the right of a
  ## language is the number of bytes of code written in that language.
  ## 
  ## 
  let valid = call_39462294.validator(path, query, header, formData, body, _)
  let scheme = call_39462294.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462294.url(scheme.get, call_39462294.host, call_39462294.base,
                           call_39462294.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462294, uri, valid, _)

proc call*(call_39462295: Call_GetReposOwnerRepoLanguages_39462288; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoLanguages
  ## List languages.
  ## List languages for the specified repository. The value on the right of a
  ## language is the number of bytes of code written in that language.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462296 = newJObject()
  var header_39462297 = newJObject()
  add(path_39462296, "owner", newJString(owner))
  add(header_39462297, "Accept", newJString(Accept))
  add(path_39462296, "repo", newJString(repo))
  result = call_39462295.call(path_39462296, nil, header_39462297, nil, nil)

var getReposOwnerRepoLanguages* = Call_GetReposOwnerRepoLanguages_39462288(
    name: "getReposOwnerRepoLanguages", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/languages",
    validator: validate_GetReposOwnerRepoLanguages_39462289, base: "/",
    url: url_GetReposOwnerRepoLanguages_39462290, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoMerges_39462298 = ref object of OpenApiRestCall_39460352
proc url_PostReposOwnerRepoMerges_39462300(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/merges")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoMerges_39462299(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Perform a merge.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462301 = path.getOrDefault("owner")
  valid_39462301 = validateParameter(valid_39462301, JString, required = true,
                                   default = nil)
  if valid_39462301 != nil:
    section.add "owner", valid_39462301
  var valid_39462302 = path.getOrDefault("repo")
  valid_39462302 = validateParameter(valid_39462302, JString, required = true,
                                   default = nil)
  if valid_39462302 != nil:
    section.add "repo", valid_39462302
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462303 = header.getOrDefault("Accept")
  valid_39462303 = validateParameter(valid_39462303, JString, required = false,
                                   default = nil)
  if valid_39462303 != nil:
    section.add "Accept", valid_39462303
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39462305: Call_PostReposOwnerRepoMerges_39462298;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Perform a merge.
  ## 
  let valid = call_39462305.validator(path, query, header, formData, body, _)
  let scheme = call_39462305.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462305.url(scheme.get, call_39462305.host, call_39462305.base,
                           call_39462305.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462305, uri, valid, _)

proc call*(call_39462306: Call_PostReposOwnerRepoMerges_39462298; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoMerges
  ## Perform a merge.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462307 = newJObject()
  var header_39462308 = newJObject()
  var body_39462309 = newJObject()
  add(path_39462307, "owner", newJString(owner))
  add(header_39462308, "Accept", newJString(Accept))
  if body != nil:
    body_39462309 = body
  add(path_39462307, "repo", newJString(repo))
  result = call_39462306.call(path_39462307, nil, header_39462308, nil, body_39462309)

var postReposOwnerRepoMerges* = Call_PostReposOwnerRepoMerges_39462298(
    name: "postReposOwnerRepoMerges", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/merges",
    validator: validate_PostReposOwnerRepoMerges_39462299, base: "/",
    url: url_PostReposOwnerRepoMerges_39462300, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoMilestones_39462324 = ref object of OpenApiRestCall_39460352
proc url_PostReposOwnerRepoMilestones_39462326(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoMilestones_39462325(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Create a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462327 = path.getOrDefault("owner")
  valid_39462327 = validateParameter(valid_39462327, JString, required = true,
                                   default = nil)
  if valid_39462327 != nil:
    section.add "owner", valid_39462327
  var valid_39462328 = path.getOrDefault("repo")
  valid_39462328 = validateParameter(valid_39462328, JString, required = true,
                                   default = nil)
  if valid_39462328 != nil:
    section.add "repo", valid_39462328
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462329 = header.getOrDefault("Accept")
  valid_39462329 = validateParameter(valid_39462329, JString, required = false,
                                   default = nil)
  if valid_39462329 != nil:
    section.add "Accept", valid_39462329
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39462331: Call_PostReposOwnerRepoMilestones_39462324;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a milestone.
  ## 
  let valid = call_39462331.validator(path, query, header, formData, body, _)
  let scheme = call_39462331.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462331.url(scheme.get, call_39462331.host, call_39462331.base,
                           call_39462331.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462331, uri, valid, _)

proc call*(call_39462332: Call_PostReposOwnerRepoMilestones_39462324;
          owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoMilestones
  ## Create a milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462333 = newJObject()
  var header_39462334 = newJObject()
  var body_39462335 = newJObject()
  add(path_39462333, "owner", newJString(owner))
  add(header_39462334, "Accept", newJString(Accept))
  if body != nil:
    body_39462335 = body
  add(path_39462333, "repo", newJString(repo))
  result = call_39462332.call(path_39462333, nil, header_39462334, nil, body_39462335)

var postReposOwnerRepoMilestones* = Call_PostReposOwnerRepoMilestones_39462324(
    name: "postReposOwnerRepoMilestones", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones",
    validator: validate_PostReposOwnerRepoMilestones_39462325, base: "/",
    url: url_PostReposOwnerRepoMilestones_39462326, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoMilestones_39462310 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoMilestones_39462312(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoMilestones_39462311(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List milestones for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462313 = path.getOrDefault("owner")
  valid_39462313 = validateParameter(valid_39462313, JString, required = true,
                                   default = nil)
  if valid_39462313 != nil:
    section.add "owner", valid_39462313
  var valid_39462314 = path.getOrDefault("repo")
  valid_39462314 = validateParameter(valid_39462314, JString, required = true,
                                   default = nil)
  if valid_39462314 != nil:
    section.add "repo", valid_39462314
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString
  ##        : String to filter by state.
  ##   sort: JString
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  section = newJObject()
  var valid_39462315 = query.getOrDefault("state")
  valid_39462315 = validateParameter(valid_39462315, JString, required = false,
                                   default = newJString("open"))
  if valid_39462315 != nil:
    section.add "state", valid_39462315
  var valid_39462316 = query.getOrDefault("sort")
  valid_39462316 = validateParameter(valid_39462316, JString, required = false,
                                   default = newJString("due_date"))
  if valid_39462316 != nil:
    section.add "sort", valid_39462316
  var valid_39462317 = query.getOrDefault("direction")
  valid_39462317 = validateParameter(valid_39462317, JString, required = false,
                                   default = nil)
  if valid_39462317 != nil:
    section.add "direction", valid_39462317
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462318 = header.getOrDefault("Accept")
  valid_39462318 = validateParameter(valid_39462318, JString, required = false,
                                   default = nil)
  if valid_39462318 != nil:
    section.add "Accept", valid_39462318
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462319: Call_GetReposOwnerRepoMilestones_39462310;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List milestones for a repository.
  ## 
  let valid = call_39462319.validator(path, query, header, formData, body, _)
  let scheme = call_39462319.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462319.url(scheme.get, call_39462319.host, call_39462319.base,
                           call_39462319.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462319, uri, valid, _)

proc call*(call_39462320: Call_GetReposOwnerRepoMilestones_39462310; owner: string;
          repo: string; state: string = "open"; Accept: string = "";
          sort: string = "due_date"; direction: string = ""): Recallable =
  ## getReposOwnerRepoMilestones
  ## List milestones for a repository.
  ##   state: string
  ##        : String to filter by state.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   sort: string
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  var path_39462321 = newJObject()
  var query_39462322 = newJObject()
  var header_39462323 = newJObject()
  add(query_39462322, "state", newJString(state))
  add(path_39462321, "owner", newJString(owner))
  add(header_39462323, "Accept", newJString(Accept))
  add(path_39462321, "repo", newJString(repo))
  add(query_39462322, "sort", newJString(sort))
  add(query_39462322, "direction", newJString(direction))
  result = call_39462320.call(path_39462321, query_39462322, header_39462323, nil, nil)

var getReposOwnerRepoMilestones* = Call_GetReposOwnerRepoMilestones_39462310(
    name: "getReposOwnerRepoMilestones", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones",
    validator: validate_GetReposOwnerRepoMilestones_39462311, base: "/",
    url: url_GetReposOwnerRepoMilestones_39462312, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoMilestonesNumber_39462336 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoMilestonesNumber_39462338(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoMilestonesNumber_39462337(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a single milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462339 = path.getOrDefault("owner")
  valid_39462339 = validateParameter(valid_39462339, JString, required = true,
                                   default = nil)
  if valid_39462339 != nil:
    section.add "owner", valid_39462339
  var valid_39462340 = path.getOrDefault("number")
  valid_39462340 = validateParameter(valid_39462340, JInt, required = true,
                                   default = nil)
  if valid_39462340 != nil:
    section.add "number", valid_39462340
  var valid_39462341 = path.getOrDefault("repo")
  valid_39462341 = validateParameter(valid_39462341, JString, required = true,
                                   default = nil)
  if valid_39462341 != nil:
    section.add "repo", valid_39462341
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462342 = header.getOrDefault("Accept")
  valid_39462342 = validateParameter(valid_39462342, JString, required = false,
                                   default = nil)
  if valid_39462342 != nil:
    section.add "Accept", valid_39462342
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462343: Call_GetReposOwnerRepoMilestonesNumber_39462336;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single milestone.
  ## 
  let valid = call_39462343.validator(path, query, header, formData, body, _)
  let scheme = call_39462343.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462343.url(scheme.get, call_39462343.host, call_39462343.base,
                           call_39462343.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462343, uri, valid, _)

proc call*(call_39462344: Call_GetReposOwnerRepoMilestonesNumber_39462336;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoMilestonesNumber
  ## Get a single milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462345 = newJObject()
  var header_39462346 = newJObject()
  add(path_39462345, "owner", newJString(owner))
  add(path_39462345, "number", newJInt(number))
  add(header_39462346, "Accept", newJString(Accept))
  add(path_39462345, "repo", newJString(repo))
  result = call_39462344.call(path_39462345, nil, header_39462346, nil, nil)

var getReposOwnerRepoMilestonesNumber* = Call_GetReposOwnerRepoMilestonesNumber_39462336(
    name: "getReposOwnerRepoMilestonesNumber", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones/{number}",
    validator: validate_GetReposOwnerRepoMilestonesNumber_39462337, base: "/",
    url: url_GetReposOwnerRepoMilestonesNumber_39462338, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoMilestonesNumber_39462358 = ref object of OpenApiRestCall_39460352
proc url_PatchReposOwnerRepoMilestonesNumber_39462360(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoMilestonesNumber_39462359(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Update a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462361 = path.getOrDefault("owner")
  valid_39462361 = validateParameter(valid_39462361, JString, required = true,
                                   default = nil)
  if valid_39462361 != nil:
    section.add "owner", valid_39462361
  var valid_39462362 = path.getOrDefault("number")
  valid_39462362 = validateParameter(valid_39462362, JInt, required = true,
                                   default = nil)
  if valid_39462362 != nil:
    section.add "number", valid_39462362
  var valid_39462363 = path.getOrDefault("repo")
  valid_39462363 = validateParameter(valid_39462363, JString, required = true,
                                   default = nil)
  if valid_39462363 != nil:
    section.add "repo", valid_39462363
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462364 = header.getOrDefault("Accept")
  valid_39462364 = validateParameter(valid_39462364, JString, required = false,
                                   default = nil)
  if valid_39462364 != nil:
    section.add "Accept", valid_39462364
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39462366: Call_PatchReposOwnerRepoMilestonesNumber_39462358;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Update a milestone.
  ## 
  let valid = call_39462366.validator(path, query, header, formData, body, _)
  let scheme = call_39462366.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462366.url(scheme.get, call_39462366.host, call_39462366.base,
                           call_39462366.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462366, uri, valid, _)

proc call*(call_39462367: Call_PatchReposOwnerRepoMilestonesNumber_39462358;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoMilestonesNumber
  ## Update a milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462368 = newJObject()
  var header_39462369 = newJObject()
  var body_39462370 = newJObject()
  add(path_39462368, "owner", newJString(owner))
  add(path_39462368, "number", newJInt(number))
  add(header_39462369, "Accept", newJString(Accept))
  if body != nil:
    body_39462370 = body
  add(path_39462368, "repo", newJString(repo))
  result = call_39462367.call(path_39462368, nil, header_39462369, nil, body_39462370)

var patchReposOwnerRepoMilestonesNumber* = Call_PatchReposOwnerRepoMilestonesNumber_39462358(
    name: "patchReposOwnerRepoMilestonesNumber", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones/{number}",
    validator: validate_PatchReposOwnerRepoMilestonesNumber_39462359, base: "/",
    url: url_PatchReposOwnerRepoMilestonesNumber_39462360, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoMilestonesNumber_39462347 = ref object of OpenApiRestCall_39460352
proc url_DeleteReposOwnerRepoMilestonesNumber_39462349(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoMilestonesNumber_39462348(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462350 = path.getOrDefault("owner")
  valid_39462350 = validateParameter(valid_39462350, JString, required = true,
                                   default = nil)
  if valid_39462350 != nil:
    section.add "owner", valid_39462350
  var valid_39462351 = path.getOrDefault("number")
  valid_39462351 = validateParameter(valid_39462351, JInt, required = true,
                                   default = nil)
  if valid_39462351 != nil:
    section.add "number", valid_39462351
  var valid_39462352 = path.getOrDefault("repo")
  valid_39462352 = validateParameter(valid_39462352, JString, required = true,
                                   default = nil)
  if valid_39462352 != nil:
    section.add "repo", valid_39462352
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462353 = header.getOrDefault("Accept")
  valid_39462353 = validateParameter(valid_39462353, JString, required = false,
                                   default = nil)
  if valid_39462353 != nil:
    section.add "Accept", valid_39462353
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462354: Call_DeleteReposOwnerRepoMilestonesNumber_39462347;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a milestone.
  ## 
  let valid = call_39462354.validator(path, query, header, formData, body, _)
  let scheme = call_39462354.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462354.url(scheme.get, call_39462354.host, call_39462354.base,
                           call_39462354.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462354, uri, valid, _)

proc call*(call_39462355: Call_DeleteReposOwnerRepoMilestonesNumber_39462347;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoMilestonesNumber
  ## Delete a milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462356 = newJObject()
  var header_39462357 = newJObject()
  add(path_39462356, "owner", newJString(owner))
  add(path_39462356, "number", newJInt(number))
  add(header_39462357, "Accept", newJString(Accept))
  add(path_39462356, "repo", newJString(repo))
  result = call_39462355.call(path_39462356, nil, header_39462357, nil, nil)

var deleteReposOwnerRepoMilestonesNumber* = Call_DeleteReposOwnerRepoMilestonesNumber_39462347(
    name: "deleteReposOwnerRepoMilestonesNumber", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones/{number}",
    validator: validate_DeleteReposOwnerRepoMilestonesNumber_39462348, base: "/",
    url: url_DeleteReposOwnerRepoMilestonesNumber_39462349,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoMilestonesNumberLabels_39462371 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoMilestonesNumberLabels_39462373(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoMilestonesNumberLabels_39462372(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get labels for every issue in a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462374 = path.getOrDefault("owner")
  valid_39462374 = validateParameter(valid_39462374, JString, required = true,
                                   default = nil)
  if valid_39462374 != nil:
    section.add "owner", valid_39462374
  var valid_39462375 = path.getOrDefault("number")
  valid_39462375 = validateParameter(valid_39462375, JInt, required = true,
                                   default = nil)
  if valid_39462375 != nil:
    section.add "number", valid_39462375
  var valid_39462376 = path.getOrDefault("repo")
  valid_39462376 = validateParameter(valid_39462376, JString, required = true,
                                   default = nil)
  if valid_39462376 != nil:
    section.add "repo", valid_39462376
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462377 = header.getOrDefault("Accept")
  valid_39462377 = validateParameter(valid_39462377, JString, required = false,
                                   default = nil)
  if valid_39462377 != nil:
    section.add "Accept", valid_39462377
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462378: Call_GetReposOwnerRepoMilestonesNumberLabels_39462371;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get labels for every issue in a milestone.
  ## 
  let valid = call_39462378.validator(path, query, header, formData, body, _)
  let scheme = call_39462378.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462378.url(scheme.get, call_39462378.host, call_39462378.base,
                           call_39462378.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462378, uri, valid, _)

proc call*(call_39462379: Call_GetReposOwnerRepoMilestonesNumberLabels_39462371;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoMilestonesNumberLabels
  ## Get labels for every issue in a milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462380 = newJObject()
  var header_39462381 = newJObject()
  add(path_39462380, "owner", newJString(owner))
  add(path_39462380, "number", newJInt(number))
  add(header_39462381, "Accept", newJString(Accept))
  add(path_39462380, "repo", newJString(repo))
  result = call_39462379.call(path_39462380, nil, header_39462381, nil, nil)

var getReposOwnerRepoMilestonesNumberLabels* = Call_GetReposOwnerRepoMilestonesNumberLabels_39462371(
    name: "getReposOwnerRepoMilestonesNumberLabels", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/milestones/{number}/labels",
    validator: validate_GetReposOwnerRepoMilestonesNumberLabels_39462372,
    base: "/", url: url_GetReposOwnerRepoMilestonesNumberLabels_39462373,
    schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoNotifications_39462396 = ref object of OpenApiRestCall_39460352
proc url_PutReposOwnerRepoNotifications_39462398(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/notifications")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoNotifications_39462397(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Mark notifications as read in a repository.
  ## Marking all notifications in a repository as "read" removes them from the
  ## default view on GitHub.com.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462399 = path.getOrDefault("owner")
  valid_39462399 = validateParameter(valid_39462399, JString, required = true,
                                   default = nil)
  if valid_39462399 != nil:
    section.add "owner", valid_39462399
  var valid_39462400 = path.getOrDefault("repo")
  valid_39462400 = validateParameter(valid_39462400, JString, required = true,
                                   default = nil)
  if valid_39462400 != nil:
    section.add "repo", valid_39462400
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462401 = header.getOrDefault("Accept")
  valid_39462401 = validateParameter(valid_39462401, JString, required = false,
                                   default = nil)
  if valid_39462401 != nil:
    section.add "Accept", valid_39462401
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39462403: Call_PutReposOwnerRepoNotifications_39462396;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Mark notifications as read in a repository.
  ## Marking all notifications in a repository as "read" removes them from the
  ## default view on GitHub.com.
  ## 
  ## 
  let valid = call_39462403.validator(path, query, header, formData, body, _)
  let scheme = call_39462403.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462403.url(scheme.get, call_39462403.host, call_39462403.base,
                           call_39462403.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462403, uri, valid, _)

proc call*(call_39462404: Call_PutReposOwnerRepoNotifications_39462396;
          owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoNotifications
  ## Mark notifications as read in a repository.
  ## Marking all notifications in a repository as "read" removes them from the
  ## default view on GitHub.com.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462405 = newJObject()
  var header_39462406 = newJObject()
  var body_39462407 = newJObject()
  add(path_39462405, "owner", newJString(owner))
  add(header_39462406, "Accept", newJString(Accept))
  if body != nil:
    body_39462407 = body
  add(path_39462405, "repo", newJString(repo))
  result = call_39462404.call(path_39462405, nil, header_39462406, nil, body_39462407)

var putReposOwnerRepoNotifications* = Call_PutReposOwnerRepoNotifications_39462396(
    name: "putReposOwnerRepoNotifications", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/notifications",
    validator: validate_PutReposOwnerRepoNotifications_39462397, base: "/",
    url: url_PutReposOwnerRepoNotifications_39462398, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoNotifications_39462382 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoNotifications_39462384(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/notifications")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoNotifications_39462383(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List your notifications in a repository
  ## List all notifications for the current user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462385 = path.getOrDefault("owner")
  valid_39462385 = validateParameter(valid_39462385, JString, required = true,
                                   default = nil)
  if valid_39462385 != nil:
    section.add "owner", valid_39462385
  var valid_39462386 = path.getOrDefault("repo")
  valid_39462386 = validateParameter(valid_39462386, JString, required = true,
                                   default = nil)
  if valid_39462386 != nil:
    section.add "repo", valid_39462386
  result.add "path", section
  ## parameters in `query` object:
  ##   participating: JBool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  ##   all: JBool
  ##      : True to show notifications marked as read.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_39462387 = query.getOrDefault("participating")
  valid_39462387 = validateParameter(valid_39462387, JBool, required = false,
                                   default = nil)
  if valid_39462387 != nil:
    section.add "participating", valid_39462387
  var valid_39462388 = query.getOrDefault("all")
  valid_39462388 = validateParameter(valid_39462388, JBool, required = false,
                                   default = nil)
  if valid_39462388 != nil:
    section.add "all", valid_39462388
  var valid_39462389 = query.getOrDefault("since")
  valid_39462389 = validateParameter(valid_39462389, JString, required = false,
                                   default = nil)
  if valid_39462389 != nil:
    section.add "since", valid_39462389
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462390 = header.getOrDefault("Accept")
  valid_39462390 = validateParameter(valid_39462390, JString, required = false,
                                   default = nil)
  if valid_39462390 != nil:
    section.add "Accept", valid_39462390
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462391: Call_GetReposOwnerRepoNotifications_39462382;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List your notifications in a repository
  ## List all notifications for the current user.
  ## 
  ## 
  let valid = call_39462391.validator(path, query, header, formData, body, _)
  let scheme = call_39462391.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462391.url(scheme.get, call_39462391.host, call_39462391.base,
                           call_39462391.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462391, uri, valid, _)

proc call*(call_39462392: Call_GetReposOwnerRepoNotifications_39462382;
          owner: string; repo: string; participating: bool = false; all: bool = false;
          Accept: string = ""; since: string = ""): Recallable =
  ## getReposOwnerRepoNotifications
  ## List your notifications in a repository
  ## List all notifications for the current user.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   participating: bool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  ##   all: bool
  ##      : True to show notifications marked as read.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var path_39462393 = newJObject()
  var query_39462394 = newJObject()
  var header_39462395 = newJObject()
  add(path_39462393, "owner", newJString(owner))
  add(query_39462394, "participating", newJBool(participating))
  add(query_39462394, "all", newJBool(all))
  add(header_39462395, "Accept", newJString(Accept))
  add(path_39462393, "repo", newJString(repo))
  add(query_39462394, "since", newJString(since))
  result = call_39462392.call(path_39462393, query_39462394, header_39462395, nil, nil)

var getReposOwnerRepoNotifications* = Call_GetReposOwnerRepoNotifications_39462382(
    name: "getReposOwnerRepoNotifications", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/notifications",
    validator: validate_GetReposOwnerRepoNotifications_39462383, base: "/",
    url: url_GetReposOwnerRepoNotifications_39462384, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoPulls_39462422 = ref object of OpenApiRestCall_39460352
proc url_PostReposOwnerRepoPulls_39462424(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoPulls_39462423(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462425 = path.getOrDefault("owner")
  valid_39462425 = validateParameter(valid_39462425, JString, required = true,
                                   default = nil)
  if valid_39462425 != nil:
    section.add "owner", valid_39462425
  var valid_39462426 = path.getOrDefault("repo")
  valid_39462426 = validateParameter(valid_39462426, JString, required = true,
                                   default = nil)
  if valid_39462426 != nil:
    section.add "repo", valid_39462426
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462427 = header.getOrDefault("Accept")
  valid_39462427 = validateParameter(valid_39462427, JString, required = false,
                                   default = nil)
  if valid_39462427 != nil:
    section.add "Accept", valid_39462427
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39462429: Call_PostReposOwnerRepoPulls_39462422;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a pull request.
  ## 
  let valid = call_39462429.validator(path, query, header, formData, body, _)
  let scheme = call_39462429.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462429.url(scheme.get, call_39462429.host, call_39462429.base,
                           call_39462429.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462429, uri, valid, _)

proc call*(call_39462430: Call_PostReposOwnerRepoPulls_39462422; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoPulls
  ## Create a pull request.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462431 = newJObject()
  var header_39462432 = newJObject()
  var body_39462433 = newJObject()
  add(path_39462431, "owner", newJString(owner))
  add(header_39462432, "Accept", newJString(Accept))
  if body != nil:
    body_39462433 = body
  add(path_39462431, "repo", newJString(repo))
  result = call_39462430.call(path_39462431, nil, header_39462432, nil, body_39462433)

var postReposOwnerRepoPulls* = Call_PostReposOwnerRepoPulls_39462422(
    name: "postReposOwnerRepoPulls", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls",
    validator: validate_PostReposOwnerRepoPulls_39462423, base: "/",
    url: url_PostReposOwnerRepoPulls_39462424, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPulls_39462408 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoPulls_39462410(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPulls_39462409(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List pull requests.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462411 = path.getOrDefault("owner")
  valid_39462411 = validateParameter(valid_39462411, JString, required = true,
                                   default = nil)
  if valid_39462411 != nil:
    section.add "owner", valid_39462411
  var valid_39462412 = path.getOrDefault("repo")
  valid_39462412 = validateParameter(valid_39462412, JString, required = true,
                                   default = nil)
  if valid_39462412 != nil:
    section.add "repo", valid_39462412
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString
  ##        : String to filter by state.
  ##   head: JString
  ##       : Filter pulls by head user and branch name in the format of 'user:ref-name'.
  ## Example: github:new-script-format.
  ## 
  ##   base: JString
  ##       : Filter pulls by base branch name. Example - gh-pages.
  section = newJObject()
  var valid_39462413 = query.getOrDefault("state")
  valid_39462413 = validateParameter(valid_39462413, JString, required = false,
                                   default = newJString("open"))
  if valid_39462413 != nil:
    section.add "state", valid_39462413
  var valid_39462414 = query.getOrDefault("head")
  valid_39462414 = validateParameter(valid_39462414, JString, required = false,
                                   default = nil)
  if valid_39462414 != nil:
    section.add "head", valid_39462414
  var valid_39462415 = query.getOrDefault("base")
  valid_39462415 = validateParameter(valid_39462415, JString, required = false,
                                   default = nil)
  if valid_39462415 != nil:
    section.add "base", valid_39462415
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462416 = header.getOrDefault("Accept")
  valid_39462416 = validateParameter(valid_39462416, JString, required = false,
                                   default = nil)
  if valid_39462416 != nil:
    section.add "Accept", valid_39462416
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462417: Call_GetReposOwnerRepoPulls_39462408;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List pull requests.
  ## 
  let valid = call_39462417.validator(path, query, header, formData, body, _)
  let scheme = call_39462417.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462417.url(scheme.get, call_39462417.host, call_39462417.base,
                           call_39462417.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462417, uri, valid, _)

proc call*(call_39462418: Call_GetReposOwnerRepoPulls_39462408; owner: string;
          repo: string; state: string = "open"; head: string = ""; base: string = "";
          Accept: string = ""): Recallable =
  ## getReposOwnerRepoPulls
  ## List pull requests.
  ##   state: string
  ##        : String to filter by state.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   head: string
  ##       : Filter pulls by head user and branch name in the format of 'user:ref-name'.
  ## Example: github:new-script-format.
  ## 
  ##   base: string
  ##       : Filter pulls by base branch name. Example - gh-pages.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462419 = newJObject()
  var query_39462420 = newJObject()
  var header_39462421 = newJObject()
  add(query_39462420, "state", newJString(state))
  add(path_39462419, "owner", newJString(owner))
  add(query_39462420, "head", newJString(head))
  add(query_39462420, "base", newJString(base))
  add(header_39462421, "Accept", newJString(Accept))
  add(path_39462419, "repo", newJString(repo))
  result = call_39462418.call(path_39462419, query_39462420, header_39462421, nil, nil)

var getReposOwnerRepoPulls* = Call_GetReposOwnerRepoPulls_39462408(
    name: "getReposOwnerRepoPulls", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls",
    validator: validate_GetReposOwnerRepoPulls_39462409, base: "/",
    url: url_GetReposOwnerRepoPulls_39462410, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsComments_39462434 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoPullsComments_39462436(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsComments_39462435(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List comments in a repository.
  ## By default, Review Comments are ordered by ascending ID.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462437 = path.getOrDefault("owner")
  valid_39462437 = validateParameter(valid_39462437, JString, required = true,
                                   default = nil)
  if valid_39462437 != nil:
    section.add "owner", valid_39462437
  var valid_39462438 = path.getOrDefault("repo")
  valid_39462438 = validateParameter(valid_39462438, JString, required = true,
                                   default = nil)
  if valid_39462438 != nil:
    section.add "repo", valid_39462438
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_39462439 = query.getOrDefault("sort")
  valid_39462439 = validateParameter(valid_39462439, JString, required = false,
                                   default = newJString("created"))
  if valid_39462439 != nil:
    section.add "sort", valid_39462439
  var valid_39462440 = query.getOrDefault("direction")
  valid_39462440 = validateParameter(valid_39462440, JString, required = false,
                                   default = nil)
  if valid_39462440 != nil:
    section.add "direction", valid_39462440
  var valid_39462441 = query.getOrDefault("since")
  valid_39462441 = validateParameter(valid_39462441, JString, required = false,
                                   default = nil)
  if valid_39462441 != nil:
    section.add "since", valid_39462441
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462442 = header.getOrDefault("Accept")
  valid_39462442 = validateParameter(valid_39462442, JString, required = false,
                                   default = nil)
  if valid_39462442 != nil:
    section.add "Accept", valid_39462442
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462443: Call_GetReposOwnerRepoPullsComments_39462434;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List comments in a repository.
  ## By default, Review Comments are ordered by ascending ID.
  ## 
  ## 
  let valid = call_39462443.validator(path, query, header, formData, body, _)
  let scheme = call_39462443.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462443.url(scheme.get, call_39462443.host, call_39462443.base,
                           call_39462443.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462443, uri, valid, _)

proc call*(call_39462444: Call_GetReposOwnerRepoPullsComments_39462434;
          owner: string; repo: string; Accept: string = ""; sort: string = "created";
          direction: string = ""; since: string = ""): Recallable =
  ## getReposOwnerRepoPullsComments
  ## List comments in a repository.
  ## By default, Review Comments are ordered by ascending ID.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   sort: string
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var path_39462445 = newJObject()
  var query_39462446 = newJObject()
  var header_39462447 = newJObject()
  add(path_39462445, "owner", newJString(owner))
  add(header_39462447, "Accept", newJString(Accept))
  add(path_39462445, "repo", newJString(repo))
  add(query_39462446, "sort", newJString(sort))
  add(query_39462446, "direction", newJString(direction))
  add(query_39462446, "since", newJString(since))
  result = call_39462444.call(path_39462445, query_39462446, header_39462447, nil, nil)

var getReposOwnerRepoPullsComments* = Call_GetReposOwnerRepoPullsComments_39462434(
    name: "getReposOwnerRepoPullsComments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/comments",
    validator: validate_GetReposOwnerRepoPullsComments_39462435, base: "/",
    url: url_GetReposOwnerRepoPullsComments_39462436, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsCommentsCommentId_39462448 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoPullsCommentsCommentId_39462450(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsCommentsCommentId_39462449(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a single comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462451 = path.getOrDefault("owner")
  valid_39462451 = validateParameter(valid_39462451, JString, required = true,
                                   default = nil)
  if valid_39462451 != nil:
    section.add "owner", valid_39462451
  var valid_39462452 = path.getOrDefault("repo")
  valid_39462452 = validateParameter(valid_39462452, JString, required = true,
                                   default = nil)
  if valid_39462452 != nil:
    section.add "repo", valid_39462452
  var valid_39462453 = path.getOrDefault("commentId")
  valid_39462453 = validateParameter(valid_39462453, JInt, required = true,
                                   default = nil)
  if valid_39462453 != nil:
    section.add "commentId", valid_39462453
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462454 = header.getOrDefault("Accept")
  valid_39462454 = validateParameter(valid_39462454, JString, required = false,
                                   default = nil)
  if valid_39462454 != nil:
    section.add "Accept", valid_39462454
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462455: Call_GetReposOwnerRepoPullsCommentsCommentId_39462448;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single comment.
  ## 
  let valid = call_39462455.validator(path, query, header, formData, body, _)
  let scheme = call_39462455.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462455.url(scheme.get, call_39462455.host, call_39462455.base,
                           call_39462455.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462455, uri, valid, _)

proc call*(call_39462456: Call_GetReposOwnerRepoPullsCommentsCommentId_39462448;
          owner: string; repo: string; commentId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsCommentsCommentId
  ## Get a single comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_39462457 = newJObject()
  var header_39462458 = newJObject()
  add(path_39462457, "owner", newJString(owner))
  add(header_39462458, "Accept", newJString(Accept))
  add(path_39462457, "repo", newJString(repo))
  add(path_39462457, "commentId", newJInt(commentId))
  result = call_39462456.call(path_39462457, nil, header_39462458, nil, nil)

var getReposOwnerRepoPullsCommentsCommentId* = Call_GetReposOwnerRepoPullsCommentsCommentId_39462448(
    name: "getReposOwnerRepoPullsCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/comments/{commentId}",
    validator: validate_GetReposOwnerRepoPullsCommentsCommentId_39462449,
    base: "/", url: url_GetReposOwnerRepoPullsCommentsCommentId_39462450,
    schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoPullsCommentsCommentId_39462470 = ref object of OpenApiRestCall_39460352
proc url_PatchReposOwnerRepoPullsCommentsCommentId_39462472(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoPullsCommentsCommentId_39462471(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Edit a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462473 = path.getOrDefault("owner")
  valid_39462473 = validateParameter(valid_39462473, JString, required = true,
                                   default = nil)
  if valid_39462473 != nil:
    section.add "owner", valid_39462473
  var valid_39462474 = path.getOrDefault("repo")
  valid_39462474 = validateParameter(valid_39462474, JString, required = true,
                                   default = nil)
  if valid_39462474 != nil:
    section.add "repo", valid_39462474
  var valid_39462475 = path.getOrDefault("commentId")
  valid_39462475 = validateParameter(valid_39462475, JInt, required = true,
                                   default = nil)
  if valid_39462475 != nil:
    section.add "commentId", valid_39462475
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462476 = header.getOrDefault("Accept")
  valid_39462476 = validateParameter(valid_39462476, JString, required = false,
                                   default = nil)
  if valid_39462476 != nil:
    section.add "Accept", valid_39462476
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39462478: Call_PatchReposOwnerRepoPullsCommentsCommentId_39462470;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit a comment.
  ## 
  let valid = call_39462478.validator(path, query, header, formData, body, _)
  let scheme = call_39462478.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462478.url(scheme.get, call_39462478.host, call_39462478.base,
                           call_39462478.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462478, uri, valid, _)

proc call*(call_39462479: Call_PatchReposOwnerRepoPullsCommentsCommentId_39462470;
          owner: string; body: JsonNode; repo: string; commentId: int;
          Accept: string = ""): Recallable =
  ## patchReposOwnerRepoPullsCommentsCommentId
  ## Edit a comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_39462480 = newJObject()
  var header_39462481 = newJObject()
  var body_39462482 = newJObject()
  add(path_39462480, "owner", newJString(owner))
  add(header_39462481, "Accept", newJString(Accept))
  if body != nil:
    body_39462482 = body
  add(path_39462480, "repo", newJString(repo))
  add(path_39462480, "commentId", newJInt(commentId))
  result = call_39462479.call(path_39462480, nil, header_39462481, nil, body_39462482)

var patchReposOwnerRepoPullsCommentsCommentId* = Call_PatchReposOwnerRepoPullsCommentsCommentId_39462470(
    name: "patchReposOwnerRepoPullsCommentsCommentId", meth: HttpMethod.HttpPatch,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/comments/{commentId}",
    validator: validate_PatchReposOwnerRepoPullsCommentsCommentId_39462471,
    base: "/", url: url_PatchReposOwnerRepoPullsCommentsCommentId_39462472,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoPullsCommentsCommentId_39462459 = ref object of OpenApiRestCall_39460352
proc url_DeleteReposOwnerRepoPullsCommentsCommentId_39462461(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoPullsCommentsCommentId_39462460(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462462 = path.getOrDefault("owner")
  valid_39462462 = validateParameter(valid_39462462, JString, required = true,
                                   default = nil)
  if valid_39462462 != nil:
    section.add "owner", valid_39462462
  var valid_39462463 = path.getOrDefault("repo")
  valid_39462463 = validateParameter(valid_39462463, JString, required = true,
                                   default = nil)
  if valid_39462463 != nil:
    section.add "repo", valid_39462463
  var valid_39462464 = path.getOrDefault("commentId")
  valid_39462464 = validateParameter(valid_39462464, JInt, required = true,
                                   default = nil)
  if valid_39462464 != nil:
    section.add "commentId", valid_39462464
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462465 = header.getOrDefault("Accept")
  valid_39462465 = validateParameter(valid_39462465, JString, required = false,
                                   default = nil)
  if valid_39462465 != nil:
    section.add "Accept", valid_39462465
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462466: Call_DeleteReposOwnerRepoPullsCommentsCommentId_39462459;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a comment.
  ## 
  let valid = call_39462466.validator(path, query, header, formData, body, _)
  let scheme = call_39462466.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462466.url(scheme.get, call_39462466.host, call_39462466.base,
                           call_39462466.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462466, uri, valid, _)

proc call*(call_39462467: Call_DeleteReposOwnerRepoPullsCommentsCommentId_39462459;
          owner: string; repo: string; commentId: int; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoPullsCommentsCommentId
  ## Delete a comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_39462468 = newJObject()
  var header_39462469 = newJObject()
  add(path_39462468, "owner", newJString(owner))
  add(header_39462469, "Accept", newJString(Accept))
  add(path_39462468, "repo", newJString(repo))
  add(path_39462468, "commentId", newJInt(commentId))
  result = call_39462467.call(path_39462468, nil, header_39462469, nil, nil)

var deleteReposOwnerRepoPullsCommentsCommentId* = Call_DeleteReposOwnerRepoPullsCommentsCommentId_39462459(
    name: "deleteReposOwnerRepoPullsCommentsCommentId",
    meth: HttpMethod.HttpDelete, host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/comments/{commentId}",
    validator: validate_DeleteReposOwnerRepoPullsCommentsCommentId_39462460,
    base: "/", url: url_DeleteReposOwnerRepoPullsCommentsCommentId_39462461,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumber_39462483 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoPullsNumber_39462485(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumber_39462484(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a single pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462486 = path.getOrDefault("owner")
  valid_39462486 = validateParameter(valid_39462486, JString, required = true,
                                   default = nil)
  if valid_39462486 != nil:
    section.add "owner", valid_39462486
  var valid_39462487 = path.getOrDefault("number")
  valid_39462487 = validateParameter(valid_39462487, JInt, required = true,
                                   default = nil)
  if valid_39462487 != nil:
    section.add "number", valid_39462487
  var valid_39462488 = path.getOrDefault("repo")
  valid_39462488 = validateParameter(valid_39462488, JString, required = true,
                                   default = nil)
  if valid_39462488 != nil:
    section.add "repo", valid_39462488
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462489 = header.getOrDefault("Accept")
  valid_39462489 = validateParameter(valid_39462489, JString, required = false,
                                   default = nil)
  if valid_39462489 != nil:
    section.add "Accept", valid_39462489
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462490: Call_GetReposOwnerRepoPullsNumber_39462483;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single pull request.
  ## 
  let valid = call_39462490.validator(path, query, header, formData, body, _)
  let scheme = call_39462490.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462490.url(scheme.get, call_39462490.host, call_39462490.base,
                           call_39462490.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462490, uri, valid, _)

proc call*(call_39462491: Call_GetReposOwnerRepoPullsNumber_39462483;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumber
  ## Get a single pull request.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462492 = newJObject()
  var header_39462493 = newJObject()
  add(path_39462492, "owner", newJString(owner))
  add(path_39462492, "number", newJInt(number))
  add(header_39462493, "Accept", newJString(Accept))
  add(path_39462492, "repo", newJString(repo))
  result = call_39462491.call(path_39462492, nil, header_39462493, nil, nil)

var getReposOwnerRepoPullsNumber* = Call_GetReposOwnerRepoPullsNumber_39462483(
    name: "getReposOwnerRepoPullsNumber", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}",
    validator: validate_GetReposOwnerRepoPullsNumber_39462484, base: "/",
    url: url_GetReposOwnerRepoPullsNumber_39462485, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoPullsNumber_39462494 = ref object of OpenApiRestCall_39460352
proc url_PatchReposOwnerRepoPullsNumber_39462496(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoPullsNumber_39462495(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Update a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462497 = path.getOrDefault("owner")
  valid_39462497 = validateParameter(valid_39462497, JString, required = true,
                                   default = nil)
  if valid_39462497 != nil:
    section.add "owner", valid_39462497
  var valid_39462498 = path.getOrDefault("number")
  valid_39462498 = validateParameter(valid_39462498, JInt, required = true,
                                   default = nil)
  if valid_39462498 != nil:
    section.add "number", valid_39462498
  var valid_39462499 = path.getOrDefault("repo")
  valid_39462499 = validateParameter(valid_39462499, JString, required = true,
                                   default = nil)
  if valid_39462499 != nil:
    section.add "repo", valid_39462499
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462500 = header.getOrDefault("Accept")
  valid_39462500 = validateParameter(valid_39462500, JString, required = false,
                                   default = nil)
  if valid_39462500 != nil:
    section.add "Accept", valid_39462500
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39462502: Call_PatchReposOwnerRepoPullsNumber_39462494;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Update a pull request.
  ## 
  let valid = call_39462502.validator(path, query, header, formData, body, _)
  let scheme = call_39462502.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462502.url(scheme.get, call_39462502.host, call_39462502.base,
                           call_39462502.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462502, uri, valid, _)

proc call*(call_39462503: Call_PatchReposOwnerRepoPullsNumber_39462494;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoPullsNumber
  ## Update a pull request.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462504 = newJObject()
  var header_39462505 = newJObject()
  var body_39462506 = newJObject()
  add(path_39462504, "owner", newJString(owner))
  add(path_39462504, "number", newJInt(number))
  add(header_39462505, "Accept", newJString(Accept))
  if body != nil:
    body_39462506 = body
  add(path_39462504, "repo", newJString(repo))
  result = call_39462503.call(path_39462504, nil, header_39462505, nil, body_39462506)

var patchReposOwnerRepoPullsNumber* = Call_PatchReposOwnerRepoPullsNumber_39462494(
    name: "patchReposOwnerRepoPullsNumber", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}",
    validator: validate_PatchReposOwnerRepoPullsNumber_39462495, base: "/",
    url: url_PatchReposOwnerRepoPullsNumber_39462496, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoPullsNumberComments_39462518 = ref object of OpenApiRestCall_39460352
proc url_PostReposOwnerRepoPullsNumberComments_39462520(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoPullsNumberComments_39462519(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Create a comment.
  ##   #TODO Alternative input ( http://developer.github.com/v3/pulls/comments/ )
  ##   description: |
  ##     Alternative Input.
  ##     Instead of passing commit_id, path, and position you can reply to an
  ##     existing Pull Request Comment like this:
  ## 
  ##         body
  ##            Required string
  ##         in_reply_to
  ##            Required number - Comment id to reply to.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462521 = path.getOrDefault("owner")
  valid_39462521 = validateParameter(valid_39462521, JString, required = true,
                                   default = nil)
  if valid_39462521 != nil:
    section.add "owner", valid_39462521
  var valid_39462522 = path.getOrDefault("number")
  valid_39462522 = validateParameter(valid_39462522, JInt, required = true,
                                   default = nil)
  if valid_39462522 != nil:
    section.add "number", valid_39462522
  var valid_39462523 = path.getOrDefault("repo")
  valid_39462523 = validateParameter(valid_39462523, JString, required = true,
                                   default = nil)
  if valid_39462523 != nil:
    section.add "repo", valid_39462523
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462524 = header.getOrDefault("Accept")
  valid_39462524 = validateParameter(valid_39462524, JString, required = false,
                                   default = nil)
  if valid_39462524 != nil:
    section.add "Accept", valid_39462524
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39462526: Call_PostReposOwnerRepoPullsNumberComments_39462518;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a comment.
  ##   #TODO Alternative input ( http://developer.github.com/v3/pulls/comments/ )
  ##   description: |
  ##     Alternative Input.
  ##     Instead of passing commit_id, path, and position you can reply to an
  ##     existing Pull Request Comment like this:
  ## 
  ##         body
  ##            Required string
  ##         in_reply_to
  ##            Required number - Comment id to reply to.
  ## 
  ## 
  let valid = call_39462526.validator(path, query, header, formData, body, _)
  let scheme = call_39462526.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462526.url(scheme.get, call_39462526.host, call_39462526.base,
                           call_39462526.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462526, uri, valid, _)

proc call*(call_39462527: Call_PostReposOwnerRepoPullsNumberComments_39462518;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoPullsNumberComments
  ## Create a comment.
  ##   #TODO Alternative input ( http://developer.github.com/v3/pulls/comments/ )
  ##   description: |
  ##     Alternative Input.
  ##     Instead of passing commit_id, path, and position you can reply to an
  ##     existing Pull Request Comment like this:
  ## 
  ##         body
  ##            Required string
  ##         in_reply_to
  ##            Required number - Comment id to reply to.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462528 = newJObject()
  var header_39462529 = newJObject()
  var body_39462530 = newJObject()
  add(path_39462528, "owner", newJString(owner))
  add(path_39462528, "number", newJInt(number))
  add(header_39462529, "Accept", newJString(Accept))
  if body != nil:
    body_39462530 = body
  add(path_39462528, "repo", newJString(repo))
  result = call_39462527.call(path_39462528, nil, header_39462529, nil, body_39462530)

var postReposOwnerRepoPullsNumberComments* = Call_PostReposOwnerRepoPullsNumberComments_39462518(
    name: "postReposOwnerRepoPullsNumberComments", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/{number}/comments",
    validator: validate_PostReposOwnerRepoPullsNumberComments_39462519, base: "/",
    url: url_PostReposOwnerRepoPullsNumberComments_39462520,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberComments_39462507 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoPullsNumberComments_39462509(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberComments_39462508(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List comments on a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462510 = path.getOrDefault("owner")
  valid_39462510 = validateParameter(valid_39462510, JString, required = true,
                                   default = nil)
  if valid_39462510 != nil:
    section.add "owner", valid_39462510
  var valid_39462511 = path.getOrDefault("number")
  valid_39462511 = validateParameter(valid_39462511, JInt, required = true,
                                   default = nil)
  if valid_39462511 != nil:
    section.add "number", valid_39462511
  var valid_39462512 = path.getOrDefault("repo")
  valid_39462512 = validateParameter(valid_39462512, JString, required = true,
                                   default = nil)
  if valid_39462512 != nil:
    section.add "repo", valid_39462512
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462513 = header.getOrDefault("Accept")
  valid_39462513 = validateParameter(valid_39462513, JString, required = false,
                                   default = nil)
  if valid_39462513 != nil:
    section.add "Accept", valid_39462513
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462514: Call_GetReposOwnerRepoPullsNumberComments_39462507;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List comments on a pull request.
  ## 
  let valid = call_39462514.validator(path, query, header, formData, body, _)
  let scheme = call_39462514.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462514.url(scheme.get, call_39462514.host, call_39462514.base,
                           call_39462514.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462514, uri, valid, _)

proc call*(call_39462515: Call_GetReposOwnerRepoPullsNumberComments_39462507;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberComments
  ## List comments on a pull request.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462516 = newJObject()
  var header_39462517 = newJObject()
  add(path_39462516, "owner", newJString(owner))
  add(path_39462516, "number", newJInt(number))
  add(header_39462517, "Accept", newJString(Accept))
  add(path_39462516, "repo", newJString(repo))
  result = call_39462515.call(path_39462516, nil, header_39462517, nil, nil)

var getReposOwnerRepoPullsNumberComments* = Call_GetReposOwnerRepoPullsNumberComments_39462507(
    name: "getReposOwnerRepoPullsNumberComments", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/{number}/comments",
    validator: validate_GetReposOwnerRepoPullsNumberComments_39462508, base: "/",
    url: url_GetReposOwnerRepoPullsNumberComments_39462509,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberCommits_39462531 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoPullsNumberCommits_39462533(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/commits")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberCommits_39462532(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List commits on a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462534 = path.getOrDefault("owner")
  valid_39462534 = validateParameter(valid_39462534, JString, required = true,
                                   default = nil)
  if valid_39462534 != nil:
    section.add "owner", valid_39462534
  var valid_39462535 = path.getOrDefault("number")
  valid_39462535 = validateParameter(valid_39462535, JInt, required = true,
                                   default = nil)
  if valid_39462535 != nil:
    section.add "number", valid_39462535
  var valid_39462536 = path.getOrDefault("repo")
  valid_39462536 = validateParameter(valid_39462536, JString, required = true,
                                   default = nil)
  if valid_39462536 != nil:
    section.add "repo", valid_39462536
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462537 = header.getOrDefault("Accept")
  valid_39462537 = validateParameter(valid_39462537, JString, required = false,
                                   default = nil)
  if valid_39462537 != nil:
    section.add "Accept", valid_39462537
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462538: Call_GetReposOwnerRepoPullsNumberCommits_39462531;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List commits on a pull request.
  ## 
  let valid = call_39462538.validator(path, query, header, formData, body, _)
  let scheme = call_39462538.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462538.url(scheme.get, call_39462538.host, call_39462538.base,
                           call_39462538.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462538, uri, valid, _)

proc call*(call_39462539: Call_GetReposOwnerRepoPullsNumberCommits_39462531;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberCommits
  ## List commits on a pull request.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462540 = newJObject()
  var header_39462541 = newJObject()
  add(path_39462540, "owner", newJString(owner))
  add(path_39462540, "number", newJInt(number))
  add(header_39462541, "Accept", newJString(Accept))
  add(path_39462540, "repo", newJString(repo))
  result = call_39462539.call(path_39462540, nil, header_39462541, nil, nil)

var getReposOwnerRepoPullsNumberCommits* = Call_GetReposOwnerRepoPullsNumberCommits_39462531(
    name: "getReposOwnerRepoPullsNumberCommits", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/commits",
    validator: validate_GetReposOwnerRepoPullsNumberCommits_39462532, base: "/",
    url: url_GetReposOwnerRepoPullsNumberCommits_39462533, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberFiles_39462542 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoPullsNumberFiles_39462544(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/files")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberFiles_39462543(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List pull requests files.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462545 = path.getOrDefault("owner")
  valid_39462545 = validateParameter(valid_39462545, JString, required = true,
                                   default = nil)
  if valid_39462545 != nil:
    section.add "owner", valid_39462545
  var valid_39462546 = path.getOrDefault("number")
  valid_39462546 = validateParameter(valid_39462546, JInt, required = true,
                                   default = nil)
  if valid_39462546 != nil:
    section.add "number", valid_39462546
  var valid_39462547 = path.getOrDefault("repo")
  valid_39462547 = validateParameter(valid_39462547, JString, required = true,
                                   default = nil)
  if valid_39462547 != nil:
    section.add "repo", valid_39462547
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462548 = header.getOrDefault("Accept")
  valid_39462548 = validateParameter(valid_39462548, JString, required = false,
                                   default = nil)
  if valid_39462548 != nil:
    section.add "Accept", valid_39462548
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462549: Call_GetReposOwnerRepoPullsNumberFiles_39462542;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List pull requests files.
  ## 
  let valid = call_39462549.validator(path, query, header, formData, body, _)
  let scheme = call_39462549.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462549.url(scheme.get, call_39462549.host, call_39462549.base,
                           call_39462549.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462549, uri, valid, _)

proc call*(call_39462550: Call_GetReposOwnerRepoPullsNumberFiles_39462542;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberFiles
  ## List pull requests files.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462551 = newJObject()
  var header_39462552 = newJObject()
  add(path_39462551, "owner", newJString(owner))
  add(path_39462551, "number", newJInt(number))
  add(header_39462552, "Accept", newJString(Accept))
  add(path_39462551, "repo", newJString(repo))
  result = call_39462550.call(path_39462551, nil, header_39462552, nil, nil)

var getReposOwnerRepoPullsNumberFiles* = Call_GetReposOwnerRepoPullsNumberFiles_39462542(
    name: "getReposOwnerRepoPullsNumberFiles", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/files",
    validator: validate_GetReposOwnerRepoPullsNumberFiles_39462543, base: "/",
    url: url_GetReposOwnerRepoPullsNumberFiles_39462544, schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoPullsNumberMerge_39462564 = ref object of OpenApiRestCall_39460352
proc url_PutReposOwnerRepoPullsNumberMerge_39462566(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/merge")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoPullsNumberMerge_39462565(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Merge a pull request (Merge Button's)
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462567 = path.getOrDefault("owner")
  valid_39462567 = validateParameter(valid_39462567, JString, required = true,
                                   default = nil)
  if valid_39462567 != nil:
    section.add "owner", valid_39462567
  var valid_39462568 = path.getOrDefault("number")
  valid_39462568 = validateParameter(valid_39462568, JInt, required = true,
                                   default = nil)
  if valid_39462568 != nil:
    section.add "number", valid_39462568
  var valid_39462569 = path.getOrDefault("repo")
  valid_39462569 = validateParameter(valid_39462569, JString, required = true,
                                   default = nil)
  if valid_39462569 != nil:
    section.add "repo", valid_39462569
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462570 = header.getOrDefault("Accept")
  valid_39462570 = validateParameter(valid_39462570, JString, required = false,
                                   default = nil)
  if valid_39462570 != nil:
    section.add "Accept", valid_39462570
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39462572: Call_PutReposOwnerRepoPullsNumberMerge_39462564;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Merge a pull request (Merge Button's)
  ## 
  let valid = call_39462572.validator(path, query, header, formData, body, _)
  let scheme = call_39462572.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462572.url(scheme.get, call_39462572.host, call_39462572.base,
                           call_39462572.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462572, uri, valid, _)

proc call*(call_39462573: Call_PutReposOwnerRepoPullsNumberMerge_39462564;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoPullsNumberMerge
  ## Merge a pull request (Merge Button's)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462574 = newJObject()
  var header_39462575 = newJObject()
  var body_39462576 = newJObject()
  add(path_39462574, "owner", newJString(owner))
  add(path_39462574, "number", newJInt(number))
  add(header_39462575, "Accept", newJString(Accept))
  if body != nil:
    body_39462576 = body
  add(path_39462574, "repo", newJString(repo))
  result = call_39462573.call(path_39462574, nil, header_39462575, nil, body_39462576)

var putReposOwnerRepoPullsNumberMerge* = Call_PutReposOwnerRepoPullsNumberMerge_39462564(
    name: "putReposOwnerRepoPullsNumberMerge", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/merge",
    validator: validate_PutReposOwnerRepoPullsNumberMerge_39462565, base: "/",
    url: url_PutReposOwnerRepoPullsNumberMerge_39462566, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberMerge_39462553 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoPullsNumberMerge_39462555(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/merge")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberMerge_39462554(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get if a pull request has been merged.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462556 = path.getOrDefault("owner")
  valid_39462556 = validateParameter(valid_39462556, JString, required = true,
                                   default = nil)
  if valid_39462556 != nil:
    section.add "owner", valid_39462556
  var valid_39462557 = path.getOrDefault("number")
  valid_39462557 = validateParameter(valid_39462557, JInt, required = true,
                                   default = nil)
  if valid_39462557 != nil:
    section.add "number", valid_39462557
  var valid_39462558 = path.getOrDefault("repo")
  valid_39462558 = validateParameter(valid_39462558, JString, required = true,
                                   default = nil)
  if valid_39462558 != nil:
    section.add "repo", valid_39462558
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462559 = header.getOrDefault("Accept")
  valid_39462559 = validateParameter(valid_39462559, JString, required = false,
                                   default = nil)
  if valid_39462559 != nil:
    section.add "Accept", valid_39462559
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462560: Call_GetReposOwnerRepoPullsNumberMerge_39462553;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get if a pull request has been merged.
  ## 
  let valid = call_39462560.validator(path, query, header, formData, body, _)
  let scheme = call_39462560.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462560.url(scheme.get, call_39462560.host, call_39462560.base,
                           call_39462560.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462560, uri, valid, _)

proc call*(call_39462561: Call_GetReposOwnerRepoPullsNumberMerge_39462553;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberMerge
  ## Get if a pull request has been merged.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462562 = newJObject()
  var header_39462563 = newJObject()
  add(path_39462562, "owner", newJString(owner))
  add(path_39462562, "number", newJInt(number))
  add(header_39462563, "Accept", newJString(Accept))
  add(path_39462562, "repo", newJString(repo))
  result = call_39462561.call(path_39462562, nil, header_39462563, nil, nil)

var getReposOwnerRepoPullsNumberMerge* = Call_GetReposOwnerRepoPullsNumberMerge_39462553(
    name: "getReposOwnerRepoPullsNumberMerge", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/merge",
    validator: validate_GetReposOwnerRepoPullsNumberMerge_39462554, base: "/",
    url: url_GetReposOwnerRepoPullsNumberMerge_39462555, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReadme_39462577 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoReadme_39462579(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/readme")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReadme_39462578(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get the README.
  ## This method returns the preferred README for a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462580 = path.getOrDefault("owner")
  valid_39462580 = validateParameter(valid_39462580, JString, required = true,
                                   default = nil)
  if valid_39462580 != nil:
    section.add "owner", valid_39462580
  var valid_39462581 = path.getOrDefault("repo")
  valid_39462581 = validateParameter(valid_39462581, JString, required = true,
                                   default = nil)
  if valid_39462581 != nil:
    section.add "repo", valid_39462581
  result.add "path", section
  ## parameters in `query` object:
  ##   ref: JString
  ##      : The String name of the Commit/Branch/Tag. Defaults to master.
  section = newJObject()
  var valid_39462582 = query.getOrDefault("ref")
  valid_39462582 = validateParameter(valid_39462582, JString, required = false,
                                   default = nil)
  if valid_39462582 != nil:
    section.add "ref", valid_39462582
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462583 = header.getOrDefault("Accept")
  valid_39462583 = validateParameter(valid_39462583, JString, required = false,
                                   default = nil)
  if valid_39462583 != nil:
    section.add "Accept", valid_39462583
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462584: Call_GetReposOwnerRepoReadme_39462577;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get the README.
  ## This method returns the preferred README for a repository.
  ## 
  ## 
  let valid = call_39462584.validator(path, query, header, formData, body, _)
  let scheme = call_39462584.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462584.url(scheme.get, call_39462584.host, call_39462584.base,
                           call_39462584.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462584, uri, valid, _)

proc call*(call_39462585: Call_GetReposOwnerRepoReadme_39462577; owner: string;
          repo: string; Accept: string = ""; `ref`: string = ""): Recallable =
  ## getReposOwnerRepoReadme
  ## Get the README.
  ## This method returns the preferred README for a repository.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   ref: string
  ##      : The String name of the Commit/Branch/Tag. Defaults to master.
  var path_39462586 = newJObject()
  var query_39462587 = newJObject()
  var header_39462588 = newJObject()
  add(path_39462586, "owner", newJString(owner))
  add(header_39462588, "Accept", newJString(Accept))
  add(path_39462586, "repo", newJString(repo))
  add(query_39462587, "ref", newJString(`ref`))
  result = call_39462585.call(path_39462586, query_39462587, header_39462588, nil, nil)

var getReposOwnerRepoReadme* = Call_GetReposOwnerRepoReadme_39462577(
    name: "getReposOwnerRepoReadme", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/readme",
    validator: validate_GetReposOwnerRepoReadme_39462578, base: "/",
    url: url_GetReposOwnerRepoReadme_39462579, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoReleases_39462599 = ref object of OpenApiRestCall_39460352
proc url_PostReposOwnerRepoReleases_39462601(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoReleases_39462600(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a release
  ## Users with push access to the repository can create a release.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462602 = path.getOrDefault("owner")
  valid_39462602 = validateParameter(valid_39462602, JString, required = true,
                                   default = nil)
  if valid_39462602 != nil:
    section.add "owner", valid_39462602
  var valid_39462603 = path.getOrDefault("repo")
  valid_39462603 = validateParameter(valid_39462603, JString, required = true,
                                   default = nil)
  if valid_39462603 != nil:
    section.add "repo", valid_39462603
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462604 = header.getOrDefault("Accept")
  valid_39462604 = validateParameter(valid_39462604, JString, required = false,
                                   default = nil)
  if valid_39462604 != nil:
    section.add "Accept", valid_39462604
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39462606: Call_PostReposOwnerRepoReleases_39462599;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a release
  ## Users with push access to the repository can create a release.
  ## 
  ## 
  let valid = call_39462606.validator(path, query, header, formData, body, _)
  let scheme = call_39462606.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462606.url(scheme.get, call_39462606.host, call_39462606.base,
                           call_39462606.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462606, uri, valid, _)

proc call*(call_39462607: Call_PostReposOwnerRepoReleases_39462599; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoReleases
  ## Create a release
  ## Users with push access to the repository can create a release.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462608 = newJObject()
  var header_39462609 = newJObject()
  var body_39462610 = newJObject()
  add(path_39462608, "owner", newJString(owner))
  add(header_39462609, "Accept", newJString(Accept))
  if body != nil:
    body_39462610 = body
  add(path_39462608, "repo", newJString(repo))
  result = call_39462607.call(path_39462608, nil, header_39462609, nil, body_39462610)

var postReposOwnerRepoReleases* = Call_PostReposOwnerRepoReleases_39462599(
    name: "postReposOwnerRepoReleases", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases",
    validator: validate_PostReposOwnerRepoReleases_39462600, base: "/",
    url: url_PostReposOwnerRepoReleases_39462601, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleases_39462589 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoReleases_39462591(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleases_39462590(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Users with push access to the repository will receive all releases (i.e., published releases and draft releases). Users with pull access will receive published releases only
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462592 = path.getOrDefault("owner")
  valid_39462592 = validateParameter(valid_39462592, JString, required = true,
                                   default = nil)
  if valid_39462592 != nil:
    section.add "owner", valid_39462592
  var valid_39462593 = path.getOrDefault("repo")
  valid_39462593 = validateParameter(valid_39462593, JString, required = true,
                                   default = nil)
  if valid_39462593 != nil:
    section.add "repo", valid_39462593
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462594 = header.getOrDefault("Accept")
  valid_39462594 = validateParameter(valid_39462594, JString, required = false,
                                   default = nil)
  if valid_39462594 != nil:
    section.add "Accept", valid_39462594
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462595: Call_GetReposOwnerRepoReleases_39462589;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Users with push access to the repository will receive all releases (i.e., published releases and draft releases). Users with pull access will receive published releases only
  ## 
  let valid = call_39462595.validator(path, query, header, formData, body, _)
  let scheme = call_39462595.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462595.url(scheme.get, call_39462595.host, call_39462595.base,
                           call_39462595.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462595, uri, valid, _)

proc call*(call_39462596: Call_GetReposOwnerRepoReleases_39462589; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleases
  ## Users with push access to the repository will receive all releases (i.e., published releases and draft releases). Users with pull access will receive published releases only
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462597 = newJObject()
  var header_39462598 = newJObject()
  add(path_39462597, "owner", newJString(owner))
  add(header_39462598, "Accept", newJString(Accept))
  add(path_39462597, "repo", newJString(repo))
  result = call_39462596.call(path_39462597, nil, header_39462598, nil, nil)

var getReposOwnerRepoReleases* = Call_GetReposOwnerRepoReleases_39462589(
    name: "getReposOwnerRepoReleases", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases",
    validator: validate_GetReposOwnerRepoReleases_39462590, base: "/",
    url: url_GetReposOwnerRepoReleases_39462591, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleasesAssetsId_39462611 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoReleasesAssetsId_39462613(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/assets/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleasesAssetsId_39462612(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a single release asset
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462614 = path.getOrDefault("owner")
  valid_39462614 = validateParameter(valid_39462614, JString, required = true,
                                   default = nil)
  if valid_39462614 != nil:
    section.add "owner", valid_39462614
  var valid_39462615 = path.getOrDefault("id")
  valid_39462615 = validateParameter(valid_39462615, JString, required = true,
                                   default = nil)
  if valid_39462615 != nil:
    section.add "id", valid_39462615
  var valid_39462616 = path.getOrDefault("repo")
  valid_39462616 = validateParameter(valid_39462616, JString, required = true,
                                   default = nil)
  if valid_39462616 != nil:
    section.add "repo", valid_39462616
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462617 = header.getOrDefault("Accept")
  valid_39462617 = validateParameter(valid_39462617, JString, required = false,
                                   default = nil)
  if valid_39462617 != nil:
    section.add "Accept", valid_39462617
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462618: Call_GetReposOwnerRepoReleasesAssetsId_39462611;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single release asset
  ## 
  let valid = call_39462618.validator(path, query, header, formData, body, _)
  let scheme = call_39462618.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462618.url(scheme.get, call_39462618.host, call_39462618.base,
                           call_39462618.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462618, uri, valid, _)

proc call*(call_39462619: Call_GetReposOwnerRepoReleasesAssetsId_39462611;
          owner: string; id: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleasesAssetsId
  ## Get a single release asset
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462620 = newJObject()
  var header_39462621 = newJObject()
  add(path_39462620, "owner", newJString(owner))
  add(path_39462620, "id", newJString(id))
  add(header_39462621, "Accept", newJString(Accept))
  add(path_39462620, "repo", newJString(repo))
  result = call_39462619.call(path_39462620, nil, header_39462621, nil, nil)

var getReposOwnerRepoReleasesAssetsId* = Call_GetReposOwnerRepoReleasesAssetsId_39462611(
    name: "getReposOwnerRepoReleasesAssetsId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/assets/{id}",
    validator: validate_GetReposOwnerRepoReleasesAssetsId_39462612, base: "/",
    url: url_GetReposOwnerRepoReleasesAssetsId_39462613, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoReleasesAssetsId_39462633 = ref object of OpenApiRestCall_39460352
proc url_PatchReposOwnerRepoReleasesAssetsId_39462635(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/assets/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoReleasesAssetsId_39462634(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Edit a release asset
  ## Users with push access to the repository can edit a release asset.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462636 = path.getOrDefault("owner")
  valid_39462636 = validateParameter(valid_39462636, JString, required = true,
                                   default = nil)
  if valid_39462636 != nil:
    section.add "owner", valid_39462636
  var valid_39462637 = path.getOrDefault("id")
  valid_39462637 = validateParameter(valid_39462637, JString, required = true,
                                   default = nil)
  if valid_39462637 != nil:
    section.add "id", valid_39462637
  var valid_39462638 = path.getOrDefault("repo")
  valid_39462638 = validateParameter(valid_39462638, JString, required = true,
                                   default = nil)
  if valid_39462638 != nil:
    section.add "repo", valid_39462638
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462639 = header.getOrDefault("Accept")
  valid_39462639 = validateParameter(valid_39462639, JString, required = false,
                                   default = nil)
  if valid_39462639 != nil:
    section.add "Accept", valid_39462639
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39462641: Call_PatchReposOwnerRepoReleasesAssetsId_39462633;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit a release asset
  ## Users with push access to the repository can edit a release asset.
  ## 
  ## 
  let valid = call_39462641.validator(path, query, header, formData, body, _)
  let scheme = call_39462641.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462641.url(scheme.get, call_39462641.host, call_39462641.base,
                           call_39462641.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462641, uri, valid, _)

proc call*(call_39462642: Call_PatchReposOwnerRepoReleasesAssetsId_39462633;
          owner: string; id: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoReleasesAssetsId
  ## Edit a release asset
  ## Users with push access to the repository can edit a release asset.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462643 = newJObject()
  var header_39462644 = newJObject()
  var body_39462645 = newJObject()
  add(path_39462643, "owner", newJString(owner))
  add(path_39462643, "id", newJString(id))
  add(header_39462644, "Accept", newJString(Accept))
  if body != nil:
    body_39462645 = body
  add(path_39462643, "repo", newJString(repo))
  result = call_39462642.call(path_39462643, nil, header_39462644, nil, body_39462645)

var patchReposOwnerRepoReleasesAssetsId* = Call_PatchReposOwnerRepoReleasesAssetsId_39462633(
    name: "patchReposOwnerRepoReleasesAssetsId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/assets/{id}",
    validator: validate_PatchReposOwnerRepoReleasesAssetsId_39462634, base: "/",
    url: url_PatchReposOwnerRepoReleasesAssetsId_39462635, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoReleasesAssetsId_39462622 = ref object of OpenApiRestCall_39460352
proc url_DeleteReposOwnerRepoReleasesAssetsId_39462624(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/assets/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoReleasesAssetsId_39462623(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a release asset
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462625 = path.getOrDefault("owner")
  valid_39462625 = validateParameter(valid_39462625, JString, required = true,
                                   default = nil)
  if valid_39462625 != nil:
    section.add "owner", valid_39462625
  var valid_39462626 = path.getOrDefault("id")
  valid_39462626 = validateParameter(valid_39462626, JString, required = true,
                                   default = nil)
  if valid_39462626 != nil:
    section.add "id", valid_39462626
  var valid_39462627 = path.getOrDefault("repo")
  valid_39462627 = validateParameter(valid_39462627, JString, required = true,
                                   default = nil)
  if valid_39462627 != nil:
    section.add "repo", valid_39462627
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462628 = header.getOrDefault("Accept")
  valid_39462628 = validateParameter(valid_39462628, JString, required = false,
                                   default = nil)
  if valid_39462628 != nil:
    section.add "Accept", valid_39462628
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462629: Call_DeleteReposOwnerRepoReleasesAssetsId_39462622;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a release asset
  ## 
  let valid = call_39462629.validator(path, query, header, formData, body, _)
  let scheme = call_39462629.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462629.url(scheme.get, call_39462629.host, call_39462629.base,
                           call_39462629.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462629, uri, valid, _)

proc call*(call_39462630: Call_DeleteReposOwnerRepoReleasesAssetsId_39462622;
          owner: string; id: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoReleasesAssetsId
  ## Delete a release asset
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462631 = newJObject()
  var header_39462632 = newJObject()
  add(path_39462631, "owner", newJString(owner))
  add(path_39462631, "id", newJString(id))
  add(header_39462632, "Accept", newJString(Accept))
  add(path_39462631, "repo", newJString(repo))
  result = call_39462630.call(path_39462631, nil, header_39462632, nil, nil)

var deleteReposOwnerRepoReleasesAssetsId* = Call_DeleteReposOwnerRepoReleasesAssetsId_39462622(
    name: "deleteReposOwnerRepoReleasesAssetsId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/assets/{id}",
    validator: validate_DeleteReposOwnerRepoReleasesAssetsId_39462623, base: "/",
    url: url_DeleteReposOwnerRepoReleasesAssetsId_39462624,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleasesId_39462646 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoReleasesId_39462648(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleasesId_39462647(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get a single release
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462649 = path.getOrDefault("owner")
  valid_39462649 = validateParameter(valid_39462649, JString, required = true,
                                   default = nil)
  if valid_39462649 != nil:
    section.add "owner", valid_39462649
  var valid_39462650 = path.getOrDefault("id")
  valid_39462650 = validateParameter(valid_39462650, JString, required = true,
                                   default = nil)
  if valid_39462650 != nil:
    section.add "id", valid_39462650
  var valid_39462651 = path.getOrDefault("repo")
  valid_39462651 = validateParameter(valid_39462651, JString, required = true,
                                   default = nil)
  if valid_39462651 != nil:
    section.add "repo", valid_39462651
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462652 = header.getOrDefault("Accept")
  valid_39462652 = validateParameter(valid_39462652, JString, required = false,
                                   default = nil)
  if valid_39462652 != nil:
    section.add "Accept", valid_39462652
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462653: Call_GetReposOwnerRepoReleasesId_39462646;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single release
  ## 
  let valid = call_39462653.validator(path, query, header, formData, body, _)
  let scheme = call_39462653.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462653.url(scheme.get, call_39462653.host, call_39462653.base,
                           call_39462653.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462653, uri, valid, _)

proc call*(call_39462654: Call_GetReposOwnerRepoReleasesId_39462646; owner: string;
          id: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleasesId
  ## Get a single release
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462655 = newJObject()
  var header_39462656 = newJObject()
  add(path_39462655, "owner", newJString(owner))
  add(path_39462655, "id", newJString(id))
  add(header_39462656, "Accept", newJString(Accept))
  add(path_39462655, "repo", newJString(repo))
  result = call_39462654.call(path_39462655, nil, header_39462656, nil, nil)

var getReposOwnerRepoReleasesId* = Call_GetReposOwnerRepoReleasesId_39462646(
    name: "getReposOwnerRepoReleasesId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}",
    validator: validate_GetReposOwnerRepoReleasesId_39462647, base: "/",
    url: url_GetReposOwnerRepoReleasesId_39462648, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoReleasesId_39462668 = ref object of OpenApiRestCall_39460352
proc url_PatchReposOwnerRepoReleasesId_39462670(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoReleasesId_39462669(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Users with push access to the repository can edit a release
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462671 = path.getOrDefault("owner")
  valid_39462671 = validateParameter(valid_39462671, JString, required = true,
                                   default = nil)
  if valid_39462671 != nil:
    section.add "owner", valid_39462671
  var valid_39462672 = path.getOrDefault("id")
  valid_39462672 = validateParameter(valid_39462672, JString, required = true,
                                   default = nil)
  if valid_39462672 != nil:
    section.add "id", valid_39462672
  var valid_39462673 = path.getOrDefault("repo")
  valid_39462673 = validateParameter(valid_39462673, JString, required = true,
                                   default = nil)
  if valid_39462673 != nil:
    section.add "repo", valid_39462673
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462674 = header.getOrDefault("Accept")
  valid_39462674 = validateParameter(valid_39462674, JString, required = false,
                                   default = nil)
  if valid_39462674 != nil:
    section.add "Accept", valid_39462674
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39462676: Call_PatchReposOwnerRepoReleasesId_39462668;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Users with push access to the repository can edit a release
  ## 
  let valid = call_39462676.validator(path, query, header, formData, body, _)
  let scheme = call_39462676.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462676.url(scheme.get, call_39462676.host, call_39462676.base,
                           call_39462676.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462676, uri, valid, _)

proc call*(call_39462677: Call_PatchReposOwnerRepoReleasesId_39462668;
          owner: string; id: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoReleasesId
  ## Users with push access to the repository can edit a release
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462678 = newJObject()
  var header_39462679 = newJObject()
  var body_39462680 = newJObject()
  add(path_39462678, "owner", newJString(owner))
  add(path_39462678, "id", newJString(id))
  add(header_39462679, "Accept", newJString(Accept))
  if body != nil:
    body_39462680 = body
  add(path_39462678, "repo", newJString(repo))
  result = call_39462677.call(path_39462678, nil, header_39462679, nil, body_39462680)

var patchReposOwnerRepoReleasesId* = Call_PatchReposOwnerRepoReleasesId_39462668(
    name: "patchReposOwnerRepoReleasesId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}",
    validator: validate_PatchReposOwnerRepoReleasesId_39462669, base: "/",
    url: url_PatchReposOwnerRepoReleasesId_39462670, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoReleasesId_39462657 = ref object of OpenApiRestCall_39460352
proc url_DeleteReposOwnerRepoReleasesId_39462659(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoReleasesId_39462658(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Users with push access to the repository can delete a release.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462660 = path.getOrDefault("owner")
  valid_39462660 = validateParameter(valid_39462660, JString, required = true,
                                   default = nil)
  if valid_39462660 != nil:
    section.add "owner", valid_39462660
  var valid_39462661 = path.getOrDefault("id")
  valid_39462661 = validateParameter(valid_39462661, JString, required = true,
                                   default = nil)
  if valid_39462661 != nil:
    section.add "id", valid_39462661
  var valid_39462662 = path.getOrDefault("repo")
  valid_39462662 = validateParameter(valid_39462662, JString, required = true,
                                   default = nil)
  if valid_39462662 != nil:
    section.add "repo", valid_39462662
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462663 = header.getOrDefault("Accept")
  valid_39462663 = validateParameter(valid_39462663, JString, required = false,
                                   default = nil)
  if valid_39462663 != nil:
    section.add "Accept", valid_39462663
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462664: Call_DeleteReposOwnerRepoReleasesId_39462657;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Users with push access to the repository can delete a release.
  ## 
  let valid = call_39462664.validator(path, query, header, formData, body, _)
  let scheme = call_39462664.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462664.url(scheme.get, call_39462664.host, call_39462664.base,
                           call_39462664.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462664, uri, valid, _)

proc call*(call_39462665: Call_DeleteReposOwnerRepoReleasesId_39462657;
          owner: string; id: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoReleasesId
  ## Users with push access to the repository can delete a release.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462666 = newJObject()
  var header_39462667 = newJObject()
  add(path_39462666, "owner", newJString(owner))
  add(path_39462666, "id", newJString(id))
  add(header_39462667, "Accept", newJString(Accept))
  add(path_39462666, "repo", newJString(repo))
  result = call_39462665.call(path_39462666, nil, header_39462667, nil, nil)

var deleteReposOwnerRepoReleasesId* = Call_DeleteReposOwnerRepoReleasesId_39462657(
    name: "deleteReposOwnerRepoReleasesId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}",
    validator: validate_DeleteReposOwnerRepoReleasesId_39462658, base: "/",
    url: url_DeleteReposOwnerRepoReleasesId_39462659, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleasesIdAssets_39462681 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoReleasesIdAssets_39462683(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/assets")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleasesIdAssets_39462682(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List assets for a release
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462684 = path.getOrDefault("owner")
  valid_39462684 = validateParameter(valid_39462684, JString, required = true,
                                   default = nil)
  if valid_39462684 != nil:
    section.add "owner", valid_39462684
  var valid_39462685 = path.getOrDefault("id")
  valid_39462685 = validateParameter(valid_39462685, JString, required = true,
                                   default = nil)
  if valid_39462685 != nil:
    section.add "id", valid_39462685
  var valid_39462686 = path.getOrDefault("repo")
  valid_39462686 = validateParameter(valid_39462686, JString, required = true,
                                   default = nil)
  if valid_39462686 != nil:
    section.add "repo", valid_39462686
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462687 = header.getOrDefault("Accept")
  valid_39462687 = validateParameter(valid_39462687, JString, required = false,
                                   default = nil)
  if valid_39462687 != nil:
    section.add "Accept", valid_39462687
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462688: Call_GetReposOwnerRepoReleasesIdAssets_39462681;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List assets for a release
  ## 
  let valid = call_39462688.validator(path, query, header, formData, body, _)
  let scheme = call_39462688.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462688.url(scheme.get, call_39462688.host, call_39462688.base,
                           call_39462688.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462688, uri, valid, _)

proc call*(call_39462689: Call_GetReposOwnerRepoReleasesIdAssets_39462681;
          owner: string; id: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleasesIdAssets
  ## List assets for a release
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462690 = newJObject()
  var header_39462691 = newJObject()
  add(path_39462690, "owner", newJString(owner))
  add(path_39462690, "id", newJString(id))
  add(header_39462691, "Accept", newJString(Accept))
  add(path_39462690, "repo", newJString(repo))
  result = call_39462689.call(path_39462690, nil, header_39462691, nil, nil)

var getReposOwnerRepoReleasesIdAssets* = Call_GetReposOwnerRepoReleasesIdAssets_39462681(
    name: "getReposOwnerRepoReleasesIdAssets", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}/assets",
    validator: validate_GetReposOwnerRepoReleasesIdAssets_39462682, base: "/",
    url: url_GetReposOwnerRepoReleasesIdAssets_39462683, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStargazers_39462692 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoStargazers_39462694(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stargazers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStargazers_39462693(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List Stargazers.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462695 = path.getOrDefault("owner")
  valid_39462695 = validateParameter(valid_39462695, JString, required = true,
                                   default = nil)
  if valid_39462695 != nil:
    section.add "owner", valid_39462695
  var valid_39462696 = path.getOrDefault("repo")
  valid_39462696 = validateParameter(valid_39462696, JString, required = true,
                                   default = nil)
  if valid_39462696 != nil:
    section.add "repo", valid_39462696
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462697 = header.getOrDefault("Accept")
  valid_39462697 = validateParameter(valid_39462697, JString, required = false,
                                   default = nil)
  if valid_39462697 != nil:
    section.add "Accept", valid_39462697
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462698: Call_GetReposOwnerRepoStargazers_39462692;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List Stargazers.
  ## 
  let valid = call_39462698.validator(path, query, header, formData, body, _)
  let scheme = call_39462698.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462698.url(scheme.get, call_39462698.host, call_39462698.base,
                           call_39462698.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462698, uri, valid, _)

proc call*(call_39462699: Call_GetReposOwnerRepoStargazers_39462692; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStargazers
  ## List Stargazers.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462700 = newJObject()
  var header_39462701 = newJObject()
  add(path_39462700, "owner", newJString(owner))
  add(header_39462701, "Accept", newJString(Accept))
  add(path_39462700, "repo", newJString(repo))
  result = call_39462699.call(path_39462700, nil, header_39462701, nil, nil)

var getReposOwnerRepoStargazers* = Call_GetReposOwnerRepoStargazers_39462692(
    name: "getReposOwnerRepoStargazers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stargazers",
    validator: validate_GetReposOwnerRepoStargazers_39462693, base: "/",
    url: url_GetReposOwnerRepoStargazers_39462694, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsCodeFrequency_39462702 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoStatsCodeFrequency_39462704(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/code_frequency")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsCodeFrequency_39462703(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get the number of additions and deletions per week.
  ## Returns a weekly aggregate of the number of additions and deletions pushed
  ## to a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462705 = path.getOrDefault("owner")
  valid_39462705 = validateParameter(valid_39462705, JString, required = true,
                                   default = nil)
  if valid_39462705 != nil:
    section.add "owner", valid_39462705
  var valid_39462706 = path.getOrDefault("repo")
  valid_39462706 = validateParameter(valid_39462706, JString, required = true,
                                   default = nil)
  if valid_39462706 != nil:
    section.add "repo", valid_39462706
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462707 = header.getOrDefault("Accept")
  valid_39462707 = validateParameter(valid_39462707, JString, required = false,
                                   default = nil)
  if valid_39462707 != nil:
    section.add "Accept", valid_39462707
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462708: Call_GetReposOwnerRepoStatsCodeFrequency_39462702;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get the number of additions and deletions per week.
  ## Returns a weekly aggregate of the number of additions and deletions pushed
  ## to a repository.
  ## 
  ## 
  let valid = call_39462708.validator(path, query, header, formData, body, _)
  let scheme = call_39462708.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462708.url(scheme.get, call_39462708.host, call_39462708.base,
                           call_39462708.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462708, uri, valid, _)

proc call*(call_39462709: Call_GetReposOwnerRepoStatsCodeFrequency_39462702;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsCodeFrequency
  ## Get the number of additions and deletions per week.
  ## Returns a weekly aggregate of the number of additions and deletions pushed
  ## to a repository.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462710 = newJObject()
  var header_39462711 = newJObject()
  add(path_39462710, "owner", newJString(owner))
  add(header_39462711, "Accept", newJString(Accept))
  add(path_39462710, "repo", newJString(repo))
  result = call_39462709.call(path_39462710, nil, header_39462711, nil, nil)

var getReposOwnerRepoStatsCodeFrequency* = Call_GetReposOwnerRepoStatsCodeFrequency_39462702(
    name: "getReposOwnerRepoStatsCodeFrequency", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/code_frequency",
    validator: validate_GetReposOwnerRepoStatsCodeFrequency_39462703, base: "/",
    url: url_GetReposOwnerRepoStatsCodeFrequency_39462704, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsCommitActivity_39462712 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoStatsCommitActivity_39462714(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/commit_activity")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsCommitActivity_39462713(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get the last year of commit activity data.
  ## Returns the last year of commit activity grouped by week. The days array
  ## is a group of commits per day, starting on Sunday.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462715 = path.getOrDefault("owner")
  valid_39462715 = validateParameter(valid_39462715, JString, required = true,
                                   default = nil)
  if valid_39462715 != nil:
    section.add "owner", valid_39462715
  var valid_39462716 = path.getOrDefault("repo")
  valid_39462716 = validateParameter(valid_39462716, JString, required = true,
                                   default = nil)
  if valid_39462716 != nil:
    section.add "repo", valid_39462716
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462717 = header.getOrDefault("Accept")
  valid_39462717 = validateParameter(valid_39462717, JString, required = false,
                                   default = nil)
  if valid_39462717 != nil:
    section.add "Accept", valid_39462717
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462718: Call_GetReposOwnerRepoStatsCommitActivity_39462712;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get the last year of commit activity data.
  ## Returns the last year of commit activity grouped by week. The days array
  ## is a group of commits per day, starting on Sunday.
  ## 
  ## 
  let valid = call_39462718.validator(path, query, header, formData, body, _)
  let scheme = call_39462718.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462718.url(scheme.get, call_39462718.host, call_39462718.base,
                           call_39462718.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462718, uri, valid, _)

proc call*(call_39462719: Call_GetReposOwnerRepoStatsCommitActivity_39462712;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsCommitActivity
  ## Get the last year of commit activity data.
  ## Returns the last year of commit activity grouped by week. The days array
  ## is a group of commits per day, starting on Sunday.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462720 = newJObject()
  var header_39462721 = newJObject()
  add(path_39462720, "owner", newJString(owner))
  add(header_39462721, "Accept", newJString(Accept))
  add(path_39462720, "repo", newJString(repo))
  result = call_39462719.call(path_39462720, nil, header_39462721, nil, nil)

var getReposOwnerRepoStatsCommitActivity* = Call_GetReposOwnerRepoStatsCommitActivity_39462712(
    name: "getReposOwnerRepoStatsCommitActivity", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/commit_activity",
    validator: validate_GetReposOwnerRepoStatsCommitActivity_39462713, base: "/",
    url: url_GetReposOwnerRepoStatsCommitActivity_39462714,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsContributors_39462722 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoStatsContributors_39462724(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/contributors")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsContributors_39462723(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get contributors list with additions, deletions, and commit counts.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462725 = path.getOrDefault("owner")
  valid_39462725 = validateParameter(valid_39462725, JString, required = true,
                                   default = nil)
  if valid_39462725 != nil:
    section.add "owner", valid_39462725
  var valid_39462726 = path.getOrDefault("repo")
  valid_39462726 = validateParameter(valid_39462726, JString, required = true,
                                   default = nil)
  if valid_39462726 != nil:
    section.add "repo", valid_39462726
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462727 = header.getOrDefault("Accept")
  valid_39462727 = validateParameter(valid_39462727, JString, required = false,
                                   default = nil)
  if valid_39462727 != nil:
    section.add "Accept", valid_39462727
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462728: Call_GetReposOwnerRepoStatsContributors_39462722;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get contributors list with additions, deletions, and commit counts.
  ## 
  let valid = call_39462728.validator(path, query, header, formData, body, _)
  let scheme = call_39462728.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462728.url(scheme.get, call_39462728.host, call_39462728.base,
                           call_39462728.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462728, uri, valid, _)

proc call*(call_39462729: Call_GetReposOwnerRepoStatsContributors_39462722;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsContributors
  ## Get contributors list with additions, deletions, and commit counts.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462730 = newJObject()
  var header_39462731 = newJObject()
  add(path_39462730, "owner", newJString(owner))
  add(header_39462731, "Accept", newJString(Accept))
  add(path_39462730, "repo", newJString(repo))
  result = call_39462729.call(path_39462730, nil, header_39462731, nil, nil)

var getReposOwnerRepoStatsContributors* = Call_GetReposOwnerRepoStatsContributors_39462722(
    name: "getReposOwnerRepoStatsContributors", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/contributors",
    validator: validate_GetReposOwnerRepoStatsContributors_39462723, base: "/",
    url: url_GetReposOwnerRepoStatsContributors_39462724, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsParticipation_39462732 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoStatsParticipation_39462734(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/participation")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsParticipation_39462733(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get the weekly commit count for the repo owner and everyone else.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462735 = path.getOrDefault("owner")
  valid_39462735 = validateParameter(valid_39462735, JString, required = true,
                                   default = nil)
  if valid_39462735 != nil:
    section.add "owner", valid_39462735
  var valid_39462736 = path.getOrDefault("repo")
  valid_39462736 = validateParameter(valid_39462736, JString, required = true,
                                   default = nil)
  if valid_39462736 != nil:
    section.add "repo", valid_39462736
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462737 = header.getOrDefault("Accept")
  valid_39462737 = validateParameter(valid_39462737, JString, required = false,
                                   default = nil)
  if valid_39462737 != nil:
    section.add "Accept", valid_39462737
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462738: Call_GetReposOwnerRepoStatsParticipation_39462732;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get the weekly commit count for the repo owner and everyone else.
  ## 
  let valid = call_39462738.validator(path, query, header, formData, body, _)
  let scheme = call_39462738.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462738.url(scheme.get, call_39462738.host, call_39462738.base,
                           call_39462738.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462738, uri, valid, _)

proc call*(call_39462739: Call_GetReposOwnerRepoStatsParticipation_39462732;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsParticipation
  ## Get the weekly commit count for the repo owner and everyone else.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462740 = newJObject()
  var header_39462741 = newJObject()
  add(path_39462740, "owner", newJString(owner))
  add(header_39462741, "Accept", newJString(Accept))
  add(path_39462740, "repo", newJString(repo))
  result = call_39462739.call(path_39462740, nil, header_39462741, nil, nil)

var getReposOwnerRepoStatsParticipation* = Call_GetReposOwnerRepoStatsParticipation_39462732(
    name: "getReposOwnerRepoStatsParticipation", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/participation",
    validator: validate_GetReposOwnerRepoStatsParticipation_39462733, base: "/",
    url: url_GetReposOwnerRepoStatsParticipation_39462734, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsPunchCard_39462742 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoStatsPunchCard_39462744(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/punch_card")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsPunchCard_39462743(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get the number of commits per hour in each day.
  ## Each array contains the day number, hour number, and number of commits
  ## 0-6 Sunday - Saturday
  ## 0-23 Hour of day
  ## Number of commits
  ## 
  ## For example, [2, 14, 25] indicates that there were 25 total commits, during
  ## the 2.00pm hour on Tuesdays. All times are based on the time zone of
  ## individual commits.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462745 = path.getOrDefault("owner")
  valid_39462745 = validateParameter(valid_39462745, JString, required = true,
                                   default = nil)
  if valid_39462745 != nil:
    section.add "owner", valid_39462745
  var valid_39462746 = path.getOrDefault("repo")
  valid_39462746 = validateParameter(valid_39462746, JString, required = true,
                                   default = nil)
  if valid_39462746 != nil:
    section.add "repo", valid_39462746
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462747 = header.getOrDefault("Accept")
  valid_39462747 = validateParameter(valid_39462747, JString, required = false,
                                   default = nil)
  if valid_39462747 != nil:
    section.add "Accept", valid_39462747
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462748: Call_GetReposOwnerRepoStatsPunchCard_39462742;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get the number of commits per hour in each day.
  ## Each array contains the day number, hour number, and number of commits
  ## 0-6 Sunday - Saturday
  ## 0-23 Hour of day
  ## Number of commits
  ## 
  ## For example, [2, 14, 25] indicates that there were 25 total commits, during
  ## the 2.00pm hour on Tuesdays. All times are based on the time zone of
  ## individual commits.
  ## 
  ## 
  let valid = call_39462748.validator(path, query, header, formData, body, _)
  let scheme = call_39462748.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462748.url(scheme.get, call_39462748.host, call_39462748.base,
                           call_39462748.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462748, uri, valid, _)

proc call*(call_39462749: Call_GetReposOwnerRepoStatsPunchCard_39462742;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsPunchCard
  ## Get the number of commits per hour in each day.
  ## Each array contains the day number, hour number, and number of commits
  ## 0-6 Sunday - Saturday
  ## 0-23 Hour of day
  ## Number of commits
  ## 
  ## For example, [2, 14, 25] indicates that there were 25 total commits, during
  ## the 2.00pm hour on Tuesdays. All times are based on the time zone of
  ## individual commits.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462750 = newJObject()
  var header_39462751 = newJObject()
  add(path_39462750, "owner", newJString(owner))
  add(header_39462751, "Accept", newJString(Accept))
  add(path_39462750, "repo", newJString(repo))
  result = call_39462749.call(path_39462750, nil, header_39462751, nil, nil)

var getReposOwnerRepoStatsPunchCard* = Call_GetReposOwnerRepoStatsPunchCard_39462742(
    name: "getReposOwnerRepoStatsPunchCard", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/punch_card",
    validator: validate_GetReposOwnerRepoStatsPunchCard_39462743, base: "/",
    url: url_GetReposOwnerRepoStatsPunchCard_39462744, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoStatusesRef_39462763 = ref object of OpenApiRestCall_39460352
proc url_PostReposOwnerRepoStatusesRef_39462765(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/statuses/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoStatusesRef_39462764(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Create a Status.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   ref: JString (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462766 = path.getOrDefault("owner")
  valid_39462766 = validateParameter(valid_39462766, JString, required = true,
                                   default = nil)
  if valid_39462766 != nil:
    section.add "owner", valid_39462766
  var valid_39462767 = path.getOrDefault("ref")
  valid_39462767 = validateParameter(valid_39462767, JString, required = true,
                                   default = nil)
  if valid_39462767 != nil:
    section.add "ref", valid_39462767
  var valid_39462768 = path.getOrDefault("repo")
  valid_39462768 = validateParameter(valid_39462768, JString, required = true,
                                   default = nil)
  if valid_39462768 != nil:
    section.add "repo", valid_39462768
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462769 = header.getOrDefault("Accept")
  valid_39462769 = validateParameter(valid_39462769, JString, required = false,
                                   default = nil)
  if valid_39462769 != nil:
    section.add "Accept", valid_39462769
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39462771: Call_PostReposOwnerRepoStatusesRef_39462763;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a Status.
  ## 
  let valid = call_39462771.validator(path, query, header, formData, body, _)
  let scheme = call_39462771.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462771.url(scheme.get, call_39462771.host, call_39462771.base,
                           call_39462771.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462771, uri, valid, _)

proc call*(call_39462772: Call_PostReposOwnerRepoStatusesRef_39462763;
          owner: string; `ref`: string; body: JsonNode; repo: string;
          Accept: string = ""): Recallable =
  ## postReposOwnerRepoStatusesRef
  ## Create a Status.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   ref: string (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462773 = newJObject()
  var header_39462774 = newJObject()
  var body_39462775 = newJObject()
  add(path_39462773, "owner", newJString(owner))
  add(path_39462773, "ref", newJString(`ref`))
  add(header_39462774, "Accept", newJString(Accept))
  if body != nil:
    body_39462775 = body
  add(path_39462773, "repo", newJString(repo))
  result = call_39462772.call(path_39462773, nil, header_39462774, nil, body_39462775)

var postReposOwnerRepoStatusesRef* = Call_PostReposOwnerRepoStatusesRef_39462763(
    name: "postReposOwnerRepoStatusesRef", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/statuses/{ref}",
    validator: validate_PostReposOwnerRepoStatusesRef_39462764, base: "/",
    url: url_PostReposOwnerRepoStatusesRef_39462765, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatusesRef_39462752 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoStatusesRef_39462754(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/statuses/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatusesRef_39462753(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List Statuses for a specific Ref.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   ref: JString (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462755 = path.getOrDefault("owner")
  valid_39462755 = validateParameter(valid_39462755, JString, required = true,
                                   default = nil)
  if valid_39462755 != nil:
    section.add "owner", valid_39462755
  var valid_39462756 = path.getOrDefault("ref")
  valid_39462756 = validateParameter(valid_39462756, JString, required = true,
                                   default = nil)
  if valid_39462756 != nil:
    section.add "ref", valid_39462756
  var valid_39462757 = path.getOrDefault("repo")
  valid_39462757 = validateParameter(valid_39462757, JString, required = true,
                                   default = nil)
  if valid_39462757 != nil:
    section.add "repo", valid_39462757
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462758 = header.getOrDefault("Accept")
  valid_39462758 = validateParameter(valid_39462758, JString, required = false,
                                   default = nil)
  if valid_39462758 != nil:
    section.add "Accept", valid_39462758
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462759: Call_GetReposOwnerRepoStatusesRef_39462752;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List Statuses for a specific Ref.
  ## 
  let valid = call_39462759.validator(path, query, header, formData, body, _)
  let scheme = call_39462759.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462759.url(scheme.get, call_39462759.host, call_39462759.base,
                           call_39462759.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462759, uri, valid, _)

proc call*(call_39462760: Call_GetReposOwnerRepoStatusesRef_39462752;
          owner: string; `ref`: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatusesRef
  ## List Statuses for a specific Ref.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   ref: string (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462761 = newJObject()
  var header_39462762 = newJObject()
  add(path_39462761, "owner", newJString(owner))
  add(path_39462761, "ref", newJString(`ref`))
  add(header_39462762, "Accept", newJString(Accept))
  add(path_39462761, "repo", newJString(repo))
  result = call_39462760.call(path_39462761, nil, header_39462762, nil, nil)

var getReposOwnerRepoStatusesRef* = Call_GetReposOwnerRepoStatusesRef_39462752(
    name: "getReposOwnerRepoStatusesRef", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/statuses/{ref}",
    validator: validate_GetReposOwnerRepoStatusesRef_39462753, base: "/",
    url: url_GetReposOwnerRepoStatusesRef_39462754, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoSubscribers_39462776 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoSubscribers_39462778(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/subscribers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoSubscribers_39462777(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List watchers.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462779 = path.getOrDefault("owner")
  valid_39462779 = validateParameter(valid_39462779, JString, required = true,
                                   default = nil)
  if valid_39462779 != nil:
    section.add "owner", valid_39462779
  var valid_39462780 = path.getOrDefault("repo")
  valid_39462780 = validateParameter(valid_39462780, JString, required = true,
                                   default = nil)
  if valid_39462780 != nil:
    section.add "repo", valid_39462780
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462781 = header.getOrDefault("Accept")
  valid_39462781 = validateParameter(valid_39462781, JString, required = false,
                                   default = nil)
  if valid_39462781 != nil:
    section.add "Accept", valid_39462781
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462782: Call_GetReposOwnerRepoSubscribers_39462776;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List watchers.
  ## 
  let valid = call_39462782.validator(path, query, header, formData, body, _)
  let scheme = call_39462782.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462782.url(scheme.get, call_39462782.host, call_39462782.base,
                           call_39462782.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462782, uri, valid, _)

proc call*(call_39462783: Call_GetReposOwnerRepoSubscribers_39462776;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoSubscribers
  ## List watchers.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462784 = newJObject()
  var header_39462785 = newJObject()
  add(path_39462784, "owner", newJString(owner))
  add(header_39462785, "Accept", newJString(Accept))
  add(path_39462784, "repo", newJString(repo))
  result = call_39462783.call(path_39462784, nil, header_39462785, nil, nil)

var getReposOwnerRepoSubscribers* = Call_GetReposOwnerRepoSubscribers_39462776(
    name: "getReposOwnerRepoSubscribers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscribers",
    validator: validate_GetReposOwnerRepoSubscribers_39462777, base: "/",
    url: url_GetReposOwnerRepoSubscribers_39462778, schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoSubscription_39462796 = ref object of OpenApiRestCall_39460352
proc url_PutReposOwnerRepoSubscription_39462798(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoSubscription_39462797(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Set a Repository Subscription
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462799 = path.getOrDefault("owner")
  valid_39462799 = validateParameter(valid_39462799, JString, required = true,
                                   default = nil)
  if valid_39462799 != nil:
    section.add "owner", valid_39462799
  var valid_39462800 = path.getOrDefault("repo")
  valid_39462800 = validateParameter(valid_39462800, JString, required = true,
                                   default = nil)
  if valid_39462800 != nil:
    section.add "repo", valid_39462800
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462801 = header.getOrDefault("Accept")
  valid_39462801 = validateParameter(valid_39462801, JString, required = false,
                                   default = nil)
  if valid_39462801 != nil:
    section.add "Accept", valid_39462801
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39462803: Call_PutReposOwnerRepoSubscription_39462796;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Set a Repository Subscription
  ## 
  let valid = call_39462803.validator(path, query, header, formData, body, _)
  let scheme = call_39462803.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462803.url(scheme.get, call_39462803.host, call_39462803.base,
                           call_39462803.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462803, uri, valid, _)

proc call*(call_39462804: Call_PutReposOwnerRepoSubscription_39462796;
          owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoSubscription
  ## Set a Repository Subscription
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462805 = newJObject()
  var header_39462806 = newJObject()
  var body_39462807 = newJObject()
  add(path_39462805, "owner", newJString(owner))
  add(header_39462806, "Accept", newJString(Accept))
  if body != nil:
    body_39462807 = body
  add(path_39462805, "repo", newJString(repo))
  result = call_39462804.call(path_39462805, nil, header_39462806, nil, body_39462807)

var putReposOwnerRepoSubscription* = Call_PutReposOwnerRepoSubscription_39462796(
    name: "putReposOwnerRepoSubscription", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscription",
    validator: validate_PutReposOwnerRepoSubscription_39462797, base: "/",
    url: url_PutReposOwnerRepoSubscription_39462798, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoSubscription_39462786 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoSubscription_39462788(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoSubscription_39462787(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a Repository Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462789 = path.getOrDefault("owner")
  valid_39462789 = validateParameter(valid_39462789, JString, required = true,
                                   default = nil)
  if valid_39462789 != nil:
    section.add "owner", valid_39462789
  var valid_39462790 = path.getOrDefault("repo")
  valid_39462790 = validateParameter(valid_39462790, JString, required = true,
                                   default = nil)
  if valid_39462790 != nil:
    section.add "repo", valid_39462790
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462791 = header.getOrDefault("Accept")
  valid_39462791 = validateParameter(valid_39462791, JString, required = false,
                                   default = nil)
  if valid_39462791 != nil:
    section.add "Accept", valid_39462791
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462792: Call_GetReposOwnerRepoSubscription_39462786;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a Repository Subscription.
  ## 
  let valid = call_39462792.validator(path, query, header, formData, body, _)
  let scheme = call_39462792.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462792.url(scheme.get, call_39462792.host, call_39462792.base,
                           call_39462792.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462792, uri, valid, _)

proc call*(call_39462793: Call_GetReposOwnerRepoSubscription_39462786;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoSubscription
  ## Get a Repository Subscription.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462794 = newJObject()
  var header_39462795 = newJObject()
  add(path_39462794, "owner", newJString(owner))
  add(header_39462795, "Accept", newJString(Accept))
  add(path_39462794, "repo", newJString(repo))
  result = call_39462793.call(path_39462794, nil, header_39462795, nil, nil)

var getReposOwnerRepoSubscription* = Call_GetReposOwnerRepoSubscription_39462786(
    name: "getReposOwnerRepoSubscription", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscription",
    validator: validate_GetReposOwnerRepoSubscription_39462787, base: "/",
    url: url_GetReposOwnerRepoSubscription_39462788, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoSubscription_39462808 = ref object of OpenApiRestCall_39460352
proc url_DeleteReposOwnerRepoSubscription_39462810(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoSubscription_39462809(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a Repository Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462811 = path.getOrDefault("owner")
  valid_39462811 = validateParameter(valid_39462811, JString, required = true,
                                   default = nil)
  if valid_39462811 != nil:
    section.add "owner", valid_39462811
  var valid_39462812 = path.getOrDefault("repo")
  valid_39462812 = validateParameter(valid_39462812, JString, required = true,
                                   default = nil)
  if valid_39462812 != nil:
    section.add "repo", valid_39462812
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462813 = header.getOrDefault("Accept")
  valid_39462813 = validateParameter(valid_39462813, JString, required = false,
                                   default = nil)
  if valid_39462813 != nil:
    section.add "Accept", valid_39462813
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462814: Call_DeleteReposOwnerRepoSubscription_39462808;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a Repository Subscription.
  ## 
  let valid = call_39462814.validator(path, query, header, formData, body, _)
  let scheme = call_39462814.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462814.url(scheme.get, call_39462814.host, call_39462814.base,
                           call_39462814.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462814, uri, valid, _)

proc call*(call_39462815: Call_DeleteReposOwnerRepoSubscription_39462808;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoSubscription
  ## Delete a Repository Subscription.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462816 = newJObject()
  var header_39462817 = newJObject()
  add(path_39462816, "owner", newJString(owner))
  add(header_39462817, "Accept", newJString(Accept))
  add(path_39462816, "repo", newJString(repo))
  result = call_39462815.call(path_39462816, nil, header_39462817, nil, nil)

var deleteReposOwnerRepoSubscription* = Call_DeleteReposOwnerRepoSubscription_39462808(
    name: "deleteReposOwnerRepoSubscription", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscription",
    validator: validate_DeleteReposOwnerRepoSubscription_39462809, base: "/",
    url: url_DeleteReposOwnerRepoSubscription_39462810, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoTags_39462818 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoTags_39462820(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/tags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoTags_39462819(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get list of tags.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462821 = path.getOrDefault("owner")
  valid_39462821 = validateParameter(valid_39462821, JString, required = true,
                                   default = nil)
  if valid_39462821 != nil:
    section.add "owner", valid_39462821
  var valid_39462822 = path.getOrDefault("repo")
  valid_39462822 = validateParameter(valid_39462822, JString, required = true,
                                   default = nil)
  if valid_39462822 != nil:
    section.add "repo", valid_39462822
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462823 = header.getOrDefault("Accept")
  valid_39462823 = validateParameter(valid_39462823, JString, required = false,
                                   default = nil)
  if valid_39462823 != nil:
    section.add "Accept", valid_39462823
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462824: Call_GetReposOwnerRepoTags_39462818;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get list of tags.
  ## 
  let valid = call_39462824.validator(path, query, header, formData, body, _)
  let scheme = call_39462824.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462824.url(scheme.get, call_39462824.host, call_39462824.base,
                           call_39462824.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462824, uri, valid, _)

proc call*(call_39462825: Call_GetReposOwnerRepoTags_39462818; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoTags
  ## Get list of tags.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462826 = newJObject()
  var header_39462827 = newJObject()
  add(path_39462826, "owner", newJString(owner))
  add(header_39462827, "Accept", newJString(Accept))
  add(path_39462826, "repo", newJString(repo))
  result = call_39462825.call(path_39462826, nil, header_39462827, nil, nil)

var getReposOwnerRepoTags* = Call_GetReposOwnerRepoTags_39462818(
    name: "getReposOwnerRepoTags", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/repos/{owner}/{repo}/tags",
    validator: validate_GetReposOwnerRepoTags_39462819, base: "/",
    url: url_GetReposOwnerRepoTags_39462820, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoTeams_39462828 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoTeams_39462830(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/teams")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoTeams_39462829(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get list of teams
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462831 = path.getOrDefault("owner")
  valid_39462831 = validateParameter(valid_39462831, JString, required = true,
                                   default = nil)
  if valid_39462831 != nil:
    section.add "owner", valid_39462831
  var valid_39462832 = path.getOrDefault("repo")
  valid_39462832 = validateParameter(valid_39462832, JString, required = true,
                                   default = nil)
  if valid_39462832 != nil:
    section.add "repo", valid_39462832
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462833 = header.getOrDefault("Accept")
  valid_39462833 = validateParameter(valid_39462833, JString, required = false,
                                   default = nil)
  if valid_39462833 != nil:
    section.add "Accept", valid_39462833
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462834: Call_GetReposOwnerRepoTeams_39462828;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get list of teams
  ## 
  let valid = call_39462834.validator(path, query, header, formData, body, _)
  let scheme = call_39462834.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462834.url(scheme.get, call_39462834.host, call_39462834.base,
                           call_39462834.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462834, uri, valid, _)

proc call*(call_39462835: Call_GetReposOwnerRepoTeams_39462828; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoTeams
  ## Get list of teams
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462836 = newJObject()
  var header_39462837 = newJObject()
  add(path_39462836, "owner", newJString(owner))
  add(header_39462837, "Accept", newJString(Accept))
  add(path_39462836, "repo", newJString(repo))
  result = call_39462835.call(path_39462836, nil, header_39462837, nil, nil)

var getReposOwnerRepoTeams* = Call_GetReposOwnerRepoTeams_39462828(
    name: "getReposOwnerRepoTeams", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/teams",
    validator: validate_GetReposOwnerRepoTeams_39462829, base: "/",
    url: url_GetReposOwnerRepoTeams_39462830, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoWatchers_39462838 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoWatchers_39462840(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/watchers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoWatchers_39462839(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List Stargazers. New implementation.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462841 = path.getOrDefault("owner")
  valid_39462841 = validateParameter(valid_39462841, JString, required = true,
                                   default = nil)
  if valid_39462841 != nil:
    section.add "owner", valid_39462841
  var valid_39462842 = path.getOrDefault("repo")
  valid_39462842 = validateParameter(valid_39462842, JString, required = true,
                                   default = nil)
  if valid_39462842 != nil:
    section.add "repo", valid_39462842
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462843 = header.getOrDefault("Accept")
  valid_39462843 = validateParameter(valid_39462843, JString, required = false,
                                   default = nil)
  if valid_39462843 != nil:
    section.add "Accept", valid_39462843
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462844: Call_GetReposOwnerRepoWatchers_39462838;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List Stargazers. New implementation.
  ## 
  let valid = call_39462844.validator(path, query, header, formData, body, _)
  let scheme = call_39462844.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462844.url(scheme.get, call_39462844.host, call_39462844.base,
                           call_39462844.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462844, uri, valid, _)

proc call*(call_39462845: Call_GetReposOwnerRepoWatchers_39462838; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoWatchers
  ## List Stargazers. New implementation.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39462846 = newJObject()
  var header_39462847 = newJObject()
  add(path_39462846, "owner", newJString(owner))
  add(header_39462847, "Accept", newJString(Accept))
  add(path_39462846, "repo", newJString(repo))
  result = call_39462845.call(path_39462846, nil, header_39462847, nil, nil)

var getReposOwnerRepoWatchers* = Call_GetReposOwnerRepoWatchers_39462838(
    name: "getReposOwnerRepoWatchers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/watchers",
    validator: validate_GetReposOwnerRepoWatchers_39462839, base: "/",
    url: url_GetReposOwnerRepoWatchers_39462840, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoArchiveFormatPath_39462848 = ref object of OpenApiRestCall_39460352
proc url_GetReposOwnerRepoArchiveFormatPath_39462850(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "archive_format" in path, "`archive_format` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "archive_format"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoArchiveFormatPath_39462849(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get archive link.
  ## This method will return a 302 to a URL to download a tarball or zipball
  ## archive for a repository. Please make sure your HTTP framework is
  ## configured to follow redirects or you will need to use the Location header
  ## to make a second GET request.
  ## Note: For private repositories, these links are temporary and expire quickly.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   archive_format: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   path: JString (required)
  ##       : Valid Git reference, defaults to 'master'.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39462851 = path.getOrDefault("owner")
  valid_39462851 = validateParameter(valid_39462851, JString, required = true,
                                   default = nil)
  if valid_39462851 != nil:
    section.add "owner", valid_39462851
  var valid_39462852 = path.getOrDefault("archive_format")
  valid_39462852 = validateParameter(valid_39462852, JString, required = true,
                                   default = newJString("tarball"))
  if valid_39462852 != nil:
    section.add "archive_format", valid_39462852
  var valid_39462853 = path.getOrDefault("repo")
  valid_39462853 = validateParameter(valid_39462853, JString, required = true,
                                   default = nil)
  if valid_39462853 != nil:
    section.add "repo", valid_39462853
  var valid_39462854 = path.getOrDefault("path")
  valid_39462854 = validateParameter(valid_39462854, JString, required = true,
                                   default = nil)
  if valid_39462854 != nil:
    section.add "path", valid_39462854
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462855 = header.getOrDefault("Accept")
  valid_39462855 = validateParameter(valid_39462855, JString, required = false,
                                   default = nil)
  if valid_39462855 != nil:
    section.add "Accept", valid_39462855
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462856: Call_GetReposOwnerRepoArchiveFormatPath_39462848;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get archive link.
  ## This method will return a 302 to a URL to download a tarball or zipball
  ## archive for a repository. Please make sure your HTTP framework is
  ## configured to follow redirects or you will need to use the Location header
  ## to make a second GET request.
  ## Note: For private repositories, these links are temporary and expire quickly.
  ## 
  ## 
  let valid = call_39462856.validator(path, query, header, formData, body, _)
  let scheme = call_39462856.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462856.url(scheme.get, call_39462856.host, call_39462856.base,
                           call_39462856.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462856, uri, valid, _)

proc call*(call_39462857: Call_GetReposOwnerRepoArchiveFormatPath_39462848;
          owner: string; repo: string; path: string;
          archiveFormat: string = "tarball"; Accept: string = ""): Recallable =
  ## getReposOwnerRepoArchiveFormatPath
  ## Get archive link.
  ## This method will return a 302 to a URL to download a tarball or zipball
  ## archive for a repository. Please make sure your HTTP framework is
  ## configured to follow redirects or you will need to use the Location header
  ## to make a second GET request.
  ## Note: For private repositories, these links are temporary and expire quickly.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   archiveFormat: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   path: string (required)
  ##       : Valid Git reference, defaults to 'master'.
  var path_39462858 = newJObject()
  var header_39462859 = newJObject()
  add(path_39462858, "owner", newJString(owner))
  add(path_39462858, "archive_format", newJString(archiveFormat))
  add(header_39462859, "Accept", newJString(Accept))
  add(path_39462858, "repo", newJString(repo))
  add(path_39462858, "path", newJString(path))
  result = call_39462857.call(path_39462858, nil, header_39462859, nil, nil)

var getReposOwnerRepoArchiveFormatPath* = Call_GetReposOwnerRepoArchiveFormatPath_39462848(
    name: "getReposOwnerRepoArchiveFormatPath", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/{archive_format}/{path}",
    validator: validate_GetReposOwnerRepoArchiveFormatPath_39462849, base: "/",
    url: url_GetReposOwnerRepoArchiveFormatPath_39462850, schemes: {Scheme.Https})
type
  Call_GetRepositories_39462860 = ref object of OpenApiRestCall_39460352
proc url_GetRepositories_39462862(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRepositories_39462861(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List all public repositories.
  ## This provides a dump of every public repository, in the order that they
  ## were created.
  ## Note: Pagination is powered exclusively by the since parameter. is the
  ## Link header to get the URL for the next page of repositories.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_39462863 = query.getOrDefault("since")
  valid_39462863 = validateParameter(valid_39462863, JString, required = false,
                                   default = nil)
  if valid_39462863 != nil:
    section.add "since", valid_39462863
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462864 = header.getOrDefault("Accept")
  valid_39462864 = validateParameter(valid_39462864, JString, required = false,
                                   default = nil)
  if valid_39462864 != nil:
    section.add "Accept", valid_39462864
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462865: Call_GetRepositories_39462860; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List all public repositories.
  ## This provides a dump of every public repository, in the order that they
  ## were created.
  ## Note: Pagination is powered exclusively by the since parameter. is the
  ## Link header to get the URL for the next page of repositories.
  ## 
  ## 
  let valid = call_39462865.validator(path, query, header, formData, body, _)
  let scheme = call_39462865.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462865.url(scheme.get, call_39462865.host, call_39462865.base,
                           call_39462865.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462865, uri, valid, _)

proc call*(call_39462866: Call_GetRepositories_39462860; Accept: string = "";
          since: string = ""): Recallable =
  ## getRepositories
  ## List all public repositories.
  ## This provides a dump of every public repository, in the order that they
  ## were created.
  ## Note: Pagination is powered exclusively by the since parameter. is the
  ## Link header to get the URL for the next page of repositories.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var query_39462867 = newJObject()
  var header_39462868 = newJObject()
  add(header_39462868, "Accept", newJString(Accept))
  add(query_39462867, "since", newJString(since))
  result = call_39462866.call(nil, query_39462867, header_39462868, nil, nil)

var getRepositories* = Call_GetRepositories_39462860(name: "getRepositories",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/repositories",
    validator: validate_GetRepositories_39462861, base: "/",
    url: url_GetRepositories_39462862, schemes: {Scheme.Https})
type
  Call_GetSearchCode_39462869 = ref object of OpenApiRestCall_39460352
proc url_GetSearchCode_39462871(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchCode_39462870(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## Search code.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   sort: JString
  ##       : Can only be 'indexed', which indicates how recently a file has been indexed
  ## by the GitHub search infrastructure. If not provided, results are sorted
  ## by best match.
  ## 
  ##   q: JString (required)
  ##    : The search terms. This can be any combination of the supported code
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier
  ## you can restrict the search to just the file contents, the file path,
  ## or both.
  ## 'Languages' Searches code based on the language it's written in.
  ## 'Forks' Filters repositories based on the number of forks, and/or
  ## whether code from forked repositories should be included in the results
  ## at all.
  ## 'Size' Finds files that match a certain size (in bytes).
  ## 'Path' Specifies the path that the resulting file must be at.
  ## 'Extension' Matches files with a certain extension.
  ## 'Users' or 'Repositories' Limits searches to a specific user or repository.
  ## 
  section = newJObject()
  var valid_39462872 = query.getOrDefault("order")
  valid_39462872 = validateParameter(valid_39462872, JString, required = false,
                                   default = newJString("desc"))
  if valid_39462872 != nil:
    section.add "order", valid_39462872
  var valid_39462873 = query.getOrDefault("sort")
  valid_39462873 = validateParameter(valid_39462873, JString, required = false,
                                   default = newJString("indexed"))
  if valid_39462873 != nil:
    section.add "sort", valid_39462873
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_39462874 = query.getOrDefault("q")
  valid_39462874 = validateParameter(valid_39462874, JString, required = true,
                                   default = nil)
  if valid_39462874 != nil:
    section.add "q", valid_39462874
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462875 = header.getOrDefault("Accept")
  valid_39462875 = validateParameter(valid_39462875, JString, required = false,
                                   default = nil)
  if valid_39462875 != nil:
    section.add "Accept", valid_39462875
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462876: Call_GetSearchCode_39462869; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Search code.
  ## 
  let valid = call_39462876.validator(path, query, header, formData, body, _)
  let scheme = call_39462876.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462876.url(scheme.get, call_39462876.host, call_39462876.base,
                           call_39462876.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462876, uri, valid, _)

proc call*(call_39462877: Call_GetSearchCode_39462869; q: string;
          order: string = "desc"; Accept: string = ""; sort: string = "indexed"): Recallable =
  ## getSearchCode
  ## Search code.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##       : Can only be 'indexed', which indicates how recently a file has been indexed
  ## by the GitHub search infrastructure. If not provided, results are sorted
  ## by best match.
  ## 
  ##   q: string (required)
  ##    : The search terms. This can be any combination of the supported code
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier
  ## you can restrict the search to just the file contents, the file path,
  ## or both.
  ## 'Languages' Searches code based on the language it's written in.
  ## 'Forks' Filters repositories based on the number of forks, and/or
  ## whether code from forked repositories should be included in the results
  ## at all.
  ## 'Size' Finds files that match a certain size (in bytes).
  ## 'Path' Specifies the path that the resulting file must be at.
  ## 'Extension' Matches files with a certain extension.
  ## 'Users' or 'Repositories' Limits searches to a specific user or repository.
  ## 
  var query_39462878 = newJObject()
  var header_39462879 = newJObject()
  add(query_39462878, "order", newJString(order))
  add(header_39462879, "Accept", newJString(Accept))
  add(query_39462878, "sort", newJString(sort))
  add(query_39462878, "q", newJString(q))
  result = call_39462877.call(nil, query_39462878, header_39462879, nil, nil)

var getSearchCode* = Call_GetSearchCode_39462869(name: "getSearchCode",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/search/code",
    validator: validate_GetSearchCode_39462870, base: "/", url: url_GetSearchCode_39462871,
    schemes: {Scheme.Https})
type
  Call_GetSearchIssues_39462880 = ref object of OpenApiRestCall_39460352
proc url_GetSearchIssues_39462882(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchIssues_39462881(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Find issues by state and keyword. (This method returns up to 100 results per page.)
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   sort: JString
  ##       : The sort field. Can be comments, created, or updated. Default: results are sorted by best match.
  ##   q: JString (required)
  ##    : The q search term can also contain any combination of the supported issue search qualifiers:
  section = newJObject()
  var valid_39462883 = query.getOrDefault("order")
  valid_39462883 = validateParameter(valid_39462883, JString, required = false,
                                   default = newJString("desc"))
  if valid_39462883 != nil:
    section.add "order", valid_39462883
  var valid_39462884 = query.getOrDefault("sort")
  valid_39462884 = validateParameter(valid_39462884, JString, required = false,
                                   default = newJString("updated"))
  if valid_39462884 != nil:
    section.add "sort", valid_39462884
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_39462885 = query.getOrDefault("q")
  valid_39462885 = validateParameter(valid_39462885, JString, required = true,
                                   default = nil)
  if valid_39462885 != nil:
    section.add "q", valid_39462885
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462886 = header.getOrDefault("Accept")
  valid_39462886 = validateParameter(valid_39462886, JString, required = false,
                                   default = nil)
  if valid_39462886 != nil:
    section.add "Accept", valid_39462886
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462887: Call_GetSearchIssues_39462880; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Find issues by state and keyword. (This method returns up to 100 results per page.)
  ## 
  let valid = call_39462887.validator(path, query, header, formData, body, _)
  let scheme = call_39462887.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462887.url(scheme.get, call_39462887.host, call_39462887.base,
                           call_39462887.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462887, uri, valid, _)

proc call*(call_39462888: Call_GetSearchIssues_39462880; q: string;
          order: string = "desc"; Accept: string = ""; sort: string = "updated"): Recallable =
  ## getSearchIssues
  ## Find issues by state and keyword. (This method returns up to 100 results per page.)
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##       : The sort field. Can be comments, created, or updated. Default: results are sorted by best match.
  ##   q: string (required)
  ##    : The q search term can also contain any combination of the supported issue search qualifiers:
  var query_39462889 = newJObject()
  var header_39462890 = newJObject()
  add(query_39462889, "order", newJString(order))
  add(header_39462890, "Accept", newJString(Accept))
  add(query_39462889, "sort", newJString(sort))
  add(query_39462889, "q", newJString(q))
  result = call_39462888.call(nil, query_39462889, header_39462890, nil, nil)

var getSearchIssues* = Call_GetSearchIssues_39462880(name: "getSearchIssues",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/search/issues",
    validator: validate_GetSearchIssues_39462881, base: "/",
    url: url_GetSearchIssues_39462882, schemes: {Scheme.Https})
type
  Call_GetSearchRepositories_39462891 = ref object of OpenApiRestCall_39460352
proc url_GetSearchRepositories_39462893(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchRepositories_39462892(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Search repositories.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   sort: JString
  ##       : If not provided, results are sorted by best match.
  ##   q: JString (required)
  ##    : The search terms. This can be any combination of the supported repository
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the repository name, description, readme,
  ## or any combination of these.
  ## 'Size' Finds repositories that match a certain size (in kilobytes).
  ## 'Forks' Filters repositories based on the number of forks, and/or whether
  ## forked repositories should be included in the results at all.
  ## 'Created' and 'Last Updated' Filters repositories based on times of
  ## creation, or when they were last updated.
  ## 'Users or Repositories' Limits searches to a specific user or repository.
  ## 'Languages' Searches repositories based on the language they are written in.
  ## 'Stars' Searches repositories based on the number of stars.
  ## 
  section = newJObject()
  var valid_39462894 = query.getOrDefault("order")
  valid_39462894 = validateParameter(valid_39462894, JString, required = false,
                                   default = newJString("desc"))
  if valid_39462894 != nil:
    section.add "order", valid_39462894
  var valid_39462895 = query.getOrDefault("sort")
  valid_39462895 = validateParameter(valid_39462895, JString, required = false,
                                   default = newJString("stars"))
  if valid_39462895 != nil:
    section.add "sort", valid_39462895
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_39462896 = query.getOrDefault("q")
  valid_39462896 = validateParameter(valid_39462896, JString, required = true,
                                   default = nil)
  if valid_39462896 != nil:
    section.add "q", valid_39462896
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462897 = header.getOrDefault("Accept")
  valid_39462897 = validateParameter(valid_39462897, JString, required = false,
                                   default = nil)
  if valid_39462897 != nil:
    section.add "Accept", valid_39462897
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462898: Call_GetSearchRepositories_39462891;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Search repositories.
  ## 
  let valid = call_39462898.validator(path, query, header, formData, body, _)
  let scheme = call_39462898.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462898.url(scheme.get, call_39462898.host, call_39462898.base,
                           call_39462898.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462898, uri, valid, _)

proc call*(call_39462899: Call_GetSearchRepositories_39462891; q: string;
          order: string = "desc"; Accept: string = ""; sort: string = "stars"): Recallable =
  ## getSearchRepositories
  ## Search repositories.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##       : If not provided, results are sorted by best match.
  ##   q: string (required)
  ##    : The search terms. This can be any combination of the supported repository
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the repository name, description, readme,
  ## or any combination of these.
  ## 'Size' Finds repositories that match a certain size (in kilobytes).
  ## 'Forks' Filters repositories based on the number of forks, and/or whether
  ## forked repositories should be included in the results at all.
  ## 'Created' and 'Last Updated' Filters repositories based on times of
  ## creation, or when they were last updated.
  ## 'Users or Repositories' Limits searches to a specific user or repository.
  ## 'Languages' Searches repositories based on the language they are written in.
  ## 'Stars' Searches repositories based on the number of stars.
  ## 
  var query_39462900 = newJObject()
  var header_39462901 = newJObject()
  add(query_39462900, "order", newJString(order))
  add(header_39462901, "Accept", newJString(Accept))
  add(query_39462900, "sort", newJString(sort))
  add(query_39462900, "q", newJString(q))
  result = call_39462899.call(nil, query_39462900, header_39462901, nil, nil)

var getSearchRepositories* = Call_GetSearchRepositories_39462891(
    name: "getSearchRepositories", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/search/repositories", validator: validate_GetSearchRepositories_39462892,
    base: "/", url: url_GetSearchRepositories_39462893, schemes: {Scheme.Https})
type
  Call_GetSearchUsers_39462902 = ref object of OpenApiRestCall_39460352
proc url_GetSearchUsers_39462904(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchUsers_39462903(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Search users.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   sort: JString
  ##       : If not provided, results are sorted by best match.
  ##   q: JString (required)
  ##    : The search terms. This can be any combination of the supported user
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the username, public email, full name,
  ## location, or any combination of these.
  ## 'Repository count' Filters users based on the number of repositories they
  ## have.
  ## 'Location' Filter users by the location indicated in their profile.
  ## 'Language' Search for users that have repositories that match a certain
  ## language.
  ## 'Created' Filter users based on when they joined.
  ## 'Followers' Filter users based on the number of followers they have.
  ## 
  section = newJObject()
  var valid_39462905 = query.getOrDefault("order")
  valid_39462905 = validateParameter(valid_39462905, JString, required = false,
                                   default = newJString("desc"))
  if valid_39462905 != nil:
    section.add "order", valid_39462905
  var valid_39462906 = query.getOrDefault("sort")
  valid_39462906 = validateParameter(valid_39462906, JString, required = false,
                                   default = newJString("followers"))
  if valid_39462906 != nil:
    section.add "sort", valid_39462906
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_39462907 = query.getOrDefault("q")
  valid_39462907 = validateParameter(valid_39462907, JString, required = true,
                                   default = nil)
  if valid_39462907 != nil:
    section.add "q", valid_39462907
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462908 = header.getOrDefault("Accept")
  valid_39462908 = validateParameter(valid_39462908, JString, required = false,
                                   default = nil)
  if valid_39462908 != nil:
    section.add "Accept", valid_39462908
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462909: Call_GetSearchUsers_39462902; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Search users.
  ## 
  let valid = call_39462909.validator(path, query, header, formData, body, _)
  let scheme = call_39462909.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462909.url(scheme.get, call_39462909.host, call_39462909.base,
                           call_39462909.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462909, uri, valid, _)

proc call*(call_39462910: Call_GetSearchUsers_39462902; q: string;
          order: string = "desc"; Accept: string = ""; sort: string = "followers"): Recallable =
  ## getSearchUsers
  ## Search users.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##       : If not provided, results are sorted by best match.
  ##   q: string (required)
  ##    : The search terms. This can be any combination of the supported user
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the username, public email, full name,
  ## location, or any combination of these.
  ## 'Repository count' Filters users based on the number of repositories they
  ## have.
  ## 'Location' Filter users by the location indicated in their profile.
  ## 'Language' Search for users that have repositories that match a certain
  ## language.
  ## 'Created' Filter users based on when they joined.
  ## 'Followers' Filter users based on the number of followers they have.
  ## 
  var query_39462911 = newJObject()
  var header_39462912 = newJObject()
  add(query_39462911, "order", newJString(order))
  add(header_39462912, "Accept", newJString(Accept))
  add(query_39462911, "sort", newJString(sort))
  add(query_39462911, "q", newJString(q))
  result = call_39462910.call(nil, query_39462911, header_39462912, nil, nil)

var getSearchUsers* = Call_GetSearchUsers_39462902(name: "getSearchUsers",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/search/users",
    validator: validate_GetSearchUsers_39462903, base: "/", url: url_GetSearchUsers_39462904,
    schemes: {Scheme.Https})
type
  Call_GetTeamsTeamId_39462913 = ref object of OpenApiRestCall_39460352
proc url_GetTeamsTeamId_39462915(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamId_39462914(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get team.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_39462916 = path.getOrDefault("teamId")
  valid_39462916 = validateParameter(valid_39462916, JInt, required = true,
                                   default = nil)
  if valid_39462916 != nil:
    section.add "teamId", valid_39462916
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462917 = header.getOrDefault("Accept")
  valid_39462917 = validateParameter(valid_39462917, JString, required = false,
                                   default = nil)
  if valid_39462917 != nil:
    section.add "Accept", valid_39462917
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462918: Call_GetTeamsTeamId_39462913; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get team.
  ## 
  let valid = call_39462918.validator(path, query, header, formData, body, _)
  let scheme = call_39462918.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462918.url(scheme.get, call_39462918.host, call_39462918.base,
                           call_39462918.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462918, uri, valid, _)

proc call*(call_39462919: Call_GetTeamsTeamId_39462913; teamId: int;
          Accept: string = ""): Recallable =
  ## getTeamsTeamId
  ## Get team.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_39462920 = newJObject()
  var header_39462921 = newJObject()
  add(header_39462921, "Accept", newJString(Accept))
  add(path_39462920, "teamId", newJInt(teamId))
  result = call_39462919.call(path_39462920, nil, header_39462921, nil, nil)

var getTeamsTeamId* = Call_GetTeamsTeamId_39462913(name: "getTeamsTeamId",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/teams/{teamId}",
    validator: validate_GetTeamsTeamId_39462914, base: "/", url: url_GetTeamsTeamId_39462915,
    schemes: {Scheme.Https})
type
  Call_PatchTeamsTeamId_39462931 = ref object of OpenApiRestCall_39460352
proc url_PatchTeamsTeamId_39462933(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchTeamsTeamId_39462932(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Edit team.
  ## In order to edit a team, the authenticated user must be an owner of the org
  ## that the team is associated with.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_39462934 = path.getOrDefault("teamId")
  valid_39462934 = validateParameter(valid_39462934, JInt, required = true,
                                   default = nil)
  if valid_39462934 != nil:
    section.add "teamId", valid_39462934
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462935 = header.getOrDefault("Accept")
  valid_39462935 = validateParameter(valid_39462935, JString, required = false,
                                   default = nil)
  if valid_39462935 != nil:
    section.add "Accept", valid_39462935
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39462937: Call_PatchTeamsTeamId_39462931; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit team.
  ## In order to edit a team, the authenticated user must be an owner of the org
  ## that the team is associated with.
  ## 
  ## 
  let valid = call_39462937.validator(path, query, header, formData, body, _)
  let scheme = call_39462937.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462937.url(scheme.get, call_39462937.host, call_39462937.base,
                           call_39462937.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462937, uri, valid, _)

proc call*(call_39462938: Call_PatchTeamsTeamId_39462931; body: JsonNode;
          teamId: int; Accept: string = ""): Recallable =
  ## patchTeamsTeamId
  ## Edit team.
  ## In order to edit a team, the authenticated user must be an owner of the org
  ## that the team is associated with.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   teamId: int (required)
  ##         : Id of team.
  var path_39462939 = newJObject()
  var header_39462940 = newJObject()
  var body_39462941 = newJObject()
  add(header_39462940, "Accept", newJString(Accept))
  if body != nil:
    body_39462941 = body
  add(path_39462939, "teamId", newJInt(teamId))
  result = call_39462938.call(path_39462939, nil, header_39462940, nil, body_39462941)

var patchTeamsTeamId* = Call_PatchTeamsTeamId_39462931(name: "patchTeamsTeamId",
    meth: HttpMethod.HttpPatch, host: "api.github.com", route: "/teams/{teamId}",
    validator: validate_PatchTeamsTeamId_39462932, base: "/",
    url: url_PatchTeamsTeamId_39462933, schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamId_39462922 = ref object of OpenApiRestCall_39460352
proc url_DeleteTeamsTeamId_39462924(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamId_39462923(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Delete team.
  ## In order to delete a team, the authenticated user must be an owner of the
  ## org that the team is associated with.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_39462925 = path.getOrDefault("teamId")
  valid_39462925 = validateParameter(valid_39462925, JInt, required = true,
                                   default = nil)
  if valid_39462925 != nil:
    section.add "teamId", valid_39462925
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462926 = header.getOrDefault("Accept")
  valid_39462926 = validateParameter(valid_39462926, JString, required = false,
                                   default = nil)
  if valid_39462926 != nil:
    section.add "Accept", valid_39462926
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462927: Call_DeleteTeamsTeamId_39462922; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete team.
  ## In order to delete a team, the authenticated user must be an owner of the
  ## org that the team is associated with.
  ## 
  ## 
  let valid = call_39462927.validator(path, query, header, formData, body, _)
  let scheme = call_39462927.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462927.url(scheme.get, call_39462927.host, call_39462927.base,
                           call_39462927.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462927, uri, valid, _)

proc call*(call_39462928: Call_DeleteTeamsTeamId_39462922; teamId: int;
          Accept: string = ""): Recallable =
  ## deleteTeamsTeamId
  ## Delete team.
  ## In order to delete a team, the authenticated user must be an owner of the
  ## org that the team is associated with.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_39462929 = newJObject()
  var header_39462930 = newJObject()
  add(header_39462930, "Accept", newJString(Accept))
  add(path_39462929, "teamId", newJInt(teamId))
  result = call_39462928.call(path_39462929, nil, header_39462930, nil, nil)

var deleteTeamsTeamId* = Call_DeleteTeamsTeamId_39462922(name: "deleteTeamsTeamId",
    meth: HttpMethod.HttpDelete, host: "api.github.com", route: "/teams/{teamId}",
    validator: validate_DeleteTeamsTeamId_39462923, base: "/",
    url: url_DeleteTeamsTeamId_39462924, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdMembers_39462942 = ref object of OpenApiRestCall_39460352
proc url_GetTeamsTeamIdMembers_39462944(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/members")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdMembers_39462943(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List team members.
  ## In order to list members in a team, the authenticated user must be a member
  ## of the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_39462945 = path.getOrDefault("teamId")
  valid_39462945 = validateParameter(valid_39462945, JInt, required = true,
                                   default = nil)
  if valid_39462945 != nil:
    section.add "teamId", valid_39462945
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462946 = header.getOrDefault("Accept")
  valid_39462946 = validateParameter(valid_39462946, JString, required = false,
                                   default = nil)
  if valid_39462946 != nil:
    section.add "Accept", valid_39462946
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462947: Call_GetTeamsTeamIdMembers_39462942;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List team members.
  ## In order to list members in a team, the authenticated user must be a member
  ## of the team.
  ## 
  ## 
  let valid = call_39462947.validator(path, query, header, formData, body, _)
  let scheme = call_39462947.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462947.url(scheme.get, call_39462947.host, call_39462947.base,
                           call_39462947.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462947, uri, valid, _)

proc call*(call_39462948: Call_GetTeamsTeamIdMembers_39462942; teamId: int;
          Accept: string = ""): Recallable =
  ## getTeamsTeamIdMembers
  ## List team members.
  ## In order to list members in a team, the authenticated user must be a member
  ## of the team.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_39462949 = newJObject()
  var header_39462950 = newJObject()
  add(header_39462950, "Accept", newJString(Accept))
  add(path_39462949, "teamId", newJInt(teamId))
  result = call_39462948.call(path_39462949, nil, header_39462950, nil, nil)

var getTeamsTeamIdMembers* = Call_GetTeamsTeamIdMembers_39462942(
    name: "getTeamsTeamIdMembers", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/teams/{teamId}/members", validator: validate_GetTeamsTeamIdMembers_39462943,
    base: "/", url: url_GetTeamsTeamIdMembers_39462944, schemes: {Scheme.Https})
type
  Call_PutTeamsTeamIdMembersUsername_39462961 = ref object of OpenApiRestCall_39460352
proc url_PutTeamsTeamIdMembersUsername_39462963(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutTeamsTeamIdMembersUsername_39462962(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## The API (described below) is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Add team membership API instead. It allows you to invite new organization members to your teams.
  ## 
  ## Add team member.
  ## In order to add a user to a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39462964 = path.getOrDefault("username")
  valid_39462964 = validateParameter(valid_39462964, JString, required = true,
                                   default = nil)
  if valid_39462964 != nil:
    section.add "username", valid_39462964
  var valid_39462965 = path.getOrDefault("teamId")
  valid_39462965 = validateParameter(valid_39462965, JInt, required = true,
                                   default = nil)
  if valid_39462965 != nil:
    section.add "teamId", valid_39462965
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462966 = header.getOrDefault("Accept")
  valid_39462966 = validateParameter(valid_39462966, JString, required = false,
                                   default = nil)
  if valid_39462966 != nil:
    section.add "Accept", valid_39462966
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462967: Call_PutTeamsTeamIdMembersUsername_39462961;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## The API (described below) is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Add team membership API instead. It allows you to invite new organization members to your teams.
  ## 
  ## Add team member.
  ## In order to add a user to a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## 
  ## 
  let valid = call_39462967.validator(path, query, header, formData, body, _)
  let scheme = call_39462967.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462967.url(scheme.get, call_39462967.host, call_39462967.base,
                           call_39462967.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462967, uri, valid, _)

proc call*(call_39462968: Call_PutTeamsTeamIdMembersUsername_39462961;
          username: string; teamId: int; Accept: string = ""): Recallable =
  ## putTeamsTeamIdMembersUsername
  ## The API (described below) is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Add team membership API instead. It allows you to invite new organization members to your teams.
  ## 
  ## Add team member.
  ## In order to add a user to a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_39462969 = newJObject()
  var header_39462970 = newJObject()
  add(path_39462969, "username", newJString(username))
  add(header_39462970, "Accept", newJString(Accept))
  add(path_39462969, "teamId", newJInt(teamId))
  result = call_39462968.call(path_39462969, nil, header_39462970, nil, nil)

var putTeamsTeamIdMembersUsername* = Call_PutTeamsTeamIdMembersUsername_39462961(
    name: "putTeamsTeamIdMembersUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/teams/{teamId}/members/{username}",
    validator: validate_PutTeamsTeamIdMembersUsername_39462962, base: "/",
    url: url_PutTeamsTeamIdMembersUsername_39462963, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdMembersUsername_39462951 = ref object of OpenApiRestCall_39460352
proc url_GetTeamsTeamIdMembersUsername_39462953(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdMembersUsername_39462952(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## The "Get team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Get team membership API instead. It allows you to get both active and pending memberships.
  ## 
  ## Get team member.
  ## In order to get if a user is a member of a team, the authenticated user mus
  ## be a member of the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39462954 = path.getOrDefault("username")
  valid_39462954 = validateParameter(valid_39462954, JString, required = true,
                                   default = nil)
  if valid_39462954 != nil:
    section.add "username", valid_39462954
  var valid_39462955 = path.getOrDefault("teamId")
  valid_39462955 = validateParameter(valid_39462955, JInt, required = true,
                                   default = nil)
  if valid_39462955 != nil:
    section.add "teamId", valid_39462955
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462956 = header.getOrDefault("Accept")
  valid_39462956 = validateParameter(valid_39462956, JString, required = false,
                                   default = nil)
  if valid_39462956 != nil:
    section.add "Accept", valid_39462956
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462957: Call_GetTeamsTeamIdMembersUsername_39462951;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## The "Get team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Get team membership API instead. It allows you to get both active and pending memberships.
  ## 
  ## Get team member.
  ## In order to get if a user is a member of a team, the authenticated user mus
  ## be a member of the team.
  ## 
  ## 
  let valid = call_39462957.validator(path, query, header, formData, body, _)
  let scheme = call_39462957.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462957.url(scheme.get, call_39462957.host, call_39462957.base,
                           call_39462957.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462957, uri, valid, _)

proc call*(call_39462958: Call_GetTeamsTeamIdMembersUsername_39462951;
          username: string; teamId: int; Accept: string = ""): Recallable =
  ## getTeamsTeamIdMembersUsername
  ## The "Get team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Get team membership API instead. It allows you to get both active and pending memberships.
  ## 
  ## Get team member.
  ## In order to get if a user is a member of a team, the authenticated user mus
  ## be a member of the team.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_39462959 = newJObject()
  var header_39462960 = newJObject()
  add(path_39462959, "username", newJString(username))
  add(header_39462960, "Accept", newJString(Accept))
  add(path_39462959, "teamId", newJInt(teamId))
  result = call_39462958.call(path_39462959, nil, header_39462960, nil, nil)

var getTeamsTeamIdMembersUsername* = Call_GetTeamsTeamIdMembersUsername_39462951(
    name: "getTeamsTeamIdMembersUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/teams/{teamId}/members/{username}",
    validator: validate_GetTeamsTeamIdMembersUsername_39462952, base: "/",
    url: url_GetTeamsTeamIdMembersUsername_39462953, schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamIdMembersUsername_39462971 = ref object of OpenApiRestCall_39460352
proc url_DeleteTeamsTeamIdMembersUsername_39462973(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamIdMembersUsername_39462972(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## The "Remove team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Remove team membership API instead. It allows you to remove both active and pending memberships.
  ## 
  ## Remove team member.
  ## In order to remove a user from a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## NOTE This does not delete the user, it just remove them from the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39462974 = path.getOrDefault("username")
  valid_39462974 = validateParameter(valid_39462974, JString, required = true,
                                   default = nil)
  if valid_39462974 != nil:
    section.add "username", valid_39462974
  var valid_39462975 = path.getOrDefault("teamId")
  valid_39462975 = validateParameter(valid_39462975, JInt, required = true,
                                   default = nil)
  if valid_39462975 != nil:
    section.add "teamId", valid_39462975
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462976 = header.getOrDefault("Accept")
  valid_39462976 = validateParameter(valid_39462976, JString, required = false,
                                   default = nil)
  if valid_39462976 != nil:
    section.add "Accept", valid_39462976
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462977: Call_DeleteTeamsTeamIdMembersUsername_39462971;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## The "Remove team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Remove team membership API instead. It allows you to remove both active and pending memberships.
  ## 
  ## Remove team member.
  ## In order to remove a user from a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## NOTE This does not delete the user, it just remove them from the team.
  ## 
  ## 
  let valid = call_39462977.validator(path, query, header, formData, body, _)
  let scheme = call_39462977.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462977.url(scheme.get, call_39462977.host, call_39462977.base,
                           call_39462977.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462977, uri, valid, _)

proc call*(call_39462978: Call_DeleteTeamsTeamIdMembersUsername_39462971;
          username: string; teamId: int; Accept: string = ""): Recallable =
  ## deleteTeamsTeamIdMembersUsername
  ## The "Remove team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Remove team membership API instead. It allows you to remove both active and pending memberships.
  ## 
  ## Remove team member.
  ## In order to remove a user from a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## NOTE This does not delete the user, it just remove them from the team.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_39462979 = newJObject()
  var header_39462980 = newJObject()
  add(path_39462979, "username", newJString(username))
  add(header_39462980, "Accept", newJString(Accept))
  add(path_39462979, "teamId", newJInt(teamId))
  result = call_39462978.call(path_39462979, nil, header_39462980, nil, nil)

var deleteTeamsTeamIdMembersUsername* = Call_DeleteTeamsTeamIdMembersUsername_39462971(
    name: "deleteTeamsTeamIdMembersUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/teams/{teamId}/members/{username}",
    validator: validate_DeleteTeamsTeamIdMembersUsername_39462972, base: "/",
    url: url_DeleteTeamsTeamIdMembersUsername_39462973, schemes: {Scheme.Https})
type
  Call_PutTeamsTeamIdMembershipsUsername_39462991 = ref object of OpenApiRestCall_39460352
proc url_PutTeamsTeamIdMembershipsUsername_39462993(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/memberships/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutTeamsTeamIdMembershipsUsername_39462992(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Add team membership.
  ## In order to add a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with.
  ## 
  ## If the user is already a part of the team's organization (meaning they're on at least one other team in the organization), this endpoint will add the user to the team.
  ## 
  ## If the user is completely unaffiliated with the team's organization (meaning they're on none of the organization's teams), this endpoint will send an invitation to the user via email. This newly-created membership will be in the 'pending' state until the user accepts the invitation, at which point the membership will transition to the 'active' state and the user will be added as a member of the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39462994 = path.getOrDefault("username")
  valid_39462994 = validateParameter(valid_39462994, JString, required = true,
                                   default = nil)
  if valid_39462994 != nil:
    section.add "username", valid_39462994
  var valid_39462995 = path.getOrDefault("teamId")
  valid_39462995 = validateParameter(valid_39462995, JInt, required = true,
                                   default = nil)
  if valid_39462995 != nil:
    section.add "teamId", valid_39462995
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462996 = header.getOrDefault("Accept")
  valid_39462996 = validateParameter(valid_39462996, JString, required = false,
                                   default = nil)
  if valid_39462996 != nil:
    section.add "Accept", valid_39462996
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462997: Call_PutTeamsTeamIdMembershipsUsername_39462991;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Add team membership.
  ## In order to add a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with.
  ## 
  ## If the user is already a part of the team's organization (meaning they're on at least one other team in the organization), this endpoint will add the user to the team.
  ## 
  ## If the user is completely unaffiliated with the team's organization (meaning they're on none of the organization's teams), this endpoint will send an invitation to the user via email. This newly-created membership will be in the 'pending' state until the user accepts the invitation, at which point the membership will transition to the 'active' state and the user will be added as a member of the team.
  ## 
  ## 
  let valid = call_39462997.validator(path, query, header, formData, body, _)
  let scheme = call_39462997.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462997.url(scheme.get, call_39462997.host, call_39462997.base,
                           call_39462997.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462997, uri, valid, _)

proc call*(call_39462998: Call_PutTeamsTeamIdMembershipsUsername_39462991;
          username: string; teamId: int; Accept: string = ""): Recallable =
  ## putTeamsTeamIdMembershipsUsername
  ## Add team membership.
  ## In order to add a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with.
  ## 
  ## If the user is already a part of the team's organization (meaning they're on at least one other team in the organization), this endpoint will add the user to the team.
  ## 
  ## If the user is completely unaffiliated with the team's organization (meaning they're on none of the organization's teams), this endpoint will send an invitation to the user via email. This newly-created membership will be in the 'pending' state until the user accepts the invitation, at which point the membership will transition to the 'active' state and the user will be added as a member of the team.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_39462999 = newJObject()
  var header_39463000 = newJObject()
  add(path_39462999, "username", newJString(username))
  add(header_39463000, "Accept", newJString(Accept))
  add(path_39462999, "teamId", newJInt(teamId))
  result = call_39462998.call(path_39462999, nil, header_39463000, nil, nil)

var putTeamsTeamIdMembershipsUsername* = Call_PutTeamsTeamIdMembershipsUsername_39462991(
    name: "putTeamsTeamIdMembershipsUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/teams/{teamId}/memberships/{username}",
    validator: validate_PutTeamsTeamIdMembershipsUsername_39462992, base: "/",
    url: url_PutTeamsTeamIdMembershipsUsername_39462993, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdMembershipsUsername_39462981 = ref object of OpenApiRestCall_39460352
proc url_GetTeamsTeamIdMembershipsUsername_39462983(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/memberships/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdMembershipsUsername_39462982(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get team membership.
  ## In order to get a user's membership with a team, the authenticated user must be a member of the team or an owner of the team's organization.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39462984 = path.getOrDefault("username")
  valid_39462984 = validateParameter(valid_39462984, JString, required = true,
                                   default = nil)
  if valid_39462984 != nil:
    section.add "username", valid_39462984
  var valid_39462985 = path.getOrDefault("teamId")
  valid_39462985 = validateParameter(valid_39462985, JInt, required = true,
                                   default = nil)
  if valid_39462985 != nil:
    section.add "teamId", valid_39462985
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39462986 = header.getOrDefault("Accept")
  valid_39462986 = validateParameter(valid_39462986, JString, required = false,
                                   default = nil)
  if valid_39462986 != nil:
    section.add "Accept", valid_39462986
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39462987: Call_GetTeamsTeamIdMembershipsUsername_39462981;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get team membership.
  ## In order to get a user's membership with a team, the authenticated user must be a member of the team or an owner of the team's organization.
  ## 
  ## 
  let valid = call_39462987.validator(path, query, header, formData, body, _)
  let scheme = call_39462987.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39462987.url(scheme.get, call_39462987.host, call_39462987.base,
                           call_39462987.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39462987, uri, valid, _)

proc call*(call_39462988: Call_GetTeamsTeamIdMembershipsUsername_39462981;
          username: string; teamId: int; Accept: string = ""): Recallable =
  ## getTeamsTeamIdMembershipsUsername
  ## Get team membership.
  ## In order to get a user's membership with a team, the authenticated user must be a member of the team or an owner of the team's organization.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_39462989 = newJObject()
  var header_39462990 = newJObject()
  add(path_39462989, "username", newJString(username))
  add(header_39462990, "Accept", newJString(Accept))
  add(path_39462989, "teamId", newJInt(teamId))
  result = call_39462988.call(path_39462989, nil, header_39462990, nil, nil)

var getTeamsTeamIdMembershipsUsername* = Call_GetTeamsTeamIdMembershipsUsername_39462981(
    name: "getTeamsTeamIdMembershipsUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/teams/{teamId}/memberships/{username}",
    validator: validate_GetTeamsTeamIdMembershipsUsername_39462982, base: "/",
    url: url_GetTeamsTeamIdMembershipsUsername_39462983, schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamIdMembershipsUsername_39463001 = ref object of OpenApiRestCall_39460352
proc url_DeleteTeamsTeamIdMembershipsUsername_39463003(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/memberships/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamIdMembershipsUsername_39463002(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Remove team membership.
  ## In order to remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. NOTE: This does not delete the user, it just removes their membership from the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39463004 = path.getOrDefault("username")
  valid_39463004 = validateParameter(valid_39463004, JString, required = true,
                                   default = nil)
  if valid_39463004 != nil:
    section.add "username", valid_39463004
  var valid_39463005 = path.getOrDefault("teamId")
  valid_39463005 = validateParameter(valid_39463005, JInt, required = true,
                                   default = nil)
  if valid_39463005 != nil:
    section.add "teamId", valid_39463005
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463006 = header.getOrDefault("Accept")
  valid_39463006 = validateParameter(valid_39463006, JString, required = false,
                                   default = nil)
  if valid_39463006 != nil:
    section.add "Accept", valid_39463006
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463007: Call_DeleteTeamsTeamIdMembershipsUsername_39463001;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Remove team membership.
  ## In order to remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. NOTE: This does not delete the user, it just removes their membership from the team.
  ## 
  ## 
  let valid = call_39463007.validator(path, query, header, formData, body, _)
  let scheme = call_39463007.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463007.url(scheme.get, call_39463007.host, call_39463007.base,
                           call_39463007.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463007, uri, valid, _)

proc call*(call_39463008: Call_DeleteTeamsTeamIdMembershipsUsername_39463001;
          username: string; teamId: int; Accept: string = ""): Recallable =
  ## deleteTeamsTeamIdMembershipsUsername
  ## Remove team membership.
  ## In order to remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. NOTE: This does not delete the user, it just removes their membership from the team.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_39463009 = newJObject()
  var header_39463010 = newJObject()
  add(path_39463009, "username", newJString(username))
  add(header_39463010, "Accept", newJString(Accept))
  add(path_39463009, "teamId", newJInt(teamId))
  result = call_39463008.call(path_39463009, nil, header_39463010, nil, nil)

var deleteTeamsTeamIdMembershipsUsername* = Call_DeleteTeamsTeamIdMembershipsUsername_39463001(
    name: "deleteTeamsTeamIdMembershipsUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/teams/{teamId}/memberships/{username}",
    validator: validate_DeleteTeamsTeamIdMembershipsUsername_39463002, base: "/",
    url: url_DeleteTeamsTeamIdMembershipsUsername_39463003,
    schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdRepos_39463011 = ref object of OpenApiRestCall_39460352
proc url_GetTeamsTeamIdRepos_39463013(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdRepos_39463012(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List team repos
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_39463014 = path.getOrDefault("teamId")
  valid_39463014 = validateParameter(valid_39463014, JInt, required = true,
                                   default = nil)
  if valid_39463014 != nil:
    section.add "teamId", valid_39463014
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463015 = header.getOrDefault("Accept")
  valid_39463015 = validateParameter(valid_39463015, JString, required = false,
                                   default = nil)
  if valid_39463015 != nil:
    section.add "Accept", valid_39463015
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463016: Call_GetTeamsTeamIdRepos_39463011; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List team repos
  ## 
  let valid = call_39463016.validator(path, query, header, formData, body, _)
  let scheme = call_39463016.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463016.url(scheme.get, call_39463016.host, call_39463016.base,
                           call_39463016.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463016, uri, valid, _)

proc call*(call_39463017: Call_GetTeamsTeamIdRepos_39463011; teamId: int;
          Accept: string = ""): Recallable =
  ## getTeamsTeamIdRepos
  ## List team repos
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_39463018 = newJObject()
  var header_39463019 = newJObject()
  add(header_39463019, "Accept", newJString(Accept))
  add(path_39463018, "teamId", newJInt(teamId))
  result = call_39463017.call(path_39463018, nil, header_39463019, nil, nil)

var getTeamsTeamIdRepos* = Call_GetTeamsTeamIdRepos_39463011(
    name: "getTeamsTeamIdRepos", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/teams/{teamId}/repos", validator: validate_GetTeamsTeamIdRepos_39463012,
    base: "/", url: url_GetTeamsTeamIdRepos_39463013, schemes: {Scheme.Https})
type
  Call_PutTeamsTeamIdReposOwnerRepo_39463031 = ref object of OpenApiRestCall_39460352
proc url_PutTeamsTeamIdReposOwnerRepo_39463033(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutTeamsTeamIdReposOwnerRepo_39463032(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## In order to add a repository to a team, the authenticated user must be an owner of the org that the team is associated with. Also, the repository must be owned by the organization, or a direct fork of a repository owned by the organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of a organization.
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39463034 = path.getOrDefault("owner")
  valid_39463034 = validateParameter(valid_39463034, JString, required = true,
                                   default = nil)
  if valid_39463034 != nil:
    section.add "owner", valid_39463034
  var valid_39463035 = path.getOrDefault("repo")
  valid_39463035 = validateParameter(valid_39463035, JString, required = true,
                                   default = nil)
  if valid_39463035 != nil:
    section.add "repo", valid_39463035
  var valid_39463036 = path.getOrDefault("teamId")
  valid_39463036 = validateParameter(valid_39463036, JInt, required = true,
                                   default = nil)
  if valid_39463036 != nil:
    section.add "teamId", valid_39463036
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463037 = header.getOrDefault("Accept")
  valid_39463037 = validateParameter(valid_39463037, JString, required = false,
                                   default = nil)
  if valid_39463037 != nil:
    section.add "Accept", valid_39463037
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463038: Call_PutTeamsTeamIdReposOwnerRepo_39463031;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## In order to add a repository to a team, the authenticated user must be an owner of the org that the team is associated with. Also, the repository must be owned by the organization, or a direct fork of a repository owned by the organization.
  ## 
  let valid = call_39463038.validator(path, query, header, formData, body, _)
  let scheme = call_39463038.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463038.url(scheme.get, call_39463038.host, call_39463038.base,
                           call_39463038.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463038, uri, valid, _)

proc call*(call_39463039: Call_PutTeamsTeamIdReposOwnerRepo_39463031;
          owner: string; repo: string; teamId: int; Accept: string = ""): Recallable =
  ## putTeamsTeamIdReposOwnerRepo
  ## In order to add a repository to a team, the authenticated user must be an owner of the org that the team is associated with. Also, the repository must be owned by the organization, or a direct fork of a repository owned by the organization.
  ##   owner: string (required)
  ##        : Name of a organization.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_39463040 = newJObject()
  var header_39463041 = newJObject()
  add(path_39463040, "owner", newJString(owner))
  add(header_39463041, "Accept", newJString(Accept))
  add(path_39463040, "repo", newJString(repo))
  add(path_39463040, "teamId", newJInt(teamId))
  result = call_39463039.call(path_39463040, nil, header_39463041, nil, nil)

var putTeamsTeamIdReposOwnerRepo* = Call_PutTeamsTeamIdReposOwnerRepo_39463031(
    name: "putTeamsTeamIdReposOwnerRepo", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/teams/{teamId}/repos/{owner}/{repo}",
    validator: validate_PutTeamsTeamIdReposOwnerRepo_39463032, base: "/",
    url: url_PutTeamsTeamIdReposOwnerRepo_39463033, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdReposOwnerRepo_39463020 = ref object of OpenApiRestCall_39460352
proc url_GetTeamsTeamIdReposOwnerRepo_39463022(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdReposOwnerRepo_39463021(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Check if a team manages a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39463023 = path.getOrDefault("owner")
  valid_39463023 = validateParameter(valid_39463023, JString, required = true,
                                   default = nil)
  if valid_39463023 != nil:
    section.add "owner", valid_39463023
  var valid_39463024 = path.getOrDefault("repo")
  valid_39463024 = validateParameter(valid_39463024, JString, required = true,
                                   default = nil)
  if valid_39463024 != nil:
    section.add "repo", valid_39463024
  var valid_39463025 = path.getOrDefault("teamId")
  valid_39463025 = validateParameter(valid_39463025, JInt, required = true,
                                   default = nil)
  if valid_39463025 != nil:
    section.add "teamId", valid_39463025
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463026 = header.getOrDefault("Accept")
  valid_39463026 = validateParameter(valid_39463026, JString, required = false,
                                   default = nil)
  if valid_39463026 != nil:
    section.add "Accept", valid_39463026
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463027: Call_GetTeamsTeamIdReposOwnerRepo_39463020;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if a team manages a repository
  ## 
  let valid = call_39463027.validator(path, query, header, formData, body, _)
  let scheme = call_39463027.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463027.url(scheme.get, call_39463027.host, call_39463027.base,
                           call_39463027.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463027, uri, valid, _)

proc call*(call_39463028: Call_GetTeamsTeamIdReposOwnerRepo_39463020;
          owner: string; repo: string; teamId: int; Accept: string = ""): Recallable =
  ## getTeamsTeamIdReposOwnerRepo
  ## Check if a team manages a repository
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_39463029 = newJObject()
  var header_39463030 = newJObject()
  add(path_39463029, "owner", newJString(owner))
  add(header_39463030, "Accept", newJString(Accept))
  add(path_39463029, "repo", newJString(repo))
  add(path_39463029, "teamId", newJInt(teamId))
  result = call_39463028.call(path_39463029, nil, header_39463030, nil, nil)

var getTeamsTeamIdReposOwnerRepo* = Call_GetTeamsTeamIdReposOwnerRepo_39463020(
    name: "getTeamsTeamIdReposOwnerRepo", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/teams/{teamId}/repos/{owner}/{repo}",
    validator: validate_GetTeamsTeamIdReposOwnerRepo_39463021, base: "/",
    url: url_GetTeamsTeamIdReposOwnerRepo_39463022, schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamIdReposOwnerRepo_39463042 = ref object of OpenApiRestCall_39460352
proc url_DeleteTeamsTeamIdReposOwnerRepo_39463044(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamIdReposOwnerRepo_39463043(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## In order to remove a repository from a team, the authenticated user must be an owner of the org that the team is associated with. NOTE: This does not delete the repository, it just removes it from the team.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39463045 = path.getOrDefault("owner")
  valid_39463045 = validateParameter(valid_39463045, JString, required = true,
                                   default = nil)
  if valid_39463045 != nil:
    section.add "owner", valid_39463045
  var valid_39463046 = path.getOrDefault("repo")
  valid_39463046 = validateParameter(valid_39463046, JString, required = true,
                                   default = nil)
  if valid_39463046 != nil:
    section.add "repo", valid_39463046
  var valid_39463047 = path.getOrDefault("teamId")
  valid_39463047 = validateParameter(valid_39463047, JInt, required = true,
                                   default = nil)
  if valid_39463047 != nil:
    section.add "teamId", valid_39463047
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463048 = header.getOrDefault("Accept")
  valid_39463048 = validateParameter(valid_39463048, JString, required = false,
                                   default = nil)
  if valid_39463048 != nil:
    section.add "Accept", valid_39463048
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463049: Call_DeleteTeamsTeamIdReposOwnerRepo_39463042;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## In order to remove a repository from a team, the authenticated user must be an owner of the org that the team is associated with. NOTE: This does not delete the repository, it just removes it from the team.
  ## 
  let valid = call_39463049.validator(path, query, header, formData, body, _)
  let scheme = call_39463049.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463049.url(scheme.get, call_39463049.host, call_39463049.base,
                           call_39463049.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463049, uri, valid, _)

proc call*(call_39463050: Call_DeleteTeamsTeamIdReposOwnerRepo_39463042;
          owner: string; repo: string; teamId: int; Accept: string = ""): Recallable =
  ## deleteTeamsTeamIdReposOwnerRepo
  ## In order to remove a repository from a team, the authenticated user must be an owner of the org that the team is associated with. NOTE: This does not delete the repository, it just removes it from the team.
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_39463051 = newJObject()
  var header_39463052 = newJObject()
  add(path_39463051, "owner", newJString(owner))
  add(header_39463052, "Accept", newJString(Accept))
  add(path_39463051, "repo", newJString(repo))
  add(path_39463051, "teamId", newJInt(teamId))
  result = call_39463050.call(path_39463051, nil, header_39463052, nil, nil)

var deleteTeamsTeamIdReposOwnerRepo* = Call_DeleteTeamsTeamIdReposOwnerRepo_39463042(
    name: "deleteTeamsTeamIdReposOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/teams/{teamId}/repos/{owner}/{repo}",
    validator: validate_DeleteTeamsTeamIdReposOwnerRepo_39463043, base: "/",
    url: url_DeleteTeamsTeamIdReposOwnerRepo_39463044, schemes: {Scheme.Https})
type
  Call_GetUser_39463053 = ref object of OpenApiRestCall_39460352
proc url_GetUser_39463055(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUser_39463054(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463056 = header.getOrDefault("Accept")
  valid_39463056 = validateParameter(valid_39463056, JString, required = false,
                                   default = nil)
  if valid_39463056 != nil:
    section.add "Accept", valid_39463056
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463057: Call_GetUser_39463053; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get the authenticated user.
  ## 
  let valid = call_39463057.validator(path, query, header, formData, body, _)
  let scheme = call_39463057.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463057.url(scheme.get, call_39463057.host, call_39463057.base,
                           call_39463057.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463057, uri, valid, _)

proc call*(call_39463058: Call_GetUser_39463053; Accept: string = ""): Recallable =
  ## getUser
  ## Get the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_39463059 = newJObject()
  add(header_39463059, "Accept", newJString(Accept))
  result = call_39463058.call(nil, nil, header_39463059, nil, nil)

var getUser* = Call_GetUser_39463053(name: "getUser", meth: HttpMethod.HttpGet,
                                  host: "api.github.com", route: "/user",
                                  validator: validate_GetUser_39463054, base: "/",
                                  url: url_GetUser_39463055,
                                  schemes: {Scheme.Https})
type
  Call_PatchUser_39463060 = ref object of OpenApiRestCall_39460352
proc url_PatchUser_39463062(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PatchUser_39463061(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Update the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463063 = header.getOrDefault("Accept")
  valid_39463063 = validateParameter(valid_39463063, JString, required = false,
                                   default = nil)
  if valid_39463063 != nil:
    section.add "Accept", valid_39463063
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39463065: Call_PatchUser_39463060; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Update the authenticated user.
  ## 
  let valid = call_39463065.validator(path, query, header, formData, body, _)
  let scheme = call_39463065.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463065.url(scheme.get, call_39463065.host, call_39463065.base,
                           call_39463065.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463065, uri, valid, _)

proc call*(call_39463066: Call_PatchUser_39463060; body: JsonNode;
          Accept: string = ""): Recallable =
  ## patchUser
  ## Update the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_39463067 = newJObject()
  var body_39463068 = newJObject()
  add(header_39463067, "Accept", newJString(Accept))
  if body != nil:
    body_39463068 = body
  result = call_39463066.call(nil, nil, header_39463067, nil, body_39463068)

var patchUser* = Call_PatchUser_39463060(name: "patchUser",
                                      meth: HttpMethod.HttpPatch,
                                      host: "api.github.com", route: "/user",
                                      validator: validate_PatchUser_39463061,
                                      base: "/", url: url_PatchUser_39463062,
                                      schemes: {Scheme.Https})
type
  Call_PostUserEmails_39463076 = ref object of OpenApiRestCall_39460352
proc url_PostUserEmails_39463078(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostUserEmails_39463077(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Add email address(es).
  ## You can post a single email address or an array of addresses.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463079 = header.getOrDefault("Accept")
  valid_39463079 = validateParameter(valid_39463079, JString, required = false,
                                   default = nil)
  if valid_39463079 != nil:
    section.add "Accept", valid_39463079
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39463081: Call_PostUserEmails_39463076; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Add email address(es).
  ## You can post a single email address or an array of addresses.
  ## 
  ## 
  let valid = call_39463081.validator(path, query, header, formData, body, _)
  let scheme = call_39463081.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463081.url(scheme.get, call_39463081.host, call_39463081.base,
                           call_39463081.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463081, uri, valid, _)

proc call*(call_39463082: Call_PostUserEmails_39463076; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postUserEmails
  ## Add email address(es).
  ## You can post a single email address or an array of addresses.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  var header_39463083 = newJObject()
  var body_39463084 = newJObject()
  add(header_39463083, "Accept", newJString(Accept))
  if body != nil:
    body_39463084 = body
  result = call_39463082.call(nil, nil, header_39463083, nil, body_39463084)

var postUserEmails* = Call_PostUserEmails_39463076(name: "postUserEmails",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/user/emails",
    validator: validate_PostUserEmails_39463077, base: "/", url: url_PostUserEmails_39463078,
    schemes: {Scheme.Https})
type
  Call_GetUserEmails_39463069 = ref object of OpenApiRestCall_39460352
proc url_GetUserEmails_39463071(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserEmails_39463070(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## List email addresses for a user.
  ## In the final version of the API, this method will return an array of hashes
  ## with extended information for each email address indicating if the address
  ## has been verified and if it's primary email address for GitHub.
  ## Until API v3 is finalized, use the application/vnd.github.v3 media type to
  ## get other response format.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463072 = header.getOrDefault("Accept")
  valid_39463072 = validateParameter(valid_39463072, JString, required = false,
                                   default = nil)
  if valid_39463072 != nil:
    section.add "Accept", valid_39463072
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463073: Call_GetUserEmails_39463069; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List email addresses for a user.
  ## In the final version of the API, this method will return an array of hashes
  ## with extended information for each email address indicating if the address
  ## has been verified and if it's primary email address for GitHub.
  ## Until API v3 is finalized, use the application/vnd.github.v3 media type to
  ## get other response format.
  ## 
  ## 
  let valid = call_39463073.validator(path, query, header, formData, body, _)
  let scheme = call_39463073.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463073.url(scheme.get, call_39463073.host, call_39463073.base,
                           call_39463073.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463073, uri, valid, _)

proc call*(call_39463074: Call_GetUserEmails_39463069; Accept: string = ""): Recallable =
  ## getUserEmails
  ## List email addresses for a user.
  ## In the final version of the API, this method will return an array of hashes
  ## with extended information for each email address indicating if the address
  ## has been verified and if it's primary email address for GitHub.
  ## Until API v3 is finalized, use the application/vnd.github.v3 media type to
  ## get other response format.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_39463075 = newJObject()
  add(header_39463075, "Accept", newJString(Accept))
  result = call_39463074.call(nil, nil, header_39463075, nil, nil)

var getUserEmails* = Call_GetUserEmails_39463069(name: "getUserEmails",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/emails",
    validator: validate_GetUserEmails_39463070, base: "/", url: url_GetUserEmails_39463071,
    schemes: {Scheme.Https})
type
  Call_DeleteUserEmails_39463085 = ref object of OpenApiRestCall_39460352
proc url_DeleteUserEmails_39463087(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DeleteUserEmails_39463086(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Delete email address(es).
  ## You can include a single email address or an array of addresses.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463088 = header.getOrDefault("Accept")
  valid_39463088 = validateParameter(valid_39463088, JString, required = false,
                                   default = nil)
  if valid_39463088 != nil:
    section.add "Accept", valid_39463088
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39463090: Call_DeleteUserEmails_39463085; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete email address(es).
  ## You can include a single email address or an array of addresses.
  ## 
  ## 
  let valid = call_39463090.validator(path, query, header, formData, body, _)
  let scheme = call_39463090.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463090.url(scheme.get, call_39463090.host, call_39463090.base,
                           call_39463090.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463090, uri, valid, _)

proc call*(call_39463091: Call_DeleteUserEmails_39463085; body: JsonNode;
          Accept: string = ""): Recallable =
  ## deleteUserEmails
  ## Delete email address(es).
  ## You can include a single email address or an array of addresses.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  var header_39463092 = newJObject()
  var body_39463093 = newJObject()
  add(header_39463092, "Accept", newJString(Accept))
  if body != nil:
    body_39463093 = body
  result = call_39463091.call(nil, nil, header_39463092, nil, body_39463093)

var deleteUserEmails* = Call_DeleteUserEmails_39463085(name: "deleteUserEmails",
    meth: HttpMethod.HttpDelete, host: "api.github.com", route: "/user/emails",
    validator: validate_DeleteUserEmails_39463086, base: "/",
    url: url_DeleteUserEmails_39463087, schemes: {Scheme.Https})
type
  Call_GetUserFollowers_39463094 = ref object of OpenApiRestCall_39460352
proc url_GetUserFollowers_39463096(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserFollowers_39463095(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List the authenticated user's followers
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463097 = header.getOrDefault("Accept")
  valid_39463097 = validateParameter(valid_39463097, JString, required = false,
                                   default = nil)
  if valid_39463097 != nil:
    section.add "Accept", valid_39463097
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463098: Call_GetUserFollowers_39463094; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List the authenticated user's followers
  ## 
  let valid = call_39463098.validator(path, query, header, formData, body, _)
  let scheme = call_39463098.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463098.url(scheme.get, call_39463098.host, call_39463098.base,
                           call_39463098.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463098, uri, valid, _)

proc call*(call_39463099: Call_GetUserFollowers_39463094; Accept: string = ""): Recallable =
  ## getUserFollowers
  ## List the authenticated user's followers
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_39463100 = newJObject()
  add(header_39463100, "Accept", newJString(Accept))
  result = call_39463099.call(nil, nil, header_39463100, nil, nil)

var getUserFollowers* = Call_GetUserFollowers_39463094(name: "getUserFollowers",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/followers",
    validator: validate_GetUserFollowers_39463095, base: "/",
    url: url_GetUserFollowers_39463096, schemes: {Scheme.Https})
type
  Call_GetUserFollowing_39463101 = ref object of OpenApiRestCall_39460352
proc url_GetUserFollowing_39463103(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserFollowing_39463102(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List who the authenticated user is following.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463104 = header.getOrDefault("Accept")
  valid_39463104 = validateParameter(valid_39463104, JString, required = false,
                                   default = nil)
  if valid_39463104 != nil:
    section.add "Accept", valid_39463104
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463105: Call_GetUserFollowing_39463101; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List who the authenticated user is following.
  ## 
  let valid = call_39463105.validator(path, query, header, formData, body, _)
  let scheme = call_39463105.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463105.url(scheme.get, call_39463105.host, call_39463105.base,
                           call_39463105.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463105, uri, valid, _)

proc call*(call_39463106: Call_GetUserFollowing_39463101; Accept: string = ""): Recallable =
  ## getUserFollowing
  ## List who the authenticated user is following.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_39463107 = newJObject()
  add(header_39463107, "Accept", newJString(Accept))
  result = call_39463106.call(nil, nil, header_39463107, nil, nil)

var getUserFollowing* = Call_GetUserFollowing_39463101(name: "getUserFollowing",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/following",
    validator: validate_GetUserFollowing_39463102, base: "/",
    url: url_GetUserFollowing_39463103, schemes: {Scheme.Https})
type
  Call_PutUserFollowingUsername_39463117 = ref object of OpenApiRestCall_39460352
proc url_PutUserFollowingUsername_39463119(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/following/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutUserFollowingUsername_39463118(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Follow a user.
  ## Following a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39463120 = path.getOrDefault("username")
  valid_39463120 = validateParameter(valid_39463120, JString, required = true,
                                   default = nil)
  if valid_39463120 != nil:
    section.add "username", valid_39463120
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463121 = header.getOrDefault("Accept")
  valid_39463121 = validateParameter(valid_39463121, JString, required = false,
                                   default = nil)
  if valid_39463121 != nil:
    section.add "Accept", valid_39463121
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463122: Call_PutUserFollowingUsername_39463117;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Follow a user.
  ## Following a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  let valid = call_39463122.validator(path, query, header, formData, body, _)
  let scheme = call_39463122.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463122.url(scheme.get, call_39463122.host, call_39463122.base,
                           call_39463122.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463122, uri, valid, _)

proc call*(call_39463123: Call_PutUserFollowingUsername_39463117; username: string;
          Accept: string = ""): Recallable =
  ## putUserFollowingUsername
  ## Follow a user.
  ## Following a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39463124 = newJObject()
  var header_39463125 = newJObject()
  add(path_39463124, "username", newJString(username))
  add(header_39463125, "Accept", newJString(Accept))
  result = call_39463123.call(path_39463124, nil, header_39463125, nil, nil)

var putUserFollowingUsername* = Call_PutUserFollowingUsername_39463117(
    name: "putUserFollowingUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/user/following/{username}",
    validator: validate_PutUserFollowingUsername_39463118, base: "/",
    url: url_PutUserFollowingUsername_39463119, schemes: {Scheme.Https})
type
  Call_GetUserFollowingUsername_39463108 = ref object of OpenApiRestCall_39460352
proc url_GetUserFollowingUsername_39463110(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/following/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserFollowingUsername_39463109(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Check if you are following a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39463111 = path.getOrDefault("username")
  valid_39463111 = validateParameter(valid_39463111, JString, required = true,
                                   default = nil)
  if valid_39463111 != nil:
    section.add "username", valid_39463111
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463112 = header.getOrDefault("Accept")
  valid_39463112 = validateParameter(valid_39463112, JString, required = false,
                                   default = nil)
  if valid_39463112 != nil:
    section.add "Accept", valid_39463112
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463113: Call_GetUserFollowingUsername_39463108;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if you are following a user.
  ## 
  let valid = call_39463113.validator(path, query, header, formData, body, _)
  let scheme = call_39463113.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463113.url(scheme.get, call_39463113.host, call_39463113.base,
                           call_39463113.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463113, uri, valid, _)

proc call*(call_39463114: Call_GetUserFollowingUsername_39463108; username: string;
          Accept: string = ""): Recallable =
  ## getUserFollowingUsername
  ## Check if you are following a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39463115 = newJObject()
  var header_39463116 = newJObject()
  add(path_39463115, "username", newJString(username))
  add(header_39463116, "Accept", newJString(Accept))
  result = call_39463114.call(path_39463115, nil, header_39463116, nil, nil)

var getUserFollowingUsername* = Call_GetUserFollowingUsername_39463108(
    name: "getUserFollowingUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/user/following/{username}",
    validator: validate_GetUserFollowingUsername_39463109, base: "/",
    url: url_GetUserFollowingUsername_39463110, schemes: {Scheme.Https})
type
  Call_DeleteUserFollowingUsername_39463126 = ref object of OpenApiRestCall_39460352
proc url_DeleteUserFollowingUsername_39463128(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/following/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserFollowingUsername_39463127(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Unfollow a user.
  ## Unfollowing a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39463129 = path.getOrDefault("username")
  valid_39463129 = validateParameter(valid_39463129, JString, required = true,
                                   default = nil)
  if valid_39463129 != nil:
    section.add "username", valid_39463129
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463130 = header.getOrDefault("Accept")
  valid_39463130 = validateParameter(valid_39463130, JString, required = false,
                                   default = nil)
  if valid_39463130 != nil:
    section.add "Accept", valid_39463130
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463131: Call_DeleteUserFollowingUsername_39463126;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Unfollow a user.
  ## Unfollowing a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  let valid = call_39463131.validator(path, query, header, formData, body, _)
  let scheme = call_39463131.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463131.url(scheme.get, call_39463131.host, call_39463131.base,
                           call_39463131.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463131, uri, valid, _)

proc call*(call_39463132: Call_DeleteUserFollowingUsername_39463126;
          username: string; Accept: string = ""): Recallable =
  ## deleteUserFollowingUsername
  ## Unfollow a user.
  ## Unfollowing a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39463133 = newJObject()
  var header_39463134 = newJObject()
  add(path_39463133, "username", newJString(username))
  add(header_39463134, "Accept", newJString(Accept))
  result = call_39463132.call(path_39463133, nil, header_39463134, nil, nil)

var deleteUserFollowingUsername* = Call_DeleteUserFollowingUsername_39463126(
    name: "deleteUserFollowingUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/following/{username}",
    validator: validate_DeleteUserFollowingUsername_39463127, base: "/",
    url: url_DeleteUserFollowingUsername_39463128, schemes: {Scheme.Https})
type
  Call_GetUserIssues_39463135 = ref object of OpenApiRestCall_39460352
proc url_GetUserIssues_39463137(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserIssues_39463136(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## List issues.
  ## List all issues across owned and member repositories for the authenticated
  ## user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString (required)
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: JString (required)
  ##   direction: JString (required)
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_39463138 = query.getOrDefault("state")
  valid_39463138 = validateParameter(valid_39463138, JString, required = true,
                                   default = newJString("open"))
  if valid_39463138 != nil:
    section.add "state", valid_39463138
  var valid_39463139 = query.getOrDefault("labels")
  valid_39463139 = validateParameter(valid_39463139, JString, required = true,
                                   default = nil)
  if valid_39463139 != nil:
    section.add "labels", valid_39463139
  var valid_39463140 = query.getOrDefault("sort")
  valid_39463140 = validateParameter(valid_39463140, JString, required = true,
                                   default = newJString("created"))
  if valid_39463140 != nil:
    section.add "sort", valid_39463140
  var valid_39463141 = query.getOrDefault("direction")
  valid_39463141 = validateParameter(valid_39463141, JString, required = true,
                                   default = newJString("desc"))
  if valid_39463141 != nil:
    section.add "direction", valid_39463141
  var valid_39463142 = query.getOrDefault("filter")
  valid_39463142 = validateParameter(valid_39463142, JString, required = true,
                                   default = newJString("all"))
  if valid_39463142 != nil:
    section.add "filter", valid_39463142
  var valid_39463143 = query.getOrDefault("since")
  valid_39463143 = validateParameter(valid_39463143, JString, required = false,
                                   default = nil)
  if valid_39463143 != nil:
    section.add "since", valid_39463143
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463144 = header.getOrDefault("Accept")
  valid_39463144 = validateParameter(valid_39463144, JString, required = false,
                                   default = nil)
  if valid_39463144 != nil:
    section.add "Accept", valid_39463144
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463145: Call_GetUserIssues_39463135; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List issues.
  ## List all issues across owned and member repositories for the authenticated
  ## user.
  ## 
  ## 
  let valid = call_39463145.validator(path, query, header, formData, body, _)
  let scheme = call_39463145.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463145.url(scheme.get, call_39463145.host, call_39463145.base,
                           call_39463145.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463145, uri, valid, _)

proc call*(call_39463146: Call_GetUserIssues_39463135; labels: string;
          state: string = "open"; Accept: string = ""; sort: string = "created";
          direction: string = "desc"; filter: string = "all"; since: string = ""): Recallable =
  ## getUserIssues
  ## List issues.
  ## List all issues across owned and member repositories for the authenticated
  ## user.
  ## 
  ##   state: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: string (required)
  ##   direction: string (required)
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  var query_39463147 = newJObject()
  var header_39463148 = newJObject()
  add(query_39463147, "state", newJString(state))
  add(header_39463148, "Accept", newJString(Accept))
  add(query_39463147, "labels", newJString(labels))
  add(query_39463147, "sort", newJString(sort))
  add(query_39463147, "direction", newJString(direction))
  add(query_39463147, "filter", newJString(filter))
  add(query_39463147, "since", newJString(since))
  result = call_39463146.call(nil, query_39463147, header_39463148, nil, nil)

var getUserIssues* = Call_GetUserIssues_39463135(name: "getUserIssues",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/issues",
    validator: validate_GetUserIssues_39463136, base: "/", url: url_GetUserIssues_39463137,
    schemes: {Scheme.Https})
type
  Call_PostUserKeys_39463156 = ref object of OpenApiRestCall_39460352
proc url_PostUserKeys_39463158(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostUserKeys_39463157(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## Create a public key.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463159 = header.getOrDefault("Accept")
  valid_39463159 = validateParameter(valid_39463159, JString, required = false,
                                   default = nil)
  if valid_39463159 != nil:
    section.add "Accept", valid_39463159
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39463161: Call_PostUserKeys_39463156; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a public key.
  ## 
  let valid = call_39463161.validator(path, query, header, formData, body, _)
  let scheme = call_39463161.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463161.url(scheme.get, call_39463161.host, call_39463161.base,
                           call_39463161.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463161, uri, valid, _)

proc call*(call_39463162: Call_PostUserKeys_39463156; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postUserKeys
  ## Create a public key.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_39463163 = newJObject()
  var body_39463164 = newJObject()
  add(header_39463163, "Accept", newJString(Accept))
  if body != nil:
    body_39463164 = body
  result = call_39463162.call(nil, nil, header_39463163, nil, body_39463164)

var postUserKeys* = Call_PostUserKeys_39463156(name: "postUserKeys",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/user/keys",
    validator: validate_PostUserKeys_39463157, base: "/", url: url_PostUserKeys_39463158,
    schemes: {Scheme.Https})
type
  Call_GetUserKeys_39463149 = ref object of OpenApiRestCall_39460352
proc url_GetUserKeys_39463151(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserKeys_39463150(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List your public keys.
  ## Lists the current user's keys. Management of public keys via the API requires
  ## that you are authenticated through basic auth, or OAuth with the 'user', 'write:public_key' scopes.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463152 = header.getOrDefault("Accept")
  valid_39463152 = validateParameter(valid_39463152, JString, required = false,
                                   default = nil)
  if valid_39463152 != nil:
    section.add "Accept", valid_39463152
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463153: Call_GetUserKeys_39463149; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List your public keys.
  ## Lists the current user's keys. Management of public keys via the API requires
  ## that you are authenticated through basic auth, or OAuth with the 'user', 'write:public_key' scopes.
  ## 
  ## 
  let valid = call_39463153.validator(path, query, header, formData, body, _)
  let scheme = call_39463153.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463153.url(scheme.get, call_39463153.host, call_39463153.base,
                           call_39463153.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463153, uri, valid, _)

proc call*(call_39463154: Call_GetUserKeys_39463149; Accept: string = ""): Recallable =
  ## getUserKeys
  ## List your public keys.
  ## Lists the current user's keys. Management of public keys via the API requires
  ## that you are authenticated through basic auth, or OAuth with the 'user', 'write:public_key' scopes.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_39463155 = newJObject()
  add(header_39463155, "Accept", newJString(Accept))
  result = call_39463154.call(nil, nil, header_39463155, nil, nil)

var getUserKeys* = Call_GetUserKeys_39463149(name: "getUserKeys",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/keys",
    validator: validate_GetUserKeys_39463150, base: "/", url: url_GetUserKeys_39463151,
    schemes: {Scheme.Https})
type
  Call_GetUserKeysKeyId_39463165 = ref object of OpenApiRestCall_39460352
proc url_GetUserKeysKeyId_39463167(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/keys/"),
               (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserKeysKeyId_39463166(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get a single public key.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyId: JInt (required)
  ##        : ID of key.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyId` field"
  var valid_39463168 = path.getOrDefault("keyId")
  valid_39463168 = validateParameter(valid_39463168, JInt, required = true,
                                   default = nil)
  if valid_39463168 != nil:
    section.add "keyId", valid_39463168
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463169 = header.getOrDefault("Accept")
  valid_39463169 = validateParameter(valid_39463169, JString, required = false,
                                   default = nil)
  if valid_39463169 != nil:
    section.add "Accept", valid_39463169
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463170: Call_GetUserKeysKeyId_39463165; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single public key.
  ## 
  let valid = call_39463170.validator(path, query, header, formData, body, _)
  let scheme = call_39463170.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463170.url(scheme.get, call_39463170.host, call_39463170.base,
                           call_39463170.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463170, uri, valid, _)

proc call*(call_39463171: Call_GetUserKeysKeyId_39463165; keyId: int;
          Accept: string = ""): Recallable =
  ## getUserKeysKeyId
  ## Get a single public key.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   keyId: int (required)
  ##        : ID of key.
  var path_39463172 = newJObject()
  var header_39463173 = newJObject()
  add(header_39463173, "Accept", newJString(Accept))
  add(path_39463172, "keyId", newJInt(keyId))
  result = call_39463171.call(path_39463172, nil, header_39463173, nil, nil)

var getUserKeysKeyId* = Call_GetUserKeysKeyId_39463165(name: "getUserKeysKeyId",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/keys/{keyId}",
    validator: validate_GetUserKeysKeyId_39463166, base: "/",
    url: url_GetUserKeysKeyId_39463167, schemes: {Scheme.Https})
type
  Call_DeleteUserKeysKeyId_39463174 = ref object of OpenApiRestCall_39460352
proc url_DeleteUserKeysKeyId_39463176(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/keys/"),
               (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserKeysKeyId_39463175(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Delete a public key. Removes a public key. Requires that you are authenticated via Basic Auth or via OAuth with at least admin:public_key scope.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyId: JInt (required)
  ##        : ID of key.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyId` field"
  var valid_39463177 = path.getOrDefault("keyId")
  valid_39463177 = validateParameter(valid_39463177, JInt, required = true,
                                   default = nil)
  if valid_39463177 != nil:
    section.add "keyId", valid_39463177
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463178 = header.getOrDefault("Accept")
  valid_39463178 = validateParameter(valid_39463178, JString, required = false,
                                   default = nil)
  if valid_39463178 != nil:
    section.add "Accept", valid_39463178
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463179: Call_DeleteUserKeysKeyId_39463174; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a public key. Removes a public key. Requires that you are authenticated via Basic Auth or via OAuth with at least admin:public_key scope.
  ## 
  let valid = call_39463179.validator(path, query, header, formData, body, _)
  let scheme = call_39463179.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463179.url(scheme.get, call_39463179.host, call_39463179.base,
                           call_39463179.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463179, uri, valid, _)

proc call*(call_39463180: Call_DeleteUserKeysKeyId_39463174; keyId: int;
          Accept: string = ""): Recallable =
  ## deleteUserKeysKeyId
  ## Delete a public key. Removes a public key. Requires that you are authenticated via Basic Auth or via OAuth with at least admin:public_key scope.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   keyId: int (required)
  ##        : ID of key.
  var path_39463181 = newJObject()
  var header_39463182 = newJObject()
  add(header_39463182, "Accept", newJString(Accept))
  add(path_39463181, "keyId", newJInt(keyId))
  result = call_39463180.call(path_39463181, nil, header_39463182, nil, nil)

var deleteUserKeysKeyId* = Call_DeleteUserKeysKeyId_39463174(
    name: "deleteUserKeysKeyId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/keys/{keyId}",
    validator: validate_DeleteUserKeysKeyId_39463175, base: "/",
    url: url_DeleteUserKeysKeyId_39463176, schemes: {Scheme.Https})
type
  Call_GetUserOrgs_39463183 = ref object of OpenApiRestCall_39460352
proc url_GetUserOrgs_39463185(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserOrgs_39463184(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List public and private organizations for the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463186 = header.getOrDefault("Accept")
  valid_39463186 = validateParameter(valid_39463186, JString, required = false,
                                   default = nil)
  if valid_39463186 != nil:
    section.add "Accept", valid_39463186
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463187: Call_GetUserOrgs_39463183; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List public and private organizations for the authenticated user.
  ## 
  let valid = call_39463187.validator(path, query, header, formData, body, _)
  let scheme = call_39463187.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463187.url(scheme.get, call_39463187.host, call_39463187.base,
                           call_39463187.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463187, uri, valid, _)

proc call*(call_39463188: Call_GetUserOrgs_39463183; Accept: string = ""): Recallable =
  ## getUserOrgs
  ## List public and private organizations for the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_39463189 = newJObject()
  add(header_39463189, "Accept", newJString(Accept))
  result = call_39463188.call(nil, nil, header_39463189, nil, nil)

var getUserOrgs* = Call_GetUserOrgs_39463183(name: "getUserOrgs",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/orgs",
    validator: validate_GetUserOrgs_39463184, base: "/", url: url_GetUserOrgs_39463185,
    schemes: {Scheme.Https})
type
  Call_PostUserRepos_39463199 = ref object of OpenApiRestCall_39460352
proc url_PostUserRepos_39463201(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostUserRepos_39463200(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463202 = header.getOrDefault("Accept")
  valid_39463202 = validateParameter(valid_39463202, JString, required = false,
                                   default = nil)
  if valid_39463202 != nil:
    section.add "Accept", valid_39463202
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39463204: Call_PostUserRepos_39463199; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  let valid = call_39463204.validator(path, query, header, formData, body, _)
  let scheme = call_39463204.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463204.url(scheme.get, call_39463204.host, call_39463204.base,
                           call_39463204.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463204, uri, valid, _)

proc call*(call_39463205: Call_PostUserRepos_39463199; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postUserRepos
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_39463206 = newJObject()
  var body_39463207 = newJObject()
  add(header_39463206, "Accept", newJString(Accept))
  if body != nil:
    body_39463207 = body
  result = call_39463205.call(nil, nil, header_39463206, nil, body_39463207)

var postUserRepos* = Call_PostUserRepos_39463199(name: "postUserRepos",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/user/repos",
    validator: validate_PostUserRepos_39463200, base: "/", url: url_PostUserRepos_39463201,
    schemes: {Scheme.Https})
type
  Call_GetUserRepos_39463190 = ref object of OpenApiRestCall_39460352
proc url_GetUserRepos_39463192(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserRepos_39463191(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## List repositories for the authenticated user. Note that this does not include
  ## repositories owned by organizations which the user can access. You can lis
  ## user organizations and list organization repositories separately.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   type: JString
  section = newJObject()
  var valid_39463193 = query.getOrDefault("type")
  valid_39463193 = validateParameter(valid_39463193, JString, required = false,
                                   default = newJString("all"))
  if valid_39463193 != nil:
    section.add "type", valid_39463193
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463194 = header.getOrDefault("Accept")
  valid_39463194 = validateParameter(valid_39463194, JString, required = false,
                                   default = nil)
  if valid_39463194 != nil:
    section.add "Accept", valid_39463194
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463195: Call_GetUserRepos_39463190; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List repositories for the authenticated user. Note that this does not include
  ## repositories owned by organizations which the user can access. You can lis
  ## user organizations and list organization repositories separately.
  ## 
  ## 
  let valid = call_39463195.validator(path, query, header, formData, body, _)
  let scheme = call_39463195.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463195.url(scheme.get, call_39463195.host, call_39463195.base,
                           call_39463195.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463195, uri, valid, _)

proc call*(call_39463196: Call_GetUserRepos_39463190; Accept: string = "";
          `type`: string = "all"): Recallable =
  ## getUserRepos
  ## List repositories for the authenticated user. Note that this does not include
  ## repositories owned by organizations which the user can access. You can lis
  ## user organizations and list organization repositories separately.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   type: string
  var query_39463197 = newJObject()
  var header_39463198 = newJObject()
  add(header_39463198, "Accept", newJString(Accept))
  add(query_39463197, "type", newJString(`type`))
  result = call_39463196.call(nil, query_39463197, header_39463198, nil, nil)

var getUserRepos* = Call_GetUserRepos_39463190(name: "getUserRepos",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/repos",
    validator: validate_GetUserRepos_39463191, base: "/", url: url_GetUserRepos_39463192,
    schemes: {Scheme.Https})
type
  Call_GetUserStarred_39463208 = ref object of OpenApiRestCall_39460352
proc url_GetUserStarred_39463210(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserStarred_39463209(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List repositories being starred by the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  section = newJObject()
  var valid_39463211 = query.getOrDefault("sort")
  valid_39463211 = validateParameter(valid_39463211, JString, required = false,
                                   default = newJString("created"))
  if valid_39463211 != nil:
    section.add "sort", valid_39463211
  var valid_39463212 = query.getOrDefault("direction")
  valid_39463212 = validateParameter(valid_39463212, JString, required = false,
                                   default = nil)
  if valid_39463212 != nil:
    section.add "direction", valid_39463212
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463213 = header.getOrDefault("Accept")
  valid_39463213 = validateParameter(valid_39463213, JString, required = false,
                                   default = nil)
  if valid_39463213 != nil:
    section.add "Accept", valid_39463213
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463214: Call_GetUserStarred_39463208; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List repositories being starred by the authenticated user.
  ## 
  let valid = call_39463214.validator(path, query, header, formData, body, _)
  let scheme = call_39463214.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463214.url(scheme.get, call_39463214.host, call_39463214.base,
                           call_39463214.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463214, uri, valid, _)

proc call*(call_39463215: Call_GetUserStarred_39463208; Accept: string = "";
          sort: string = "created"; direction: string = ""): Recallable =
  ## getUserStarred
  ## List repositories being starred by the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  var query_39463216 = newJObject()
  var header_39463217 = newJObject()
  add(header_39463217, "Accept", newJString(Accept))
  add(query_39463216, "sort", newJString(sort))
  add(query_39463216, "direction", newJString(direction))
  result = call_39463215.call(nil, query_39463216, header_39463217, nil, nil)

var getUserStarred* = Call_GetUserStarred_39463208(name: "getUserStarred",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/starred",
    validator: validate_GetUserStarred_39463209, base: "/", url: url_GetUserStarred_39463210,
    schemes: {Scheme.Https})
type
  Call_PutUserStarredOwnerRepo_39463228 = ref object of OpenApiRestCall_39460352
proc url_PutUserStarredOwnerRepo_39463230(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/starred/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutUserStarredOwnerRepo_39463229(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Star a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  ##   repo: JString (required)
  ##       : Name of a repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39463231 = path.getOrDefault("owner")
  valid_39463231 = validateParameter(valid_39463231, JString, required = true,
                                   default = nil)
  if valid_39463231 != nil:
    section.add "owner", valid_39463231
  var valid_39463232 = path.getOrDefault("repo")
  valid_39463232 = validateParameter(valid_39463232, JString, required = true,
                                   default = nil)
  if valid_39463232 != nil:
    section.add "repo", valid_39463232
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463233 = header.getOrDefault("Accept")
  valid_39463233 = validateParameter(valid_39463233, JString, required = false,
                                   default = nil)
  if valid_39463233 != nil:
    section.add "Accept", valid_39463233
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463234: Call_PutUserStarredOwnerRepo_39463228;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Star a repository.
  ## 
  let valid = call_39463234.validator(path, query, header, formData, body, _)
  let scheme = call_39463234.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463234.url(scheme.get, call_39463234.host, call_39463234.base,
                           call_39463234.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463234, uri, valid, _)

proc call*(call_39463235: Call_PutUserStarredOwnerRepo_39463228; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## putUserStarredOwnerRepo
  ## Star a repository.
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  var path_39463236 = newJObject()
  var header_39463237 = newJObject()
  add(path_39463236, "owner", newJString(owner))
  add(header_39463237, "Accept", newJString(Accept))
  add(path_39463236, "repo", newJString(repo))
  result = call_39463235.call(path_39463236, nil, header_39463237, nil, nil)

var putUserStarredOwnerRepo* = Call_PutUserStarredOwnerRepo_39463228(
    name: "putUserStarredOwnerRepo", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/user/starred/{owner}/{repo}",
    validator: validate_PutUserStarredOwnerRepo_39463229, base: "/",
    url: url_PutUserStarredOwnerRepo_39463230, schemes: {Scheme.Https})
type
  Call_GetUserStarredOwnerRepo_39463218 = ref object of OpenApiRestCall_39460352
proc url_GetUserStarredOwnerRepo_39463220(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/starred/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserStarredOwnerRepo_39463219(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Check if you are starring a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  ##   repo: JString (required)
  ##       : Name of a repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39463221 = path.getOrDefault("owner")
  valid_39463221 = validateParameter(valid_39463221, JString, required = true,
                                   default = nil)
  if valid_39463221 != nil:
    section.add "owner", valid_39463221
  var valid_39463222 = path.getOrDefault("repo")
  valid_39463222 = validateParameter(valid_39463222, JString, required = true,
                                   default = nil)
  if valid_39463222 != nil:
    section.add "repo", valid_39463222
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463223 = header.getOrDefault("Accept")
  valid_39463223 = validateParameter(valid_39463223, JString, required = false,
                                   default = nil)
  if valid_39463223 != nil:
    section.add "Accept", valid_39463223
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463224: Call_GetUserStarredOwnerRepo_39463218;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if you are starring a repository.
  ## 
  let valid = call_39463224.validator(path, query, header, formData, body, _)
  let scheme = call_39463224.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463224.url(scheme.get, call_39463224.host, call_39463224.base,
                           call_39463224.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463224, uri, valid, _)

proc call*(call_39463225: Call_GetUserStarredOwnerRepo_39463218; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getUserStarredOwnerRepo
  ## Check if you are starring a repository.
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  var path_39463226 = newJObject()
  var header_39463227 = newJObject()
  add(path_39463226, "owner", newJString(owner))
  add(header_39463227, "Accept", newJString(Accept))
  add(path_39463226, "repo", newJString(repo))
  result = call_39463225.call(path_39463226, nil, header_39463227, nil, nil)

var getUserStarredOwnerRepo* = Call_GetUserStarredOwnerRepo_39463218(
    name: "getUserStarredOwnerRepo", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/user/starred/{owner}/{repo}",
    validator: validate_GetUserStarredOwnerRepo_39463219, base: "/",
    url: url_GetUserStarredOwnerRepo_39463220, schemes: {Scheme.Https})
type
  Call_DeleteUserStarredOwnerRepo_39463238 = ref object of OpenApiRestCall_39460352
proc url_DeleteUserStarredOwnerRepo_39463240(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/starred/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserStarredOwnerRepo_39463239(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Unstar a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  ##   repo: JString (required)
  ##       : Name of a repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39463241 = path.getOrDefault("owner")
  valid_39463241 = validateParameter(valid_39463241, JString, required = true,
                                   default = nil)
  if valid_39463241 != nil:
    section.add "owner", valid_39463241
  var valid_39463242 = path.getOrDefault("repo")
  valid_39463242 = validateParameter(valid_39463242, JString, required = true,
                                   default = nil)
  if valid_39463242 != nil:
    section.add "repo", valid_39463242
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463243 = header.getOrDefault("Accept")
  valid_39463243 = validateParameter(valid_39463243, JString, required = false,
                                   default = nil)
  if valid_39463243 != nil:
    section.add "Accept", valid_39463243
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463244: Call_DeleteUserStarredOwnerRepo_39463238;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Unstar a repository
  ## 
  let valid = call_39463244.validator(path, query, header, formData, body, _)
  let scheme = call_39463244.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463244.url(scheme.get, call_39463244.host, call_39463244.base,
                           call_39463244.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463244, uri, valid, _)

proc call*(call_39463245: Call_DeleteUserStarredOwnerRepo_39463238; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## deleteUserStarredOwnerRepo
  ## Unstar a repository
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  var path_39463246 = newJObject()
  var header_39463247 = newJObject()
  add(path_39463246, "owner", newJString(owner))
  add(header_39463247, "Accept", newJString(Accept))
  add(path_39463246, "repo", newJString(repo))
  result = call_39463245.call(path_39463246, nil, header_39463247, nil, nil)

var deleteUserStarredOwnerRepo* = Call_DeleteUserStarredOwnerRepo_39463238(
    name: "deleteUserStarredOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/starred/{owner}/{repo}",
    validator: validate_DeleteUserStarredOwnerRepo_39463239, base: "/",
    url: url_DeleteUserStarredOwnerRepo_39463240, schemes: {Scheme.Https})
type
  Call_GetUserSubscriptions_39463248 = ref object of OpenApiRestCall_39460352
proc url_GetUserSubscriptions_39463250(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserSubscriptions_39463249(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List repositories being watched by the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463251 = header.getOrDefault("Accept")
  valid_39463251 = validateParameter(valid_39463251, JString, required = false,
                                   default = nil)
  if valid_39463251 != nil:
    section.add "Accept", valid_39463251
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463252: Call_GetUserSubscriptions_39463248; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List repositories being watched by the authenticated user.
  ## 
  let valid = call_39463252.validator(path, query, header, formData, body, _)
  let scheme = call_39463252.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463252.url(scheme.get, call_39463252.host, call_39463252.base,
                           call_39463252.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463252, uri, valid, _)

proc call*(call_39463253: Call_GetUserSubscriptions_39463248; Accept: string = ""): Recallable =
  ## getUserSubscriptions
  ## List repositories being watched by the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_39463254 = newJObject()
  add(header_39463254, "Accept", newJString(Accept))
  result = call_39463253.call(nil, nil, header_39463254, nil, nil)

var getUserSubscriptions* = Call_GetUserSubscriptions_39463248(
    name: "getUserSubscriptions", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/user/subscriptions", validator: validate_GetUserSubscriptions_39463249,
    base: "/", url: url_GetUserSubscriptions_39463250, schemes: {Scheme.Https})
type
  Call_PutUserSubscriptionsOwnerRepo_39463265 = ref object of OpenApiRestCall_39460352
proc url_PutUserSubscriptionsOwnerRepo_39463267(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/subscriptions/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutUserSubscriptionsOwnerRepo_39463266(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Watch a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of the owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39463268 = path.getOrDefault("owner")
  valid_39463268 = validateParameter(valid_39463268, JString, required = true,
                                   default = nil)
  if valid_39463268 != nil:
    section.add "owner", valid_39463268
  var valid_39463269 = path.getOrDefault("repo")
  valid_39463269 = validateParameter(valid_39463269, JString, required = true,
                                   default = nil)
  if valid_39463269 != nil:
    section.add "repo", valid_39463269
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463270 = header.getOrDefault("Accept")
  valid_39463270 = validateParameter(valid_39463270, JString, required = false,
                                   default = nil)
  if valid_39463270 != nil:
    section.add "Accept", valid_39463270
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463271: Call_PutUserSubscriptionsOwnerRepo_39463265;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Watch a repository.
  ## 
  let valid = call_39463271.validator(path, query, header, formData, body, _)
  let scheme = call_39463271.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463271.url(scheme.get, call_39463271.host, call_39463271.base,
                           call_39463271.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463271, uri, valid, _)

proc call*(call_39463272: Call_PutUserSubscriptionsOwnerRepo_39463265;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## putUserSubscriptionsOwnerRepo
  ## Watch a repository.
  ##   owner: string (required)
  ##        : Name of the owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39463273 = newJObject()
  var header_39463274 = newJObject()
  add(path_39463273, "owner", newJString(owner))
  add(header_39463274, "Accept", newJString(Accept))
  add(path_39463273, "repo", newJString(repo))
  result = call_39463272.call(path_39463273, nil, header_39463274, nil, nil)

var putUserSubscriptionsOwnerRepo* = Call_PutUserSubscriptionsOwnerRepo_39463265(
    name: "putUserSubscriptionsOwnerRepo", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/user/subscriptions/{owner}/{repo}",
    validator: validate_PutUserSubscriptionsOwnerRepo_39463266, base: "/",
    url: url_PutUserSubscriptionsOwnerRepo_39463267, schemes: {Scheme.Https})
type
  Call_GetUserSubscriptionsOwnerRepo_39463255 = ref object of OpenApiRestCall_39460352
proc url_GetUserSubscriptionsOwnerRepo_39463257(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/subscriptions/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserSubscriptionsOwnerRepo_39463256(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Check if you are watching a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of the owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39463258 = path.getOrDefault("owner")
  valid_39463258 = validateParameter(valid_39463258, JString, required = true,
                                   default = nil)
  if valid_39463258 != nil:
    section.add "owner", valid_39463258
  var valid_39463259 = path.getOrDefault("repo")
  valid_39463259 = validateParameter(valid_39463259, JString, required = true,
                                   default = nil)
  if valid_39463259 != nil:
    section.add "repo", valid_39463259
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463260 = header.getOrDefault("Accept")
  valid_39463260 = validateParameter(valid_39463260, JString, required = false,
                                   default = nil)
  if valid_39463260 != nil:
    section.add "Accept", valid_39463260
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463261: Call_GetUserSubscriptionsOwnerRepo_39463255;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if you are watching a repository.
  ## 
  let valid = call_39463261.validator(path, query, header, formData, body, _)
  let scheme = call_39463261.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463261.url(scheme.get, call_39463261.host, call_39463261.base,
                           call_39463261.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463261, uri, valid, _)

proc call*(call_39463262: Call_GetUserSubscriptionsOwnerRepo_39463255;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getUserSubscriptionsOwnerRepo
  ## Check if you are watching a repository.
  ##   owner: string (required)
  ##        : Name of the owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39463263 = newJObject()
  var header_39463264 = newJObject()
  add(path_39463263, "owner", newJString(owner))
  add(header_39463264, "Accept", newJString(Accept))
  add(path_39463263, "repo", newJString(repo))
  result = call_39463262.call(path_39463263, nil, header_39463264, nil, nil)

var getUserSubscriptionsOwnerRepo* = Call_GetUserSubscriptionsOwnerRepo_39463255(
    name: "getUserSubscriptionsOwnerRepo", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/user/subscriptions/{owner}/{repo}",
    validator: validate_GetUserSubscriptionsOwnerRepo_39463256, base: "/",
    url: url_GetUserSubscriptionsOwnerRepo_39463257, schemes: {Scheme.Https})
type
  Call_DeleteUserSubscriptionsOwnerRepo_39463275 = ref object of OpenApiRestCall_39460352
proc url_DeleteUserSubscriptionsOwnerRepo_39463277(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/subscriptions/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserSubscriptionsOwnerRepo_39463276(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Stop watching a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of the owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39463278 = path.getOrDefault("owner")
  valid_39463278 = validateParameter(valid_39463278, JString, required = true,
                                   default = nil)
  if valid_39463278 != nil:
    section.add "owner", valid_39463278
  var valid_39463279 = path.getOrDefault("repo")
  valid_39463279 = validateParameter(valid_39463279, JString, required = true,
                                   default = nil)
  if valid_39463279 != nil:
    section.add "repo", valid_39463279
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463280 = header.getOrDefault("Accept")
  valid_39463280 = validateParameter(valid_39463280, JString, required = false,
                                   default = nil)
  if valid_39463280 != nil:
    section.add "Accept", valid_39463280
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463281: Call_DeleteUserSubscriptionsOwnerRepo_39463275;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Stop watching a repository
  ## 
  let valid = call_39463281.validator(path, query, header, formData, body, _)
  let scheme = call_39463281.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463281.url(scheme.get, call_39463281.host, call_39463281.base,
                           call_39463281.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463281, uri, valid, _)

proc call*(call_39463282: Call_DeleteUserSubscriptionsOwnerRepo_39463275;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## deleteUserSubscriptionsOwnerRepo
  ## Stop watching a repository
  ##   owner: string (required)
  ##        : Name of the owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39463283 = newJObject()
  var header_39463284 = newJObject()
  add(path_39463283, "owner", newJString(owner))
  add(header_39463284, "Accept", newJString(Accept))
  add(path_39463283, "repo", newJString(repo))
  result = call_39463282.call(path_39463283, nil, header_39463284, nil, nil)

var deleteUserSubscriptionsOwnerRepo* = Call_DeleteUserSubscriptionsOwnerRepo_39463275(
    name: "deleteUserSubscriptionsOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/subscriptions/{owner}/{repo}",
    validator: validate_DeleteUserSubscriptionsOwnerRepo_39463276, base: "/",
    url: url_DeleteUserSubscriptionsOwnerRepo_39463277, schemes: {Scheme.Https})
type
  Call_GetUserTeams_39463285 = ref object of OpenApiRestCall_39460352
proc url_GetUserTeams_39463287(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserTeams_39463286(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## List all of the teams across all of the organizations to which the authenticated user belongs. This method requires user or repo scope when authenticating via OAuth.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463288 = header.getOrDefault("Accept")
  valid_39463288 = validateParameter(valid_39463288, JString, required = false,
                                   default = nil)
  if valid_39463288 != nil:
    section.add "Accept", valid_39463288
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463289: Call_GetUserTeams_39463285; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List all of the teams across all of the organizations to which the authenticated user belongs. This method requires user or repo scope when authenticating via OAuth.
  ## 
  let valid = call_39463289.validator(path, query, header, formData, body, _)
  let scheme = call_39463289.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463289.url(scheme.get, call_39463289.host, call_39463289.base,
                           call_39463289.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463289, uri, valid, _)

proc call*(call_39463290: Call_GetUserTeams_39463285; Accept: string = ""): Recallable =
  ## getUserTeams
  ## List all of the teams across all of the organizations to which the authenticated user belongs. This method requires user or repo scope when authenticating via OAuth.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_39463291 = newJObject()
  add(header_39463291, "Accept", newJString(Accept))
  result = call_39463290.call(nil, nil, header_39463291, nil, nil)

var getUserTeams* = Call_GetUserTeams_39463285(name: "getUserTeams",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/teams",
    validator: validate_GetUserTeams_39463286, base: "/", url: url_GetUserTeams_39463287,
    schemes: {Scheme.Https})
type
  Call_GetUsers_39463292 = ref object of OpenApiRestCall_39460352
proc url_GetUsers_39463294(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUsers_39463293(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get all users.
  ## This provides a dump of every user, in the order that they signed up for GitHub.
  ## Note: Pagination is powered exclusively by the since parameter. Use the Link
  ## header to get the URL for the next page of users.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JInt
  ##        : The integer ID of the last user that you've seen.
  section = newJObject()
  var valid_39463295 = query.getOrDefault("since")
  valid_39463295 = validateParameter(valid_39463295, JInt, required = false,
                                   default = nil)
  if valid_39463295 != nil:
    section.add "since", valid_39463295
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463296 = header.getOrDefault("Accept")
  valid_39463296 = validateParameter(valid_39463296, JString, required = false,
                                   default = nil)
  if valid_39463296 != nil:
    section.add "Accept", valid_39463296
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463297: Call_GetUsers_39463292; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get all users.
  ## This provides a dump of every user, in the order that they signed up for GitHub.
  ## Note: Pagination is powered exclusively by the since parameter. Use the Link
  ## header to get the URL for the next page of users.
  ## 
  ## 
  let valid = call_39463297.validator(path, query, header, formData, body, _)
  let scheme = call_39463297.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463297.url(scheme.get, call_39463297.host, call_39463297.base,
                           call_39463297.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463297, uri, valid, _)

proc call*(call_39463298: Call_GetUsers_39463292; Accept: string = ""; since: int = 0): Recallable =
  ## getUsers
  ## Get all users.
  ## This provides a dump of every user, in the order that they signed up for GitHub.
  ## Note: Pagination is powered exclusively by the since parameter. Use the Link
  ## header to get the URL for the next page of users.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: int
  ##        : The integer ID of the last user that you've seen.
  var query_39463299 = newJObject()
  var header_39463300 = newJObject()
  add(header_39463300, "Accept", newJString(Accept))
  add(query_39463299, "since", newJInt(since))
  result = call_39463298.call(nil, query_39463299, header_39463300, nil, nil)

var getUsers* = Call_GetUsers_39463292(name: "getUsers", meth: HttpMethod.HttpGet,
                                    host: "api.github.com", route: "/users",
                                    validator: validate_GetUsers_39463293,
                                    base: "/", url: url_GetUsers_39463294,
                                    schemes: {Scheme.Https})
type
  Call_GetUsersUsername_39463301 = ref object of OpenApiRestCall_39460352
proc url_GetUsersUsername_39463303(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsername_39463302(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get a single user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39463304 = path.getOrDefault("username")
  valid_39463304 = validateParameter(valid_39463304, JString, required = true,
                                   default = nil)
  if valid_39463304 != nil:
    section.add "username", valid_39463304
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463305 = header.getOrDefault("Accept")
  valid_39463305 = validateParameter(valid_39463305, JString, required = false,
                                   default = nil)
  if valid_39463305 != nil:
    section.add "Accept", valid_39463305
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463306: Call_GetUsersUsername_39463301; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single user.
  ## 
  let valid = call_39463306.validator(path, query, header, formData, body, _)
  let scheme = call_39463306.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463306.url(scheme.get, call_39463306.host, call_39463306.base,
                           call_39463306.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463306, uri, valid, _)

proc call*(call_39463307: Call_GetUsersUsername_39463301; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsername
  ## Get a single user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39463308 = newJObject()
  var header_39463309 = newJObject()
  add(path_39463308, "username", newJString(username))
  add(header_39463309, "Accept", newJString(Accept))
  result = call_39463307.call(path_39463308, nil, header_39463309, nil, nil)

var getUsersUsername* = Call_GetUsersUsername_39463301(name: "getUsersUsername",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/users/{username}",
    validator: validate_GetUsersUsername_39463302, base: "/",
    url: url_GetUsersUsername_39463303, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameEvents_39463310 = ref object of OpenApiRestCall_39460352
proc url_GetUsersUsernameEvents_39463312(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameEvents_39463311(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39463313 = path.getOrDefault("username")
  valid_39463313 = validateParameter(valid_39463313, JString, required = true,
                                   default = nil)
  if valid_39463313 != nil:
    section.add "username", valid_39463313
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463314 = header.getOrDefault("Accept")
  valid_39463314 = validateParameter(valid_39463314, JString, required = false,
                                   default = nil)
  if valid_39463314 != nil:
    section.add "Accept", valid_39463314
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463315: Call_GetUsersUsernameEvents_39463310;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
  ## 
  let valid = call_39463315.validator(path, query, header, formData, body, _)
  let scheme = call_39463315.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463315.url(scheme.get, call_39463315.host, call_39463315.base,
                           call_39463315.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463315, uri, valid, _)

proc call*(call_39463316: Call_GetUsersUsernameEvents_39463310; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameEvents
  ## If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39463317 = newJObject()
  var header_39463318 = newJObject()
  add(path_39463317, "username", newJString(username))
  add(header_39463318, "Accept", newJString(Accept))
  result = call_39463316.call(path_39463317, nil, header_39463318, nil, nil)

var getUsersUsernameEvents* = Call_GetUsersUsernameEvents_39463310(
    name: "getUsersUsernameEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/events",
    validator: validate_GetUsersUsernameEvents_39463311, base: "/",
    url: url_GetUsersUsernameEvents_39463312, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameEventsOrgsOrg_39463319 = ref object of OpenApiRestCall_39460352
proc url_GetUsersUsernameEventsOrgsOrg_39463321(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/events/orgs/"),
               (kind: VariableSegment, value: "org")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameEventsOrgsOrg_39463320(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## This is the user's organization dashboard. You must be authenticated as the user to view this.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  ##   org: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39463322 = path.getOrDefault("username")
  valid_39463322 = validateParameter(valid_39463322, JString, required = true,
                                   default = nil)
  if valid_39463322 != nil:
    section.add "username", valid_39463322
  var valid_39463323 = path.getOrDefault("org")
  valid_39463323 = validateParameter(valid_39463323, JString, required = true,
                                   default = nil)
  if valid_39463323 != nil:
    section.add "org", valid_39463323
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463324 = header.getOrDefault("Accept")
  valid_39463324 = validateParameter(valid_39463324, JString, required = false,
                                   default = nil)
  if valid_39463324 != nil:
    section.add "Accept", valid_39463324
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463325: Call_GetUsersUsernameEventsOrgsOrg_39463319;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## This is the user's organization dashboard. You must be authenticated as the user to view this.
  ## 
  let valid = call_39463325.validator(path, query, header, formData, body, _)
  let scheme = call_39463325.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463325.url(scheme.get, call_39463325.host, call_39463325.base,
                           call_39463325.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463325, uri, valid, _)

proc call*(call_39463326: Call_GetUsersUsernameEventsOrgsOrg_39463319;
          username: string; org: string; Accept: string = ""): Recallable =
  ## getUsersUsernameEventsOrgsOrg
  ## This is the user's organization dashboard. You must be authenticated as the user to view this.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  var path_39463327 = newJObject()
  var header_39463328 = newJObject()
  add(path_39463327, "username", newJString(username))
  add(header_39463328, "Accept", newJString(Accept))
  add(path_39463327, "org", newJString(org))
  result = call_39463326.call(path_39463327, nil, header_39463328, nil, nil)

var getUsersUsernameEventsOrgsOrg* = Call_GetUsersUsernameEventsOrgsOrg_39463319(
    name: "getUsersUsernameEventsOrgsOrg", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/events/orgs/{org}",
    validator: validate_GetUsersUsernameEventsOrgsOrg_39463320, base: "/",
    url: url_GetUsersUsernameEventsOrgsOrg_39463321, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameFollowers_39463329 = ref object of OpenApiRestCall_39460352
proc url_GetUsersUsernameFollowers_39463331(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/followers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameFollowers_39463330(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List a user's followers
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39463332 = path.getOrDefault("username")
  valid_39463332 = validateParameter(valid_39463332, JString, required = true,
                                   default = nil)
  if valid_39463332 != nil:
    section.add "username", valid_39463332
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463333 = header.getOrDefault("Accept")
  valid_39463333 = validateParameter(valid_39463333, JString, required = false,
                                   default = nil)
  if valid_39463333 != nil:
    section.add "Accept", valid_39463333
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463334: Call_GetUsersUsernameFollowers_39463329;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List a user's followers
  ## 
  let valid = call_39463334.validator(path, query, header, formData, body, _)
  let scheme = call_39463334.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463334.url(scheme.get, call_39463334.host, call_39463334.base,
                           call_39463334.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463334, uri, valid, _)

proc call*(call_39463335: Call_GetUsersUsernameFollowers_39463329;
          username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameFollowers
  ## List a user's followers
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39463336 = newJObject()
  var header_39463337 = newJObject()
  add(path_39463336, "username", newJString(username))
  add(header_39463337, "Accept", newJString(Accept))
  result = call_39463335.call(path_39463336, nil, header_39463337, nil, nil)

var getUsersUsernameFollowers* = Call_GetUsersUsernameFollowers_39463329(
    name: "getUsersUsernameFollowers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/followers",
    validator: validate_GetUsersUsernameFollowers_39463330, base: "/",
    url: url_GetUsersUsernameFollowers_39463331, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameFollowingTargetUser_39463338 = ref object of OpenApiRestCall_39460352
proc url_GetUsersUsernameFollowingTargetUser_39463340(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  assert "targetUser" in path, "`targetUser` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/following/"),
               (kind: VariableSegment, value: "targetUser")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameFollowingTargetUser_39463339(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Check if one user follows another.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  ##   targetUser: JString (required)
  ##             : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39463341 = path.getOrDefault("username")
  valid_39463341 = validateParameter(valid_39463341, JString, required = true,
                                   default = nil)
  if valid_39463341 != nil:
    section.add "username", valid_39463341
  var valid_39463342 = path.getOrDefault("targetUser")
  valid_39463342 = validateParameter(valid_39463342, JString, required = true,
                                   default = nil)
  if valid_39463342 != nil:
    section.add "targetUser", valid_39463342
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463343 = header.getOrDefault("Accept")
  valid_39463343 = validateParameter(valid_39463343, JString, required = false,
                                   default = nil)
  if valid_39463343 != nil:
    section.add "Accept", valid_39463343
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463344: Call_GetUsersUsernameFollowingTargetUser_39463338;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if one user follows another.
  ## 
  let valid = call_39463344.validator(path, query, header, formData, body, _)
  let scheme = call_39463344.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463344.url(scheme.get, call_39463344.host, call_39463344.base,
                           call_39463344.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463344, uri, valid, _)

proc call*(call_39463345: Call_GetUsersUsernameFollowingTargetUser_39463338;
          username: string; targetUser: string; Accept: string = ""): Recallable =
  ## getUsersUsernameFollowingTargetUser
  ## Check if one user follows another.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   targetUser: string (required)
  ##             : Name of user.
  var path_39463346 = newJObject()
  var header_39463347 = newJObject()
  add(path_39463346, "username", newJString(username))
  add(header_39463347, "Accept", newJString(Accept))
  add(path_39463346, "targetUser", newJString(targetUser))
  result = call_39463345.call(path_39463346, nil, header_39463347, nil, nil)

var getUsersUsernameFollowingTargetUser* = Call_GetUsersUsernameFollowingTargetUser_39463338(
    name: "getUsersUsernameFollowingTargetUser", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/following/{targetUser}",
    validator: validate_GetUsersUsernameFollowingTargetUser_39463339, base: "/",
    url: url_GetUsersUsernameFollowingTargetUser_39463340, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameGists_39463348 = ref object of OpenApiRestCall_39460352
proc url_GetUsersUsernameGists_39463350(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/gists")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameGists_39463349(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List a users gists.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39463351 = path.getOrDefault("username")
  valid_39463351 = validateParameter(valid_39463351, JString, required = true,
                                   default = nil)
  if valid_39463351 != nil:
    section.add "username", valid_39463351
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_39463352 = query.getOrDefault("since")
  valid_39463352 = validateParameter(valid_39463352, JString, required = false,
                                   default = nil)
  if valid_39463352 != nil:
    section.add "since", valid_39463352
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463353 = header.getOrDefault("Accept")
  valid_39463353 = validateParameter(valid_39463353, JString, required = false,
                                   default = nil)
  if valid_39463353 != nil:
    section.add "Accept", valid_39463353
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463354: Call_GetUsersUsernameGists_39463348;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List a users gists.
  ## 
  let valid = call_39463354.validator(path, query, header, formData, body, _)
  let scheme = call_39463354.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463354.url(scheme.get, call_39463354.host, call_39463354.base,
                           call_39463354.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463354, uri, valid, _)

proc call*(call_39463355: Call_GetUsersUsernameGists_39463348; username: string;
          Accept: string = ""; since: string = ""): Recallable =
  ## getUsersUsernameGists
  ## List a users gists.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var path_39463356 = newJObject()
  var query_39463357 = newJObject()
  var header_39463358 = newJObject()
  add(path_39463356, "username", newJString(username))
  add(header_39463358, "Accept", newJString(Accept))
  add(query_39463357, "since", newJString(since))
  result = call_39463355.call(path_39463356, query_39463357, header_39463358, nil, nil)

var getUsersUsernameGists* = Call_GetUsersUsernameGists_39463348(
    name: "getUsersUsernameGists", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/users/{username}/gists", validator: validate_GetUsersUsernameGists_39463349,
    base: "/", url: url_GetUsersUsernameGists_39463350, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameKeys_39463359 = ref object of OpenApiRestCall_39460352
proc url_GetUsersUsernameKeys_39463361(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/keys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameKeys_39463360(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List public keys for a user.
  ## Lists the verified public keys for a user. This is accessible by anyone.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39463362 = path.getOrDefault("username")
  valid_39463362 = validateParameter(valid_39463362, JString, required = true,
                                   default = nil)
  if valid_39463362 != nil:
    section.add "username", valid_39463362
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463363 = header.getOrDefault("Accept")
  valid_39463363 = validateParameter(valid_39463363, JString, required = false,
                                   default = nil)
  if valid_39463363 != nil:
    section.add "Accept", valid_39463363
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463364: Call_GetUsersUsernameKeys_39463359; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List public keys for a user.
  ## Lists the verified public keys for a user. This is accessible by anyone.
  ## 
  ## 
  let valid = call_39463364.validator(path, query, header, formData, body, _)
  let scheme = call_39463364.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463364.url(scheme.get, call_39463364.host, call_39463364.base,
                           call_39463364.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463364, uri, valid, _)

proc call*(call_39463365: Call_GetUsersUsernameKeys_39463359; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameKeys
  ## List public keys for a user.
  ## Lists the verified public keys for a user. This is accessible by anyone.
  ## 
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39463366 = newJObject()
  var header_39463367 = newJObject()
  add(path_39463366, "username", newJString(username))
  add(header_39463367, "Accept", newJString(Accept))
  result = call_39463365.call(path_39463366, nil, header_39463367, nil, nil)

var getUsersUsernameKeys* = Call_GetUsersUsernameKeys_39463359(
    name: "getUsersUsernameKeys", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/users/{username}/keys", validator: validate_GetUsersUsernameKeys_39463360,
    base: "/", url: url_GetUsersUsernameKeys_39463361, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameOrgs_39463368 = ref object of OpenApiRestCall_39460352
proc url_GetUsersUsernameOrgs_39463370(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/orgs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameOrgs_39463369(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List all public organizations for a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39463371 = path.getOrDefault("username")
  valid_39463371 = validateParameter(valid_39463371, JString, required = true,
                                   default = nil)
  if valid_39463371 != nil:
    section.add "username", valid_39463371
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463372 = header.getOrDefault("Accept")
  valid_39463372 = validateParameter(valid_39463372, JString, required = false,
                                   default = nil)
  if valid_39463372 != nil:
    section.add "Accept", valid_39463372
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463373: Call_GetUsersUsernameOrgs_39463368; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List all public organizations for a user.
  ## 
  let valid = call_39463373.validator(path, query, header, formData, body, _)
  let scheme = call_39463373.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463373.url(scheme.get, call_39463373.host, call_39463373.base,
                           call_39463373.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463373, uri, valid, _)

proc call*(call_39463374: Call_GetUsersUsernameOrgs_39463368; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameOrgs
  ## List all public organizations for a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39463375 = newJObject()
  var header_39463376 = newJObject()
  add(path_39463375, "username", newJString(username))
  add(header_39463376, "Accept", newJString(Accept))
  result = call_39463374.call(path_39463375, nil, header_39463376, nil, nil)

var getUsersUsernameOrgs* = Call_GetUsersUsernameOrgs_39463368(
    name: "getUsersUsernameOrgs", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/users/{username}/orgs", validator: validate_GetUsersUsernameOrgs_39463369,
    base: "/", url: url_GetUsersUsernameOrgs_39463370, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameReceivedEvents_39463377 = ref object of OpenApiRestCall_39460352
proc url_GetUsersUsernameReceivedEvents_39463379(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/received_events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameReceivedEvents_39463378(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## These are events that you'll only see public events.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39463380 = path.getOrDefault("username")
  valid_39463380 = validateParameter(valid_39463380, JString, required = true,
                                   default = nil)
  if valid_39463380 != nil:
    section.add "username", valid_39463380
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463381 = header.getOrDefault("Accept")
  valid_39463381 = validateParameter(valid_39463381, JString, required = false,
                                   default = nil)
  if valid_39463381 != nil:
    section.add "Accept", valid_39463381
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463382: Call_GetUsersUsernameReceivedEvents_39463377;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## These are events that you'll only see public events.
  ## 
  let valid = call_39463382.validator(path, query, header, formData, body, _)
  let scheme = call_39463382.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463382.url(scheme.get, call_39463382.host, call_39463382.base,
                           call_39463382.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463382, uri, valid, _)

proc call*(call_39463383: Call_GetUsersUsernameReceivedEvents_39463377;
          username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameReceivedEvents
  ## These are events that you'll only see public events.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39463384 = newJObject()
  var header_39463385 = newJObject()
  add(path_39463384, "username", newJString(username))
  add(header_39463385, "Accept", newJString(Accept))
  result = call_39463383.call(path_39463384, nil, header_39463385, nil, nil)

var getUsersUsernameReceivedEvents* = Call_GetUsersUsernameReceivedEvents_39463377(
    name: "getUsersUsernameReceivedEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/received_events",
    validator: validate_GetUsersUsernameReceivedEvents_39463378, base: "/",
    url: url_GetUsersUsernameReceivedEvents_39463379, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameReceivedEventsPublic_39463386 = ref object of OpenApiRestCall_39460352
proc url_GetUsersUsernameReceivedEventsPublic_39463388(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/received_events/public")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameReceivedEventsPublic_39463387(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List public events that a user has received
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39463389 = path.getOrDefault("username")
  valid_39463389 = validateParameter(valid_39463389, JString, required = true,
                                   default = nil)
  if valid_39463389 != nil:
    section.add "username", valid_39463389
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463390 = header.getOrDefault("Accept")
  valid_39463390 = validateParameter(valid_39463390, JString, required = false,
                                   default = nil)
  if valid_39463390 != nil:
    section.add "Accept", valid_39463390
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463391: Call_GetUsersUsernameReceivedEventsPublic_39463386;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List public events that a user has received
  ## 
  let valid = call_39463391.validator(path, query, header, formData, body, _)
  let scheme = call_39463391.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463391.url(scheme.get, call_39463391.host, call_39463391.base,
                           call_39463391.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463391, uri, valid, _)

proc call*(call_39463392: Call_GetUsersUsernameReceivedEventsPublic_39463386;
          username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameReceivedEventsPublic
  ## List public events that a user has received
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39463393 = newJObject()
  var header_39463394 = newJObject()
  add(path_39463393, "username", newJString(username))
  add(header_39463394, "Accept", newJString(Accept))
  result = call_39463392.call(path_39463393, nil, header_39463394, nil, nil)

var getUsersUsernameReceivedEventsPublic* = Call_GetUsersUsernameReceivedEventsPublic_39463386(
    name: "getUsersUsernameReceivedEventsPublic", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/received_events/public",
    validator: validate_GetUsersUsernameReceivedEventsPublic_39463387, base: "/",
    url: url_GetUsersUsernameReceivedEventsPublic_39463388,
    schemes: {Scheme.Https})
type
  Call_GetUsersUsernameRepos_39463395 = ref object of OpenApiRestCall_39460352
proc url_GetUsersUsernameRepos_39463397(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameRepos_39463396(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List public repositories for the specified user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39463398 = path.getOrDefault("username")
  valid_39463398 = validateParameter(valid_39463398, JString, required = true,
                                   default = nil)
  if valid_39463398 != nil:
    section.add "username", valid_39463398
  result.add "path", section
  ## parameters in `query` object:
  ##   type: JString
  section = newJObject()
  var valid_39463399 = query.getOrDefault("type")
  valid_39463399 = validateParameter(valid_39463399, JString, required = false,
                                   default = newJString("all"))
  if valid_39463399 != nil:
    section.add "type", valid_39463399
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463400 = header.getOrDefault("Accept")
  valid_39463400 = validateParameter(valid_39463400, JString, required = false,
                                   default = nil)
  if valid_39463400 != nil:
    section.add "Accept", valid_39463400
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463401: Call_GetUsersUsernameRepos_39463395;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List public repositories for the specified user.
  ## 
  let valid = call_39463401.validator(path, query, header, formData, body, _)
  let scheme = call_39463401.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463401.url(scheme.get, call_39463401.host, call_39463401.base,
                           call_39463401.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463401, uri, valid, _)

proc call*(call_39463402: Call_GetUsersUsernameRepos_39463395; username: string;
          Accept: string = ""; `type`: string = "all"): Recallable =
  ## getUsersUsernameRepos
  ## List public repositories for the specified user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   type: string
  var path_39463403 = newJObject()
  var query_39463404 = newJObject()
  var header_39463405 = newJObject()
  add(path_39463403, "username", newJString(username))
  add(header_39463405, "Accept", newJString(Accept))
  add(query_39463404, "type", newJString(`type`))
  result = call_39463402.call(path_39463403, query_39463404, header_39463405, nil, nil)

var getUsersUsernameRepos* = Call_GetUsersUsernameRepos_39463395(
    name: "getUsersUsernameRepos", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/users/{username}/repos", validator: validate_GetUsersUsernameRepos_39463396,
    base: "/", url: url_GetUsersUsernameRepos_39463397, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameStarred_39463406 = ref object of OpenApiRestCall_39460352
proc url_GetUsersUsernameStarred_39463408(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/starred")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameStarred_39463407(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List repositories being starred by a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39463409 = path.getOrDefault("username")
  valid_39463409 = validateParameter(valid_39463409, JString, required = true,
                                   default = nil)
  if valid_39463409 != nil:
    section.add "username", valid_39463409
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463410 = header.getOrDefault("Accept")
  valid_39463410 = validateParameter(valid_39463410, JString, required = false,
                                   default = nil)
  if valid_39463410 != nil:
    section.add "Accept", valid_39463410
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463411: Call_GetUsersUsernameStarred_39463406;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List repositories being starred by a user.
  ## 
  let valid = call_39463411.validator(path, query, header, formData, body, _)
  let scheme = call_39463411.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463411.url(scheme.get, call_39463411.host, call_39463411.base,
                           call_39463411.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463411, uri, valid, _)

proc call*(call_39463412: Call_GetUsersUsernameStarred_39463406; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameStarred
  ## List repositories being starred by a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39463413 = newJObject()
  var header_39463414 = newJObject()
  add(path_39463413, "username", newJString(username))
  add(header_39463414, "Accept", newJString(Accept))
  result = call_39463412.call(path_39463413, nil, header_39463414, nil, nil)

var getUsersUsernameStarred* = Call_GetUsersUsernameStarred_39463406(
    name: "getUsersUsernameStarred", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/starred",
    validator: validate_GetUsersUsernameStarred_39463407, base: "/",
    url: url_GetUsersUsernameStarred_39463408, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameSubscriptions_39463415 = ref object of OpenApiRestCall_39460352
proc url_GetUsersUsernameSubscriptions_39463417(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/subscriptions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameSubscriptions_39463416(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List repositories being watched by a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39463418 = path.getOrDefault("username")
  valid_39463418 = validateParameter(valid_39463418, JString, required = true,
                                   default = nil)
  if valid_39463418 != nil:
    section.add "username", valid_39463418
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39463419 = header.getOrDefault("Accept")
  valid_39463419 = validateParameter(valid_39463419, JString, required = false,
                                   default = nil)
  if valid_39463419 != nil:
    section.add "Accept", valid_39463419
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39463420: Call_GetUsersUsernameSubscriptions_39463415;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List repositories being watched by a user.
  ## 
  let valid = call_39463420.validator(path, query, header, formData, body, _)
  let scheme = call_39463420.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_39463420.url(scheme.get, call_39463420.host, call_39463420.base,
                           call_39463420.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39463420, uri, valid, _)

proc call*(call_39463421: Call_GetUsersUsernameSubscriptions_39463415;
          username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameSubscriptions
  ## List repositories being watched by a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39463422 = newJObject()
  var header_39463423 = newJObject()
  add(path_39463422, "username", newJString(username))
  add(header_39463423, "Accept", newJString(Accept))
  result = call_39463421.call(path_39463422, nil, header_39463423, nil, nil)

var getUsersUsernameSubscriptions* = Call_GetUsersUsernameSubscriptions_39463415(
    name: "getUsersUsernameSubscriptions", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/subscriptions",
    validator: validate_GetUsersUsernameSubscriptions_39463416, base: "/",
    url: url_GetUsersUsernameSubscriptions_39463417, schemes: {Scheme.Https})
export
  rest

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode; body: string): Recallable {.
    base.} =
  var headers = massageHeaders(input.getOrDefault("header")).newHttpHeaders
  let token = os.getEnv("GITHUB_TOKEN", "")
  if not headers.hasKey("Authorization") and token.len > 0:
    headers.add "Authorization", "token " & token
  if headers.hasKey "Accept":
    headers.del "Accept"
  headers.add "Accept", "application/vnd.github.v3+json"
  result = newRecallable(call, url, headers, body)
