
import
  json, options, hashes, uri, strutils, rest, os, uri, httpcore

## auto-generated via openapi macro
## title: GitHub
## version: v3
## termsOfService: https://help.github.com/articles/github-terms-of-service/#b-api-terms
## license: (not provided)
## 
## Powerful collaboration, code review, and code management for open source and private projects.
## 
## 
## https://developer.github.com/v3/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (path: JsonNode = nil; query: JsonNode = nil;
                          header: JsonNode = nil; formData: JsonNode = nil;
                          body: JsonNode = nil; _: string = ""): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_39115352 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_39115352](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_39115352): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low .. Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js == nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result == nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind == kind, $kind & " expected; received " & $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string {.used.} =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] {.used.} =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    case js.kind
    of JInt, JFloat, JNull, JBool:
      head = $js
    of JString:
      head = js.getStr
    else:
      return
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode; body: string = ""): Recallable {.
    base.}
type
  Call_GetEmojis_39115539 = ref object of OpenApiRestCall_39115352
proc url_GetEmojis_39115541(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEmojis_39115540(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Lists all the emojis available to use on GitHub.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39115674 = header.getOrDefault("Accept")
  valid_39115674 = validateParameter(valid_39115674, JString, required = false,
                                   default = nil)
  if valid_39115674 != nil:
    section.add "Accept", valid_39115674
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39115699: Call_GetEmojis_39115539; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Lists all the emojis available to use on GitHub.
  ## 
  let valid = call_39115699.validator(path, query, header, formData, body, _)
  let scheme = call_39115699.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39115699.url(scheme.get, call_39115699.host, call_39115699.base,
                           call_39115699.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39115699, url, valid, _)

proc call*(call_39115762: Call_GetEmojis_39115539; Accept: string = ""): Recallable =
  ## getEmojis
  ## Lists all the emojis available to use on GitHub.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_39115764 = newJObject()
  add(header_39115764, "Accept", newJString(Accept))
  result = call_39115762.call(nil, nil, header_39115764, nil, nil)

var getEmojis* = Call_GetEmojis_39115539(name: "getEmojis", meth: HttpMethod.HttpGet,
                                      host: "api.github.com", route: "/emojis",
                                      validator: validate_GetEmojis_39115540,
                                      base: "/", url: url_GetEmojis_39115541,
                                      schemes: {Scheme.Https})
type
  Call_GetEvents_39115806 = ref object of OpenApiRestCall_39115352
proc url_GetEvents_39115808(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEvents_39115807(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List public events.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39115809 = header.getOrDefault("Accept")
  valid_39115809 = validateParameter(valid_39115809, JString, required = false,
                                   default = nil)
  if valid_39115809 != nil:
    section.add "Accept", valid_39115809
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39115810: Call_GetEvents_39115806; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List public events.
  ## 
  let valid = call_39115810.validator(path, query, header, formData, body, _)
  let scheme = call_39115810.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39115810.url(scheme.get, call_39115810.host, call_39115810.base,
                           call_39115810.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39115810, url, valid, _)

proc call*(call_39115811: Call_GetEvents_39115806; Accept: string = ""): Recallable =
  ## getEvents
  ## List public events.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_39115812 = newJObject()
  add(header_39115812, "Accept", newJString(Accept))
  result = call_39115811.call(nil, nil, header_39115812, nil, nil)

var getEvents* = Call_GetEvents_39115806(name: "getEvents", meth: HttpMethod.HttpGet,
                                      host: "api.github.com", route: "/events",
                                      validator: validate_GetEvents_39115807,
                                      base: "/", url: url_GetEvents_39115808,
                                      schemes: {Scheme.Https})
type
  Call_GetFeeds_39115813 = ref object of OpenApiRestCall_39115352
proc url_GetFeeds_39115815(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetFeeds_39115814(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List Feeds.
  ## GitHub provides several timeline resources in Atom format. The Feeds API
  ##  lists all the feeds available to the authenticating user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39115816 = header.getOrDefault("Accept")
  valid_39115816 = validateParameter(valid_39115816, JString, required = false,
                                   default = nil)
  if valid_39115816 != nil:
    section.add "Accept", valid_39115816
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39115817: Call_GetFeeds_39115813; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List Feeds.
  ## GitHub provides several timeline resources in Atom format. The Feeds API
  ##  lists all the feeds available to the authenticating user.
  ## 
  ## 
  let valid = call_39115817.validator(path, query, header, formData, body, _)
  let scheme = call_39115817.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39115817.url(scheme.get, call_39115817.host, call_39115817.base,
                           call_39115817.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39115817, url, valid, _)

proc call*(call_39115818: Call_GetFeeds_39115813; Accept: string = ""): Recallable =
  ## getFeeds
  ## List Feeds.
  ## GitHub provides several timeline resources in Atom format. The Feeds API
  ##  lists all the feeds available to the authenticating user.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_39115819 = newJObject()
  add(header_39115819, "Accept", newJString(Accept))
  result = call_39115818.call(nil, nil, header_39115819, nil, nil)

var getFeeds* = Call_GetFeeds_39115813(name: "getFeeds", meth: HttpMethod.HttpGet,
                                    host: "api.github.com", route: "/feeds",
                                    validator: validate_GetFeeds_39115814,
                                    base: "/", url: url_GetFeeds_39115815,
                                    schemes: {Scheme.Https})
type
  Call_PostGists_39115829 = ref object of OpenApiRestCall_39115352
proc url_PostGists_39115831(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostGists_39115830(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39115841 = header.getOrDefault("Accept")
  valid_39115841 = validateParameter(valid_39115841, JString, required = false,
                                   default = nil)
  if valid_39115841 != nil:
    section.add "Accept", valid_39115841
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39115843: Call_PostGists_39115829; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a gist.
  ## 
  let valid = call_39115843.validator(path, query, header, formData, body, _)
  let scheme = call_39115843.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39115843.url(scheme.get, call_39115843.host, call_39115843.base,
                           call_39115843.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39115843, url, valid, _)

proc call*(call_39115844: Call_PostGists_39115829; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postGists
  ## Create a gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_39115845 = newJObject()
  var body_39115846 = newJObject()
  add(header_39115845, "Accept", newJString(Accept))
  if body != nil:
    body_39115846 = body
  result = call_39115844.call(nil, nil, header_39115845, nil, body_39115846)

var postGists* = Call_PostGists_39115829(name: "postGists",
                                      meth: HttpMethod.HttpPost,
                                      host: "api.github.com", route: "/gists",
                                      validator: validate_PostGists_39115830,
                                      base: "/", url: url_PostGists_39115831,
                                      schemes: {Scheme.Https})
type
  Call_GetGists_39115820 = ref object of OpenApiRestCall_39115352
proc url_GetGists_39115822(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGists_39115821(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List the authenticated user's gists or if called anonymously, this will
  ## return all public gists.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_39115823 = query.getOrDefault("since")
  valid_39115823 = validateParameter(valid_39115823, JString, required = false,
                                   default = nil)
  if valid_39115823 != nil:
    section.add "since", valid_39115823
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39115824 = header.getOrDefault("Accept")
  valid_39115824 = validateParameter(valid_39115824, JString, required = false,
                                   default = nil)
  if valid_39115824 != nil:
    section.add "Accept", valid_39115824
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39115825: Call_GetGists_39115820; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List the authenticated user's gists or if called anonymously, this will
  ## return all public gists.
  ## 
  ## 
  let valid = call_39115825.validator(path, query, header, formData, body, _)
  let scheme = call_39115825.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39115825.url(scheme.get, call_39115825.host, call_39115825.base,
                           call_39115825.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39115825, url, valid, _)

proc call*(call_39115826: Call_GetGists_39115820; Accept: string = "";
          since: string = ""): Recallable =
  ## getGists
  ## List the authenticated user's gists or if called anonymously, this will
  ## return all public gists.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: string
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  var query_39115827 = newJObject()
  var header_39115828 = newJObject()
  add(header_39115828, "Accept", newJString(Accept))
  add(query_39115827, "since", newJString(since))
  result = call_39115826.call(nil, query_39115827, header_39115828, nil, nil)

var getGists* = Call_GetGists_39115820(name: "getGists", meth: HttpMethod.HttpGet,
                                    host: "api.github.com", route: "/gists",
                                    validator: validate_GetGists_39115821,
                                    base: "/", url: url_GetGists_39115822,
                                    schemes: {Scheme.Https})
type
  Call_GetGistsPublic_39115847 = ref object of OpenApiRestCall_39115352
proc url_GetGistsPublic_39115849(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGistsPublic_39115848(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List all public gists.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_39115850 = query.getOrDefault("since")
  valid_39115850 = validateParameter(valid_39115850, JString, required = false,
                                   default = nil)
  if valid_39115850 != nil:
    section.add "since", valid_39115850
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39115851 = header.getOrDefault("Accept")
  valid_39115851 = validateParameter(valid_39115851, JString, required = false,
                                   default = nil)
  if valid_39115851 != nil:
    section.add "Accept", valid_39115851
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39115852: Call_GetGistsPublic_39115847; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List all public gists.
  ## 
  let valid = call_39115852.validator(path, query, header, formData, body, _)
  let scheme = call_39115852.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39115852.url(scheme.get, call_39115852.host, call_39115852.base,
                           call_39115852.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39115852, url, valid, _)

proc call*(call_39115853: Call_GetGistsPublic_39115847; Accept: string = "";
          since: string = ""): Recallable =
  ## getGistsPublic
  ## List all public gists.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: string
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  var query_39115854 = newJObject()
  var header_39115855 = newJObject()
  add(header_39115855, "Accept", newJString(Accept))
  add(query_39115854, "since", newJString(since))
  result = call_39115853.call(nil, query_39115854, header_39115855, nil, nil)

var getGistsPublic* = Call_GetGistsPublic_39115847(name: "getGistsPublic",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/gists/public",
    validator: validate_GetGistsPublic_39115848, base: "/", url: url_GetGistsPublic_39115849,
    schemes: {Scheme.Https})
type
  Call_GetGistsStarred_39115856 = ref object of OpenApiRestCall_39115352
proc url_GetGistsStarred_39115858(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGistsStarred_39115857(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List the authenticated user's starred gists.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_39115859 = query.getOrDefault("since")
  valid_39115859 = validateParameter(valid_39115859, JString, required = false,
                                   default = nil)
  if valid_39115859 != nil:
    section.add "since", valid_39115859
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39115860 = header.getOrDefault("Accept")
  valid_39115860 = validateParameter(valid_39115860, JString, required = false,
                                   default = nil)
  if valid_39115860 != nil:
    section.add "Accept", valid_39115860
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39115861: Call_GetGistsStarred_39115856; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List the authenticated user's starred gists.
  ## 
  let valid = call_39115861.validator(path, query, header, formData, body, _)
  let scheme = call_39115861.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39115861.url(scheme.get, call_39115861.host, call_39115861.base,
                           call_39115861.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39115861, url, valid, _)

proc call*(call_39115862: Call_GetGistsStarred_39115856; Accept: string = "";
          since: string = ""): Recallable =
  ## getGistsStarred
  ## List the authenticated user's starred gists.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: string
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  var query_39115863 = newJObject()
  var header_39115864 = newJObject()
  add(header_39115864, "Accept", newJString(Accept))
  add(query_39115863, "since", newJString(since))
  result = call_39115862.call(nil, query_39115863, header_39115864, nil, nil)

var getGistsStarred* = Call_GetGistsStarred_39115856(name: "getGistsStarred",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/gists/starred",
    validator: validate_GetGistsStarred_39115857, base: "/",
    url: url_GetGistsStarred_39115858, schemes: {Scheme.Https})
type
  Call_GetGistsId_39115865 = ref object of OpenApiRestCall_39115352
proc url_GetGistsId_39115867(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsId_39115866(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get a single gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39115881 = path.getOrDefault("id")
  valid_39115881 = validateParameter(valid_39115881, JInt, required = true,
                                   default = nil)
  if valid_39115881 != nil:
    section.add "id", valid_39115881
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39115882 = header.getOrDefault("Accept")
  valid_39115882 = validateParameter(valid_39115882, JString, required = false,
                                   default = nil)
  if valid_39115882 != nil:
    section.add "Accept", valid_39115882
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39115883: Call_GetGistsId_39115865; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single gist.
  ## 
  let valid = call_39115883.validator(path, query, header, formData, body, _)
  let scheme = call_39115883.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39115883.url(scheme.get, call_39115883.host, call_39115883.base,
                           call_39115883.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39115883, url, valid, _)

proc call*(call_39115884: Call_GetGistsId_39115865; id: int; Accept: string = ""): Recallable =
  ## getGistsId
  ## Get a single gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39115885 = newJObject()
  var header_39115886 = newJObject()
  add(path_39115885, "id", newJInt(id))
  add(header_39115886, "Accept", newJString(Accept))
  result = call_39115884.call(path_39115885, nil, header_39115886, nil, nil)

var getGistsId* = Call_GetGistsId_39115865(name: "getGistsId",
                                        meth: HttpMethod.HttpGet,
                                        host: "api.github.com",
                                        route: "/gists/{id}",
                                        validator: validate_GetGistsId_39115866,
                                        base: "/", url: url_GetGistsId_39115867,
                                        schemes: {Scheme.Https})
type
  Call_PatchGistsId_39115896 = ref object of OpenApiRestCall_39115352
proc url_PatchGistsId_39115898(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchGistsId_39115897(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## Edit a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39115899 = path.getOrDefault("id")
  valid_39115899 = validateParameter(valid_39115899, JInt, required = true,
                                   default = nil)
  if valid_39115899 != nil:
    section.add "id", valid_39115899
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39115900 = header.getOrDefault("Accept")
  valid_39115900 = validateParameter(valid_39115900, JString, required = false,
                                   default = nil)
  if valid_39115900 != nil:
    section.add "Accept", valid_39115900
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39115902: Call_PatchGistsId_39115896; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit a gist.
  ## 
  let valid = call_39115902.validator(path, query, header, formData, body, _)
  let scheme = call_39115902.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39115902.url(scheme.get, call_39115902.host, call_39115902.base,
                           call_39115902.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39115902, url, valid, _)

proc call*(call_39115903: Call_PatchGistsId_39115896; id: int; body: JsonNode;
          Accept: string = ""): Recallable =
  ## patchGistsId
  ## Edit a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var path_39115904 = newJObject()
  var header_39115905 = newJObject()
  var body_39115906 = newJObject()
  add(path_39115904, "id", newJInt(id))
  add(header_39115905, "Accept", newJString(Accept))
  if body != nil:
    body_39115906 = body
  result = call_39115903.call(path_39115904, nil, header_39115905, nil, body_39115906)

var patchGistsId* = Call_PatchGistsId_39115896(name: "patchGistsId",
    meth: HttpMethod.HttpPatch, host: "api.github.com", route: "/gists/{id}",
    validator: validate_PatchGistsId_39115897, base: "/", url: url_PatchGistsId_39115898,
    schemes: {Scheme.Https})
type
  Call_DeleteGistsId_39115887 = ref object of OpenApiRestCall_39115352
proc url_DeleteGistsId_39115889(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteGistsId_39115888(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## Delete a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39115890 = path.getOrDefault("id")
  valid_39115890 = validateParameter(valid_39115890, JInt, required = true,
                                   default = nil)
  if valid_39115890 != nil:
    section.add "id", valid_39115890
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39115891 = header.getOrDefault("Accept")
  valid_39115891 = validateParameter(valid_39115891, JString, required = false,
                                   default = nil)
  if valid_39115891 != nil:
    section.add "Accept", valid_39115891
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39115892: Call_DeleteGistsId_39115887; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a gist.
  ## 
  let valid = call_39115892.validator(path, query, header, formData, body, _)
  let scheme = call_39115892.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39115892.url(scheme.get, call_39115892.host, call_39115892.base,
                           call_39115892.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39115892, url, valid, _)

proc call*(call_39115893: Call_DeleteGistsId_39115887; id: int; Accept: string = ""): Recallable =
  ## deleteGistsId
  ## Delete a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39115894 = newJObject()
  var header_39115895 = newJObject()
  add(path_39115894, "id", newJInt(id))
  add(header_39115895, "Accept", newJString(Accept))
  result = call_39115893.call(path_39115894, nil, header_39115895, nil, nil)

var deleteGistsId* = Call_DeleteGistsId_39115887(name: "deleteGistsId",
    meth: HttpMethod.HttpDelete, host: "api.github.com", route: "/gists/{id}",
    validator: validate_DeleteGistsId_39115888, base: "/", url: url_DeleteGistsId_39115889,
    schemes: {Scheme.Https})
type
  Call_PostGistsIdComments_39115916 = ref object of OpenApiRestCall_39115352
proc url_PostGistsIdComments_39115918(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostGistsIdComments_39115917(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a commen
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39115919 = path.getOrDefault("id")
  valid_39115919 = validateParameter(valid_39115919, JInt, required = true,
                                   default = nil)
  if valid_39115919 != nil:
    section.add "id", valid_39115919
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39115920 = header.getOrDefault("Accept")
  valid_39115920 = validateParameter(valid_39115920, JString, required = false,
                                   default = nil)
  if valid_39115920 != nil:
    section.add "Accept", valid_39115920
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39115922: Call_PostGistsIdComments_39115916; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a commen
  ## 
  let valid = call_39115922.validator(path, query, header, formData, body, _)
  let scheme = call_39115922.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39115922.url(scheme.get, call_39115922.host, call_39115922.base,
                           call_39115922.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39115922, url, valid, _)

proc call*(call_39115923: Call_PostGistsIdComments_39115916; id: int; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postGistsIdComments
  ## Create a commen
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var path_39115924 = newJObject()
  var header_39115925 = newJObject()
  var body_39115926 = newJObject()
  add(path_39115924, "id", newJInt(id))
  add(header_39115925, "Accept", newJString(Accept))
  if body != nil:
    body_39115926 = body
  result = call_39115923.call(path_39115924, nil, header_39115925, nil, body_39115926)

var postGistsIdComments* = Call_PostGistsIdComments_39115916(
    name: "postGistsIdComments", meth: HttpMethod.HttpPost, host: "api.github.com",
    route: "/gists/{id}/comments", validator: validate_PostGistsIdComments_39115917,
    base: "/", url: url_PostGistsIdComments_39115918, schemes: {Scheme.Https})
type
  Call_GetGistsIdComments_39115907 = ref object of OpenApiRestCall_39115352
proc url_GetGistsIdComments_39115909(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsIdComments_39115908(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List comments on a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39115910 = path.getOrDefault("id")
  valid_39115910 = validateParameter(valid_39115910, JInt, required = true,
                                   default = nil)
  if valid_39115910 != nil:
    section.add "id", valid_39115910
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39115911 = header.getOrDefault("Accept")
  valid_39115911 = validateParameter(valid_39115911, JString, required = false,
                                   default = nil)
  if valid_39115911 != nil:
    section.add "Accept", valid_39115911
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39115912: Call_GetGistsIdComments_39115907; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List comments on a gist.
  ## 
  let valid = call_39115912.validator(path, query, header, formData, body, _)
  let scheme = call_39115912.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39115912.url(scheme.get, call_39115912.host, call_39115912.base,
                           call_39115912.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39115912, url, valid, _)

proc call*(call_39115913: Call_GetGistsIdComments_39115907; id: int;
          Accept: string = ""): Recallable =
  ## getGistsIdComments
  ## List comments on a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39115914 = newJObject()
  var header_39115915 = newJObject()
  add(path_39115914, "id", newJInt(id))
  add(header_39115915, "Accept", newJString(Accept))
  result = call_39115913.call(path_39115914, nil, header_39115915, nil, nil)

var getGistsIdComments* = Call_GetGistsIdComments_39115907(
    name: "getGistsIdComments", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/gists/{id}/comments", validator: validate_GetGistsIdComments_39115908,
    base: "/", url: url_GetGistsIdComments_39115909, schemes: {Scheme.Https})
type
  Call_GetGistsIdCommentsCommentId_39115927 = ref object of OpenApiRestCall_39115352
proc url_GetGistsIdCommentsCommentId_39115929(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsIdCommentsCommentId_39115928(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get a single comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39115930 = path.getOrDefault("id")
  valid_39115930 = validateParameter(valid_39115930, JInt, required = true,
                                   default = nil)
  if valid_39115930 != nil:
    section.add "id", valid_39115930
  var valid_39115931 = path.getOrDefault("commentId")
  valid_39115931 = validateParameter(valid_39115931, JInt, required = true,
                                   default = nil)
  if valid_39115931 != nil:
    section.add "commentId", valid_39115931
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39115932 = header.getOrDefault("Accept")
  valid_39115932 = validateParameter(valid_39115932, JString, required = false,
                                   default = nil)
  if valid_39115932 != nil:
    section.add "Accept", valid_39115932
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39115933: Call_GetGistsIdCommentsCommentId_39115927;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single comment.
  ## 
  let valid = call_39115933.validator(path, query, header, formData, body, _)
  let scheme = call_39115933.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39115933.url(scheme.get, call_39115933.host, call_39115933.base,
                           call_39115933.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39115933, url, valid, _)

proc call*(call_39115934: Call_GetGistsIdCommentsCommentId_39115927; id: int;
          commentId: int; Accept: string = ""): Recallable =
  ## getGistsIdCommentsCommentId
  ## Get a single comment.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_39115935 = newJObject()
  var header_39115936 = newJObject()
  add(path_39115935, "id", newJInt(id))
  add(header_39115936, "Accept", newJString(Accept))
  add(path_39115935, "commentId", newJInt(commentId))
  result = call_39115934.call(path_39115935, nil, header_39115936, nil, nil)

var getGistsIdCommentsCommentId* = Call_GetGistsIdCommentsCommentId_39115927(
    name: "getGistsIdCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/gists/{id}/comments/{commentId}",
    validator: validate_GetGistsIdCommentsCommentId_39115928, base: "/",
    url: url_GetGistsIdCommentsCommentId_39115929, schemes: {Scheme.Https})
type
  Call_PatchGistsIdCommentsCommentId_39115947 = ref object of OpenApiRestCall_39115352
proc url_PatchGistsIdCommentsCommentId_39115949(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchGistsIdCommentsCommentId_39115948(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Edit a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39115950 = path.getOrDefault("id")
  valid_39115950 = validateParameter(valid_39115950, JInt, required = true,
                                   default = nil)
  if valid_39115950 != nil:
    section.add "id", valid_39115950
  var valid_39115951 = path.getOrDefault("commentId")
  valid_39115951 = validateParameter(valid_39115951, JInt, required = true,
                                   default = nil)
  if valid_39115951 != nil:
    section.add "commentId", valid_39115951
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39115952 = header.getOrDefault("Accept")
  valid_39115952 = validateParameter(valid_39115952, JString, required = false,
                                   default = nil)
  if valid_39115952 != nil:
    section.add "Accept", valid_39115952
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39115954: Call_PatchGistsIdCommentsCommentId_39115947;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit a comment.
  ## 
  let valid = call_39115954.validator(path, query, header, formData, body, _)
  let scheme = call_39115954.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39115954.url(scheme.get, call_39115954.host, call_39115954.base,
                           call_39115954.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39115954, url, valid, _)

proc call*(call_39115955: Call_PatchGistsIdCommentsCommentId_39115947; id: int;
          body: JsonNode; commentId: int; Accept: string = ""): Recallable =
  ## patchGistsIdCommentsCommentId
  ## Edit a comment.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_39115956 = newJObject()
  var header_39115957 = newJObject()
  var body_39115958 = newJObject()
  add(path_39115956, "id", newJInt(id))
  add(header_39115957, "Accept", newJString(Accept))
  if body != nil:
    body_39115958 = body
  add(path_39115956, "commentId", newJInt(commentId))
  result = call_39115955.call(path_39115956, nil, header_39115957, nil, body_39115958)

var patchGistsIdCommentsCommentId* = Call_PatchGistsIdCommentsCommentId_39115947(
    name: "patchGistsIdCommentsCommentId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/gists/{id}/comments/{commentId}",
    validator: validate_PatchGistsIdCommentsCommentId_39115948, base: "/",
    url: url_PatchGistsIdCommentsCommentId_39115949, schemes: {Scheme.Https})
type
  Call_DeleteGistsIdCommentsCommentId_39115937 = ref object of OpenApiRestCall_39115352
proc url_DeleteGistsIdCommentsCommentId_39115939(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteGistsIdCommentsCommentId_39115938(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39115940 = path.getOrDefault("id")
  valid_39115940 = validateParameter(valid_39115940, JInt, required = true,
                                   default = nil)
  if valid_39115940 != nil:
    section.add "id", valid_39115940
  var valid_39115941 = path.getOrDefault("commentId")
  valid_39115941 = validateParameter(valid_39115941, JInt, required = true,
                                   default = nil)
  if valid_39115941 != nil:
    section.add "commentId", valid_39115941
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39115942 = header.getOrDefault("Accept")
  valid_39115942 = validateParameter(valid_39115942, JString, required = false,
                                   default = nil)
  if valid_39115942 != nil:
    section.add "Accept", valid_39115942
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39115943: Call_DeleteGistsIdCommentsCommentId_39115937;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a comment.
  ## 
  let valid = call_39115943.validator(path, query, header, formData, body, _)
  let scheme = call_39115943.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39115943.url(scheme.get, call_39115943.host, call_39115943.base,
                           call_39115943.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39115943, url, valid, _)

proc call*(call_39115944: Call_DeleteGistsIdCommentsCommentId_39115937; id: int;
          commentId: int; Accept: string = ""): Recallable =
  ## deleteGistsIdCommentsCommentId
  ## Delete a comment.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_39115945 = newJObject()
  var header_39115946 = newJObject()
  add(path_39115945, "id", newJInt(id))
  add(header_39115946, "Accept", newJString(Accept))
  add(path_39115945, "commentId", newJInt(commentId))
  result = call_39115944.call(path_39115945, nil, header_39115946, nil, nil)

var deleteGistsIdCommentsCommentId* = Call_DeleteGistsIdCommentsCommentId_39115937(
    name: "deleteGistsIdCommentsCommentId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/gists/{id}/comments/{commentId}",
    validator: validate_DeleteGistsIdCommentsCommentId_39115938, base: "/",
    url: url_DeleteGistsIdCommentsCommentId_39115939, schemes: {Scheme.Https})
type
  Call_PostGistsIdForks_39115959 = ref object of OpenApiRestCall_39115352
proc url_PostGistsIdForks_39115961(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/forks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostGistsIdForks_39115960(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Fork a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39115962 = path.getOrDefault("id")
  valid_39115962 = validateParameter(valid_39115962, JInt, required = true,
                                   default = nil)
  if valid_39115962 != nil:
    section.add "id", valid_39115962
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39115963 = header.getOrDefault("Accept")
  valid_39115963 = validateParameter(valid_39115963, JString, required = false,
                                   default = nil)
  if valid_39115963 != nil:
    section.add "Accept", valid_39115963
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39115964: Call_PostGistsIdForks_39115959; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Fork a gist.
  ## 
  let valid = call_39115964.validator(path, query, header, formData, body, _)
  let scheme = call_39115964.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39115964.url(scheme.get, call_39115964.host, call_39115964.base,
                           call_39115964.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39115964, url, valid, _)

proc call*(call_39115965: Call_PostGistsIdForks_39115959; id: int;
          Accept: string = ""): Recallable =
  ## postGistsIdForks
  ## Fork a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39115966 = newJObject()
  var header_39115967 = newJObject()
  add(path_39115966, "id", newJInt(id))
  add(header_39115967, "Accept", newJString(Accept))
  result = call_39115965.call(path_39115966, nil, header_39115967, nil, nil)

var postGistsIdForks* = Call_PostGistsIdForks_39115959(name: "postGistsIdForks",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/gists/{id}/forks",
    validator: validate_PostGistsIdForks_39115960, base: "/",
    url: url_PostGistsIdForks_39115961, schemes: {Scheme.Https})
type
  Call_PutGistsIdStar_39115977 = ref object of OpenApiRestCall_39115352
proc url_PutGistsIdStar_39115979(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/star")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutGistsIdStar_39115978(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Star a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39115980 = path.getOrDefault("id")
  valid_39115980 = validateParameter(valid_39115980, JInt, required = true,
                                   default = nil)
  if valid_39115980 != nil:
    section.add "id", valid_39115980
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39115981 = header.getOrDefault("Accept")
  valid_39115981 = validateParameter(valid_39115981, JString, required = false,
                                   default = nil)
  if valid_39115981 != nil:
    section.add "Accept", valid_39115981
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39115982: Call_PutGistsIdStar_39115977; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Star a gist.
  ## 
  let valid = call_39115982.validator(path, query, header, formData, body, _)
  let scheme = call_39115982.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39115982.url(scheme.get, call_39115982.host, call_39115982.base,
                           call_39115982.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39115982, url, valid, _)

proc call*(call_39115983: Call_PutGistsIdStar_39115977; id: int; Accept: string = ""): Recallable =
  ## putGistsIdStar
  ## Star a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39115984 = newJObject()
  var header_39115985 = newJObject()
  add(path_39115984, "id", newJInt(id))
  add(header_39115985, "Accept", newJString(Accept))
  result = call_39115983.call(path_39115984, nil, header_39115985, nil, nil)

var putGistsIdStar* = Call_PutGistsIdStar_39115977(name: "putGistsIdStar",
    meth: HttpMethod.HttpPut, host: "api.github.com", route: "/gists/{id}/star",
    validator: validate_PutGistsIdStar_39115978, base: "/", url: url_PutGistsIdStar_39115979,
    schemes: {Scheme.Https})
type
  Call_GetGistsIdStar_39115968 = ref object of OpenApiRestCall_39115352
proc url_GetGistsIdStar_39115970(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/star")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsIdStar_39115969(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Check if a gist is starred.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39115971 = path.getOrDefault("id")
  valid_39115971 = validateParameter(valid_39115971, JInt, required = true,
                                   default = nil)
  if valid_39115971 != nil:
    section.add "id", valid_39115971
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39115972 = header.getOrDefault("Accept")
  valid_39115972 = validateParameter(valid_39115972, JString, required = false,
                                   default = nil)
  if valid_39115972 != nil:
    section.add "Accept", valid_39115972
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39115973: Call_GetGistsIdStar_39115968; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if a gist is starred.
  ## 
  let valid = call_39115973.validator(path, query, header, formData, body, _)
  let scheme = call_39115973.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39115973.url(scheme.get, call_39115973.host, call_39115973.base,
                           call_39115973.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39115973, url, valid, _)

proc call*(call_39115974: Call_GetGistsIdStar_39115968; id: int; Accept: string = ""): Recallable =
  ## getGistsIdStar
  ## Check if a gist is starred.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39115975 = newJObject()
  var header_39115976 = newJObject()
  add(path_39115975, "id", newJInt(id))
  add(header_39115976, "Accept", newJString(Accept))
  result = call_39115974.call(path_39115975, nil, header_39115976, nil, nil)

var getGistsIdStar* = Call_GetGistsIdStar_39115968(name: "getGistsIdStar",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/gists/{id}/star",
    validator: validate_GetGistsIdStar_39115969, base: "/", url: url_GetGistsIdStar_39115970,
    schemes: {Scheme.Https})
type
  Call_DeleteGistsIdStar_39115986 = ref object of OpenApiRestCall_39115352
proc url_DeleteGistsIdStar_39115988(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/star")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteGistsIdStar_39115987(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Unstar a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39115989 = path.getOrDefault("id")
  valid_39115989 = validateParameter(valid_39115989, JInt, required = true,
                                   default = nil)
  if valid_39115989 != nil:
    section.add "id", valid_39115989
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39115990 = header.getOrDefault("Accept")
  valid_39115990 = validateParameter(valid_39115990, JString, required = false,
                                   default = nil)
  if valid_39115990 != nil:
    section.add "Accept", valid_39115990
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39115991: Call_DeleteGistsIdStar_39115986; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Unstar a gist.
  ## 
  let valid = call_39115991.validator(path, query, header, formData, body, _)
  let scheme = call_39115991.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39115991.url(scheme.get, call_39115991.host, call_39115991.base,
                           call_39115991.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39115991, url, valid, _)

proc call*(call_39115992: Call_DeleteGistsIdStar_39115986; id: int;
          Accept: string = ""): Recallable =
  ## deleteGistsIdStar
  ## Unstar a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39115993 = newJObject()
  var header_39115994 = newJObject()
  add(path_39115993, "id", newJInt(id))
  add(header_39115994, "Accept", newJString(Accept))
  result = call_39115992.call(path_39115993, nil, header_39115994, nil, nil)

var deleteGistsIdStar* = Call_DeleteGistsIdStar_39115986(name: "deleteGistsIdStar",
    meth: HttpMethod.HttpDelete, host: "api.github.com", route: "/gists/{id}/star",
    validator: validate_DeleteGistsIdStar_39115987, base: "/",
    url: url_DeleteGistsIdStar_39115988, schemes: {Scheme.Https})
type
  Call_GetGitignoreTemplates_39115995 = ref object of OpenApiRestCall_39115352
proc url_GetGitignoreTemplates_39115997(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGitignoreTemplates_39115996(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Listing available templates.
  ## List all templates available to pass as an option when creating a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39115998 = header.getOrDefault("Accept")
  valid_39115998 = validateParameter(valid_39115998, JString, required = false,
                                   default = nil)
  if valid_39115998 != nil:
    section.add "Accept", valid_39115998
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39115999: Call_GetGitignoreTemplates_39115995;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Listing available templates.
  ## List all templates available to pass as an option when creating a repository.
  ## 
  ## 
  let valid = call_39115999.validator(path, query, header, formData, body, _)
  let scheme = call_39115999.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39115999.url(scheme.get, call_39115999.host, call_39115999.base,
                           call_39115999.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39115999, url, valid, _)

proc call*(call_39116000: Call_GetGitignoreTemplates_39115995; Accept: string = ""): Recallable =
  ## getGitignoreTemplates
  ## Listing available templates.
  ## List all templates available to pass as an option when creating a repository.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_39116001 = newJObject()
  add(header_39116001, "Accept", newJString(Accept))
  result = call_39116000.call(nil, nil, header_39116001, nil, nil)

var getGitignoreTemplates* = Call_GetGitignoreTemplates_39115995(
    name: "getGitignoreTemplates", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/gitignore/templates", validator: validate_GetGitignoreTemplates_39115996,
    base: "/", url: url_GetGitignoreTemplates_39115997, schemes: {Scheme.Https})
type
  Call_GetGitignoreTemplatesLanguage_39116002 = ref object of OpenApiRestCall_39115352
proc url_GetGitignoreTemplatesLanguage_39116004(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "language" in path, "`language` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gitignore/templates/"),
               (kind: VariableSegment, value: "language")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGitignoreTemplatesLanguage_39116003(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a single template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   language: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `language` field"
  var valid_39116005 = path.getOrDefault("language")
  valid_39116005 = validateParameter(valid_39116005, JString, required = true,
                                   default = nil)
  if valid_39116005 != nil:
    section.add "language", valid_39116005
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116006 = header.getOrDefault("Accept")
  valid_39116006 = validateParameter(valid_39116006, JString, required = false,
                                   default = nil)
  if valid_39116006 != nil:
    section.add "Accept", valid_39116006
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116007: Call_GetGitignoreTemplatesLanguage_39116002;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single template.
  ## 
  let valid = call_39116007.validator(path, query, header, formData, body, _)
  let scheme = call_39116007.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116007.url(scheme.get, call_39116007.host, call_39116007.base,
                           call_39116007.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116007, url, valid, _)

proc call*(call_39116008: Call_GetGitignoreTemplatesLanguage_39116002;
          language: string; Accept: string = ""): Recallable =
  ## getGitignoreTemplatesLanguage
  ## Get a single template.
  ##   language: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39116009 = newJObject()
  var header_39116010 = newJObject()
  add(path_39116009, "language", newJString(language))
  add(header_39116010, "Accept", newJString(Accept))
  result = call_39116008.call(path_39116009, nil, header_39116010, nil, nil)

var getGitignoreTemplatesLanguage* = Call_GetGitignoreTemplatesLanguage_39116002(
    name: "getGitignoreTemplatesLanguage", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/gitignore/templates/{language}",
    validator: validate_GetGitignoreTemplatesLanguage_39116003, base: "/",
    url: url_GetGitignoreTemplatesLanguage_39116004, schemes: {Scheme.Https})
type
  Call_GetIssues_39116011 = ref object of OpenApiRestCall_39115352
proc url_GetIssues_39116013(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetIssues_39116012(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List issues.
  ## List all issues across all the authenticated user's visible repositories.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString (required)
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: JString (required)
  ##   direction: JString (required)
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_39116028 = query.getOrDefault("state")
  valid_39116028 = validateParameter(valid_39116028, JString, required = true,
                                   default = newJString("open"))
  if valid_39116028 != nil:
    section.add "state", valid_39116028
  var valid_39116029 = query.getOrDefault("labels")
  valid_39116029 = validateParameter(valid_39116029, JString, required = true,
                                   default = nil)
  if valid_39116029 != nil:
    section.add "labels", valid_39116029
  var valid_39116030 = query.getOrDefault("sort")
  valid_39116030 = validateParameter(valid_39116030, JString, required = true,
                                   default = newJString("created"))
  if valid_39116030 != nil:
    section.add "sort", valid_39116030
  var valid_39116031 = query.getOrDefault("direction")
  valid_39116031 = validateParameter(valid_39116031, JString, required = true,
                                   default = newJString("desc"))
  if valid_39116031 != nil:
    section.add "direction", valid_39116031
  var valid_39116032 = query.getOrDefault("filter")
  valid_39116032 = validateParameter(valid_39116032, JString, required = true,
                                   default = newJString("all"))
  if valid_39116032 != nil:
    section.add "filter", valid_39116032
  var valid_39116033 = query.getOrDefault("since")
  valid_39116033 = validateParameter(valid_39116033, JString, required = false,
                                   default = nil)
  if valid_39116033 != nil:
    section.add "since", valid_39116033
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116034 = header.getOrDefault("Accept")
  valid_39116034 = validateParameter(valid_39116034, JString, required = false,
                                   default = nil)
  if valid_39116034 != nil:
    section.add "Accept", valid_39116034
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116035: Call_GetIssues_39116011; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List issues.
  ## List all issues across all the authenticated user's visible repositories.
  ## 
  ## 
  let valid = call_39116035.validator(path, query, header, formData, body, _)
  let scheme = call_39116035.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116035.url(scheme.get, call_39116035.host, call_39116035.base,
                           call_39116035.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116035, url, valid, _)

proc call*(call_39116036: Call_GetIssues_39116011; labels: string;
          state: string = "open"; Accept: string = ""; sort: string = "created";
          direction: string = "desc"; filter: string = "all"; since: string = ""): Recallable =
  ## getIssues
  ## List issues.
  ## List all issues across all the authenticated user's visible repositories.
  ## 
  ##   state: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: string (required)
  ##   direction: string (required)
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  var query_39116037 = newJObject()
  var header_39116038 = newJObject()
  add(query_39116037, "state", newJString(state))
  add(header_39116038, "Accept", newJString(Accept))
  add(query_39116037, "labels", newJString(labels))
  add(query_39116037, "sort", newJString(sort))
  add(query_39116037, "direction", newJString(direction))
  add(query_39116037, "filter", newJString(filter))
  add(query_39116037, "since", newJString(since))
  result = call_39116036.call(nil, query_39116037, header_39116038, nil, nil)

var getIssues* = Call_GetIssues_39116011(name: "getIssues", meth: HttpMethod.HttpGet,
                                      host: "api.github.com", route: "/issues",
                                      validator: validate_GetIssues_39116012,
                                      base: "/", url: url_GetIssues_39116013,
                                      schemes: {Scheme.Https})
type
  Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_39116040 = ref object of OpenApiRestCall_39115352
proc url_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_39116042(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repository" in path, "`repository` is a required path parameter"
  assert "state" in path, "`state` is a required path parameter"
  assert "keyword" in path, "`keyword` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/issues/search/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repository"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "state"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "keyword")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_39116041(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## Find issues by state and keyword.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##   repository: JString (required)
  ##   keyword: JString (required)
  ##          : The search term.
  ##   state: JString (required)
  ##        : Indicates the state of the issues to return. Can be either open or closed.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116043 = path.getOrDefault("owner")
  valid_39116043 = validateParameter(valid_39116043, JString, required = true,
                                   default = nil)
  if valid_39116043 != nil:
    section.add "owner", valid_39116043
  var valid_39116044 = path.getOrDefault("repository")
  valid_39116044 = validateParameter(valid_39116044, JString, required = true,
                                   default = nil)
  if valid_39116044 != nil:
    section.add "repository", valid_39116044
  var valid_39116045 = path.getOrDefault("keyword")
  valid_39116045 = validateParameter(valid_39116045, JString, required = true,
                                   default = nil)
  if valid_39116045 != nil:
    section.add "keyword", valid_39116045
  var valid_39116046 = path.getOrDefault("state")
  valid_39116046 = validateParameter(valid_39116046, JString, required = true,
                                   default = newJString("open"))
  if valid_39116046 != nil:
    section.add "state", valid_39116046
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116047 = header.getOrDefault("Accept")
  valid_39116047 = validateParameter(valid_39116047, JString, required = false,
                                   default = nil)
  if valid_39116047 != nil:
    section.add "Accept", valid_39116047
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116048: Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_39116040;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Find issues by state and keyword.
  ## 
  let valid = call_39116048.validator(path, query, header, formData, body, _)
  let scheme = call_39116048.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116048.url(scheme.get, call_39116048.host, call_39116048.base,
                           call_39116048.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116048, url, valid, _)

proc call*(call_39116049: Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_39116040;
          owner: string; repository: string; keyword: string; Accept: string = "";
          state: string = "open"): Recallable =
  ## getLegacyIssuesSearchOwnerRepositoryStateKeyword
  ## Find issues by state and keyword.
  ##   owner: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repository: string (required)
  ##   keyword: string (required)
  ##          : The search term.
  ##   state: string (required)
  ##        : Indicates the state of the issues to return. Can be either open or closed.
  var path_39116050 = newJObject()
  var header_39116051 = newJObject()
  add(path_39116050, "owner", newJString(owner))
  add(header_39116051, "Accept", newJString(Accept))
  add(path_39116050, "repository", newJString(repository))
  add(path_39116050, "keyword", newJString(keyword))
  add(path_39116050, "state", newJString(state))
  result = call_39116049.call(path_39116050, nil, header_39116051, nil, nil)

var getLegacyIssuesSearchOwnerRepositoryStateKeyword* = Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_39116040(
    name: "getLegacyIssuesSearchOwnerRepositoryStateKeyword",
    meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/legacy/issues/search/{owner}/{repository}/{state}/{keyword}",
    validator: validate_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_39116041,
    base: "/", url: url_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_39116042,
    schemes: {Scheme.Https})
type
  Call_GetLegacyReposSearchKeyword_39116052 = ref object of OpenApiRestCall_39115352
proc url_GetLegacyReposSearchKeyword_39116054(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyword" in path, "`keyword` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/repos/search/"),
               (kind: VariableSegment, value: "keyword")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyReposSearchKeyword_39116053(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Find repositories by keyword. Note, this legacy method does not follow the v3 pagination pattern. This method returns up to 100 results per page and pages can be fetched using the start_page parameter.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyword: JString (required)
  ##          : The search term
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyword` field"
  var valid_39116055 = path.getOrDefault("keyword")
  valid_39116055 = validateParameter(valid_39116055, JString, required = true,
                                   default = nil)
  if valid_39116055 != nil:
    section.add "keyword", valid_39116055
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   language: JString
  ##           : Filter results by language
  ##   start_page: JString
  ##             : The page number to fetch
  ##   sort: JString
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  section = newJObject()
  var valid_39116056 = query.getOrDefault("order")
  valid_39116056 = validateParameter(valid_39116056, JString, required = false,
                                   default = newJString("desc"))
  if valid_39116056 != nil:
    section.add "order", valid_39116056
  var valid_39116057 = query.getOrDefault("language")
  valid_39116057 = validateParameter(valid_39116057, JString, required = false,
                                   default = nil)
  if valid_39116057 != nil:
    section.add "language", valid_39116057
  var valid_39116058 = query.getOrDefault("start_page")
  valid_39116058 = validateParameter(valid_39116058, JString, required = false,
                                   default = nil)
  if valid_39116058 != nil:
    section.add "start_page", valid_39116058
  var valid_39116059 = query.getOrDefault("sort")
  valid_39116059 = validateParameter(valid_39116059, JString, required = false,
                                   default = newJString("updated"))
  if valid_39116059 != nil:
    section.add "sort", valid_39116059
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116060 = header.getOrDefault("Accept")
  valid_39116060 = validateParameter(valid_39116060, JString, required = false,
                                   default = nil)
  if valid_39116060 != nil:
    section.add "Accept", valid_39116060
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116061: Call_GetLegacyReposSearchKeyword_39116052;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Find repositories by keyword. Note, this legacy method does not follow the v3 pagination pattern. This method returns up to 100 results per page and pages can be fetched using the start_page parameter.
  ## 
  let valid = call_39116061.validator(path, query, header, formData, body, _)
  let scheme = call_39116061.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116061.url(scheme.get, call_39116061.host, call_39116061.base,
                           call_39116061.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116061, url, valid, _)

proc call*(call_39116062: Call_GetLegacyReposSearchKeyword_39116052;
          keyword: string; order: string = "desc"; language: string = "";
          Accept: string = ""; startPage: string = ""; sort: string = "updated"): Recallable =
  ## getLegacyReposSearchKeyword
  ## Find repositories by keyword. Note, this legacy method does not follow the v3 pagination pattern. This method returns up to 100 results per page and pages can be fetched using the start_page parameter.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   language: string
  ##           : Filter results by language
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   startPage: string
  ##            : The page number to fetch
  ##   sort: string
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  ##   keyword: string (required)
  ##          : The search term
  var path_39116063 = newJObject()
  var query_39116064 = newJObject()
  var header_39116065 = newJObject()
  add(query_39116064, "order", newJString(order))
  add(query_39116064, "language", newJString(language))
  add(header_39116065, "Accept", newJString(Accept))
  add(query_39116064, "start_page", newJString(startPage))
  add(query_39116064, "sort", newJString(sort))
  add(path_39116063, "keyword", newJString(keyword))
  result = call_39116062.call(path_39116063, query_39116064, header_39116065, nil, nil)

var getLegacyReposSearchKeyword* = Call_GetLegacyReposSearchKeyword_39116052(
    name: "getLegacyReposSearchKeyword", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/legacy/repos/search/{keyword}",
    validator: validate_GetLegacyReposSearchKeyword_39116053, base: "/",
    url: url_GetLegacyReposSearchKeyword_39116054, schemes: {Scheme.Https})
type
  Call_GetLegacyUserEmailEmail_39116066 = ref object of OpenApiRestCall_39115352
proc url_GetLegacyUserEmailEmail_39116068(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "email" in path, "`email` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/user/email/"),
               (kind: VariableSegment, value: "email")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyUserEmailEmail_39116067(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## This API call is added for compatibility reasons only.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   email: JString (required)
  ##        : The email address
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `email` field"
  var valid_39116069 = path.getOrDefault("email")
  valid_39116069 = validateParameter(valid_39116069, JString, required = true,
                                   default = nil)
  if valid_39116069 != nil:
    section.add "email", valid_39116069
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116070 = header.getOrDefault("Accept")
  valid_39116070 = validateParameter(valid_39116070, JString, required = false,
                                   default = nil)
  if valid_39116070 != nil:
    section.add "Accept", valid_39116070
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116071: Call_GetLegacyUserEmailEmail_39116066;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## This API call is added for compatibility reasons only.
  ## 
  let valid = call_39116071.validator(path, query, header, formData, body, _)
  let scheme = call_39116071.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116071.url(scheme.get, call_39116071.host, call_39116071.base,
                           call_39116071.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116071, url, valid, _)

proc call*(call_39116072: Call_GetLegacyUserEmailEmail_39116066; email: string;
          Accept: string = ""): Recallable =
  ## getLegacyUserEmailEmail
  ## This API call is added for compatibility reasons only.
  ##   email: string (required)
  ##        : The email address
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39116073 = newJObject()
  var header_39116074 = newJObject()
  add(path_39116073, "email", newJString(email))
  add(header_39116074, "Accept", newJString(Accept))
  result = call_39116072.call(path_39116073, nil, header_39116074, nil, nil)

var getLegacyUserEmailEmail* = Call_GetLegacyUserEmailEmail_39116066(
    name: "getLegacyUserEmailEmail", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/legacy/user/email/{email}",
    validator: validate_GetLegacyUserEmailEmail_39116067, base: "/",
    url: url_GetLegacyUserEmailEmail_39116068, schemes: {Scheme.Https})
type
  Call_GetLegacyUserSearchKeyword_39116075 = ref object of OpenApiRestCall_39115352
proc url_GetLegacyUserSearchKeyword_39116077(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyword" in path, "`keyword` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/user/search/"),
               (kind: VariableSegment, value: "keyword")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyUserSearchKeyword_39116076(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Find users by keyword.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyword: JString (required)
  ##          : The search term
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyword` field"
  var valid_39116078 = path.getOrDefault("keyword")
  valid_39116078 = validateParameter(valid_39116078, JString, required = true,
                                   default = nil)
  if valid_39116078 != nil:
    section.add "keyword", valid_39116078
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   start_page: JString
  ##             : The page number to fetch
  ##   sort: JString
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  section = newJObject()
  var valid_39116079 = query.getOrDefault("order")
  valid_39116079 = validateParameter(valid_39116079, JString, required = false,
                                   default = newJString("desc"))
  if valid_39116079 != nil:
    section.add "order", valid_39116079
  var valid_39116080 = query.getOrDefault("start_page")
  valid_39116080 = validateParameter(valid_39116080, JString, required = false,
                                   default = nil)
  if valid_39116080 != nil:
    section.add "start_page", valid_39116080
  var valid_39116081 = query.getOrDefault("sort")
  valid_39116081 = validateParameter(valid_39116081, JString, required = false,
                                   default = newJString("updated"))
  if valid_39116081 != nil:
    section.add "sort", valid_39116081
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116082 = header.getOrDefault("Accept")
  valid_39116082 = validateParameter(valid_39116082, JString, required = false,
                                   default = nil)
  if valid_39116082 != nil:
    section.add "Accept", valid_39116082
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116083: Call_GetLegacyUserSearchKeyword_39116075;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Find users by keyword.
  ## 
  let valid = call_39116083.validator(path, query, header, formData, body, _)
  let scheme = call_39116083.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116083.url(scheme.get, call_39116083.host, call_39116083.base,
                           call_39116083.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116083, url, valid, _)

proc call*(call_39116084: Call_GetLegacyUserSearchKeyword_39116075;
          keyword: string; order: string = "desc"; Accept: string = "";
          startPage: string = ""; sort: string = "updated"): Recallable =
  ## getLegacyUserSearchKeyword
  ## Find users by keyword.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   startPage: string
  ##            : The page number to fetch
  ##   sort: string
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  ##   keyword: string (required)
  ##          : The search term
  var path_39116085 = newJObject()
  var query_39116086 = newJObject()
  var header_39116087 = newJObject()
  add(query_39116086, "order", newJString(order))
  add(header_39116087, "Accept", newJString(Accept))
  add(query_39116086, "start_page", newJString(startPage))
  add(query_39116086, "sort", newJString(sort))
  add(path_39116085, "keyword", newJString(keyword))
  result = call_39116084.call(path_39116085, query_39116086, header_39116087, nil, nil)

var getLegacyUserSearchKeyword* = Call_GetLegacyUserSearchKeyword_39116075(
    name: "getLegacyUserSearchKeyword", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/legacy/user/search/{keyword}",
    validator: validate_GetLegacyUserSearchKeyword_39116076, base: "/",
    url: url_GetLegacyUserSearchKeyword_39116077, schemes: {Scheme.Https})
type
  Call_PostMarkdown_39116088 = ref object of OpenApiRestCall_39115352
proc url_PostMarkdown_39116090(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostMarkdown_39116089(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## Render an arbitrary Markdown document
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116091 = header.getOrDefault("Accept")
  valid_39116091 = validateParameter(valid_39116091, JString, required = false,
                                   default = nil)
  if valid_39116091 != nil:
    section.add "Accept", valid_39116091
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39116093: Call_PostMarkdown_39116088; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Render an arbitrary Markdown document
  ## 
  let valid = call_39116093.validator(path, query, header, formData, body, _)
  let scheme = call_39116093.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116093.url(scheme.get, call_39116093.host, call_39116093.base,
                           call_39116093.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116093, url, valid, _)

proc call*(call_39116094: Call_PostMarkdown_39116088; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postMarkdown
  ## Render an arbitrary Markdown document
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_39116095 = newJObject()
  var body_39116096 = newJObject()
  add(header_39116095, "Accept", newJString(Accept))
  if body != nil:
    body_39116096 = body
  result = call_39116094.call(nil, nil, header_39116095, nil, body_39116096)

var postMarkdown* = Call_PostMarkdown_39116088(name: "postMarkdown",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/markdown",
    validator: validate_PostMarkdown_39116089, base: "/", url: url_PostMarkdown_39116090,
    schemes: {Scheme.Https})
type
  Call_PostMarkdownRaw_39116097 = ref object of OpenApiRestCall_39115352
proc url_PostMarkdownRaw_39116099(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostMarkdownRaw_39116098(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Render a Markdown document in raw mode
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116100 = header.getOrDefault("Accept")
  valid_39116100 = validateParameter(valid_39116100, JString, required = false,
                                   default = nil)
  if valid_39116100 != nil:
    section.add "Accept", valid_39116100
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116101: Call_PostMarkdownRaw_39116097; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Render a Markdown document in raw mode
  ## 
  let valid = call_39116101.validator(path, query, header, formData, body, _)
  let scheme = call_39116101.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116101.url(scheme.get, call_39116101.host, call_39116101.base,
                           call_39116101.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116101, url, valid, _)

proc call*(call_39116102: Call_PostMarkdownRaw_39116097; Accept: string = ""): Recallable =
  ## postMarkdownRaw
  ## Render a Markdown document in raw mode
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_39116103 = newJObject()
  add(header_39116103, "Accept", newJString(Accept))
  result = call_39116102.call(nil, nil, header_39116103, nil, nil)

var postMarkdownRaw* = Call_PostMarkdownRaw_39116097(name: "postMarkdownRaw",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/markdown/raw",
    validator: validate_PostMarkdownRaw_39116098, base: "/",
    url: url_PostMarkdownRaw_39116099, schemes: {Scheme.Https})
type
  Call_GetMeta_39116104 = ref object of OpenApiRestCall_39115352
proc url_GetMeta_39116106(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetMeta_39116105(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## This gives some information about GitHub.com, the service.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116107 = header.getOrDefault("Accept")
  valid_39116107 = validateParameter(valid_39116107, JString, required = false,
                                   default = nil)
  if valid_39116107 != nil:
    section.add "Accept", valid_39116107
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116108: Call_GetMeta_39116104; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## This gives some information about GitHub.com, the service.
  ## 
  let valid = call_39116108.validator(path, query, header, formData, body, _)
  let scheme = call_39116108.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116108.url(scheme.get, call_39116108.host, call_39116108.base,
                           call_39116108.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116108, url, valid, _)

proc call*(call_39116109: Call_GetMeta_39116104; Accept: string = ""): Recallable =
  ## getMeta
  ## This gives some information about GitHub.com, the service.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_39116110 = newJObject()
  add(header_39116110, "Accept", newJString(Accept))
  result = call_39116109.call(nil, nil, header_39116110, nil, nil)

var getMeta* = Call_GetMeta_39116104(name: "getMeta", meth: HttpMethod.HttpGet,
                                  host: "api.github.com", route: "/meta",
                                  validator: validate_GetMeta_39116105, base: "/",
                                  url: url_GetMeta_39116106,
                                  schemes: {Scheme.Https})
type
  Call_GetNetworksOwnerRepoEvents_39116111 = ref object of OpenApiRestCall_39115352
proc url_GetNetworksOwnerRepoEvents_39116113(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/networks/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetNetworksOwnerRepoEvents_39116112(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List public events for a network of repositories.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of the owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116114 = path.getOrDefault("owner")
  valid_39116114 = validateParameter(valid_39116114, JString, required = true,
                                   default = nil)
  if valid_39116114 != nil:
    section.add "owner", valid_39116114
  var valid_39116115 = path.getOrDefault("repo")
  valid_39116115 = validateParameter(valid_39116115, JString, required = true,
                                   default = nil)
  if valid_39116115 != nil:
    section.add "repo", valid_39116115
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116116 = header.getOrDefault("Accept")
  valid_39116116 = validateParameter(valid_39116116, JString, required = false,
                                   default = nil)
  if valid_39116116 != nil:
    section.add "Accept", valid_39116116
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116117: Call_GetNetworksOwnerRepoEvents_39116111;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List public events for a network of repositories.
  ## 
  let valid = call_39116117.validator(path, query, header, formData, body, _)
  let scheme = call_39116117.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116117.url(scheme.get, call_39116117.host, call_39116117.base,
                           call_39116117.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116117, url, valid, _)

proc call*(call_39116118: Call_GetNetworksOwnerRepoEvents_39116111; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getNetworksOwnerRepoEvents
  ## List public events for a network of repositories.
  ##   owner: string (required)
  ##        : Name of the owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116119 = newJObject()
  var header_39116120 = newJObject()
  add(path_39116119, "owner", newJString(owner))
  add(header_39116120, "Accept", newJString(Accept))
  add(path_39116119, "repo", newJString(repo))
  result = call_39116118.call(path_39116119, nil, header_39116120, nil, nil)

var getNetworksOwnerRepoEvents* = Call_GetNetworksOwnerRepoEvents_39116111(
    name: "getNetworksOwnerRepoEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/networks/{owner}/{repo}/events",
    validator: validate_GetNetworksOwnerRepoEvents_39116112, base: "/",
    url: url_GetNetworksOwnerRepoEvents_39116113, schemes: {Scheme.Https})
type
  Call_PutNotifications_39116132 = ref object of OpenApiRestCall_39115352
proc url_PutNotifications_39116134(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PutNotifications_39116133(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Mark as read.
  ## Marking a notification as "read" removes it from the default view on GitHub.com.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116135 = header.getOrDefault("Accept")
  valid_39116135 = validateParameter(valid_39116135, JString, required = false,
                                   default = nil)
  if valid_39116135 != nil:
    section.add "Accept", valid_39116135
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39116137: Call_PutNotifications_39116132; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Mark as read.
  ## Marking a notification as "read" removes it from the default view on GitHub.com.
  ## 
  ## 
  let valid = call_39116137.validator(path, query, header, formData, body, _)
  let scheme = call_39116137.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116137.url(scheme.get, call_39116137.host, call_39116137.base,
                           call_39116137.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116137, url, valid, _)

proc call*(call_39116138: Call_PutNotifications_39116132; body: JsonNode;
          Accept: string = ""): Recallable =
  ## putNotifications
  ## Mark as read.
  ## Marking a notification as "read" removes it from the default view on GitHub.com.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_39116139 = newJObject()
  var body_39116140 = newJObject()
  add(header_39116139, "Accept", newJString(Accept))
  if body != nil:
    body_39116140 = body
  result = call_39116138.call(nil, nil, header_39116139, nil, body_39116140)

var putNotifications* = Call_PutNotifications_39116132(name: "putNotifications",
    meth: HttpMethod.HttpPut, host: "api.github.com", route: "/notifications",
    validator: validate_PutNotifications_39116133, base: "/",
    url: url_PutNotifications_39116134, schemes: {Scheme.Https})
type
  Call_GetNotifications_39116121 = ref object of OpenApiRestCall_39115352
proc url_GetNotifications_39116123(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetNotifications_39116122(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List your notifications.
  ## List all notifications for the current user, grouped by repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   participating: JBool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  ##   all: JBool
  ##      : True to show notifications marked as read.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_39116124 = query.getOrDefault("participating")
  valid_39116124 = validateParameter(valid_39116124, JBool, required = false,
                                   default = nil)
  if valid_39116124 != nil:
    section.add "participating", valid_39116124
  var valid_39116125 = query.getOrDefault("all")
  valid_39116125 = validateParameter(valid_39116125, JBool, required = false,
                                   default = nil)
  if valid_39116125 != nil:
    section.add "all", valid_39116125
  var valid_39116126 = query.getOrDefault("since")
  valid_39116126 = validateParameter(valid_39116126, JString, required = false,
                                   default = nil)
  if valid_39116126 != nil:
    section.add "since", valid_39116126
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116127 = header.getOrDefault("Accept")
  valid_39116127 = validateParameter(valid_39116127, JString, required = false,
                                   default = nil)
  if valid_39116127 != nil:
    section.add "Accept", valid_39116127
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116128: Call_GetNotifications_39116121; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List your notifications.
  ## List all notifications for the current user, grouped by repository.
  ## 
  ## 
  let valid = call_39116128.validator(path, query, header, formData, body, _)
  let scheme = call_39116128.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116128.url(scheme.get, call_39116128.host, call_39116128.base,
                           call_39116128.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116128, url, valid, _)

proc call*(call_39116129: Call_GetNotifications_39116121;
          participating: bool = false; all: bool = false; Accept: string = "";
          since: string = ""): Recallable =
  ## getNotifications
  ## List your notifications.
  ## List all notifications for the current user, grouped by repository.
  ## 
  ##   participating: bool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  ##   all: bool
  ##      : True to show notifications marked as read.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var query_39116130 = newJObject()
  var header_39116131 = newJObject()
  add(query_39116130, "participating", newJBool(participating))
  add(query_39116130, "all", newJBool(all))
  add(header_39116131, "Accept", newJString(Accept))
  add(query_39116130, "since", newJString(since))
  result = call_39116129.call(nil, query_39116130, header_39116131, nil, nil)

var getNotifications* = Call_GetNotifications_39116121(name: "getNotifications",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/notifications",
    validator: validate_GetNotifications_39116122, base: "/",
    url: url_GetNotifications_39116123, schemes: {Scheme.Https})
type
  Call_GetNotificationsThreadsId_39116141 = ref object of OpenApiRestCall_39115352
proc url_GetNotificationsThreadsId_39116143(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetNotificationsThreadsId_39116142(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## View a single thread.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39116144 = path.getOrDefault("id")
  valid_39116144 = validateParameter(valid_39116144, JInt, required = true,
                                   default = nil)
  if valid_39116144 != nil:
    section.add "id", valid_39116144
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116145 = header.getOrDefault("Accept")
  valid_39116145 = validateParameter(valid_39116145, JString, required = false,
                                   default = nil)
  if valid_39116145 != nil:
    section.add "Accept", valid_39116145
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116146: Call_GetNotificationsThreadsId_39116141;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## View a single thread.
  ## 
  let valid = call_39116146.validator(path, query, header, formData, body, _)
  let scheme = call_39116146.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116146.url(scheme.get, call_39116146.host, call_39116146.base,
                           call_39116146.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116146, url, valid, _)

proc call*(call_39116147: Call_GetNotificationsThreadsId_39116141; id: int;
          Accept: string = ""): Recallable =
  ## getNotificationsThreadsId
  ## View a single thread.
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39116148 = newJObject()
  var header_39116149 = newJObject()
  add(path_39116148, "id", newJInt(id))
  add(header_39116149, "Accept", newJString(Accept))
  result = call_39116147.call(path_39116148, nil, header_39116149, nil, nil)

var getNotificationsThreadsId* = Call_GetNotificationsThreadsId_39116141(
    name: "getNotificationsThreadsId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/notifications/threads/{id}",
    validator: validate_GetNotificationsThreadsId_39116142, base: "/",
    url: url_GetNotificationsThreadsId_39116143, schemes: {Scheme.Https})
type
  Call_PatchNotificationsThreadsId_39116150 = ref object of OpenApiRestCall_39115352
proc url_PatchNotificationsThreadsId_39116152(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchNotificationsThreadsId_39116151(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Mark a thread as read
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39116153 = path.getOrDefault("id")
  valid_39116153 = validateParameter(valid_39116153, JInt, required = true,
                                   default = nil)
  if valid_39116153 != nil:
    section.add "id", valid_39116153
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116154 = header.getOrDefault("Accept")
  valid_39116154 = validateParameter(valid_39116154, JString, required = false,
                                   default = nil)
  if valid_39116154 != nil:
    section.add "Accept", valid_39116154
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116155: Call_PatchNotificationsThreadsId_39116150;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Mark a thread as read
  ## 
  let valid = call_39116155.validator(path, query, header, formData, body, _)
  let scheme = call_39116155.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116155.url(scheme.get, call_39116155.host, call_39116155.base,
                           call_39116155.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116155, url, valid, _)

proc call*(call_39116156: Call_PatchNotificationsThreadsId_39116150; id: int;
          Accept: string = ""): Recallable =
  ## patchNotificationsThreadsId
  ## Mark a thread as read
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39116157 = newJObject()
  var header_39116158 = newJObject()
  add(path_39116157, "id", newJInt(id))
  add(header_39116158, "Accept", newJString(Accept))
  result = call_39116156.call(path_39116157, nil, header_39116158, nil, nil)

var patchNotificationsThreadsId* = Call_PatchNotificationsThreadsId_39116150(
    name: "patchNotificationsThreadsId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/notifications/threads/{id}",
    validator: validate_PatchNotificationsThreadsId_39116151, base: "/",
    url: url_PatchNotificationsThreadsId_39116152, schemes: {Scheme.Https})
type
  Call_PutNotificationsThreadsIdSubscription_39116168 = ref object of OpenApiRestCall_39115352
proc url_PutNotificationsThreadsIdSubscription_39116170(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutNotificationsThreadsIdSubscription_39116169(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Set a Thread Subscription.
  ## This lets you subscribe to a thread, or ignore it. Subscribing to a thread
  ## is unnecessary if the user is already subscribed to the repository. Ignoring
  ## a thread will mute all future notifications (until you comment or get @mentioned).
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39116171 = path.getOrDefault("id")
  valid_39116171 = validateParameter(valid_39116171, JInt, required = true,
                                   default = nil)
  if valid_39116171 != nil:
    section.add "id", valid_39116171
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116172 = header.getOrDefault("Accept")
  valid_39116172 = validateParameter(valid_39116172, JString, required = false,
                                   default = nil)
  if valid_39116172 != nil:
    section.add "Accept", valid_39116172
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39116174: Call_PutNotificationsThreadsIdSubscription_39116168;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Set a Thread Subscription.
  ## This lets you subscribe to a thread, or ignore it. Subscribing to a thread
  ## is unnecessary if the user is already subscribed to the repository. Ignoring
  ## a thread will mute all future notifications (until you comment or get @mentioned).
  ## 
  ## 
  let valid = call_39116174.validator(path, query, header, formData, body, _)
  let scheme = call_39116174.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116174.url(scheme.get, call_39116174.host, call_39116174.base,
                           call_39116174.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116174, url, valid, _)

proc call*(call_39116175: Call_PutNotificationsThreadsIdSubscription_39116168;
          id: int; body: JsonNode; Accept: string = ""): Recallable =
  ## putNotificationsThreadsIdSubscription
  ## Set a Thread Subscription.
  ## This lets you subscribe to a thread, or ignore it. Subscribing to a thread
  ## is unnecessary if the user is already subscribed to the repository. Ignoring
  ## a thread will mute all future notifications (until you comment or get @mentioned).
  ## 
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var path_39116176 = newJObject()
  var header_39116177 = newJObject()
  var body_39116178 = newJObject()
  add(path_39116176, "id", newJInt(id))
  add(header_39116177, "Accept", newJString(Accept))
  if body != nil:
    body_39116178 = body
  result = call_39116175.call(path_39116176, nil, header_39116177, nil, body_39116178)

var putNotificationsThreadsIdSubscription* = Call_PutNotificationsThreadsIdSubscription_39116168(
    name: "putNotificationsThreadsIdSubscription", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/notifications/threads/{id}/subscription",
    validator: validate_PutNotificationsThreadsIdSubscription_39116169, base: "/",
    url: url_PutNotificationsThreadsIdSubscription_39116170,
    schemes: {Scheme.Https})
type
  Call_GetNotificationsThreadsIdSubscription_39116159 = ref object of OpenApiRestCall_39115352
proc url_GetNotificationsThreadsIdSubscription_39116161(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetNotificationsThreadsIdSubscription_39116160(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a Thread Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39116162 = path.getOrDefault("id")
  valid_39116162 = validateParameter(valid_39116162, JInt, required = true,
                                   default = nil)
  if valid_39116162 != nil:
    section.add "id", valid_39116162
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116163 = header.getOrDefault("Accept")
  valid_39116163 = validateParameter(valid_39116163, JString, required = false,
                                   default = nil)
  if valid_39116163 != nil:
    section.add "Accept", valid_39116163
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116164: Call_GetNotificationsThreadsIdSubscription_39116159;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a Thread Subscription.
  ## 
  let valid = call_39116164.validator(path, query, header, formData, body, _)
  let scheme = call_39116164.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116164.url(scheme.get, call_39116164.host, call_39116164.base,
                           call_39116164.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116164, url, valid, _)

proc call*(call_39116165: Call_GetNotificationsThreadsIdSubscription_39116159;
          id: int; Accept: string = ""): Recallable =
  ## getNotificationsThreadsIdSubscription
  ## Get a Thread Subscription.
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39116166 = newJObject()
  var header_39116167 = newJObject()
  add(path_39116166, "id", newJInt(id))
  add(header_39116167, "Accept", newJString(Accept))
  result = call_39116165.call(path_39116166, nil, header_39116167, nil, nil)

var getNotificationsThreadsIdSubscription* = Call_GetNotificationsThreadsIdSubscription_39116159(
    name: "getNotificationsThreadsIdSubscription", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/notifications/threads/{id}/subscription",
    validator: validate_GetNotificationsThreadsIdSubscription_39116160, base: "/",
    url: url_GetNotificationsThreadsIdSubscription_39116161,
    schemes: {Scheme.Https})
type
  Call_DeleteNotificationsThreadsIdSubscription_39116179 = ref object of OpenApiRestCall_39115352
proc url_DeleteNotificationsThreadsIdSubscription_39116181(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteNotificationsThreadsIdSubscription_39116180(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a Thread Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_39116182 = path.getOrDefault("id")
  valid_39116182 = validateParameter(valid_39116182, JInt, required = true,
                                   default = nil)
  if valid_39116182 != nil:
    section.add "id", valid_39116182
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116183 = header.getOrDefault("Accept")
  valid_39116183 = validateParameter(valid_39116183, JString, required = false,
                                   default = nil)
  if valid_39116183 != nil:
    section.add "Accept", valid_39116183
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116184: Call_DeleteNotificationsThreadsIdSubscription_39116179;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a Thread Subscription.
  ## 
  let valid = call_39116184.validator(path, query, header, formData, body, _)
  let scheme = call_39116184.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116184.url(scheme.get, call_39116184.host, call_39116184.base,
                           call_39116184.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116184, url, valid, _)

proc call*(call_39116185: Call_DeleteNotificationsThreadsIdSubscription_39116179;
          id: int; Accept: string = ""): Recallable =
  ## deleteNotificationsThreadsIdSubscription
  ## Delete a Thread Subscription.
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39116186 = newJObject()
  var header_39116187 = newJObject()
  add(path_39116186, "id", newJInt(id))
  add(header_39116187, "Accept", newJString(Accept))
  result = call_39116185.call(path_39116186, nil, header_39116187, nil, nil)

var deleteNotificationsThreadsIdSubscription* = Call_DeleteNotificationsThreadsIdSubscription_39116179(
    name: "deleteNotificationsThreadsIdSubscription", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/notifications/threads/{id}/subscription",
    validator: validate_DeleteNotificationsThreadsIdSubscription_39116180,
    base: "/", url: url_DeleteNotificationsThreadsIdSubscription_39116181,
    schemes: {Scheme.Https})
type
  Call_GetOrgsOrg_39116188 = ref object of OpenApiRestCall_39115352
proc url_GetOrgsOrg_39116190(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrg_39116189(path: JsonNode; query: JsonNode; header: JsonNode;
                                 formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get an Organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_39116191 = path.getOrDefault("org")
  valid_39116191 = validateParameter(valid_39116191, JString, required = true,
                                   default = nil)
  if valid_39116191 != nil:
    section.add "org", valid_39116191
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116192 = header.getOrDefault("Accept")
  valid_39116192 = validateParameter(valid_39116192, JString, required = false,
                                   default = nil)
  if valid_39116192 != nil:
    section.add "Accept", valid_39116192
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116193: Call_GetOrgsOrg_39116188; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get an Organization.
  ## 
  let valid = call_39116193.validator(path, query, header, formData, body, _)
  let scheme = call_39116193.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116193.url(scheme.get, call_39116193.host, call_39116193.base,
                           call_39116193.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116193, url, valid, _)

proc call*(call_39116194: Call_GetOrgsOrg_39116188; org: string; Accept: string = ""): Recallable =
  ## getOrgsOrg
  ## Get an Organization.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_39116195 = newJObject()
  var header_39116196 = newJObject()
  add(header_39116196, "Accept", newJString(Accept))
  add(path_39116195, "org", newJString(org))
  result = call_39116194.call(path_39116195, nil, header_39116196, nil, nil)

var getOrgsOrg* = Call_GetOrgsOrg_39116188(name: "getOrgsOrg",
                                        meth: HttpMethod.HttpGet,
                                        host: "api.github.com",
                                        route: "/orgs/{org}",
                                        validator: validate_GetOrgsOrg_39116189,
                                        base: "/", url: url_GetOrgsOrg_39116190,
                                        schemes: {Scheme.Https})
type
  Call_PatchOrgsOrg_39116197 = ref object of OpenApiRestCall_39115352
proc url_PatchOrgsOrg_39116199(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchOrgsOrg_39116198(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## Edit an Organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_39116200 = path.getOrDefault("org")
  valid_39116200 = validateParameter(valid_39116200, JString, required = true,
                                   default = nil)
  if valid_39116200 != nil:
    section.add "org", valid_39116200
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116201 = header.getOrDefault("Accept")
  valid_39116201 = validateParameter(valid_39116201, JString, required = false,
                                   default = nil)
  if valid_39116201 != nil:
    section.add "Accept", valid_39116201
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39116203: Call_PatchOrgsOrg_39116197; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit an Organization.
  ## 
  let valid = call_39116203.validator(path, query, header, formData, body, _)
  let scheme = call_39116203.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116203.url(scheme.get, call_39116203.host, call_39116203.base,
                           call_39116203.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116203, url, valid, _)

proc call*(call_39116204: Call_PatchOrgsOrg_39116197; body: JsonNode; org: string;
          Accept: string = ""): Recallable =
  ## patchOrgsOrg
  ## Edit an Organization.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   org: string (required)
  ##      : Name of organisation.
  var path_39116205 = newJObject()
  var header_39116206 = newJObject()
  var body_39116207 = newJObject()
  add(header_39116206, "Accept", newJString(Accept))
  if body != nil:
    body_39116207 = body
  add(path_39116205, "org", newJString(org))
  result = call_39116204.call(path_39116205, nil, header_39116206, nil, body_39116207)

var patchOrgsOrg* = Call_PatchOrgsOrg_39116197(name: "patchOrgsOrg",
    meth: HttpMethod.HttpPatch, host: "api.github.com", route: "/orgs/{org}",
    validator: validate_PatchOrgsOrg_39116198, base: "/", url: url_PatchOrgsOrg_39116199,
    schemes: {Scheme.Https})
type
  Call_GetOrgsOrgEvents_39116208 = ref object of OpenApiRestCall_39115352
proc url_GetOrgsOrgEvents_39116210(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgEvents_39116209(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List public events for an organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_39116211 = path.getOrDefault("org")
  valid_39116211 = validateParameter(valid_39116211, JString, required = true,
                                   default = nil)
  if valid_39116211 != nil:
    section.add "org", valid_39116211
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116212 = header.getOrDefault("Accept")
  valid_39116212 = validateParameter(valid_39116212, JString, required = false,
                                   default = nil)
  if valid_39116212 != nil:
    section.add "Accept", valid_39116212
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116213: Call_GetOrgsOrgEvents_39116208; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List public events for an organization.
  ## 
  let valid = call_39116213.validator(path, query, header, formData, body, _)
  let scheme = call_39116213.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116213.url(scheme.get, call_39116213.host, call_39116213.base,
                           call_39116213.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116213, url, valid, _)

proc call*(call_39116214: Call_GetOrgsOrgEvents_39116208; org: string;
          Accept: string = ""): Recallable =
  ## getOrgsOrgEvents
  ## List public events for an organization.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_39116215 = newJObject()
  var header_39116216 = newJObject()
  add(header_39116216, "Accept", newJString(Accept))
  add(path_39116215, "org", newJString(org))
  result = call_39116214.call(path_39116215, nil, header_39116216, nil, nil)

var getOrgsOrgEvents* = Call_GetOrgsOrgEvents_39116208(name: "getOrgsOrgEvents",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/events",
    validator: validate_GetOrgsOrgEvents_39116209, base: "/",
    url: url_GetOrgsOrgEvents_39116210, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgIssues_39116217 = ref object of OpenApiRestCall_39115352
proc url_GetOrgsOrgIssues_39116219(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/issues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgIssues_39116218(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List issues.
  ## List all issues for a given organization for the authenticated user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_39116220 = path.getOrDefault("org")
  valid_39116220 = validateParameter(valid_39116220, JString, required = true,
                                   default = nil)
  if valid_39116220 != nil:
    section.add "org", valid_39116220
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString (required)
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: JString (required)
  ##   direction: JString (required)
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_39116221 = query.getOrDefault("state")
  valid_39116221 = validateParameter(valid_39116221, JString, required = true,
                                   default = newJString("open"))
  if valid_39116221 != nil:
    section.add "state", valid_39116221
  var valid_39116222 = query.getOrDefault("labels")
  valid_39116222 = validateParameter(valid_39116222, JString, required = true,
                                   default = nil)
  if valid_39116222 != nil:
    section.add "labels", valid_39116222
  var valid_39116223 = query.getOrDefault("sort")
  valid_39116223 = validateParameter(valid_39116223, JString, required = true,
                                   default = newJString("created"))
  if valid_39116223 != nil:
    section.add "sort", valid_39116223
  var valid_39116224 = query.getOrDefault("direction")
  valid_39116224 = validateParameter(valid_39116224, JString, required = true,
                                   default = newJString("desc"))
  if valid_39116224 != nil:
    section.add "direction", valid_39116224
  var valid_39116225 = query.getOrDefault("filter")
  valid_39116225 = validateParameter(valid_39116225, JString, required = true,
                                   default = newJString("all"))
  if valid_39116225 != nil:
    section.add "filter", valid_39116225
  var valid_39116226 = query.getOrDefault("since")
  valid_39116226 = validateParameter(valid_39116226, JString, required = false,
                                   default = nil)
  if valid_39116226 != nil:
    section.add "since", valid_39116226
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116227 = header.getOrDefault("Accept")
  valid_39116227 = validateParameter(valid_39116227, JString, required = false,
                                   default = nil)
  if valid_39116227 != nil:
    section.add "Accept", valid_39116227
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116228: Call_GetOrgsOrgIssues_39116217; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List issues.
  ## List all issues for a given organization for the authenticated user.
  ## 
  ## 
  let valid = call_39116228.validator(path, query, header, formData, body, _)
  let scheme = call_39116228.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116228.url(scheme.get, call_39116228.host, call_39116228.base,
                           call_39116228.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116228, url, valid, _)

proc call*(call_39116229: Call_GetOrgsOrgIssues_39116217; labels: string;
          org: string; state: string = "open"; Accept: string = "";
          sort: string = "created"; direction: string = "desc"; filter: string = "all";
          since: string = ""): Recallable =
  ## getOrgsOrgIssues
  ## List issues.
  ## List all issues for a given organization for the authenticated user.
  ## 
  ##   state: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: string (required)
  ##   direction: string (required)
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   org: string (required)
  ##      : Name of organisation.
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  var path_39116230 = newJObject()
  var query_39116231 = newJObject()
  var header_39116232 = newJObject()
  add(query_39116231, "state", newJString(state))
  add(header_39116232, "Accept", newJString(Accept))
  add(query_39116231, "labels", newJString(labels))
  add(query_39116231, "sort", newJString(sort))
  add(query_39116231, "direction", newJString(direction))
  add(query_39116231, "filter", newJString(filter))
  add(path_39116230, "org", newJString(org))
  add(query_39116231, "since", newJString(since))
  result = call_39116229.call(path_39116230, query_39116231, header_39116232, nil, nil)

var getOrgsOrgIssues* = Call_GetOrgsOrgIssues_39116217(name: "getOrgsOrgIssues",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/issues",
    validator: validate_GetOrgsOrgIssues_39116218, base: "/",
    url: url_GetOrgsOrgIssues_39116219, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgMembers_39116233 = ref object of OpenApiRestCall_39115352
proc url_GetOrgsOrgMembers_39116235(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/members")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgMembers_39116234(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Members list.
  ## List all users who are members of an organization. A member is a user tha
  ## belongs to at least 1 team in the organization. If the authenticated user
  ## is also an owner of this organization then both concealed and public members
  ## will be returned. If the requester is not an owner of the organization the
  ## query will be redirected to the public members list.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_39116236 = path.getOrDefault("org")
  valid_39116236 = validateParameter(valid_39116236, JString, required = true,
                                   default = nil)
  if valid_39116236 != nil:
    section.add "org", valid_39116236
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116237 = header.getOrDefault("Accept")
  valid_39116237 = validateParameter(valid_39116237, JString, required = false,
                                   default = nil)
  if valid_39116237 != nil:
    section.add "Accept", valid_39116237
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116238: Call_GetOrgsOrgMembers_39116233; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Members list.
  ## List all users who are members of an organization. A member is a user tha
  ## belongs to at least 1 team in the organization. If the authenticated user
  ## is also an owner of this organization then both concealed and public members
  ## will be returned. If the requester is not an owner of the organization the
  ## query will be redirected to the public members list.
  ## 
  ## 
  let valid = call_39116238.validator(path, query, header, formData, body, _)
  let scheme = call_39116238.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116238.url(scheme.get, call_39116238.host, call_39116238.base,
                           call_39116238.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116238, url, valid, _)

proc call*(call_39116239: Call_GetOrgsOrgMembers_39116233; org: string;
          Accept: string = ""): Recallable =
  ## getOrgsOrgMembers
  ## Members list.
  ## List all users who are members of an organization. A member is a user tha
  ## belongs to at least 1 team in the organization. If the authenticated user
  ## is also an owner of this organization then both concealed and public members
  ## will be returned. If the requester is not an owner of the organization the
  ## query will be redirected to the public members list.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_39116240 = newJObject()
  var header_39116241 = newJObject()
  add(header_39116241, "Accept", newJString(Accept))
  add(path_39116240, "org", newJString(org))
  result = call_39116239.call(path_39116240, nil, header_39116241, nil, nil)

var getOrgsOrgMembers* = Call_GetOrgsOrgMembers_39116233(name: "getOrgsOrgMembers",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/members",
    validator: validate_GetOrgsOrgMembers_39116234, base: "/",
    url: url_GetOrgsOrgMembers_39116235, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgMembersUsername_39116242 = ref object of OpenApiRestCall_39115352
proc url_GetOrgsOrgMembersUsername_39116244(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgMembersUsername_39116243(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Check if a user is, publicly or privately, a member of the organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of the user.
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39116245 = path.getOrDefault("username")
  valid_39116245 = validateParameter(valid_39116245, JString, required = true,
                                   default = nil)
  if valid_39116245 != nil:
    section.add "username", valid_39116245
  var valid_39116246 = path.getOrDefault("org")
  valid_39116246 = validateParameter(valid_39116246, JString, required = true,
                                   default = nil)
  if valid_39116246 != nil:
    section.add "org", valid_39116246
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116247 = header.getOrDefault("Accept")
  valid_39116247 = validateParameter(valid_39116247, JString, required = false,
                                   default = nil)
  if valid_39116247 != nil:
    section.add "Accept", valid_39116247
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116248: Call_GetOrgsOrgMembersUsername_39116242;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if a user is, publicly or privately, a member of the organization.
  ## 
  let valid = call_39116248.validator(path, query, header, formData, body, _)
  let scheme = call_39116248.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116248.url(scheme.get, call_39116248.host, call_39116248.base,
                           call_39116248.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116248, url, valid, _)

proc call*(call_39116249: Call_GetOrgsOrgMembersUsername_39116242;
          username: string; org: string; Accept: string = ""): Recallable =
  ## getOrgsOrgMembersUsername
  ## Check if a user is, publicly or privately, a member of the organization.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_39116250 = newJObject()
  var header_39116251 = newJObject()
  add(path_39116250, "username", newJString(username))
  add(header_39116251, "Accept", newJString(Accept))
  add(path_39116250, "org", newJString(org))
  result = call_39116249.call(path_39116250, nil, header_39116251, nil, nil)

var getOrgsOrgMembersUsername* = Call_GetOrgsOrgMembersUsername_39116242(
    name: "getOrgsOrgMembersUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/orgs/{org}/members/{username}",
    validator: validate_GetOrgsOrgMembersUsername_39116243, base: "/",
    url: url_GetOrgsOrgMembersUsername_39116244, schemes: {Scheme.Https})
type
  Call_DeleteOrgsOrgMembersUsername_39116252 = ref object of OpenApiRestCall_39115352
proc url_DeleteOrgsOrgMembersUsername_39116254(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteOrgsOrgMembersUsername_39116253(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Remove a member.
  ## Removing a user from this list will remove them from all teams and they
  ## will no longer have any access to the organization's repositories.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of the user.
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39116255 = path.getOrDefault("username")
  valid_39116255 = validateParameter(valid_39116255, JString, required = true,
                                   default = nil)
  if valid_39116255 != nil:
    section.add "username", valid_39116255
  var valid_39116256 = path.getOrDefault("org")
  valid_39116256 = validateParameter(valid_39116256, JString, required = true,
                                   default = nil)
  if valid_39116256 != nil:
    section.add "org", valid_39116256
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116257 = header.getOrDefault("Accept")
  valid_39116257 = validateParameter(valid_39116257, JString, required = false,
                                   default = nil)
  if valid_39116257 != nil:
    section.add "Accept", valid_39116257
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116258: Call_DeleteOrgsOrgMembersUsername_39116252;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Remove a member.
  ## Removing a user from this list will remove them from all teams and they
  ## will no longer have any access to the organization's repositories.
  ## 
  ## 
  let valid = call_39116258.validator(path, query, header, formData, body, _)
  let scheme = call_39116258.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116258.url(scheme.get, call_39116258.host, call_39116258.base,
                           call_39116258.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116258, url, valid, _)

proc call*(call_39116259: Call_DeleteOrgsOrgMembersUsername_39116252;
          username: string; org: string; Accept: string = ""): Recallable =
  ## deleteOrgsOrgMembersUsername
  ## Remove a member.
  ## Removing a user from this list will remove them from all teams and they
  ## will no longer have any access to the organization's repositories.
  ## 
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_39116260 = newJObject()
  var header_39116261 = newJObject()
  add(path_39116260, "username", newJString(username))
  add(header_39116261, "Accept", newJString(Accept))
  add(path_39116260, "org", newJString(org))
  result = call_39116259.call(path_39116260, nil, header_39116261, nil, nil)

var deleteOrgsOrgMembersUsername* = Call_DeleteOrgsOrgMembersUsername_39116252(
    name: "deleteOrgsOrgMembersUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/orgs/{org}/members/{username}",
    validator: validate_DeleteOrgsOrgMembersUsername_39116253, base: "/",
    url: url_DeleteOrgsOrgMembersUsername_39116254, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgPublicMembers_39116262 = ref object of OpenApiRestCall_39115352
proc url_GetOrgsOrgPublicMembers_39116264(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/public_members")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgPublicMembers_39116263(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Public members list.
  ## Members of an organization can choose to have their membership publicized
  ## or not.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_39116265 = path.getOrDefault("org")
  valid_39116265 = validateParameter(valid_39116265, JString, required = true,
                                   default = nil)
  if valid_39116265 != nil:
    section.add "org", valid_39116265
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116266 = header.getOrDefault("Accept")
  valid_39116266 = validateParameter(valid_39116266, JString, required = false,
                                   default = nil)
  if valid_39116266 != nil:
    section.add "Accept", valid_39116266
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116267: Call_GetOrgsOrgPublicMembers_39116262;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Public members list.
  ## Members of an organization can choose to have their membership publicized
  ## or not.
  ## 
  ## 
  let valid = call_39116267.validator(path, query, header, formData, body, _)
  let scheme = call_39116267.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116267.url(scheme.get, call_39116267.host, call_39116267.base,
                           call_39116267.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116267, url, valid, _)

proc call*(call_39116268: Call_GetOrgsOrgPublicMembers_39116262; org: string;
          Accept: string = ""): Recallable =
  ## getOrgsOrgPublicMembers
  ## Public members list.
  ## Members of an organization can choose to have their membership publicized
  ## or not.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_39116269 = newJObject()
  var header_39116270 = newJObject()
  add(header_39116270, "Accept", newJString(Accept))
  add(path_39116269, "org", newJString(org))
  result = call_39116268.call(path_39116269, nil, header_39116270, nil, nil)

var getOrgsOrgPublicMembers* = Call_GetOrgsOrgPublicMembers_39116262(
    name: "getOrgsOrgPublicMembers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/orgs/{org}/public_members",
    validator: validate_GetOrgsOrgPublicMembers_39116263, base: "/",
    url: url_GetOrgsOrgPublicMembers_39116264, schemes: {Scheme.Https})
type
  Call_PutOrgsOrgPublicMembersUsername_39116281 = ref object of OpenApiRestCall_39115352
proc url_PutOrgsOrgPublicMembersUsername_39116283(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/public_members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutOrgsOrgPublicMembersUsername_39116282(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Publicize a user's membership.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of the user.
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39116284 = path.getOrDefault("username")
  valid_39116284 = validateParameter(valid_39116284, JString, required = true,
                                   default = nil)
  if valid_39116284 != nil:
    section.add "username", valid_39116284
  var valid_39116285 = path.getOrDefault("org")
  valid_39116285 = validateParameter(valid_39116285, JString, required = true,
                                   default = nil)
  if valid_39116285 != nil:
    section.add "org", valid_39116285
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116286 = header.getOrDefault("Accept")
  valid_39116286 = validateParameter(valid_39116286, JString, required = false,
                                   default = nil)
  if valid_39116286 != nil:
    section.add "Accept", valid_39116286
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116287: Call_PutOrgsOrgPublicMembersUsername_39116281;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Publicize a user's membership.
  ## 
  let valid = call_39116287.validator(path, query, header, formData, body, _)
  let scheme = call_39116287.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116287.url(scheme.get, call_39116287.host, call_39116287.base,
                           call_39116287.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116287, url, valid, _)

proc call*(call_39116288: Call_PutOrgsOrgPublicMembersUsername_39116281;
          username: string; org: string; Accept: string = ""): Recallable =
  ## putOrgsOrgPublicMembersUsername
  ## Publicize a user's membership.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_39116289 = newJObject()
  var header_39116290 = newJObject()
  add(path_39116289, "username", newJString(username))
  add(header_39116290, "Accept", newJString(Accept))
  add(path_39116289, "org", newJString(org))
  result = call_39116288.call(path_39116289, nil, header_39116290, nil, nil)

var putOrgsOrgPublicMembersUsername* = Call_PutOrgsOrgPublicMembersUsername_39116281(
    name: "putOrgsOrgPublicMembersUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/orgs/{org}/public_members/{username}",
    validator: validate_PutOrgsOrgPublicMembersUsername_39116282, base: "/",
    url: url_PutOrgsOrgPublicMembersUsername_39116283, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgPublicMembersUsername_39116271 = ref object of OpenApiRestCall_39115352
proc url_GetOrgsOrgPublicMembersUsername_39116273(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/public_members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgPublicMembersUsername_39116272(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Check public membership.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of the user.
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39116274 = path.getOrDefault("username")
  valid_39116274 = validateParameter(valid_39116274, JString, required = true,
                                   default = nil)
  if valid_39116274 != nil:
    section.add "username", valid_39116274
  var valid_39116275 = path.getOrDefault("org")
  valid_39116275 = validateParameter(valid_39116275, JString, required = true,
                                   default = nil)
  if valid_39116275 != nil:
    section.add "org", valid_39116275
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116276 = header.getOrDefault("Accept")
  valid_39116276 = validateParameter(valid_39116276, JString, required = false,
                                   default = nil)
  if valid_39116276 != nil:
    section.add "Accept", valid_39116276
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116277: Call_GetOrgsOrgPublicMembersUsername_39116271;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check public membership.
  ## 
  let valid = call_39116277.validator(path, query, header, formData, body, _)
  let scheme = call_39116277.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116277.url(scheme.get, call_39116277.host, call_39116277.base,
                           call_39116277.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116277, url, valid, _)

proc call*(call_39116278: Call_GetOrgsOrgPublicMembersUsername_39116271;
          username: string; org: string; Accept: string = ""): Recallable =
  ## getOrgsOrgPublicMembersUsername
  ## Check public membership.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_39116279 = newJObject()
  var header_39116280 = newJObject()
  add(path_39116279, "username", newJString(username))
  add(header_39116280, "Accept", newJString(Accept))
  add(path_39116279, "org", newJString(org))
  result = call_39116278.call(path_39116279, nil, header_39116280, nil, nil)

var getOrgsOrgPublicMembersUsername* = Call_GetOrgsOrgPublicMembersUsername_39116271(
    name: "getOrgsOrgPublicMembersUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/orgs/{org}/public_members/{username}",
    validator: validate_GetOrgsOrgPublicMembersUsername_39116272, base: "/",
    url: url_GetOrgsOrgPublicMembersUsername_39116273, schemes: {Scheme.Https})
type
  Call_DeleteOrgsOrgPublicMembersUsername_39116291 = ref object of OpenApiRestCall_39115352
proc url_DeleteOrgsOrgPublicMembersUsername_39116293(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/public_members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteOrgsOrgPublicMembersUsername_39116292(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Conceal a user's membership.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of the user.
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39116294 = path.getOrDefault("username")
  valid_39116294 = validateParameter(valid_39116294, JString, required = true,
                                   default = nil)
  if valid_39116294 != nil:
    section.add "username", valid_39116294
  var valid_39116295 = path.getOrDefault("org")
  valid_39116295 = validateParameter(valid_39116295, JString, required = true,
                                   default = nil)
  if valid_39116295 != nil:
    section.add "org", valid_39116295
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116296 = header.getOrDefault("Accept")
  valid_39116296 = validateParameter(valid_39116296, JString, required = false,
                                   default = nil)
  if valid_39116296 != nil:
    section.add "Accept", valid_39116296
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116297: Call_DeleteOrgsOrgPublicMembersUsername_39116291;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Conceal a user's membership.
  ## 
  let valid = call_39116297.validator(path, query, header, formData, body, _)
  let scheme = call_39116297.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116297.url(scheme.get, call_39116297.host, call_39116297.base,
                           call_39116297.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116297, url, valid, _)

proc call*(call_39116298: Call_DeleteOrgsOrgPublicMembersUsername_39116291;
          username: string; org: string; Accept: string = ""): Recallable =
  ## deleteOrgsOrgPublicMembersUsername
  ## Conceal a user's membership.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_39116299 = newJObject()
  var header_39116300 = newJObject()
  add(path_39116299, "username", newJString(username))
  add(header_39116300, "Accept", newJString(Accept))
  add(path_39116299, "org", newJString(org))
  result = call_39116298.call(path_39116299, nil, header_39116300, nil, nil)

var deleteOrgsOrgPublicMembersUsername* = Call_DeleteOrgsOrgPublicMembersUsername_39116291(
    name: "deleteOrgsOrgPublicMembersUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/orgs/{org}/public_members/{username}",
    validator: validate_DeleteOrgsOrgPublicMembersUsername_39116292, base: "/",
    url: url_DeleteOrgsOrgPublicMembersUsername_39116293, schemes: {Scheme.Https})
type
  Call_PostOrgsOrgRepos_39116312 = ref object of OpenApiRestCall_39115352
proc url_PostOrgsOrgRepos_39116314(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostOrgsOrgRepos_39116313(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_39116315 = path.getOrDefault("org")
  valid_39116315 = validateParameter(valid_39116315, JString, required = true,
                                   default = nil)
  if valid_39116315 != nil:
    section.add "org", valid_39116315
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116316 = header.getOrDefault("Accept")
  valid_39116316 = validateParameter(valid_39116316, JString, required = false,
                                   default = nil)
  if valid_39116316 != nil:
    section.add "Accept", valid_39116316
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39116318: Call_PostOrgsOrgRepos_39116312; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  let valid = call_39116318.validator(path, query, header, formData, body, _)
  let scheme = call_39116318.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116318.url(scheme.get, call_39116318.host, call_39116318.base,
                           call_39116318.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116318, url, valid, _)

proc call*(call_39116319: Call_PostOrgsOrgRepos_39116312; body: JsonNode;
          org: string; Accept: string = ""): Recallable =
  ## postOrgsOrgRepos
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   org: string (required)
  ##      : Name of organisation.
  var path_39116320 = newJObject()
  var header_39116321 = newJObject()
  var body_39116322 = newJObject()
  add(header_39116321, "Accept", newJString(Accept))
  if body != nil:
    body_39116322 = body
  add(path_39116320, "org", newJString(org))
  result = call_39116319.call(path_39116320, nil, header_39116321, nil, body_39116322)

var postOrgsOrgRepos* = Call_PostOrgsOrgRepos_39116312(name: "postOrgsOrgRepos",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/orgs/{org}/repos",
    validator: validate_PostOrgsOrgRepos_39116313, base: "/",
    url: url_PostOrgsOrgRepos_39116314, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgRepos_39116301 = ref object of OpenApiRestCall_39115352
proc url_GetOrgsOrgRepos_39116303(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgRepos_39116302(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List repositories for the specified org.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_39116304 = path.getOrDefault("org")
  valid_39116304 = validateParameter(valid_39116304, JString, required = true,
                                   default = nil)
  if valid_39116304 != nil:
    section.add "org", valid_39116304
  result.add "path", section
  ## parameters in `query` object:
  ##   type: JString
  section = newJObject()
  var valid_39116305 = query.getOrDefault("type")
  valid_39116305 = validateParameter(valid_39116305, JString, required = false,
                                   default = newJString("all"))
  if valid_39116305 != nil:
    section.add "type", valid_39116305
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116306 = header.getOrDefault("Accept")
  valid_39116306 = validateParameter(valid_39116306, JString, required = false,
                                   default = nil)
  if valid_39116306 != nil:
    section.add "Accept", valid_39116306
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116307: Call_GetOrgsOrgRepos_39116301; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List repositories for the specified org.
  ## 
  let valid = call_39116307.validator(path, query, header, formData, body, _)
  let scheme = call_39116307.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116307.url(scheme.get, call_39116307.host, call_39116307.base,
                           call_39116307.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116307, url, valid, _)

proc call*(call_39116308: Call_GetOrgsOrgRepos_39116301; org: string;
          Accept: string = ""; `type`: string = "all"): Recallable =
  ## getOrgsOrgRepos
  ## List repositories for the specified org.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   type: string
  ##   org: string (required)
  ##      : Name of organisation.
  var path_39116309 = newJObject()
  var query_39116310 = newJObject()
  var header_39116311 = newJObject()
  add(header_39116311, "Accept", newJString(Accept))
  add(query_39116310, "type", newJString(`type`))
  add(path_39116309, "org", newJString(org))
  result = call_39116308.call(path_39116309, query_39116310, header_39116311, nil, nil)

var getOrgsOrgRepos* = Call_GetOrgsOrgRepos_39116301(name: "getOrgsOrgRepos",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/repos",
    validator: validate_GetOrgsOrgRepos_39116302, base: "/",
    url: url_GetOrgsOrgRepos_39116303, schemes: {Scheme.Https})
type
  Call_PostOrgsOrgTeams_39116332 = ref object of OpenApiRestCall_39115352
proc url_PostOrgsOrgTeams_39116334(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/teams")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostOrgsOrgTeams_39116333(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create team.
  ## In order to create a team, the authenticated user must be an owner of organization.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_39116335 = path.getOrDefault("org")
  valid_39116335 = validateParameter(valid_39116335, JString, required = true,
                                   default = nil)
  if valid_39116335 != nil:
    section.add "org", valid_39116335
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116336 = header.getOrDefault("Accept")
  valid_39116336 = validateParameter(valid_39116336, JString, required = false,
                                   default = nil)
  if valid_39116336 != nil:
    section.add "Accept", valid_39116336
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39116338: Call_PostOrgsOrgTeams_39116332; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Create team.
  ## In order to create a team, the authenticated user must be an owner of organization.
  ## 
  ## 
  let valid = call_39116338.validator(path, query, header, formData, body, _)
  let scheme = call_39116338.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116338.url(scheme.get, call_39116338.host, call_39116338.base,
                           call_39116338.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116338, url, valid, _)

proc call*(call_39116339: Call_PostOrgsOrgTeams_39116332; body: JsonNode;
          org: string; Accept: string = ""): Recallable =
  ## postOrgsOrgTeams
  ## Create team.
  ## In order to create a team, the authenticated user must be an owner of organization.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   org: string (required)
  ##      : Name of organisation.
  var path_39116340 = newJObject()
  var header_39116341 = newJObject()
  var body_39116342 = newJObject()
  add(header_39116341, "Accept", newJString(Accept))
  if body != nil:
    body_39116342 = body
  add(path_39116340, "org", newJString(org))
  result = call_39116339.call(path_39116340, nil, header_39116341, nil, body_39116342)

var postOrgsOrgTeams* = Call_PostOrgsOrgTeams_39116332(name: "postOrgsOrgTeams",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/orgs/{org}/teams",
    validator: validate_PostOrgsOrgTeams_39116333, base: "/",
    url: url_PostOrgsOrgTeams_39116334, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgTeams_39116323 = ref object of OpenApiRestCall_39115352
proc url_GetOrgsOrgTeams_39116325(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
               (kind: VariableSegment, value: "org"),
               (kind: ConstantSegment, value: "/teams")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgTeams_39116324(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List teams.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_39116326 = path.getOrDefault("org")
  valid_39116326 = validateParameter(valid_39116326, JString, required = true,
                                   default = nil)
  if valid_39116326 != nil:
    section.add "org", valid_39116326
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116327 = header.getOrDefault("Accept")
  valid_39116327 = validateParameter(valid_39116327, JString, required = false,
                                   default = nil)
  if valid_39116327 != nil:
    section.add "Accept", valid_39116327
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116328: Call_GetOrgsOrgTeams_39116323; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List teams.
  ## 
  let valid = call_39116328.validator(path, query, header, formData, body, _)
  let scheme = call_39116328.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116328.url(scheme.get, call_39116328.host, call_39116328.base,
                           call_39116328.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116328, url, valid, _)

proc call*(call_39116329: Call_GetOrgsOrgTeams_39116323; org: string;
          Accept: string = ""): Recallable =
  ## getOrgsOrgTeams
  ## List teams.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_39116330 = newJObject()
  var header_39116331 = newJObject()
  add(header_39116331, "Accept", newJString(Accept))
  add(path_39116330, "org", newJString(org))
  result = call_39116329.call(path_39116330, nil, header_39116331, nil, nil)

var getOrgsOrgTeams* = Call_GetOrgsOrgTeams_39116323(name: "getOrgsOrgTeams",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}/teams",
    validator: validate_GetOrgsOrgTeams_39116324, base: "/",
    url: url_GetOrgsOrgTeams_39116325, schemes: {Scheme.Https})
type
  Call_GetRateLimit_39116343 = ref object of OpenApiRestCall_39115352
proc url_GetRateLimit_39116345(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRateLimit_39116344(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## Get your current rate limit status
  ## Note: Accessing this endpoint does not count against your rate limit.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116346 = header.getOrDefault("Accept")
  valid_39116346 = validateParameter(valid_39116346, JString, required = false,
                                   default = nil)
  if valid_39116346 != nil:
    section.add "Accept", valid_39116346
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116347: Call_GetRateLimit_39116343; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get your current rate limit status
  ## Note: Accessing this endpoint does not count against your rate limit.
  ## 
  ## 
  let valid = call_39116347.validator(path, query, header, formData, body, _)
  let scheme = call_39116347.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116347.url(scheme.get, call_39116347.host, call_39116347.base,
                           call_39116347.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116347, url, valid, _)

proc call*(call_39116348: Call_GetRateLimit_39116343; Accept: string = ""): Recallable =
  ## getRateLimit
  ## Get your current rate limit status
  ## Note: Accessing this endpoint does not count against your rate limit.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_39116349 = newJObject()
  add(header_39116349, "Accept", newJString(Accept))
  result = call_39116348.call(nil, nil, header_39116349, nil, nil)

var getRateLimit* = Call_GetRateLimit_39116343(name: "getRateLimit",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/rate_limit",
    validator: validate_GetRateLimit_39116344, base: "/", url: url_GetRateLimit_39116345,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepo_39116350 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepo_39116352(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepo_39116351(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116353 = path.getOrDefault("owner")
  valid_39116353 = validateParameter(valid_39116353, JString, required = true,
                                   default = nil)
  if valid_39116353 != nil:
    section.add "owner", valid_39116353
  var valid_39116354 = path.getOrDefault("repo")
  valid_39116354 = validateParameter(valid_39116354, JString, required = true,
                                   default = nil)
  if valid_39116354 != nil:
    section.add "repo", valid_39116354
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116355 = header.getOrDefault("Accept")
  valid_39116355 = validateParameter(valid_39116355, JString, required = false,
                                   default = nil)
  if valid_39116355 != nil:
    section.add "Accept", valid_39116355
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116356: Call_GetReposOwnerRepo_39116350; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get repository.
  ## 
  let valid = call_39116356.validator(path, query, header, formData, body, _)
  let scheme = call_39116356.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116356.url(scheme.get, call_39116356.host, call_39116356.base,
                           call_39116356.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116356, url, valid, _)

proc call*(call_39116357: Call_GetReposOwnerRepo_39116350; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepo
  ## Get repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116358 = newJObject()
  var header_39116359 = newJObject()
  add(path_39116358, "owner", newJString(owner))
  add(header_39116359, "Accept", newJString(Accept))
  add(path_39116358, "repo", newJString(repo))
  result = call_39116357.call(path_39116358, nil, header_39116359, nil, nil)

var getReposOwnerRepo* = Call_GetReposOwnerRepo_39116350(name: "getReposOwnerRepo",
    meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/repos/{owner}/{repo}", validator: validate_GetReposOwnerRepo_39116351,
    base: "/", url: url_GetReposOwnerRepo_39116352, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepo_39116370 = ref object of OpenApiRestCall_39115352
proc url_PatchReposOwnerRepo_39116372(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepo_39116371(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Edit repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116373 = path.getOrDefault("owner")
  valid_39116373 = validateParameter(valid_39116373, JString, required = true,
                                   default = nil)
  if valid_39116373 != nil:
    section.add "owner", valid_39116373
  var valid_39116374 = path.getOrDefault("repo")
  valid_39116374 = validateParameter(valid_39116374, JString, required = true,
                                   default = nil)
  if valid_39116374 != nil:
    section.add "repo", valid_39116374
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116375 = header.getOrDefault("Accept")
  valid_39116375 = validateParameter(valid_39116375, JString, required = false,
                                   default = nil)
  if valid_39116375 != nil:
    section.add "Accept", valid_39116375
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39116377: Call_PatchReposOwnerRepo_39116370; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit repository.
  ## 
  let valid = call_39116377.validator(path, query, header, formData, body, _)
  let scheme = call_39116377.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116377.url(scheme.get, call_39116377.host, call_39116377.base,
                           call_39116377.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116377, url, valid, _)

proc call*(call_39116378: Call_PatchReposOwnerRepo_39116370; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepo
  ## Edit repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116379 = newJObject()
  var header_39116380 = newJObject()
  var body_39116381 = newJObject()
  add(path_39116379, "owner", newJString(owner))
  add(header_39116380, "Accept", newJString(Accept))
  if body != nil:
    body_39116381 = body
  add(path_39116379, "repo", newJString(repo))
  result = call_39116378.call(path_39116379, nil, header_39116380, nil, body_39116381)

var patchReposOwnerRepo* = Call_PatchReposOwnerRepo_39116370(
    name: "patchReposOwnerRepo", meth: HttpMethod.HttpPatch, host: "api.github.com",
    route: "/repos/{owner}/{repo}", validator: validate_PatchReposOwnerRepo_39116371,
    base: "/", url: url_PatchReposOwnerRepo_39116372, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepo_39116360 = ref object of OpenApiRestCall_39115352
proc url_DeleteReposOwnerRepo_39116362(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepo_39116361(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Delete a Repository.
  ## Deleting a repository requires admin access. If OAuth is used, the delete_repo
  ## scope is required.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116363 = path.getOrDefault("owner")
  valid_39116363 = validateParameter(valid_39116363, JString, required = true,
                                   default = nil)
  if valid_39116363 != nil:
    section.add "owner", valid_39116363
  var valid_39116364 = path.getOrDefault("repo")
  valid_39116364 = validateParameter(valid_39116364, JString, required = true,
                                   default = nil)
  if valid_39116364 != nil:
    section.add "repo", valid_39116364
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116365 = header.getOrDefault("Accept")
  valid_39116365 = validateParameter(valid_39116365, JString, required = false,
                                   default = nil)
  if valid_39116365 != nil:
    section.add "Accept", valid_39116365
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116366: Call_DeleteReposOwnerRepo_39116360; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a Repository.
  ## Deleting a repository requires admin access. If OAuth is used, the delete_repo
  ## scope is required.
  ## 
  ## 
  let valid = call_39116366.validator(path, query, header, formData, body, _)
  let scheme = call_39116366.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116366.url(scheme.get, call_39116366.host, call_39116366.base,
                           call_39116366.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116366, url, valid, _)

proc call*(call_39116367: Call_DeleteReposOwnerRepo_39116360; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepo
  ## Delete a Repository.
  ## Deleting a repository requires admin access. If OAuth is used, the delete_repo
  ## scope is required.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116368 = newJObject()
  var header_39116369 = newJObject()
  add(path_39116368, "owner", newJString(owner))
  add(header_39116369, "Accept", newJString(Accept))
  add(path_39116368, "repo", newJString(repo))
  result = call_39116367.call(path_39116368, nil, header_39116369, nil, nil)

var deleteReposOwnerRepo* = Call_DeleteReposOwnerRepo_39116360(
    name: "deleteReposOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}",
    validator: validate_DeleteReposOwnerRepo_39116361, base: "/",
    url: url_DeleteReposOwnerRepo_39116362, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoAssignees_39116382 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoAssignees_39116384(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/assignees")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoAssignees_39116383(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List assignees.
  ## This call lists all the available assignees (owner + collaborators) to which
  ## issues may be assigned.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116385 = path.getOrDefault("owner")
  valid_39116385 = validateParameter(valid_39116385, JString, required = true,
                                   default = nil)
  if valid_39116385 != nil:
    section.add "owner", valid_39116385
  var valid_39116386 = path.getOrDefault("repo")
  valid_39116386 = validateParameter(valid_39116386, JString, required = true,
                                   default = nil)
  if valid_39116386 != nil:
    section.add "repo", valid_39116386
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116387 = header.getOrDefault("Accept")
  valid_39116387 = validateParameter(valid_39116387, JString, required = false,
                                   default = nil)
  if valid_39116387 != nil:
    section.add "Accept", valid_39116387
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116388: Call_GetReposOwnerRepoAssignees_39116382;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List assignees.
  ## This call lists all the available assignees (owner + collaborators) to which
  ## issues may be assigned.
  ## 
  ## 
  let valid = call_39116388.validator(path, query, header, formData, body, _)
  let scheme = call_39116388.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116388.url(scheme.get, call_39116388.host, call_39116388.base,
                           call_39116388.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116388, url, valid, _)

proc call*(call_39116389: Call_GetReposOwnerRepoAssignees_39116382; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoAssignees
  ## List assignees.
  ## This call lists all the available assignees (owner + collaborators) to which
  ## issues may be assigned.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116390 = newJObject()
  var header_39116391 = newJObject()
  add(path_39116390, "owner", newJString(owner))
  add(header_39116391, "Accept", newJString(Accept))
  add(path_39116390, "repo", newJString(repo))
  result = call_39116389.call(path_39116390, nil, header_39116391, nil, nil)

var getReposOwnerRepoAssignees* = Call_GetReposOwnerRepoAssignees_39116382(
    name: "getReposOwnerRepoAssignees", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/assignees",
    validator: validate_GetReposOwnerRepoAssignees_39116383, base: "/",
    url: url_GetReposOwnerRepoAssignees_39116384, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoAssigneesAssignee_39116392 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoAssigneesAssignee_39116394(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "assignee" in path, "`assignee` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/assignees/"),
               (kind: VariableSegment, value: "assignee")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoAssigneesAssignee_39116393(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Check assignee.
  ## You may also check to see if a particular user is an assignee for a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   assignee: JString (required)
  ##           : Login of the assignee.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116395 = path.getOrDefault("owner")
  valid_39116395 = validateParameter(valid_39116395, JString, required = true,
                                   default = nil)
  if valid_39116395 != nil:
    section.add "owner", valid_39116395
  var valid_39116396 = path.getOrDefault("assignee")
  valid_39116396 = validateParameter(valid_39116396, JString, required = true,
                                   default = nil)
  if valid_39116396 != nil:
    section.add "assignee", valid_39116396
  var valid_39116397 = path.getOrDefault("repo")
  valid_39116397 = validateParameter(valid_39116397, JString, required = true,
                                   default = nil)
  if valid_39116397 != nil:
    section.add "repo", valid_39116397
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116398 = header.getOrDefault("Accept")
  valid_39116398 = validateParameter(valid_39116398, JString, required = false,
                                   default = nil)
  if valid_39116398 != nil:
    section.add "Accept", valid_39116398
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116399: Call_GetReposOwnerRepoAssigneesAssignee_39116392;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check assignee.
  ## You may also check to see if a particular user is an assignee for a repository.
  ## 
  ## 
  let valid = call_39116399.validator(path, query, header, formData, body, _)
  let scheme = call_39116399.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116399.url(scheme.get, call_39116399.host, call_39116399.base,
                           call_39116399.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116399, url, valid, _)

proc call*(call_39116400: Call_GetReposOwnerRepoAssigneesAssignee_39116392;
          owner: string; assignee: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoAssigneesAssignee
  ## Check assignee.
  ## You may also check to see if a particular user is an assignee for a repository.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   assignee: string (required)
  ##           : Login of the assignee.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116401 = newJObject()
  var header_39116402 = newJObject()
  add(path_39116401, "owner", newJString(owner))
  add(path_39116401, "assignee", newJString(assignee))
  add(header_39116402, "Accept", newJString(Accept))
  add(path_39116401, "repo", newJString(repo))
  result = call_39116400.call(path_39116401, nil, header_39116402, nil, nil)

var getReposOwnerRepoAssigneesAssignee* = Call_GetReposOwnerRepoAssigneesAssignee_39116392(
    name: "getReposOwnerRepoAssigneesAssignee", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/assignees/{assignee}",
    validator: validate_GetReposOwnerRepoAssigneesAssignee_39116393, base: "/",
    url: url_GetReposOwnerRepoAssigneesAssignee_39116394, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoBranches_39116403 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoBranches_39116405(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/branches")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoBranches_39116404(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get list of branches
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116406 = path.getOrDefault("owner")
  valid_39116406 = validateParameter(valid_39116406, JString, required = true,
                                   default = nil)
  if valid_39116406 != nil:
    section.add "owner", valid_39116406
  var valid_39116407 = path.getOrDefault("repo")
  valid_39116407 = validateParameter(valid_39116407, JString, required = true,
                                   default = nil)
  if valid_39116407 != nil:
    section.add "repo", valid_39116407
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116408 = header.getOrDefault("Accept")
  valid_39116408 = validateParameter(valid_39116408, JString, required = false,
                                   default = nil)
  if valid_39116408 != nil:
    section.add "Accept", valid_39116408
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116409: Call_GetReposOwnerRepoBranches_39116403;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get list of branches
  ## 
  let valid = call_39116409.validator(path, query, header, formData, body, _)
  let scheme = call_39116409.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116409.url(scheme.get, call_39116409.host, call_39116409.base,
                           call_39116409.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116409, url, valid, _)

proc call*(call_39116410: Call_GetReposOwnerRepoBranches_39116403; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoBranches
  ## Get list of branches
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116411 = newJObject()
  var header_39116412 = newJObject()
  add(path_39116411, "owner", newJString(owner))
  add(header_39116412, "Accept", newJString(Accept))
  add(path_39116411, "repo", newJString(repo))
  result = call_39116410.call(path_39116411, nil, header_39116412, nil, nil)

var getReposOwnerRepoBranches* = Call_GetReposOwnerRepoBranches_39116403(
    name: "getReposOwnerRepoBranches", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/branches",
    validator: validate_GetReposOwnerRepoBranches_39116404, base: "/",
    url: url_GetReposOwnerRepoBranches_39116405, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoBranchesBranch_39116413 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoBranchesBranch_39116415(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "branch" in path, "`branch` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/branches/"),
               (kind: VariableSegment, value: "branch")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoBranchesBranch_39116414(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get Branch
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   branch: JString (required)
  ##         : Name of the branch.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116416 = path.getOrDefault("owner")
  valid_39116416 = validateParameter(valid_39116416, JString, required = true,
                                   default = nil)
  if valid_39116416 != nil:
    section.add "owner", valid_39116416
  var valid_39116417 = path.getOrDefault("branch")
  valid_39116417 = validateParameter(valid_39116417, JString, required = true,
                                   default = nil)
  if valid_39116417 != nil:
    section.add "branch", valid_39116417
  var valid_39116418 = path.getOrDefault("repo")
  valid_39116418 = validateParameter(valid_39116418, JString, required = true,
                                   default = nil)
  if valid_39116418 != nil:
    section.add "repo", valid_39116418
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116419 = header.getOrDefault("Accept")
  valid_39116419 = validateParameter(valid_39116419, JString, required = false,
                                   default = nil)
  if valid_39116419 != nil:
    section.add "Accept", valid_39116419
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116420: Call_GetReposOwnerRepoBranchesBranch_39116413;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get Branch
  ## 
  let valid = call_39116420.validator(path, query, header, formData, body, _)
  let scheme = call_39116420.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116420.url(scheme.get, call_39116420.host, call_39116420.base,
                           call_39116420.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116420, url, valid, _)

proc call*(call_39116421: Call_GetReposOwnerRepoBranchesBranch_39116413;
          owner: string; branch: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoBranchesBranch
  ## Get Branch
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   branch: string (required)
  ##         : Name of the branch.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116422 = newJObject()
  var header_39116423 = newJObject()
  add(path_39116422, "owner", newJString(owner))
  add(path_39116422, "branch", newJString(branch))
  add(header_39116423, "Accept", newJString(Accept))
  add(path_39116422, "repo", newJString(repo))
  result = call_39116421.call(path_39116422, nil, header_39116423, nil, nil)

var getReposOwnerRepoBranchesBranch* = Call_GetReposOwnerRepoBranchesBranch_39116413(
    name: "getReposOwnerRepoBranchesBranch", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/branches/{branch}",
    validator: validate_GetReposOwnerRepoBranchesBranch_39116414, base: "/",
    url: url_GetReposOwnerRepoBranchesBranch_39116415, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCollaborators_39116424 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoCollaborators_39116426(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/collaborators")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCollaborators_39116425(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List.
  ## When authenticating as an organization owner of an organization-owned
  ## repository, all organization owners are included in the list of
  ## collaborators. Otherwise, only users with access to the repository are
  ## returned in the collaborators list.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116427 = path.getOrDefault("owner")
  valid_39116427 = validateParameter(valid_39116427, JString, required = true,
                                   default = nil)
  if valid_39116427 != nil:
    section.add "owner", valid_39116427
  var valid_39116428 = path.getOrDefault("repo")
  valid_39116428 = validateParameter(valid_39116428, JString, required = true,
                                   default = nil)
  if valid_39116428 != nil:
    section.add "repo", valid_39116428
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116429 = header.getOrDefault("Accept")
  valid_39116429 = validateParameter(valid_39116429, JString, required = false,
                                   default = nil)
  if valid_39116429 != nil:
    section.add "Accept", valid_39116429
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116430: Call_GetReposOwnerRepoCollaborators_39116424;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List.
  ## When authenticating as an organization owner of an organization-owned
  ## repository, all organization owners are included in the list of
  ## collaborators. Otherwise, only users with access to the repository are
  ## returned in the collaborators list.
  ## 
  ## 
  let valid = call_39116430.validator(path, query, header, formData, body, _)
  let scheme = call_39116430.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116430.url(scheme.get, call_39116430.host, call_39116430.base,
                           call_39116430.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116430, url, valid, _)

proc call*(call_39116431: Call_GetReposOwnerRepoCollaborators_39116424;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCollaborators
  ## List.
  ## When authenticating as an organization owner of an organization-owned
  ## repository, all organization owners are included in the list of
  ## collaborators. Otherwise, only users with access to the repository are
  ## returned in the collaborators list.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116432 = newJObject()
  var header_39116433 = newJObject()
  add(path_39116432, "owner", newJString(owner))
  add(header_39116433, "Accept", newJString(Accept))
  add(path_39116432, "repo", newJString(repo))
  result = call_39116431.call(path_39116432, nil, header_39116433, nil, nil)

var getReposOwnerRepoCollaborators* = Call_GetReposOwnerRepoCollaborators_39116424(
    name: "getReposOwnerRepoCollaborators", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators",
    validator: validate_GetReposOwnerRepoCollaborators_39116425, base: "/",
    url: url_GetReposOwnerRepoCollaborators_39116426, schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoCollaboratorsUser_39116445 = ref object of OpenApiRestCall_39115352
proc url_PutReposOwnerRepoCollaboratorsUser_39116447(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "user" in path, "`user` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/collaborators/"),
               (kind: VariableSegment, value: "user")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoCollaboratorsUser_39116446(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Add collaborator.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   user: JString (required)
  ##       : Login of the user.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116448 = path.getOrDefault("owner")
  valid_39116448 = validateParameter(valid_39116448, JString, required = true,
                                   default = nil)
  if valid_39116448 != nil:
    section.add "owner", valid_39116448
  var valid_39116449 = path.getOrDefault("user")
  valid_39116449 = validateParameter(valid_39116449, JString, required = true,
                                   default = nil)
  if valid_39116449 != nil:
    section.add "user", valid_39116449
  var valid_39116450 = path.getOrDefault("repo")
  valid_39116450 = validateParameter(valid_39116450, JString, required = true,
                                   default = nil)
  if valid_39116450 != nil:
    section.add "repo", valid_39116450
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116451 = header.getOrDefault("Accept")
  valid_39116451 = validateParameter(valid_39116451, JString, required = false,
                                   default = nil)
  if valid_39116451 != nil:
    section.add "Accept", valid_39116451
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116452: Call_PutReposOwnerRepoCollaboratorsUser_39116445;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Add collaborator.
  ## 
  let valid = call_39116452.validator(path, query, header, formData, body, _)
  let scheme = call_39116452.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116452.url(scheme.get, call_39116452.host, call_39116452.base,
                           call_39116452.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116452, url, valid, _)

proc call*(call_39116453: Call_PutReposOwnerRepoCollaboratorsUser_39116445;
          owner: string; user: string; repo: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoCollaboratorsUser
  ## Add collaborator.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   user: string (required)
  ##       : Login of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116454 = newJObject()
  var header_39116455 = newJObject()
  add(path_39116454, "owner", newJString(owner))
  add(path_39116454, "user", newJString(user))
  add(header_39116455, "Accept", newJString(Accept))
  add(path_39116454, "repo", newJString(repo))
  result = call_39116453.call(path_39116454, nil, header_39116455, nil, nil)

var putReposOwnerRepoCollaboratorsUser* = Call_PutReposOwnerRepoCollaboratorsUser_39116445(
    name: "putReposOwnerRepoCollaboratorsUser", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators/{user}",
    validator: validate_PutReposOwnerRepoCollaboratorsUser_39116446, base: "/",
    url: url_PutReposOwnerRepoCollaboratorsUser_39116447, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCollaboratorsUser_39116434 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoCollaboratorsUser_39116436(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "user" in path, "`user` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/collaborators/"),
               (kind: VariableSegment, value: "user")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCollaboratorsUser_39116435(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Check if user is a collaborator
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   user: JString (required)
  ##       : Login of the user.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116437 = path.getOrDefault("owner")
  valid_39116437 = validateParameter(valid_39116437, JString, required = true,
                                   default = nil)
  if valid_39116437 != nil:
    section.add "owner", valid_39116437
  var valid_39116438 = path.getOrDefault("user")
  valid_39116438 = validateParameter(valid_39116438, JString, required = true,
                                   default = nil)
  if valid_39116438 != nil:
    section.add "user", valid_39116438
  var valid_39116439 = path.getOrDefault("repo")
  valid_39116439 = validateParameter(valid_39116439, JString, required = true,
                                   default = nil)
  if valid_39116439 != nil:
    section.add "repo", valid_39116439
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116440 = header.getOrDefault("Accept")
  valid_39116440 = validateParameter(valid_39116440, JString, required = false,
                                   default = nil)
  if valid_39116440 != nil:
    section.add "Accept", valid_39116440
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116441: Call_GetReposOwnerRepoCollaboratorsUser_39116434;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if user is a collaborator
  ## 
  let valid = call_39116441.validator(path, query, header, formData, body, _)
  let scheme = call_39116441.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116441.url(scheme.get, call_39116441.host, call_39116441.base,
                           call_39116441.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116441, url, valid, _)

proc call*(call_39116442: Call_GetReposOwnerRepoCollaboratorsUser_39116434;
          owner: string; user: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCollaboratorsUser
  ## Check if user is a collaborator
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   user: string (required)
  ##       : Login of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116443 = newJObject()
  var header_39116444 = newJObject()
  add(path_39116443, "owner", newJString(owner))
  add(path_39116443, "user", newJString(user))
  add(header_39116444, "Accept", newJString(Accept))
  add(path_39116443, "repo", newJString(repo))
  result = call_39116442.call(path_39116443, nil, header_39116444, nil, nil)

var getReposOwnerRepoCollaboratorsUser* = Call_GetReposOwnerRepoCollaboratorsUser_39116434(
    name: "getReposOwnerRepoCollaboratorsUser", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators/{user}",
    validator: validate_GetReposOwnerRepoCollaboratorsUser_39116435, base: "/",
    url: url_GetReposOwnerRepoCollaboratorsUser_39116436, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoCollaboratorsUser_39116456 = ref object of OpenApiRestCall_39115352
proc url_DeleteReposOwnerRepoCollaboratorsUser_39116458(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "user" in path, "`user` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/collaborators/"),
               (kind: VariableSegment, value: "user")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoCollaboratorsUser_39116457(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Remove collaborator.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   user: JString (required)
  ##       : Login of the user.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116459 = path.getOrDefault("owner")
  valid_39116459 = validateParameter(valid_39116459, JString, required = true,
                                   default = nil)
  if valid_39116459 != nil:
    section.add "owner", valid_39116459
  var valid_39116460 = path.getOrDefault("user")
  valid_39116460 = validateParameter(valid_39116460, JString, required = true,
                                   default = nil)
  if valid_39116460 != nil:
    section.add "user", valid_39116460
  var valid_39116461 = path.getOrDefault("repo")
  valid_39116461 = validateParameter(valid_39116461, JString, required = true,
                                   default = nil)
  if valid_39116461 != nil:
    section.add "repo", valid_39116461
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116462 = header.getOrDefault("Accept")
  valid_39116462 = validateParameter(valid_39116462, JString, required = false,
                                   default = nil)
  if valid_39116462 != nil:
    section.add "Accept", valid_39116462
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116463: Call_DeleteReposOwnerRepoCollaboratorsUser_39116456;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Remove collaborator.
  ## 
  let valid = call_39116463.validator(path, query, header, formData, body, _)
  let scheme = call_39116463.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116463.url(scheme.get, call_39116463.host, call_39116463.base,
                           call_39116463.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116463, url, valid, _)

proc call*(call_39116464: Call_DeleteReposOwnerRepoCollaboratorsUser_39116456;
          owner: string; user: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoCollaboratorsUser
  ## Remove collaborator.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   user: string (required)
  ##       : Login of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116465 = newJObject()
  var header_39116466 = newJObject()
  add(path_39116465, "owner", newJString(owner))
  add(path_39116465, "user", newJString(user))
  add(header_39116466, "Accept", newJString(Accept))
  add(path_39116465, "repo", newJString(repo))
  result = call_39116464.call(path_39116465, nil, header_39116466, nil, nil)

var deleteReposOwnerRepoCollaboratorsUser* = Call_DeleteReposOwnerRepoCollaboratorsUser_39116456(
    name: "deleteReposOwnerRepoCollaboratorsUser", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators/{user}",
    validator: validate_DeleteReposOwnerRepoCollaboratorsUser_39116457, base: "/",
    url: url_DeleteReposOwnerRepoCollaboratorsUser_39116458,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoComments_39116467 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoComments_39116469(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoComments_39116468(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List commit comments for a repository.
  ## Comments are ordered by ascending ID.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116470 = path.getOrDefault("owner")
  valid_39116470 = validateParameter(valid_39116470, JString, required = true,
                                   default = nil)
  if valid_39116470 != nil:
    section.add "owner", valid_39116470
  var valid_39116471 = path.getOrDefault("repo")
  valid_39116471 = validateParameter(valid_39116471, JString, required = true,
                                   default = nil)
  if valid_39116471 != nil:
    section.add "repo", valid_39116471
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116472 = header.getOrDefault("Accept")
  valid_39116472 = validateParameter(valid_39116472, JString, required = false,
                                   default = nil)
  if valid_39116472 != nil:
    section.add "Accept", valid_39116472
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116473: Call_GetReposOwnerRepoComments_39116467;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List commit comments for a repository.
  ## Comments are ordered by ascending ID.
  ## 
  ## 
  let valid = call_39116473.validator(path, query, header, formData, body, _)
  let scheme = call_39116473.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116473.url(scheme.get, call_39116473.host, call_39116473.base,
                           call_39116473.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116473, url, valid, _)

proc call*(call_39116474: Call_GetReposOwnerRepoComments_39116467; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoComments
  ## List commit comments for a repository.
  ## Comments are ordered by ascending ID.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116475 = newJObject()
  var header_39116476 = newJObject()
  add(path_39116475, "owner", newJString(owner))
  add(header_39116476, "Accept", newJString(Accept))
  add(path_39116475, "repo", newJString(repo))
  result = call_39116474.call(path_39116475, nil, header_39116476, nil, nil)

var getReposOwnerRepoComments* = Call_GetReposOwnerRepoComments_39116467(
    name: "getReposOwnerRepoComments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments",
    validator: validate_GetReposOwnerRepoComments_39116468, base: "/",
    url: url_GetReposOwnerRepoComments_39116469, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommentsCommentId_39116477 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoCommentsCommentId_39116479(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommentsCommentId_39116478(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a single commit comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116480 = path.getOrDefault("owner")
  valid_39116480 = validateParameter(valid_39116480, JString, required = true,
                                   default = nil)
  if valid_39116480 != nil:
    section.add "owner", valid_39116480
  var valid_39116481 = path.getOrDefault("repo")
  valid_39116481 = validateParameter(valid_39116481, JString, required = true,
                                   default = nil)
  if valid_39116481 != nil:
    section.add "repo", valid_39116481
  var valid_39116482 = path.getOrDefault("commentId")
  valid_39116482 = validateParameter(valid_39116482, JInt, required = true,
                                   default = nil)
  if valid_39116482 != nil:
    section.add "commentId", valid_39116482
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116483 = header.getOrDefault("Accept")
  valid_39116483 = validateParameter(valid_39116483, JString, required = false,
                                   default = nil)
  if valid_39116483 != nil:
    section.add "Accept", valid_39116483
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116484: Call_GetReposOwnerRepoCommentsCommentId_39116477;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single commit comment.
  ## 
  let valid = call_39116484.validator(path, query, header, formData, body, _)
  let scheme = call_39116484.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116484.url(scheme.get, call_39116484.host, call_39116484.base,
                           call_39116484.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116484, url, valid, _)

proc call*(call_39116485: Call_GetReposOwnerRepoCommentsCommentId_39116477;
          owner: string; repo: string; commentId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommentsCommentId
  ## Get a single commit comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_39116486 = newJObject()
  var header_39116487 = newJObject()
  add(path_39116486, "owner", newJString(owner))
  add(header_39116487, "Accept", newJString(Accept))
  add(path_39116486, "repo", newJString(repo))
  add(path_39116486, "commentId", newJInt(commentId))
  result = call_39116485.call(path_39116486, nil, header_39116487, nil, nil)

var getReposOwnerRepoCommentsCommentId* = Call_GetReposOwnerRepoCommentsCommentId_39116477(
    name: "getReposOwnerRepoCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments/{commentId}",
    validator: validate_GetReposOwnerRepoCommentsCommentId_39116478, base: "/",
    url: url_GetReposOwnerRepoCommentsCommentId_39116479, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoCommentsCommentId_39116499 = ref object of OpenApiRestCall_39115352
proc url_PatchReposOwnerRepoCommentsCommentId_39116501(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoCommentsCommentId_39116500(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Update a commit comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116502 = path.getOrDefault("owner")
  valid_39116502 = validateParameter(valid_39116502, JString, required = true,
                                   default = nil)
  if valid_39116502 != nil:
    section.add "owner", valid_39116502
  var valid_39116503 = path.getOrDefault("repo")
  valid_39116503 = validateParameter(valid_39116503, JString, required = true,
                                   default = nil)
  if valid_39116503 != nil:
    section.add "repo", valid_39116503
  var valid_39116504 = path.getOrDefault("commentId")
  valid_39116504 = validateParameter(valid_39116504, JInt, required = true,
                                   default = nil)
  if valid_39116504 != nil:
    section.add "commentId", valid_39116504
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116505 = header.getOrDefault("Accept")
  valid_39116505 = validateParameter(valid_39116505, JString, required = false,
                                   default = nil)
  if valid_39116505 != nil:
    section.add "Accept", valid_39116505
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39116507: Call_PatchReposOwnerRepoCommentsCommentId_39116499;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Update a commit comment.
  ## 
  let valid = call_39116507.validator(path, query, header, formData, body, _)
  let scheme = call_39116507.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116507.url(scheme.get, call_39116507.host, call_39116507.base,
                           call_39116507.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116507, url, valid, _)

proc call*(call_39116508: Call_PatchReposOwnerRepoCommentsCommentId_39116499;
          owner: string; body: JsonNode; repo: string; commentId: int;
          Accept: string = ""): Recallable =
  ## patchReposOwnerRepoCommentsCommentId
  ## Update a commit comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_39116509 = newJObject()
  var header_39116510 = newJObject()
  var body_39116511 = newJObject()
  add(path_39116509, "owner", newJString(owner))
  add(header_39116510, "Accept", newJString(Accept))
  if body != nil:
    body_39116511 = body
  add(path_39116509, "repo", newJString(repo))
  add(path_39116509, "commentId", newJInt(commentId))
  result = call_39116508.call(path_39116509, nil, header_39116510, nil, body_39116511)

var patchReposOwnerRepoCommentsCommentId* = Call_PatchReposOwnerRepoCommentsCommentId_39116499(
    name: "patchReposOwnerRepoCommentsCommentId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments/{commentId}",
    validator: validate_PatchReposOwnerRepoCommentsCommentId_39116500, base: "/",
    url: url_PatchReposOwnerRepoCommentsCommentId_39116501,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoCommentsCommentId_39116488 = ref object of OpenApiRestCall_39115352
proc url_DeleteReposOwnerRepoCommentsCommentId_39116490(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoCommentsCommentId_39116489(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a commit comment
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116491 = path.getOrDefault("owner")
  valid_39116491 = validateParameter(valid_39116491, JString, required = true,
                                   default = nil)
  if valid_39116491 != nil:
    section.add "owner", valid_39116491
  var valid_39116492 = path.getOrDefault("repo")
  valid_39116492 = validateParameter(valid_39116492, JString, required = true,
                                   default = nil)
  if valid_39116492 != nil:
    section.add "repo", valid_39116492
  var valid_39116493 = path.getOrDefault("commentId")
  valid_39116493 = validateParameter(valid_39116493, JInt, required = true,
                                   default = nil)
  if valid_39116493 != nil:
    section.add "commentId", valid_39116493
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116494 = header.getOrDefault("Accept")
  valid_39116494 = validateParameter(valid_39116494, JString, required = false,
                                   default = nil)
  if valid_39116494 != nil:
    section.add "Accept", valid_39116494
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116495: Call_DeleteReposOwnerRepoCommentsCommentId_39116488;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a commit comment
  ## 
  let valid = call_39116495.validator(path, query, header, formData, body, _)
  let scheme = call_39116495.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116495.url(scheme.get, call_39116495.host, call_39116495.base,
                           call_39116495.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116495, url, valid, _)

proc call*(call_39116496: Call_DeleteReposOwnerRepoCommentsCommentId_39116488;
          owner: string; repo: string; commentId: int; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoCommentsCommentId
  ## Delete a commit comment
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_39116497 = newJObject()
  var header_39116498 = newJObject()
  add(path_39116497, "owner", newJString(owner))
  add(header_39116498, "Accept", newJString(Accept))
  add(path_39116497, "repo", newJString(repo))
  add(path_39116497, "commentId", newJInt(commentId))
  result = call_39116496.call(path_39116497, nil, header_39116498, nil, nil)

var deleteReposOwnerRepoCommentsCommentId* = Call_DeleteReposOwnerRepoCommentsCommentId_39116488(
    name: "deleteReposOwnerRepoCommentsCommentId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments/{commentId}",
    validator: validate_DeleteReposOwnerRepoCommentsCommentId_39116489, base: "/",
    url: url_DeleteReposOwnerRepoCommentsCommentId_39116490,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommits_39116512 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoCommits_39116514(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommits_39116513(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List commits on a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116515 = path.getOrDefault("owner")
  valid_39116515 = validateParameter(valid_39116515, JString, required = true,
                                   default = nil)
  if valid_39116515 != nil:
    section.add "owner", valid_39116515
  var valid_39116516 = path.getOrDefault("repo")
  valid_39116516 = validateParameter(valid_39116516, JString, required = true,
                                   default = nil)
  if valid_39116516 != nil:
    section.add "repo", valid_39116516
  result.add "path", section
  ## parameters in `query` object:
  ##   path: JString
  ##       : Only commits containing this file path will be returned.
  ##   sha: JString
  ##      : Sha or branch to start listing commits from.
  ##   author: JString
  ##         : GitHub login, name, or email by which to filter by commit author.
  ##   until: JString
  ##        : ISO 8601 Date - Only commits before this date will be returned.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_39116517 = query.getOrDefault("path")
  valid_39116517 = validateParameter(valid_39116517, JString, required = false,
                                   default = nil)
  if valid_39116517 != nil:
    section.add "path", valid_39116517
  var valid_39116518 = query.getOrDefault("sha")
  valid_39116518 = validateParameter(valid_39116518, JString, required = false,
                                   default = nil)
  if valid_39116518 != nil:
    section.add "sha", valid_39116518
  var valid_39116519 = query.getOrDefault("author")
  valid_39116519 = validateParameter(valid_39116519, JString, required = false,
                                   default = nil)
  if valid_39116519 != nil:
    section.add "author", valid_39116519
  var valid_39116520 = query.getOrDefault("until")
  valid_39116520 = validateParameter(valid_39116520, JString, required = false,
                                   default = nil)
  if valid_39116520 != nil:
    section.add "until", valid_39116520
  var valid_39116521 = query.getOrDefault("since")
  valid_39116521 = validateParameter(valid_39116521, JString, required = false,
                                   default = nil)
  if valid_39116521 != nil:
    section.add "since", valid_39116521
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116522 = header.getOrDefault("Accept")
  valid_39116522 = validateParameter(valid_39116522, JString, required = false,
                                   default = nil)
  if valid_39116522 != nil:
    section.add "Accept", valid_39116522
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116523: Call_GetReposOwnerRepoCommits_39116512;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List commits on a repository.
  ## 
  let valid = call_39116523.validator(path, query, header, formData, body, _)
  let scheme = call_39116523.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116523.url(scheme.get, call_39116523.host, call_39116523.base,
                           call_39116523.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116523, url, valid, _)

proc call*(call_39116524: Call_GetReposOwnerRepoCommits_39116512; owner: string;
          repo: string; path: string = ""; Accept: string = ""; sha: string = "";
          author: string = ""; until: string = ""; since: string = ""): Recallable =
  ## getReposOwnerRepoCommits
  ## List commits on a repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   path: string
  ##       : Only commits containing this file path will be returned.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   sha: string
  ##      : Sha or branch to start listing commits from.
  ##   author: string
  ##         : GitHub login, name, or email by which to filter by commit author.
  ##   until: string
  ##        : ISO 8601 Date - Only commits before this date will be returned.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var path_39116525 = newJObject()
  var query_39116526 = newJObject()
  var header_39116527 = newJObject()
  add(path_39116525, "owner", newJString(owner))
  add(query_39116526, "path", newJString(path))
  add(header_39116527, "Accept", newJString(Accept))
  add(path_39116525, "repo", newJString(repo))
  add(query_39116526, "sha", newJString(sha))
  add(query_39116526, "author", newJString(author))
  add(query_39116526, "until", newJString(until))
  add(query_39116526, "since", newJString(since))
  result = call_39116524.call(path_39116525, query_39116526, header_39116527, nil, nil)

var getReposOwnerRepoCommits* = Call_GetReposOwnerRepoCommits_39116512(
    name: "getReposOwnerRepoCommits", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/commits",
    validator: validate_GetReposOwnerRepoCommits_39116513, base: "/",
    url: url_GetReposOwnerRepoCommits_39116514, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommitsRefStatus_39116528 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoCommitsRefStatus_39116530(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits/"),
               (kind: VariableSegment, value: "ref"),
               (kind: ConstantSegment, value: "/status")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommitsRefStatus_39116529(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get the combined Status for a specific Ref
  ## The Combined status endpoint is currently available for developers to preview. During the preview period, the API may change without advance notice. Please see the blog post for full details.
  ## To access this endpoint during the preview period, you must provide a custom media type in the Accept header:
  ## application/vnd.github.she-hulk-preview+json
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   ref: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116531 = path.getOrDefault("owner")
  valid_39116531 = validateParameter(valid_39116531, JString, required = true,
                                   default = nil)
  if valid_39116531 != nil:
    section.add "owner", valid_39116531
  var valid_39116532 = path.getOrDefault("ref")
  valid_39116532 = validateParameter(valid_39116532, JString, required = true,
                                   default = nil)
  if valid_39116532 != nil:
    section.add "ref", valid_39116532
  var valid_39116533 = path.getOrDefault("repo")
  valid_39116533 = validateParameter(valid_39116533, JString, required = true,
                                   default = nil)
  if valid_39116533 != nil:
    section.add "repo", valid_39116533
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116534 = header.getOrDefault("Accept")
  valid_39116534 = validateParameter(valid_39116534, JString, required = false,
                                   default = nil)
  if valid_39116534 != nil:
    section.add "Accept", valid_39116534
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116535: Call_GetReposOwnerRepoCommitsRefStatus_39116528;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get the combined Status for a specific Ref
  ## The Combined status endpoint is currently available for developers to preview. During the preview period, the API may change without advance notice. Please see the blog post for full details.
  ## To access this endpoint during the preview period, you must provide a custom media type in the Accept header:
  ## application/vnd.github.she-hulk-preview+json
  ## 
  ## 
  let valid = call_39116535.validator(path, query, header, formData, body, _)
  let scheme = call_39116535.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116535.url(scheme.get, call_39116535.host, call_39116535.base,
                           call_39116535.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116535, url, valid, _)

proc call*(call_39116536: Call_GetReposOwnerRepoCommitsRefStatus_39116528;
          owner: string; `ref`: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommitsRefStatus
  ## Get the combined Status for a specific Ref
  ## The Combined status endpoint is currently available for developers to preview. During the preview period, the API may change without advance notice. Please see the blog post for full details.
  ## To access this endpoint during the preview period, you must provide a custom media type in the Accept header:
  ## application/vnd.github.she-hulk-preview+json
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   ref: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116537 = newJObject()
  var header_39116538 = newJObject()
  add(path_39116537, "owner", newJString(owner))
  add(path_39116537, "ref", newJString(`ref`))
  add(header_39116538, "Accept", newJString(Accept))
  add(path_39116537, "repo", newJString(repo))
  result = call_39116536.call(path_39116537, nil, header_39116538, nil, nil)

var getReposOwnerRepoCommitsRefStatus* = Call_GetReposOwnerRepoCommitsRefStatus_39116528(
    name: "getReposOwnerRepoCommitsRefStatus", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/commits/{ref}/status",
    validator: validate_GetReposOwnerRepoCommitsRefStatus_39116529, base: "/",
    url: url_GetReposOwnerRepoCommitsRefStatus_39116530, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommitsShaCode_39116539 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoCommitsShaCode_39116541(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommitsShaCode_39116540(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a single commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  ##          : SHA-1 code of the commit.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116542 = path.getOrDefault("owner")
  valid_39116542 = validateParameter(valid_39116542, JString, required = true,
                                   default = nil)
  if valid_39116542 != nil:
    section.add "owner", valid_39116542
  var valid_39116543 = path.getOrDefault("repo")
  valid_39116543 = validateParameter(valid_39116543, JString, required = true,
                                   default = nil)
  if valid_39116543 != nil:
    section.add "repo", valid_39116543
  var valid_39116544 = path.getOrDefault("shaCode")
  valid_39116544 = validateParameter(valid_39116544, JString, required = true,
                                   default = nil)
  if valid_39116544 != nil:
    section.add "shaCode", valid_39116544
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116545 = header.getOrDefault("Accept")
  valid_39116545 = validateParameter(valid_39116545, JString, required = false,
                                   default = nil)
  if valid_39116545 != nil:
    section.add "Accept", valid_39116545
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116546: Call_GetReposOwnerRepoCommitsShaCode_39116539;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single commit.
  ## 
  let valid = call_39116546.validator(path, query, header, formData, body, _)
  let scheme = call_39116546.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116546.url(scheme.get, call_39116546.host, call_39116546.base,
                           call_39116546.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116546, url, valid, _)

proc call*(call_39116547: Call_GetReposOwnerRepoCommitsShaCode_39116539;
          owner: string; repo: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommitsShaCode
  ## Get a single commit.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  ##          : SHA-1 code of the commit.
  var path_39116548 = newJObject()
  var header_39116549 = newJObject()
  add(path_39116548, "owner", newJString(owner))
  add(header_39116549, "Accept", newJString(Accept))
  add(path_39116548, "repo", newJString(repo))
  add(path_39116548, "shaCode", newJString(shaCode))
  result = call_39116547.call(path_39116548, nil, header_39116549, nil, nil)

var getReposOwnerRepoCommitsShaCode* = Call_GetReposOwnerRepoCommitsShaCode_39116539(
    name: "getReposOwnerRepoCommitsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/commits/{shaCode}",
    validator: validate_GetReposOwnerRepoCommitsShaCode_39116540, base: "/",
    url: url_GetReposOwnerRepoCommitsShaCode_39116541, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoCommitsShaCodeComments_39116561 = ref object of OpenApiRestCall_39115352
proc url_PostReposOwnerRepoCommitsShaCodeComments_39116563(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits/"),
               (kind: VariableSegment, value: "shaCode"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoCommitsShaCodeComments_39116562(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Create a commit comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  ##          : SHA-1 code of the commit.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116564 = path.getOrDefault("owner")
  valid_39116564 = validateParameter(valid_39116564, JString, required = true,
                                   default = nil)
  if valid_39116564 != nil:
    section.add "owner", valid_39116564
  var valid_39116565 = path.getOrDefault("repo")
  valid_39116565 = validateParameter(valid_39116565, JString, required = true,
                                   default = nil)
  if valid_39116565 != nil:
    section.add "repo", valid_39116565
  var valid_39116566 = path.getOrDefault("shaCode")
  valid_39116566 = validateParameter(valid_39116566, JString, required = true,
                                   default = nil)
  if valid_39116566 != nil:
    section.add "shaCode", valid_39116566
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116567 = header.getOrDefault("Accept")
  valid_39116567 = validateParameter(valid_39116567, JString, required = false,
                                   default = nil)
  if valid_39116567 != nil:
    section.add "Accept", valid_39116567
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39116569: Call_PostReposOwnerRepoCommitsShaCodeComments_39116561;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a commit comment.
  ## 
  let valid = call_39116569.validator(path, query, header, formData, body, _)
  let scheme = call_39116569.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116569.url(scheme.get, call_39116569.host, call_39116569.base,
                           call_39116569.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116569, url, valid, _)

proc call*(call_39116570: Call_PostReposOwnerRepoCommitsShaCodeComments_39116561;
          owner: string; body: JsonNode; repo: string; shaCode: string;
          Accept: string = ""): Recallable =
  ## postReposOwnerRepoCommitsShaCodeComments
  ## Create a commit comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  ##          : SHA-1 code of the commit.
  var path_39116571 = newJObject()
  var header_39116572 = newJObject()
  var body_39116573 = newJObject()
  add(path_39116571, "owner", newJString(owner))
  add(header_39116572, "Accept", newJString(Accept))
  if body != nil:
    body_39116573 = body
  add(path_39116571, "repo", newJString(repo))
  add(path_39116571, "shaCode", newJString(shaCode))
  result = call_39116570.call(path_39116571, nil, header_39116572, nil, body_39116573)

var postReposOwnerRepoCommitsShaCodeComments* = Call_PostReposOwnerRepoCommitsShaCodeComments_39116561(
    name: "postReposOwnerRepoCommitsShaCodeComments", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/commits/{shaCode}/comments",
    validator: validate_PostReposOwnerRepoCommitsShaCodeComments_39116562,
    base: "/", url: url_PostReposOwnerRepoCommitsShaCodeComments_39116563,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommitsShaCodeComments_39116550 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoCommitsShaCodeComments_39116552(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/commits/"),
               (kind: VariableSegment, value: "shaCode"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommitsShaCodeComments_39116551(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List comments for a single commitList comments for a single commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  ##          : SHA-1 code of the commit.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116553 = path.getOrDefault("owner")
  valid_39116553 = validateParameter(valid_39116553, JString, required = true,
                                   default = nil)
  if valid_39116553 != nil:
    section.add "owner", valid_39116553
  var valid_39116554 = path.getOrDefault("repo")
  valid_39116554 = validateParameter(valid_39116554, JString, required = true,
                                   default = nil)
  if valid_39116554 != nil:
    section.add "repo", valid_39116554
  var valid_39116555 = path.getOrDefault("shaCode")
  valid_39116555 = validateParameter(valid_39116555, JString, required = true,
                                   default = nil)
  if valid_39116555 != nil:
    section.add "shaCode", valid_39116555
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116556 = header.getOrDefault("Accept")
  valid_39116556 = validateParameter(valid_39116556, JString, required = false,
                                   default = nil)
  if valid_39116556 != nil:
    section.add "Accept", valid_39116556
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116557: Call_GetReposOwnerRepoCommitsShaCodeComments_39116550;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List comments for a single commitList comments for a single commit.
  ## 
  let valid = call_39116557.validator(path, query, header, formData, body, _)
  let scheme = call_39116557.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116557.url(scheme.get, call_39116557.host, call_39116557.base,
                           call_39116557.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116557, url, valid, _)

proc call*(call_39116558: Call_GetReposOwnerRepoCommitsShaCodeComments_39116550;
          owner: string; repo: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommitsShaCodeComments
  ## List comments for a single commitList comments for a single commit.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  ##          : SHA-1 code of the commit.
  var path_39116559 = newJObject()
  var header_39116560 = newJObject()
  add(path_39116559, "owner", newJString(owner))
  add(header_39116560, "Accept", newJString(Accept))
  add(path_39116559, "repo", newJString(repo))
  add(path_39116559, "shaCode", newJString(shaCode))
  result = call_39116558.call(path_39116559, nil, header_39116560, nil, nil)

var getReposOwnerRepoCommitsShaCodeComments* = Call_GetReposOwnerRepoCommitsShaCodeComments_39116550(
    name: "getReposOwnerRepoCommitsShaCodeComments", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/commits/{shaCode}/comments",
    validator: validate_GetReposOwnerRepoCommitsShaCodeComments_39116551,
    base: "/", url: url_GetReposOwnerRepoCommitsShaCodeComments_39116552,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCompareBaseIdHeadId_39116574 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoCompareBaseIdHeadId_39116576(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "baseId" in path, "`baseId` is a required path parameter"
  assert "headId" in path, "`headId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/compare/"),
               (kind: VariableSegment, value: "baseId"),
               (kind: ConstantSegment, value: "..."),
               (kind: VariableSegment, value: "headId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCompareBaseIdHeadId_39116575(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Compare two commits
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   baseId: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   headId: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116577 = path.getOrDefault("owner")
  valid_39116577 = validateParameter(valid_39116577, JString, required = true,
                                   default = nil)
  if valid_39116577 != nil:
    section.add "owner", valid_39116577
  var valid_39116578 = path.getOrDefault("baseId")
  valid_39116578 = validateParameter(valid_39116578, JString, required = true,
                                   default = nil)
  if valid_39116578 != nil:
    section.add "baseId", valid_39116578
  var valid_39116579 = path.getOrDefault("repo")
  valid_39116579 = validateParameter(valid_39116579, JString, required = true,
                                   default = nil)
  if valid_39116579 != nil:
    section.add "repo", valid_39116579
  var valid_39116580 = path.getOrDefault("headId")
  valid_39116580 = validateParameter(valid_39116580, JString, required = true,
                                   default = nil)
  if valid_39116580 != nil:
    section.add "headId", valid_39116580
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116581 = header.getOrDefault("Accept")
  valid_39116581 = validateParameter(valid_39116581, JString, required = false,
                                   default = nil)
  if valid_39116581 != nil:
    section.add "Accept", valid_39116581
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116582: Call_GetReposOwnerRepoCompareBaseIdHeadId_39116574;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Compare two commits
  ## 
  let valid = call_39116582.validator(path, query, header, formData, body, _)
  let scheme = call_39116582.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116582.url(scheme.get, call_39116582.host, call_39116582.base,
                           call_39116582.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116582, url, valid, _)

proc call*(call_39116583: Call_GetReposOwnerRepoCompareBaseIdHeadId_39116574;
          owner: string; baseId: string; repo: string; headId: string;
          Accept: string = ""): Recallable =
  ## getReposOwnerRepoCompareBaseIdHeadId
  ## Compare two commits
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   baseId: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   headId: string (required)
  var path_39116584 = newJObject()
  var header_39116585 = newJObject()
  add(path_39116584, "owner", newJString(owner))
  add(path_39116584, "baseId", newJString(baseId))
  add(header_39116585, "Accept", newJString(Accept))
  add(path_39116584, "repo", newJString(repo))
  add(path_39116584, "headId", newJString(headId))
  result = call_39116583.call(path_39116584, nil, header_39116585, nil, nil)

var getReposOwnerRepoCompareBaseIdHeadId* = Call_GetReposOwnerRepoCompareBaseIdHeadId_39116574(
    name: "getReposOwnerRepoCompareBaseIdHeadId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/compare/{baseId}...{headId}",
    validator: validate_GetReposOwnerRepoCompareBaseIdHeadId_39116575, base: "/",
    url: url_GetReposOwnerRepoCompareBaseIdHeadId_39116576,
    schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoContentsPath_39116600 = ref object of OpenApiRestCall_39115352
proc url_PutReposOwnerRepoContentsPath_39116602(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/contents/"),
               (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoContentsPath_39116601(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Create a file.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   path: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116603 = path.getOrDefault("owner")
  valid_39116603 = validateParameter(valid_39116603, JString, required = true,
                                   default = nil)
  if valid_39116603 != nil:
    section.add "owner", valid_39116603
  var valid_39116604 = path.getOrDefault("repo")
  valid_39116604 = validateParameter(valid_39116604, JString, required = true,
                                   default = nil)
  if valid_39116604 != nil:
    section.add "repo", valid_39116604
  var valid_39116605 = path.getOrDefault("path")
  valid_39116605 = validateParameter(valid_39116605, JString, required = true,
                                   default = nil)
  if valid_39116605 != nil:
    section.add "path", valid_39116605
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116606 = header.getOrDefault("Accept")
  valid_39116606 = validateParameter(valid_39116606, JString, required = false,
                                   default = nil)
  if valid_39116606 != nil:
    section.add "Accept", valid_39116606
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39116608: Call_PutReposOwnerRepoContentsPath_39116600;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a file.
  ## 
  let valid = call_39116608.validator(path, query, header, formData, body, _)
  let scheme = call_39116608.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116608.url(scheme.get, call_39116608.host, call_39116608.base,
                           call_39116608.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116608, url, valid, _)

proc call*(call_39116609: Call_PutReposOwnerRepoContentsPath_39116600;
          owner: string; body: JsonNode; repo: string; path: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoContentsPath
  ## Create a file.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   path: string (required)
  var path_39116610 = newJObject()
  var header_39116611 = newJObject()
  var body_39116612 = newJObject()
  add(path_39116610, "owner", newJString(owner))
  add(header_39116611, "Accept", newJString(Accept))
  if body != nil:
    body_39116612 = body
  add(path_39116610, "repo", newJString(repo))
  add(path_39116610, "path", newJString(path))
  result = call_39116609.call(path_39116610, nil, header_39116611, nil, body_39116612)

var putReposOwnerRepoContentsPath* = Call_PutReposOwnerRepoContentsPath_39116600(
    name: "putReposOwnerRepoContentsPath", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contents/{path}",
    validator: validate_PutReposOwnerRepoContentsPath_39116601, base: "/",
    url: url_PutReposOwnerRepoContentsPath_39116602, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoContentsPath_39116586 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoContentsPath_39116588(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/contents/"),
               (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoContentsPath_39116587(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get contents.
  ## This method returns the contents of a file or directory in a repository.
  ## Files and symlinks support a custom media type for getting the raw content.
  ## Directories and submodules do not support custom media types.
  ## Note: This API supports files up to 1 megabyte in size.
  ## Here can be many outcomes. For details see "http://developer.github.com/v3/repos/contents/"
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   path: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116589 = path.getOrDefault("owner")
  valid_39116589 = validateParameter(valid_39116589, JString, required = true,
                                   default = nil)
  if valid_39116589 != nil:
    section.add "owner", valid_39116589
  var valid_39116590 = path.getOrDefault("repo")
  valid_39116590 = validateParameter(valid_39116590, JString, required = true,
                                   default = nil)
  if valid_39116590 != nil:
    section.add "repo", valid_39116590
  var valid_39116591 = path.getOrDefault("path")
  valid_39116591 = validateParameter(valid_39116591, JString, required = true,
                                   default = nil)
  if valid_39116591 != nil:
    section.add "path", valid_39116591
  result.add "path", section
  ## parameters in `query` object:
  ##   path: JString
  ##       : The content path.
  ##   ref: JString
  ##      : The String name of the Commit/Branch/Tag. Defaults to 'master'.
  section = newJObject()
  var valid_39116592 = query.getOrDefault("path")
  valid_39116592 = validateParameter(valid_39116592, JString, required = false,
                                   default = nil)
  if valid_39116592 != nil:
    section.add "path", valid_39116592
  var valid_39116593 = query.getOrDefault("ref")
  valid_39116593 = validateParameter(valid_39116593, JString, required = false,
                                   default = nil)
  if valid_39116593 != nil:
    section.add "ref", valid_39116593
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116594 = header.getOrDefault("Accept")
  valid_39116594 = validateParameter(valid_39116594, JString, required = false,
                                   default = nil)
  if valid_39116594 != nil:
    section.add "Accept", valid_39116594
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116595: Call_GetReposOwnerRepoContentsPath_39116586;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get contents.
  ## This method returns the contents of a file or directory in a repository.
  ## Files and symlinks support a custom media type for getting the raw content.
  ## Directories and submodules do not support custom media types.
  ## Note: This API supports files up to 1 megabyte in size.
  ## Here can be many outcomes. For details see "http://developer.github.com/v3/repos/contents/"
  ## 
  ## 
  let valid = call_39116595.validator(path, query, header, formData, body, _)
  let scheme = call_39116595.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116595.url(scheme.get, call_39116595.host, call_39116595.base,
                           call_39116595.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116595, url, valid, _)

var getReposOwnerRepoContentsPath* = Call_GetReposOwnerRepoContentsPath_39116586(
    name: "getReposOwnerRepoContentsPath", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contents/{path}",
    validator: validate_GetReposOwnerRepoContentsPath_39116587, base: "/",
    url: url_GetReposOwnerRepoContentsPath_39116588, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoContentsPath_39116613 = ref object of OpenApiRestCall_39115352
proc url_DeleteReposOwnerRepoContentsPath_39116615(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/contents/"),
               (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoContentsPath_39116614(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a file.
  ## This method deletes a file in a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   path: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116616 = path.getOrDefault("owner")
  valid_39116616 = validateParameter(valid_39116616, JString, required = true,
                                   default = nil)
  if valid_39116616 != nil:
    section.add "owner", valid_39116616
  var valid_39116617 = path.getOrDefault("repo")
  valid_39116617 = validateParameter(valid_39116617, JString, required = true,
                                   default = nil)
  if valid_39116617 != nil:
    section.add "repo", valid_39116617
  var valid_39116618 = path.getOrDefault("path")
  valid_39116618 = validateParameter(valid_39116618, JString, required = true,
                                   default = nil)
  if valid_39116618 != nil:
    section.add "path", valid_39116618
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116619 = header.getOrDefault("Accept")
  valid_39116619 = validateParameter(valid_39116619, JString, required = false,
                                   default = nil)
  if valid_39116619 != nil:
    section.add "Accept", valid_39116619
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39116621: Call_DeleteReposOwnerRepoContentsPath_39116613;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a file.
  ## This method deletes a file in a repository.
  ## 
  ## 
  let valid = call_39116621.validator(path, query, header, formData, body, _)
  let scheme = call_39116621.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116621.url(scheme.get, call_39116621.host, call_39116621.base,
                           call_39116621.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116621, url, valid, _)

proc call*(call_39116622: Call_DeleteReposOwnerRepoContentsPath_39116613;
          owner: string; body: JsonNode; repo: string; path: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoContentsPath
  ## Delete a file.
  ## This method deletes a file in a repository.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   path: string (required)
  var path_39116623 = newJObject()
  var header_39116624 = newJObject()
  var body_39116625 = newJObject()
  add(path_39116623, "owner", newJString(owner))
  add(header_39116624, "Accept", newJString(Accept))
  if body != nil:
    body_39116625 = body
  add(path_39116623, "repo", newJString(repo))
  add(path_39116623, "path", newJString(path))
  result = call_39116622.call(path_39116623, nil, header_39116624, nil, body_39116625)

var deleteReposOwnerRepoContentsPath* = Call_DeleteReposOwnerRepoContentsPath_39116613(
    name: "deleteReposOwnerRepoContentsPath", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contents/{path}",
    validator: validate_DeleteReposOwnerRepoContentsPath_39116614, base: "/",
    url: url_DeleteReposOwnerRepoContentsPath_39116615, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoContributors_39116626 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoContributors_39116628(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/contributors")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoContributors_39116627(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get list of contributors.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116629 = path.getOrDefault("owner")
  valid_39116629 = validateParameter(valid_39116629, JString, required = true,
                                   default = nil)
  if valid_39116629 != nil:
    section.add "owner", valid_39116629
  var valid_39116630 = path.getOrDefault("repo")
  valid_39116630 = validateParameter(valid_39116630, JString, required = true,
                                   default = nil)
  if valid_39116630 != nil:
    section.add "repo", valid_39116630
  result.add "path", section
  ## parameters in `query` object:
  ##   anon: JString (required)
  ##       : Set to 1 or true to include anonymous contributors in results.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `anon` field"
  var valid_39116631 = query.getOrDefault("anon")
  valid_39116631 = validateParameter(valid_39116631, JString, required = true,
                                   default = nil)
  if valid_39116631 != nil:
    section.add "anon", valid_39116631
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116632 = header.getOrDefault("Accept")
  valid_39116632 = validateParameter(valid_39116632, JString, required = false,
                                   default = nil)
  if valid_39116632 != nil:
    section.add "Accept", valid_39116632
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116633: Call_GetReposOwnerRepoContributors_39116626;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get list of contributors.
  ## 
  let valid = call_39116633.validator(path, query, header, formData, body, _)
  let scheme = call_39116633.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116633.url(scheme.get, call_39116633.host, call_39116633.base,
                           call_39116633.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116633, url, valid, _)

proc call*(call_39116634: Call_GetReposOwnerRepoContributors_39116626;
          owner: string; repo: string; anon: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoContributors
  ## Get list of contributors.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   anon: string (required)
  ##       : Set to 1 or true to include anonymous contributors in results.
  var path_39116635 = newJObject()
  var query_39116636 = newJObject()
  var header_39116637 = newJObject()
  add(path_39116635, "owner", newJString(owner))
  add(header_39116637, "Accept", newJString(Accept))
  add(path_39116635, "repo", newJString(repo))
  add(query_39116636, "anon", newJString(anon))
  result = call_39116634.call(path_39116635, query_39116636, header_39116637, nil, nil)

var getReposOwnerRepoContributors* = Call_GetReposOwnerRepoContributors_39116626(
    name: "getReposOwnerRepoContributors", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contributors",
    validator: validate_GetReposOwnerRepoContributors_39116627, base: "/",
    url: url_GetReposOwnerRepoContributors_39116628, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoDeployments_39116648 = ref object of OpenApiRestCall_39115352
proc url_PostReposOwnerRepoDeployments_39116650(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/deployments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoDeployments_39116649(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Users with push access can create a deployment for a given ref
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116651 = path.getOrDefault("owner")
  valid_39116651 = validateParameter(valid_39116651, JString, required = true,
                                   default = nil)
  if valid_39116651 != nil:
    section.add "owner", valid_39116651
  var valid_39116652 = path.getOrDefault("repo")
  valid_39116652 = validateParameter(valid_39116652, JString, required = true,
                                   default = nil)
  if valid_39116652 != nil:
    section.add "repo", valid_39116652
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116653 = header.getOrDefault("Accept")
  valid_39116653 = validateParameter(valid_39116653, JString, required = false,
                                   default = nil)
  if valid_39116653 != nil:
    section.add "Accept", valid_39116653
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39116655: Call_PostReposOwnerRepoDeployments_39116648;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Users with push access can create a deployment for a given ref
  ## 
  let valid = call_39116655.validator(path, query, header, formData, body, _)
  let scheme = call_39116655.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116655.url(scheme.get, call_39116655.host, call_39116655.base,
                           call_39116655.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116655, url, valid, _)

proc call*(call_39116656: Call_PostReposOwnerRepoDeployments_39116648;
          owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoDeployments
  ## Users with push access can create a deployment for a given ref
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116657 = newJObject()
  var header_39116658 = newJObject()
  var body_39116659 = newJObject()
  add(path_39116657, "owner", newJString(owner))
  add(header_39116658, "Accept", newJString(Accept))
  if body != nil:
    body_39116659 = body
  add(path_39116657, "repo", newJString(repo))
  result = call_39116656.call(path_39116657, nil, header_39116658, nil, body_39116659)

var postReposOwnerRepoDeployments* = Call_PostReposOwnerRepoDeployments_39116648(
    name: "postReposOwnerRepoDeployments", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/deployments",
    validator: validate_PostReposOwnerRepoDeployments_39116649, base: "/",
    url: url_PostReposOwnerRepoDeployments_39116650, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDeployments_39116638 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoDeployments_39116640(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/deployments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDeployments_39116639(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Users with pull access can view deployments for a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116641 = path.getOrDefault("owner")
  valid_39116641 = validateParameter(valid_39116641, JString, required = true,
                                   default = nil)
  if valid_39116641 != nil:
    section.add "owner", valid_39116641
  var valid_39116642 = path.getOrDefault("repo")
  valid_39116642 = validateParameter(valid_39116642, JString, required = true,
                                   default = nil)
  if valid_39116642 != nil:
    section.add "repo", valid_39116642
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116643 = header.getOrDefault("Accept")
  valid_39116643 = validateParameter(valid_39116643, JString, required = false,
                                   default = nil)
  if valid_39116643 != nil:
    section.add "Accept", valid_39116643
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116644: Call_GetReposOwnerRepoDeployments_39116638;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Users with pull access can view deployments for a repository
  ## 
  let valid = call_39116644.validator(path, query, header, formData, body, _)
  let scheme = call_39116644.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116644.url(scheme.get, call_39116644.host, call_39116644.base,
                           call_39116644.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116644, url, valid, _)

proc call*(call_39116645: Call_GetReposOwnerRepoDeployments_39116638;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDeployments
  ## Users with pull access can view deployments for a repository
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116646 = newJObject()
  var header_39116647 = newJObject()
  add(path_39116646, "owner", newJString(owner))
  add(header_39116647, "Accept", newJString(Accept))
  add(path_39116646, "repo", newJString(repo))
  result = call_39116645.call(path_39116646, nil, header_39116647, nil, nil)

var getReposOwnerRepoDeployments* = Call_GetReposOwnerRepoDeployments_39116638(
    name: "getReposOwnerRepoDeployments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/deployments",
    validator: validate_GetReposOwnerRepoDeployments_39116639, base: "/",
    url: url_GetReposOwnerRepoDeployments_39116640, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoDeploymentsIdStatuses_39116671 = ref object of OpenApiRestCall_39115352
proc url_PostReposOwnerRepoDeploymentsIdStatuses_39116673(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/deployments/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/statuses")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoDeploymentsIdStatuses_39116672(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Create a Deployment Status
  ## Users with push access can create deployment statuses for a given deployment:
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JInt (required)
  ##     : The Deployment ID to list the statuses from.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116674 = path.getOrDefault("owner")
  valid_39116674 = validateParameter(valid_39116674, JString, required = true,
                                   default = nil)
  if valid_39116674 != nil:
    section.add "owner", valid_39116674
  var valid_39116675 = path.getOrDefault("id")
  valid_39116675 = validateParameter(valid_39116675, JInt, required = true,
                                   default = nil)
  if valid_39116675 != nil:
    section.add "id", valid_39116675
  var valid_39116676 = path.getOrDefault("repo")
  valid_39116676 = validateParameter(valid_39116676, JString, required = true,
                                   default = nil)
  if valid_39116676 != nil:
    section.add "repo", valid_39116676
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116677 = header.getOrDefault("Accept")
  valid_39116677 = validateParameter(valid_39116677, JString, required = false,
                                   default = nil)
  if valid_39116677 != nil:
    section.add "Accept", valid_39116677
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39116679: Call_PostReposOwnerRepoDeploymentsIdStatuses_39116671;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a Deployment Status
  ## Users with push access can create deployment statuses for a given deployment:
  ## 
  ## 
  let valid = call_39116679.validator(path, query, header, formData, body, _)
  let scheme = call_39116679.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116679.url(scheme.get, call_39116679.host, call_39116679.base,
                           call_39116679.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116679, url, valid, _)

proc call*(call_39116680: Call_PostReposOwnerRepoDeploymentsIdStatuses_39116671;
          owner: string; id: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoDeploymentsIdStatuses
  ## Create a Deployment Status
  ## Users with push access can create deployment statuses for a given deployment:
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: int (required)
  ##     : The Deployment ID to list the statuses from.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116681 = newJObject()
  var header_39116682 = newJObject()
  var body_39116683 = newJObject()
  add(path_39116681, "owner", newJString(owner))
  add(path_39116681, "id", newJInt(id))
  add(header_39116682, "Accept", newJString(Accept))
  if body != nil:
    body_39116683 = body
  add(path_39116681, "repo", newJString(repo))
  result = call_39116680.call(path_39116681, nil, header_39116682, nil, body_39116683)

var postReposOwnerRepoDeploymentsIdStatuses* = Call_PostReposOwnerRepoDeploymentsIdStatuses_39116671(
    name: "postReposOwnerRepoDeploymentsIdStatuses", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/deployments/{id}/statuses",
    validator: validate_PostReposOwnerRepoDeploymentsIdStatuses_39116672,
    base: "/", url: url_PostReposOwnerRepoDeploymentsIdStatuses_39116673,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDeploymentsIdStatuses_39116660 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoDeploymentsIdStatuses_39116662(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/deployments/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/statuses")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDeploymentsIdStatuses_39116661(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Users with pull access can view deployment statuses for a deployment
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JInt (required)
  ##     : The Deployment ID to list the statuses from.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116663 = path.getOrDefault("owner")
  valid_39116663 = validateParameter(valid_39116663, JString, required = true,
                                   default = nil)
  if valid_39116663 != nil:
    section.add "owner", valid_39116663
  var valid_39116664 = path.getOrDefault("id")
  valid_39116664 = validateParameter(valid_39116664, JInt, required = true,
                                   default = nil)
  if valid_39116664 != nil:
    section.add "id", valid_39116664
  var valid_39116665 = path.getOrDefault("repo")
  valid_39116665 = validateParameter(valid_39116665, JString, required = true,
                                   default = nil)
  if valid_39116665 != nil:
    section.add "repo", valid_39116665
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116666 = header.getOrDefault("Accept")
  valid_39116666 = validateParameter(valid_39116666, JString, required = false,
                                   default = nil)
  if valid_39116666 != nil:
    section.add "Accept", valid_39116666
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116667: Call_GetReposOwnerRepoDeploymentsIdStatuses_39116660;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Users with pull access can view deployment statuses for a deployment
  ## 
  let valid = call_39116667.validator(path, query, header, formData, body, _)
  let scheme = call_39116667.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116667.url(scheme.get, call_39116667.host, call_39116667.base,
                           call_39116667.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116667, url, valid, _)

proc call*(call_39116668: Call_GetReposOwnerRepoDeploymentsIdStatuses_39116660;
          owner: string; id: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDeploymentsIdStatuses
  ## Users with pull access can view deployment statuses for a deployment
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: int (required)
  ##     : The Deployment ID to list the statuses from.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116669 = newJObject()
  var header_39116670 = newJObject()
  add(path_39116669, "owner", newJString(owner))
  add(path_39116669, "id", newJInt(id))
  add(header_39116670, "Accept", newJString(Accept))
  add(path_39116669, "repo", newJString(repo))
  result = call_39116668.call(path_39116669, nil, header_39116670, nil, nil)

var getReposOwnerRepoDeploymentsIdStatuses* = Call_GetReposOwnerRepoDeploymentsIdStatuses_39116660(
    name: "getReposOwnerRepoDeploymentsIdStatuses", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/deployments/{id}/statuses",
    validator: validate_GetReposOwnerRepoDeploymentsIdStatuses_39116661,
    base: "/", url: url_GetReposOwnerRepoDeploymentsIdStatuses_39116662,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDownloads_39116684 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoDownloads_39116686(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/downloads")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDownloads_39116685(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Deprecated. List downloads for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116687 = path.getOrDefault("owner")
  valid_39116687 = validateParameter(valid_39116687, JString, required = true,
                                   default = nil)
  if valid_39116687 != nil:
    section.add "owner", valid_39116687
  var valid_39116688 = path.getOrDefault("repo")
  valid_39116688 = validateParameter(valid_39116688, JString, required = true,
                                   default = nil)
  if valid_39116688 != nil:
    section.add "repo", valid_39116688
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116689 = header.getOrDefault("Accept")
  valid_39116689 = validateParameter(valid_39116689, JString, required = false,
                                   default = nil)
  if valid_39116689 != nil:
    section.add "Accept", valid_39116689
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116690: Call_GetReposOwnerRepoDownloads_39116684;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Deprecated. List downloads for a repository.
  ## 
  let valid = call_39116690.validator(path, query, header, formData, body, _)
  let scheme = call_39116690.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116690.url(scheme.get, call_39116690.host, call_39116690.base,
                           call_39116690.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116690, url, valid, _)

proc call*(call_39116691: Call_GetReposOwnerRepoDownloads_39116684; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDownloads
  ## Deprecated. List downloads for a repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116692 = newJObject()
  var header_39116693 = newJObject()
  add(path_39116692, "owner", newJString(owner))
  add(header_39116693, "Accept", newJString(Accept))
  add(path_39116692, "repo", newJString(repo))
  result = call_39116691.call(path_39116692, nil, header_39116693, nil, nil)

var getReposOwnerRepoDownloads* = Call_GetReposOwnerRepoDownloads_39116684(
    name: "getReposOwnerRepoDownloads", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/downloads",
    validator: validate_GetReposOwnerRepoDownloads_39116685, base: "/",
    url: url_GetReposOwnerRepoDownloads_39116686, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDownloadsDownloadId_39116694 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoDownloadsDownloadId_39116696(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "downloadId" in path, "`downloadId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/downloads/"),
               (kind: VariableSegment, value: "downloadId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDownloadsDownloadId_39116695(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Deprecated. Get a single download.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   downloadId: JInt (required)
  ##             : Id of download.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116697 = path.getOrDefault("owner")
  valid_39116697 = validateParameter(valid_39116697, JString, required = true,
                                   default = nil)
  if valid_39116697 != nil:
    section.add "owner", valid_39116697
  var valid_39116698 = path.getOrDefault("repo")
  valid_39116698 = validateParameter(valid_39116698, JString, required = true,
                                   default = nil)
  if valid_39116698 != nil:
    section.add "repo", valid_39116698
  var valid_39116699 = path.getOrDefault("downloadId")
  valid_39116699 = validateParameter(valid_39116699, JInt, required = true,
                                   default = nil)
  if valid_39116699 != nil:
    section.add "downloadId", valid_39116699
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116700 = header.getOrDefault("Accept")
  valid_39116700 = validateParameter(valid_39116700, JString, required = false,
                                   default = nil)
  if valid_39116700 != nil:
    section.add "Accept", valid_39116700
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116701: Call_GetReposOwnerRepoDownloadsDownloadId_39116694;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Deprecated. Get a single download.
  ## 
  let valid = call_39116701.validator(path, query, header, formData, body, _)
  let scheme = call_39116701.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116701.url(scheme.get, call_39116701.host, call_39116701.base,
                           call_39116701.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116701, url, valid, _)

proc call*(call_39116702: Call_GetReposOwnerRepoDownloadsDownloadId_39116694;
          owner: string; repo: string; downloadId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDownloadsDownloadId
  ## Deprecated. Get a single download.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   downloadId: int (required)
  ##             : Id of download.
  var path_39116703 = newJObject()
  var header_39116704 = newJObject()
  add(path_39116703, "owner", newJString(owner))
  add(header_39116704, "Accept", newJString(Accept))
  add(path_39116703, "repo", newJString(repo))
  add(path_39116703, "downloadId", newJInt(downloadId))
  result = call_39116702.call(path_39116703, nil, header_39116704, nil, nil)

var getReposOwnerRepoDownloadsDownloadId* = Call_GetReposOwnerRepoDownloadsDownloadId_39116694(
    name: "getReposOwnerRepoDownloadsDownloadId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/downloads/{downloadId}",
    validator: validate_GetReposOwnerRepoDownloadsDownloadId_39116695, base: "/",
    url: url_GetReposOwnerRepoDownloadsDownloadId_39116696,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoDownloadsDownloadId_39116705 = ref object of OpenApiRestCall_39115352
proc url_DeleteReposOwnerRepoDownloadsDownloadId_39116707(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "downloadId" in path, "`downloadId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/downloads/"),
               (kind: VariableSegment, value: "downloadId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoDownloadsDownloadId_39116706(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Deprecated. Delete a download.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   downloadId: JInt (required)
  ##             : Id of download.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116708 = path.getOrDefault("owner")
  valid_39116708 = validateParameter(valid_39116708, JString, required = true,
                                   default = nil)
  if valid_39116708 != nil:
    section.add "owner", valid_39116708
  var valid_39116709 = path.getOrDefault("repo")
  valid_39116709 = validateParameter(valid_39116709, JString, required = true,
                                   default = nil)
  if valid_39116709 != nil:
    section.add "repo", valid_39116709
  var valid_39116710 = path.getOrDefault("downloadId")
  valid_39116710 = validateParameter(valid_39116710, JInt, required = true,
                                   default = nil)
  if valid_39116710 != nil:
    section.add "downloadId", valid_39116710
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116711 = header.getOrDefault("Accept")
  valid_39116711 = validateParameter(valid_39116711, JString, required = false,
                                   default = nil)
  if valid_39116711 != nil:
    section.add "Accept", valid_39116711
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116712: Call_DeleteReposOwnerRepoDownloadsDownloadId_39116705;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Deprecated. Delete a download.
  ## 
  let valid = call_39116712.validator(path, query, header, formData, body, _)
  let scheme = call_39116712.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116712.url(scheme.get, call_39116712.host, call_39116712.base,
                           call_39116712.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116712, url, valid, _)

proc call*(call_39116713: Call_DeleteReposOwnerRepoDownloadsDownloadId_39116705;
          owner: string; repo: string; downloadId: int; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoDownloadsDownloadId
  ## Deprecated. Delete a download.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   downloadId: int (required)
  ##             : Id of download.
  var path_39116714 = newJObject()
  var header_39116715 = newJObject()
  add(path_39116714, "owner", newJString(owner))
  add(header_39116715, "Accept", newJString(Accept))
  add(path_39116714, "repo", newJString(repo))
  add(path_39116714, "downloadId", newJInt(downloadId))
  result = call_39116713.call(path_39116714, nil, header_39116715, nil, nil)

var deleteReposOwnerRepoDownloadsDownloadId* = Call_DeleteReposOwnerRepoDownloadsDownloadId_39116705(
    name: "deleteReposOwnerRepoDownloadsDownloadId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/downloads/{downloadId}",
    validator: validate_DeleteReposOwnerRepoDownloadsDownloadId_39116706,
    base: "/", url: url_DeleteReposOwnerRepoDownloadsDownloadId_39116707,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoEvents_39116716 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoEvents_39116718(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoEvents_39116717(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get list of repository events.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116719 = path.getOrDefault("owner")
  valid_39116719 = validateParameter(valid_39116719, JString, required = true,
                                   default = nil)
  if valid_39116719 != nil:
    section.add "owner", valid_39116719
  var valid_39116720 = path.getOrDefault("repo")
  valid_39116720 = validateParameter(valid_39116720, JString, required = true,
                                   default = nil)
  if valid_39116720 != nil:
    section.add "repo", valid_39116720
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116721 = header.getOrDefault("Accept")
  valid_39116721 = validateParameter(valid_39116721, JString, required = false,
                                   default = nil)
  if valid_39116721 != nil:
    section.add "Accept", valid_39116721
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116722: Call_GetReposOwnerRepoEvents_39116716;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get list of repository events.
  ## 
  let valid = call_39116722.validator(path, query, header, formData, body, _)
  let scheme = call_39116722.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116722.url(scheme.get, call_39116722.host, call_39116722.base,
                           call_39116722.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116722, url, valid, _)

proc call*(call_39116723: Call_GetReposOwnerRepoEvents_39116716; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoEvents
  ## Get list of repository events.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116724 = newJObject()
  var header_39116725 = newJObject()
  add(path_39116724, "owner", newJString(owner))
  add(header_39116725, "Accept", newJString(Accept))
  add(path_39116724, "repo", newJString(repo))
  result = call_39116723.call(path_39116724, nil, header_39116725, nil, nil)

var getReposOwnerRepoEvents* = Call_GetReposOwnerRepoEvents_39116716(
    name: "getReposOwnerRepoEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/events",
    validator: validate_GetReposOwnerRepoEvents_39116717, base: "/",
    url: url_GetReposOwnerRepoEvents_39116718, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoForks_39116738 = ref object of OpenApiRestCall_39115352
proc url_PostReposOwnerRepoForks_39116740(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/forks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoForks_39116739(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a fork.
  ## Forking a Repository happens asynchronously. Therefore, you may have to wai
  ## a short period before accessing the git objects. If this takes longer than 5
  ## minutes, be sure to contact Support.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116741 = path.getOrDefault("owner")
  valid_39116741 = validateParameter(valid_39116741, JString, required = true,
                                   default = nil)
  if valid_39116741 != nil:
    section.add "owner", valid_39116741
  var valid_39116742 = path.getOrDefault("repo")
  valid_39116742 = validateParameter(valid_39116742, JString, required = true,
                                   default = nil)
  if valid_39116742 != nil:
    section.add "repo", valid_39116742
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116743 = header.getOrDefault("Accept")
  valid_39116743 = validateParameter(valid_39116743, JString, required = false,
                                   default = nil)
  if valid_39116743 != nil:
    section.add "Accept", valid_39116743
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39116745: Call_PostReposOwnerRepoForks_39116738;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a fork.
  ## Forking a Repository happens asynchronously. Therefore, you may have to wai
  ## a short period before accessing the git objects. If this takes longer than 5
  ## minutes, be sure to contact Support.
  ## 
  ## 
  let valid = call_39116745.validator(path, query, header, formData, body, _)
  let scheme = call_39116745.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116745.url(scheme.get, call_39116745.host, call_39116745.base,
                           call_39116745.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116745, url, valid, _)

proc call*(call_39116746: Call_PostReposOwnerRepoForks_39116738; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoForks
  ## Create a fork.
  ## Forking a Repository happens asynchronously. Therefore, you may have to wai
  ## a short period before accessing the git objects. If this takes longer than 5
  ## minutes, be sure to contact Support.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116747 = newJObject()
  var header_39116748 = newJObject()
  var body_39116749 = newJObject()
  add(path_39116747, "owner", newJString(owner))
  add(header_39116748, "Accept", newJString(Accept))
  if body != nil:
    body_39116749 = body
  add(path_39116747, "repo", newJString(repo))
  result = call_39116746.call(path_39116747, nil, header_39116748, nil, body_39116749)

var postReposOwnerRepoForks* = Call_PostReposOwnerRepoForks_39116738(
    name: "postReposOwnerRepoForks", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/forks",
    validator: validate_PostReposOwnerRepoForks_39116739, base: "/",
    url: url_PostReposOwnerRepoForks_39116740, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoForks_39116726 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoForks_39116728(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/forks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoForks_39116727(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List forks.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116729 = path.getOrDefault("owner")
  valid_39116729 = validateParameter(valid_39116729, JString, required = true,
                                   default = nil)
  if valid_39116729 != nil:
    section.add "owner", valid_39116729
  var valid_39116730 = path.getOrDefault("repo")
  valid_39116730 = validateParameter(valid_39116730, JString, required = true,
                                   default = nil)
  if valid_39116730 != nil:
    section.add "repo", valid_39116730
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  section = newJObject()
  var valid_39116731 = query.getOrDefault("sort")
  valid_39116731 = validateParameter(valid_39116731, JString, required = false,
                                   default = newJString("newes"))
  if valid_39116731 != nil:
    section.add "sort", valid_39116731
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116732 = header.getOrDefault("Accept")
  valid_39116732 = validateParameter(valid_39116732, JString, required = false,
                                   default = nil)
  if valid_39116732 != nil:
    section.add "Accept", valid_39116732
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116733: Call_GetReposOwnerRepoForks_39116726;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List forks.
  ## 
  let valid = call_39116733.validator(path, query, header, formData, body, _)
  let scheme = call_39116733.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116733.url(scheme.get, call_39116733.host, call_39116733.base,
                           call_39116733.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116733, url, valid, _)

proc call*(call_39116734: Call_GetReposOwnerRepoForks_39116726; owner: string;
          repo: string; Accept: string = ""; sort: string = "newes"): Recallable =
  ## getReposOwnerRepoForks
  ## List forks.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   sort: string
  var path_39116735 = newJObject()
  var query_39116736 = newJObject()
  var header_39116737 = newJObject()
  add(path_39116735, "owner", newJString(owner))
  add(header_39116737, "Accept", newJString(Accept))
  add(path_39116735, "repo", newJString(repo))
  add(query_39116736, "sort", newJString(sort))
  result = call_39116734.call(path_39116735, query_39116736, header_39116737, nil, nil)

var getReposOwnerRepoForks* = Call_GetReposOwnerRepoForks_39116726(
    name: "getReposOwnerRepoForks", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/forks",
    validator: validate_GetReposOwnerRepoForks_39116727, base: "/",
    url: url_GetReposOwnerRepoForks_39116728, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitBlobs_39116750 = ref object of OpenApiRestCall_39115352
proc url_PostReposOwnerRepoGitBlobs_39116752(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/blobs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitBlobs_39116751(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a Blob.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116753 = path.getOrDefault("owner")
  valid_39116753 = validateParameter(valid_39116753, JString, required = true,
                                   default = nil)
  if valid_39116753 != nil:
    section.add "owner", valid_39116753
  var valid_39116754 = path.getOrDefault("repo")
  valid_39116754 = validateParameter(valid_39116754, JString, required = true,
                                   default = nil)
  if valid_39116754 != nil:
    section.add "repo", valid_39116754
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116755 = header.getOrDefault("Accept")
  valid_39116755 = validateParameter(valid_39116755, JString, required = false,
                                   default = nil)
  if valid_39116755 != nil:
    section.add "Accept", valid_39116755
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39116757: Call_PostReposOwnerRepoGitBlobs_39116750;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a Blob.
  ## 
  let valid = call_39116757.validator(path, query, header, formData, body, _)
  let scheme = call_39116757.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116757.url(scheme.get, call_39116757.host, call_39116757.base,
                           call_39116757.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116757, url, valid, _)

proc call*(call_39116758: Call_PostReposOwnerRepoGitBlobs_39116750; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitBlobs
  ## Create a Blob.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116759 = newJObject()
  var header_39116760 = newJObject()
  var body_39116761 = newJObject()
  add(path_39116759, "owner", newJString(owner))
  add(header_39116760, "Accept", newJString(Accept))
  if body != nil:
    body_39116761 = body
  add(path_39116759, "repo", newJString(repo))
  result = call_39116758.call(path_39116759, nil, header_39116760, nil, body_39116761)

var postReposOwnerRepoGitBlobs* = Call_PostReposOwnerRepoGitBlobs_39116750(
    name: "postReposOwnerRepoGitBlobs", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/blobs",
    validator: validate_PostReposOwnerRepoGitBlobs_39116751, base: "/",
    url: url_PostReposOwnerRepoGitBlobs_39116752, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitBlobsShaCode_39116762 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoGitBlobsShaCode_39116764(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/blobs/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitBlobsShaCode_39116763(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a Blob.
  ## Since blobs can be any arbitrary binary data, the input and responses for
  ## the blob API takes an encoding parameter that can be either utf-8 or
  ## base64. If your data cannot be losslessly sent as a UTF-8 string, you can
  ## base64 encode it.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  ##          : SHA-1 code.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116765 = path.getOrDefault("owner")
  valid_39116765 = validateParameter(valid_39116765, JString, required = true,
                                   default = nil)
  if valid_39116765 != nil:
    section.add "owner", valid_39116765
  var valid_39116766 = path.getOrDefault("repo")
  valid_39116766 = validateParameter(valid_39116766, JString, required = true,
                                   default = nil)
  if valid_39116766 != nil:
    section.add "repo", valid_39116766
  var valid_39116767 = path.getOrDefault("shaCode")
  valid_39116767 = validateParameter(valid_39116767, JString, required = true,
                                   default = nil)
  if valid_39116767 != nil:
    section.add "shaCode", valid_39116767
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116768 = header.getOrDefault("Accept")
  valid_39116768 = validateParameter(valid_39116768, JString, required = false,
                                   default = nil)
  if valid_39116768 != nil:
    section.add "Accept", valid_39116768
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116769: Call_GetReposOwnerRepoGitBlobsShaCode_39116762;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a Blob.
  ## Since blobs can be any arbitrary binary data, the input and responses for
  ## the blob API takes an encoding parameter that can be either utf-8 or
  ## base64. If your data cannot be losslessly sent as a UTF-8 string, you can
  ## base64 encode it.
  ## 
  ## 
  let valid = call_39116769.validator(path, query, header, formData, body, _)
  let scheme = call_39116769.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116769.url(scheme.get, call_39116769.host, call_39116769.base,
                           call_39116769.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116769, url, valid, _)

proc call*(call_39116770: Call_GetReposOwnerRepoGitBlobsShaCode_39116762;
          owner: string; repo: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitBlobsShaCode
  ## Get a Blob.
  ## Since blobs can be any arbitrary binary data, the input and responses for
  ## the blob API takes an encoding parameter that can be either utf-8 or
  ## base64. If your data cannot be losslessly sent as a UTF-8 string, you can
  ## base64 encode it.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  ##          : SHA-1 code.
  var path_39116771 = newJObject()
  var header_39116772 = newJObject()
  add(path_39116771, "owner", newJString(owner))
  add(header_39116772, "Accept", newJString(Accept))
  add(path_39116771, "repo", newJString(repo))
  add(path_39116771, "shaCode", newJString(shaCode))
  result = call_39116770.call(path_39116771, nil, header_39116772, nil, nil)

var getReposOwnerRepoGitBlobsShaCode* = Call_GetReposOwnerRepoGitBlobsShaCode_39116762(
    name: "getReposOwnerRepoGitBlobsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/blobs/{shaCode}",
    validator: validate_GetReposOwnerRepoGitBlobsShaCode_39116763, base: "/",
    url: url_GetReposOwnerRepoGitBlobsShaCode_39116764, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitCommits_39116773 = ref object of OpenApiRestCall_39115352
proc url_PostReposOwnerRepoGitCommits_39116775(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/commits")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitCommits_39116774(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Create a Commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116776 = path.getOrDefault("owner")
  valid_39116776 = validateParameter(valid_39116776, JString, required = true,
                                   default = nil)
  if valid_39116776 != nil:
    section.add "owner", valid_39116776
  var valid_39116777 = path.getOrDefault("repo")
  valid_39116777 = validateParameter(valid_39116777, JString, required = true,
                                   default = nil)
  if valid_39116777 != nil:
    section.add "repo", valid_39116777
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116778 = header.getOrDefault("Accept")
  valid_39116778 = validateParameter(valid_39116778, JString, required = false,
                                   default = nil)
  if valid_39116778 != nil:
    section.add "Accept", valid_39116778
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39116780: Call_PostReposOwnerRepoGitCommits_39116773;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a Commit.
  ## 
  let valid = call_39116780.validator(path, query, header, formData, body, _)
  let scheme = call_39116780.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116780.url(scheme.get, call_39116780.host, call_39116780.base,
                           call_39116780.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116780, url, valid, _)

proc call*(call_39116781: Call_PostReposOwnerRepoGitCommits_39116773;
          owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitCommits
  ## Create a Commit.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116782 = newJObject()
  var header_39116783 = newJObject()
  var body_39116784 = newJObject()
  add(path_39116782, "owner", newJString(owner))
  add(header_39116783, "Accept", newJString(Accept))
  if body != nil:
    body_39116784 = body
  add(path_39116782, "repo", newJString(repo))
  result = call_39116781.call(path_39116782, nil, header_39116783, nil, body_39116784)

var postReposOwnerRepoGitCommits* = Call_PostReposOwnerRepoGitCommits_39116773(
    name: "postReposOwnerRepoGitCommits", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/commits",
    validator: validate_PostReposOwnerRepoGitCommits_39116774, base: "/",
    url: url_PostReposOwnerRepoGitCommits_39116775, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitCommitsShaCode_39116785 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoGitCommitsShaCode_39116787(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/commits/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitCommitsShaCode_39116786(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a Commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  ##          : SHA-1 code.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116788 = path.getOrDefault("owner")
  valid_39116788 = validateParameter(valid_39116788, JString, required = true,
                                   default = nil)
  if valid_39116788 != nil:
    section.add "owner", valid_39116788
  var valid_39116789 = path.getOrDefault("repo")
  valid_39116789 = validateParameter(valid_39116789, JString, required = true,
                                   default = nil)
  if valid_39116789 != nil:
    section.add "repo", valid_39116789
  var valid_39116790 = path.getOrDefault("shaCode")
  valid_39116790 = validateParameter(valid_39116790, JString, required = true,
                                   default = nil)
  if valid_39116790 != nil:
    section.add "shaCode", valid_39116790
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116791 = header.getOrDefault("Accept")
  valid_39116791 = validateParameter(valid_39116791, JString, required = false,
                                   default = nil)
  if valid_39116791 != nil:
    section.add "Accept", valid_39116791
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116792: Call_GetReposOwnerRepoGitCommitsShaCode_39116785;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a Commit.
  ## 
  let valid = call_39116792.validator(path, query, header, formData, body, _)
  let scheme = call_39116792.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116792.url(scheme.get, call_39116792.host, call_39116792.base,
                           call_39116792.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116792, url, valid, _)

proc call*(call_39116793: Call_GetReposOwnerRepoGitCommitsShaCode_39116785;
          owner: string; repo: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitCommitsShaCode
  ## Get a Commit.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  ##          : SHA-1 code.
  var path_39116794 = newJObject()
  var header_39116795 = newJObject()
  add(path_39116794, "owner", newJString(owner))
  add(header_39116795, "Accept", newJString(Accept))
  add(path_39116794, "repo", newJString(repo))
  add(path_39116794, "shaCode", newJString(shaCode))
  result = call_39116793.call(path_39116794, nil, header_39116795, nil, nil)

var getReposOwnerRepoGitCommitsShaCode* = Call_GetReposOwnerRepoGitCommitsShaCode_39116785(
    name: "getReposOwnerRepoGitCommitsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/commits/{shaCode}",
    validator: validate_GetReposOwnerRepoGitCommitsShaCode_39116786, base: "/",
    url: url_GetReposOwnerRepoGitCommitsShaCode_39116787, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitRefs_39116806 = ref object of OpenApiRestCall_39115352
proc url_PostReposOwnerRepoGitRefs_39116808(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitRefs_39116807(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a Reference
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116809 = path.getOrDefault("owner")
  valid_39116809 = validateParameter(valid_39116809, JString, required = true,
                                   default = nil)
  if valid_39116809 != nil:
    section.add "owner", valid_39116809
  var valid_39116810 = path.getOrDefault("repo")
  valid_39116810 = validateParameter(valid_39116810, JString, required = true,
                                   default = nil)
  if valid_39116810 != nil:
    section.add "repo", valid_39116810
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116811 = header.getOrDefault("Accept")
  valid_39116811 = validateParameter(valid_39116811, JString, required = false,
                                   default = nil)
  if valid_39116811 != nil:
    section.add "Accept", valid_39116811
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39116813: Call_PostReposOwnerRepoGitRefs_39116806;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a Reference
  ## 
  let valid = call_39116813.validator(path, query, header, formData, body, _)
  let scheme = call_39116813.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116813.url(scheme.get, call_39116813.host, call_39116813.base,
                           call_39116813.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116813, url, valid, _)

proc call*(call_39116814: Call_PostReposOwnerRepoGitRefs_39116806; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitRefs
  ## Create a Reference
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116815 = newJObject()
  var header_39116816 = newJObject()
  var body_39116817 = newJObject()
  add(path_39116815, "owner", newJString(owner))
  add(header_39116816, "Accept", newJString(Accept))
  if body != nil:
    body_39116817 = body
  add(path_39116815, "repo", newJString(repo))
  result = call_39116814.call(path_39116815, nil, header_39116816, nil, body_39116817)

var postReposOwnerRepoGitRefs* = Call_PostReposOwnerRepoGitRefs_39116806(
    name: "postReposOwnerRepoGitRefs", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs",
    validator: validate_PostReposOwnerRepoGitRefs_39116807, base: "/",
    url: url_PostReposOwnerRepoGitRefs_39116808, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitRefs_39116796 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoGitRefs_39116798(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitRefs_39116797(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get all References
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116799 = path.getOrDefault("owner")
  valid_39116799 = validateParameter(valid_39116799, JString, required = true,
                                   default = nil)
  if valid_39116799 != nil:
    section.add "owner", valid_39116799
  var valid_39116800 = path.getOrDefault("repo")
  valid_39116800 = validateParameter(valid_39116800, JString, required = true,
                                   default = nil)
  if valid_39116800 != nil:
    section.add "repo", valid_39116800
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116801 = header.getOrDefault("Accept")
  valid_39116801 = validateParameter(valid_39116801, JString, required = false,
                                   default = nil)
  if valid_39116801 != nil:
    section.add "Accept", valid_39116801
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116802: Call_GetReposOwnerRepoGitRefs_39116796;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get all References
  ## 
  let valid = call_39116802.validator(path, query, header, formData, body, _)
  let scheme = call_39116802.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116802.url(scheme.get, call_39116802.host, call_39116802.base,
                           call_39116802.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116802, url, valid, _)

proc call*(call_39116803: Call_GetReposOwnerRepoGitRefs_39116796; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitRefs
  ## Get all References
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116804 = newJObject()
  var header_39116805 = newJObject()
  add(path_39116804, "owner", newJString(owner))
  add(header_39116805, "Accept", newJString(Accept))
  add(path_39116804, "repo", newJString(repo))
  result = call_39116803.call(path_39116804, nil, header_39116805, nil, nil)

var getReposOwnerRepoGitRefs* = Call_GetReposOwnerRepoGitRefs_39116796(
    name: "getReposOwnerRepoGitRefs", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs",
    validator: validate_GetReposOwnerRepoGitRefs_39116797, base: "/",
    url: url_GetReposOwnerRepoGitRefs_39116798, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitRefsRef_39116818 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoGitRefsRef_39116820(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitRefsRef_39116819(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get a Reference
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   ref: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116821 = path.getOrDefault("owner")
  valid_39116821 = validateParameter(valid_39116821, JString, required = true,
                                   default = nil)
  if valid_39116821 != nil:
    section.add "owner", valid_39116821
  var valid_39116822 = path.getOrDefault("ref")
  valid_39116822 = validateParameter(valid_39116822, JString, required = true,
                                   default = nil)
  if valid_39116822 != nil:
    section.add "ref", valid_39116822
  var valid_39116823 = path.getOrDefault("repo")
  valid_39116823 = validateParameter(valid_39116823, JString, required = true,
                                   default = nil)
  if valid_39116823 != nil:
    section.add "repo", valid_39116823
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116824 = header.getOrDefault("Accept")
  valid_39116824 = validateParameter(valid_39116824, JString, required = false,
                                   default = nil)
  if valid_39116824 != nil:
    section.add "Accept", valid_39116824
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116825: Call_GetReposOwnerRepoGitRefsRef_39116818;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a Reference
  ## 
  let valid = call_39116825.validator(path, query, header, formData, body, _)
  let scheme = call_39116825.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116825.url(scheme.get, call_39116825.host, call_39116825.base,
                           call_39116825.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116825, url, valid, _)

proc call*(call_39116826: Call_GetReposOwnerRepoGitRefsRef_39116818; owner: string;
          `ref`: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitRefsRef
  ## Get a Reference
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   ref: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116827 = newJObject()
  var header_39116828 = newJObject()
  add(path_39116827, "owner", newJString(owner))
  add(path_39116827, "ref", newJString(`ref`))
  add(header_39116828, "Accept", newJString(Accept))
  add(path_39116827, "repo", newJString(repo))
  result = call_39116826.call(path_39116827, nil, header_39116828, nil, nil)

var getReposOwnerRepoGitRefsRef* = Call_GetReposOwnerRepoGitRefsRef_39116818(
    name: "getReposOwnerRepoGitRefsRef", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs/{ref}",
    validator: validate_GetReposOwnerRepoGitRefsRef_39116819, base: "/",
    url: url_GetReposOwnerRepoGitRefsRef_39116820, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoGitRefsRef_39116840 = ref object of OpenApiRestCall_39115352
proc url_PatchReposOwnerRepoGitRefsRef_39116842(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoGitRefsRef_39116841(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Update a Reference
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   ref: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116843 = path.getOrDefault("owner")
  valid_39116843 = validateParameter(valid_39116843, JString, required = true,
                                   default = nil)
  if valid_39116843 != nil:
    section.add "owner", valid_39116843
  var valid_39116844 = path.getOrDefault("ref")
  valid_39116844 = validateParameter(valid_39116844, JString, required = true,
                                   default = nil)
  if valid_39116844 != nil:
    section.add "ref", valid_39116844
  var valid_39116845 = path.getOrDefault("repo")
  valid_39116845 = validateParameter(valid_39116845, JString, required = true,
                                   default = nil)
  if valid_39116845 != nil:
    section.add "repo", valid_39116845
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116846 = header.getOrDefault("Accept")
  valid_39116846 = validateParameter(valid_39116846, JString, required = false,
                                   default = nil)
  if valid_39116846 != nil:
    section.add "Accept", valid_39116846
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39116848: Call_PatchReposOwnerRepoGitRefsRef_39116840;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Update a Reference
  ## 
  let valid = call_39116848.validator(path, query, header, formData, body, _)
  let scheme = call_39116848.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116848.url(scheme.get, call_39116848.host, call_39116848.base,
                           call_39116848.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116848, url, valid, _)

proc call*(call_39116849: Call_PatchReposOwnerRepoGitRefsRef_39116840;
          owner: string; `ref`: string; body: JsonNode; repo: string;
          Accept: string = ""): Recallable =
  ## patchReposOwnerRepoGitRefsRef
  ## Update a Reference
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   ref: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116850 = newJObject()
  var header_39116851 = newJObject()
  var body_39116852 = newJObject()
  add(path_39116850, "owner", newJString(owner))
  add(path_39116850, "ref", newJString(`ref`))
  add(header_39116851, "Accept", newJString(Accept))
  if body != nil:
    body_39116852 = body
  add(path_39116850, "repo", newJString(repo))
  result = call_39116849.call(path_39116850, nil, header_39116851, nil, body_39116852)

var patchReposOwnerRepoGitRefsRef* = Call_PatchReposOwnerRepoGitRefsRef_39116840(
    name: "patchReposOwnerRepoGitRefsRef", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs/{ref}",
    validator: validate_PatchReposOwnerRepoGitRefsRef_39116841, base: "/",
    url: url_PatchReposOwnerRepoGitRefsRef_39116842, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoGitRefsRef_39116829 = ref object of OpenApiRestCall_39115352
proc url_DeleteReposOwnerRepoGitRefsRef_39116831(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/refs/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoGitRefsRef_39116830(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a Reference
  ## Example: Deleting a branch: DELETE /repos/octocat/Hello-World/git/refs/heads/feature-a
  ## Example: Deleting a tag:        DELETE /repos/octocat/Hello-World/git/refs/tags/v1.0
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   ref: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116832 = path.getOrDefault("owner")
  valid_39116832 = validateParameter(valid_39116832, JString, required = true,
                                   default = nil)
  if valid_39116832 != nil:
    section.add "owner", valid_39116832
  var valid_39116833 = path.getOrDefault("ref")
  valid_39116833 = validateParameter(valid_39116833, JString, required = true,
                                   default = nil)
  if valid_39116833 != nil:
    section.add "ref", valid_39116833
  var valid_39116834 = path.getOrDefault("repo")
  valid_39116834 = validateParameter(valid_39116834, JString, required = true,
                                   default = nil)
  if valid_39116834 != nil:
    section.add "repo", valid_39116834
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116835 = header.getOrDefault("Accept")
  valid_39116835 = validateParameter(valid_39116835, JString, required = false,
                                   default = nil)
  if valid_39116835 != nil:
    section.add "Accept", valid_39116835
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116836: Call_DeleteReposOwnerRepoGitRefsRef_39116829;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a Reference
  ## Example: Deleting a branch: DELETE /repos/octocat/Hello-World/git/refs/heads/feature-a
  ## Example: Deleting a tag:        DELETE /repos/octocat/Hello-World/git/refs/tags/v1.0
  ## 
  ## 
  let valid = call_39116836.validator(path, query, header, formData, body, _)
  let scheme = call_39116836.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116836.url(scheme.get, call_39116836.host, call_39116836.base,
                           call_39116836.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116836, url, valid, _)

proc call*(call_39116837: Call_DeleteReposOwnerRepoGitRefsRef_39116829;
          owner: string; `ref`: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoGitRefsRef
  ## Delete a Reference
  ## Example: Deleting a branch: DELETE /repos/octocat/Hello-World/git/refs/heads/feature-a
  ## Example: Deleting a tag:        DELETE /repos/octocat/Hello-World/git/refs/tags/v1.0
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   ref: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116838 = newJObject()
  var header_39116839 = newJObject()
  add(path_39116838, "owner", newJString(owner))
  add(path_39116838, "ref", newJString(`ref`))
  add(header_39116839, "Accept", newJString(Accept))
  add(path_39116838, "repo", newJString(repo))
  result = call_39116837.call(path_39116838, nil, header_39116839, nil, nil)

var deleteReposOwnerRepoGitRefsRef* = Call_DeleteReposOwnerRepoGitRefsRef_39116829(
    name: "deleteReposOwnerRepoGitRefsRef", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs/{ref}",
    validator: validate_DeleteReposOwnerRepoGitRefsRef_39116830, base: "/",
    url: url_DeleteReposOwnerRepoGitRefsRef_39116831, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitTags_39116853 = ref object of OpenApiRestCall_39115352
proc url_PostReposOwnerRepoGitTags_39116855(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/tags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitTags_39116854(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a Tag Object.
  ## Note that creating a tag object does not create the reference that makes a
  ## tag in Git. If you want to create an annotated tag in Git, you have to do
  ## this call to create the tag object, and then create the refs/tags/[tag]
  ## reference. If you want to create a lightweight tag, you only have to create
  ## the tag reference - this call would be unnecessary.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116856 = path.getOrDefault("owner")
  valid_39116856 = validateParameter(valid_39116856, JString, required = true,
                                   default = nil)
  if valid_39116856 != nil:
    section.add "owner", valid_39116856
  var valid_39116857 = path.getOrDefault("repo")
  valid_39116857 = validateParameter(valid_39116857, JString, required = true,
                                   default = nil)
  if valid_39116857 != nil:
    section.add "repo", valid_39116857
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116858 = header.getOrDefault("Accept")
  valid_39116858 = validateParameter(valid_39116858, JString, required = false,
                                   default = nil)
  if valid_39116858 != nil:
    section.add "Accept", valid_39116858
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39116860: Call_PostReposOwnerRepoGitTags_39116853;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a Tag Object.
  ## Note that creating a tag object does not create the reference that makes a
  ## tag in Git. If you want to create an annotated tag in Git, you have to do
  ## this call to create the tag object, and then create the refs/tags/[tag]
  ## reference. If you want to create a lightweight tag, you only have to create
  ## the tag reference - this call would be unnecessary.
  ## 
  ## 
  let valid = call_39116860.validator(path, query, header, formData, body, _)
  let scheme = call_39116860.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116860.url(scheme.get, call_39116860.host, call_39116860.base,
                           call_39116860.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116860, url, valid, _)

proc call*(call_39116861: Call_PostReposOwnerRepoGitTags_39116853; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitTags
  ## Create a Tag Object.
  ## Note that creating a tag object does not create the reference that makes a
  ## tag in Git. If you want to create an annotated tag in Git, you have to do
  ## this call to create the tag object, and then create the refs/tags/[tag]
  ## reference. If you want to create a lightweight tag, you only have to create
  ## the tag reference - this call would be unnecessary.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116862 = newJObject()
  var header_39116863 = newJObject()
  var body_39116864 = newJObject()
  add(path_39116862, "owner", newJString(owner))
  add(header_39116863, "Accept", newJString(Accept))
  if body != nil:
    body_39116864 = body
  add(path_39116862, "repo", newJString(repo))
  result = call_39116861.call(path_39116862, nil, header_39116863, nil, body_39116864)

var postReposOwnerRepoGitTags* = Call_PostReposOwnerRepoGitTags_39116853(
    name: "postReposOwnerRepoGitTags", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/tags",
    validator: validate_PostReposOwnerRepoGitTags_39116854, base: "/",
    url: url_PostReposOwnerRepoGitTags_39116855, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitTagsShaCode_39116865 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoGitTagsShaCode_39116867(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/tags/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitTagsShaCode_39116866(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a Tag.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116868 = path.getOrDefault("owner")
  valid_39116868 = validateParameter(valid_39116868, JString, required = true,
                                   default = nil)
  if valid_39116868 != nil:
    section.add "owner", valid_39116868
  var valid_39116869 = path.getOrDefault("repo")
  valid_39116869 = validateParameter(valid_39116869, JString, required = true,
                                   default = nil)
  if valid_39116869 != nil:
    section.add "repo", valid_39116869
  var valid_39116870 = path.getOrDefault("shaCode")
  valid_39116870 = validateParameter(valid_39116870, JString, required = true,
                                   default = nil)
  if valid_39116870 != nil:
    section.add "shaCode", valid_39116870
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116871 = header.getOrDefault("Accept")
  valid_39116871 = validateParameter(valid_39116871, JString, required = false,
                                   default = nil)
  if valid_39116871 != nil:
    section.add "Accept", valid_39116871
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116872: Call_GetReposOwnerRepoGitTagsShaCode_39116865;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a Tag.
  ## 
  let valid = call_39116872.validator(path, query, header, formData, body, _)
  let scheme = call_39116872.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116872.url(scheme.get, call_39116872.host, call_39116872.base,
                           call_39116872.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116872, url, valid, _)

proc call*(call_39116873: Call_GetReposOwnerRepoGitTagsShaCode_39116865;
          owner: string; repo: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitTagsShaCode
  ## Get a Tag.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  var path_39116874 = newJObject()
  var header_39116875 = newJObject()
  add(path_39116874, "owner", newJString(owner))
  add(header_39116875, "Accept", newJString(Accept))
  add(path_39116874, "repo", newJString(repo))
  add(path_39116874, "shaCode", newJString(shaCode))
  result = call_39116873.call(path_39116874, nil, header_39116875, nil, nil)

var getReposOwnerRepoGitTagsShaCode* = Call_GetReposOwnerRepoGitTagsShaCode_39116865(
    name: "getReposOwnerRepoGitTagsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/tags/{shaCode}",
    validator: validate_GetReposOwnerRepoGitTagsShaCode_39116866, base: "/",
    url: url_GetReposOwnerRepoGitTagsShaCode_39116867, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitTrees_39116876 = ref object of OpenApiRestCall_39115352
proc url_PostReposOwnerRepoGitTrees_39116878(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/trees")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitTrees_39116877(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a Tree.
  ## The tree creation API will take nested entries as well. If both a tree and
  ## a nested path modifying that tree are specified, it will overwrite the
  ## contents of that tree with the new path contents and write a new tree out.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116879 = path.getOrDefault("owner")
  valid_39116879 = validateParameter(valid_39116879, JString, required = true,
                                   default = nil)
  if valid_39116879 != nil:
    section.add "owner", valid_39116879
  var valid_39116880 = path.getOrDefault("repo")
  valid_39116880 = validateParameter(valid_39116880, JString, required = true,
                                   default = nil)
  if valid_39116880 != nil:
    section.add "repo", valid_39116880
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116881 = header.getOrDefault("Accept")
  valid_39116881 = validateParameter(valid_39116881, JString, required = false,
                                   default = nil)
  if valid_39116881 != nil:
    section.add "Accept", valid_39116881
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39116883: Call_PostReposOwnerRepoGitTrees_39116876;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a Tree.
  ## The tree creation API will take nested entries as well. If both a tree and
  ## a nested path modifying that tree are specified, it will overwrite the
  ## contents of that tree with the new path contents and write a new tree out.
  ## 
  ## 
  let valid = call_39116883.validator(path, query, header, formData, body, _)
  let scheme = call_39116883.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116883.url(scheme.get, call_39116883.host, call_39116883.base,
                           call_39116883.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116883, url, valid, _)

proc call*(call_39116884: Call_PostReposOwnerRepoGitTrees_39116876; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitTrees
  ## Create a Tree.
  ## The tree creation API will take nested entries as well. If both a tree and
  ## a nested path modifying that tree are specified, it will overwrite the
  ## contents of that tree with the new path contents and write a new tree out.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116885 = newJObject()
  var header_39116886 = newJObject()
  var body_39116887 = newJObject()
  add(path_39116885, "owner", newJString(owner))
  add(header_39116886, "Accept", newJString(Accept))
  if body != nil:
    body_39116887 = body
  add(path_39116885, "repo", newJString(repo))
  result = call_39116884.call(path_39116885, nil, header_39116886, nil, body_39116887)

var postReposOwnerRepoGitTrees* = Call_PostReposOwnerRepoGitTrees_39116876(
    name: "postReposOwnerRepoGitTrees", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/trees",
    validator: validate_PostReposOwnerRepoGitTrees_39116877, base: "/",
    url: url_PostReposOwnerRepoGitTrees_39116878, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitTreesShaCode_39116888 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoGitTreesShaCode_39116890(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/git/trees/"),
               (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitTreesShaCode_39116889(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a Tree.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  ##          : Tree SHA.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116891 = path.getOrDefault("owner")
  valid_39116891 = validateParameter(valid_39116891, JString, required = true,
                                   default = nil)
  if valid_39116891 != nil:
    section.add "owner", valid_39116891
  var valid_39116892 = path.getOrDefault("repo")
  valid_39116892 = validateParameter(valid_39116892, JString, required = true,
                                   default = nil)
  if valid_39116892 != nil:
    section.add "repo", valid_39116892
  var valid_39116893 = path.getOrDefault("shaCode")
  valid_39116893 = validateParameter(valid_39116893, JString, required = true,
                                   default = nil)
  if valid_39116893 != nil:
    section.add "shaCode", valid_39116893
  result.add "path", section
  ## parameters in `query` object:
  ##   recursive: JInt
  ##            : Get a Tree Recursively. (0 or 1)
  section = newJObject()
  var valid_39116894 = query.getOrDefault("recursive")
  valid_39116894 = validateParameter(valid_39116894, JInt, required = false,
                                   default = nil)
  if valid_39116894 != nil:
    section.add "recursive", valid_39116894
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116895 = header.getOrDefault("Accept")
  valid_39116895 = validateParameter(valid_39116895, JString, required = false,
                                   default = nil)
  if valid_39116895 != nil:
    section.add "Accept", valid_39116895
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116896: Call_GetReposOwnerRepoGitTreesShaCode_39116888;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a Tree.
  ## 
  let valid = call_39116896.validator(path, query, header, formData, body, _)
  let scheme = call_39116896.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116896.url(scheme.get, call_39116896.host, call_39116896.base,
                           call_39116896.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116896, url, valid, _)

proc call*(call_39116897: Call_GetReposOwnerRepoGitTreesShaCode_39116888;
          owner: string; repo: string; shaCode: string; recursive: int = 0;
          Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitTreesShaCode
  ## Get a Tree.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   recursive: int
  ##            : Get a Tree Recursively. (0 or 1)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  ##          : Tree SHA.
  var path_39116898 = newJObject()
  var query_39116899 = newJObject()
  var header_39116900 = newJObject()
  add(path_39116898, "owner", newJString(owner))
  add(query_39116899, "recursive", newJInt(recursive))
  add(header_39116900, "Accept", newJString(Accept))
  add(path_39116898, "repo", newJString(repo))
  add(path_39116898, "shaCode", newJString(shaCode))
  result = call_39116897.call(path_39116898, query_39116899, header_39116900, nil, nil)

var getReposOwnerRepoGitTreesShaCode* = Call_GetReposOwnerRepoGitTreesShaCode_39116888(
    name: "getReposOwnerRepoGitTreesShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/trees/{shaCode}",
    validator: validate_GetReposOwnerRepoGitTreesShaCode_39116889, base: "/",
    url: url_GetReposOwnerRepoGitTreesShaCode_39116890, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoHooks_39116911 = ref object of OpenApiRestCall_39115352
proc url_PostReposOwnerRepoHooks_39116913(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoHooks_39116912(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116914 = path.getOrDefault("owner")
  valid_39116914 = validateParameter(valid_39116914, JString, required = true,
                                   default = nil)
  if valid_39116914 != nil:
    section.add "owner", valid_39116914
  var valid_39116915 = path.getOrDefault("repo")
  valid_39116915 = validateParameter(valid_39116915, JString, required = true,
                                   default = nil)
  if valid_39116915 != nil:
    section.add "repo", valid_39116915
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116916 = header.getOrDefault("Accept")
  valid_39116916 = validateParameter(valid_39116916, JString, required = false,
                                   default = nil)
  if valid_39116916 != nil:
    section.add "Accept", valid_39116916
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39116918: Call_PostReposOwnerRepoHooks_39116911;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a hook.
  ## 
  let valid = call_39116918.validator(path, query, header, formData, body, _)
  let scheme = call_39116918.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116918.url(scheme.get, call_39116918.host, call_39116918.base,
                           call_39116918.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116918, url, valid, _)

proc call*(call_39116919: Call_PostReposOwnerRepoHooks_39116911; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoHooks
  ## Create a hook.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116920 = newJObject()
  var header_39116921 = newJObject()
  var body_39116922 = newJObject()
  add(path_39116920, "owner", newJString(owner))
  add(header_39116921, "Accept", newJString(Accept))
  if body != nil:
    body_39116922 = body
  add(path_39116920, "repo", newJString(repo))
  result = call_39116919.call(path_39116920, nil, header_39116921, nil, body_39116922)

var postReposOwnerRepoHooks* = Call_PostReposOwnerRepoHooks_39116911(
    name: "postReposOwnerRepoHooks", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks",
    validator: validate_PostReposOwnerRepoHooks_39116912, base: "/",
    url: url_PostReposOwnerRepoHooks_39116913, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoHooks_39116901 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoHooks_39116903(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoHooks_39116902(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get list of hooks.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116904 = path.getOrDefault("owner")
  valid_39116904 = validateParameter(valid_39116904, JString, required = true,
                                   default = nil)
  if valid_39116904 != nil:
    section.add "owner", valid_39116904
  var valid_39116905 = path.getOrDefault("repo")
  valid_39116905 = validateParameter(valid_39116905, JString, required = true,
                                   default = nil)
  if valid_39116905 != nil:
    section.add "repo", valid_39116905
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116906 = header.getOrDefault("Accept")
  valid_39116906 = validateParameter(valid_39116906, JString, required = false,
                                   default = nil)
  if valid_39116906 != nil:
    section.add "Accept", valid_39116906
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116907: Call_GetReposOwnerRepoHooks_39116901;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get list of hooks.
  ## 
  let valid = call_39116907.validator(path, query, header, formData, body, _)
  let scheme = call_39116907.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116907.url(scheme.get, call_39116907.host, call_39116907.base,
                           call_39116907.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116907, url, valid, _)

proc call*(call_39116908: Call_GetReposOwnerRepoHooks_39116901; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoHooks
  ## Get list of hooks.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116909 = newJObject()
  var header_39116910 = newJObject()
  add(path_39116909, "owner", newJString(owner))
  add(header_39116910, "Accept", newJString(Accept))
  add(path_39116909, "repo", newJString(repo))
  result = call_39116908.call(path_39116909, nil, header_39116910, nil, nil)

var getReposOwnerRepoHooks* = Call_GetReposOwnerRepoHooks_39116901(
    name: "getReposOwnerRepoHooks", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks",
    validator: validate_GetReposOwnerRepoHooks_39116902, base: "/",
    url: url_GetReposOwnerRepoHooks_39116903, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoHooksHookId_39116923 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoHooksHookId_39116925(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hookId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoHooksHookId_39116924(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get single hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   hookId: JInt (required)
  ##         : Id of hook.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116926 = path.getOrDefault("owner")
  valid_39116926 = validateParameter(valid_39116926, JString, required = true,
                                   default = nil)
  if valid_39116926 != nil:
    section.add "owner", valid_39116926
  var valid_39116927 = path.getOrDefault("repo")
  valid_39116927 = validateParameter(valid_39116927, JString, required = true,
                                   default = nil)
  if valid_39116927 != nil:
    section.add "repo", valid_39116927
  var valid_39116928 = path.getOrDefault("hookId")
  valid_39116928 = validateParameter(valid_39116928, JInt, required = true,
                                   default = nil)
  if valid_39116928 != nil:
    section.add "hookId", valid_39116928
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116929 = header.getOrDefault("Accept")
  valid_39116929 = validateParameter(valid_39116929, JString, required = false,
                                   default = nil)
  if valid_39116929 != nil:
    section.add "Accept", valid_39116929
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116930: Call_GetReposOwnerRepoHooksHookId_39116923;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get single hook.
  ## 
  let valid = call_39116930.validator(path, query, header, formData, body, _)
  let scheme = call_39116930.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116930.url(scheme.get, call_39116930.host, call_39116930.base,
                           call_39116930.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116930, url, valid, _)

proc call*(call_39116931: Call_GetReposOwnerRepoHooksHookId_39116923;
          owner: string; repo: string; hookId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoHooksHookId
  ## Get single hook.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   hookId: int (required)
  ##         : Id of hook.
  var path_39116932 = newJObject()
  var header_39116933 = newJObject()
  add(path_39116932, "owner", newJString(owner))
  add(header_39116933, "Accept", newJString(Accept))
  add(path_39116932, "repo", newJString(repo))
  add(path_39116932, "hookId", newJInt(hookId))
  result = call_39116931.call(path_39116932, nil, header_39116933, nil, nil)

var getReposOwnerRepoHooksHookId* = Call_GetReposOwnerRepoHooksHookId_39116923(
    name: "getReposOwnerRepoHooksHookId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}",
    validator: validate_GetReposOwnerRepoHooksHookId_39116924, base: "/",
    url: url_GetReposOwnerRepoHooksHookId_39116925, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoHooksHookId_39116945 = ref object of OpenApiRestCall_39115352
proc url_PatchReposOwnerRepoHooksHookId_39116947(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hookId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoHooksHookId_39116946(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Edit a hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   hookId: JInt (required)
  ##         : Id of hook.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116948 = path.getOrDefault("owner")
  valid_39116948 = validateParameter(valid_39116948, JString, required = true,
                                   default = nil)
  if valid_39116948 != nil:
    section.add "owner", valid_39116948
  var valid_39116949 = path.getOrDefault("repo")
  valid_39116949 = validateParameter(valid_39116949, JString, required = true,
                                   default = nil)
  if valid_39116949 != nil:
    section.add "repo", valid_39116949
  var valid_39116950 = path.getOrDefault("hookId")
  valid_39116950 = validateParameter(valid_39116950, JInt, required = true,
                                   default = nil)
  if valid_39116950 != nil:
    section.add "hookId", valid_39116950
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116951 = header.getOrDefault("Accept")
  valid_39116951 = validateParameter(valid_39116951, JString, required = false,
                                   default = nil)
  if valid_39116951 != nil:
    section.add "Accept", valid_39116951
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39116953: Call_PatchReposOwnerRepoHooksHookId_39116945;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit a hook.
  ## 
  let valid = call_39116953.validator(path, query, header, formData, body, _)
  let scheme = call_39116953.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116953.url(scheme.get, call_39116953.host, call_39116953.base,
                           call_39116953.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116953, url, valid, _)

proc call*(call_39116954: Call_PatchReposOwnerRepoHooksHookId_39116945;
          owner: string; body: JsonNode; repo: string; hookId: int; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoHooksHookId
  ## Edit a hook.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   hookId: int (required)
  ##         : Id of hook.
  var path_39116955 = newJObject()
  var header_39116956 = newJObject()
  var body_39116957 = newJObject()
  add(path_39116955, "owner", newJString(owner))
  add(header_39116956, "Accept", newJString(Accept))
  if body != nil:
    body_39116957 = body
  add(path_39116955, "repo", newJString(repo))
  add(path_39116955, "hookId", newJInt(hookId))
  result = call_39116954.call(path_39116955, nil, header_39116956, nil, body_39116957)

var patchReposOwnerRepoHooksHookId* = Call_PatchReposOwnerRepoHooksHookId_39116945(
    name: "patchReposOwnerRepoHooksHookId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}",
    validator: validate_PatchReposOwnerRepoHooksHookId_39116946, base: "/",
    url: url_PatchReposOwnerRepoHooksHookId_39116947, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoHooksHookId_39116934 = ref object of OpenApiRestCall_39115352
proc url_DeleteReposOwnerRepoHooksHookId_39116936(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hookId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoHooksHookId_39116935(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   hookId: JInt (required)
  ##         : Id of hook.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116937 = path.getOrDefault("owner")
  valid_39116937 = validateParameter(valid_39116937, JString, required = true,
                                   default = nil)
  if valid_39116937 != nil:
    section.add "owner", valid_39116937
  var valid_39116938 = path.getOrDefault("repo")
  valid_39116938 = validateParameter(valid_39116938, JString, required = true,
                                   default = nil)
  if valid_39116938 != nil:
    section.add "repo", valid_39116938
  var valid_39116939 = path.getOrDefault("hookId")
  valid_39116939 = validateParameter(valid_39116939, JInt, required = true,
                                   default = nil)
  if valid_39116939 != nil:
    section.add "hookId", valid_39116939
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116940 = header.getOrDefault("Accept")
  valid_39116940 = validateParameter(valid_39116940, JString, required = false,
                                   default = nil)
  if valid_39116940 != nil:
    section.add "Accept", valid_39116940
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116941: Call_DeleteReposOwnerRepoHooksHookId_39116934;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a hook.
  ## 
  let valid = call_39116941.validator(path, query, header, formData, body, _)
  let scheme = call_39116941.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116941.url(scheme.get, call_39116941.host, call_39116941.base,
                           call_39116941.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116941, url, valid, _)

proc call*(call_39116942: Call_DeleteReposOwnerRepoHooksHookId_39116934;
          owner: string; repo: string; hookId: int; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoHooksHookId
  ## Delete a hook.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   hookId: int (required)
  ##         : Id of hook.
  var path_39116943 = newJObject()
  var header_39116944 = newJObject()
  add(path_39116943, "owner", newJString(owner))
  add(header_39116944, "Accept", newJString(Accept))
  add(path_39116943, "repo", newJString(repo))
  add(path_39116943, "hookId", newJInt(hookId))
  result = call_39116942.call(path_39116943, nil, header_39116944, nil, nil)

var deleteReposOwnerRepoHooksHookId* = Call_DeleteReposOwnerRepoHooksHookId_39116934(
    name: "deleteReposOwnerRepoHooksHookId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}",
    validator: validate_DeleteReposOwnerRepoHooksHookId_39116935, base: "/",
    url: url_DeleteReposOwnerRepoHooksHookId_39116936, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoHooksHookIdTests_39116958 = ref object of OpenApiRestCall_39115352
proc url_PostReposOwnerRepoHooksHookIdTests_39116960(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/hooks/"),
               (kind: VariableSegment, value: "hookId"),
               (kind: ConstantSegment, value: "/tests")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoHooksHookIdTests_39116959(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Test a push hook.
  ## This will trigger the hook with the latest push to the current repository
  ## if the hook is subscribed to push events. If the hook is not subscribed
  ## to push events, the server will respond with 204 but no test POST will
  ## be generated.
  ## Note: Previously /repos/:owner/:repo/hooks/:id/tes
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   hookId: JInt (required)
  ##         : Id of hook.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116961 = path.getOrDefault("owner")
  valid_39116961 = validateParameter(valid_39116961, JString, required = true,
                                   default = nil)
  if valid_39116961 != nil:
    section.add "owner", valid_39116961
  var valid_39116962 = path.getOrDefault("repo")
  valid_39116962 = validateParameter(valid_39116962, JString, required = true,
                                   default = nil)
  if valid_39116962 != nil:
    section.add "repo", valid_39116962
  var valid_39116963 = path.getOrDefault("hookId")
  valid_39116963 = validateParameter(valid_39116963, JInt, required = true,
                                   default = nil)
  if valid_39116963 != nil:
    section.add "hookId", valid_39116963
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116964 = header.getOrDefault("Accept")
  valid_39116964 = validateParameter(valid_39116964, JString, required = false,
                                   default = nil)
  if valid_39116964 != nil:
    section.add "Accept", valid_39116964
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116965: Call_PostReposOwnerRepoHooksHookIdTests_39116958;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Test a push hook.
  ## This will trigger the hook with the latest push to the current repository
  ## if the hook is subscribed to push events. If the hook is not subscribed
  ## to push events, the server will respond with 204 but no test POST will
  ## be generated.
  ## Note: Previously /repos/:owner/:repo/hooks/:id/tes
  ## 
  ## 
  let valid = call_39116965.validator(path, query, header, formData, body, _)
  let scheme = call_39116965.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116965.url(scheme.get, call_39116965.host, call_39116965.base,
                           call_39116965.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116965, url, valid, _)

proc call*(call_39116966: Call_PostReposOwnerRepoHooksHookIdTests_39116958;
          owner: string; repo: string; hookId: int; Accept: string = ""): Recallable =
  ## postReposOwnerRepoHooksHookIdTests
  ## Test a push hook.
  ## This will trigger the hook with the latest push to the current repository
  ## if the hook is subscribed to push events. If the hook is not subscribed
  ## to push events, the server will respond with 204 but no test POST will
  ## be generated.
  ## Note: Previously /repos/:owner/:repo/hooks/:id/tes
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   hookId: int (required)
  ##         : Id of hook.
  var path_39116967 = newJObject()
  var header_39116968 = newJObject()
  add(path_39116967, "owner", newJString(owner))
  add(header_39116968, "Accept", newJString(Accept))
  add(path_39116967, "repo", newJString(repo))
  add(path_39116967, "hookId", newJInt(hookId))
  result = call_39116966.call(path_39116967, nil, header_39116968, nil, nil)

var postReposOwnerRepoHooksHookIdTests* = Call_PostReposOwnerRepoHooksHookIdTests_39116958(
    name: "postReposOwnerRepoHooksHookIdTests", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}/tests",
    validator: validate_PostReposOwnerRepoHooksHookIdTests_39116959, base: "/",
    url: url_PostReposOwnerRepoHooksHookIdTests_39116960, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoIssues_39116986 = ref object of OpenApiRestCall_39115352
proc url_PostReposOwnerRepoIssues_39116988(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoIssues_39116987(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create an issue.
  ## Any user with pull access to a repository can create an issue.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116989 = path.getOrDefault("owner")
  valid_39116989 = validateParameter(valid_39116989, JString, required = true,
                                   default = nil)
  if valid_39116989 != nil:
    section.add "owner", valid_39116989
  var valid_39116990 = path.getOrDefault("repo")
  valid_39116990 = validateParameter(valid_39116990, JString, required = true,
                                   default = nil)
  if valid_39116990 != nil:
    section.add "repo", valid_39116990
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116991 = header.getOrDefault("Accept")
  valid_39116991 = validateParameter(valid_39116991, JString, required = false,
                                   default = nil)
  if valid_39116991 != nil:
    section.add "Accept", valid_39116991
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39116993: Call_PostReposOwnerRepoIssues_39116986;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create an issue.
  ## Any user with pull access to a repository can create an issue.
  ## 
  ## 
  let valid = call_39116993.validator(path, query, header, formData, body, _)
  let scheme = call_39116993.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116993.url(scheme.get, call_39116993.host, call_39116993.base,
                           call_39116993.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116993, url, valid, _)

proc call*(call_39116994: Call_PostReposOwnerRepoIssues_39116986; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoIssues
  ## Create an issue.
  ## Any user with pull access to a repository can create an issue.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39116995 = newJObject()
  var header_39116996 = newJObject()
  var body_39116997 = newJObject()
  add(path_39116995, "owner", newJString(owner))
  add(header_39116996, "Accept", newJString(Accept))
  if body != nil:
    body_39116997 = body
  add(path_39116995, "repo", newJString(repo))
  result = call_39116994.call(path_39116995, nil, header_39116996, nil, body_39116997)

var postReposOwnerRepoIssues* = Call_PostReposOwnerRepoIssues_39116986(
    name: "postReposOwnerRepoIssues", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues",
    validator: validate_PostReposOwnerRepoIssues_39116987, base: "/",
    url: url_PostReposOwnerRepoIssues_39116988, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssues_39116969 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoIssues_39116971(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssues_39116970(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List issues for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39116972 = path.getOrDefault("owner")
  valid_39116972 = validateParameter(valid_39116972, JString, required = true,
                                   default = nil)
  if valid_39116972 != nil:
    section.add "owner", valid_39116972
  var valid_39116973 = path.getOrDefault("repo")
  valid_39116973 = validateParameter(valid_39116973, JString, required = true,
                                   default = nil)
  if valid_39116973 != nil:
    section.add "repo", valid_39116973
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString (required)
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: JString (required)
  ##   direction: JString (required)
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_39116974 = query.getOrDefault("state")
  valid_39116974 = validateParameter(valid_39116974, JString, required = true,
                                   default = newJString("open"))
  if valid_39116974 != nil:
    section.add "state", valid_39116974
  var valid_39116975 = query.getOrDefault("labels")
  valid_39116975 = validateParameter(valid_39116975, JString, required = true,
                                   default = nil)
  if valid_39116975 != nil:
    section.add "labels", valid_39116975
  var valid_39116976 = query.getOrDefault("sort")
  valid_39116976 = validateParameter(valid_39116976, JString, required = true,
                                   default = newJString("created"))
  if valid_39116976 != nil:
    section.add "sort", valid_39116976
  var valid_39116977 = query.getOrDefault("direction")
  valid_39116977 = validateParameter(valid_39116977, JString, required = true,
                                   default = newJString("desc"))
  if valid_39116977 != nil:
    section.add "direction", valid_39116977
  var valid_39116978 = query.getOrDefault("filter")
  valid_39116978 = validateParameter(valid_39116978, JString, required = true,
                                   default = newJString("all"))
  if valid_39116978 != nil:
    section.add "filter", valid_39116978
  var valid_39116979 = query.getOrDefault("since")
  valid_39116979 = validateParameter(valid_39116979, JString, required = false,
                                   default = nil)
  if valid_39116979 != nil:
    section.add "since", valid_39116979
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39116980 = header.getOrDefault("Accept")
  valid_39116980 = validateParameter(valid_39116980, JString, required = false,
                                   default = nil)
  if valid_39116980 != nil:
    section.add "Accept", valid_39116980
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39116981: Call_GetReposOwnerRepoIssues_39116969;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List issues for a repository.
  ## 
  let valid = call_39116981.validator(path, query, header, formData, body, _)
  let scheme = call_39116981.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39116981.url(scheme.get, call_39116981.host, call_39116981.base,
                           call_39116981.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39116981, url, valid, _)

proc call*(call_39116982: Call_GetReposOwnerRepoIssues_39116969; owner: string;
          repo: string; labels: string; state: string = "open"; Accept: string = "";
          sort: string = "created"; direction: string = "desc"; filter: string = "all";
          since: string = ""): Recallable =
  ## getReposOwnerRepoIssues
  ## List issues for a repository.
  ##   state: string (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: string (required)
  ##   direction: string (required)
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  var path_39116983 = newJObject()
  var query_39116984 = newJObject()
  var header_39116985 = newJObject()
  add(query_39116984, "state", newJString(state))
  add(path_39116983, "owner", newJString(owner))
  add(header_39116985, "Accept", newJString(Accept))
  add(path_39116983, "repo", newJString(repo))
  add(query_39116984, "labels", newJString(labels))
  add(query_39116984, "sort", newJString(sort))
  add(query_39116984, "direction", newJString(direction))
  add(query_39116984, "filter", newJString(filter))
  add(query_39116984, "since", newJString(since))
  result = call_39116982.call(path_39116983, query_39116984, header_39116985, nil, nil)

var getReposOwnerRepoIssues* = Call_GetReposOwnerRepoIssues_39116969(
    name: "getReposOwnerRepoIssues", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues",
    validator: validate_GetReposOwnerRepoIssues_39116970, base: "/",
    url: url_GetReposOwnerRepoIssues_39116971, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesComments_39116998 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoIssuesComments_39117000(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesComments_39116999(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List comments in a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117001 = path.getOrDefault("owner")
  valid_39117001 = validateParameter(valid_39117001, JString, required = true,
                                   default = nil)
  if valid_39117001 != nil:
    section.add "owner", valid_39117001
  var valid_39117002 = path.getOrDefault("repo")
  valid_39117002 = validateParameter(valid_39117002, JString, required = true,
                                   default = nil)
  if valid_39117002 != nil:
    section.add "repo", valid_39117002
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_39117003 = query.getOrDefault("sort")
  valid_39117003 = validateParameter(valid_39117003, JString, required = false,
                                   default = newJString("created"))
  if valid_39117003 != nil:
    section.add "sort", valid_39117003
  var valid_39117004 = query.getOrDefault("direction")
  valid_39117004 = validateParameter(valid_39117004, JString, required = false,
                                   default = nil)
  if valid_39117004 != nil:
    section.add "direction", valid_39117004
  var valid_39117005 = query.getOrDefault("since")
  valid_39117005 = validateParameter(valid_39117005, JString, required = false,
                                   default = nil)
  if valid_39117005 != nil:
    section.add "since", valid_39117005
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117006 = header.getOrDefault("Accept")
  valid_39117006 = validateParameter(valid_39117006, JString, required = false,
                                   default = nil)
  if valid_39117006 != nil:
    section.add "Accept", valid_39117006
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117007: Call_GetReposOwnerRepoIssuesComments_39116998;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List comments in a repository.
  ## 
  let valid = call_39117007.validator(path, query, header, formData, body, _)
  let scheme = call_39117007.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117007.url(scheme.get, call_39117007.host, call_39117007.base,
                           call_39117007.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117007, url, valid, _)

proc call*(call_39117008: Call_GetReposOwnerRepoIssuesComments_39116998;
          owner: string; repo: string; Accept: string = ""; sort: string = "created";
          direction: string = ""; since: string = ""): Recallable =
  ## getReposOwnerRepoIssuesComments
  ## List comments in a repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   sort: string
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var path_39117009 = newJObject()
  var query_39117010 = newJObject()
  var header_39117011 = newJObject()
  add(path_39117009, "owner", newJString(owner))
  add(header_39117011, "Accept", newJString(Accept))
  add(path_39117009, "repo", newJString(repo))
  add(query_39117010, "sort", newJString(sort))
  add(query_39117010, "direction", newJString(direction))
  add(query_39117010, "since", newJString(since))
  result = call_39117008.call(path_39117009, query_39117010, header_39117011, nil, nil)

var getReposOwnerRepoIssuesComments* = Call_GetReposOwnerRepoIssuesComments_39116998(
    name: "getReposOwnerRepoIssuesComments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/comments",
    validator: validate_GetReposOwnerRepoIssuesComments_39116999, base: "/",
    url: url_GetReposOwnerRepoIssuesComments_39117000, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesCommentsCommentId_39117012 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoIssuesCommentsCommentId_39117014(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesCommentsCommentId_39117013(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a single comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : ID of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117015 = path.getOrDefault("owner")
  valid_39117015 = validateParameter(valid_39117015, JString, required = true,
                                   default = nil)
  if valid_39117015 != nil:
    section.add "owner", valid_39117015
  var valid_39117016 = path.getOrDefault("repo")
  valid_39117016 = validateParameter(valid_39117016, JString, required = true,
                                   default = nil)
  if valid_39117016 != nil:
    section.add "repo", valid_39117016
  var valid_39117017 = path.getOrDefault("commentId")
  valid_39117017 = validateParameter(valid_39117017, JInt, required = true,
                                   default = nil)
  if valid_39117017 != nil:
    section.add "commentId", valid_39117017
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117018 = header.getOrDefault("Accept")
  valid_39117018 = validateParameter(valid_39117018, JString, required = false,
                                   default = nil)
  if valid_39117018 != nil:
    section.add "Accept", valid_39117018
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117019: Call_GetReposOwnerRepoIssuesCommentsCommentId_39117012;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single comment.
  ## 
  let valid = call_39117019.validator(path, query, header, formData, body, _)
  let scheme = call_39117019.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117019.url(scheme.get, call_39117019.host, call_39117019.base,
                           call_39117019.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117019, url, valid, _)

proc call*(call_39117020: Call_GetReposOwnerRepoIssuesCommentsCommentId_39117012;
          owner: string; repo: string; commentId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesCommentsCommentId
  ## Get a single comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : ID of comment.
  var path_39117021 = newJObject()
  var header_39117022 = newJObject()
  add(path_39117021, "owner", newJString(owner))
  add(header_39117022, "Accept", newJString(Accept))
  add(path_39117021, "repo", newJString(repo))
  add(path_39117021, "commentId", newJInt(commentId))
  result = call_39117020.call(path_39117021, nil, header_39117022, nil, nil)

var getReposOwnerRepoIssuesCommentsCommentId* = Call_GetReposOwnerRepoIssuesCommentsCommentId_39117012(
    name: "getReposOwnerRepoIssuesCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/comments/{commentId}",
    validator: validate_GetReposOwnerRepoIssuesCommentsCommentId_39117013,
    base: "/", url: url_GetReposOwnerRepoIssuesCommentsCommentId_39117014,
    schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoIssuesCommentsCommentId_39117034 = ref object of OpenApiRestCall_39115352
proc url_PatchReposOwnerRepoIssuesCommentsCommentId_39117036(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoIssuesCommentsCommentId_39117035(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Edit a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : ID of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117037 = path.getOrDefault("owner")
  valid_39117037 = validateParameter(valid_39117037, JString, required = true,
                                   default = nil)
  if valid_39117037 != nil:
    section.add "owner", valid_39117037
  var valid_39117038 = path.getOrDefault("repo")
  valid_39117038 = validateParameter(valid_39117038, JString, required = true,
                                   default = nil)
  if valid_39117038 != nil:
    section.add "repo", valid_39117038
  var valid_39117039 = path.getOrDefault("commentId")
  valid_39117039 = validateParameter(valid_39117039, JInt, required = true,
                                   default = nil)
  if valid_39117039 != nil:
    section.add "commentId", valid_39117039
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117040 = header.getOrDefault("Accept")
  valid_39117040 = validateParameter(valid_39117040, JString, required = false,
                                   default = nil)
  if valid_39117040 != nil:
    section.add "Accept", valid_39117040
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39117042: Call_PatchReposOwnerRepoIssuesCommentsCommentId_39117034;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit a comment.
  ## 
  let valid = call_39117042.validator(path, query, header, formData, body, _)
  let scheme = call_39117042.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117042.url(scheme.get, call_39117042.host, call_39117042.base,
                           call_39117042.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117042, url, valid, _)

proc call*(call_39117043: Call_PatchReposOwnerRepoIssuesCommentsCommentId_39117034;
          owner: string; body: JsonNode; repo: string; commentId: int;
          Accept: string = ""): Recallable =
  ## patchReposOwnerRepoIssuesCommentsCommentId
  ## Edit a comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : ID of comment.
  var path_39117044 = newJObject()
  var header_39117045 = newJObject()
  var body_39117046 = newJObject()
  add(path_39117044, "owner", newJString(owner))
  add(header_39117045, "Accept", newJString(Accept))
  if body != nil:
    body_39117046 = body
  add(path_39117044, "repo", newJString(repo))
  add(path_39117044, "commentId", newJInt(commentId))
  result = call_39117043.call(path_39117044, nil, header_39117045, nil, body_39117046)

var patchReposOwnerRepoIssuesCommentsCommentId* = Call_PatchReposOwnerRepoIssuesCommentsCommentId_39117034(
    name: "patchReposOwnerRepoIssuesCommentsCommentId",
    meth: HttpMethod.HttpPatch, host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/comments/{commentId}",
    validator: validate_PatchReposOwnerRepoIssuesCommentsCommentId_39117035,
    base: "/", url: url_PatchReposOwnerRepoIssuesCommentsCommentId_39117036,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoIssuesCommentsCommentId_39117023 = ref object of OpenApiRestCall_39115352
proc url_DeleteReposOwnerRepoIssuesCommentsCommentId_39117025(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoIssuesCommentsCommentId_39117024(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## Delete a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : ID of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117026 = path.getOrDefault("owner")
  valid_39117026 = validateParameter(valid_39117026, JString, required = true,
                                   default = nil)
  if valid_39117026 != nil:
    section.add "owner", valid_39117026
  var valid_39117027 = path.getOrDefault("repo")
  valid_39117027 = validateParameter(valid_39117027, JString, required = true,
                                   default = nil)
  if valid_39117027 != nil:
    section.add "repo", valid_39117027
  var valid_39117028 = path.getOrDefault("commentId")
  valid_39117028 = validateParameter(valid_39117028, JInt, required = true,
                                   default = nil)
  if valid_39117028 != nil:
    section.add "commentId", valid_39117028
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117029 = header.getOrDefault("Accept")
  valid_39117029 = validateParameter(valid_39117029, JString, required = false,
                                   default = nil)
  if valid_39117029 != nil:
    section.add "Accept", valid_39117029
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117030: Call_DeleteReposOwnerRepoIssuesCommentsCommentId_39117023;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a comment.
  ## 
  let valid = call_39117030.validator(path, query, header, formData, body, _)
  let scheme = call_39117030.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117030.url(scheme.get, call_39117030.host, call_39117030.base,
                           call_39117030.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117030, url, valid, _)

proc call*(call_39117031: Call_DeleteReposOwnerRepoIssuesCommentsCommentId_39117023;
          owner: string; repo: string; commentId: int; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoIssuesCommentsCommentId
  ## Delete a comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : ID of comment.
  var path_39117032 = newJObject()
  var header_39117033 = newJObject()
  add(path_39117032, "owner", newJString(owner))
  add(header_39117033, "Accept", newJString(Accept))
  add(path_39117032, "repo", newJString(repo))
  add(path_39117032, "commentId", newJInt(commentId))
  result = call_39117031.call(path_39117032, nil, header_39117033, nil, nil)

var deleteReposOwnerRepoIssuesCommentsCommentId* = Call_DeleteReposOwnerRepoIssuesCommentsCommentId_39117023(
    name: "deleteReposOwnerRepoIssuesCommentsCommentId",
    meth: HttpMethod.HttpDelete, host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/comments/{commentId}",
    validator: validate_DeleteReposOwnerRepoIssuesCommentsCommentId_39117024,
    base: "/", url: url_DeleteReposOwnerRepoIssuesCommentsCommentId_39117025,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesEvents_39117047 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoIssuesEvents_39117049(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesEvents_39117048(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List issue events for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117050 = path.getOrDefault("owner")
  valid_39117050 = validateParameter(valid_39117050, JString, required = true,
                                   default = nil)
  if valid_39117050 != nil:
    section.add "owner", valid_39117050
  var valid_39117051 = path.getOrDefault("repo")
  valid_39117051 = validateParameter(valid_39117051, JString, required = true,
                                   default = nil)
  if valid_39117051 != nil:
    section.add "repo", valid_39117051
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117052 = header.getOrDefault("Accept")
  valid_39117052 = validateParameter(valid_39117052, JString, required = false,
                                   default = nil)
  if valid_39117052 != nil:
    section.add "Accept", valid_39117052
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117053: Call_GetReposOwnerRepoIssuesEvents_39117047;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List issue events for a repository.
  ## 
  let valid = call_39117053.validator(path, query, header, formData, body, _)
  let scheme = call_39117053.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117053.url(scheme.get, call_39117053.host, call_39117053.base,
                           call_39117053.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117053, url, valid, _)

proc call*(call_39117054: Call_GetReposOwnerRepoIssuesEvents_39117047;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesEvents
  ## List issue events for a repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117055 = newJObject()
  var header_39117056 = newJObject()
  add(path_39117055, "owner", newJString(owner))
  add(header_39117056, "Accept", newJString(Accept))
  add(path_39117055, "repo", newJString(repo))
  result = call_39117054.call(path_39117055, nil, header_39117056, nil, nil)

var getReposOwnerRepoIssuesEvents* = Call_GetReposOwnerRepoIssuesEvents_39117047(
    name: "getReposOwnerRepoIssuesEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/events",
    validator: validate_GetReposOwnerRepoIssuesEvents_39117048, base: "/",
    url: url_GetReposOwnerRepoIssuesEvents_39117049, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesEventsEventId_39117057 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoIssuesEventsEventId_39117059(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "eventId" in path, "`eventId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/events/"),
               (kind: VariableSegment, value: "eventId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesEventsEventId_39117058(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a single event.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   eventId: JInt (required)
  ##          : Id of the event.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117060 = path.getOrDefault("owner")
  valid_39117060 = validateParameter(valid_39117060, JString, required = true,
                                   default = nil)
  if valid_39117060 != nil:
    section.add "owner", valid_39117060
  var valid_39117061 = path.getOrDefault("repo")
  valid_39117061 = validateParameter(valid_39117061, JString, required = true,
                                   default = nil)
  if valid_39117061 != nil:
    section.add "repo", valid_39117061
  var valid_39117062 = path.getOrDefault("eventId")
  valid_39117062 = validateParameter(valid_39117062, JInt, required = true,
                                   default = nil)
  if valid_39117062 != nil:
    section.add "eventId", valid_39117062
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117063 = header.getOrDefault("Accept")
  valid_39117063 = validateParameter(valid_39117063, JString, required = false,
                                   default = nil)
  if valid_39117063 != nil:
    section.add "Accept", valid_39117063
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117064: Call_GetReposOwnerRepoIssuesEventsEventId_39117057;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single event.
  ## 
  let valid = call_39117064.validator(path, query, header, formData, body, _)
  let scheme = call_39117064.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117064.url(scheme.get, call_39117064.host, call_39117064.base,
                           call_39117064.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117064, url, valid, _)

proc call*(call_39117065: Call_GetReposOwnerRepoIssuesEventsEventId_39117057;
          owner: string; repo: string; eventId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesEventsEventId
  ## Get a single event.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   eventId: int (required)
  ##          : Id of the event.
  var path_39117066 = newJObject()
  var header_39117067 = newJObject()
  add(path_39117066, "owner", newJString(owner))
  add(header_39117067, "Accept", newJString(Accept))
  add(path_39117066, "repo", newJString(repo))
  add(path_39117066, "eventId", newJInt(eventId))
  result = call_39117065.call(path_39117066, nil, header_39117067, nil, nil)

var getReposOwnerRepoIssuesEventsEventId* = Call_GetReposOwnerRepoIssuesEventsEventId_39117057(
    name: "getReposOwnerRepoIssuesEventsEventId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/events/{eventId}",
    validator: validate_GetReposOwnerRepoIssuesEventsEventId_39117058, base: "/",
    url: url_GetReposOwnerRepoIssuesEventsEventId_39117059,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumber_39117068 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoIssuesNumber_39117070(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumber_39117069(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a single issue
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117071 = path.getOrDefault("owner")
  valid_39117071 = validateParameter(valid_39117071, JString, required = true,
                                   default = nil)
  if valid_39117071 != nil:
    section.add "owner", valid_39117071
  var valid_39117072 = path.getOrDefault("number")
  valid_39117072 = validateParameter(valid_39117072, JInt, required = true,
                                   default = nil)
  if valid_39117072 != nil:
    section.add "number", valid_39117072
  var valid_39117073 = path.getOrDefault("repo")
  valid_39117073 = validateParameter(valid_39117073, JString, required = true,
                                   default = nil)
  if valid_39117073 != nil:
    section.add "repo", valid_39117073
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117074 = header.getOrDefault("Accept")
  valid_39117074 = validateParameter(valid_39117074, JString, required = false,
                                   default = nil)
  if valid_39117074 != nil:
    section.add "Accept", valid_39117074
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117075: Call_GetReposOwnerRepoIssuesNumber_39117068;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single issue
  ## 
  let valid = call_39117075.validator(path, query, header, formData, body, _)
  let scheme = call_39117075.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117075.url(scheme.get, call_39117075.host, call_39117075.base,
                           call_39117075.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117075, url, valid, _)

proc call*(call_39117076: Call_GetReposOwnerRepoIssuesNumber_39117068;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumber
  ## Get a single issue
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117077 = newJObject()
  var header_39117078 = newJObject()
  add(path_39117077, "owner", newJString(owner))
  add(path_39117077, "number", newJInt(number))
  add(header_39117078, "Accept", newJString(Accept))
  add(path_39117077, "repo", newJString(repo))
  result = call_39117076.call(path_39117077, nil, header_39117078, nil, nil)

var getReposOwnerRepoIssuesNumber* = Call_GetReposOwnerRepoIssuesNumber_39117068(
    name: "getReposOwnerRepoIssuesNumber", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}",
    validator: validate_GetReposOwnerRepoIssuesNumber_39117069, base: "/",
    url: url_GetReposOwnerRepoIssuesNumber_39117070, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoIssuesNumber_39117079 = ref object of OpenApiRestCall_39115352
proc url_PatchReposOwnerRepoIssuesNumber_39117081(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoIssuesNumber_39117080(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Edit an issue.
  ## Issue owners and users with push access can edit an issue.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117082 = path.getOrDefault("owner")
  valid_39117082 = validateParameter(valid_39117082, JString, required = true,
                                   default = nil)
  if valid_39117082 != nil:
    section.add "owner", valid_39117082
  var valid_39117083 = path.getOrDefault("number")
  valid_39117083 = validateParameter(valid_39117083, JInt, required = true,
                                   default = nil)
  if valid_39117083 != nil:
    section.add "number", valid_39117083
  var valid_39117084 = path.getOrDefault("repo")
  valid_39117084 = validateParameter(valid_39117084, JString, required = true,
                                   default = nil)
  if valid_39117084 != nil:
    section.add "repo", valid_39117084
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117085 = header.getOrDefault("Accept")
  valid_39117085 = validateParameter(valid_39117085, JString, required = false,
                                   default = nil)
  if valid_39117085 != nil:
    section.add "Accept", valid_39117085
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39117087: Call_PatchReposOwnerRepoIssuesNumber_39117079;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit an issue.
  ## Issue owners and users with push access can edit an issue.
  ## 
  ## 
  let valid = call_39117087.validator(path, query, header, formData, body, _)
  let scheme = call_39117087.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117087.url(scheme.get, call_39117087.host, call_39117087.base,
                           call_39117087.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117087, url, valid, _)

proc call*(call_39117088: Call_PatchReposOwnerRepoIssuesNumber_39117079;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoIssuesNumber
  ## Edit an issue.
  ## Issue owners and users with push access can edit an issue.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117089 = newJObject()
  var header_39117090 = newJObject()
  var body_39117091 = newJObject()
  add(path_39117089, "owner", newJString(owner))
  add(path_39117089, "number", newJInt(number))
  add(header_39117090, "Accept", newJString(Accept))
  if body != nil:
    body_39117091 = body
  add(path_39117089, "repo", newJString(repo))
  result = call_39117088.call(path_39117089, nil, header_39117090, nil, body_39117091)

var patchReposOwnerRepoIssuesNumber* = Call_PatchReposOwnerRepoIssuesNumber_39117079(
    name: "patchReposOwnerRepoIssuesNumber", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}",
    validator: validate_PatchReposOwnerRepoIssuesNumber_39117080, base: "/",
    url: url_PatchReposOwnerRepoIssuesNumber_39117081, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoIssuesNumberComments_39117103 = ref object of OpenApiRestCall_39115352
proc url_PostReposOwnerRepoIssuesNumberComments_39117105(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoIssuesNumberComments_39117104(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Create a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117106 = path.getOrDefault("owner")
  valid_39117106 = validateParameter(valid_39117106, JString, required = true,
                                   default = nil)
  if valid_39117106 != nil:
    section.add "owner", valid_39117106
  var valid_39117107 = path.getOrDefault("number")
  valid_39117107 = validateParameter(valid_39117107, JInt, required = true,
                                   default = nil)
  if valid_39117107 != nil:
    section.add "number", valid_39117107
  var valid_39117108 = path.getOrDefault("repo")
  valid_39117108 = validateParameter(valid_39117108, JString, required = true,
                                   default = nil)
  if valid_39117108 != nil:
    section.add "repo", valid_39117108
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117109 = header.getOrDefault("Accept")
  valid_39117109 = validateParameter(valid_39117109, JString, required = false,
                                   default = nil)
  if valid_39117109 != nil:
    section.add "Accept", valid_39117109
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39117111: Call_PostReposOwnerRepoIssuesNumberComments_39117103;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a comment.
  ## 
  let valid = call_39117111.validator(path, query, header, formData, body, _)
  let scheme = call_39117111.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117111.url(scheme.get, call_39117111.host, call_39117111.base,
                           call_39117111.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117111, url, valid, _)

proc call*(call_39117112: Call_PostReposOwnerRepoIssuesNumberComments_39117103;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoIssuesNumberComments
  ## Create a comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117113 = newJObject()
  var header_39117114 = newJObject()
  var body_39117115 = newJObject()
  add(path_39117113, "owner", newJString(owner))
  add(path_39117113, "number", newJInt(number))
  add(header_39117114, "Accept", newJString(Accept))
  if body != nil:
    body_39117115 = body
  add(path_39117113, "repo", newJString(repo))
  result = call_39117112.call(path_39117113, nil, header_39117114, nil, body_39117115)

var postReposOwnerRepoIssuesNumberComments* = Call_PostReposOwnerRepoIssuesNumberComments_39117103(
    name: "postReposOwnerRepoIssuesNumberComments", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/{number}/comments",
    validator: validate_PostReposOwnerRepoIssuesNumberComments_39117104,
    base: "/", url: url_PostReposOwnerRepoIssuesNumberComments_39117105,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumberComments_39117092 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoIssuesNumberComments_39117094(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumberComments_39117093(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List comments on an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117095 = path.getOrDefault("owner")
  valid_39117095 = validateParameter(valid_39117095, JString, required = true,
                                   default = nil)
  if valid_39117095 != nil:
    section.add "owner", valid_39117095
  var valid_39117096 = path.getOrDefault("number")
  valid_39117096 = validateParameter(valid_39117096, JInt, required = true,
                                   default = nil)
  if valid_39117096 != nil:
    section.add "number", valid_39117096
  var valid_39117097 = path.getOrDefault("repo")
  valid_39117097 = validateParameter(valid_39117097, JString, required = true,
                                   default = nil)
  if valid_39117097 != nil:
    section.add "repo", valid_39117097
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117098 = header.getOrDefault("Accept")
  valid_39117098 = validateParameter(valid_39117098, JString, required = false,
                                   default = nil)
  if valid_39117098 != nil:
    section.add "Accept", valid_39117098
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117099: Call_GetReposOwnerRepoIssuesNumberComments_39117092;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List comments on an issue.
  ## 
  let valid = call_39117099.validator(path, query, header, formData, body, _)
  let scheme = call_39117099.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117099.url(scheme.get, call_39117099.host, call_39117099.base,
                           call_39117099.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117099, url, valid, _)

proc call*(call_39117100: Call_GetReposOwnerRepoIssuesNumberComments_39117092;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumberComments
  ## List comments on an issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117101 = newJObject()
  var header_39117102 = newJObject()
  add(path_39117101, "owner", newJString(owner))
  add(path_39117101, "number", newJInt(number))
  add(header_39117102, "Accept", newJString(Accept))
  add(path_39117101, "repo", newJString(repo))
  result = call_39117100.call(path_39117101, nil, header_39117102, nil, nil)

var getReposOwnerRepoIssuesNumberComments* = Call_GetReposOwnerRepoIssuesNumberComments_39117092(
    name: "getReposOwnerRepoIssuesNumberComments", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/{number}/comments",
    validator: validate_GetReposOwnerRepoIssuesNumberComments_39117093, base: "/",
    url: url_GetReposOwnerRepoIssuesNumberComments_39117094,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumberEvents_39117116 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoIssuesNumberEvents_39117118(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumberEvents_39117117(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List events for an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117119 = path.getOrDefault("owner")
  valid_39117119 = validateParameter(valid_39117119, JString, required = true,
                                   default = nil)
  if valid_39117119 != nil:
    section.add "owner", valid_39117119
  var valid_39117120 = path.getOrDefault("number")
  valid_39117120 = validateParameter(valid_39117120, JInt, required = true,
                                   default = nil)
  if valid_39117120 != nil:
    section.add "number", valid_39117120
  var valid_39117121 = path.getOrDefault("repo")
  valid_39117121 = validateParameter(valid_39117121, JString, required = true,
                                   default = nil)
  if valid_39117121 != nil:
    section.add "repo", valid_39117121
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117122 = header.getOrDefault("Accept")
  valid_39117122 = validateParameter(valid_39117122, JString, required = false,
                                   default = nil)
  if valid_39117122 != nil:
    section.add "Accept", valid_39117122
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117123: Call_GetReposOwnerRepoIssuesNumberEvents_39117116;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List events for an issue.
  ## 
  let valid = call_39117123.validator(path, query, header, formData, body, _)
  let scheme = call_39117123.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117123.url(scheme.get, call_39117123.host, call_39117123.base,
                           call_39117123.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117123, url, valid, _)

proc call*(call_39117124: Call_GetReposOwnerRepoIssuesNumberEvents_39117116;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumberEvents
  ## List events for an issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117125 = newJObject()
  var header_39117126 = newJObject()
  add(path_39117125, "owner", newJString(owner))
  add(path_39117125, "number", newJInt(number))
  add(header_39117126, "Accept", newJString(Accept))
  add(path_39117125, "repo", newJString(repo))
  result = call_39117124.call(path_39117125, nil, header_39117126, nil, nil)

var getReposOwnerRepoIssuesNumberEvents* = Call_GetReposOwnerRepoIssuesNumberEvents_39117116(
    name: "getReposOwnerRepoIssuesNumberEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/events",
    validator: validate_GetReposOwnerRepoIssuesNumberEvents_39117117, base: "/",
    url: url_GetReposOwnerRepoIssuesNumberEvents_39117118, schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoIssuesNumberLabels_39117138 = ref object of OpenApiRestCall_39115352
proc url_PutReposOwnerRepoIssuesNumberLabels_39117140(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoIssuesNumberLabels_39117139(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Replace all labels for an issue.
  ## Sending an empty array ([]) will remove all Labels from the Issue.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117141 = path.getOrDefault("owner")
  valid_39117141 = validateParameter(valid_39117141, JString, required = true,
                                   default = nil)
  if valid_39117141 != nil:
    section.add "owner", valid_39117141
  var valid_39117142 = path.getOrDefault("number")
  valid_39117142 = validateParameter(valid_39117142, JInt, required = true,
                                   default = nil)
  if valid_39117142 != nil:
    section.add "number", valid_39117142
  var valid_39117143 = path.getOrDefault("repo")
  valid_39117143 = validateParameter(valid_39117143, JString, required = true,
                                   default = nil)
  if valid_39117143 != nil:
    section.add "repo", valid_39117143
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117144 = header.getOrDefault("Accept")
  valid_39117144 = validateParameter(valid_39117144, JString, required = false,
                                   default = nil)
  if valid_39117144 != nil:
    section.add "Accept", valid_39117144
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39117146: Call_PutReposOwnerRepoIssuesNumberLabels_39117138;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Replace all labels for an issue.
  ## Sending an empty array ([]) will remove all Labels from the Issue.
  ## 
  ## 
  let valid = call_39117146.validator(path, query, header, formData, body, _)
  let scheme = call_39117146.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117146.url(scheme.get, call_39117146.host, call_39117146.base,
                           call_39117146.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117146, url, valid, _)

proc call*(call_39117147: Call_PutReposOwnerRepoIssuesNumberLabels_39117138;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoIssuesNumberLabels
  ## Replace all labels for an issue.
  ## Sending an empty array ([]) will remove all Labels from the Issue.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117148 = newJObject()
  var header_39117149 = newJObject()
  var body_39117150 = newJObject()
  add(path_39117148, "owner", newJString(owner))
  add(path_39117148, "number", newJInt(number))
  add(header_39117149, "Accept", newJString(Accept))
  if body != nil:
    body_39117150 = body
  add(path_39117148, "repo", newJString(repo))
  result = call_39117147.call(path_39117148, nil, header_39117149, nil, body_39117150)

var putReposOwnerRepoIssuesNumberLabels* = Call_PutReposOwnerRepoIssuesNumberLabels_39117138(
    name: "putReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_PutReposOwnerRepoIssuesNumberLabels_39117139, base: "/",
    url: url_PutReposOwnerRepoIssuesNumberLabels_39117140, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoIssuesNumberLabels_39117151 = ref object of OpenApiRestCall_39115352
proc url_PostReposOwnerRepoIssuesNumberLabels_39117153(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoIssuesNumberLabels_39117152(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Add labels to an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117154 = path.getOrDefault("owner")
  valid_39117154 = validateParameter(valid_39117154, JString, required = true,
                                   default = nil)
  if valid_39117154 != nil:
    section.add "owner", valid_39117154
  var valid_39117155 = path.getOrDefault("number")
  valid_39117155 = validateParameter(valid_39117155, JInt, required = true,
                                   default = nil)
  if valid_39117155 != nil:
    section.add "number", valid_39117155
  var valid_39117156 = path.getOrDefault("repo")
  valid_39117156 = validateParameter(valid_39117156, JString, required = true,
                                   default = nil)
  if valid_39117156 != nil:
    section.add "repo", valid_39117156
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117157 = header.getOrDefault("Accept")
  valid_39117157 = validateParameter(valid_39117157, JString, required = false,
                                   default = nil)
  if valid_39117157 != nil:
    section.add "Accept", valid_39117157
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39117159: Call_PostReposOwnerRepoIssuesNumberLabels_39117151;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Add labels to an issue.
  ## 
  let valid = call_39117159.validator(path, query, header, formData, body, _)
  let scheme = call_39117159.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117159.url(scheme.get, call_39117159.host, call_39117159.base,
                           call_39117159.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117159, url, valid, _)

proc call*(call_39117160: Call_PostReposOwnerRepoIssuesNumberLabels_39117151;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoIssuesNumberLabels
  ## Add labels to an issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117161 = newJObject()
  var header_39117162 = newJObject()
  var body_39117163 = newJObject()
  add(path_39117161, "owner", newJString(owner))
  add(path_39117161, "number", newJInt(number))
  add(header_39117162, "Accept", newJString(Accept))
  if body != nil:
    body_39117163 = body
  add(path_39117161, "repo", newJString(repo))
  result = call_39117160.call(path_39117161, nil, header_39117162, nil, body_39117163)

var postReposOwnerRepoIssuesNumberLabels* = Call_PostReposOwnerRepoIssuesNumberLabels_39117151(
    name: "postReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_PostReposOwnerRepoIssuesNumberLabels_39117152, base: "/",
    url: url_PostReposOwnerRepoIssuesNumberLabels_39117153,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumberLabels_39117127 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoIssuesNumberLabels_39117129(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumberLabels_39117128(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List labels on an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117130 = path.getOrDefault("owner")
  valid_39117130 = validateParameter(valid_39117130, JString, required = true,
                                   default = nil)
  if valid_39117130 != nil:
    section.add "owner", valid_39117130
  var valid_39117131 = path.getOrDefault("number")
  valid_39117131 = validateParameter(valid_39117131, JInt, required = true,
                                   default = nil)
  if valid_39117131 != nil:
    section.add "number", valid_39117131
  var valid_39117132 = path.getOrDefault("repo")
  valid_39117132 = validateParameter(valid_39117132, JString, required = true,
                                   default = nil)
  if valid_39117132 != nil:
    section.add "repo", valid_39117132
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117133 = header.getOrDefault("Accept")
  valid_39117133 = validateParameter(valid_39117133, JString, required = false,
                                   default = nil)
  if valid_39117133 != nil:
    section.add "Accept", valid_39117133
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117134: Call_GetReposOwnerRepoIssuesNumberLabels_39117127;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List labels on an issue.
  ## 
  let valid = call_39117134.validator(path, query, header, formData, body, _)
  let scheme = call_39117134.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117134.url(scheme.get, call_39117134.host, call_39117134.base,
                           call_39117134.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117134, url, valid, _)

proc call*(call_39117135: Call_GetReposOwnerRepoIssuesNumberLabels_39117127;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumberLabels
  ## List labels on an issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117136 = newJObject()
  var header_39117137 = newJObject()
  add(path_39117136, "owner", newJString(owner))
  add(path_39117136, "number", newJInt(number))
  add(header_39117137, "Accept", newJString(Accept))
  add(path_39117136, "repo", newJString(repo))
  result = call_39117135.call(path_39117136, nil, header_39117137, nil, nil)

var getReposOwnerRepoIssuesNumberLabels* = Call_GetReposOwnerRepoIssuesNumberLabels_39117127(
    name: "getReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_GetReposOwnerRepoIssuesNumberLabels_39117128, base: "/",
    url: url_GetReposOwnerRepoIssuesNumberLabels_39117129, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoIssuesNumberLabels_39117164 = ref object of OpenApiRestCall_39115352
proc url_DeleteReposOwnerRepoIssuesNumberLabels_39117166(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoIssuesNumberLabels_39117165(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Remove all labels from an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117167 = path.getOrDefault("owner")
  valid_39117167 = validateParameter(valid_39117167, JString, required = true,
                                   default = nil)
  if valid_39117167 != nil:
    section.add "owner", valid_39117167
  var valid_39117168 = path.getOrDefault("number")
  valid_39117168 = validateParameter(valid_39117168, JInt, required = true,
                                   default = nil)
  if valid_39117168 != nil:
    section.add "number", valid_39117168
  var valid_39117169 = path.getOrDefault("repo")
  valid_39117169 = validateParameter(valid_39117169, JString, required = true,
                                   default = nil)
  if valid_39117169 != nil:
    section.add "repo", valid_39117169
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117170 = header.getOrDefault("Accept")
  valid_39117170 = validateParameter(valid_39117170, JString, required = false,
                                   default = nil)
  if valid_39117170 != nil:
    section.add "Accept", valid_39117170
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117171: Call_DeleteReposOwnerRepoIssuesNumberLabels_39117164;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Remove all labels from an issue.
  ## 
  let valid = call_39117171.validator(path, query, header, formData, body, _)
  let scheme = call_39117171.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117171.url(scheme.get, call_39117171.host, call_39117171.base,
                           call_39117171.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117171, url, valid, _)

proc call*(call_39117172: Call_DeleteReposOwnerRepoIssuesNumberLabels_39117164;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoIssuesNumberLabels
  ## Remove all labels from an issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117173 = newJObject()
  var header_39117174 = newJObject()
  add(path_39117173, "owner", newJString(owner))
  add(path_39117173, "number", newJInt(number))
  add(header_39117174, "Accept", newJString(Accept))
  add(path_39117173, "repo", newJString(repo))
  result = call_39117172.call(path_39117173, nil, header_39117174, nil, nil)

var deleteReposOwnerRepoIssuesNumberLabels* = Call_DeleteReposOwnerRepoIssuesNumberLabels_39117164(
    name: "deleteReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_DeleteReposOwnerRepoIssuesNumberLabels_39117165,
    base: "/", url: url_DeleteReposOwnerRepoIssuesNumberLabels_39117166,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoIssuesNumberLabelsName_39117175 = ref object of OpenApiRestCall_39115352
proc url_DeleteReposOwnerRepoIssuesNumberLabelsName_39117177(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/issues/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoIssuesNumberLabelsName_39117176(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Remove a label from an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   name: JString (required)
  ##       : Name of the label.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117178 = path.getOrDefault("owner")
  valid_39117178 = validateParameter(valid_39117178, JString, required = true,
                                   default = nil)
  if valid_39117178 != nil:
    section.add "owner", valid_39117178
  var valid_39117179 = path.getOrDefault("number")
  valid_39117179 = validateParameter(valid_39117179, JInt, required = true,
                                   default = nil)
  if valid_39117179 != nil:
    section.add "number", valid_39117179
  var valid_39117180 = path.getOrDefault("name")
  valid_39117180 = validateParameter(valid_39117180, JString, required = true,
                                   default = nil)
  if valid_39117180 != nil:
    section.add "name", valid_39117180
  var valid_39117181 = path.getOrDefault("repo")
  valid_39117181 = validateParameter(valid_39117181, JString, required = true,
                                   default = nil)
  if valid_39117181 != nil:
    section.add "repo", valid_39117181
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117182 = header.getOrDefault("Accept")
  valid_39117182 = validateParameter(valid_39117182, JString, required = false,
                                   default = nil)
  if valid_39117182 != nil:
    section.add "Accept", valid_39117182
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117183: Call_DeleteReposOwnerRepoIssuesNumberLabelsName_39117175;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Remove a label from an issue.
  ## 
  let valid = call_39117183.validator(path, query, header, formData, body, _)
  let scheme = call_39117183.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117183.url(scheme.get, call_39117183.host, call_39117183.base,
                           call_39117183.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117183, url, valid, _)

proc call*(call_39117184: Call_DeleteReposOwnerRepoIssuesNumberLabelsName_39117175;
          owner: string; number: int; name: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoIssuesNumberLabelsName
  ## Remove a label from an issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   name: string (required)
  ##       : Name of the label.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117185 = newJObject()
  var header_39117186 = newJObject()
  add(path_39117185, "owner", newJString(owner))
  add(path_39117185, "number", newJInt(number))
  add(path_39117185, "name", newJString(name))
  add(header_39117186, "Accept", newJString(Accept))
  add(path_39117185, "repo", newJString(repo))
  result = call_39117184.call(path_39117185, nil, header_39117186, nil, nil)

var deleteReposOwnerRepoIssuesNumberLabelsName* = Call_DeleteReposOwnerRepoIssuesNumberLabelsName_39117175(
    name: "deleteReposOwnerRepoIssuesNumberLabelsName",
    meth: HttpMethod.HttpDelete, host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/{number}/labels/{name}",
    validator: validate_DeleteReposOwnerRepoIssuesNumberLabelsName_39117176,
    base: "/", url: url_DeleteReposOwnerRepoIssuesNumberLabelsName_39117177,
    schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoKeys_39117197 = ref object of OpenApiRestCall_39115352
proc url_PostReposOwnerRepoKeys_39117199(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/keys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoKeys_39117198(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a key.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117200 = path.getOrDefault("owner")
  valid_39117200 = validateParameter(valid_39117200, JString, required = true,
                                   default = nil)
  if valid_39117200 != nil:
    section.add "owner", valid_39117200
  var valid_39117201 = path.getOrDefault("repo")
  valid_39117201 = validateParameter(valid_39117201, JString, required = true,
                                   default = nil)
  if valid_39117201 != nil:
    section.add "repo", valid_39117201
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117202 = header.getOrDefault("Accept")
  valid_39117202 = validateParameter(valid_39117202, JString, required = false,
                                   default = nil)
  if valid_39117202 != nil:
    section.add "Accept", valid_39117202
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39117204: Call_PostReposOwnerRepoKeys_39117197;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a key.
  ## 
  let valid = call_39117204.validator(path, query, header, formData, body, _)
  let scheme = call_39117204.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117204.url(scheme.get, call_39117204.host, call_39117204.base,
                           call_39117204.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117204, url, valid, _)

proc call*(call_39117205: Call_PostReposOwnerRepoKeys_39117197; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoKeys
  ## Create a key.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117206 = newJObject()
  var header_39117207 = newJObject()
  var body_39117208 = newJObject()
  add(path_39117206, "owner", newJString(owner))
  add(header_39117207, "Accept", newJString(Accept))
  if body != nil:
    body_39117208 = body
  add(path_39117206, "repo", newJString(repo))
  result = call_39117205.call(path_39117206, nil, header_39117207, nil, body_39117208)

var postReposOwnerRepoKeys* = Call_PostReposOwnerRepoKeys_39117197(
    name: "postReposOwnerRepoKeys", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/keys",
    validator: validate_PostReposOwnerRepoKeys_39117198, base: "/",
    url: url_PostReposOwnerRepoKeys_39117199, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoKeys_39117187 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoKeys_39117189(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/keys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoKeys_39117188(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get list of keys.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117190 = path.getOrDefault("owner")
  valid_39117190 = validateParameter(valid_39117190, JString, required = true,
                                   default = nil)
  if valid_39117190 != nil:
    section.add "owner", valid_39117190
  var valid_39117191 = path.getOrDefault("repo")
  valid_39117191 = validateParameter(valid_39117191, JString, required = true,
                                   default = nil)
  if valid_39117191 != nil:
    section.add "repo", valid_39117191
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117192 = header.getOrDefault("Accept")
  valid_39117192 = validateParameter(valid_39117192, JString, required = false,
                                   default = nil)
  if valid_39117192 != nil:
    section.add "Accept", valid_39117192
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117193: Call_GetReposOwnerRepoKeys_39117187;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get list of keys.
  ## 
  let valid = call_39117193.validator(path, query, header, formData, body, _)
  let scheme = call_39117193.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117193.url(scheme.get, call_39117193.host, call_39117193.base,
                           call_39117193.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117193, url, valid, _)

proc call*(call_39117194: Call_GetReposOwnerRepoKeys_39117187; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoKeys
  ## Get list of keys.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117195 = newJObject()
  var header_39117196 = newJObject()
  add(path_39117195, "owner", newJString(owner))
  add(header_39117196, "Accept", newJString(Accept))
  add(path_39117195, "repo", newJString(repo))
  result = call_39117194.call(path_39117195, nil, header_39117196, nil, nil)

var getReposOwnerRepoKeys* = Call_GetReposOwnerRepoKeys_39117187(
    name: "getReposOwnerRepoKeys", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/repos/{owner}/{repo}/keys",
    validator: validate_GetReposOwnerRepoKeys_39117188, base: "/",
    url: url_GetReposOwnerRepoKeys_39117189, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoKeysKeyId_39117209 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoKeysKeyId_39117211(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/keys/"),
               (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoKeysKeyId_39117210(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get a key
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   keyId: JInt (required)
  ##        : Id of key.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117212 = path.getOrDefault("owner")
  valid_39117212 = validateParameter(valid_39117212, JString, required = true,
                                   default = nil)
  if valid_39117212 != nil:
    section.add "owner", valid_39117212
  var valid_39117213 = path.getOrDefault("keyId")
  valid_39117213 = validateParameter(valid_39117213, JInt, required = true,
                                   default = nil)
  if valid_39117213 != nil:
    section.add "keyId", valid_39117213
  var valid_39117214 = path.getOrDefault("repo")
  valid_39117214 = validateParameter(valid_39117214, JString, required = true,
                                   default = nil)
  if valid_39117214 != nil:
    section.add "repo", valid_39117214
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117215 = header.getOrDefault("Accept")
  valid_39117215 = validateParameter(valid_39117215, JString, required = false,
                                   default = nil)
  if valid_39117215 != nil:
    section.add "Accept", valid_39117215
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117216: Call_GetReposOwnerRepoKeysKeyId_39117209;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a key
  ## 
  let valid = call_39117216.validator(path, query, header, formData, body, _)
  let scheme = call_39117216.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117216.url(scheme.get, call_39117216.host, call_39117216.base,
                           call_39117216.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117216, url, valid, _)

proc call*(call_39117217: Call_GetReposOwnerRepoKeysKeyId_39117209; owner: string;
          keyId: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoKeysKeyId
  ## Get a key
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   keyId: int (required)
  ##        : Id of key.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117218 = newJObject()
  var header_39117219 = newJObject()
  add(path_39117218, "owner", newJString(owner))
  add(header_39117219, "Accept", newJString(Accept))
  add(path_39117218, "keyId", newJInt(keyId))
  add(path_39117218, "repo", newJString(repo))
  result = call_39117217.call(path_39117218, nil, header_39117219, nil, nil)

var getReposOwnerRepoKeysKeyId* = Call_GetReposOwnerRepoKeysKeyId_39117209(
    name: "getReposOwnerRepoKeysKeyId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/keys/{keyId}",
    validator: validate_GetReposOwnerRepoKeysKeyId_39117210, base: "/",
    url: url_GetReposOwnerRepoKeysKeyId_39117211, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoKeysKeyId_39117220 = ref object of OpenApiRestCall_39115352
proc url_DeleteReposOwnerRepoKeysKeyId_39117222(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/keys/"),
               (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoKeysKeyId_39117221(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a key.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   keyId: JInt (required)
  ##        : Id of key.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117223 = path.getOrDefault("owner")
  valid_39117223 = validateParameter(valid_39117223, JString, required = true,
                                   default = nil)
  if valid_39117223 != nil:
    section.add "owner", valid_39117223
  var valid_39117224 = path.getOrDefault("keyId")
  valid_39117224 = validateParameter(valid_39117224, JInt, required = true,
                                   default = nil)
  if valid_39117224 != nil:
    section.add "keyId", valid_39117224
  var valid_39117225 = path.getOrDefault("repo")
  valid_39117225 = validateParameter(valid_39117225, JString, required = true,
                                   default = nil)
  if valid_39117225 != nil:
    section.add "repo", valid_39117225
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117226 = header.getOrDefault("Accept")
  valid_39117226 = validateParameter(valid_39117226, JString, required = false,
                                   default = nil)
  if valid_39117226 != nil:
    section.add "Accept", valid_39117226
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117227: Call_DeleteReposOwnerRepoKeysKeyId_39117220;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a key.
  ## 
  let valid = call_39117227.validator(path, query, header, formData, body, _)
  let scheme = call_39117227.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117227.url(scheme.get, call_39117227.host, call_39117227.base,
                           call_39117227.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117227, url, valid, _)

proc call*(call_39117228: Call_DeleteReposOwnerRepoKeysKeyId_39117220;
          owner: string; keyId: int; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoKeysKeyId
  ## Delete a key.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   keyId: int (required)
  ##        : Id of key.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117229 = newJObject()
  var header_39117230 = newJObject()
  add(path_39117229, "owner", newJString(owner))
  add(header_39117230, "Accept", newJString(Accept))
  add(path_39117229, "keyId", newJInt(keyId))
  add(path_39117229, "repo", newJString(repo))
  result = call_39117228.call(path_39117229, nil, header_39117230, nil, nil)

var deleteReposOwnerRepoKeysKeyId* = Call_DeleteReposOwnerRepoKeysKeyId_39117220(
    name: "deleteReposOwnerRepoKeysKeyId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/keys/{keyId}",
    validator: validate_DeleteReposOwnerRepoKeysKeyId_39117221, base: "/",
    url: url_DeleteReposOwnerRepoKeysKeyId_39117222, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoLabels_39117241 = ref object of OpenApiRestCall_39115352
proc url_PostReposOwnerRepoLabels_39117243(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoLabels_39117242(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117244 = path.getOrDefault("owner")
  valid_39117244 = validateParameter(valid_39117244, JString, required = true,
                                   default = nil)
  if valid_39117244 != nil:
    section.add "owner", valid_39117244
  var valid_39117245 = path.getOrDefault("repo")
  valid_39117245 = validateParameter(valid_39117245, JString, required = true,
                                   default = nil)
  if valid_39117245 != nil:
    section.add "repo", valid_39117245
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117246 = header.getOrDefault("Accept")
  valid_39117246 = validateParameter(valid_39117246, JString, required = false,
                                   default = nil)
  if valid_39117246 != nil:
    section.add "Accept", valid_39117246
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39117248: Call_PostReposOwnerRepoLabels_39117241;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a label.
  ## 
  let valid = call_39117248.validator(path, query, header, formData, body, _)
  let scheme = call_39117248.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117248.url(scheme.get, call_39117248.host, call_39117248.base,
                           call_39117248.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117248, url, valid, _)

proc call*(call_39117249: Call_PostReposOwnerRepoLabels_39117241; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoLabels
  ## Create a label.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117250 = newJObject()
  var header_39117251 = newJObject()
  var body_39117252 = newJObject()
  add(path_39117250, "owner", newJString(owner))
  add(header_39117251, "Accept", newJString(Accept))
  if body != nil:
    body_39117252 = body
  add(path_39117250, "repo", newJString(repo))
  result = call_39117249.call(path_39117250, nil, header_39117251, nil, body_39117252)

var postReposOwnerRepoLabels* = Call_PostReposOwnerRepoLabels_39117241(
    name: "postReposOwnerRepoLabels", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels",
    validator: validate_PostReposOwnerRepoLabels_39117242, base: "/",
    url: url_PostReposOwnerRepoLabels_39117243, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoLabels_39117231 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoLabels_39117233(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoLabels_39117232(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List all labels for this repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117234 = path.getOrDefault("owner")
  valid_39117234 = validateParameter(valid_39117234, JString, required = true,
                                   default = nil)
  if valid_39117234 != nil:
    section.add "owner", valid_39117234
  var valid_39117235 = path.getOrDefault("repo")
  valid_39117235 = validateParameter(valid_39117235, JString, required = true,
                                   default = nil)
  if valid_39117235 != nil:
    section.add "repo", valid_39117235
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117236 = header.getOrDefault("Accept")
  valid_39117236 = validateParameter(valid_39117236, JString, required = false,
                                   default = nil)
  if valid_39117236 != nil:
    section.add "Accept", valid_39117236
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117237: Call_GetReposOwnerRepoLabels_39117231;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List all labels for this repository.
  ## 
  let valid = call_39117237.validator(path, query, header, formData, body, _)
  let scheme = call_39117237.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117237.url(scheme.get, call_39117237.host, call_39117237.base,
                           call_39117237.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117237, url, valid, _)

proc call*(call_39117238: Call_GetReposOwnerRepoLabels_39117231; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoLabels
  ## List all labels for this repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117239 = newJObject()
  var header_39117240 = newJObject()
  add(path_39117239, "owner", newJString(owner))
  add(header_39117240, "Accept", newJString(Accept))
  add(path_39117239, "repo", newJString(repo))
  result = call_39117238.call(path_39117239, nil, header_39117240, nil, nil)

var getReposOwnerRepoLabels* = Call_GetReposOwnerRepoLabels_39117231(
    name: "getReposOwnerRepoLabels", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels",
    validator: validate_GetReposOwnerRepoLabels_39117232, base: "/",
    url: url_GetReposOwnerRepoLabels_39117233, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoLabelsName_39117253 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoLabelsName_39117255(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoLabelsName_39117254(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get a single label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   name: JString (required)
  ##       : Name of the label.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117256 = path.getOrDefault("owner")
  valid_39117256 = validateParameter(valid_39117256, JString, required = true,
                                   default = nil)
  if valid_39117256 != nil:
    section.add "owner", valid_39117256
  var valid_39117257 = path.getOrDefault("name")
  valid_39117257 = validateParameter(valid_39117257, JString, required = true,
                                   default = nil)
  if valid_39117257 != nil:
    section.add "name", valid_39117257
  var valid_39117258 = path.getOrDefault("repo")
  valid_39117258 = validateParameter(valid_39117258, JString, required = true,
                                   default = nil)
  if valid_39117258 != nil:
    section.add "repo", valid_39117258
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117259 = header.getOrDefault("Accept")
  valid_39117259 = validateParameter(valid_39117259, JString, required = false,
                                   default = nil)
  if valid_39117259 != nil:
    section.add "Accept", valid_39117259
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117260: Call_GetReposOwnerRepoLabelsName_39117253;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single label.
  ## 
  let valid = call_39117260.validator(path, query, header, formData, body, _)
  let scheme = call_39117260.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117260.url(scheme.get, call_39117260.host, call_39117260.base,
                           call_39117260.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117260, url, valid, _)

proc call*(call_39117261: Call_GetReposOwnerRepoLabelsName_39117253; owner: string;
          name: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoLabelsName
  ## Get a single label.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   name: string (required)
  ##       : Name of the label.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117262 = newJObject()
  var header_39117263 = newJObject()
  add(path_39117262, "owner", newJString(owner))
  add(path_39117262, "name", newJString(name))
  add(header_39117263, "Accept", newJString(Accept))
  add(path_39117262, "repo", newJString(repo))
  result = call_39117261.call(path_39117262, nil, header_39117263, nil, nil)

var getReposOwnerRepoLabelsName* = Call_GetReposOwnerRepoLabelsName_39117253(
    name: "getReposOwnerRepoLabelsName", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels/{name}",
    validator: validate_GetReposOwnerRepoLabelsName_39117254, base: "/",
    url: url_GetReposOwnerRepoLabelsName_39117255, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoLabelsName_39117275 = ref object of OpenApiRestCall_39115352
proc url_PatchReposOwnerRepoLabelsName_39117277(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoLabelsName_39117276(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Update a label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   name: JString (required)
  ##       : Name of the label.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117278 = path.getOrDefault("owner")
  valid_39117278 = validateParameter(valid_39117278, JString, required = true,
                                   default = nil)
  if valid_39117278 != nil:
    section.add "owner", valid_39117278
  var valid_39117279 = path.getOrDefault("name")
  valid_39117279 = validateParameter(valid_39117279, JString, required = true,
                                   default = nil)
  if valid_39117279 != nil:
    section.add "name", valid_39117279
  var valid_39117280 = path.getOrDefault("repo")
  valid_39117280 = validateParameter(valid_39117280, JString, required = true,
                                   default = nil)
  if valid_39117280 != nil:
    section.add "repo", valid_39117280
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117281 = header.getOrDefault("Accept")
  valid_39117281 = validateParameter(valid_39117281, JString, required = false,
                                   default = nil)
  if valid_39117281 != nil:
    section.add "Accept", valid_39117281
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39117283: Call_PatchReposOwnerRepoLabelsName_39117275;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Update a label.
  ## 
  let valid = call_39117283.validator(path, query, header, formData, body, _)
  let scheme = call_39117283.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117283.url(scheme.get, call_39117283.host, call_39117283.base,
                           call_39117283.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117283, url, valid, _)

proc call*(call_39117284: Call_PatchReposOwnerRepoLabelsName_39117275;
          owner: string; name: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoLabelsName
  ## Update a label.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   name: string (required)
  ##       : Name of the label.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117285 = newJObject()
  var header_39117286 = newJObject()
  var body_39117287 = newJObject()
  add(path_39117285, "owner", newJString(owner))
  add(path_39117285, "name", newJString(name))
  add(header_39117286, "Accept", newJString(Accept))
  if body != nil:
    body_39117287 = body
  add(path_39117285, "repo", newJString(repo))
  result = call_39117284.call(path_39117285, nil, header_39117286, nil, body_39117287)

var patchReposOwnerRepoLabelsName* = Call_PatchReposOwnerRepoLabelsName_39117275(
    name: "patchReposOwnerRepoLabelsName", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels/{name}",
    validator: validate_PatchReposOwnerRepoLabelsName_39117276, base: "/",
    url: url_PatchReposOwnerRepoLabelsName_39117277, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoLabelsName_39117264 = ref object of OpenApiRestCall_39115352
proc url_DeleteReposOwnerRepoLabelsName_39117266(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/labels/"),
               (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoLabelsName_39117265(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   name: JString (required)
  ##       : Name of the label.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117267 = path.getOrDefault("owner")
  valid_39117267 = validateParameter(valid_39117267, JString, required = true,
                                   default = nil)
  if valid_39117267 != nil:
    section.add "owner", valid_39117267
  var valid_39117268 = path.getOrDefault("name")
  valid_39117268 = validateParameter(valid_39117268, JString, required = true,
                                   default = nil)
  if valid_39117268 != nil:
    section.add "name", valid_39117268
  var valid_39117269 = path.getOrDefault("repo")
  valid_39117269 = validateParameter(valid_39117269, JString, required = true,
                                   default = nil)
  if valid_39117269 != nil:
    section.add "repo", valid_39117269
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117270 = header.getOrDefault("Accept")
  valid_39117270 = validateParameter(valid_39117270, JString, required = false,
                                   default = nil)
  if valid_39117270 != nil:
    section.add "Accept", valid_39117270
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117271: Call_DeleteReposOwnerRepoLabelsName_39117264;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a label.
  ## 
  let valid = call_39117271.validator(path, query, header, formData, body, _)
  let scheme = call_39117271.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117271.url(scheme.get, call_39117271.host, call_39117271.base,
                           call_39117271.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117271, url, valid, _)

proc call*(call_39117272: Call_DeleteReposOwnerRepoLabelsName_39117264;
          owner: string; name: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoLabelsName
  ## Delete a label.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   name: string (required)
  ##       : Name of the label.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117273 = newJObject()
  var header_39117274 = newJObject()
  add(path_39117273, "owner", newJString(owner))
  add(path_39117273, "name", newJString(name))
  add(header_39117274, "Accept", newJString(Accept))
  add(path_39117273, "repo", newJString(repo))
  result = call_39117272.call(path_39117273, nil, header_39117274, nil, nil)

var deleteReposOwnerRepoLabelsName* = Call_DeleteReposOwnerRepoLabelsName_39117264(
    name: "deleteReposOwnerRepoLabelsName", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels/{name}",
    validator: validate_DeleteReposOwnerRepoLabelsName_39117265, base: "/",
    url: url_DeleteReposOwnerRepoLabelsName_39117266, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoLanguages_39117288 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoLanguages_39117290(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/languages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoLanguages_39117289(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List languages.
  ## List languages for the specified repository. The value on the right of a
  ## language is the number of bytes of code written in that language.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117291 = path.getOrDefault("owner")
  valid_39117291 = validateParameter(valid_39117291, JString, required = true,
                                   default = nil)
  if valid_39117291 != nil:
    section.add "owner", valid_39117291
  var valid_39117292 = path.getOrDefault("repo")
  valid_39117292 = validateParameter(valid_39117292, JString, required = true,
                                   default = nil)
  if valid_39117292 != nil:
    section.add "repo", valid_39117292
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117293 = header.getOrDefault("Accept")
  valid_39117293 = validateParameter(valid_39117293, JString, required = false,
                                   default = nil)
  if valid_39117293 != nil:
    section.add "Accept", valid_39117293
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117294: Call_GetReposOwnerRepoLanguages_39117288;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List languages.
  ## List languages for the specified repository. The value on the right of a
  ## language is the number of bytes of code written in that language.
  ## 
  ## 
  let valid = call_39117294.validator(path, query, header, formData, body, _)
  let scheme = call_39117294.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117294.url(scheme.get, call_39117294.host, call_39117294.base,
                           call_39117294.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117294, url, valid, _)

proc call*(call_39117295: Call_GetReposOwnerRepoLanguages_39117288; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoLanguages
  ## List languages.
  ## List languages for the specified repository. The value on the right of a
  ## language is the number of bytes of code written in that language.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117296 = newJObject()
  var header_39117297 = newJObject()
  add(path_39117296, "owner", newJString(owner))
  add(header_39117297, "Accept", newJString(Accept))
  add(path_39117296, "repo", newJString(repo))
  result = call_39117295.call(path_39117296, nil, header_39117297, nil, nil)

var getReposOwnerRepoLanguages* = Call_GetReposOwnerRepoLanguages_39117288(
    name: "getReposOwnerRepoLanguages", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/languages",
    validator: validate_GetReposOwnerRepoLanguages_39117289, base: "/",
    url: url_GetReposOwnerRepoLanguages_39117290, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoMerges_39117298 = ref object of OpenApiRestCall_39115352
proc url_PostReposOwnerRepoMerges_39117300(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/merges")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoMerges_39117299(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Perform a merge.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117301 = path.getOrDefault("owner")
  valid_39117301 = validateParameter(valid_39117301, JString, required = true,
                                   default = nil)
  if valid_39117301 != nil:
    section.add "owner", valid_39117301
  var valid_39117302 = path.getOrDefault("repo")
  valid_39117302 = validateParameter(valid_39117302, JString, required = true,
                                   default = nil)
  if valid_39117302 != nil:
    section.add "repo", valid_39117302
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117303 = header.getOrDefault("Accept")
  valid_39117303 = validateParameter(valid_39117303, JString, required = false,
                                   default = nil)
  if valid_39117303 != nil:
    section.add "Accept", valid_39117303
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39117305: Call_PostReposOwnerRepoMerges_39117298;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Perform a merge.
  ## 
  let valid = call_39117305.validator(path, query, header, formData, body, _)
  let scheme = call_39117305.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117305.url(scheme.get, call_39117305.host, call_39117305.base,
                           call_39117305.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117305, url, valid, _)

proc call*(call_39117306: Call_PostReposOwnerRepoMerges_39117298; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoMerges
  ## Perform a merge.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117307 = newJObject()
  var header_39117308 = newJObject()
  var body_39117309 = newJObject()
  add(path_39117307, "owner", newJString(owner))
  add(header_39117308, "Accept", newJString(Accept))
  if body != nil:
    body_39117309 = body
  add(path_39117307, "repo", newJString(repo))
  result = call_39117306.call(path_39117307, nil, header_39117308, nil, body_39117309)

var postReposOwnerRepoMerges* = Call_PostReposOwnerRepoMerges_39117298(
    name: "postReposOwnerRepoMerges", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/merges",
    validator: validate_PostReposOwnerRepoMerges_39117299, base: "/",
    url: url_PostReposOwnerRepoMerges_39117300, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoMilestones_39117324 = ref object of OpenApiRestCall_39115352
proc url_PostReposOwnerRepoMilestones_39117326(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoMilestones_39117325(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Create a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117327 = path.getOrDefault("owner")
  valid_39117327 = validateParameter(valid_39117327, JString, required = true,
                                   default = nil)
  if valid_39117327 != nil:
    section.add "owner", valid_39117327
  var valid_39117328 = path.getOrDefault("repo")
  valid_39117328 = validateParameter(valid_39117328, JString, required = true,
                                   default = nil)
  if valid_39117328 != nil:
    section.add "repo", valid_39117328
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117329 = header.getOrDefault("Accept")
  valid_39117329 = validateParameter(valid_39117329, JString, required = false,
                                   default = nil)
  if valid_39117329 != nil:
    section.add "Accept", valid_39117329
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39117331: Call_PostReposOwnerRepoMilestones_39117324;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a milestone.
  ## 
  let valid = call_39117331.validator(path, query, header, formData, body, _)
  let scheme = call_39117331.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117331.url(scheme.get, call_39117331.host, call_39117331.base,
                           call_39117331.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117331, url, valid, _)

proc call*(call_39117332: Call_PostReposOwnerRepoMilestones_39117324;
          owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoMilestones
  ## Create a milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117333 = newJObject()
  var header_39117334 = newJObject()
  var body_39117335 = newJObject()
  add(path_39117333, "owner", newJString(owner))
  add(header_39117334, "Accept", newJString(Accept))
  if body != nil:
    body_39117335 = body
  add(path_39117333, "repo", newJString(repo))
  result = call_39117332.call(path_39117333, nil, header_39117334, nil, body_39117335)

var postReposOwnerRepoMilestones* = Call_PostReposOwnerRepoMilestones_39117324(
    name: "postReposOwnerRepoMilestones", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones",
    validator: validate_PostReposOwnerRepoMilestones_39117325, base: "/",
    url: url_PostReposOwnerRepoMilestones_39117326, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoMilestones_39117310 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoMilestones_39117312(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoMilestones_39117311(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List milestones for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117313 = path.getOrDefault("owner")
  valid_39117313 = validateParameter(valid_39117313, JString, required = true,
                                   default = nil)
  if valid_39117313 != nil:
    section.add "owner", valid_39117313
  var valid_39117314 = path.getOrDefault("repo")
  valid_39117314 = validateParameter(valid_39117314, JString, required = true,
                                   default = nil)
  if valid_39117314 != nil:
    section.add "repo", valid_39117314
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString
  ##        : String to filter by state.
  ##   sort: JString
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  section = newJObject()
  var valid_39117315 = query.getOrDefault("state")
  valid_39117315 = validateParameter(valid_39117315, JString, required = false,
                                   default = newJString("open"))
  if valid_39117315 != nil:
    section.add "state", valid_39117315
  var valid_39117316 = query.getOrDefault("sort")
  valid_39117316 = validateParameter(valid_39117316, JString, required = false,
                                   default = newJString("due_date"))
  if valid_39117316 != nil:
    section.add "sort", valid_39117316
  var valid_39117317 = query.getOrDefault("direction")
  valid_39117317 = validateParameter(valid_39117317, JString, required = false,
                                   default = nil)
  if valid_39117317 != nil:
    section.add "direction", valid_39117317
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117318 = header.getOrDefault("Accept")
  valid_39117318 = validateParameter(valid_39117318, JString, required = false,
                                   default = nil)
  if valid_39117318 != nil:
    section.add "Accept", valid_39117318
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117319: Call_GetReposOwnerRepoMilestones_39117310;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List milestones for a repository.
  ## 
  let valid = call_39117319.validator(path, query, header, formData, body, _)
  let scheme = call_39117319.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117319.url(scheme.get, call_39117319.host, call_39117319.base,
                           call_39117319.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117319, url, valid, _)

proc call*(call_39117320: Call_GetReposOwnerRepoMilestones_39117310; owner: string;
          repo: string; state: string = "open"; Accept: string = "";
          sort: string = "due_date"; direction: string = ""): Recallable =
  ## getReposOwnerRepoMilestones
  ## List milestones for a repository.
  ##   state: string
  ##        : String to filter by state.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   sort: string
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  var path_39117321 = newJObject()
  var query_39117322 = newJObject()
  var header_39117323 = newJObject()
  add(query_39117322, "state", newJString(state))
  add(path_39117321, "owner", newJString(owner))
  add(header_39117323, "Accept", newJString(Accept))
  add(path_39117321, "repo", newJString(repo))
  add(query_39117322, "sort", newJString(sort))
  add(query_39117322, "direction", newJString(direction))
  result = call_39117320.call(path_39117321, query_39117322, header_39117323, nil, nil)

var getReposOwnerRepoMilestones* = Call_GetReposOwnerRepoMilestones_39117310(
    name: "getReposOwnerRepoMilestones", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones",
    validator: validate_GetReposOwnerRepoMilestones_39117311, base: "/",
    url: url_GetReposOwnerRepoMilestones_39117312, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoMilestonesNumber_39117336 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoMilestonesNumber_39117338(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoMilestonesNumber_39117337(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a single milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117339 = path.getOrDefault("owner")
  valid_39117339 = validateParameter(valid_39117339, JString, required = true,
                                   default = nil)
  if valid_39117339 != nil:
    section.add "owner", valid_39117339
  var valid_39117340 = path.getOrDefault("number")
  valid_39117340 = validateParameter(valid_39117340, JInt, required = true,
                                   default = nil)
  if valid_39117340 != nil:
    section.add "number", valid_39117340
  var valid_39117341 = path.getOrDefault("repo")
  valid_39117341 = validateParameter(valid_39117341, JString, required = true,
                                   default = nil)
  if valid_39117341 != nil:
    section.add "repo", valid_39117341
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117342 = header.getOrDefault("Accept")
  valid_39117342 = validateParameter(valid_39117342, JString, required = false,
                                   default = nil)
  if valid_39117342 != nil:
    section.add "Accept", valid_39117342
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117343: Call_GetReposOwnerRepoMilestonesNumber_39117336;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single milestone.
  ## 
  let valid = call_39117343.validator(path, query, header, formData, body, _)
  let scheme = call_39117343.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117343.url(scheme.get, call_39117343.host, call_39117343.base,
                           call_39117343.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117343, url, valid, _)

proc call*(call_39117344: Call_GetReposOwnerRepoMilestonesNumber_39117336;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoMilestonesNumber
  ## Get a single milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117345 = newJObject()
  var header_39117346 = newJObject()
  add(path_39117345, "owner", newJString(owner))
  add(path_39117345, "number", newJInt(number))
  add(header_39117346, "Accept", newJString(Accept))
  add(path_39117345, "repo", newJString(repo))
  result = call_39117344.call(path_39117345, nil, header_39117346, nil, nil)

var getReposOwnerRepoMilestonesNumber* = Call_GetReposOwnerRepoMilestonesNumber_39117336(
    name: "getReposOwnerRepoMilestonesNumber", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones/{number}",
    validator: validate_GetReposOwnerRepoMilestonesNumber_39117337, base: "/",
    url: url_GetReposOwnerRepoMilestonesNumber_39117338, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoMilestonesNumber_39117358 = ref object of OpenApiRestCall_39115352
proc url_PatchReposOwnerRepoMilestonesNumber_39117360(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoMilestonesNumber_39117359(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Update a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117361 = path.getOrDefault("owner")
  valid_39117361 = validateParameter(valid_39117361, JString, required = true,
                                   default = nil)
  if valid_39117361 != nil:
    section.add "owner", valid_39117361
  var valid_39117362 = path.getOrDefault("number")
  valid_39117362 = validateParameter(valid_39117362, JInt, required = true,
                                   default = nil)
  if valid_39117362 != nil:
    section.add "number", valid_39117362
  var valid_39117363 = path.getOrDefault("repo")
  valid_39117363 = validateParameter(valid_39117363, JString, required = true,
                                   default = nil)
  if valid_39117363 != nil:
    section.add "repo", valid_39117363
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117364 = header.getOrDefault("Accept")
  valid_39117364 = validateParameter(valid_39117364, JString, required = false,
                                   default = nil)
  if valid_39117364 != nil:
    section.add "Accept", valid_39117364
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39117366: Call_PatchReposOwnerRepoMilestonesNumber_39117358;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Update a milestone.
  ## 
  let valid = call_39117366.validator(path, query, header, formData, body, _)
  let scheme = call_39117366.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117366.url(scheme.get, call_39117366.host, call_39117366.base,
                           call_39117366.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117366, url, valid, _)

proc call*(call_39117367: Call_PatchReposOwnerRepoMilestonesNumber_39117358;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoMilestonesNumber
  ## Update a milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117368 = newJObject()
  var header_39117369 = newJObject()
  var body_39117370 = newJObject()
  add(path_39117368, "owner", newJString(owner))
  add(path_39117368, "number", newJInt(number))
  add(header_39117369, "Accept", newJString(Accept))
  if body != nil:
    body_39117370 = body
  add(path_39117368, "repo", newJString(repo))
  result = call_39117367.call(path_39117368, nil, header_39117369, nil, body_39117370)

var patchReposOwnerRepoMilestonesNumber* = Call_PatchReposOwnerRepoMilestonesNumber_39117358(
    name: "patchReposOwnerRepoMilestonesNumber", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones/{number}",
    validator: validate_PatchReposOwnerRepoMilestonesNumber_39117359, base: "/",
    url: url_PatchReposOwnerRepoMilestonesNumber_39117360, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoMilestonesNumber_39117347 = ref object of OpenApiRestCall_39115352
proc url_DeleteReposOwnerRepoMilestonesNumber_39117349(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoMilestonesNumber_39117348(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117350 = path.getOrDefault("owner")
  valid_39117350 = validateParameter(valid_39117350, JString, required = true,
                                   default = nil)
  if valid_39117350 != nil:
    section.add "owner", valid_39117350
  var valid_39117351 = path.getOrDefault("number")
  valid_39117351 = validateParameter(valid_39117351, JInt, required = true,
                                   default = nil)
  if valid_39117351 != nil:
    section.add "number", valid_39117351
  var valid_39117352 = path.getOrDefault("repo")
  valid_39117352 = validateParameter(valid_39117352, JString, required = true,
                                   default = nil)
  if valid_39117352 != nil:
    section.add "repo", valid_39117352
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117353 = header.getOrDefault("Accept")
  valid_39117353 = validateParameter(valid_39117353, JString, required = false,
                                   default = nil)
  if valid_39117353 != nil:
    section.add "Accept", valid_39117353
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117354: Call_DeleteReposOwnerRepoMilestonesNumber_39117347;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a milestone.
  ## 
  let valid = call_39117354.validator(path, query, header, formData, body, _)
  let scheme = call_39117354.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117354.url(scheme.get, call_39117354.host, call_39117354.base,
                           call_39117354.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117354, url, valid, _)

proc call*(call_39117355: Call_DeleteReposOwnerRepoMilestonesNumber_39117347;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoMilestonesNumber
  ## Delete a milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117356 = newJObject()
  var header_39117357 = newJObject()
  add(path_39117356, "owner", newJString(owner))
  add(path_39117356, "number", newJInt(number))
  add(header_39117357, "Accept", newJString(Accept))
  add(path_39117356, "repo", newJString(repo))
  result = call_39117355.call(path_39117356, nil, header_39117357, nil, nil)

var deleteReposOwnerRepoMilestonesNumber* = Call_DeleteReposOwnerRepoMilestonesNumber_39117347(
    name: "deleteReposOwnerRepoMilestonesNumber", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones/{number}",
    validator: validate_DeleteReposOwnerRepoMilestonesNumber_39117348, base: "/",
    url: url_DeleteReposOwnerRepoMilestonesNumber_39117349,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoMilestonesNumberLabels_39117371 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoMilestonesNumberLabels_39117373(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/milestones/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoMilestonesNumberLabels_39117372(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get labels for every issue in a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117374 = path.getOrDefault("owner")
  valid_39117374 = validateParameter(valid_39117374, JString, required = true,
                                   default = nil)
  if valid_39117374 != nil:
    section.add "owner", valid_39117374
  var valid_39117375 = path.getOrDefault("number")
  valid_39117375 = validateParameter(valid_39117375, JInt, required = true,
                                   default = nil)
  if valid_39117375 != nil:
    section.add "number", valid_39117375
  var valid_39117376 = path.getOrDefault("repo")
  valid_39117376 = validateParameter(valid_39117376, JString, required = true,
                                   default = nil)
  if valid_39117376 != nil:
    section.add "repo", valid_39117376
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117377 = header.getOrDefault("Accept")
  valid_39117377 = validateParameter(valid_39117377, JString, required = false,
                                   default = nil)
  if valid_39117377 != nil:
    section.add "Accept", valid_39117377
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117378: Call_GetReposOwnerRepoMilestonesNumberLabels_39117371;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get labels for every issue in a milestone.
  ## 
  let valid = call_39117378.validator(path, query, header, formData, body, _)
  let scheme = call_39117378.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117378.url(scheme.get, call_39117378.host, call_39117378.base,
                           call_39117378.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117378, url, valid, _)

proc call*(call_39117379: Call_GetReposOwnerRepoMilestonesNumberLabels_39117371;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoMilestonesNumberLabels
  ## Get labels for every issue in a milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117380 = newJObject()
  var header_39117381 = newJObject()
  add(path_39117380, "owner", newJString(owner))
  add(path_39117380, "number", newJInt(number))
  add(header_39117381, "Accept", newJString(Accept))
  add(path_39117380, "repo", newJString(repo))
  result = call_39117379.call(path_39117380, nil, header_39117381, nil, nil)

var getReposOwnerRepoMilestonesNumberLabels* = Call_GetReposOwnerRepoMilestonesNumberLabels_39117371(
    name: "getReposOwnerRepoMilestonesNumberLabels", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/milestones/{number}/labels",
    validator: validate_GetReposOwnerRepoMilestonesNumberLabels_39117372,
    base: "/", url: url_GetReposOwnerRepoMilestonesNumberLabels_39117373,
    schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoNotifications_39117396 = ref object of OpenApiRestCall_39115352
proc url_PutReposOwnerRepoNotifications_39117398(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/notifications")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoNotifications_39117397(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Mark notifications as read in a repository.
  ## Marking all notifications in a repository as "read" removes them from the
  ## default view on GitHub.com.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117399 = path.getOrDefault("owner")
  valid_39117399 = validateParameter(valid_39117399, JString, required = true,
                                   default = nil)
  if valid_39117399 != nil:
    section.add "owner", valid_39117399
  var valid_39117400 = path.getOrDefault("repo")
  valid_39117400 = validateParameter(valid_39117400, JString, required = true,
                                   default = nil)
  if valid_39117400 != nil:
    section.add "repo", valid_39117400
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117401 = header.getOrDefault("Accept")
  valid_39117401 = validateParameter(valid_39117401, JString, required = false,
                                   default = nil)
  if valid_39117401 != nil:
    section.add "Accept", valid_39117401
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39117403: Call_PutReposOwnerRepoNotifications_39117396;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Mark notifications as read in a repository.
  ## Marking all notifications in a repository as "read" removes them from the
  ## default view on GitHub.com.
  ## 
  ## 
  let valid = call_39117403.validator(path, query, header, formData, body, _)
  let scheme = call_39117403.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117403.url(scheme.get, call_39117403.host, call_39117403.base,
                           call_39117403.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117403, url, valid, _)

proc call*(call_39117404: Call_PutReposOwnerRepoNotifications_39117396;
          owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoNotifications
  ## Mark notifications as read in a repository.
  ## Marking all notifications in a repository as "read" removes them from the
  ## default view on GitHub.com.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117405 = newJObject()
  var header_39117406 = newJObject()
  var body_39117407 = newJObject()
  add(path_39117405, "owner", newJString(owner))
  add(header_39117406, "Accept", newJString(Accept))
  if body != nil:
    body_39117407 = body
  add(path_39117405, "repo", newJString(repo))
  result = call_39117404.call(path_39117405, nil, header_39117406, nil, body_39117407)

var putReposOwnerRepoNotifications* = Call_PutReposOwnerRepoNotifications_39117396(
    name: "putReposOwnerRepoNotifications", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/notifications",
    validator: validate_PutReposOwnerRepoNotifications_39117397, base: "/",
    url: url_PutReposOwnerRepoNotifications_39117398, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoNotifications_39117382 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoNotifications_39117384(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/notifications")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoNotifications_39117383(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List your notifications in a repository
  ## List all notifications for the current user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117385 = path.getOrDefault("owner")
  valid_39117385 = validateParameter(valid_39117385, JString, required = true,
                                   default = nil)
  if valid_39117385 != nil:
    section.add "owner", valid_39117385
  var valid_39117386 = path.getOrDefault("repo")
  valid_39117386 = validateParameter(valid_39117386, JString, required = true,
                                   default = nil)
  if valid_39117386 != nil:
    section.add "repo", valid_39117386
  result.add "path", section
  ## parameters in `query` object:
  ##   participating: JBool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  ##   all: JBool
  ##      : True to show notifications marked as read.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_39117387 = query.getOrDefault("participating")
  valid_39117387 = validateParameter(valid_39117387, JBool, required = false,
                                   default = nil)
  if valid_39117387 != nil:
    section.add "participating", valid_39117387
  var valid_39117388 = query.getOrDefault("all")
  valid_39117388 = validateParameter(valid_39117388, JBool, required = false,
                                   default = nil)
  if valid_39117388 != nil:
    section.add "all", valid_39117388
  var valid_39117389 = query.getOrDefault("since")
  valid_39117389 = validateParameter(valid_39117389, JString, required = false,
                                   default = nil)
  if valid_39117389 != nil:
    section.add "since", valid_39117389
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117390 = header.getOrDefault("Accept")
  valid_39117390 = validateParameter(valid_39117390, JString, required = false,
                                   default = nil)
  if valid_39117390 != nil:
    section.add "Accept", valid_39117390
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117391: Call_GetReposOwnerRepoNotifications_39117382;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List your notifications in a repository
  ## List all notifications for the current user.
  ## 
  ## 
  let valid = call_39117391.validator(path, query, header, formData, body, _)
  let scheme = call_39117391.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117391.url(scheme.get, call_39117391.host, call_39117391.base,
                           call_39117391.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117391, url, valid, _)

proc call*(call_39117392: Call_GetReposOwnerRepoNotifications_39117382;
          owner: string; repo: string; participating: bool = false; all: bool = false;
          Accept: string = ""; since: string = ""): Recallable =
  ## getReposOwnerRepoNotifications
  ## List your notifications in a repository
  ## List all notifications for the current user.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   participating: bool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  ##   all: bool
  ##      : True to show notifications marked as read.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var path_39117393 = newJObject()
  var query_39117394 = newJObject()
  var header_39117395 = newJObject()
  add(path_39117393, "owner", newJString(owner))
  add(query_39117394, "participating", newJBool(participating))
  add(query_39117394, "all", newJBool(all))
  add(header_39117395, "Accept", newJString(Accept))
  add(path_39117393, "repo", newJString(repo))
  add(query_39117394, "since", newJString(since))
  result = call_39117392.call(path_39117393, query_39117394, header_39117395, nil, nil)

var getReposOwnerRepoNotifications* = Call_GetReposOwnerRepoNotifications_39117382(
    name: "getReposOwnerRepoNotifications", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/notifications",
    validator: validate_GetReposOwnerRepoNotifications_39117383, base: "/",
    url: url_GetReposOwnerRepoNotifications_39117384, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoPulls_39117422 = ref object of OpenApiRestCall_39115352
proc url_PostReposOwnerRepoPulls_39117424(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoPulls_39117423(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117425 = path.getOrDefault("owner")
  valid_39117425 = validateParameter(valid_39117425, JString, required = true,
                                   default = nil)
  if valid_39117425 != nil:
    section.add "owner", valid_39117425
  var valid_39117426 = path.getOrDefault("repo")
  valid_39117426 = validateParameter(valid_39117426, JString, required = true,
                                   default = nil)
  if valid_39117426 != nil:
    section.add "repo", valid_39117426
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117427 = header.getOrDefault("Accept")
  valid_39117427 = validateParameter(valid_39117427, JString, required = false,
                                   default = nil)
  if valid_39117427 != nil:
    section.add "Accept", valid_39117427
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39117429: Call_PostReposOwnerRepoPulls_39117422;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a pull request.
  ## 
  let valid = call_39117429.validator(path, query, header, formData, body, _)
  let scheme = call_39117429.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117429.url(scheme.get, call_39117429.host, call_39117429.base,
                           call_39117429.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117429, url, valid, _)

proc call*(call_39117430: Call_PostReposOwnerRepoPulls_39117422; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoPulls
  ## Create a pull request.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117431 = newJObject()
  var header_39117432 = newJObject()
  var body_39117433 = newJObject()
  add(path_39117431, "owner", newJString(owner))
  add(header_39117432, "Accept", newJString(Accept))
  if body != nil:
    body_39117433 = body
  add(path_39117431, "repo", newJString(repo))
  result = call_39117430.call(path_39117431, nil, header_39117432, nil, body_39117433)

var postReposOwnerRepoPulls* = Call_PostReposOwnerRepoPulls_39117422(
    name: "postReposOwnerRepoPulls", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls",
    validator: validate_PostReposOwnerRepoPulls_39117423, base: "/",
    url: url_PostReposOwnerRepoPulls_39117424, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPulls_39117408 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoPulls_39117410(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPulls_39117409(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List pull requests.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117411 = path.getOrDefault("owner")
  valid_39117411 = validateParameter(valid_39117411, JString, required = true,
                                   default = nil)
  if valid_39117411 != nil:
    section.add "owner", valid_39117411
  var valid_39117412 = path.getOrDefault("repo")
  valid_39117412 = validateParameter(valid_39117412, JString, required = true,
                                   default = nil)
  if valid_39117412 != nil:
    section.add "repo", valid_39117412
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString
  ##        : String to filter by state.
  ##   head: JString
  ##       : Filter pulls by head user and branch name in the format of 'user:ref-name'.
  ## Example: github:new-script-format.
  ## 
  ##   base: JString
  ##       : Filter pulls by base branch name. Example - gh-pages.
  section = newJObject()
  var valid_39117413 = query.getOrDefault("state")
  valid_39117413 = validateParameter(valid_39117413, JString, required = false,
                                   default = newJString("open"))
  if valid_39117413 != nil:
    section.add "state", valid_39117413
  var valid_39117414 = query.getOrDefault("head")
  valid_39117414 = validateParameter(valid_39117414, JString, required = false,
                                   default = nil)
  if valid_39117414 != nil:
    section.add "head", valid_39117414
  var valid_39117415 = query.getOrDefault("base")
  valid_39117415 = validateParameter(valid_39117415, JString, required = false,
                                   default = nil)
  if valid_39117415 != nil:
    section.add "base", valid_39117415
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117416 = header.getOrDefault("Accept")
  valid_39117416 = validateParameter(valid_39117416, JString, required = false,
                                   default = nil)
  if valid_39117416 != nil:
    section.add "Accept", valid_39117416
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117417: Call_GetReposOwnerRepoPulls_39117408;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List pull requests.
  ## 
  let valid = call_39117417.validator(path, query, header, formData, body, _)
  let scheme = call_39117417.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117417.url(scheme.get, call_39117417.host, call_39117417.base,
                           call_39117417.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117417, url, valid, _)

proc call*(call_39117418: Call_GetReposOwnerRepoPulls_39117408; owner: string;
          repo: string; state: string = "open"; head: string = ""; base: string = "";
          Accept: string = ""): Recallable =
  ## getReposOwnerRepoPulls
  ## List pull requests.
  ##   state: string
  ##        : String to filter by state.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   head: string
  ##       : Filter pulls by head user and branch name in the format of 'user:ref-name'.
  ## Example: github:new-script-format.
  ## 
  ##   base: string
  ##       : Filter pulls by base branch name. Example - gh-pages.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117419 = newJObject()
  var query_39117420 = newJObject()
  var header_39117421 = newJObject()
  add(query_39117420, "state", newJString(state))
  add(path_39117419, "owner", newJString(owner))
  add(query_39117420, "head", newJString(head))
  add(query_39117420, "base", newJString(base))
  add(header_39117421, "Accept", newJString(Accept))
  add(path_39117419, "repo", newJString(repo))
  result = call_39117418.call(path_39117419, query_39117420, header_39117421, nil, nil)

var getReposOwnerRepoPulls* = Call_GetReposOwnerRepoPulls_39117408(
    name: "getReposOwnerRepoPulls", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls",
    validator: validate_GetReposOwnerRepoPulls_39117409, base: "/",
    url: url_GetReposOwnerRepoPulls_39117410, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsComments_39117434 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoPullsComments_39117436(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsComments_39117435(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List comments in a repository.
  ## By default, Review Comments are ordered by ascending ID.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117437 = path.getOrDefault("owner")
  valid_39117437 = validateParameter(valid_39117437, JString, required = true,
                                   default = nil)
  if valid_39117437 != nil:
    section.add "owner", valid_39117437
  var valid_39117438 = path.getOrDefault("repo")
  valid_39117438 = validateParameter(valid_39117438, JString, required = true,
                                   default = nil)
  if valid_39117438 != nil:
    section.add "repo", valid_39117438
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_39117439 = query.getOrDefault("sort")
  valid_39117439 = validateParameter(valid_39117439, JString, required = false,
                                   default = newJString("created"))
  if valid_39117439 != nil:
    section.add "sort", valid_39117439
  var valid_39117440 = query.getOrDefault("direction")
  valid_39117440 = validateParameter(valid_39117440, JString, required = false,
                                   default = nil)
  if valid_39117440 != nil:
    section.add "direction", valid_39117440
  var valid_39117441 = query.getOrDefault("since")
  valid_39117441 = validateParameter(valid_39117441, JString, required = false,
                                   default = nil)
  if valid_39117441 != nil:
    section.add "since", valid_39117441
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117442 = header.getOrDefault("Accept")
  valid_39117442 = validateParameter(valid_39117442, JString, required = false,
                                   default = nil)
  if valid_39117442 != nil:
    section.add "Accept", valid_39117442
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117443: Call_GetReposOwnerRepoPullsComments_39117434;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List comments in a repository.
  ## By default, Review Comments are ordered by ascending ID.
  ## 
  ## 
  let valid = call_39117443.validator(path, query, header, formData, body, _)
  let scheme = call_39117443.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117443.url(scheme.get, call_39117443.host, call_39117443.base,
                           call_39117443.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117443, url, valid, _)

proc call*(call_39117444: Call_GetReposOwnerRepoPullsComments_39117434;
          owner: string; repo: string; Accept: string = ""; sort: string = "created";
          direction: string = ""; since: string = ""): Recallable =
  ## getReposOwnerRepoPullsComments
  ## List comments in a repository.
  ## By default, Review Comments are ordered by ascending ID.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   sort: string
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var path_39117445 = newJObject()
  var query_39117446 = newJObject()
  var header_39117447 = newJObject()
  add(path_39117445, "owner", newJString(owner))
  add(header_39117447, "Accept", newJString(Accept))
  add(path_39117445, "repo", newJString(repo))
  add(query_39117446, "sort", newJString(sort))
  add(query_39117446, "direction", newJString(direction))
  add(query_39117446, "since", newJString(since))
  result = call_39117444.call(path_39117445, query_39117446, header_39117447, nil, nil)

var getReposOwnerRepoPullsComments* = Call_GetReposOwnerRepoPullsComments_39117434(
    name: "getReposOwnerRepoPullsComments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/comments",
    validator: validate_GetReposOwnerRepoPullsComments_39117435, base: "/",
    url: url_GetReposOwnerRepoPullsComments_39117436, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsCommentsCommentId_39117448 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoPullsCommentsCommentId_39117450(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsCommentsCommentId_39117449(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a single comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117451 = path.getOrDefault("owner")
  valid_39117451 = validateParameter(valid_39117451, JString, required = true,
                                   default = nil)
  if valid_39117451 != nil:
    section.add "owner", valid_39117451
  var valid_39117452 = path.getOrDefault("repo")
  valid_39117452 = validateParameter(valid_39117452, JString, required = true,
                                   default = nil)
  if valid_39117452 != nil:
    section.add "repo", valid_39117452
  var valid_39117453 = path.getOrDefault("commentId")
  valid_39117453 = validateParameter(valid_39117453, JInt, required = true,
                                   default = nil)
  if valid_39117453 != nil:
    section.add "commentId", valid_39117453
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117454 = header.getOrDefault("Accept")
  valid_39117454 = validateParameter(valid_39117454, JString, required = false,
                                   default = nil)
  if valid_39117454 != nil:
    section.add "Accept", valid_39117454
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117455: Call_GetReposOwnerRepoPullsCommentsCommentId_39117448;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single comment.
  ## 
  let valid = call_39117455.validator(path, query, header, formData, body, _)
  let scheme = call_39117455.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117455.url(scheme.get, call_39117455.host, call_39117455.base,
                           call_39117455.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117455, url, valid, _)

proc call*(call_39117456: Call_GetReposOwnerRepoPullsCommentsCommentId_39117448;
          owner: string; repo: string; commentId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsCommentsCommentId
  ## Get a single comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_39117457 = newJObject()
  var header_39117458 = newJObject()
  add(path_39117457, "owner", newJString(owner))
  add(header_39117458, "Accept", newJString(Accept))
  add(path_39117457, "repo", newJString(repo))
  add(path_39117457, "commentId", newJInt(commentId))
  result = call_39117456.call(path_39117457, nil, header_39117458, nil, nil)

var getReposOwnerRepoPullsCommentsCommentId* = Call_GetReposOwnerRepoPullsCommentsCommentId_39117448(
    name: "getReposOwnerRepoPullsCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/comments/{commentId}",
    validator: validate_GetReposOwnerRepoPullsCommentsCommentId_39117449,
    base: "/", url: url_GetReposOwnerRepoPullsCommentsCommentId_39117450,
    schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoPullsCommentsCommentId_39117470 = ref object of OpenApiRestCall_39115352
proc url_PatchReposOwnerRepoPullsCommentsCommentId_39117472(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoPullsCommentsCommentId_39117471(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Edit a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117473 = path.getOrDefault("owner")
  valid_39117473 = validateParameter(valid_39117473, JString, required = true,
                                   default = nil)
  if valid_39117473 != nil:
    section.add "owner", valid_39117473
  var valid_39117474 = path.getOrDefault("repo")
  valid_39117474 = validateParameter(valid_39117474, JString, required = true,
                                   default = nil)
  if valid_39117474 != nil:
    section.add "repo", valid_39117474
  var valid_39117475 = path.getOrDefault("commentId")
  valid_39117475 = validateParameter(valid_39117475, JInt, required = true,
                                   default = nil)
  if valid_39117475 != nil:
    section.add "commentId", valid_39117475
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117476 = header.getOrDefault("Accept")
  valid_39117476 = validateParameter(valid_39117476, JString, required = false,
                                   default = nil)
  if valid_39117476 != nil:
    section.add "Accept", valid_39117476
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39117478: Call_PatchReposOwnerRepoPullsCommentsCommentId_39117470;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit a comment.
  ## 
  let valid = call_39117478.validator(path, query, header, formData, body, _)
  let scheme = call_39117478.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117478.url(scheme.get, call_39117478.host, call_39117478.base,
                           call_39117478.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117478, url, valid, _)

proc call*(call_39117479: Call_PatchReposOwnerRepoPullsCommentsCommentId_39117470;
          owner: string; body: JsonNode; repo: string; commentId: int;
          Accept: string = ""): Recallable =
  ## patchReposOwnerRepoPullsCommentsCommentId
  ## Edit a comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_39117480 = newJObject()
  var header_39117481 = newJObject()
  var body_39117482 = newJObject()
  add(path_39117480, "owner", newJString(owner))
  add(header_39117481, "Accept", newJString(Accept))
  if body != nil:
    body_39117482 = body
  add(path_39117480, "repo", newJString(repo))
  add(path_39117480, "commentId", newJInt(commentId))
  result = call_39117479.call(path_39117480, nil, header_39117481, nil, body_39117482)

var patchReposOwnerRepoPullsCommentsCommentId* = Call_PatchReposOwnerRepoPullsCommentsCommentId_39117470(
    name: "patchReposOwnerRepoPullsCommentsCommentId", meth: HttpMethod.HttpPatch,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/comments/{commentId}",
    validator: validate_PatchReposOwnerRepoPullsCommentsCommentId_39117471,
    base: "/", url: url_PatchReposOwnerRepoPullsCommentsCommentId_39117472,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoPullsCommentsCommentId_39117459 = ref object of OpenApiRestCall_39115352
proc url_DeleteReposOwnerRepoPullsCommentsCommentId_39117461(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/comments/"),
               (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoPullsCommentsCommentId_39117460(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117462 = path.getOrDefault("owner")
  valid_39117462 = validateParameter(valid_39117462, JString, required = true,
                                   default = nil)
  if valid_39117462 != nil:
    section.add "owner", valid_39117462
  var valid_39117463 = path.getOrDefault("repo")
  valid_39117463 = validateParameter(valid_39117463, JString, required = true,
                                   default = nil)
  if valid_39117463 != nil:
    section.add "repo", valid_39117463
  var valid_39117464 = path.getOrDefault("commentId")
  valid_39117464 = validateParameter(valid_39117464, JInt, required = true,
                                   default = nil)
  if valid_39117464 != nil:
    section.add "commentId", valid_39117464
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117465 = header.getOrDefault("Accept")
  valid_39117465 = validateParameter(valid_39117465, JString, required = false,
                                   default = nil)
  if valid_39117465 != nil:
    section.add "Accept", valid_39117465
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117466: Call_DeleteReposOwnerRepoPullsCommentsCommentId_39117459;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a comment.
  ## 
  let valid = call_39117466.validator(path, query, header, formData, body, _)
  let scheme = call_39117466.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117466.url(scheme.get, call_39117466.host, call_39117466.base,
                           call_39117466.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117466, url, valid, _)

proc call*(call_39117467: Call_DeleteReposOwnerRepoPullsCommentsCommentId_39117459;
          owner: string; repo: string; commentId: int; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoPullsCommentsCommentId
  ## Delete a comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_39117468 = newJObject()
  var header_39117469 = newJObject()
  add(path_39117468, "owner", newJString(owner))
  add(header_39117469, "Accept", newJString(Accept))
  add(path_39117468, "repo", newJString(repo))
  add(path_39117468, "commentId", newJInt(commentId))
  result = call_39117467.call(path_39117468, nil, header_39117469, nil, nil)

var deleteReposOwnerRepoPullsCommentsCommentId* = Call_DeleteReposOwnerRepoPullsCommentsCommentId_39117459(
    name: "deleteReposOwnerRepoPullsCommentsCommentId",
    meth: HttpMethod.HttpDelete, host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/comments/{commentId}",
    validator: validate_DeleteReposOwnerRepoPullsCommentsCommentId_39117460,
    base: "/", url: url_DeleteReposOwnerRepoPullsCommentsCommentId_39117461,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumber_39117483 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoPullsNumber_39117485(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumber_39117484(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a single pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117486 = path.getOrDefault("owner")
  valid_39117486 = validateParameter(valid_39117486, JString, required = true,
                                   default = nil)
  if valid_39117486 != nil:
    section.add "owner", valid_39117486
  var valid_39117487 = path.getOrDefault("number")
  valid_39117487 = validateParameter(valid_39117487, JInt, required = true,
                                   default = nil)
  if valid_39117487 != nil:
    section.add "number", valid_39117487
  var valid_39117488 = path.getOrDefault("repo")
  valid_39117488 = validateParameter(valid_39117488, JString, required = true,
                                   default = nil)
  if valid_39117488 != nil:
    section.add "repo", valid_39117488
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117489 = header.getOrDefault("Accept")
  valid_39117489 = validateParameter(valid_39117489, JString, required = false,
                                   default = nil)
  if valid_39117489 != nil:
    section.add "Accept", valid_39117489
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117490: Call_GetReposOwnerRepoPullsNumber_39117483;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single pull request.
  ## 
  let valid = call_39117490.validator(path, query, header, formData, body, _)
  let scheme = call_39117490.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117490.url(scheme.get, call_39117490.host, call_39117490.base,
                           call_39117490.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117490, url, valid, _)

proc call*(call_39117491: Call_GetReposOwnerRepoPullsNumber_39117483;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumber
  ## Get a single pull request.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117492 = newJObject()
  var header_39117493 = newJObject()
  add(path_39117492, "owner", newJString(owner))
  add(path_39117492, "number", newJInt(number))
  add(header_39117493, "Accept", newJString(Accept))
  add(path_39117492, "repo", newJString(repo))
  result = call_39117491.call(path_39117492, nil, header_39117493, nil, nil)

var getReposOwnerRepoPullsNumber* = Call_GetReposOwnerRepoPullsNumber_39117483(
    name: "getReposOwnerRepoPullsNumber", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}",
    validator: validate_GetReposOwnerRepoPullsNumber_39117484, base: "/",
    url: url_GetReposOwnerRepoPullsNumber_39117485, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoPullsNumber_39117494 = ref object of OpenApiRestCall_39115352
proc url_PatchReposOwnerRepoPullsNumber_39117496(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoPullsNumber_39117495(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Update a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117497 = path.getOrDefault("owner")
  valid_39117497 = validateParameter(valid_39117497, JString, required = true,
                                   default = nil)
  if valid_39117497 != nil:
    section.add "owner", valid_39117497
  var valid_39117498 = path.getOrDefault("number")
  valid_39117498 = validateParameter(valid_39117498, JInt, required = true,
                                   default = nil)
  if valid_39117498 != nil:
    section.add "number", valid_39117498
  var valid_39117499 = path.getOrDefault("repo")
  valid_39117499 = validateParameter(valid_39117499, JString, required = true,
                                   default = nil)
  if valid_39117499 != nil:
    section.add "repo", valid_39117499
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117500 = header.getOrDefault("Accept")
  valid_39117500 = validateParameter(valid_39117500, JString, required = false,
                                   default = nil)
  if valid_39117500 != nil:
    section.add "Accept", valid_39117500
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39117502: Call_PatchReposOwnerRepoPullsNumber_39117494;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Update a pull request.
  ## 
  let valid = call_39117502.validator(path, query, header, formData, body, _)
  let scheme = call_39117502.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117502.url(scheme.get, call_39117502.host, call_39117502.base,
                           call_39117502.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117502, url, valid, _)

proc call*(call_39117503: Call_PatchReposOwnerRepoPullsNumber_39117494;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoPullsNumber
  ## Update a pull request.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117504 = newJObject()
  var header_39117505 = newJObject()
  var body_39117506 = newJObject()
  add(path_39117504, "owner", newJString(owner))
  add(path_39117504, "number", newJInt(number))
  add(header_39117505, "Accept", newJString(Accept))
  if body != nil:
    body_39117506 = body
  add(path_39117504, "repo", newJString(repo))
  result = call_39117503.call(path_39117504, nil, header_39117505, nil, body_39117506)

var patchReposOwnerRepoPullsNumber* = Call_PatchReposOwnerRepoPullsNumber_39117494(
    name: "patchReposOwnerRepoPullsNumber", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}",
    validator: validate_PatchReposOwnerRepoPullsNumber_39117495, base: "/",
    url: url_PatchReposOwnerRepoPullsNumber_39117496, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoPullsNumberComments_39117518 = ref object of OpenApiRestCall_39115352
proc url_PostReposOwnerRepoPullsNumberComments_39117520(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoPullsNumberComments_39117519(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Create a comment.
  ##   #TODO Alternative input ( http://developer.github.com/v3/pulls/comments/ )
  ##   description: |
  ##     Alternative Input.
  ##     Instead of passing commit_id, path, and position you can reply to an
  ##     existing Pull Request Comment like this:
  ## 
  ##         body
  ##            Required string
  ##         in_reply_to
  ##            Required number - Comment id to reply to.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117521 = path.getOrDefault("owner")
  valid_39117521 = validateParameter(valid_39117521, JString, required = true,
                                   default = nil)
  if valid_39117521 != nil:
    section.add "owner", valid_39117521
  var valid_39117522 = path.getOrDefault("number")
  valid_39117522 = validateParameter(valid_39117522, JInt, required = true,
                                   default = nil)
  if valid_39117522 != nil:
    section.add "number", valid_39117522
  var valid_39117523 = path.getOrDefault("repo")
  valid_39117523 = validateParameter(valid_39117523, JString, required = true,
                                   default = nil)
  if valid_39117523 != nil:
    section.add "repo", valid_39117523
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117524 = header.getOrDefault("Accept")
  valid_39117524 = validateParameter(valid_39117524, JString, required = false,
                                   default = nil)
  if valid_39117524 != nil:
    section.add "Accept", valid_39117524
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39117526: Call_PostReposOwnerRepoPullsNumberComments_39117518;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a comment.
  ##   #TODO Alternative input ( http://developer.github.com/v3/pulls/comments/ )
  ##   description: |
  ##     Alternative Input.
  ##     Instead of passing commit_id, path, and position you can reply to an
  ##     existing Pull Request Comment like this:
  ## 
  ##         body
  ##            Required string
  ##         in_reply_to
  ##            Required number - Comment id to reply to.
  ## 
  ## 
  let valid = call_39117526.validator(path, query, header, formData, body, _)
  let scheme = call_39117526.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117526.url(scheme.get, call_39117526.host, call_39117526.base,
                           call_39117526.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117526, url, valid, _)

proc call*(call_39117527: Call_PostReposOwnerRepoPullsNumberComments_39117518;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoPullsNumberComments
  ## Create a comment.
  ##   #TODO Alternative input ( http://developer.github.com/v3/pulls/comments/ )
  ##   description: |
  ##     Alternative Input.
  ##     Instead of passing commit_id, path, and position you can reply to an
  ##     existing Pull Request Comment like this:
  ## 
  ##         body
  ##            Required string
  ##         in_reply_to
  ##            Required number - Comment id to reply to.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117528 = newJObject()
  var header_39117529 = newJObject()
  var body_39117530 = newJObject()
  add(path_39117528, "owner", newJString(owner))
  add(path_39117528, "number", newJInt(number))
  add(header_39117529, "Accept", newJString(Accept))
  if body != nil:
    body_39117530 = body
  add(path_39117528, "repo", newJString(repo))
  result = call_39117527.call(path_39117528, nil, header_39117529, nil, body_39117530)

var postReposOwnerRepoPullsNumberComments* = Call_PostReposOwnerRepoPullsNumberComments_39117518(
    name: "postReposOwnerRepoPullsNumberComments", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/{number}/comments",
    validator: validate_PostReposOwnerRepoPullsNumberComments_39117519, base: "/",
    url: url_PostReposOwnerRepoPullsNumberComments_39117520,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberComments_39117507 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoPullsNumberComments_39117509(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberComments_39117508(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List comments on a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117510 = path.getOrDefault("owner")
  valid_39117510 = validateParameter(valid_39117510, JString, required = true,
                                   default = nil)
  if valid_39117510 != nil:
    section.add "owner", valid_39117510
  var valid_39117511 = path.getOrDefault("number")
  valid_39117511 = validateParameter(valid_39117511, JInt, required = true,
                                   default = nil)
  if valid_39117511 != nil:
    section.add "number", valid_39117511
  var valid_39117512 = path.getOrDefault("repo")
  valid_39117512 = validateParameter(valid_39117512, JString, required = true,
                                   default = nil)
  if valid_39117512 != nil:
    section.add "repo", valid_39117512
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117513 = header.getOrDefault("Accept")
  valid_39117513 = validateParameter(valid_39117513, JString, required = false,
                                   default = nil)
  if valid_39117513 != nil:
    section.add "Accept", valid_39117513
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117514: Call_GetReposOwnerRepoPullsNumberComments_39117507;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List comments on a pull request.
  ## 
  let valid = call_39117514.validator(path, query, header, formData, body, _)
  let scheme = call_39117514.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117514.url(scheme.get, call_39117514.host, call_39117514.base,
                           call_39117514.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117514, url, valid, _)

proc call*(call_39117515: Call_GetReposOwnerRepoPullsNumberComments_39117507;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberComments
  ## List comments on a pull request.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117516 = newJObject()
  var header_39117517 = newJObject()
  add(path_39117516, "owner", newJString(owner))
  add(path_39117516, "number", newJInt(number))
  add(header_39117517, "Accept", newJString(Accept))
  add(path_39117516, "repo", newJString(repo))
  result = call_39117515.call(path_39117516, nil, header_39117517, nil, nil)

var getReposOwnerRepoPullsNumberComments* = Call_GetReposOwnerRepoPullsNumberComments_39117507(
    name: "getReposOwnerRepoPullsNumberComments", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/{number}/comments",
    validator: validate_GetReposOwnerRepoPullsNumberComments_39117508, base: "/",
    url: url_GetReposOwnerRepoPullsNumberComments_39117509,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberCommits_39117531 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoPullsNumberCommits_39117533(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/commits")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberCommits_39117532(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List commits on a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117534 = path.getOrDefault("owner")
  valid_39117534 = validateParameter(valid_39117534, JString, required = true,
                                   default = nil)
  if valid_39117534 != nil:
    section.add "owner", valid_39117534
  var valid_39117535 = path.getOrDefault("number")
  valid_39117535 = validateParameter(valid_39117535, JInt, required = true,
                                   default = nil)
  if valid_39117535 != nil:
    section.add "number", valid_39117535
  var valid_39117536 = path.getOrDefault("repo")
  valid_39117536 = validateParameter(valid_39117536, JString, required = true,
                                   default = nil)
  if valid_39117536 != nil:
    section.add "repo", valid_39117536
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117537 = header.getOrDefault("Accept")
  valid_39117537 = validateParameter(valid_39117537, JString, required = false,
                                   default = nil)
  if valid_39117537 != nil:
    section.add "Accept", valid_39117537
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117538: Call_GetReposOwnerRepoPullsNumberCommits_39117531;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List commits on a pull request.
  ## 
  let valid = call_39117538.validator(path, query, header, formData, body, _)
  let scheme = call_39117538.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117538.url(scheme.get, call_39117538.host, call_39117538.base,
                           call_39117538.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117538, url, valid, _)

proc call*(call_39117539: Call_GetReposOwnerRepoPullsNumberCommits_39117531;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberCommits
  ## List commits on a pull request.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117540 = newJObject()
  var header_39117541 = newJObject()
  add(path_39117540, "owner", newJString(owner))
  add(path_39117540, "number", newJInt(number))
  add(header_39117541, "Accept", newJString(Accept))
  add(path_39117540, "repo", newJString(repo))
  result = call_39117539.call(path_39117540, nil, header_39117541, nil, nil)

var getReposOwnerRepoPullsNumberCommits* = Call_GetReposOwnerRepoPullsNumberCommits_39117531(
    name: "getReposOwnerRepoPullsNumberCommits", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/commits",
    validator: validate_GetReposOwnerRepoPullsNumberCommits_39117532, base: "/",
    url: url_GetReposOwnerRepoPullsNumberCommits_39117533, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberFiles_39117542 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoPullsNumberFiles_39117544(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/files")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberFiles_39117543(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List pull requests files.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117545 = path.getOrDefault("owner")
  valid_39117545 = validateParameter(valid_39117545, JString, required = true,
                                   default = nil)
  if valid_39117545 != nil:
    section.add "owner", valid_39117545
  var valid_39117546 = path.getOrDefault("number")
  valid_39117546 = validateParameter(valid_39117546, JInt, required = true,
                                   default = nil)
  if valid_39117546 != nil:
    section.add "number", valid_39117546
  var valid_39117547 = path.getOrDefault("repo")
  valid_39117547 = validateParameter(valid_39117547, JString, required = true,
                                   default = nil)
  if valid_39117547 != nil:
    section.add "repo", valid_39117547
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117548 = header.getOrDefault("Accept")
  valid_39117548 = validateParameter(valid_39117548, JString, required = false,
                                   default = nil)
  if valid_39117548 != nil:
    section.add "Accept", valid_39117548
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117549: Call_GetReposOwnerRepoPullsNumberFiles_39117542;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List pull requests files.
  ## 
  let valid = call_39117549.validator(path, query, header, formData, body, _)
  let scheme = call_39117549.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117549.url(scheme.get, call_39117549.host, call_39117549.base,
                           call_39117549.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117549, url, valid, _)

proc call*(call_39117550: Call_GetReposOwnerRepoPullsNumberFiles_39117542;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberFiles
  ## List pull requests files.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117551 = newJObject()
  var header_39117552 = newJObject()
  add(path_39117551, "owner", newJString(owner))
  add(path_39117551, "number", newJInt(number))
  add(header_39117552, "Accept", newJString(Accept))
  add(path_39117551, "repo", newJString(repo))
  result = call_39117550.call(path_39117551, nil, header_39117552, nil, nil)

var getReposOwnerRepoPullsNumberFiles* = Call_GetReposOwnerRepoPullsNumberFiles_39117542(
    name: "getReposOwnerRepoPullsNumberFiles", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/files",
    validator: validate_GetReposOwnerRepoPullsNumberFiles_39117543, base: "/",
    url: url_GetReposOwnerRepoPullsNumberFiles_39117544, schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoPullsNumberMerge_39117564 = ref object of OpenApiRestCall_39115352
proc url_PutReposOwnerRepoPullsNumberMerge_39117566(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/merge")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoPullsNumberMerge_39117565(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Merge a pull request (Merge Button's)
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117567 = path.getOrDefault("owner")
  valid_39117567 = validateParameter(valid_39117567, JString, required = true,
                                   default = nil)
  if valid_39117567 != nil:
    section.add "owner", valid_39117567
  var valid_39117568 = path.getOrDefault("number")
  valid_39117568 = validateParameter(valid_39117568, JInt, required = true,
                                   default = nil)
  if valid_39117568 != nil:
    section.add "number", valid_39117568
  var valid_39117569 = path.getOrDefault("repo")
  valid_39117569 = validateParameter(valid_39117569, JString, required = true,
                                   default = nil)
  if valid_39117569 != nil:
    section.add "repo", valid_39117569
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117570 = header.getOrDefault("Accept")
  valid_39117570 = validateParameter(valid_39117570, JString, required = false,
                                   default = nil)
  if valid_39117570 != nil:
    section.add "Accept", valid_39117570
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39117572: Call_PutReposOwnerRepoPullsNumberMerge_39117564;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Merge a pull request (Merge Button's)
  ## 
  let valid = call_39117572.validator(path, query, header, formData, body, _)
  let scheme = call_39117572.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117572.url(scheme.get, call_39117572.host, call_39117572.base,
                           call_39117572.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117572, url, valid, _)

proc call*(call_39117573: Call_PutReposOwnerRepoPullsNumberMerge_39117564;
          owner: string; number: int; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoPullsNumberMerge
  ## Merge a pull request (Merge Button's)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117574 = newJObject()
  var header_39117575 = newJObject()
  var body_39117576 = newJObject()
  add(path_39117574, "owner", newJString(owner))
  add(path_39117574, "number", newJInt(number))
  add(header_39117575, "Accept", newJString(Accept))
  if body != nil:
    body_39117576 = body
  add(path_39117574, "repo", newJString(repo))
  result = call_39117573.call(path_39117574, nil, header_39117575, nil, body_39117576)

var putReposOwnerRepoPullsNumberMerge* = Call_PutReposOwnerRepoPullsNumberMerge_39117564(
    name: "putReposOwnerRepoPullsNumberMerge", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/merge",
    validator: validate_PutReposOwnerRepoPullsNumberMerge_39117565, base: "/",
    url: url_PutReposOwnerRepoPullsNumberMerge_39117566, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberMerge_39117553 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoPullsNumberMerge_39117555(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/pulls/"),
               (kind: VariableSegment, value: "number"),
               (kind: ConstantSegment, value: "/merge")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberMerge_39117554(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get if a pull request has been merged.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117556 = path.getOrDefault("owner")
  valid_39117556 = validateParameter(valid_39117556, JString, required = true,
                                   default = nil)
  if valid_39117556 != nil:
    section.add "owner", valid_39117556
  var valid_39117557 = path.getOrDefault("number")
  valid_39117557 = validateParameter(valid_39117557, JInt, required = true,
                                   default = nil)
  if valid_39117557 != nil:
    section.add "number", valid_39117557
  var valid_39117558 = path.getOrDefault("repo")
  valid_39117558 = validateParameter(valid_39117558, JString, required = true,
                                   default = nil)
  if valid_39117558 != nil:
    section.add "repo", valid_39117558
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117559 = header.getOrDefault("Accept")
  valid_39117559 = validateParameter(valid_39117559, JString, required = false,
                                   default = nil)
  if valid_39117559 != nil:
    section.add "Accept", valid_39117559
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117560: Call_GetReposOwnerRepoPullsNumberMerge_39117553;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get if a pull request has been merged.
  ## 
  let valid = call_39117560.validator(path, query, header, formData, body, _)
  let scheme = call_39117560.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117560.url(scheme.get, call_39117560.host, call_39117560.base,
                           call_39117560.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117560, url, valid, _)

proc call*(call_39117561: Call_GetReposOwnerRepoPullsNumberMerge_39117553;
          owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberMerge
  ## Get if a pull request has been merged.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117562 = newJObject()
  var header_39117563 = newJObject()
  add(path_39117562, "owner", newJString(owner))
  add(path_39117562, "number", newJInt(number))
  add(header_39117563, "Accept", newJString(Accept))
  add(path_39117562, "repo", newJString(repo))
  result = call_39117561.call(path_39117562, nil, header_39117563, nil, nil)

var getReposOwnerRepoPullsNumberMerge* = Call_GetReposOwnerRepoPullsNumberMerge_39117553(
    name: "getReposOwnerRepoPullsNumberMerge", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/merge",
    validator: validate_GetReposOwnerRepoPullsNumberMerge_39117554, base: "/",
    url: url_GetReposOwnerRepoPullsNumberMerge_39117555, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReadme_39117577 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoReadme_39117579(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/readme")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReadme_39117578(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get the README.
  ## This method returns the preferred README for a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117580 = path.getOrDefault("owner")
  valid_39117580 = validateParameter(valid_39117580, JString, required = true,
                                   default = nil)
  if valid_39117580 != nil:
    section.add "owner", valid_39117580
  var valid_39117581 = path.getOrDefault("repo")
  valid_39117581 = validateParameter(valid_39117581, JString, required = true,
                                   default = nil)
  if valid_39117581 != nil:
    section.add "repo", valid_39117581
  result.add "path", section
  ## parameters in `query` object:
  ##   ref: JString
  ##      : The String name of the Commit/Branch/Tag. Defaults to master.
  section = newJObject()
  var valid_39117582 = query.getOrDefault("ref")
  valid_39117582 = validateParameter(valid_39117582, JString, required = false,
                                   default = nil)
  if valid_39117582 != nil:
    section.add "ref", valid_39117582
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117583 = header.getOrDefault("Accept")
  valid_39117583 = validateParameter(valid_39117583, JString, required = false,
                                   default = nil)
  if valid_39117583 != nil:
    section.add "Accept", valid_39117583
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117584: Call_GetReposOwnerRepoReadme_39117577;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get the README.
  ## This method returns the preferred README for a repository.
  ## 
  ## 
  let valid = call_39117584.validator(path, query, header, formData, body, _)
  let scheme = call_39117584.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117584.url(scheme.get, call_39117584.host, call_39117584.base,
                           call_39117584.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117584, url, valid, _)

proc call*(call_39117585: Call_GetReposOwnerRepoReadme_39117577; owner: string;
          repo: string; Accept: string = ""; `ref`: string = ""): Recallable =
  ## getReposOwnerRepoReadme
  ## Get the README.
  ## This method returns the preferred README for a repository.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   ref: string
  ##      : The String name of the Commit/Branch/Tag. Defaults to master.
  var path_39117586 = newJObject()
  var query_39117587 = newJObject()
  var header_39117588 = newJObject()
  add(path_39117586, "owner", newJString(owner))
  add(header_39117588, "Accept", newJString(Accept))
  add(path_39117586, "repo", newJString(repo))
  add(query_39117587, "ref", newJString(`ref`))
  result = call_39117585.call(path_39117586, query_39117587, header_39117588, nil, nil)

var getReposOwnerRepoReadme* = Call_GetReposOwnerRepoReadme_39117577(
    name: "getReposOwnerRepoReadme", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/readme",
    validator: validate_GetReposOwnerRepoReadme_39117578, base: "/",
    url: url_GetReposOwnerRepoReadme_39117579, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoReleases_39117599 = ref object of OpenApiRestCall_39115352
proc url_PostReposOwnerRepoReleases_39117601(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoReleases_39117600(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Create a release
  ## Users with push access to the repository can create a release.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117602 = path.getOrDefault("owner")
  valid_39117602 = validateParameter(valid_39117602, JString, required = true,
                                   default = nil)
  if valid_39117602 != nil:
    section.add "owner", valid_39117602
  var valid_39117603 = path.getOrDefault("repo")
  valid_39117603 = validateParameter(valid_39117603, JString, required = true,
                                   default = nil)
  if valid_39117603 != nil:
    section.add "repo", valid_39117603
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117604 = header.getOrDefault("Accept")
  valid_39117604 = validateParameter(valid_39117604, JString, required = false,
                                   default = nil)
  if valid_39117604 != nil:
    section.add "Accept", valid_39117604
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39117606: Call_PostReposOwnerRepoReleases_39117599;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a release
  ## Users with push access to the repository can create a release.
  ## 
  ## 
  let valid = call_39117606.validator(path, query, header, formData, body, _)
  let scheme = call_39117606.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117606.url(scheme.get, call_39117606.host, call_39117606.base,
                           call_39117606.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117606, url, valid, _)

proc call*(call_39117607: Call_PostReposOwnerRepoReleases_39117599; owner: string;
          body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoReleases
  ## Create a release
  ## Users with push access to the repository can create a release.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117608 = newJObject()
  var header_39117609 = newJObject()
  var body_39117610 = newJObject()
  add(path_39117608, "owner", newJString(owner))
  add(header_39117609, "Accept", newJString(Accept))
  if body != nil:
    body_39117610 = body
  add(path_39117608, "repo", newJString(repo))
  result = call_39117607.call(path_39117608, nil, header_39117609, nil, body_39117610)

var postReposOwnerRepoReleases* = Call_PostReposOwnerRepoReleases_39117599(
    name: "postReposOwnerRepoReleases", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases",
    validator: validate_PostReposOwnerRepoReleases_39117600, base: "/",
    url: url_PostReposOwnerRepoReleases_39117601, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleases_39117589 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoReleases_39117591(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleases_39117590(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Users with push access to the repository will receive all releases (i.e., published releases and draft releases). Users with pull access will receive published releases only
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117592 = path.getOrDefault("owner")
  valid_39117592 = validateParameter(valid_39117592, JString, required = true,
                                   default = nil)
  if valid_39117592 != nil:
    section.add "owner", valid_39117592
  var valid_39117593 = path.getOrDefault("repo")
  valid_39117593 = validateParameter(valid_39117593, JString, required = true,
                                   default = nil)
  if valid_39117593 != nil:
    section.add "repo", valid_39117593
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117594 = header.getOrDefault("Accept")
  valid_39117594 = validateParameter(valid_39117594, JString, required = false,
                                   default = nil)
  if valid_39117594 != nil:
    section.add "Accept", valid_39117594
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117595: Call_GetReposOwnerRepoReleases_39117589;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Users with push access to the repository will receive all releases (i.e., published releases and draft releases). Users with pull access will receive published releases only
  ## 
  let valid = call_39117595.validator(path, query, header, formData, body, _)
  let scheme = call_39117595.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117595.url(scheme.get, call_39117595.host, call_39117595.base,
                           call_39117595.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117595, url, valid, _)

proc call*(call_39117596: Call_GetReposOwnerRepoReleases_39117589; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleases
  ## Users with push access to the repository will receive all releases (i.e., published releases and draft releases). Users with pull access will receive published releases only
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117597 = newJObject()
  var header_39117598 = newJObject()
  add(path_39117597, "owner", newJString(owner))
  add(header_39117598, "Accept", newJString(Accept))
  add(path_39117597, "repo", newJString(repo))
  result = call_39117596.call(path_39117597, nil, header_39117598, nil, nil)

var getReposOwnerRepoReleases* = Call_GetReposOwnerRepoReleases_39117589(
    name: "getReposOwnerRepoReleases", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases",
    validator: validate_GetReposOwnerRepoReleases_39117590, base: "/",
    url: url_GetReposOwnerRepoReleases_39117591, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleasesAssetsId_39117611 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoReleasesAssetsId_39117613(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/assets/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleasesAssetsId_39117612(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a single release asset
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117614 = path.getOrDefault("owner")
  valid_39117614 = validateParameter(valid_39117614, JString, required = true,
                                   default = nil)
  if valid_39117614 != nil:
    section.add "owner", valid_39117614
  var valid_39117615 = path.getOrDefault("id")
  valid_39117615 = validateParameter(valid_39117615, JString, required = true,
                                   default = nil)
  if valid_39117615 != nil:
    section.add "id", valid_39117615
  var valid_39117616 = path.getOrDefault("repo")
  valid_39117616 = validateParameter(valid_39117616, JString, required = true,
                                   default = nil)
  if valid_39117616 != nil:
    section.add "repo", valid_39117616
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117617 = header.getOrDefault("Accept")
  valid_39117617 = validateParameter(valid_39117617, JString, required = false,
                                   default = nil)
  if valid_39117617 != nil:
    section.add "Accept", valid_39117617
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117618: Call_GetReposOwnerRepoReleasesAssetsId_39117611;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single release asset
  ## 
  let valid = call_39117618.validator(path, query, header, formData, body, _)
  let scheme = call_39117618.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117618.url(scheme.get, call_39117618.host, call_39117618.base,
                           call_39117618.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117618, url, valid, _)

proc call*(call_39117619: Call_GetReposOwnerRepoReleasesAssetsId_39117611;
          owner: string; id: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleasesAssetsId
  ## Get a single release asset
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117620 = newJObject()
  var header_39117621 = newJObject()
  add(path_39117620, "owner", newJString(owner))
  add(path_39117620, "id", newJString(id))
  add(header_39117621, "Accept", newJString(Accept))
  add(path_39117620, "repo", newJString(repo))
  result = call_39117619.call(path_39117620, nil, header_39117621, nil, nil)

var getReposOwnerRepoReleasesAssetsId* = Call_GetReposOwnerRepoReleasesAssetsId_39117611(
    name: "getReposOwnerRepoReleasesAssetsId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/assets/{id}",
    validator: validate_GetReposOwnerRepoReleasesAssetsId_39117612, base: "/",
    url: url_GetReposOwnerRepoReleasesAssetsId_39117613, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoReleasesAssetsId_39117633 = ref object of OpenApiRestCall_39115352
proc url_PatchReposOwnerRepoReleasesAssetsId_39117635(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/assets/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoReleasesAssetsId_39117634(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Edit a release asset
  ## Users with push access to the repository can edit a release asset.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117636 = path.getOrDefault("owner")
  valid_39117636 = validateParameter(valid_39117636, JString, required = true,
                                   default = nil)
  if valid_39117636 != nil:
    section.add "owner", valid_39117636
  var valid_39117637 = path.getOrDefault("id")
  valid_39117637 = validateParameter(valid_39117637, JString, required = true,
                                   default = nil)
  if valid_39117637 != nil:
    section.add "id", valid_39117637
  var valid_39117638 = path.getOrDefault("repo")
  valid_39117638 = validateParameter(valid_39117638, JString, required = true,
                                   default = nil)
  if valid_39117638 != nil:
    section.add "repo", valid_39117638
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117639 = header.getOrDefault("Accept")
  valid_39117639 = validateParameter(valid_39117639, JString, required = false,
                                   default = nil)
  if valid_39117639 != nil:
    section.add "Accept", valid_39117639
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39117641: Call_PatchReposOwnerRepoReleasesAssetsId_39117633;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit a release asset
  ## Users with push access to the repository can edit a release asset.
  ## 
  ## 
  let valid = call_39117641.validator(path, query, header, formData, body, _)
  let scheme = call_39117641.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117641.url(scheme.get, call_39117641.host, call_39117641.base,
                           call_39117641.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117641, url, valid, _)

proc call*(call_39117642: Call_PatchReposOwnerRepoReleasesAssetsId_39117633;
          owner: string; id: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoReleasesAssetsId
  ## Edit a release asset
  ## Users with push access to the repository can edit a release asset.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117643 = newJObject()
  var header_39117644 = newJObject()
  var body_39117645 = newJObject()
  add(path_39117643, "owner", newJString(owner))
  add(path_39117643, "id", newJString(id))
  add(header_39117644, "Accept", newJString(Accept))
  if body != nil:
    body_39117645 = body
  add(path_39117643, "repo", newJString(repo))
  result = call_39117642.call(path_39117643, nil, header_39117644, nil, body_39117645)

var patchReposOwnerRepoReleasesAssetsId* = Call_PatchReposOwnerRepoReleasesAssetsId_39117633(
    name: "patchReposOwnerRepoReleasesAssetsId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/assets/{id}",
    validator: validate_PatchReposOwnerRepoReleasesAssetsId_39117634, base: "/",
    url: url_PatchReposOwnerRepoReleasesAssetsId_39117635, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoReleasesAssetsId_39117622 = ref object of OpenApiRestCall_39115352
proc url_DeleteReposOwnerRepoReleasesAssetsId_39117624(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/assets/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoReleasesAssetsId_39117623(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a release asset
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117625 = path.getOrDefault("owner")
  valid_39117625 = validateParameter(valid_39117625, JString, required = true,
                                   default = nil)
  if valid_39117625 != nil:
    section.add "owner", valid_39117625
  var valid_39117626 = path.getOrDefault("id")
  valid_39117626 = validateParameter(valid_39117626, JString, required = true,
                                   default = nil)
  if valid_39117626 != nil:
    section.add "id", valid_39117626
  var valid_39117627 = path.getOrDefault("repo")
  valid_39117627 = validateParameter(valid_39117627, JString, required = true,
                                   default = nil)
  if valid_39117627 != nil:
    section.add "repo", valid_39117627
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117628 = header.getOrDefault("Accept")
  valid_39117628 = validateParameter(valid_39117628, JString, required = false,
                                   default = nil)
  if valid_39117628 != nil:
    section.add "Accept", valid_39117628
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117629: Call_DeleteReposOwnerRepoReleasesAssetsId_39117622;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a release asset
  ## 
  let valid = call_39117629.validator(path, query, header, formData, body, _)
  let scheme = call_39117629.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117629.url(scheme.get, call_39117629.host, call_39117629.base,
                           call_39117629.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117629, url, valid, _)

proc call*(call_39117630: Call_DeleteReposOwnerRepoReleasesAssetsId_39117622;
          owner: string; id: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoReleasesAssetsId
  ## Delete a release asset
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117631 = newJObject()
  var header_39117632 = newJObject()
  add(path_39117631, "owner", newJString(owner))
  add(path_39117631, "id", newJString(id))
  add(header_39117632, "Accept", newJString(Accept))
  add(path_39117631, "repo", newJString(repo))
  result = call_39117630.call(path_39117631, nil, header_39117632, nil, nil)

var deleteReposOwnerRepoReleasesAssetsId* = Call_DeleteReposOwnerRepoReleasesAssetsId_39117622(
    name: "deleteReposOwnerRepoReleasesAssetsId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/assets/{id}",
    validator: validate_DeleteReposOwnerRepoReleasesAssetsId_39117623, base: "/",
    url: url_DeleteReposOwnerRepoReleasesAssetsId_39117624,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleasesId_39117646 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoReleasesId_39117648(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleasesId_39117647(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get a single release
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117649 = path.getOrDefault("owner")
  valid_39117649 = validateParameter(valid_39117649, JString, required = true,
                                   default = nil)
  if valid_39117649 != nil:
    section.add "owner", valid_39117649
  var valid_39117650 = path.getOrDefault("id")
  valid_39117650 = validateParameter(valid_39117650, JString, required = true,
                                   default = nil)
  if valid_39117650 != nil:
    section.add "id", valid_39117650
  var valid_39117651 = path.getOrDefault("repo")
  valid_39117651 = validateParameter(valid_39117651, JString, required = true,
                                   default = nil)
  if valid_39117651 != nil:
    section.add "repo", valid_39117651
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117652 = header.getOrDefault("Accept")
  valid_39117652 = validateParameter(valid_39117652, JString, required = false,
                                   default = nil)
  if valid_39117652 != nil:
    section.add "Accept", valid_39117652
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117653: Call_GetReposOwnerRepoReleasesId_39117646;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single release
  ## 
  let valid = call_39117653.validator(path, query, header, formData, body, _)
  let scheme = call_39117653.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117653.url(scheme.get, call_39117653.host, call_39117653.base,
                           call_39117653.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117653, url, valid, _)

proc call*(call_39117654: Call_GetReposOwnerRepoReleasesId_39117646; owner: string;
          id: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleasesId
  ## Get a single release
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117655 = newJObject()
  var header_39117656 = newJObject()
  add(path_39117655, "owner", newJString(owner))
  add(path_39117655, "id", newJString(id))
  add(header_39117656, "Accept", newJString(Accept))
  add(path_39117655, "repo", newJString(repo))
  result = call_39117654.call(path_39117655, nil, header_39117656, nil, nil)

var getReposOwnerRepoReleasesId* = Call_GetReposOwnerRepoReleasesId_39117646(
    name: "getReposOwnerRepoReleasesId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}",
    validator: validate_GetReposOwnerRepoReleasesId_39117647, base: "/",
    url: url_GetReposOwnerRepoReleasesId_39117648, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoReleasesId_39117668 = ref object of OpenApiRestCall_39115352
proc url_PatchReposOwnerRepoReleasesId_39117670(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoReleasesId_39117669(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Users with push access to the repository can edit a release
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117671 = path.getOrDefault("owner")
  valid_39117671 = validateParameter(valid_39117671, JString, required = true,
                                   default = nil)
  if valid_39117671 != nil:
    section.add "owner", valid_39117671
  var valid_39117672 = path.getOrDefault("id")
  valid_39117672 = validateParameter(valid_39117672, JString, required = true,
                                   default = nil)
  if valid_39117672 != nil:
    section.add "id", valid_39117672
  var valid_39117673 = path.getOrDefault("repo")
  valid_39117673 = validateParameter(valid_39117673, JString, required = true,
                                   default = nil)
  if valid_39117673 != nil:
    section.add "repo", valid_39117673
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117674 = header.getOrDefault("Accept")
  valid_39117674 = validateParameter(valid_39117674, JString, required = false,
                                   default = nil)
  if valid_39117674 != nil:
    section.add "Accept", valid_39117674
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39117676: Call_PatchReposOwnerRepoReleasesId_39117668;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Users with push access to the repository can edit a release
  ## 
  let valid = call_39117676.validator(path, query, header, formData, body, _)
  let scheme = call_39117676.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117676.url(scheme.get, call_39117676.host, call_39117676.base,
                           call_39117676.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117676, url, valid, _)

proc call*(call_39117677: Call_PatchReposOwnerRepoReleasesId_39117668;
          owner: string; id: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepoReleasesId
  ## Users with push access to the repository can edit a release
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117678 = newJObject()
  var header_39117679 = newJObject()
  var body_39117680 = newJObject()
  add(path_39117678, "owner", newJString(owner))
  add(path_39117678, "id", newJString(id))
  add(header_39117679, "Accept", newJString(Accept))
  if body != nil:
    body_39117680 = body
  add(path_39117678, "repo", newJString(repo))
  result = call_39117677.call(path_39117678, nil, header_39117679, nil, body_39117680)

var patchReposOwnerRepoReleasesId* = Call_PatchReposOwnerRepoReleasesId_39117668(
    name: "patchReposOwnerRepoReleasesId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}",
    validator: validate_PatchReposOwnerRepoReleasesId_39117669, base: "/",
    url: url_PatchReposOwnerRepoReleasesId_39117670, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoReleasesId_39117657 = ref object of OpenApiRestCall_39115352
proc url_DeleteReposOwnerRepoReleasesId_39117659(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/"),
               (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoReleasesId_39117658(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Users with push access to the repository can delete a release.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117660 = path.getOrDefault("owner")
  valid_39117660 = validateParameter(valid_39117660, JString, required = true,
                                   default = nil)
  if valid_39117660 != nil:
    section.add "owner", valid_39117660
  var valid_39117661 = path.getOrDefault("id")
  valid_39117661 = validateParameter(valid_39117661, JString, required = true,
                                   default = nil)
  if valid_39117661 != nil:
    section.add "id", valid_39117661
  var valid_39117662 = path.getOrDefault("repo")
  valid_39117662 = validateParameter(valid_39117662, JString, required = true,
                                   default = nil)
  if valid_39117662 != nil:
    section.add "repo", valid_39117662
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117663 = header.getOrDefault("Accept")
  valid_39117663 = validateParameter(valid_39117663, JString, required = false,
                                   default = nil)
  if valid_39117663 != nil:
    section.add "Accept", valid_39117663
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117664: Call_DeleteReposOwnerRepoReleasesId_39117657;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Users with push access to the repository can delete a release.
  ## 
  let valid = call_39117664.validator(path, query, header, formData, body, _)
  let scheme = call_39117664.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117664.url(scheme.get, call_39117664.host, call_39117664.base,
                           call_39117664.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117664, url, valid, _)

proc call*(call_39117665: Call_DeleteReposOwnerRepoReleasesId_39117657;
          owner: string; id: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoReleasesId
  ## Users with push access to the repository can delete a release.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117666 = newJObject()
  var header_39117667 = newJObject()
  add(path_39117666, "owner", newJString(owner))
  add(path_39117666, "id", newJString(id))
  add(header_39117667, "Accept", newJString(Accept))
  add(path_39117666, "repo", newJString(repo))
  result = call_39117665.call(path_39117666, nil, header_39117667, nil, nil)

var deleteReposOwnerRepoReleasesId* = Call_DeleteReposOwnerRepoReleasesId_39117657(
    name: "deleteReposOwnerRepoReleasesId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}",
    validator: validate_DeleteReposOwnerRepoReleasesId_39117658, base: "/",
    url: url_DeleteReposOwnerRepoReleasesId_39117659, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleasesIdAssets_39117681 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoReleasesIdAssets_39117683(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/releases/"),
               (kind: VariableSegment, value: "id"),
               (kind: ConstantSegment, value: "/assets")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleasesIdAssets_39117682(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List assets for a release
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117684 = path.getOrDefault("owner")
  valid_39117684 = validateParameter(valid_39117684, JString, required = true,
                                   default = nil)
  if valid_39117684 != nil:
    section.add "owner", valid_39117684
  var valid_39117685 = path.getOrDefault("id")
  valid_39117685 = validateParameter(valid_39117685, JString, required = true,
                                   default = nil)
  if valid_39117685 != nil:
    section.add "id", valid_39117685
  var valid_39117686 = path.getOrDefault("repo")
  valid_39117686 = validateParameter(valid_39117686, JString, required = true,
                                   default = nil)
  if valid_39117686 != nil:
    section.add "repo", valid_39117686
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117687 = header.getOrDefault("Accept")
  valid_39117687 = validateParameter(valid_39117687, JString, required = false,
                                   default = nil)
  if valid_39117687 != nil:
    section.add "Accept", valid_39117687
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117688: Call_GetReposOwnerRepoReleasesIdAssets_39117681;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List assets for a release
  ## 
  let valid = call_39117688.validator(path, query, header, formData, body, _)
  let scheme = call_39117688.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117688.url(scheme.get, call_39117688.host, call_39117688.base,
                           call_39117688.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117688, url, valid, _)

proc call*(call_39117689: Call_GetReposOwnerRepoReleasesIdAssets_39117681;
          owner: string; id: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleasesIdAssets
  ## List assets for a release
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117690 = newJObject()
  var header_39117691 = newJObject()
  add(path_39117690, "owner", newJString(owner))
  add(path_39117690, "id", newJString(id))
  add(header_39117691, "Accept", newJString(Accept))
  add(path_39117690, "repo", newJString(repo))
  result = call_39117689.call(path_39117690, nil, header_39117691, nil, nil)

var getReposOwnerRepoReleasesIdAssets* = Call_GetReposOwnerRepoReleasesIdAssets_39117681(
    name: "getReposOwnerRepoReleasesIdAssets", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}/assets",
    validator: validate_GetReposOwnerRepoReleasesIdAssets_39117682, base: "/",
    url: url_GetReposOwnerRepoReleasesIdAssets_39117683, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStargazers_39117692 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoStargazers_39117694(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stargazers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStargazers_39117693(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List Stargazers.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117695 = path.getOrDefault("owner")
  valid_39117695 = validateParameter(valid_39117695, JString, required = true,
                                   default = nil)
  if valid_39117695 != nil:
    section.add "owner", valid_39117695
  var valid_39117696 = path.getOrDefault("repo")
  valid_39117696 = validateParameter(valid_39117696, JString, required = true,
                                   default = nil)
  if valid_39117696 != nil:
    section.add "repo", valid_39117696
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117697 = header.getOrDefault("Accept")
  valid_39117697 = validateParameter(valid_39117697, JString, required = false,
                                   default = nil)
  if valid_39117697 != nil:
    section.add "Accept", valid_39117697
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117698: Call_GetReposOwnerRepoStargazers_39117692;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List Stargazers.
  ## 
  let valid = call_39117698.validator(path, query, header, formData, body, _)
  let scheme = call_39117698.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117698.url(scheme.get, call_39117698.host, call_39117698.base,
                           call_39117698.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117698, url, valid, _)

proc call*(call_39117699: Call_GetReposOwnerRepoStargazers_39117692; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStargazers
  ## List Stargazers.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117700 = newJObject()
  var header_39117701 = newJObject()
  add(path_39117700, "owner", newJString(owner))
  add(header_39117701, "Accept", newJString(Accept))
  add(path_39117700, "repo", newJString(repo))
  result = call_39117699.call(path_39117700, nil, header_39117701, nil, nil)

var getReposOwnerRepoStargazers* = Call_GetReposOwnerRepoStargazers_39117692(
    name: "getReposOwnerRepoStargazers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stargazers",
    validator: validate_GetReposOwnerRepoStargazers_39117693, base: "/",
    url: url_GetReposOwnerRepoStargazers_39117694, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsCodeFrequency_39117702 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoStatsCodeFrequency_39117704(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/code_frequency")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsCodeFrequency_39117703(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get the number of additions and deletions per week.
  ## Returns a weekly aggregate of the number of additions and deletions pushed
  ## to a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117705 = path.getOrDefault("owner")
  valid_39117705 = validateParameter(valid_39117705, JString, required = true,
                                   default = nil)
  if valid_39117705 != nil:
    section.add "owner", valid_39117705
  var valid_39117706 = path.getOrDefault("repo")
  valid_39117706 = validateParameter(valid_39117706, JString, required = true,
                                   default = nil)
  if valid_39117706 != nil:
    section.add "repo", valid_39117706
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117707 = header.getOrDefault("Accept")
  valid_39117707 = validateParameter(valid_39117707, JString, required = false,
                                   default = nil)
  if valid_39117707 != nil:
    section.add "Accept", valid_39117707
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117708: Call_GetReposOwnerRepoStatsCodeFrequency_39117702;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get the number of additions and deletions per week.
  ## Returns a weekly aggregate of the number of additions and deletions pushed
  ## to a repository.
  ## 
  ## 
  let valid = call_39117708.validator(path, query, header, formData, body, _)
  let scheme = call_39117708.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117708.url(scheme.get, call_39117708.host, call_39117708.base,
                           call_39117708.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117708, url, valid, _)

proc call*(call_39117709: Call_GetReposOwnerRepoStatsCodeFrequency_39117702;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsCodeFrequency
  ## Get the number of additions and deletions per week.
  ## Returns a weekly aggregate of the number of additions and deletions pushed
  ## to a repository.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117710 = newJObject()
  var header_39117711 = newJObject()
  add(path_39117710, "owner", newJString(owner))
  add(header_39117711, "Accept", newJString(Accept))
  add(path_39117710, "repo", newJString(repo))
  result = call_39117709.call(path_39117710, nil, header_39117711, nil, nil)

var getReposOwnerRepoStatsCodeFrequency* = Call_GetReposOwnerRepoStatsCodeFrequency_39117702(
    name: "getReposOwnerRepoStatsCodeFrequency", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/code_frequency",
    validator: validate_GetReposOwnerRepoStatsCodeFrequency_39117703, base: "/",
    url: url_GetReposOwnerRepoStatsCodeFrequency_39117704, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsCommitActivity_39117712 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoStatsCommitActivity_39117714(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/commit_activity")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsCommitActivity_39117713(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get the last year of commit activity data.
  ## Returns the last year of commit activity grouped by week. The days array
  ## is a group of commits per day, starting on Sunday.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117715 = path.getOrDefault("owner")
  valid_39117715 = validateParameter(valid_39117715, JString, required = true,
                                   default = nil)
  if valid_39117715 != nil:
    section.add "owner", valid_39117715
  var valid_39117716 = path.getOrDefault("repo")
  valid_39117716 = validateParameter(valid_39117716, JString, required = true,
                                   default = nil)
  if valid_39117716 != nil:
    section.add "repo", valid_39117716
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117717 = header.getOrDefault("Accept")
  valid_39117717 = validateParameter(valid_39117717, JString, required = false,
                                   default = nil)
  if valid_39117717 != nil:
    section.add "Accept", valid_39117717
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117718: Call_GetReposOwnerRepoStatsCommitActivity_39117712;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get the last year of commit activity data.
  ## Returns the last year of commit activity grouped by week. The days array
  ## is a group of commits per day, starting on Sunday.
  ## 
  ## 
  let valid = call_39117718.validator(path, query, header, formData, body, _)
  let scheme = call_39117718.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117718.url(scheme.get, call_39117718.host, call_39117718.base,
                           call_39117718.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117718, url, valid, _)

proc call*(call_39117719: Call_GetReposOwnerRepoStatsCommitActivity_39117712;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsCommitActivity
  ## Get the last year of commit activity data.
  ## Returns the last year of commit activity grouped by week. The days array
  ## is a group of commits per day, starting on Sunday.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117720 = newJObject()
  var header_39117721 = newJObject()
  add(path_39117720, "owner", newJString(owner))
  add(header_39117721, "Accept", newJString(Accept))
  add(path_39117720, "repo", newJString(repo))
  result = call_39117719.call(path_39117720, nil, header_39117721, nil, nil)

var getReposOwnerRepoStatsCommitActivity* = Call_GetReposOwnerRepoStatsCommitActivity_39117712(
    name: "getReposOwnerRepoStatsCommitActivity", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/commit_activity",
    validator: validate_GetReposOwnerRepoStatsCommitActivity_39117713, base: "/",
    url: url_GetReposOwnerRepoStatsCommitActivity_39117714,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsContributors_39117722 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoStatsContributors_39117724(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/contributors")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsContributors_39117723(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get contributors list with additions, deletions, and commit counts.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117725 = path.getOrDefault("owner")
  valid_39117725 = validateParameter(valid_39117725, JString, required = true,
                                   default = nil)
  if valid_39117725 != nil:
    section.add "owner", valid_39117725
  var valid_39117726 = path.getOrDefault("repo")
  valid_39117726 = validateParameter(valid_39117726, JString, required = true,
                                   default = nil)
  if valid_39117726 != nil:
    section.add "repo", valid_39117726
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117727 = header.getOrDefault("Accept")
  valid_39117727 = validateParameter(valid_39117727, JString, required = false,
                                   default = nil)
  if valid_39117727 != nil:
    section.add "Accept", valid_39117727
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117728: Call_GetReposOwnerRepoStatsContributors_39117722;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get contributors list with additions, deletions, and commit counts.
  ## 
  let valid = call_39117728.validator(path, query, header, formData, body, _)
  let scheme = call_39117728.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117728.url(scheme.get, call_39117728.host, call_39117728.base,
                           call_39117728.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117728, url, valid, _)

proc call*(call_39117729: Call_GetReposOwnerRepoStatsContributors_39117722;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsContributors
  ## Get contributors list with additions, deletions, and commit counts.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117730 = newJObject()
  var header_39117731 = newJObject()
  add(path_39117730, "owner", newJString(owner))
  add(header_39117731, "Accept", newJString(Accept))
  add(path_39117730, "repo", newJString(repo))
  result = call_39117729.call(path_39117730, nil, header_39117731, nil, nil)

var getReposOwnerRepoStatsContributors* = Call_GetReposOwnerRepoStatsContributors_39117722(
    name: "getReposOwnerRepoStatsContributors", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/contributors",
    validator: validate_GetReposOwnerRepoStatsContributors_39117723, base: "/",
    url: url_GetReposOwnerRepoStatsContributors_39117724, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsParticipation_39117732 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoStatsParticipation_39117734(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/participation")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsParticipation_39117733(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get the weekly commit count for the repo owner and everyone else.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117735 = path.getOrDefault("owner")
  valid_39117735 = validateParameter(valid_39117735, JString, required = true,
                                   default = nil)
  if valid_39117735 != nil:
    section.add "owner", valid_39117735
  var valid_39117736 = path.getOrDefault("repo")
  valid_39117736 = validateParameter(valid_39117736, JString, required = true,
                                   default = nil)
  if valid_39117736 != nil:
    section.add "repo", valid_39117736
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117737 = header.getOrDefault("Accept")
  valid_39117737 = validateParameter(valid_39117737, JString, required = false,
                                   default = nil)
  if valid_39117737 != nil:
    section.add "Accept", valid_39117737
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117738: Call_GetReposOwnerRepoStatsParticipation_39117732;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get the weekly commit count for the repo owner and everyone else.
  ## 
  let valid = call_39117738.validator(path, query, header, formData, body, _)
  let scheme = call_39117738.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117738.url(scheme.get, call_39117738.host, call_39117738.base,
                           call_39117738.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117738, url, valid, _)

proc call*(call_39117739: Call_GetReposOwnerRepoStatsParticipation_39117732;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsParticipation
  ## Get the weekly commit count for the repo owner and everyone else.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117740 = newJObject()
  var header_39117741 = newJObject()
  add(path_39117740, "owner", newJString(owner))
  add(header_39117741, "Accept", newJString(Accept))
  add(path_39117740, "repo", newJString(repo))
  result = call_39117739.call(path_39117740, nil, header_39117741, nil, nil)

var getReposOwnerRepoStatsParticipation* = Call_GetReposOwnerRepoStatsParticipation_39117732(
    name: "getReposOwnerRepoStatsParticipation", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/participation",
    validator: validate_GetReposOwnerRepoStatsParticipation_39117733, base: "/",
    url: url_GetReposOwnerRepoStatsParticipation_39117734, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsPunchCard_39117742 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoStatsPunchCard_39117744(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/stats/punch_card")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsPunchCard_39117743(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get the number of commits per hour in each day.
  ## Each array contains the day number, hour number, and number of commits
  ## 0-6 Sunday - Saturday
  ## 0-23 Hour of day
  ## Number of commits
  ## 
  ## For example, [2, 14, 25] indicates that there were 25 total commits, during
  ## the 2.00pm hour on Tuesdays. All times are based on the time zone of
  ## individual commits.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117745 = path.getOrDefault("owner")
  valid_39117745 = validateParameter(valid_39117745, JString, required = true,
                                   default = nil)
  if valid_39117745 != nil:
    section.add "owner", valid_39117745
  var valid_39117746 = path.getOrDefault("repo")
  valid_39117746 = validateParameter(valid_39117746, JString, required = true,
                                   default = nil)
  if valid_39117746 != nil:
    section.add "repo", valid_39117746
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117747 = header.getOrDefault("Accept")
  valid_39117747 = validateParameter(valid_39117747, JString, required = false,
                                   default = nil)
  if valid_39117747 != nil:
    section.add "Accept", valid_39117747
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117748: Call_GetReposOwnerRepoStatsPunchCard_39117742;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get the number of commits per hour in each day.
  ## Each array contains the day number, hour number, and number of commits
  ## 0-6 Sunday - Saturday
  ## 0-23 Hour of day
  ## Number of commits
  ## 
  ## For example, [2, 14, 25] indicates that there were 25 total commits, during
  ## the 2.00pm hour on Tuesdays. All times are based on the time zone of
  ## individual commits.
  ## 
  ## 
  let valid = call_39117748.validator(path, query, header, formData, body, _)
  let scheme = call_39117748.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117748.url(scheme.get, call_39117748.host, call_39117748.base,
                           call_39117748.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117748, url, valid, _)

proc call*(call_39117749: Call_GetReposOwnerRepoStatsPunchCard_39117742;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsPunchCard
  ## Get the number of commits per hour in each day.
  ## Each array contains the day number, hour number, and number of commits
  ## 0-6 Sunday - Saturday
  ## 0-23 Hour of day
  ## Number of commits
  ## 
  ## For example, [2, 14, 25] indicates that there were 25 total commits, during
  ## the 2.00pm hour on Tuesdays. All times are based on the time zone of
  ## individual commits.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117750 = newJObject()
  var header_39117751 = newJObject()
  add(path_39117750, "owner", newJString(owner))
  add(header_39117751, "Accept", newJString(Accept))
  add(path_39117750, "repo", newJString(repo))
  result = call_39117749.call(path_39117750, nil, header_39117751, nil, nil)

var getReposOwnerRepoStatsPunchCard* = Call_GetReposOwnerRepoStatsPunchCard_39117742(
    name: "getReposOwnerRepoStatsPunchCard", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/punch_card",
    validator: validate_GetReposOwnerRepoStatsPunchCard_39117743, base: "/",
    url: url_GetReposOwnerRepoStatsPunchCard_39117744, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoStatusesRef_39117763 = ref object of OpenApiRestCall_39115352
proc url_PostReposOwnerRepoStatusesRef_39117765(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/statuses/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoStatusesRef_39117764(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Create a Status.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   ref: JString (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117766 = path.getOrDefault("owner")
  valid_39117766 = validateParameter(valid_39117766, JString, required = true,
                                   default = nil)
  if valid_39117766 != nil:
    section.add "owner", valid_39117766
  var valid_39117767 = path.getOrDefault("ref")
  valid_39117767 = validateParameter(valid_39117767, JString, required = true,
                                   default = nil)
  if valid_39117767 != nil:
    section.add "ref", valid_39117767
  var valid_39117768 = path.getOrDefault("repo")
  valid_39117768 = validateParameter(valid_39117768, JString, required = true,
                                   default = nil)
  if valid_39117768 != nil:
    section.add "repo", valid_39117768
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117769 = header.getOrDefault("Accept")
  valid_39117769 = validateParameter(valid_39117769, JString, required = false,
                                   default = nil)
  if valid_39117769 != nil:
    section.add "Accept", valid_39117769
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39117771: Call_PostReposOwnerRepoStatusesRef_39117763;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a Status.
  ## 
  let valid = call_39117771.validator(path, query, header, formData, body, _)
  let scheme = call_39117771.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117771.url(scheme.get, call_39117771.host, call_39117771.base,
                           call_39117771.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117771, url, valid, _)

proc call*(call_39117772: Call_PostReposOwnerRepoStatusesRef_39117763;
          owner: string; `ref`: string; body: JsonNode; repo: string;
          Accept: string = ""): Recallable =
  ## postReposOwnerRepoStatusesRef
  ## Create a Status.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   ref: string (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117773 = newJObject()
  var header_39117774 = newJObject()
  var body_39117775 = newJObject()
  add(path_39117773, "owner", newJString(owner))
  add(path_39117773, "ref", newJString(`ref`))
  add(header_39117774, "Accept", newJString(Accept))
  if body != nil:
    body_39117775 = body
  add(path_39117773, "repo", newJString(repo))
  result = call_39117772.call(path_39117773, nil, header_39117774, nil, body_39117775)

var postReposOwnerRepoStatusesRef* = Call_PostReposOwnerRepoStatusesRef_39117763(
    name: "postReposOwnerRepoStatusesRef", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/statuses/{ref}",
    validator: validate_PostReposOwnerRepoStatusesRef_39117764, base: "/",
    url: url_PostReposOwnerRepoStatusesRef_39117765, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatusesRef_39117752 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoStatusesRef_39117754(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/statuses/"),
               (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatusesRef_39117753(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List Statuses for a specific Ref.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   ref: JString (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117755 = path.getOrDefault("owner")
  valid_39117755 = validateParameter(valid_39117755, JString, required = true,
                                   default = nil)
  if valid_39117755 != nil:
    section.add "owner", valid_39117755
  var valid_39117756 = path.getOrDefault("ref")
  valid_39117756 = validateParameter(valid_39117756, JString, required = true,
                                   default = nil)
  if valid_39117756 != nil:
    section.add "ref", valid_39117756
  var valid_39117757 = path.getOrDefault("repo")
  valid_39117757 = validateParameter(valid_39117757, JString, required = true,
                                   default = nil)
  if valid_39117757 != nil:
    section.add "repo", valid_39117757
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117758 = header.getOrDefault("Accept")
  valid_39117758 = validateParameter(valid_39117758, JString, required = false,
                                   default = nil)
  if valid_39117758 != nil:
    section.add "Accept", valid_39117758
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117759: Call_GetReposOwnerRepoStatusesRef_39117752;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List Statuses for a specific Ref.
  ## 
  let valid = call_39117759.validator(path, query, header, formData, body, _)
  let scheme = call_39117759.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117759.url(scheme.get, call_39117759.host, call_39117759.base,
                           call_39117759.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117759, url, valid, _)

proc call*(call_39117760: Call_GetReposOwnerRepoStatusesRef_39117752;
          owner: string; `ref`: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatusesRef
  ## List Statuses for a specific Ref.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   ref: string (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117761 = newJObject()
  var header_39117762 = newJObject()
  add(path_39117761, "owner", newJString(owner))
  add(path_39117761, "ref", newJString(`ref`))
  add(header_39117762, "Accept", newJString(Accept))
  add(path_39117761, "repo", newJString(repo))
  result = call_39117760.call(path_39117761, nil, header_39117762, nil, nil)

var getReposOwnerRepoStatusesRef* = Call_GetReposOwnerRepoStatusesRef_39117752(
    name: "getReposOwnerRepoStatusesRef", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/statuses/{ref}",
    validator: validate_GetReposOwnerRepoStatusesRef_39117753, base: "/",
    url: url_GetReposOwnerRepoStatusesRef_39117754, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoSubscribers_39117776 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoSubscribers_39117778(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/subscribers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoSubscribers_39117777(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List watchers.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117779 = path.getOrDefault("owner")
  valid_39117779 = validateParameter(valid_39117779, JString, required = true,
                                   default = nil)
  if valid_39117779 != nil:
    section.add "owner", valid_39117779
  var valid_39117780 = path.getOrDefault("repo")
  valid_39117780 = validateParameter(valid_39117780, JString, required = true,
                                   default = nil)
  if valid_39117780 != nil:
    section.add "repo", valid_39117780
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117781 = header.getOrDefault("Accept")
  valid_39117781 = validateParameter(valid_39117781, JString, required = false,
                                   default = nil)
  if valid_39117781 != nil:
    section.add "Accept", valid_39117781
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117782: Call_GetReposOwnerRepoSubscribers_39117776;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List watchers.
  ## 
  let valid = call_39117782.validator(path, query, header, formData, body, _)
  let scheme = call_39117782.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117782.url(scheme.get, call_39117782.host, call_39117782.base,
                           call_39117782.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117782, url, valid, _)

proc call*(call_39117783: Call_GetReposOwnerRepoSubscribers_39117776;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoSubscribers
  ## List watchers.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117784 = newJObject()
  var header_39117785 = newJObject()
  add(path_39117784, "owner", newJString(owner))
  add(header_39117785, "Accept", newJString(Accept))
  add(path_39117784, "repo", newJString(repo))
  result = call_39117783.call(path_39117784, nil, header_39117785, nil, nil)

var getReposOwnerRepoSubscribers* = Call_GetReposOwnerRepoSubscribers_39117776(
    name: "getReposOwnerRepoSubscribers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscribers",
    validator: validate_GetReposOwnerRepoSubscribers_39117777, base: "/",
    url: url_GetReposOwnerRepoSubscribers_39117778, schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoSubscription_39117796 = ref object of OpenApiRestCall_39115352
proc url_PutReposOwnerRepoSubscription_39117798(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoSubscription_39117797(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Set a Repository Subscription
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117799 = path.getOrDefault("owner")
  valid_39117799 = validateParameter(valid_39117799, JString, required = true,
                                   default = nil)
  if valid_39117799 != nil:
    section.add "owner", valid_39117799
  var valid_39117800 = path.getOrDefault("repo")
  valid_39117800 = validateParameter(valid_39117800, JString, required = true,
                                   default = nil)
  if valid_39117800 != nil:
    section.add "repo", valid_39117800
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117801 = header.getOrDefault("Accept")
  valid_39117801 = validateParameter(valid_39117801, JString, required = false,
                                   default = nil)
  if valid_39117801 != nil:
    section.add "Accept", valid_39117801
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39117803: Call_PutReposOwnerRepoSubscription_39117796;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Set a Repository Subscription
  ## 
  let valid = call_39117803.validator(path, query, header, formData, body, _)
  let scheme = call_39117803.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117803.url(scheme.get, call_39117803.host, call_39117803.base,
                           call_39117803.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117803, url, valid, _)

proc call*(call_39117804: Call_PutReposOwnerRepoSubscription_39117796;
          owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoSubscription
  ## Set a Repository Subscription
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117805 = newJObject()
  var header_39117806 = newJObject()
  var body_39117807 = newJObject()
  add(path_39117805, "owner", newJString(owner))
  add(header_39117806, "Accept", newJString(Accept))
  if body != nil:
    body_39117807 = body
  add(path_39117805, "repo", newJString(repo))
  result = call_39117804.call(path_39117805, nil, header_39117806, nil, body_39117807)

var putReposOwnerRepoSubscription* = Call_PutReposOwnerRepoSubscription_39117796(
    name: "putReposOwnerRepoSubscription", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscription",
    validator: validate_PutReposOwnerRepoSubscription_39117797, base: "/",
    url: url_PutReposOwnerRepoSubscription_39117798, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoSubscription_39117786 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoSubscription_39117788(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoSubscription_39117787(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get a Repository Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117789 = path.getOrDefault("owner")
  valid_39117789 = validateParameter(valid_39117789, JString, required = true,
                                   default = nil)
  if valid_39117789 != nil:
    section.add "owner", valid_39117789
  var valid_39117790 = path.getOrDefault("repo")
  valid_39117790 = validateParameter(valid_39117790, JString, required = true,
                                   default = nil)
  if valid_39117790 != nil:
    section.add "repo", valid_39117790
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117791 = header.getOrDefault("Accept")
  valid_39117791 = validateParameter(valid_39117791, JString, required = false,
                                   default = nil)
  if valid_39117791 != nil:
    section.add "Accept", valid_39117791
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117792: Call_GetReposOwnerRepoSubscription_39117786;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a Repository Subscription.
  ## 
  let valid = call_39117792.validator(path, query, header, formData, body, _)
  let scheme = call_39117792.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117792.url(scheme.get, call_39117792.host, call_39117792.base,
                           call_39117792.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117792, url, valid, _)

proc call*(call_39117793: Call_GetReposOwnerRepoSubscription_39117786;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoSubscription
  ## Get a Repository Subscription.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117794 = newJObject()
  var header_39117795 = newJObject()
  add(path_39117794, "owner", newJString(owner))
  add(header_39117795, "Accept", newJString(Accept))
  add(path_39117794, "repo", newJString(repo))
  result = call_39117793.call(path_39117794, nil, header_39117795, nil, nil)

var getReposOwnerRepoSubscription* = Call_GetReposOwnerRepoSubscription_39117786(
    name: "getReposOwnerRepoSubscription", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscription",
    validator: validate_GetReposOwnerRepoSubscription_39117787, base: "/",
    url: url_GetReposOwnerRepoSubscription_39117788, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoSubscription_39117808 = ref object of OpenApiRestCall_39115352
proc url_DeleteReposOwnerRepoSubscription_39117810(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoSubscription_39117809(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Delete a Repository Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117811 = path.getOrDefault("owner")
  valid_39117811 = validateParameter(valid_39117811, JString, required = true,
                                   default = nil)
  if valid_39117811 != nil:
    section.add "owner", valid_39117811
  var valid_39117812 = path.getOrDefault("repo")
  valid_39117812 = validateParameter(valid_39117812, JString, required = true,
                                   default = nil)
  if valid_39117812 != nil:
    section.add "repo", valid_39117812
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117813 = header.getOrDefault("Accept")
  valid_39117813 = validateParameter(valid_39117813, JString, required = false,
                                   default = nil)
  if valid_39117813 != nil:
    section.add "Accept", valid_39117813
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117814: Call_DeleteReposOwnerRepoSubscription_39117808;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a Repository Subscription.
  ## 
  let valid = call_39117814.validator(path, query, header, formData, body, _)
  let scheme = call_39117814.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117814.url(scheme.get, call_39117814.host, call_39117814.base,
                           call_39117814.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117814, url, valid, _)

proc call*(call_39117815: Call_DeleteReposOwnerRepoSubscription_39117808;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoSubscription
  ## Delete a Repository Subscription.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117816 = newJObject()
  var header_39117817 = newJObject()
  add(path_39117816, "owner", newJString(owner))
  add(header_39117817, "Accept", newJString(Accept))
  add(path_39117816, "repo", newJString(repo))
  result = call_39117815.call(path_39117816, nil, header_39117817, nil, nil)

var deleteReposOwnerRepoSubscription* = Call_DeleteReposOwnerRepoSubscription_39117808(
    name: "deleteReposOwnerRepoSubscription", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscription",
    validator: validate_DeleteReposOwnerRepoSubscription_39117809, base: "/",
    url: url_DeleteReposOwnerRepoSubscription_39117810, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoTags_39117818 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoTags_39117820(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/tags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoTags_39117819(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get list of tags.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117821 = path.getOrDefault("owner")
  valid_39117821 = validateParameter(valid_39117821, JString, required = true,
                                   default = nil)
  if valid_39117821 != nil:
    section.add "owner", valid_39117821
  var valid_39117822 = path.getOrDefault("repo")
  valid_39117822 = validateParameter(valid_39117822, JString, required = true,
                                   default = nil)
  if valid_39117822 != nil:
    section.add "repo", valid_39117822
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117823 = header.getOrDefault("Accept")
  valid_39117823 = validateParameter(valid_39117823, JString, required = false,
                                   default = nil)
  if valid_39117823 != nil:
    section.add "Accept", valid_39117823
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117824: Call_GetReposOwnerRepoTags_39117818;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get list of tags.
  ## 
  let valid = call_39117824.validator(path, query, header, formData, body, _)
  let scheme = call_39117824.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117824.url(scheme.get, call_39117824.host, call_39117824.base,
                           call_39117824.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117824, url, valid, _)

proc call*(call_39117825: Call_GetReposOwnerRepoTags_39117818; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoTags
  ## Get list of tags.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117826 = newJObject()
  var header_39117827 = newJObject()
  add(path_39117826, "owner", newJString(owner))
  add(header_39117827, "Accept", newJString(Accept))
  add(path_39117826, "repo", newJString(repo))
  result = call_39117825.call(path_39117826, nil, header_39117827, nil, nil)

var getReposOwnerRepoTags* = Call_GetReposOwnerRepoTags_39117818(
    name: "getReposOwnerRepoTags", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/repos/{owner}/{repo}/tags",
    validator: validate_GetReposOwnerRepoTags_39117819, base: "/",
    url: url_GetReposOwnerRepoTags_39117820, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoTeams_39117828 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoTeams_39117830(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/teams")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoTeams_39117829(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get list of teams
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117831 = path.getOrDefault("owner")
  valid_39117831 = validateParameter(valid_39117831, JString, required = true,
                                   default = nil)
  if valid_39117831 != nil:
    section.add "owner", valid_39117831
  var valid_39117832 = path.getOrDefault("repo")
  valid_39117832 = validateParameter(valid_39117832, JString, required = true,
                                   default = nil)
  if valid_39117832 != nil:
    section.add "repo", valid_39117832
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117833 = header.getOrDefault("Accept")
  valid_39117833 = validateParameter(valid_39117833, JString, required = false,
                                   default = nil)
  if valid_39117833 != nil:
    section.add "Accept", valid_39117833
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117834: Call_GetReposOwnerRepoTeams_39117828;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get list of teams
  ## 
  let valid = call_39117834.validator(path, query, header, formData, body, _)
  let scheme = call_39117834.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117834.url(scheme.get, call_39117834.host, call_39117834.base,
                           call_39117834.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117834, url, valid, _)

proc call*(call_39117835: Call_GetReposOwnerRepoTeams_39117828; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoTeams
  ## Get list of teams
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117836 = newJObject()
  var header_39117837 = newJObject()
  add(path_39117836, "owner", newJString(owner))
  add(header_39117837, "Accept", newJString(Accept))
  add(path_39117836, "repo", newJString(repo))
  result = call_39117835.call(path_39117836, nil, header_39117837, nil, nil)

var getReposOwnerRepoTeams* = Call_GetReposOwnerRepoTeams_39117828(
    name: "getReposOwnerRepoTeams", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/teams",
    validator: validate_GetReposOwnerRepoTeams_39117829, base: "/",
    url: url_GetReposOwnerRepoTeams_39117830, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoWatchers_39117838 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoWatchers_39117840(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/watchers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoWatchers_39117839(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List Stargazers. New implementation.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117841 = path.getOrDefault("owner")
  valid_39117841 = validateParameter(valid_39117841, JString, required = true,
                                   default = nil)
  if valid_39117841 != nil:
    section.add "owner", valid_39117841
  var valid_39117842 = path.getOrDefault("repo")
  valid_39117842 = validateParameter(valid_39117842, JString, required = true,
                                   default = nil)
  if valid_39117842 != nil:
    section.add "repo", valid_39117842
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117843 = header.getOrDefault("Accept")
  valid_39117843 = validateParameter(valid_39117843, JString, required = false,
                                   default = nil)
  if valid_39117843 != nil:
    section.add "Accept", valid_39117843
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117844: Call_GetReposOwnerRepoWatchers_39117838;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List Stargazers. New implementation.
  ## 
  let valid = call_39117844.validator(path, query, header, formData, body, _)
  let scheme = call_39117844.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117844.url(scheme.get, call_39117844.host, call_39117844.base,
                           call_39117844.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117844, url, valid, _)

proc call*(call_39117845: Call_GetReposOwnerRepoWatchers_39117838; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoWatchers
  ## List Stargazers. New implementation.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39117846 = newJObject()
  var header_39117847 = newJObject()
  add(path_39117846, "owner", newJString(owner))
  add(header_39117847, "Accept", newJString(Accept))
  add(path_39117846, "repo", newJString(repo))
  result = call_39117845.call(path_39117846, nil, header_39117847, nil, nil)

var getReposOwnerRepoWatchers* = Call_GetReposOwnerRepoWatchers_39117838(
    name: "getReposOwnerRepoWatchers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/watchers",
    validator: validate_GetReposOwnerRepoWatchers_39117839, base: "/",
    url: url_GetReposOwnerRepoWatchers_39117840, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoArchiveFormatPath_39117848 = ref object of OpenApiRestCall_39115352
proc url_GetReposOwnerRepoArchiveFormatPath_39117850(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "archive_format" in path, "`archive_format` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "archive_format"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoArchiveFormatPath_39117849(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get archive link.
  ## This method will return a 302 to a URL to download a tarball or zipball
  ## archive for a repository. Please make sure your HTTP framework is
  ## configured to follow redirects or you will need to use the Location header
  ## to make a second GET request.
  ## Note: For private repositories, these links are temporary and expire quickly.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   archive_format: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   path: JString (required)
  ##       : Valid Git reference, defaults to 'master'.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39117851 = path.getOrDefault("owner")
  valid_39117851 = validateParameter(valid_39117851, JString, required = true,
                                   default = nil)
  if valid_39117851 != nil:
    section.add "owner", valid_39117851
  var valid_39117852 = path.getOrDefault("archive_format")
  valid_39117852 = validateParameter(valid_39117852, JString, required = true,
                                   default = newJString("tarball"))
  if valid_39117852 != nil:
    section.add "archive_format", valid_39117852
  var valid_39117853 = path.getOrDefault("repo")
  valid_39117853 = validateParameter(valid_39117853, JString, required = true,
                                   default = nil)
  if valid_39117853 != nil:
    section.add "repo", valid_39117853
  var valid_39117854 = path.getOrDefault("path")
  valid_39117854 = validateParameter(valid_39117854, JString, required = true,
                                   default = nil)
  if valid_39117854 != nil:
    section.add "path", valid_39117854
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117855 = header.getOrDefault("Accept")
  valid_39117855 = validateParameter(valid_39117855, JString, required = false,
                                   default = nil)
  if valid_39117855 != nil:
    section.add "Accept", valid_39117855
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117856: Call_GetReposOwnerRepoArchiveFormatPath_39117848;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get archive link.
  ## This method will return a 302 to a URL to download a tarball or zipball
  ## archive for a repository. Please make sure your HTTP framework is
  ## configured to follow redirects or you will need to use the Location header
  ## to make a second GET request.
  ## Note: For private repositories, these links are temporary and expire quickly.
  ## 
  ## 
  let valid = call_39117856.validator(path, query, header, formData, body, _)
  let scheme = call_39117856.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117856.url(scheme.get, call_39117856.host, call_39117856.base,
                           call_39117856.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117856, url, valid, _)

proc call*(call_39117857: Call_GetReposOwnerRepoArchiveFormatPath_39117848;
          owner: string; repo: string; path: string;
          archiveFormat: string = "tarball"; Accept: string = ""): Recallable =
  ## getReposOwnerRepoArchiveFormatPath
  ## Get archive link.
  ## This method will return a 302 to a URL to download a tarball or zipball
  ## archive for a repository. Please make sure your HTTP framework is
  ## configured to follow redirects or you will need to use the Location header
  ## to make a second GET request.
  ## Note: For private repositories, these links are temporary and expire quickly.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   archiveFormat: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   path: string (required)
  ##       : Valid Git reference, defaults to 'master'.
  var path_39117858 = newJObject()
  var header_39117859 = newJObject()
  add(path_39117858, "owner", newJString(owner))
  add(path_39117858, "archive_format", newJString(archiveFormat))
  add(header_39117859, "Accept", newJString(Accept))
  add(path_39117858, "repo", newJString(repo))
  add(path_39117858, "path", newJString(path))
  result = call_39117857.call(path_39117858, nil, header_39117859, nil, nil)

var getReposOwnerRepoArchiveFormatPath* = Call_GetReposOwnerRepoArchiveFormatPath_39117848(
    name: "getReposOwnerRepoArchiveFormatPath", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/{archive_format}/{path}",
    validator: validate_GetReposOwnerRepoArchiveFormatPath_39117849, base: "/",
    url: url_GetReposOwnerRepoArchiveFormatPath_39117850, schemes: {Scheme.Https})
type
  Call_GetRepositories_39117860 = ref object of OpenApiRestCall_39115352
proc url_GetRepositories_39117862(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRepositories_39117861(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List all public repositories.
  ## This provides a dump of every public repository, in the order that they
  ## were created.
  ## Note: Pagination is powered exclusively by the since parameter. is the
  ## Link header to get the URL for the next page of repositories.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_39117863 = query.getOrDefault("since")
  valid_39117863 = validateParameter(valid_39117863, JString, required = false,
                                   default = nil)
  if valid_39117863 != nil:
    section.add "since", valid_39117863
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117864 = header.getOrDefault("Accept")
  valid_39117864 = validateParameter(valid_39117864, JString, required = false,
                                   default = nil)
  if valid_39117864 != nil:
    section.add "Accept", valid_39117864
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117865: Call_GetRepositories_39117860; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List all public repositories.
  ## This provides a dump of every public repository, in the order that they
  ## were created.
  ## Note: Pagination is powered exclusively by the since parameter. is the
  ## Link header to get the URL for the next page of repositories.
  ## 
  ## 
  let valid = call_39117865.validator(path, query, header, formData, body, _)
  let scheme = call_39117865.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117865.url(scheme.get, call_39117865.host, call_39117865.base,
                           call_39117865.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117865, url, valid, _)

proc call*(call_39117866: Call_GetRepositories_39117860; Accept: string = "";
          since: string = ""): Recallable =
  ## getRepositories
  ## List all public repositories.
  ## This provides a dump of every public repository, in the order that they
  ## were created.
  ## Note: Pagination is powered exclusively by the since parameter. is the
  ## Link header to get the URL for the next page of repositories.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var query_39117867 = newJObject()
  var header_39117868 = newJObject()
  add(header_39117868, "Accept", newJString(Accept))
  add(query_39117867, "since", newJString(since))
  result = call_39117866.call(nil, query_39117867, header_39117868, nil, nil)

var getRepositories* = Call_GetRepositories_39117860(name: "getRepositories",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/repositories",
    validator: validate_GetRepositories_39117861, base: "/",
    url: url_GetRepositories_39117862, schemes: {Scheme.Https})
type
  Call_GetSearchCode_39117869 = ref object of OpenApiRestCall_39115352
proc url_GetSearchCode_39117871(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchCode_39117870(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## Search code.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   sort: JString
  ##       : Can only be 'indexed', which indicates how recently a file has been indexed
  ## by the GitHub search infrastructure. If not provided, results are sorted
  ## by best match.
  ## 
  ##   q: JString (required)
  ##    : The search terms. This can be any combination of the supported code
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier
  ## you can restrict the search to just the file contents, the file path,
  ## or both.
  ## 'Languages' Searches code based on the language it's written in.
  ## 'Forks' Filters repositories based on the number of forks, and/or
  ## whether code from forked repositories should be included in the results
  ## at all.
  ## 'Size' Finds files that match a certain size (in bytes).
  ## 'Path' Specifies the path that the resulting file must be at.
  ## 'Extension' Matches files with a certain extension.
  ## 'Users' or 'Repositories' Limits searches to a specific user or repository.
  ## 
  section = newJObject()
  var valid_39117872 = query.getOrDefault("order")
  valid_39117872 = validateParameter(valid_39117872, JString, required = false,
                                   default = newJString("desc"))
  if valid_39117872 != nil:
    section.add "order", valid_39117872
  var valid_39117873 = query.getOrDefault("sort")
  valid_39117873 = validateParameter(valid_39117873, JString, required = false,
                                   default = newJString("indexed"))
  if valid_39117873 != nil:
    section.add "sort", valid_39117873
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_39117874 = query.getOrDefault("q")
  valid_39117874 = validateParameter(valid_39117874, JString, required = true,
                                   default = nil)
  if valid_39117874 != nil:
    section.add "q", valid_39117874
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117875 = header.getOrDefault("Accept")
  valid_39117875 = validateParameter(valid_39117875, JString, required = false,
                                   default = nil)
  if valid_39117875 != nil:
    section.add "Accept", valid_39117875
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117876: Call_GetSearchCode_39117869; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Search code.
  ## 
  let valid = call_39117876.validator(path, query, header, formData, body, _)
  let scheme = call_39117876.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117876.url(scheme.get, call_39117876.host, call_39117876.base,
                           call_39117876.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117876, url, valid, _)

proc call*(call_39117877: Call_GetSearchCode_39117869; q: string;
          order: string = "desc"; Accept: string = ""; sort: string = "indexed"): Recallable =
  ## getSearchCode
  ## Search code.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##       : Can only be 'indexed', which indicates how recently a file has been indexed
  ## by the GitHub search infrastructure. If not provided, results are sorted
  ## by best match.
  ## 
  ##   q: string (required)
  ##    : The search terms. This can be any combination of the supported code
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier
  ## you can restrict the search to just the file contents, the file path,
  ## or both.
  ## 'Languages' Searches code based on the language it's written in.
  ## 'Forks' Filters repositories based on the number of forks, and/or
  ## whether code from forked repositories should be included in the results
  ## at all.
  ## 'Size' Finds files that match a certain size (in bytes).
  ## 'Path' Specifies the path that the resulting file must be at.
  ## 'Extension' Matches files with a certain extension.
  ## 'Users' or 'Repositories' Limits searches to a specific user or repository.
  ## 
  var query_39117878 = newJObject()
  var header_39117879 = newJObject()
  add(query_39117878, "order", newJString(order))
  add(header_39117879, "Accept", newJString(Accept))
  add(query_39117878, "sort", newJString(sort))
  add(query_39117878, "q", newJString(q))
  result = call_39117877.call(nil, query_39117878, header_39117879, nil, nil)

var getSearchCode* = Call_GetSearchCode_39117869(name: "getSearchCode",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/search/code",
    validator: validate_GetSearchCode_39117870, base: "/", url: url_GetSearchCode_39117871,
    schemes: {Scheme.Https})
type
  Call_GetSearchIssues_39117880 = ref object of OpenApiRestCall_39115352
proc url_GetSearchIssues_39117882(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchIssues_39117881(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Find issues by state and keyword. (This method returns up to 100 results per page.)
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   sort: JString
  ##       : The sort field. Can be comments, created, or updated. Default: results are sorted by best match.
  ##   q: JString (required)
  ##    : The q search term can also contain any combination of the supported issue search qualifiers:
  section = newJObject()
  var valid_39117883 = query.getOrDefault("order")
  valid_39117883 = validateParameter(valid_39117883, JString, required = false,
                                   default = newJString("desc"))
  if valid_39117883 != nil:
    section.add "order", valid_39117883
  var valid_39117884 = query.getOrDefault("sort")
  valid_39117884 = validateParameter(valid_39117884, JString, required = false,
                                   default = newJString("updated"))
  if valid_39117884 != nil:
    section.add "sort", valid_39117884
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_39117885 = query.getOrDefault("q")
  valid_39117885 = validateParameter(valid_39117885, JString, required = true,
                                   default = nil)
  if valid_39117885 != nil:
    section.add "q", valid_39117885
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117886 = header.getOrDefault("Accept")
  valid_39117886 = validateParameter(valid_39117886, JString, required = false,
                                   default = nil)
  if valid_39117886 != nil:
    section.add "Accept", valid_39117886
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117887: Call_GetSearchIssues_39117880; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Find issues by state and keyword. (This method returns up to 100 results per page.)
  ## 
  let valid = call_39117887.validator(path, query, header, formData, body, _)
  let scheme = call_39117887.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117887.url(scheme.get, call_39117887.host, call_39117887.base,
                           call_39117887.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117887, url, valid, _)

proc call*(call_39117888: Call_GetSearchIssues_39117880; q: string;
          order: string = "desc"; Accept: string = ""; sort: string = "updated"): Recallable =
  ## getSearchIssues
  ## Find issues by state and keyword. (This method returns up to 100 results per page.)
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##       : The sort field. Can be comments, created, or updated. Default: results are sorted by best match.
  ##   q: string (required)
  ##    : The q search term can also contain any combination of the supported issue search qualifiers:
  var query_39117889 = newJObject()
  var header_39117890 = newJObject()
  add(query_39117889, "order", newJString(order))
  add(header_39117890, "Accept", newJString(Accept))
  add(query_39117889, "sort", newJString(sort))
  add(query_39117889, "q", newJString(q))
  result = call_39117888.call(nil, query_39117889, header_39117890, nil, nil)

var getSearchIssues* = Call_GetSearchIssues_39117880(name: "getSearchIssues",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/search/issues",
    validator: validate_GetSearchIssues_39117881, base: "/",
    url: url_GetSearchIssues_39117882, schemes: {Scheme.Https})
type
  Call_GetSearchRepositories_39117891 = ref object of OpenApiRestCall_39115352
proc url_GetSearchRepositories_39117893(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchRepositories_39117892(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Search repositories.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   sort: JString
  ##       : If not provided, results are sorted by best match.
  ##   q: JString (required)
  ##    : The search terms. This can be any combination of the supported repository
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the repository name, description, readme,
  ## or any combination of these.
  ## 'Size' Finds repositories that match a certain size (in kilobytes).
  ## 'Forks' Filters repositories based on the number of forks, and/or whether
  ## forked repositories should be included in the results at all.
  ## 'Created' and 'Last Updated' Filters repositories based on times of
  ## creation, or when they were last updated.
  ## 'Users or Repositories' Limits searches to a specific user or repository.
  ## 'Languages' Searches repositories based on the language they are written in.
  ## 'Stars' Searches repositories based on the number of stars.
  ## 
  section = newJObject()
  var valid_39117894 = query.getOrDefault("order")
  valid_39117894 = validateParameter(valid_39117894, JString, required = false,
                                   default = newJString("desc"))
  if valid_39117894 != nil:
    section.add "order", valid_39117894
  var valid_39117895 = query.getOrDefault("sort")
  valid_39117895 = validateParameter(valid_39117895, JString, required = false,
                                   default = newJString("stars"))
  if valid_39117895 != nil:
    section.add "sort", valid_39117895
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_39117896 = query.getOrDefault("q")
  valid_39117896 = validateParameter(valid_39117896, JString, required = true,
                                   default = nil)
  if valid_39117896 != nil:
    section.add "q", valid_39117896
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117897 = header.getOrDefault("Accept")
  valid_39117897 = validateParameter(valid_39117897, JString, required = false,
                                   default = nil)
  if valid_39117897 != nil:
    section.add "Accept", valid_39117897
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117898: Call_GetSearchRepositories_39117891;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Search repositories.
  ## 
  let valid = call_39117898.validator(path, query, header, formData, body, _)
  let scheme = call_39117898.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117898.url(scheme.get, call_39117898.host, call_39117898.base,
                           call_39117898.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117898, url, valid, _)

proc call*(call_39117899: Call_GetSearchRepositories_39117891; q: string;
          order: string = "desc"; Accept: string = ""; sort: string = "stars"): Recallable =
  ## getSearchRepositories
  ## Search repositories.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##       : If not provided, results are sorted by best match.
  ##   q: string (required)
  ##    : The search terms. This can be any combination of the supported repository
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the repository name, description, readme,
  ## or any combination of these.
  ## 'Size' Finds repositories that match a certain size (in kilobytes).
  ## 'Forks' Filters repositories based on the number of forks, and/or whether
  ## forked repositories should be included in the results at all.
  ## 'Created' and 'Last Updated' Filters repositories based on times of
  ## creation, or when they were last updated.
  ## 'Users or Repositories' Limits searches to a specific user or repository.
  ## 'Languages' Searches repositories based on the language they are written in.
  ## 'Stars' Searches repositories based on the number of stars.
  ## 
  var query_39117900 = newJObject()
  var header_39117901 = newJObject()
  add(query_39117900, "order", newJString(order))
  add(header_39117901, "Accept", newJString(Accept))
  add(query_39117900, "sort", newJString(sort))
  add(query_39117900, "q", newJString(q))
  result = call_39117899.call(nil, query_39117900, header_39117901, nil, nil)

var getSearchRepositories* = Call_GetSearchRepositories_39117891(
    name: "getSearchRepositories", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/search/repositories", validator: validate_GetSearchRepositories_39117892,
    base: "/", url: url_GetSearchRepositories_39117893, schemes: {Scheme.Https})
type
  Call_GetSearchUsers_39117902 = ref object of OpenApiRestCall_39115352
proc url_GetSearchUsers_39117904(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchUsers_39117903(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Search users.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   sort: JString
  ##       : If not provided, results are sorted by best match.
  ##   q: JString (required)
  ##    : The search terms. This can be any combination of the supported user
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the username, public email, full name,
  ## location, or any combination of these.
  ## 'Repository count' Filters users based on the number of repositories they
  ## have.
  ## 'Location' Filter users by the location indicated in their profile.
  ## 'Language' Search for users that have repositories that match a certain
  ## language.
  ## 'Created' Filter users based on when they joined.
  ## 'Followers' Filter users based on the number of followers they have.
  ## 
  section = newJObject()
  var valid_39117905 = query.getOrDefault("order")
  valid_39117905 = validateParameter(valid_39117905, JString, required = false,
                                   default = newJString("desc"))
  if valid_39117905 != nil:
    section.add "order", valid_39117905
  var valid_39117906 = query.getOrDefault("sort")
  valid_39117906 = validateParameter(valid_39117906, JString, required = false,
                                   default = newJString("followers"))
  if valid_39117906 != nil:
    section.add "sort", valid_39117906
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_39117907 = query.getOrDefault("q")
  valid_39117907 = validateParameter(valid_39117907, JString, required = true,
                                   default = nil)
  if valid_39117907 != nil:
    section.add "q", valid_39117907
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117908 = header.getOrDefault("Accept")
  valid_39117908 = validateParameter(valid_39117908, JString, required = false,
                                   default = nil)
  if valid_39117908 != nil:
    section.add "Accept", valid_39117908
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117909: Call_GetSearchUsers_39117902; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Search users.
  ## 
  let valid = call_39117909.validator(path, query, header, formData, body, _)
  let scheme = call_39117909.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117909.url(scheme.get, call_39117909.host, call_39117909.base,
                           call_39117909.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117909, url, valid, _)

proc call*(call_39117910: Call_GetSearchUsers_39117902; q: string;
          order: string = "desc"; Accept: string = ""; sort: string = "followers"): Recallable =
  ## getSearchUsers
  ## Search users.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##       : If not provided, results are sorted by best match.
  ##   q: string (required)
  ##    : The search terms. This can be any combination of the supported user
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the username, public email, full name,
  ## location, or any combination of these.
  ## 'Repository count' Filters users based on the number of repositories they
  ## have.
  ## 'Location' Filter users by the location indicated in their profile.
  ## 'Language' Search for users that have repositories that match a certain
  ## language.
  ## 'Created' Filter users based on when they joined.
  ## 'Followers' Filter users based on the number of followers they have.
  ## 
  var query_39117911 = newJObject()
  var header_39117912 = newJObject()
  add(query_39117911, "order", newJString(order))
  add(header_39117912, "Accept", newJString(Accept))
  add(query_39117911, "sort", newJString(sort))
  add(query_39117911, "q", newJString(q))
  result = call_39117910.call(nil, query_39117911, header_39117912, nil, nil)

var getSearchUsers* = Call_GetSearchUsers_39117902(name: "getSearchUsers",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/search/users",
    validator: validate_GetSearchUsers_39117903, base: "/", url: url_GetSearchUsers_39117904,
    schemes: {Scheme.Https})
type
  Call_GetTeamsTeamId_39117913 = ref object of OpenApiRestCall_39115352
proc url_GetTeamsTeamId_39117915(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamId_39117914(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get team.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_39117916 = path.getOrDefault("teamId")
  valid_39117916 = validateParameter(valid_39117916, JInt, required = true,
                                   default = nil)
  if valid_39117916 != nil:
    section.add "teamId", valid_39117916
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117917 = header.getOrDefault("Accept")
  valid_39117917 = validateParameter(valid_39117917, JString, required = false,
                                   default = nil)
  if valid_39117917 != nil:
    section.add "Accept", valid_39117917
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117918: Call_GetTeamsTeamId_39117913; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get team.
  ## 
  let valid = call_39117918.validator(path, query, header, formData, body, _)
  let scheme = call_39117918.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117918.url(scheme.get, call_39117918.host, call_39117918.base,
                           call_39117918.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117918, url, valid, _)

proc call*(call_39117919: Call_GetTeamsTeamId_39117913; teamId: int;
          Accept: string = ""): Recallable =
  ## getTeamsTeamId
  ## Get team.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_39117920 = newJObject()
  var header_39117921 = newJObject()
  add(header_39117921, "Accept", newJString(Accept))
  add(path_39117920, "teamId", newJInt(teamId))
  result = call_39117919.call(path_39117920, nil, header_39117921, nil, nil)

var getTeamsTeamId* = Call_GetTeamsTeamId_39117913(name: "getTeamsTeamId",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/teams/{teamId}",
    validator: validate_GetTeamsTeamId_39117914, base: "/", url: url_GetTeamsTeamId_39117915,
    schemes: {Scheme.Https})
type
  Call_PatchTeamsTeamId_39117931 = ref object of OpenApiRestCall_39115352
proc url_PatchTeamsTeamId_39117933(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchTeamsTeamId_39117932(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Edit team.
  ## In order to edit a team, the authenticated user must be an owner of the org
  ## that the team is associated with.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_39117934 = path.getOrDefault("teamId")
  valid_39117934 = validateParameter(valid_39117934, JInt, required = true,
                                   default = nil)
  if valid_39117934 != nil:
    section.add "teamId", valid_39117934
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117935 = header.getOrDefault("Accept")
  valid_39117935 = validateParameter(valid_39117935, JString, required = false,
                                   default = nil)
  if valid_39117935 != nil:
    section.add "Accept", valid_39117935
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39117937: Call_PatchTeamsTeamId_39117931; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Edit team.
  ## In order to edit a team, the authenticated user must be an owner of the org
  ## that the team is associated with.
  ## 
  ## 
  let valid = call_39117937.validator(path, query, header, formData, body, _)
  let scheme = call_39117937.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117937.url(scheme.get, call_39117937.host, call_39117937.base,
                           call_39117937.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117937, url, valid, _)

proc call*(call_39117938: Call_PatchTeamsTeamId_39117931; body: JsonNode;
          teamId: int; Accept: string = ""): Recallable =
  ## patchTeamsTeamId
  ## Edit team.
  ## In order to edit a team, the authenticated user must be an owner of the org
  ## that the team is associated with.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   teamId: int (required)
  ##         : Id of team.
  var path_39117939 = newJObject()
  var header_39117940 = newJObject()
  var body_39117941 = newJObject()
  add(header_39117940, "Accept", newJString(Accept))
  if body != nil:
    body_39117941 = body
  add(path_39117939, "teamId", newJInt(teamId))
  result = call_39117938.call(path_39117939, nil, header_39117940, nil, body_39117941)

var patchTeamsTeamId* = Call_PatchTeamsTeamId_39117931(name: "patchTeamsTeamId",
    meth: HttpMethod.HttpPatch, host: "api.github.com", route: "/teams/{teamId}",
    validator: validate_PatchTeamsTeamId_39117932, base: "/",
    url: url_PatchTeamsTeamId_39117933, schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamId_39117922 = ref object of OpenApiRestCall_39115352
proc url_DeleteTeamsTeamId_39117924(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamId_39117923(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Delete team.
  ## In order to delete a team, the authenticated user must be an owner of the
  ## org that the team is associated with.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_39117925 = path.getOrDefault("teamId")
  valid_39117925 = validateParameter(valid_39117925, JInt, required = true,
                                   default = nil)
  if valid_39117925 != nil:
    section.add "teamId", valid_39117925
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117926 = header.getOrDefault("Accept")
  valid_39117926 = validateParameter(valid_39117926, JString, required = false,
                                   default = nil)
  if valid_39117926 != nil:
    section.add "Accept", valid_39117926
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117927: Call_DeleteTeamsTeamId_39117922; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete team.
  ## In order to delete a team, the authenticated user must be an owner of the
  ## org that the team is associated with.
  ## 
  ## 
  let valid = call_39117927.validator(path, query, header, formData, body, _)
  let scheme = call_39117927.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117927.url(scheme.get, call_39117927.host, call_39117927.base,
                           call_39117927.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117927, url, valid, _)

proc call*(call_39117928: Call_DeleteTeamsTeamId_39117922; teamId: int;
          Accept: string = ""): Recallable =
  ## deleteTeamsTeamId
  ## Delete team.
  ## In order to delete a team, the authenticated user must be an owner of the
  ## org that the team is associated with.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_39117929 = newJObject()
  var header_39117930 = newJObject()
  add(header_39117930, "Accept", newJString(Accept))
  add(path_39117929, "teamId", newJInt(teamId))
  result = call_39117928.call(path_39117929, nil, header_39117930, nil, nil)

var deleteTeamsTeamId* = Call_DeleteTeamsTeamId_39117922(name: "deleteTeamsTeamId",
    meth: HttpMethod.HttpDelete, host: "api.github.com", route: "/teams/{teamId}",
    validator: validate_DeleteTeamsTeamId_39117923, base: "/",
    url: url_DeleteTeamsTeamId_39117924, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdMembers_39117942 = ref object of OpenApiRestCall_39115352
proc url_GetTeamsTeamIdMembers_39117944(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/members")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdMembers_39117943(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List team members.
  ## In order to list members in a team, the authenticated user must be a member
  ## of the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_39117945 = path.getOrDefault("teamId")
  valid_39117945 = validateParameter(valid_39117945, JInt, required = true,
                                   default = nil)
  if valid_39117945 != nil:
    section.add "teamId", valid_39117945
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117946 = header.getOrDefault("Accept")
  valid_39117946 = validateParameter(valid_39117946, JString, required = false,
                                   default = nil)
  if valid_39117946 != nil:
    section.add "Accept", valid_39117946
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117947: Call_GetTeamsTeamIdMembers_39117942;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List team members.
  ## In order to list members in a team, the authenticated user must be a member
  ## of the team.
  ## 
  ## 
  let valid = call_39117947.validator(path, query, header, formData, body, _)
  let scheme = call_39117947.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117947.url(scheme.get, call_39117947.host, call_39117947.base,
                           call_39117947.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117947, url, valid, _)

proc call*(call_39117948: Call_GetTeamsTeamIdMembers_39117942; teamId: int;
          Accept: string = ""): Recallable =
  ## getTeamsTeamIdMembers
  ## List team members.
  ## In order to list members in a team, the authenticated user must be a member
  ## of the team.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_39117949 = newJObject()
  var header_39117950 = newJObject()
  add(header_39117950, "Accept", newJString(Accept))
  add(path_39117949, "teamId", newJInt(teamId))
  result = call_39117948.call(path_39117949, nil, header_39117950, nil, nil)

var getTeamsTeamIdMembers* = Call_GetTeamsTeamIdMembers_39117942(
    name: "getTeamsTeamIdMembers", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/teams/{teamId}/members", validator: validate_GetTeamsTeamIdMembers_39117943,
    base: "/", url: url_GetTeamsTeamIdMembers_39117944, schemes: {Scheme.Https})
type
  Call_PutTeamsTeamIdMembersUsername_39117961 = ref object of OpenApiRestCall_39115352
proc url_PutTeamsTeamIdMembersUsername_39117963(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutTeamsTeamIdMembersUsername_39117962(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## The API (described below) is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Add team membership API instead. It allows you to invite new organization members to your teams.
  ## 
  ## Add team member.
  ## In order to add a user to a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39117964 = path.getOrDefault("username")
  valid_39117964 = validateParameter(valid_39117964, JString, required = true,
                                   default = nil)
  if valid_39117964 != nil:
    section.add "username", valid_39117964
  var valid_39117965 = path.getOrDefault("teamId")
  valid_39117965 = validateParameter(valid_39117965, JInt, required = true,
                                   default = nil)
  if valid_39117965 != nil:
    section.add "teamId", valid_39117965
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117966 = header.getOrDefault("Accept")
  valid_39117966 = validateParameter(valid_39117966, JString, required = false,
                                   default = nil)
  if valid_39117966 != nil:
    section.add "Accept", valid_39117966
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117967: Call_PutTeamsTeamIdMembersUsername_39117961;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## The API (described below) is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Add team membership API instead. It allows you to invite new organization members to your teams.
  ## 
  ## Add team member.
  ## In order to add a user to a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## 
  ## 
  let valid = call_39117967.validator(path, query, header, formData, body, _)
  let scheme = call_39117967.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117967.url(scheme.get, call_39117967.host, call_39117967.base,
                           call_39117967.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117967, url, valid, _)

proc call*(call_39117968: Call_PutTeamsTeamIdMembersUsername_39117961;
          username: string; teamId: int; Accept: string = ""): Recallable =
  ## putTeamsTeamIdMembersUsername
  ## The API (described below) is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Add team membership API instead. It allows you to invite new organization members to your teams.
  ## 
  ## Add team member.
  ## In order to add a user to a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_39117969 = newJObject()
  var header_39117970 = newJObject()
  add(path_39117969, "username", newJString(username))
  add(header_39117970, "Accept", newJString(Accept))
  add(path_39117969, "teamId", newJInt(teamId))
  result = call_39117968.call(path_39117969, nil, header_39117970, nil, nil)

var putTeamsTeamIdMembersUsername* = Call_PutTeamsTeamIdMembersUsername_39117961(
    name: "putTeamsTeamIdMembersUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/teams/{teamId}/members/{username}",
    validator: validate_PutTeamsTeamIdMembersUsername_39117962, base: "/",
    url: url_PutTeamsTeamIdMembersUsername_39117963, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdMembersUsername_39117951 = ref object of OpenApiRestCall_39115352
proc url_GetTeamsTeamIdMembersUsername_39117953(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdMembersUsername_39117952(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## The "Get team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Get team membership API instead. It allows you to get both active and pending memberships.
  ## 
  ## Get team member.
  ## In order to get if a user is a member of a team, the authenticated user mus
  ## be a member of the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39117954 = path.getOrDefault("username")
  valid_39117954 = validateParameter(valid_39117954, JString, required = true,
                                   default = nil)
  if valid_39117954 != nil:
    section.add "username", valid_39117954
  var valid_39117955 = path.getOrDefault("teamId")
  valid_39117955 = validateParameter(valid_39117955, JInt, required = true,
                                   default = nil)
  if valid_39117955 != nil:
    section.add "teamId", valid_39117955
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117956 = header.getOrDefault("Accept")
  valid_39117956 = validateParameter(valid_39117956, JString, required = false,
                                   default = nil)
  if valid_39117956 != nil:
    section.add "Accept", valid_39117956
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117957: Call_GetTeamsTeamIdMembersUsername_39117951;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## The "Get team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Get team membership API instead. It allows you to get both active and pending memberships.
  ## 
  ## Get team member.
  ## In order to get if a user is a member of a team, the authenticated user mus
  ## be a member of the team.
  ## 
  ## 
  let valid = call_39117957.validator(path, query, header, formData, body, _)
  let scheme = call_39117957.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117957.url(scheme.get, call_39117957.host, call_39117957.base,
                           call_39117957.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117957, url, valid, _)

proc call*(call_39117958: Call_GetTeamsTeamIdMembersUsername_39117951;
          username: string; teamId: int; Accept: string = ""): Recallable =
  ## getTeamsTeamIdMembersUsername
  ## The "Get team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Get team membership API instead. It allows you to get both active and pending memberships.
  ## 
  ## Get team member.
  ## In order to get if a user is a member of a team, the authenticated user mus
  ## be a member of the team.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_39117959 = newJObject()
  var header_39117960 = newJObject()
  add(path_39117959, "username", newJString(username))
  add(header_39117960, "Accept", newJString(Accept))
  add(path_39117959, "teamId", newJInt(teamId))
  result = call_39117958.call(path_39117959, nil, header_39117960, nil, nil)

var getTeamsTeamIdMembersUsername* = Call_GetTeamsTeamIdMembersUsername_39117951(
    name: "getTeamsTeamIdMembersUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/teams/{teamId}/members/{username}",
    validator: validate_GetTeamsTeamIdMembersUsername_39117952, base: "/",
    url: url_GetTeamsTeamIdMembersUsername_39117953, schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamIdMembersUsername_39117971 = ref object of OpenApiRestCall_39115352
proc url_DeleteTeamsTeamIdMembersUsername_39117973(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/members/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamIdMembersUsername_39117972(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## The "Remove team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Remove team membership API instead. It allows you to remove both active and pending memberships.
  ## 
  ## Remove team member.
  ## In order to remove a user from a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## NOTE This does not delete the user, it just remove them from the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39117974 = path.getOrDefault("username")
  valid_39117974 = validateParameter(valid_39117974, JString, required = true,
                                   default = nil)
  if valid_39117974 != nil:
    section.add "username", valid_39117974
  var valid_39117975 = path.getOrDefault("teamId")
  valid_39117975 = validateParameter(valid_39117975, JInt, required = true,
                                   default = nil)
  if valid_39117975 != nil:
    section.add "teamId", valid_39117975
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117976 = header.getOrDefault("Accept")
  valid_39117976 = validateParameter(valid_39117976, JString, required = false,
                                   default = nil)
  if valid_39117976 != nil:
    section.add "Accept", valid_39117976
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117977: Call_DeleteTeamsTeamIdMembersUsername_39117971;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## The "Remove team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Remove team membership API instead. It allows you to remove both active and pending memberships.
  ## 
  ## Remove team member.
  ## In order to remove a user from a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## NOTE This does not delete the user, it just remove them from the team.
  ## 
  ## 
  let valid = call_39117977.validator(path, query, header, formData, body, _)
  let scheme = call_39117977.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117977.url(scheme.get, call_39117977.host, call_39117977.base,
                           call_39117977.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117977, url, valid, _)

proc call*(call_39117978: Call_DeleteTeamsTeamIdMembersUsername_39117971;
          username: string; teamId: int; Accept: string = ""): Recallable =
  ## deleteTeamsTeamIdMembersUsername
  ## The "Remove team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Remove team membership API instead. It allows you to remove both active and pending memberships.
  ## 
  ## Remove team member.
  ## In order to remove a user from a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## NOTE This does not delete the user, it just remove them from the team.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_39117979 = newJObject()
  var header_39117980 = newJObject()
  add(path_39117979, "username", newJString(username))
  add(header_39117980, "Accept", newJString(Accept))
  add(path_39117979, "teamId", newJInt(teamId))
  result = call_39117978.call(path_39117979, nil, header_39117980, nil, nil)

var deleteTeamsTeamIdMembersUsername* = Call_DeleteTeamsTeamIdMembersUsername_39117971(
    name: "deleteTeamsTeamIdMembersUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/teams/{teamId}/members/{username}",
    validator: validate_DeleteTeamsTeamIdMembersUsername_39117972, base: "/",
    url: url_DeleteTeamsTeamIdMembersUsername_39117973, schemes: {Scheme.Https})
type
  Call_PutTeamsTeamIdMembershipsUsername_39117991 = ref object of OpenApiRestCall_39115352
proc url_PutTeamsTeamIdMembershipsUsername_39117993(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/memberships/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutTeamsTeamIdMembershipsUsername_39117992(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Add team membership.
  ## In order to add a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with.
  ## 
  ## If the user is already a part of the team's organization (meaning they're on at least one other team in the organization), this endpoint will add the user to the team.
  ## 
  ## If the user is completely unaffiliated with the team's organization (meaning they're on none of the organization's teams), this endpoint will send an invitation to the user via email. This newly-created membership will be in the 'pending' state until the user accepts the invitation, at which point the membership will transition to the 'active' state and the user will be added as a member of the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39117994 = path.getOrDefault("username")
  valid_39117994 = validateParameter(valid_39117994, JString, required = true,
                                   default = nil)
  if valid_39117994 != nil:
    section.add "username", valid_39117994
  var valid_39117995 = path.getOrDefault("teamId")
  valid_39117995 = validateParameter(valid_39117995, JInt, required = true,
                                   default = nil)
  if valid_39117995 != nil:
    section.add "teamId", valid_39117995
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117996 = header.getOrDefault("Accept")
  valid_39117996 = validateParameter(valid_39117996, JString, required = false,
                                   default = nil)
  if valid_39117996 != nil:
    section.add "Accept", valid_39117996
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117997: Call_PutTeamsTeamIdMembershipsUsername_39117991;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Add team membership.
  ## In order to add a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with.
  ## 
  ## If the user is already a part of the team's organization (meaning they're on at least one other team in the organization), this endpoint will add the user to the team.
  ## 
  ## If the user is completely unaffiliated with the team's organization (meaning they're on none of the organization's teams), this endpoint will send an invitation to the user via email. This newly-created membership will be in the 'pending' state until the user accepts the invitation, at which point the membership will transition to the 'active' state and the user will be added as a member of the team.
  ## 
  ## 
  let valid = call_39117997.validator(path, query, header, formData, body, _)
  let scheme = call_39117997.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117997.url(scheme.get, call_39117997.host, call_39117997.base,
                           call_39117997.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117997, url, valid, _)

proc call*(call_39117998: Call_PutTeamsTeamIdMembershipsUsername_39117991;
          username: string; teamId: int; Accept: string = ""): Recallable =
  ## putTeamsTeamIdMembershipsUsername
  ## Add team membership.
  ## In order to add a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with.
  ## 
  ## If the user is already a part of the team's organization (meaning they're on at least one other team in the organization), this endpoint will add the user to the team.
  ## 
  ## If the user is completely unaffiliated with the team's organization (meaning they're on none of the organization's teams), this endpoint will send an invitation to the user via email. This newly-created membership will be in the 'pending' state until the user accepts the invitation, at which point the membership will transition to the 'active' state and the user will be added as a member of the team.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_39117999 = newJObject()
  var header_39118000 = newJObject()
  add(path_39117999, "username", newJString(username))
  add(header_39118000, "Accept", newJString(Accept))
  add(path_39117999, "teamId", newJInt(teamId))
  result = call_39117998.call(path_39117999, nil, header_39118000, nil, nil)

var putTeamsTeamIdMembershipsUsername* = Call_PutTeamsTeamIdMembershipsUsername_39117991(
    name: "putTeamsTeamIdMembershipsUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/teams/{teamId}/memberships/{username}",
    validator: validate_PutTeamsTeamIdMembershipsUsername_39117992, base: "/",
    url: url_PutTeamsTeamIdMembershipsUsername_39117993, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdMembershipsUsername_39117981 = ref object of OpenApiRestCall_39115352
proc url_GetTeamsTeamIdMembershipsUsername_39117983(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/memberships/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdMembershipsUsername_39117982(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Get team membership.
  ## In order to get a user's membership with a team, the authenticated user must be a member of the team or an owner of the team's organization.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39117984 = path.getOrDefault("username")
  valid_39117984 = validateParameter(valid_39117984, JString, required = true,
                                   default = nil)
  if valid_39117984 != nil:
    section.add "username", valid_39117984
  var valid_39117985 = path.getOrDefault("teamId")
  valid_39117985 = validateParameter(valid_39117985, JInt, required = true,
                                   default = nil)
  if valid_39117985 != nil:
    section.add "teamId", valid_39117985
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39117986 = header.getOrDefault("Accept")
  valid_39117986 = validateParameter(valid_39117986, JString, required = false,
                                   default = nil)
  if valid_39117986 != nil:
    section.add "Accept", valid_39117986
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39117987: Call_GetTeamsTeamIdMembershipsUsername_39117981;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Get team membership.
  ## In order to get a user's membership with a team, the authenticated user must be a member of the team or an owner of the team's organization.
  ## 
  ## 
  let valid = call_39117987.validator(path, query, header, formData, body, _)
  let scheme = call_39117987.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39117987.url(scheme.get, call_39117987.host, call_39117987.base,
                           call_39117987.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39117987, url, valid, _)

proc call*(call_39117988: Call_GetTeamsTeamIdMembershipsUsername_39117981;
          username: string; teamId: int; Accept: string = ""): Recallable =
  ## getTeamsTeamIdMembershipsUsername
  ## Get team membership.
  ## In order to get a user's membership with a team, the authenticated user must be a member of the team or an owner of the team's organization.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_39117989 = newJObject()
  var header_39117990 = newJObject()
  add(path_39117989, "username", newJString(username))
  add(header_39117990, "Accept", newJString(Accept))
  add(path_39117989, "teamId", newJInt(teamId))
  result = call_39117988.call(path_39117989, nil, header_39117990, nil, nil)

var getTeamsTeamIdMembershipsUsername* = Call_GetTeamsTeamIdMembershipsUsername_39117981(
    name: "getTeamsTeamIdMembershipsUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/teams/{teamId}/memberships/{username}",
    validator: validate_GetTeamsTeamIdMembershipsUsername_39117982, base: "/",
    url: url_GetTeamsTeamIdMembershipsUsername_39117983, schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamIdMembershipsUsername_39118001 = ref object of OpenApiRestCall_39115352
proc url_DeleteTeamsTeamIdMembershipsUsername_39118003(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/memberships/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamIdMembershipsUsername_39118002(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Remove team membership.
  ## In order to remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. NOTE: This does not delete the user, it just removes their membership from the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39118004 = path.getOrDefault("username")
  valid_39118004 = validateParameter(valid_39118004, JString, required = true,
                                   default = nil)
  if valid_39118004 != nil:
    section.add "username", valid_39118004
  var valid_39118005 = path.getOrDefault("teamId")
  valid_39118005 = validateParameter(valid_39118005, JInt, required = true,
                                   default = nil)
  if valid_39118005 != nil:
    section.add "teamId", valid_39118005
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118006 = header.getOrDefault("Accept")
  valid_39118006 = validateParameter(valid_39118006, JString, required = false,
                                   default = nil)
  if valid_39118006 != nil:
    section.add "Accept", valid_39118006
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118007: Call_DeleteTeamsTeamIdMembershipsUsername_39118001;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Remove team membership.
  ## In order to remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. NOTE: This does not delete the user, it just removes their membership from the team.
  ## 
  ## 
  let valid = call_39118007.validator(path, query, header, formData, body, _)
  let scheme = call_39118007.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118007.url(scheme.get, call_39118007.host, call_39118007.base,
                           call_39118007.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118007, url, valid, _)

proc call*(call_39118008: Call_DeleteTeamsTeamIdMembershipsUsername_39118001;
          username: string; teamId: int; Accept: string = ""): Recallable =
  ## deleteTeamsTeamIdMembershipsUsername
  ## Remove team membership.
  ## In order to remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. NOTE: This does not delete the user, it just removes their membership from the team.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_39118009 = newJObject()
  var header_39118010 = newJObject()
  add(path_39118009, "username", newJString(username))
  add(header_39118010, "Accept", newJString(Accept))
  add(path_39118009, "teamId", newJInt(teamId))
  result = call_39118008.call(path_39118009, nil, header_39118010, nil, nil)

var deleteTeamsTeamIdMembershipsUsername* = Call_DeleteTeamsTeamIdMembershipsUsername_39118001(
    name: "deleteTeamsTeamIdMembershipsUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/teams/{teamId}/memberships/{username}",
    validator: validate_DeleteTeamsTeamIdMembershipsUsername_39118002, base: "/",
    url: url_DeleteTeamsTeamIdMembershipsUsername_39118003,
    schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdRepos_39118011 = ref object of OpenApiRestCall_39115352
proc url_GetTeamsTeamIdRepos_39118013(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdRepos_39118012(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List team repos
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `teamId` field"
  var valid_39118014 = path.getOrDefault("teamId")
  valid_39118014 = validateParameter(valid_39118014, JInt, required = true,
                                   default = nil)
  if valid_39118014 != nil:
    section.add "teamId", valid_39118014
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118015 = header.getOrDefault("Accept")
  valid_39118015 = validateParameter(valid_39118015, JString, required = false,
                                   default = nil)
  if valid_39118015 != nil:
    section.add "Accept", valid_39118015
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118016: Call_GetTeamsTeamIdRepos_39118011; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List team repos
  ## 
  let valid = call_39118016.validator(path, query, header, formData, body, _)
  let scheme = call_39118016.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118016.url(scheme.get, call_39118016.host, call_39118016.base,
                           call_39118016.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118016, url, valid, _)

proc call*(call_39118017: Call_GetTeamsTeamIdRepos_39118011; teamId: int;
          Accept: string = ""): Recallable =
  ## getTeamsTeamIdRepos
  ## List team repos
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_39118018 = newJObject()
  var header_39118019 = newJObject()
  add(header_39118019, "Accept", newJString(Accept))
  add(path_39118018, "teamId", newJInt(teamId))
  result = call_39118017.call(path_39118018, nil, header_39118019, nil, nil)

var getTeamsTeamIdRepos* = Call_GetTeamsTeamIdRepos_39118011(
    name: "getTeamsTeamIdRepos", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/teams/{teamId}/repos", validator: validate_GetTeamsTeamIdRepos_39118012,
    base: "/", url: url_GetTeamsTeamIdRepos_39118013, schemes: {Scheme.Https})
type
  Call_PutTeamsTeamIdReposOwnerRepo_39118031 = ref object of OpenApiRestCall_39115352
proc url_PutTeamsTeamIdReposOwnerRepo_39118033(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutTeamsTeamIdReposOwnerRepo_39118032(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## In order to add a repository to a team, the authenticated user must be an owner of the org that the team is associated with. Also, the repository must be owned by the organization, or a direct fork of a repository owned by the organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of a organization.
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39118034 = path.getOrDefault("owner")
  valid_39118034 = validateParameter(valid_39118034, JString, required = true,
                                   default = nil)
  if valid_39118034 != nil:
    section.add "owner", valid_39118034
  var valid_39118035 = path.getOrDefault("repo")
  valid_39118035 = validateParameter(valid_39118035, JString, required = true,
                                   default = nil)
  if valid_39118035 != nil:
    section.add "repo", valid_39118035
  var valid_39118036 = path.getOrDefault("teamId")
  valid_39118036 = validateParameter(valid_39118036, JInt, required = true,
                                   default = nil)
  if valid_39118036 != nil:
    section.add "teamId", valid_39118036
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118037 = header.getOrDefault("Accept")
  valid_39118037 = validateParameter(valid_39118037, JString, required = false,
                                   default = nil)
  if valid_39118037 != nil:
    section.add "Accept", valid_39118037
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118038: Call_PutTeamsTeamIdReposOwnerRepo_39118031;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## In order to add a repository to a team, the authenticated user must be an owner of the org that the team is associated with. Also, the repository must be owned by the organization, or a direct fork of a repository owned by the organization.
  ## 
  let valid = call_39118038.validator(path, query, header, formData, body, _)
  let scheme = call_39118038.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118038.url(scheme.get, call_39118038.host, call_39118038.base,
                           call_39118038.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118038, url, valid, _)

proc call*(call_39118039: Call_PutTeamsTeamIdReposOwnerRepo_39118031;
          owner: string; repo: string; teamId: int; Accept: string = ""): Recallable =
  ## putTeamsTeamIdReposOwnerRepo
  ## In order to add a repository to a team, the authenticated user must be an owner of the org that the team is associated with. Also, the repository must be owned by the organization, or a direct fork of a repository owned by the organization.
  ##   owner: string (required)
  ##        : Name of a organization.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_39118040 = newJObject()
  var header_39118041 = newJObject()
  add(path_39118040, "owner", newJString(owner))
  add(header_39118041, "Accept", newJString(Accept))
  add(path_39118040, "repo", newJString(repo))
  add(path_39118040, "teamId", newJInt(teamId))
  result = call_39118039.call(path_39118040, nil, header_39118041, nil, nil)

var putTeamsTeamIdReposOwnerRepo* = Call_PutTeamsTeamIdReposOwnerRepo_39118031(
    name: "putTeamsTeamIdReposOwnerRepo", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/teams/{teamId}/repos/{owner}/{repo}",
    validator: validate_PutTeamsTeamIdReposOwnerRepo_39118032, base: "/",
    url: url_PutTeamsTeamIdReposOwnerRepo_39118033, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdReposOwnerRepo_39118020 = ref object of OpenApiRestCall_39115352
proc url_GetTeamsTeamIdReposOwnerRepo_39118022(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdReposOwnerRepo_39118021(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Check if a team manages a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39118023 = path.getOrDefault("owner")
  valid_39118023 = validateParameter(valid_39118023, JString, required = true,
                                   default = nil)
  if valid_39118023 != nil:
    section.add "owner", valid_39118023
  var valid_39118024 = path.getOrDefault("repo")
  valid_39118024 = validateParameter(valid_39118024, JString, required = true,
                                   default = nil)
  if valid_39118024 != nil:
    section.add "repo", valid_39118024
  var valid_39118025 = path.getOrDefault("teamId")
  valid_39118025 = validateParameter(valid_39118025, JInt, required = true,
                                   default = nil)
  if valid_39118025 != nil:
    section.add "teamId", valid_39118025
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118026 = header.getOrDefault("Accept")
  valid_39118026 = validateParameter(valid_39118026, JString, required = false,
                                   default = nil)
  if valid_39118026 != nil:
    section.add "Accept", valid_39118026
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118027: Call_GetTeamsTeamIdReposOwnerRepo_39118020;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if a team manages a repository
  ## 
  let valid = call_39118027.validator(path, query, header, formData, body, _)
  let scheme = call_39118027.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118027.url(scheme.get, call_39118027.host, call_39118027.base,
                           call_39118027.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118027, url, valid, _)

proc call*(call_39118028: Call_GetTeamsTeamIdReposOwnerRepo_39118020;
          owner: string; repo: string; teamId: int; Accept: string = ""): Recallable =
  ## getTeamsTeamIdReposOwnerRepo
  ## Check if a team manages a repository
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_39118029 = newJObject()
  var header_39118030 = newJObject()
  add(path_39118029, "owner", newJString(owner))
  add(header_39118030, "Accept", newJString(Accept))
  add(path_39118029, "repo", newJString(repo))
  add(path_39118029, "teamId", newJInt(teamId))
  result = call_39118028.call(path_39118029, nil, header_39118030, nil, nil)

var getTeamsTeamIdReposOwnerRepo* = Call_GetTeamsTeamIdReposOwnerRepo_39118020(
    name: "getTeamsTeamIdReposOwnerRepo", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/teams/{teamId}/repos/{owner}/{repo}",
    validator: validate_GetTeamsTeamIdReposOwnerRepo_39118021, base: "/",
    url: url_GetTeamsTeamIdReposOwnerRepo_39118022, schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamIdReposOwnerRepo_39118042 = ref object of OpenApiRestCall_39115352
proc url_DeleteTeamsTeamIdReposOwnerRepo_39118044(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
               (kind: VariableSegment, value: "teamId"),
               (kind: ConstantSegment, value: "/repos/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamIdReposOwnerRepo_39118043(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## In order to remove a repository from a team, the authenticated user must be an owner of the org that the team is associated with. NOTE: This does not delete the repository, it just removes it from the team.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39118045 = path.getOrDefault("owner")
  valid_39118045 = validateParameter(valid_39118045, JString, required = true,
                                   default = nil)
  if valid_39118045 != nil:
    section.add "owner", valid_39118045
  var valid_39118046 = path.getOrDefault("repo")
  valid_39118046 = validateParameter(valid_39118046, JString, required = true,
                                   default = nil)
  if valid_39118046 != nil:
    section.add "repo", valid_39118046
  var valid_39118047 = path.getOrDefault("teamId")
  valid_39118047 = validateParameter(valid_39118047, JInt, required = true,
                                   default = nil)
  if valid_39118047 != nil:
    section.add "teamId", valid_39118047
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118048 = header.getOrDefault("Accept")
  valid_39118048 = validateParameter(valid_39118048, JString, required = false,
                                   default = nil)
  if valid_39118048 != nil:
    section.add "Accept", valid_39118048
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118049: Call_DeleteTeamsTeamIdReposOwnerRepo_39118042;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## In order to remove a repository from a team, the authenticated user must be an owner of the org that the team is associated with. NOTE: This does not delete the repository, it just removes it from the team.
  ## 
  let valid = call_39118049.validator(path, query, header, formData, body, _)
  let scheme = call_39118049.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118049.url(scheme.get, call_39118049.host, call_39118049.base,
                           call_39118049.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118049, url, valid, _)

proc call*(call_39118050: Call_DeleteTeamsTeamIdReposOwnerRepo_39118042;
          owner: string; repo: string; teamId: int; Accept: string = ""): Recallable =
  ## deleteTeamsTeamIdReposOwnerRepo
  ## In order to remove a repository from a team, the authenticated user must be an owner of the org that the team is associated with. NOTE: This does not delete the repository, it just removes it from the team.
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_39118051 = newJObject()
  var header_39118052 = newJObject()
  add(path_39118051, "owner", newJString(owner))
  add(header_39118052, "Accept", newJString(Accept))
  add(path_39118051, "repo", newJString(repo))
  add(path_39118051, "teamId", newJInt(teamId))
  result = call_39118050.call(path_39118051, nil, header_39118052, nil, nil)

var deleteTeamsTeamIdReposOwnerRepo* = Call_DeleteTeamsTeamIdReposOwnerRepo_39118042(
    name: "deleteTeamsTeamIdReposOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/teams/{teamId}/repos/{owner}/{repo}",
    validator: validate_DeleteTeamsTeamIdReposOwnerRepo_39118043, base: "/",
    url: url_DeleteTeamsTeamIdReposOwnerRepo_39118044, schemes: {Scheme.Https})
type
  Call_GetUser_39118053 = ref object of OpenApiRestCall_39115352
proc url_GetUser_39118055(protocol: Scheme; host: string; base: string; route: string;
                         path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUser_39118054(path: JsonNode; query: JsonNode; header: JsonNode;
                              formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118056 = header.getOrDefault("Accept")
  valid_39118056 = validateParameter(valid_39118056, JString, required = false,
                                   default = nil)
  if valid_39118056 != nil:
    section.add "Accept", valid_39118056
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118057: Call_GetUser_39118053; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get the authenticated user.
  ## 
  let valid = call_39118057.validator(path, query, header, formData, body, _)
  let scheme = call_39118057.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118057.url(scheme.get, call_39118057.host, call_39118057.base,
                           call_39118057.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118057, url, valid, _)

proc call*(call_39118058: Call_GetUser_39118053; Accept: string = ""): Recallable =
  ## getUser
  ## Get the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_39118059 = newJObject()
  add(header_39118059, "Accept", newJString(Accept))
  result = call_39118058.call(nil, nil, header_39118059, nil, nil)

var getUser* = Call_GetUser_39118053(name: "getUser", meth: HttpMethod.HttpGet,
                                  host: "api.github.com", route: "/user",
                                  validator: validate_GetUser_39118054, base: "/",
                                  url: url_GetUser_39118055,
                                  schemes: {Scheme.Https})
type
  Call_PatchUser_39118060 = ref object of OpenApiRestCall_39115352
proc url_PatchUser_39118062(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PatchUser_39118061(path: JsonNode; query: JsonNode; header: JsonNode;
                                formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Update the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118063 = header.getOrDefault("Accept")
  valid_39118063 = validateParameter(valid_39118063, JString, required = false,
                                   default = nil)
  if valid_39118063 != nil:
    section.add "Accept", valid_39118063
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39118065: Call_PatchUser_39118060; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Update the authenticated user.
  ## 
  let valid = call_39118065.validator(path, query, header, formData, body, _)
  let scheme = call_39118065.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118065.url(scheme.get, call_39118065.host, call_39118065.base,
                           call_39118065.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118065, url, valid, _)

proc call*(call_39118066: Call_PatchUser_39118060; body: JsonNode;
          Accept: string = ""): Recallable =
  ## patchUser
  ## Update the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_39118067 = newJObject()
  var body_39118068 = newJObject()
  add(header_39118067, "Accept", newJString(Accept))
  if body != nil:
    body_39118068 = body
  result = call_39118066.call(nil, nil, header_39118067, nil, body_39118068)

var patchUser* = Call_PatchUser_39118060(name: "patchUser",
                                      meth: HttpMethod.HttpPatch,
                                      host: "api.github.com", route: "/user",
                                      validator: validate_PatchUser_39118061,
                                      base: "/", url: url_PatchUser_39118062,
                                      schemes: {Scheme.Https})
type
  Call_PostUserEmails_39118076 = ref object of OpenApiRestCall_39115352
proc url_PostUserEmails_39118078(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostUserEmails_39118077(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Add email address(es).
  ## You can post a single email address or an array of addresses.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118079 = header.getOrDefault("Accept")
  valid_39118079 = validateParameter(valid_39118079, JString, required = false,
                                   default = nil)
  if valid_39118079 != nil:
    section.add "Accept", valid_39118079
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39118081: Call_PostUserEmails_39118076; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Add email address(es).
  ## You can post a single email address or an array of addresses.
  ## 
  ## 
  let valid = call_39118081.validator(path, query, header, formData, body, _)
  let scheme = call_39118081.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118081.url(scheme.get, call_39118081.host, call_39118081.base,
                           call_39118081.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118081, url, valid, _)

proc call*(call_39118082: Call_PostUserEmails_39118076; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postUserEmails
  ## Add email address(es).
  ## You can post a single email address or an array of addresses.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  var header_39118083 = newJObject()
  var body_39118084 = newJObject()
  add(header_39118083, "Accept", newJString(Accept))
  if body != nil:
    body_39118084 = body
  result = call_39118082.call(nil, nil, header_39118083, nil, body_39118084)

var postUserEmails* = Call_PostUserEmails_39118076(name: "postUserEmails",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/user/emails",
    validator: validate_PostUserEmails_39118077, base: "/", url: url_PostUserEmails_39118078,
    schemes: {Scheme.Https})
type
  Call_GetUserEmails_39118069 = ref object of OpenApiRestCall_39115352
proc url_GetUserEmails_39118071(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserEmails_39118070(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## List email addresses for a user.
  ## In the final version of the API, this method will return an array of hashes
  ## with extended information for each email address indicating if the address
  ## has been verified and if it's primary email address for GitHub.
  ## Until API v3 is finalized, use the application/vnd.github.v3 media type to
  ## get other response format.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118072 = header.getOrDefault("Accept")
  valid_39118072 = validateParameter(valid_39118072, JString, required = false,
                                   default = nil)
  if valid_39118072 != nil:
    section.add "Accept", valid_39118072
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118073: Call_GetUserEmails_39118069; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List email addresses for a user.
  ## In the final version of the API, this method will return an array of hashes
  ## with extended information for each email address indicating if the address
  ## has been verified and if it's primary email address for GitHub.
  ## Until API v3 is finalized, use the application/vnd.github.v3 media type to
  ## get other response format.
  ## 
  ## 
  let valid = call_39118073.validator(path, query, header, formData, body, _)
  let scheme = call_39118073.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118073.url(scheme.get, call_39118073.host, call_39118073.base,
                           call_39118073.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118073, url, valid, _)

proc call*(call_39118074: Call_GetUserEmails_39118069; Accept: string = ""): Recallable =
  ## getUserEmails
  ## List email addresses for a user.
  ## In the final version of the API, this method will return an array of hashes
  ## with extended information for each email address indicating if the address
  ## has been verified and if it's primary email address for GitHub.
  ## Until API v3 is finalized, use the application/vnd.github.v3 media type to
  ## get other response format.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_39118075 = newJObject()
  add(header_39118075, "Accept", newJString(Accept))
  result = call_39118074.call(nil, nil, header_39118075, nil, nil)

var getUserEmails* = Call_GetUserEmails_39118069(name: "getUserEmails",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/emails",
    validator: validate_GetUserEmails_39118070, base: "/", url: url_GetUserEmails_39118071,
    schemes: {Scheme.Https})
type
  Call_DeleteUserEmails_39118085 = ref object of OpenApiRestCall_39115352
proc url_DeleteUserEmails_39118087(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DeleteUserEmails_39118086(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Delete email address(es).
  ## You can include a single email address or an array of addresses.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118088 = header.getOrDefault("Accept")
  valid_39118088 = validateParameter(valid_39118088, JString, required = false,
                                   default = nil)
  if valid_39118088 != nil:
    section.add "Accept", valid_39118088
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39118090: Call_DeleteUserEmails_39118085; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete email address(es).
  ## You can include a single email address or an array of addresses.
  ## 
  ## 
  let valid = call_39118090.validator(path, query, header, formData, body, _)
  let scheme = call_39118090.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118090.url(scheme.get, call_39118090.host, call_39118090.base,
                           call_39118090.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118090, url, valid, _)

proc call*(call_39118091: Call_DeleteUserEmails_39118085; body: JsonNode;
          Accept: string = ""): Recallable =
  ## deleteUserEmails
  ## Delete email address(es).
  ## You can include a single email address or an array of addresses.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  var header_39118092 = newJObject()
  var body_39118093 = newJObject()
  add(header_39118092, "Accept", newJString(Accept))
  if body != nil:
    body_39118093 = body
  result = call_39118091.call(nil, nil, header_39118092, nil, body_39118093)

var deleteUserEmails* = Call_DeleteUserEmails_39118085(name: "deleteUserEmails",
    meth: HttpMethod.HttpDelete, host: "api.github.com", route: "/user/emails",
    validator: validate_DeleteUserEmails_39118086, base: "/",
    url: url_DeleteUserEmails_39118087, schemes: {Scheme.Https})
type
  Call_GetUserFollowers_39118094 = ref object of OpenApiRestCall_39115352
proc url_GetUserFollowers_39118096(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserFollowers_39118095(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List the authenticated user's followers
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118097 = header.getOrDefault("Accept")
  valid_39118097 = validateParameter(valid_39118097, JString, required = false,
                                   default = nil)
  if valid_39118097 != nil:
    section.add "Accept", valid_39118097
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118098: Call_GetUserFollowers_39118094; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List the authenticated user's followers
  ## 
  let valid = call_39118098.validator(path, query, header, formData, body, _)
  let scheme = call_39118098.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118098.url(scheme.get, call_39118098.host, call_39118098.base,
                           call_39118098.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118098, url, valid, _)

proc call*(call_39118099: Call_GetUserFollowers_39118094; Accept: string = ""): Recallable =
  ## getUserFollowers
  ## List the authenticated user's followers
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_39118100 = newJObject()
  add(header_39118100, "Accept", newJString(Accept))
  result = call_39118099.call(nil, nil, header_39118100, nil, nil)

var getUserFollowers* = Call_GetUserFollowers_39118094(name: "getUserFollowers",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/followers",
    validator: validate_GetUserFollowers_39118095, base: "/",
    url: url_GetUserFollowers_39118096, schemes: {Scheme.Https})
type
  Call_GetUserFollowing_39118101 = ref object of OpenApiRestCall_39115352
proc url_GetUserFollowing_39118103(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserFollowing_39118102(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List who the authenticated user is following.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118104 = header.getOrDefault("Accept")
  valid_39118104 = validateParameter(valid_39118104, JString, required = false,
                                   default = nil)
  if valid_39118104 != nil:
    section.add "Accept", valid_39118104
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118105: Call_GetUserFollowing_39118101; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List who the authenticated user is following.
  ## 
  let valid = call_39118105.validator(path, query, header, formData, body, _)
  let scheme = call_39118105.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118105.url(scheme.get, call_39118105.host, call_39118105.base,
                           call_39118105.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118105, url, valid, _)

proc call*(call_39118106: Call_GetUserFollowing_39118101; Accept: string = ""): Recallable =
  ## getUserFollowing
  ## List who the authenticated user is following.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_39118107 = newJObject()
  add(header_39118107, "Accept", newJString(Accept))
  result = call_39118106.call(nil, nil, header_39118107, nil, nil)

var getUserFollowing* = Call_GetUserFollowing_39118101(name: "getUserFollowing",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/following",
    validator: validate_GetUserFollowing_39118102, base: "/",
    url: url_GetUserFollowing_39118103, schemes: {Scheme.Https})
type
  Call_PutUserFollowingUsername_39118117 = ref object of OpenApiRestCall_39115352
proc url_PutUserFollowingUsername_39118119(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/following/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutUserFollowingUsername_39118118(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Follow a user.
  ## Following a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39118120 = path.getOrDefault("username")
  valid_39118120 = validateParameter(valid_39118120, JString, required = true,
                                   default = nil)
  if valid_39118120 != nil:
    section.add "username", valid_39118120
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118121 = header.getOrDefault("Accept")
  valid_39118121 = validateParameter(valid_39118121, JString, required = false,
                                   default = nil)
  if valid_39118121 != nil:
    section.add "Accept", valid_39118121
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118122: Call_PutUserFollowingUsername_39118117;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Follow a user.
  ## Following a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  let valid = call_39118122.validator(path, query, header, formData, body, _)
  let scheme = call_39118122.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118122.url(scheme.get, call_39118122.host, call_39118122.base,
                           call_39118122.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118122, url, valid, _)

proc call*(call_39118123: Call_PutUserFollowingUsername_39118117; username: string;
          Accept: string = ""): Recallable =
  ## putUserFollowingUsername
  ## Follow a user.
  ## Following a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39118124 = newJObject()
  var header_39118125 = newJObject()
  add(path_39118124, "username", newJString(username))
  add(header_39118125, "Accept", newJString(Accept))
  result = call_39118123.call(path_39118124, nil, header_39118125, nil, nil)

var putUserFollowingUsername* = Call_PutUserFollowingUsername_39118117(
    name: "putUserFollowingUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/user/following/{username}",
    validator: validate_PutUserFollowingUsername_39118118, base: "/",
    url: url_PutUserFollowingUsername_39118119, schemes: {Scheme.Https})
type
  Call_GetUserFollowingUsername_39118108 = ref object of OpenApiRestCall_39115352
proc url_GetUserFollowingUsername_39118110(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/following/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserFollowingUsername_39118109(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Check if you are following a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39118111 = path.getOrDefault("username")
  valid_39118111 = validateParameter(valid_39118111, JString, required = true,
                                   default = nil)
  if valid_39118111 != nil:
    section.add "username", valid_39118111
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118112 = header.getOrDefault("Accept")
  valid_39118112 = validateParameter(valid_39118112, JString, required = false,
                                   default = nil)
  if valid_39118112 != nil:
    section.add "Accept", valid_39118112
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118113: Call_GetUserFollowingUsername_39118108;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if you are following a user.
  ## 
  let valid = call_39118113.validator(path, query, header, formData, body, _)
  let scheme = call_39118113.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118113.url(scheme.get, call_39118113.host, call_39118113.base,
                           call_39118113.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118113, url, valid, _)

proc call*(call_39118114: Call_GetUserFollowingUsername_39118108; username: string;
          Accept: string = ""): Recallable =
  ## getUserFollowingUsername
  ## Check if you are following a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39118115 = newJObject()
  var header_39118116 = newJObject()
  add(path_39118115, "username", newJString(username))
  add(header_39118116, "Accept", newJString(Accept))
  result = call_39118114.call(path_39118115, nil, header_39118116, nil, nil)

var getUserFollowingUsername* = Call_GetUserFollowingUsername_39118108(
    name: "getUserFollowingUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/user/following/{username}",
    validator: validate_GetUserFollowingUsername_39118109, base: "/",
    url: url_GetUserFollowingUsername_39118110, schemes: {Scheme.Https})
type
  Call_DeleteUserFollowingUsername_39118126 = ref object of OpenApiRestCall_39115352
proc url_DeleteUserFollowingUsername_39118128(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/following/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserFollowingUsername_39118127(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Unfollow a user.
  ## Unfollowing a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39118129 = path.getOrDefault("username")
  valid_39118129 = validateParameter(valid_39118129, JString, required = true,
                                   default = nil)
  if valid_39118129 != nil:
    section.add "username", valid_39118129
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118130 = header.getOrDefault("Accept")
  valid_39118130 = validateParameter(valid_39118130, JString, required = false,
                                   default = nil)
  if valid_39118130 != nil:
    section.add "Accept", valid_39118130
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118131: Call_DeleteUserFollowingUsername_39118126;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Unfollow a user.
  ## Unfollowing a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  let valid = call_39118131.validator(path, query, header, formData, body, _)
  let scheme = call_39118131.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118131.url(scheme.get, call_39118131.host, call_39118131.base,
                           call_39118131.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118131, url, valid, _)

proc call*(call_39118132: Call_DeleteUserFollowingUsername_39118126;
          username: string; Accept: string = ""): Recallable =
  ## deleteUserFollowingUsername
  ## Unfollow a user.
  ## Unfollowing a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39118133 = newJObject()
  var header_39118134 = newJObject()
  add(path_39118133, "username", newJString(username))
  add(header_39118134, "Accept", newJString(Accept))
  result = call_39118132.call(path_39118133, nil, header_39118134, nil, nil)

var deleteUserFollowingUsername* = Call_DeleteUserFollowingUsername_39118126(
    name: "deleteUserFollowingUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/following/{username}",
    validator: validate_DeleteUserFollowingUsername_39118127, base: "/",
    url: url_DeleteUserFollowingUsername_39118128, schemes: {Scheme.Https})
type
  Call_GetUserIssues_39118135 = ref object of OpenApiRestCall_39115352
proc url_GetUserIssues_39118137(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserIssues_39118136(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## List issues.
  ## List all issues across owned and member repositories for the authenticated
  ## user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString (required)
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: JString (required)
  ##   direction: JString (required)
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_39118138 = query.getOrDefault("state")
  valid_39118138 = validateParameter(valid_39118138, JString, required = true,
                                   default = newJString("open"))
  if valid_39118138 != nil:
    section.add "state", valid_39118138
  var valid_39118139 = query.getOrDefault("labels")
  valid_39118139 = validateParameter(valid_39118139, JString, required = true,
                                   default = nil)
  if valid_39118139 != nil:
    section.add "labels", valid_39118139
  var valid_39118140 = query.getOrDefault("sort")
  valid_39118140 = validateParameter(valid_39118140, JString, required = true,
                                   default = newJString("created"))
  if valid_39118140 != nil:
    section.add "sort", valid_39118140
  var valid_39118141 = query.getOrDefault("direction")
  valid_39118141 = validateParameter(valid_39118141, JString, required = true,
                                   default = newJString("desc"))
  if valid_39118141 != nil:
    section.add "direction", valid_39118141
  var valid_39118142 = query.getOrDefault("filter")
  valid_39118142 = validateParameter(valid_39118142, JString, required = true,
                                   default = newJString("all"))
  if valid_39118142 != nil:
    section.add "filter", valid_39118142
  var valid_39118143 = query.getOrDefault("since")
  valid_39118143 = validateParameter(valid_39118143, JString, required = false,
                                   default = nil)
  if valid_39118143 != nil:
    section.add "since", valid_39118143
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118144 = header.getOrDefault("Accept")
  valid_39118144 = validateParameter(valid_39118144, JString, required = false,
                                   default = nil)
  if valid_39118144 != nil:
    section.add "Accept", valid_39118144
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118145: Call_GetUserIssues_39118135; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List issues.
  ## List all issues across owned and member repositories for the authenticated
  ## user.
  ## 
  ## 
  let valid = call_39118145.validator(path, query, header, formData, body, _)
  let scheme = call_39118145.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118145.url(scheme.get, call_39118145.host, call_39118145.base,
                           call_39118145.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118145, url, valid, _)

proc call*(call_39118146: Call_GetUserIssues_39118135; labels: string;
          state: string = "open"; Accept: string = ""; sort: string = "created";
          direction: string = "desc"; filter: string = "all"; since: string = ""): Recallable =
  ## getUserIssues
  ## List issues.
  ## List all issues across owned and member repositories for the authenticated
  ## user.
  ## 
  ##   state: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: string (required)
  ##   direction: string (required)
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  var query_39118147 = newJObject()
  var header_39118148 = newJObject()
  add(query_39118147, "state", newJString(state))
  add(header_39118148, "Accept", newJString(Accept))
  add(query_39118147, "labels", newJString(labels))
  add(query_39118147, "sort", newJString(sort))
  add(query_39118147, "direction", newJString(direction))
  add(query_39118147, "filter", newJString(filter))
  add(query_39118147, "since", newJString(since))
  result = call_39118146.call(nil, query_39118147, header_39118148, nil, nil)

var getUserIssues* = Call_GetUserIssues_39118135(name: "getUserIssues",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/issues",
    validator: validate_GetUserIssues_39118136, base: "/", url: url_GetUserIssues_39118137,
    schemes: {Scheme.Https})
type
  Call_PostUserKeys_39118156 = ref object of OpenApiRestCall_39115352
proc url_PostUserKeys_39118158(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostUserKeys_39118157(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## Create a public key.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118159 = header.getOrDefault("Accept")
  valid_39118159 = validateParameter(valid_39118159, JString, required = false,
                                   default = nil)
  if valid_39118159 != nil:
    section.add "Accept", valid_39118159
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39118161: Call_PostUserKeys_39118156; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a public key.
  ## 
  let valid = call_39118161.validator(path, query, header, formData, body, _)
  let scheme = call_39118161.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118161.url(scheme.get, call_39118161.host, call_39118161.base,
                           call_39118161.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118161, url, valid, _)

proc call*(call_39118162: Call_PostUserKeys_39118156; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postUserKeys
  ## Create a public key.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_39118163 = newJObject()
  var body_39118164 = newJObject()
  add(header_39118163, "Accept", newJString(Accept))
  if body != nil:
    body_39118164 = body
  result = call_39118162.call(nil, nil, header_39118163, nil, body_39118164)

var postUserKeys* = Call_PostUserKeys_39118156(name: "postUserKeys",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/user/keys",
    validator: validate_PostUserKeys_39118157, base: "/", url: url_PostUserKeys_39118158,
    schemes: {Scheme.Https})
type
  Call_GetUserKeys_39118149 = ref object of OpenApiRestCall_39115352
proc url_GetUserKeys_39118151(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserKeys_39118150(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List your public keys.
  ## Lists the current user's keys. Management of public keys via the API requires
  ## that you are authenticated through basic auth, or OAuth with the 'user', 'write:public_key' scopes.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118152 = header.getOrDefault("Accept")
  valid_39118152 = validateParameter(valid_39118152, JString, required = false,
                                   default = nil)
  if valid_39118152 != nil:
    section.add "Accept", valid_39118152
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118153: Call_GetUserKeys_39118149; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List your public keys.
  ## Lists the current user's keys. Management of public keys via the API requires
  ## that you are authenticated through basic auth, or OAuth with the 'user', 'write:public_key' scopes.
  ## 
  ## 
  let valid = call_39118153.validator(path, query, header, formData, body, _)
  let scheme = call_39118153.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118153.url(scheme.get, call_39118153.host, call_39118153.base,
                           call_39118153.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118153, url, valid, _)

proc call*(call_39118154: Call_GetUserKeys_39118149; Accept: string = ""): Recallable =
  ## getUserKeys
  ## List your public keys.
  ## Lists the current user's keys. Management of public keys via the API requires
  ## that you are authenticated through basic auth, or OAuth with the 'user', 'write:public_key' scopes.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_39118155 = newJObject()
  add(header_39118155, "Accept", newJString(Accept))
  result = call_39118154.call(nil, nil, header_39118155, nil, nil)

var getUserKeys* = Call_GetUserKeys_39118149(name: "getUserKeys",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/keys",
    validator: validate_GetUserKeys_39118150, base: "/", url: url_GetUserKeys_39118151,
    schemes: {Scheme.Https})
type
  Call_GetUserKeysKeyId_39118165 = ref object of OpenApiRestCall_39115352
proc url_GetUserKeysKeyId_39118167(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/keys/"),
               (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserKeysKeyId_39118166(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get a single public key.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyId: JInt (required)
  ##        : ID of key.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyId` field"
  var valid_39118168 = path.getOrDefault("keyId")
  valid_39118168 = validateParameter(valid_39118168, JInt, required = true,
                                   default = nil)
  if valid_39118168 != nil:
    section.add "keyId", valid_39118168
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118169 = header.getOrDefault("Accept")
  valid_39118169 = validateParameter(valid_39118169, JString, required = false,
                                   default = nil)
  if valid_39118169 != nil:
    section.add "Accept", valid_39118169
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118170: Call_GetUserKeysKeyId_39118165; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single public key.
  ## 
  let valid = call_39118170.validator(path, query, header, formData, body, _)
  let scheme = call_39118170.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118170.url(scheme.get, call_39118170.host, call_39118170.base,
                           call_39118170.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118170, url, valid, _)

proc call*(call_39118171: Call_GetUserKeysKeyId_39118165; keyId: int;
          Accept: string = ""): Recallable =
  ## getUserKeysKeyId
  ## Get a single public key.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   keyId: int (required)
  ##        : ID of key.
  var path_39118172 = newJObject()
  var header_39118173 = newJObject()
  add(header_39118173, "Accept", newJString(Accept))
  add(path_39118172, "keyId", newJInt(keyId))
  result = call_39118171.call(path_39118172, nil, header_39118173, nil, nil)

var getUserKeysKeyId* = Call_GetUserKeysKeyId_39118165(name: "getUserKeysKeyId",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/keys/{keyId}",
    validator: validate_GetUserKeysKeyId_39118166, base: "/",
    url: url_GetUserKeysKeyId_39118167, schemes: {Scheme.Https})
type
  Call_DeleteUserKeysKeyId_39118174 = ref object of OpenApiRestCall_39115352
proc url_DeleteUserKeysKeyId_39118176(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/keys/"),
               (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserKeysKeyId_39118175(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Delete a public key. Removes a public key. Requires that you are authenticated via Basic Auth or via OAuth with at least admin:public_key scope.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyId: JInt (required)
  ##        : ID of key.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyId` field"
  var valid_39118177 = path.getOrDefault("keyId")
  valid_39118177 = validateParameter(valid_39118177, JInt, required = true,
                                   default = nil)
  if valid_39118177 != nil:
    section.add "keyId", valid_39118177
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118178 = header.getOrDefault("Accept")
  valid_39118178 = validateParameter(valid_39118178, JString, required = false,
                                   default = nil)
  if valid_39118178 != nil:
    section.add "Accept", valid_39118178
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118179: Call_DeleteUserKeysKeyId_39118174; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Delete a public key. Removes a public key. Requires that you are authenticated via Basic Auth or via OAuth with at least admin:public_key scope.
  ## 
  let valid = call_39118179.validator(path, query, header, formData, body, _)
  let scheme = call_39118179.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118179.url(scheme.get, call_39118179.host, call_39118179.base,
                           call_39118179.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118179, url, valid, _)

proc call*(call_39118180: Call_DeleteUserKeysKeyId_39118174; keyId: int;
          Accept: string = ""): Recallable =
  ## deleteUserKeysKeyId
  ## Delete a public key. Removes a public key. Requires that you are authenticated via Basic Auth or via OAuth with at least admin:public_key scope.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   keyId: int (required)
  ##        : ID of key.
  var path_39118181 = newJObject()
  var header_39118182 = newJObject()
  add(header_39118182, "Accept", newJString(Accept))
  add(path_39118181, "keyId", newJInt(keyId))
  result = call_39118180.call(path_39118181, nil, header_39118182, nil, nil)

var deleteUserKeysKeyId* = Call_DeleteUserKeysKeyId_39118174(
    name: "deleteUserKeysKeyId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/keys/{keyId}",
    validator: validate_DeleteUserKeysKeyId_39118175, base: "/",
    url: url_DeleteUserKeysKeyId_39118176, schemes: {Scheme.Https})
type
  Call_GetUserOrgs_39118183 = ref object of OpenApiRestCall_39115352
proc url_GetUserOrgs_39118185(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserOrgs_39118184(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List public and private organizations for the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118186 = header.getOrDefault("Accept")
  valid_39118186 = validateParameter(valid_39118186, JString, required = false,
                                   default = nil)
  if valid_39118186 != nil:
    section.add "Accept", valid_39118186
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118187: Call_GetUserOrgs_39118183; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List public and private organizations for the authenticated user.
  ## 
  let valid = call_39118187.validator(path, query, header, formData, body, _)
  let scheme = call_39118187.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118187.url(scheme.get, call_39118187.host, call_39118187.base,
                           call_39118187.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118187, url, valid, _)

proc call*(call_39118188: Call_GetUserOrgs_39118183; Accept: string = ""): Recallable =
  ## getUserOrgs
  ## List public and private organizations for the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_39118189 = newJObject()
  add(header_39118189, "Accept", newJString(Accept))
  result = call_39118188.call(nil, nil, header_39118189, nil, nil)

var getUserOrgs* = Call_GetUserOrgs_39118183(name: "getUserOrgs",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/orgs",
    validator: validate_GetUserOrgs_39118184, base: "/", url: url_GetUserOrgs_39118185,
    schemes: {Scheme.Https})
type
  Call_PostUserRepos_39118199 = ref object of OpenApiRestCall_39115352
proc url_PostUserRepos_39118201(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostUserRepos_39118200(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118202 = header.getOrDefault("Accept")
  valid_39118202 = validateParameter(valid_39118202, JString, required = false,
                                   default = nil)
  if valid_39118202 != nil:
    section.add "Accept", valid_39118202
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  assert body != nil, "body argument is necessary"
  section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_39118204: Call_PostUserRepos_39118199; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  let valid = call_39118204.validator(path, query, header, formData, body, _)
  let scheme = call_39118204.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118204.url(scheme.get, call_39118204.host, call_39118204.base,
                           call_39118204.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118204, url, valid, _)

proc call*(call_39118205: Call_PostUserRepos_39118199; body: JsonNode;
          Accept: string = ""): Recallable =
  ## postUserRepos
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_39118206 = newJObject()
  var body_39118207 = newJObject()
  add(header_39118206, "Accept", newJString(Accept))
  if body != nil:
    body_39118207 = body
  result = call_39118205.call(nil, nil, header_39118206, nil, body_39118207)

var postUserRepos* = Call_PostUserRepos_39118199(name: "postUserRepos",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/user/repos",
    validator: validate_PostUserRepos_39118200, base: "/", url: url_PostUserRepos_39118201,
    schemes: {Scheme.Https})
type
  Call_GetUserRepos_39118190 = ref object of OpenApiRestCall_39115352
proc url_GetUserRepos_39118192(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserRepos_39118191(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## List repositories for the authenticated user. Note that this does not include
  ## repositories owned by organizations which the user can access. You can lis
  ## user organizations and list organization repositories separately.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   type: JString
  section = newJObject()
  var valid_39118193 = query.getOrDefault("type")
  valid_39118193 = validateParameter(valid_39118193, JString, required = false,
                                   default = newJString("all"))
  if valid_39118193 != nil:
    section.add "type", valid_39118193
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118194 = header.getOrDefault("Accept")
  valid_39118194 = validateParameter(valid_39118194, JString, required = false,
                                   default = nil)
  if valid_39118194 != nil:
    section.add "Accept", valid_39118194
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118195: Call_GetUserRepos_39118190; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List repositories for the authenticated user. Note that this does not include
  ## repositories owned by organizations which the user can access. You can lis
  ## user organizations and list organization repositories separately.
  ## 
  ## 
  let valid = call_39118195.validator(path, query, header, formData, body, _)
  let scheme = call_39118195.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118195.url(scheme.get, call_39118195.host, call_39118195.base,
                           call_39118195.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118195, url, valid, _)

proc call*(call_39118196: Call_GetUserRepos_39118190; Accept: string = "";
          `type`: string = "all"): Recallable =
  ## getUserRepos
  ## List repositories for the authenticated user. Note that this does not include
  ## repositories owned by organizations which the user can access. You can lis
  ## user organizations and list organization repositories separately.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   type: string
  var query_39118197 = newJObject()
  var header_39118198 = newJObject()
  add(header_39118198, "Accept", newJString(Accept))
  add(query_39118197, "type", newJString(`type`))
  result = call_39118196.call(nil, query_39118197, header_39118198, nil, nil)

var getUserRepos* = Call_GetUserRepos_39118190(name: "getUserRepos",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/repos",
    validator: validate_GetUserRepos_39118191, base: "/", url: url_GetUserRepos_39118192,
    schemes: {Scheme.Https})
type
  Call_GetUserStarred_39118208 = ref object of OpenApiRestCall_39115352
proc url_GetUserStarred_39118210(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserStarred_39118209(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List repositories being starred by the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  section = newJObject()
  var valid_39118211 = query.getOrDefault("sort")
  valid_39118211 = validateParameter(valid_39118211, JString, required = false,
                                   default = newJString("created"))
  if valid_39118211 != nil:
    section.add "sort", valid_39118211
  var valid_39118212 = query.getOrDefault("direction")
  valid_39118212 = validateParameter(valid_39118212, JString, required = false,
                                   default = nil)
  if valid_39118212 != nil:
    section.add "direction", valid_39118212
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118213 = header.getOrDefault("Accept")
  valid_39118213 = validateParameter(valid_39118213, JString, required = false,
                                   default = nil)
  if valid_39118213 != nil:
    section.add "Accept", valid_39118213
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118214: Call_GetUserStarred_39118208; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List repositories being starred by the authenticated user.
  ## 
  let valid = call_39118214.validator(path, query, header, formData, body, _)
  let scheme = call_39118214.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118214.url(scheme.get, call_39118214.host, call_39118214.base,
                           call_39118214.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118214, url, valid, _)

proc call*(call_39118215: Call_GetUserStarred_39118208; Accept: string = "";
          sort: string = "created"; direction: string = ""): Recallable =
  ## getUserStarred
  ## List repositories being starred by the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  var query_39118216 = newJObject()
  var header_39118217 = newJObject()
  add(header_39118217, "Accept", newJString(Accept))
  add(query_39118216, "sort", newJString(sort))
  add(query_39118216, "direction", newJString(direction))
  result = call_39118215.call(nil, query_39118216, header_39118217, nil, nil)

var getUserStarred* = Call_GetUserStarred_39118208(name: "getUserStarred",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/starred",
    validator: validate_GetUserStarred_39118209, base: "/", url: url_GetUserStarred_39118210,
    schemes: {Scheme.Https})
type
  Call_PutUserStarredOwnerRepo_39118228 = ref object of OpenApiRestCall_39115352
proc url_PutUserStarredOwnerRepo_39118230(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/starred/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutUserStarredOwnerRepo_39118229(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Star a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  ##   repo: JString (required)
  ##       : Name of a repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39118231 = path.getOrDefault("owner")
  valid_39118231 = validateParameter(valid_39118231, JString, required = true,
                                   default = nil)
  if valid_39118231 != nil:
    section.add "owner", valid_39118231
  var valid_39118232 = path.getOrDefault("repo")
  valid_39118232 = validateParameter(valid_39118232, JString, required = true,
                                   default = nil)
  if valid_39118232 != nil:
    section.add "repo", valid_39118232
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118233 = header.getOrDefault("Accept")
  valid_39118233 = validateParameter(valid_39118233, JString, required = false,
                                   default = nil)
  if valid_39118233 != nil:
    section.add "Accept", valid_39118233
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118234: Call_PutUserStarredOwnerRepo_39118228;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Star a repository.
  ## 
  let valid = call_39118234.validator(path, query, header, formData, body, _)
  let scheme = call_39118234.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118234.url(scheme.get, call_39118234.host, call_39118234.base,
                           call_39118234.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118234, url, valid, _)

proc call*(call_39118235: Call_PutUserStarredOwnerRepo_39118228; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## putUserStarredOwnerRepo
  ## Star a repository.
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  var path_39118236 = newJObject()
  var header_39118237 = newJObject()
  add(path_39118236, "owner", newJString(owner))
  add(header_39118237, "Accept", newJString(Accept))
  add(path_39118236, "repo", newJString(repo))
  result = call_39118235.call(path_39118236, nil, header_39118237, nil, nil)

var putUserStarredOwnerRepo* = Call_PutUserStarredOwnerRepo_39118228(
    name: "putUserStarredOwnerRepo", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/user/starred/{owner}/{repo}",
    validator: validate_PutUserStarredOwnerRepo_39118229, base: "/",
    url: url_PutUserStarredOwnerRepo_39118230, schemes: {Scheme.Https})
type
  Call_GetUserStarredOwnerRepo_39118218 = ref object of OpenApiRestCall_39115352
proc url_GetUserStarredOwnerRepo_39118220(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/starred/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserStarredOwnerRepo_39118219(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Check if you are starring a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  ##   repo: JString (required)
  ##       : Name of a repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39118221 = path.getOrDefault("owner")
  valid_39118221 = validateParameter(valid_39118221, JString, required = true,
                                   default = nil)
  if valid_39118221 != nil:
    section.add "owner", valid_39118221
  var valid_39118222 = path.getOrDefault("repo")
  valid_39118222 = validateParameter(valid_39118222, JString, required = true,
                                   default = nil)
  if valid_39118222 != nil:
    section.add "repo", valid_39118222
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118223 = header.getOrDefault("Accept")
  valid_39118223 = validateParameter(valid_39118223, JString, required = false,
                                   default = nil)
  if valid_39118223 != nil:
    section.add "Accept", valid_39118223
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118224: Call_GetUserStarredOwnerRepo_39118218;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if you are starring a repository.
  ## 
  let valid = call_39118224.validator(path, query, header, formData, body, _)
  let scheme = call_39118224.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118224.url(scheme.get, call_39118224.host, call_39118224.base,
                           call_39118224.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118224, url, valid, _)

proc call*(call_39118225: Call_GetUserStarredOwnerRepo_39118218; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## getUserStarredOwnerRepo
  ## Check if you are starring a repository.
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  var path_39118226 = newJObject()
  var header_39118227 = newJObject()
  add(path_39118226, "owner", newJString(owner))
  add(header_39118227, "Accept", newJString(Accept))
  add(path_39118226, "repo", newJString(repo))
  result = call_39118225.call(path_39118226, nil, header_39118227, nil, nil)

var getUserStarredOwnerRepo* = Call_GetUserStarredOwnerRepo_39118218(
    name: "getUserStarredOwnerRepo", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/user/starred/{owner}/{repo}",
    validator: validate_GetUserStarredOwnerRepo_39118219, base: "/",
    url: url_GetUserStarredOwnerRepo_39118220, schemes: {Scheme.Https})
type
  Call_DeleteUserStarredOwnerRepo_39118238 = ref object of OpenApiRestCall_39115352
proc url_DeleteUserStarredOwnerRepo_39118240(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/starred/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserStarredOwnerRepo_39118239(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Unstar a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  ##   repo: JString (required)
  ##       : Name of a repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39118241 = path.getOrDefault("owner")
  valid_39118241 = validateParameter(valid_39118241, JString, required = true,
                                   default = nil)
  if valid_39118241 != nil:
    section.add "owner", valid_39118241
  var valid_39118242 = path.getOrDefault("repo")
  valid_39118242 = validateParameter(valid_39118242, JString, required = true,
                                   default = nil)
  if valid_39118242 != nil:
    section.add "repo", valid_39118242
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118243 = header.getOrDefault("Accept")
  valid_39118243 = validateParameter(valid_39118243, JString, required = false,
                                   default = nil)
  if valid_39118243 != nil:
    section.add "Accept", valid_39118243
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118244: Call_DeleteUserStarredOwnerRepo_39118238;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Unstar a repository
  ## 
  let valid = call_39118244.validator(path, query, header, formData, body, _)
  let scheme = call_39118244.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118244.url(scheme.get, call_39118244.host, call_39118244.base,
                           call_39118244.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118244, url, valid, _)

proc call*(call_39118245: Call_DeleteUserStarredOwnerRepo_39118238; owner: string;
          repo: string; Accept: string = ""): Recallable =
  ## deleteUserStarredOwnerRepo
  ## Unstar a repository
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  var path_39118246 = newJObject()
  var header_39118247 = newJObject()
  add(path_39118246, "owner", newJString(owner))
  add(header_39118247, "Accept", newJString(Accept))
  add(path_39118246, "repo", newJString(repo))
  result = call_39118245.call(path_39118246, nil, header_39118247, nil, nil)

var deleteUserStarredOwnerRepo* = Call_DeleteUserStarredOwnerRepo_39118238(
    name: "deleteUserStarredOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/starred/{owner}/{repo}",
    validator: validate_DeleteUserStarredOwnerRepo_39118239, base: "/",
    url: url_DeleteUserStarredOwnerRepo_39118240, schemes: {Scheme.Https})
type
  Call_GetUserSubscriptions_39118248 = ref object of OpenApiRestCall_39115352
proc url_GetUserSubscriptions_39118250(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserSubscriptions_39118249(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List repositories being watched by the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118251 = header.getOrDefault("Accept")
  valid_39118251 = validateParameter(valid_39118251, JString, required = false,
                                   default = nil)
  if valid_39118251 != nil:
    section.add "Accept", valid_39118251
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118252: Call_GetUserSubscriptions_39118248; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List repositories being watched by the authenticated user.
  ## 
  let valid = call_39118252.validator(path, query, header, formData, body, _)
  let scheme = call_39118252.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118252.url(scheme.get, call_39118252.host, call_39118252.base,
                           call_39118252.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118252, url, valid, _)

proc call*(call_39118253: Call_GetUserSubscriptions_39118248; Accept: string = ""): Recallable =
  ## getUserSubscriptions
  ## List repositories being watched by the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_39118254 = newJObject()
  add(header_39118254, "Accept", newJString(Accept))
  result = call_39118253.call(nil, nil, header_39118254, nil, nil)

var getUserSubscriptions* = Call_GetUserSubscriptions_39118248(
    name: "getUserSubscriptions", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/user/subscriptions", validator: validate_GetUserSubscriptions_39118249,
    base: "/", url: url_GetUserSubscriptions_39118250, schemes: {Scheme.Https})
type
  Call_PutUserSubscriptionsOwnerRepo_39118265 = ref object of OpenApiRestCall_39115352
proc url_PutUserSubscriptionsOwnerRepo_39118267(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/subscriptions/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutUserSubscriptionsOwnerRepo_39118266(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Watch a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of the owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39118268 = path.getOrDefault("owner")
  valid_39118268 = validateParameter(valid_39118268, JString, required = true,
                                   default = nil)
  if valid_39118268 != nil:
    section.add "owner", valid_39118268
  var valid_39118269 = path.getOrDefault("repo")
  valid_39118269 = validateParameter(valid_39118269, JString, required = true,
                                   default = nil)
  if valid_39118269 != nil:
    section.add "repo", valid_39118269
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118270 = header.getOrDefault("Accept")
  valid_39118270 = validateParameter(valid_39118270, JString, required = false,
                                   default = nil)
  if valid_39118270 != nil:
    section.add "Accept", valid_39118270
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118271: Call_PutUserSubscriptionsOwnerRepo_39118265;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Watch a repository.
  ## 
  let valid = call_39118271.validator(path, query, header, formData, body, _)
  let scheme = call_39118271.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118271.url(scheme.get, call_39118271.host, call_39118271.base,
                           call_39118271.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118271, url, valid, _)

proc call*(call_39118272: Call_PutUserSubscriptionsOwnerRepo_39118265;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## putUserSubscriptionsOwnerRepo
  ## Watch a repository.
  ##   owner: string (required)
  ##        : Name of the owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39118273 = newJObject()
  var header_39118274 = newJObject()
  add(path_39118273, "owner", newJString(owner))
  add(header_39118274, "Accept", newJString(Accept))
  add(path_39118273, "repo", newJString(repo))
  result = call_39118272.call(path_39118273, nil, header_39118274, nil, nil)

var putUserSubscriptionsOwnerRepo* = Call_PutUserSubscriptionsOwnerRepo_39118265(
    name: "putUserSubscriptionsOwnerRepo", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/user/subscriptions/{owner}/{repo}",
    validator: validate_PutUserSubscriptionsOwnerRepo_39118266, base: "/",
    url: url_PutUserSubscriptionsOwnerRepo_39118267, schemes: {Scheme.Https})
type
  Call_GetUserSubscriptionsOwnerRepo_39118255 = ref object of OpenApiRestCall_39115352
proc url_GetUserSubscriptionsOwnerRepo_39118257(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/subscriptions/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserSubscriptionsOwnerRepo_39118256(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Check if you are watching a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of the owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39118258 = path.getOrDefault("owner")
  valid_39118258 = validateParameter(valid_39118258, JString, required = true,
                                   default = nil)
  if valid_39118258 != nil:
    section.add "owner", valid_39118258
  var valid_39118259 = path.getOrDefault("repo")
  valid_39118259 = validateParameter(valid_39118259, JString, required = true,
                                   default = nil)
  if valid_39118259 != nil:
    section.add "repo", valid_39118259
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118260 = header.getOrDefault("Accept")
  valid_39118260 = validateParameter(valid_39118260, JString, required = false,
                                   default = nil)
  if valid_39118260 != nil:
    section.add "Accept", valid_39118260
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118261: Call_GetUserSubscriptionsOwnerRepo_39118255;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if you are watching a repository.
  ## 
  let valid = call_39118261.validator(path, query, header, formData, body, _)
  let scheme = call_39118261.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118261.url(scheme.get, call_39118261.host, call_39118261.base,
                           call_39118261.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118261, url, valid, _)

proc call*(call_39118262: Call_GetUserSubscriptionsOwnerRepo_39118255;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## getUserSubscriptionsOwnerRepo
  ## Check if you are watching a repository.
  ##   owner: string (required)
  ##        : Name of the owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39118263 = newJObject()
  var header_39118264 = newJObject()
  add(path_39118263, "owner", newJString(owner))
  add(header_39118264, "Accept", newJString(Accept))
  add(path_39118263, "repo", newJString(repo))
  result = call_39118262.call(path_39118263, nil, header_39118264, nil, nil)

var getUserSubscriptionsOwnerRepo* = Call_GetUserSubscriptionsOwnerRepo_39118255(
    name: "getUserSubscriptionsOwnerRepo", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/user/subscriptions/{owner}/{repo}",
    validator: validate_GetUserSubscriptionsOwnerRepo_39118256, base: "/",
    url: url_GetUserSubscriptionsOwnerRepo_39118257, schemes: {Scheme.Https})
type
  Call_DeleteUserSubscriptionsOwnerRepo_39118275 = ref object of OpenApiRestCall_39115352
proc url_DeleteUserSubscriptionsOwnerRepo_39118277(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/subscriptions/"),
               (kind: VariableSegment, value: "owner"),
               (kind: ConstantSegment, value: "/"),
               (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserSubscriptionsOwnerRepo_39118276(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Stop watching a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of the owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_39118278 = path.getOrDefault("owner")
  valid_39118278 = validateParameter(valid_39118278, JString, required = true,
                                   default = nil)
  if valid_39118278 != nil:
    section.add "owner", valid_39118278
  var valid_39118279 = path.getOrDefault("repo")
  valid_39118279 = validateParameter(valid_39118279, JString, required = true,
                                   default = nil)
  if valid_39118279 != nil:
    section.add "repo", valid_39118279
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118280 = header.getOrDefault("Accept")
  valid_39118280 = validateParameter(valid_39118280, JString, required = false,
                                   default = nil)
  if valid_39118280 != nil:
    section.add "Accept", valid_39118280
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118281: Call_DeleteUserSubscriptionsOwnerRepo_39118275;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Stop watching a repository
  ## 
  let valid = call_39118281.validator(path, query, header, formData, body, _)
  let scheme = call_39118281.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118281.url(scheme.get, call_39118281.host, call_39118281.base,
                           call_39118281.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118281, url, valid, _)

proc call*(call_39118282: Call_DeleteUserSubscriptionsOwnerRepo_39118275;
          owner: string; repo: string; Accept: string = ""): Recallable =
  ## deleteUserSubscriptionsOwnerRepo
  ## Stop watching a repository
  ##   owner: string (required)
  ##        : Name of the owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_39118283 = newJObject()
  var header_39118284 = newJObject()
  add(path_39118283, "owner", newJString(owner))
  add(header_39118284, "Accept", newJString(Accept))
  add(path_39118283, "repo", newJString(repo))
  result = call_39118282.call(path_39118283, nil, header_39118284, nil, nil)

var deleteUserSubscriptionsOwnerRepo* = Call_DeleteUserSubscriptionsOwnerRepo_39118275(
    name: "deleteUserSubscriptionsOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/subscriptions/{owner}/{repo}",
    validator: validate_DeleteUserSubscriptionsOwnerRepo_39118276, base: "/",
    url: url_DeleteUserSubscriptionsOwnerRepo_39118277, schemes: {Scheme.Https})
type
  Call_GetUserTeams_39118285 = ref object of OpenApiRestCall_39115352
proc url_GetUserTeams_39118287(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserTeams_39118286(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; _: string = ""): JsonNode {.nosinks.} =
  ## List all of the teams across all of the organizations to which the authenticated user belongs. This method requires user or repo scope when authenticating via OAuth.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118288 = header.getOrDefault("Accept")
  valid_39118288 = validateParameter(valid_39118288, JString, required = false,
                                   default = nil)
  if valid_39118288 != nil:
    section.add "Accept", valid_39118288
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118289: Call_GetUserTeams_39118285; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List all of the teams across all of the organizations to which the authenticated user belongs. This method requires user or repo scope when authenticating via OAuth.
  ## 
  let valid = call_39118289.validator(path, query, header, formData, body, _)
  let scheme = call_39118289.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118289.url(scheme.get, call_39118289.host, call_39118289.base,
                           call_39118289.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118289, url, valid, _)

proc call*(call_39118290: Call_GetUserTeams_39118285; Accept: string = ""): Recallable =
  ## getUserTeams
  ## List all of the teams across all of the organizations to which the authenticated user belongs. This method requires user or repo scope when authenticating via OAuth.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_39118291 = newJObject()
  add(header_39118291, "Accept", newJString(Accept))
  result = call_39118290.call(nil, nil, header_39118291, nil, nil)

var getUserTeams* = Call_GetUserTeams_39118285(name: "getUserTeams",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/teams",
    validator: validate_GetUserTeams_39118286, base: "/", url: url_GetUserTeams_39118287,
    schemes: {Scheme.Https})
type
  Call_GetUsers_39118292 = ref object of OpenApiRestCall_39115352
proc url_GetUsers_39118294(protocol: Scheme; host: string; base: string; route: string;
                          path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUsers_39118293(path: JsonNode; query: JsonNode; header: JsonNode;
                               formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get all users.
  ## This provides a dump of every user, in the order that they signed up for GitHub.
  ## Note: Pagination is powered exclusively by the since parameter. Use the Link
  ## header to get the URL for the next page of users.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JInt
  ##        : The integer ID of the last user that you've seen.
  section = newJObject()
  var valid_39118295 = query.getOrDefault("since")
  valid_39118295 = validateParameter(valid_39118295, JInt, required = false,
                                   default = nil)
  if valid_39118295 != nil:
    section.add "since", valid_39118295
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118296 = header.getOrDefault("Accept")
  valid_39118296 = validateParameter(valid_39118296, JString, required = false,
                                   default = nil)
  if valid_39118296 != nil:
    section.add "Accept", valid_39118296
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118297: Call_GetUsers_39118292; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get all users.
  ## This provides a dump of every user, in the order that they signed up for GitHub.
  ## Note: Pagination is powered exclusively by the since parameter. Use the Link
  ## header to get the URL for the next page of users.
  ## 
  ## 
  let valid = call_39118297.validator(path, query, header, formData, body, _)
  let scheme = call_39118297.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118297.url(scheme.get, call_39118297.host, call_39118297.base,
                           call_39118297.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118297, url, valid, _)

proc call*(call_39118298: Call_GetUsers_39118292; Accept: string = ""; since: int = 0): Recallable =
  ## getUsers
  ## Get all users.
  ## This provides a dump of every user, in the order that they signed up for GitHub.
  ## Note: Pagination is powered exclusively by the since parameter. Use the Link
  ## header to get the URL for the next page of users.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: int
  ##        : The integer ID of the last user that you've seen.
  var query_39118299 = newJObject()
  var header_39118300 = newJObject()
  add(header_39118300, "Accept", newJString(Accept))
  add(query_39118299, "since", newJInt(since))
  result = call_39118298.call(nil, query_39118299, header_39118300, nil, nil)

var getUsers* = Call_GetUsers_39118292(name: "getUsers", meth: HttpMethod.HttpGet,
                                    host: "api.github.com", route: "/users",
                                    validator: validate_GetUsers_39118293,
                                    base: "/", url: url_GetUsers_39118294,
                                    schemes: {Scheme.Https})
type
  Call_GetUsersUsername_39118301 = ref object of OpenApiRestCall_39115352
proc url_GetUsersUsername_39118303(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsername_39118302(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## Get a single user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39118304 = path.getOrDefault("username")
  valid_39118304 = validateParameter(valid_39118304, JString, required = true,
                                   default = nil)
  if valid_39118304 != nil:
    section.add "username", valid_39118304
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118305 = header.getOrDefault("Accept")
  valid_39118305 = validateParameter(valid_39118305, JString, required = false,
                                   default = nil)
  if valid_39118305 != nil:
    section.add "Accept", valid_39118305
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118306: Call_GetUsersUsername_39118301; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Get a single user.
  ## 
  let valid = call_39118306.validator(path, query, header, formData, body, _)
  let scheme = call_39118306.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118306.url(scheme.get, call_39118306.host, call_39118306.base,
                           call_39118306.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118306, url, valid, _)

proc call*(call_39118307: Call_GetUsersUsername_39118301; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsername
  ## Get a single user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39118308 = newJObject()
  var header_39118309 = newJObject()
  add(path_39118308, "username", newJString(username))
  add(header_39118309, "Accept", newJString(Accept))
  result = call_39118307.call(path_39118308, nil, header_39118309, nil, nil)

var getUsersUsername* = Call_GetUsersUsername_39118301(name: "getUsersUsername",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/users/{username}",
    validator: validate_GetUsersUsername_39118302, base: "/",
    url: url_GetUsersUsername_39118303, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameEvents_39118310 = ref object of OpenApiRestCall_39115352
proc url_GetUsersUsernameEvents_39118312(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameEvents_39118311(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39118313 = path.getOrDefault("username")
  valid_39118313 = validateParameter(valid_39118313, JString, required = true,
                                   default = nil)
  if valid_39118313 != nil:
    section.add "username", valid_39118313
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118314 = header.getOrDefault("Accept")
  valid_39118314 = validateParameter(valid_39118314, JString, required = false,
                                   default = nil)
  if valid_39118314 != nil:
    section.add "Accept", valid_39118314
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118315: Call_GetUsersUsernameEvents_39118310;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
  ## 
  let valid = call_39118315.validator(path, query, header, formData, body, _)
  let scheme = call_39118315.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118315.url(scheme.get, call_39118315.host, call_39118315.base,
                           call_39118315.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118315, url, valid, _)

proc call*(call_39118316: Call_GetUsersUsernameEvents_39118310; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameEvents
  ## If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39118317 = newJObject()
  var header_39118318 = newJObject()
  add(path_39118317, "username", newJString(username))
  add(header_39118318, "Accept", newJString(Accept))
  result = call_39118316.call(path_39118317, nil, header_39118318, nil, nil)

var getUsersUsernameEvents* = Call_GetUsersUsernameEvents_39118310(
    name: "getUsersUsernameEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/events",
    validator: validate_GetUsersUsernameEvents_39118311, base: "/",
    url: url_GetUsersUsernameEvents_39118312, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameEventsOrgsOrg_39118319 = ref object of OpenApiRestCall_39115352
proc url_GetUsersUsernameEventsOrgsOrg_39118321(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/events/orgs/"),
               (kind: VariableSegment, value: "org")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameEventsOrgsOrg_39118320(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## This is the user's organization dashboard. You must be authenticated as the user to view this.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  ##   org: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39118322 = path.getOrDefault("username")
  valid_39118322 = validateParameter(valid_39118322, JString, required = true,
                                   default = nil)
  if valid_39118322 != nil:
    section.add "username", valid_39118322
  var valid_39118323 = path.getOrDefault("org")
  valid_39118323 = validateParameter(valid_39118323, JString, required = true,
                                   default = nil)
  if valid_39118323 != nil:
    section.add "org", valid_39118323
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118324 = header.getOrDefault("Accept")
  valid_39118324 = validateParameter(valid_39118324, JString, required = false,
                                   default = nil)
  if valid_39118324 != nil:
    section.add "Accept", valid_39118324
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118325: Call_GetUsersUsernameEventsOrgsOrg_39118319;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## This is the user's organization dashboard. You must be authenticated as the user to view this.
  ## 
  let valid = call_39118325.validator(path, query, header, formData, body, _)
  let scheme = call_39118325.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118325.url(scheme.get, call_39118325.host, call_39118325.base,
                           call_39118325.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118325, url, valid, _)

proc call*(call_39118326: Call_GetUsersUsernameEventsOrgsOrg_39118319;
          username: string; org: string; Accept: string = ""): Recallable =
  ## getUsersUsernameEventsOrgsOrg
  ## This is the user's organization dashboard. You must be authenticated as the user to view this.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  var path_39118327 = newJObject()
  var header_39118328 = newJObject()
  add(path_39118327, "username", newJString(username))
  add(header_39118328, "Accept", newJString(Accept))
  add(path_39118327, "org", newJString(org))
  result = call_39118326.call(path_39118327, nil, header_39118328, nil, nil)

var getUsersUsernameEventsOrgsOrg* = Call_GetUsersUsernameEventsOrgsOrg_39118319(
    name: "getUsersUsernameEventsOrgsOrg", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/events/orgs/{org}",
    validator: validate_GetUsersUsernameEventsOrgsOrg_39118320, base: "/",
    url: url_GetUsersUsernameEventsOrgsOrg_39118321, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameFollowers_39118329 = ref object of OpenApiRestCall_39115352
proc url_GetUsersUsernameFollowers_39118331(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/followers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameFollowers_39118330(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List a user's followers
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39118332 = path.getOrDefault("username")
  valid_39118332 = validateParameter(valid_39118332, JString, required = true,
                                   default = nil)
  if valid_39118332 != nil:
    section.add "username", valid_39118332
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118333 = header.getOrDefault("Accept")
  valid_39118333 = validateParameter(valid_39118333, JString, required = false,
                                   default = nil)
  if valid_39118333 != nil:
    section.add "Accept", valid_39118333
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118334: Call_GetUsersUsernameFollowers_39118329;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List a user's followers
  ## 
  let valid = call_39118334.validator(path, query, header, formData, body, _)
  let scheme = call_39118334.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118334.url(scheme.get, call_39118334.host, call_39118334.base,
                           call_39118334.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118334, url, valid, _)

proc call*(call_39118335: Call_GetUsersUsernameFollowers_39118329;
          username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameFollowers
  ## List a user's followers
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39118336 = newJObject()
  var header_39118337 = newJObject()
  add(path_39118336, "username", newJString(username))
  add(header_39118337, "Accept", newJString(Accept))
  result = call_39118335.call(path_39118336, nil, header_39118337, nil, nil)

var getUsersUsernameFollowers* = Call_GetUsersUsernameFollowers_39118329(
    name: "getUsersUsernameFollowers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/followers",
    validator: validate_GetUsersUsernameFollowers_39118330, base: "/",
    url: url_GetUsersUsernameFollowers_39118331, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameFollowingTargetUser_39118338 = ref object of OpenApiRestCall_39115352
proc url_GetUsersUsernameFollowingTargetUser_39118340(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  assert "targetUser" in path, "`targetUser` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/following/"),
               (kind: VariableSegment, value: "targetUser")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameFollowingTargetUser_39118339(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## Check if one user follows another.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  ##   targetUser: JString (required)
  ##             : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39118341 = path.getOrDefault("username")
  valid_39118341 = validateParameter(valid_39118341, JString, required = true,
                                   default = nil)
  if valid_39118341 != nil:
    section.add "username", valid_39118341
  var valid_39118342 = path.getOrDefault("targetUser")
  valid_39118342 = validateParameter(valid_39118342, JString, required = true,
                                   default = nil)
  if valid_39118342 != nil:
    section.add "targetUser", valid_39118342
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118343 = header.getOrDefault("Accept")
  valid_39118343 = validateParameter(valid_39118343, JString, required = false,
                                   default = nil)
  if valid_39118343 != nil:
    section.add "Accept", valid_39118343
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118344: Call_GetUsersUsernameFollowingTargetUser_39118338;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Check if one user follows another.
  ## 
  let valid = call_39118344.validator(path, query, header, formData, body, _)
  let scheme = call_39118344.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118344.url(scheme.get, call_39118344.host, call_39118344.base,
                           call_39118344.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118344, url, valid, _)

proc call*(call_39118345: Call_GetUsersUsernameFollowingTargetUser_39118338;
          username: string; targetUser: string; Accept: string = ""): Recallable =
  ## getUsersUsernameFollowingTargetUser
  ## Check if one user follows another.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   targetUser: string (required)
  ##             : Name of user.
  var path_39118346 = newJObject()
  var header_39118347 = newJObject()
  add(path_39118346, "username", newJString(username))
  add(header_39118347, "Accept", newJString(Accept))
  add(path_39118346, "targetUser", newJString(targetUser))
  result = call_39118345.call(path_39118346, nil, header_39118347, nil, nil)

var getUsersUsernameFollowingTargetUser* = Call_GetUsersUsernameFollowingTargetUser_39118338(
    name: "getUsersUsernameFollowingTargetUser", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/following/{targetUser}",
    validator: validate_GetUsersUsernameFollowingTargetUser_39118339, base: "/",
    url: url_GetUsersUsernameFollowingTargetUser_39118340, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameGists_39118348 = ref object of OpenApiRestCall_39115352
proc url_GetUsersUsernameGists_39118350(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/gists")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameGists_39118349(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List a users gists.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39118351 = path.getOrDefault("username")
  valid_39118351 = validateParameter(valid_39118351, JString, required = true,
                                   default = nil)
  if valid_39118351 != nil:
    section.add "username", valid_39118351
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_39118352 = query.getOrDefault("since")
  valid_39118352 = validateParameter(valid_39118352, JString, required = false,
                                   default = nil)
  if valid_39118352 != nil:
    section.add "since", valid_39118352
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118353 = header.getOrDefault("Accept")
  valid_39118353 = validateParameter(valid_39118353, JString, required = false,
                                   default = nil)
  if valid_39118353 != nil:
    section.add "Accept", valid_39118353
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118354: Call_GetUsersUsernameGists_39118348;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List a users gists.
  ## 
  let valid = call_39118354.validator(path, query, header, formData, body, _)
  let scheme = call_39118354.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118354.url(scheme.get, call_39118354.host, call_39118354.base,
                           call_39118354.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118354, url, valid, _)

proc call*(call_39118355: Call_GetUsersUsernameGists_39118348; username: string;
          Accept: string = ""; since: string = ""): Recallable =
  ## getUsersUsernameGists
  ## List a users gists.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var path_39118356 = newJObject()
  var query_39118357 = newJObject()
  var header_39118358 = newJObject()
  add(path_39118356, "username", newJString(username))
  add(header_39118358, "Accept", newJString(Accept))
  add(query_39118357, "since", newJString(since))
  result = call_39118355.call(path_39118356, query_39118357, header_39118358, nil, nil)

var getUsersUsernameGists* = Call_GetUsersUsernameGists_39118348(
    name: "getUsersUsernameGists", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/users/{username}/gists", validator: validate_GetUsersUsernameGists_39118349,
    base: "/", url: url_GetUsersUsernameGists_39118350, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameKeys_39118359 = ref object of OpenApiRestCall_39115352
proc url_GetUsersUsernameKeys_39118361(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/keys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameKeys_39118360(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List public keys for a user.
  ## Lists the verified public keys for a user. This is accessible by anyone.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39118362 = path.getOrDefault("username")
  valid_39118362 = validateParameter(valid_39118362, JString, required = true,
                                   default = nil)
  if valid_39118362 != nil:
    section.add "username", valid_39118362
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118363 = header.getOrDefault("Accept")
  valid_39118363 = validateParameter(valid_39118363, JString, required = false,
                                   default = nil)
  if valid_39118363 != nil:
    section.add "Accept", valid_39118363
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118364: Call_GetUsersUsernameKeys_39118359; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List public keys for a user.
  ## Lists the verified public keys for a user. This is accessible by anyone.
  ## 
  ## 
  let valid = call_39118364.validator(path, query, header, formData, body, _)
  let scheme = call_39118364.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118364.url(scheme.get, call_39118364.host, call_39118364.base,
                           call_39118364.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118364, url, valid, _)

proc call*(call_39118365: Call_GetUsersUsernameKeys_39118359; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameKeys
  ## List public keys for a user.
  ## Lists the verified public keys for a user. This is accessible by anyone.
  ## 
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39118366 = newJObject()
  var header_39118367 = newJObject()
  add(path_39118366, "username", newJString(username))
  add(header_39118367, "Accept", newJString(Accept))
  result = call_39118365.call(path_39118366, nil, header_39118367, nil, nil)

var getUsersUsernameKeys* = Call_GetUsersUsernameKeys_39118359(
    name: "getUsersUsernameKeys", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/users/{username}/keys", validator: validate_GetUsersUsernameKeys_39118360,
    base: "/", url: url_GetUsersUsernameKeys_39118361, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameOrgs_39118368 = ref object of OpenApiRestCall_39115352
proc url_GetUsersUsernameOrgs_39118370(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/orgs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameOrgs_39118369(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List all public organizations for a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39118371 = path.getOrDefault("username")
  valid_39118371 = validateParameter(valid_39118371, JString, required = true,
                                   default = nil)
  if valid_39118371 != nil:
    section.add "username", valid_39118371
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118372 = header.getOrDefault("Accept")
  valid_39118372 = validateParameter(valid_39118372, JString, required = false,
                                   default = nil)
  if valid_39118372 != nil:
    section.add "Accept", valid_39118372
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118373: Call_GetUsersUsernameOrgs_39118368; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## List all public organizations for a user.
  ## 
  let valid = call_39118373.validator(path, query, header, formData, body, _)
  let scheme = call_39118373.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118373.url(scheme.get, call_39118373.host, call_39118373.base,
                           call_39118373.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118373, url, valid, _)

proc call*(call_39118374: Call_GetUsersUsernameOrgs_39118368; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameOrgs
  ## List all public organizations for a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39118375 = newJObject()
  var header_39118376 = newJObject()
  add(path_39118375, "username", newJString(username))
  add(header_39118376, "Accept", newJString(Accept))
  result = call_39118374.call(path_39118375, nil, header_39118376, nil, nil)

var getUsersUsernameOrgs* = Call_GetUsersUsernameOrgs_39118368(
    name: "getUsersUsernameOrgs", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/users/{username}/orgs", validator: validate_GetUsersUsernameOrgs_39118369,
    base: "/", url: url_GetUsersUsernameOrgs_39118370, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameReceivedEvents_39118377 = ref object of OpenApiRestCall_39115352
proc url_GetUsersUsernameReceivedEvents_39118379(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/received_events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameReceivedEvents_39118378(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## These are events that you'll only see public events.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39118380 = path.getOrDefault("username")
  valid_39118380 = validateParameter(valid_39118380, JString, required = true,
                                   default = nil)
  if valid_39118380 != nil:
    section.add "username", valid_39118380
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118381 = header.getOrDefault("Accept")
  valid_39118381 = validateParameter(valid_39118381, JString, required = false,
                                   default = nil)
  if valid_39118381 != nil:
    section.add "Accept", valid_39118381
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118382: Call_GetUsersUsernameReceivedEvents_39118377;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## These are events that you'll only see public events.
  ## 
  let valid = call_39118382.validator(path, query, header, formData, body, _)
  let scheme = call_39118382.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118382.url(scheme.get, call_39118382.host, call_39118382.base,
                           call_39118382.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118382, url, valid, _)

proc call*(call_39118383: Call_GetUsersUsernameReceivedEvents_39118377;
          username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameReceivedEvents
  ## These are events that you'll only see public events.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39118384 = newJObject()
  var header_39118385 = newJObject()
  add(path_39118384, "username", newJString(username))
  add(header_39118385, "Accept", newJString(Accept))
  result = call_39118383.call(path_39118384, nil, header_39118385, nil, nil)

var getUsersUsernameReceivedEvents* = Call_GetUsersUsernameReceivedEvents_39118377(
    name: "getUsersUsernameReceivedEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/received_events",
    validator: validate_GetUsersUsernameReceivedEvents_39118378, base: "/",
    url: url_GetUsersUsernameReceivedEvents_39118379, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameReceivedEventsPublic_39118386 = ref object of OpenApiRestCall_39115352
proc url_GetUsersUsernameReceivedEventsPublic_39118388(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/received_events/public")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameReceivedEventsPublic_39118387(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List public events that a user has received
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39118389 = path.getOrDefault("username")
  valid_39118389 = validateParameter(valid_39118389, JString, required = true,
                                   default = nil)
  if valid_39118389 != nil:
    section.add "username", valid_39118389
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118390 = header.getOrDefault("Accept")
  valid_39118390 = validateParameter(valid_39118390, JString, required = false,
                                   default = nil)
  if valid_39118390 != nil:
    section.add "Accept", valid_39118390
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118391: Call_GetUsersUsernameReceivedEventsPublic_39118386;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List public events that a user has received
  ## 
  let valid = call_39118391.validator(path, query, header, formData, body, _)
  let scheme = call_39118391.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118391.url(scheme.get, call_39118391.host, call_39118391.base,
                           call_39118391.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118391, url, valid, _)

proc call*(call_39118392: Call_GetUsersUsernameReceivedEventsPublic_39118386;
          username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameReceivedEventsPublic
  ## List public events that a user has received
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39118393 = newJObject()
  var header_39118394 = newJObject()
  add(path_39118393, "username", newJString(username))
  add(header_39118394, "Accept", newJString(Accept))
  result = call_39118392.call(path_39118393, nil, header_39118394, nil, nil)

var getUsersUsernameReceivedEventsPublic* = Call_GetUsersUsernameReceivedEventsPublic_39118386(
    name: "getUsersUsernameReceivedEventsPublic", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/received_events/public",
    validator: validate_GetUsersUsernameReceivedEventsPublic_39118387, base: "/",
    url: url_GetUsersUsernameReceivedEventsPublic_39118388,
    schemes: {Scheme.Https})
type
  Call_GetUsersUsernameRepos_39118395 = ref object of OpenApiRestCall_39115352
proc url_GetUsersUsernameRepos_39118397(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameRepos_39118396(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List public repositories for the specified user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39118398 = path.getOrDefault("username")
  valid_39118398 = validateParameter(valid_39118398, JString, required = true,
                                   default = nil)
  if valid_39118398 != nil:
    section.add "username", valid_39118398
  result.add "path", section
  ## parameters in `query` object:
  ##   type: JString
  section = newJObject()
  var valid_39118399 = query.getOrDefault("type")
  valid_39118399 = validateParameter(valid_39118399, JString, required = false,
                                   default = newJString("all"))
  if valid_39118399 != nil:
    section.add "type", valid_39118399
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118400 = header.getOrDefault("Accept")
  valid_39118400 = validateParameter(valid_39118400, JString, required = false,
                                   default = nil)
  if valid_39118400 != nil:
    section.add "Accept", valid_39118400
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118401: Call_GetUsersUsernameRepos_39118395;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List public repositories for the specified user.
  ## 
  let valid = call_39118401.validator(path, query, header, formData, body, _)
  let scheme = call_39118401.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118401.url(scheme.get, call_39118401.host, call_39118401.base,
                           call_39118401.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118401, url, valid, _)

proc call*(call_39118402: Call_GetUsersUsernameRepos_39118395; username: string;
          Accept: string = ""; `type`: string = "all"): Recallable =
  ## getUsersUsernameRepos
  ## List public repositories for the specified user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   type: string
  var path_39118403 = newJObject()
  var query_39118404 = newJObject()
  var header_39118405 = newJObject()
  add(path_39118403, "username", newJString(username))
  add(header_39118405, "Accept", newJString(Accept))
  add(query_39118404, "type", newJString(`type`))
  result = call_39118402.call(path_39118403, query_39118404, header_39118405, nil, nil)

var getUsersUsernameRepos* = Call_GetUsersUsernameRepos_39118395(
    name: "getUsersUsernameRepos", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/users/{username}/repos", validator: validate_GetUsersUsernameRepos_39118396,
    base: "/", url: url_GetUsersUsernameRepos_39118397, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameStarred_39118406 = ref object of OpenApiRestCall_39115352
proc url_GetUsersUsernameStarred_39118408(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/starred")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameStarred_39118407(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode {.
    nosinks.} =
  ## List repositories being starred by a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39118409 = path.getOrDefault("username")
  valid_39118409 = validateParameter(valid_39118409, JString, required = true,
                                   default = nil)
  if valid_39118409 != nil:
    section.add "username", valid_39118409
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118410 = header.getOrDefault("Accept")
  valid_39118410 = validateParameter(valid_39118410, JString, required = false,
                                   default = nil)
  if valid_39118410 != nil:
    section.add "Accept", valid_39118410
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118411: Call_GetUsersUsernameStarred_39118406;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List repositories being starred by a user.
  ## 
  let valid = call_39118411.validator(path, query, header, formData, body, _)
  let scheme = call_39118411.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118411.url(scheme.get, call_39118411.host, call_39118411.base,
                           call_39118411.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118411, url, valid, _)

proc call*(call_39118412: Call_GetUsersUsernameStarred_39118406; username: string;
          Accept: string = ""): Recallable =
  ## getUsersUsernameStarred
  ## List repositories being starred by a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39118413 = newJObject()
  var header_39118414 = newJObject()
  add(path_39118413, "username", newJString(username))
  add(header_39118414, "Accept", newJString(Accept))
  result = call_39118412.call(path_39118413, nil, header_39118414, nil, nil)

var getUsersUsernameStarred* = Call_GetUsersUsernameStarred_39118406(
    name: "getUsersUsernameStarred", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/starred",
    validator: validate_GetUsersUsernameStarred_39118407, base: "/",
    url: url_GetUsersUsernameStarred_39118408, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameSubscriptions_39118415 = ref object of OpenApiRestCall_39115352
proc url_GetUsersUsernameSubscriptions_39118417(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
               (kind: VariableSegment, value: "username"),
               (kind: ConstantSegment, value: "/subscriptions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameSubscriptions_39118416(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode {.nosinks.} =
  ## List repositories being watched by a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `username` field"
  var valid_39118418 = path.getOrDefault("username")
  valid_39118418 = validateParameter(valid_39118418, JString, required = true,
                                   default = nil)
  if valid_39118418 != nil:
    section.add "username", valid_39118418
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_39118419 = header.getOrDefault("Accept")
  valid_39118419 = validateParameter(valid_39118419, JString, required = false,
                                   default = nil)
  if valid_39118419 != nil:
    section.add "Accept", valid_39118419
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_39118420: Call_GetUsersUsernameSubscriptions_39118415;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## List repositories being watched by a user.
  ## 
  let valid = call_39118420.validator(path, query, header, formData, body, _)
  let scheme = call_39118420.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_39118420.url(scheme.get, call_39118420.host, call_39118420.base,
                           call_39118420.route, valid.getOrDefault("path"),
                           valid.getOrDefault("query"))
  result = hook(call_39118420, url, valid, _)

proc call*(call_39118421: Call_GetUsersUsernameSubscriptions_39118415;
          username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameSubscriptions
  ## List repositories being watched by a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_39118422 = newJObject()
  var header_39118423 = newJObject()
  add(path_39118422, "username", newJString(username))
  add(header_39118423, "Accept", newJString(Accept))
  result = call_39118421.call(path_39118422, nil, header_39118423, nil, nil)

var getUsersUsernameSubscriptions* = Call_GetUsersUsernameSubscriptions_39118415(
    name: "getUsersUsernameSubscriptions", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/subscriptions",
    validator: validate_GetUsersUsernameSubscriptions_39118416, base: "/",
    url: url_GetUsersUsernameSubscriptions_39118417, schemes: {Scheme.Https})
export
  rest

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.} =
  var headers = massageHeaders(input.getOrDefault("header")).newHttpHeaders
  let token = os.getEnv("GITHUB_TOKEN", "")
  if not headers.hasKey("Authorization") and token.len > 0:
    headers.add "Authorization", "token " & token
  if headers.hasKey "Accept":
    headers.del "Accept"
  headers.add "Accept", "application/vnd.github.v3+json"
  result = newRecallable(call, url, headers, input.getOrDefault("body").getStr)
