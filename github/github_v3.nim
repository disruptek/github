
import
  json, options, hashes, uri, strutils, rest, os, uri, httpcore

## auto-generated via openapi macro
## title: GitHub
## version: v3
## termsOfService: https://help.github.com/articles/github-terms-of-service/#b-api-terms
## license: (not provided)
## 
## Powerful collaboration, code review, and code management for open source and private projects.
## 
## 
## https://developer.github.com/v3/
type
  Scheme* {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (path: JsonNode = nil; query: JsonNode = nil;
                             header: JsonNode = nil; formData: JsonNode = nil;
                             body: JsonNode = nil; content: string = ""): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    makeUrl*: proc (protocol: Scheme; host: string; base: string; route: string;
                    path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_553648476 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_553648476](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base,
             route: t.route, schemes: t.schemes, validator: t.validator,
             url: t.url)

proc pickScheme(t: OpenApiRestCall_553648476): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low .. Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                       default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js == nil:
    if required:
      if default != nil:
        return validateParameter(default, kind, required = required)
  result = js
  if result == nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind == kind, $kind & " expected; received " & $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string {.used.} =
  proc toString(js: JsonNode): string =
    case js.kind
    of JNull:
      ""
    of JInt:
      $(getInt js)
    of JFloat:
      $(getFloat js)
    of JBool:
      $(getBool js)
    else:
      getStr js

  if query.isNil:
    return ""
  var qs: seq[KeyVal]
  for k, v in query.pairs:
    if not v.isNil and v.kind == JArray:
      if v.len == 0:
        qs.add (key: k, val: "")
      else:
        for v in v.items:
          qs.add (key: k, val: v.toString)
    else:
      qs.add (key: k, val: v.toString)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] {.
    used.} =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    case js.kind
    of JInt, JFloat, JNull, JBool:
      head = $js
    of JString:
      head = js.getStr
    else:
      return
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode; body: string = ""): Recallable {.
    base.}
type
  Call_GetEmojis_553648624 = ref object of OpenApiRestCall_553648476
proc url_GetEmojis_553648626(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEmojis_553648625(path: JsonNode; query: JsonNode;
                                  header: JsonNode; formData: JsonNode;
                                  body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Lists all the emojis available to use on GitHub.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553648726 = header.getOrDefault("Accept")
  valid_553648726 = validateParameter(valid_553648726, JString,
                                      required = false, default = nil)
  if valid_553648726 != nil:
    section.add "Accept", valid_553648726
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553648738: Call_GetEmojis_553648624; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Lists all the emojis available to use on GitHub.
  ## 
  let valid = call_553648738.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553648738.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553648738.makeUrl(scheme.get, call_553648738.host, call_553648738.base,
                                   call_553648738.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553648738, uri, valid, content)

proc call*(call_553648787: Call_GetEmojis_553648624; Accept: string = ""): Recallable =
  ## getEmojis
  ## Lists all the emojis available to use on GitHub.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_553648788 = newJObject()
  add(header_553648788, "Accept", newJString(Accept))
  result = call_553648787.call(nil, nil, header_553648788, nil, nil)

var getEmojis* = Call_GetEmojis_553648624(name: "getEmojis",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/emojis",
    validator: validate_GetEmojis_553648625, base: "/", makeUrl: url_GetEmojis_553648626,
    schemes: {Scheme.Https})
type
  Call_GetEvents_553648818 = ref object of OpenApiRestCall_553648476
proc url_GetEvents_553648820(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEvents_553648819(path: JsonNode; query: JsonNode;
                                  header: JsonNode; formData: JsonNode;
                                  body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List public events.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553648821 = header.getOrDefault("Accept")
  valid_553648821 = validateParameter(valid_553648821, JString,
                                      required = false, default = nil)
  if valid_553648821 != nil:
    section.add "Accept", valid_553648821
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553648822: Call_GetEvents_553648818; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List public events.
  ## 
  let valid = call_553648822.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553648822.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553648822.makeUrl(scheme.get, call_553648822.host, call_553648822.base,
                                   call_553648822.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553648822, uri, valid, content)

proc call*(call_553648823: Call_GetEvents_553648818; Accept: string = ""): Recallable =
  ## getEvents
  ## List public events.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_553648824 = newJObject()
  add(header_553648824, "Accept", newJString(Accept))
  result = call_553648823.call(nil, nil, header_553648824, nil, nil)

var getEvents* = Call_GetEvents_553648818(name: "getEvents",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/events",
    validator: validate_GetEvents_553648819, base: "/", makeUrl: url_GetEvents_553648820,
    schemes: {Scheme.Https})
type
  Call_GetFeeds_553648825 = ref object of OpenApiRestCall_553648476
proc url_GetFeeds_553648827(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetFeeds_553648826(path: JsonNode; query: JsonNode;
                                 header: JsonNode; formData: JsonNode;
                                 body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List Feeds.
  ## GitHub provides several timeline resources in Atom format. The Feeds API
  ##  lists all the feeds available to the authenticating user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553648828 = header.getOrDefault("Accept")
  valid_553648828 = validateParameter(valid_553648828, JString,
                                      required = false, default = nil)
  if valid_553648828 != nil:
    section.add "Accept", valid_553648828
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553648829: Call_GetFeeds_553648825; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List Feeds.
  ## GitHub provides several timeline resources in Atom format. The Feeds API
  ##  lists all the feeds available to the authenticating user.
  ## 
  ## 
  let valid = call_553648829.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553648829.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553648829.makeUrl(scheme.get, call_553648829.host, call_553648829.base,
                                   call_553648829.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553648829, uri, valid, content)

proc call*(call_553648830: Call_GetFeeds_553648825; Accept: string = ""): Recallable =
  ## getFeeds
  ## List Feeds.
  ## GitHub provides several timeline resources in Atom format. The Feeds API
  ##  lists all the feeds available to the authenticating user.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_553648831 = newJObject()
  add(header_553648831, "Accept", newJString(Accept))
  result = call_553648830.call(nil, nil, header_553648831, nil, nil)

var getFeeds* = Call_GetFeeds_553648825(name: "getFeeds",
                                        meth: HttpMethod.HttpGet,
                                        host: "api.github.com", route: "/feeds",
                                        validator: validate_GetFeeds_553648826,
                                        base: "/", makeUrl: url_GetFeeds_553648827,
                                        schemes: {Scheme.Https})
type
  Call_PostGists_553648841 = ref object of OpenApiRestCall_553648476
proc url_PostGists_553648843(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostGists_553648842(path: JsonNode; query: JsonNode;
                                  header: JsonNode; formData: JsonNode;
                                  body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Create a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553648853 = header.getOrDefault("Accept")
  valid_553648853 = validateParameter(valid_553648853, JString,
                                      required = false, default = nil)
  if valid_553648853 != nil:
    section.add "Accept", valid_553648853
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553648855: Call_PostGists_553648841; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Create a gist.
  ## 
  let valid = call_553648855.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553648855.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553648855.makeUrl(scheme.get, call_553648855.host, call_553648855.base,
                                   call_553648855.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553648855, uri, valid, content)

proc call*(call_553648856: Call_PostGists_553648841; body: JsonNode;
           Accept: string = ""): Recallable =
  ## postGists
  ## Create a gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_553648857 = newJObject()
  var body_553648858 = newJObject()
  add(header_553648857, "Accept", newJString(Accept))
  if body != nil:
    body_553648858 = body
  result = call_553648856.call(nil, nil, header_553648857, nil, body_553648858)

var postGists* = Call_PostGists_553648841(name: "postGists",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/gists",
    validator: validate_PostGists_553648842, base: "/", makeUrl: url_PostGists_553648843,
    schemes: {Scheme.Https})
type
  Call_GetGists_553648832 = ref object of OpenApiRestCall_553648476
proc url_GetGists_553648834(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGists_553648833(path: JsonNode; query: JsonNode;
                                 header: JsonNode; formData: JsonNode;
                                 body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List the authenticated user's gists or if called anonymously, this will
  ## return all public gists.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_553648835 = query.getOrDefault("since")
  valid_553648835 = validateParameter(valid_553648835, JString,
                                      required = false, default = nil)
  if valid_553648835 != nil:
    section.add "since", valid_553648835
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553648836 = header.getOrDefault("Accept")
  valid_553648836 = validateParameter(valid_553648836, JString,
                                      required = false, default = nil)
  if valid_553648836 != nil:
    section.add "Accept", valid_553648836
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553648837: Call_GetGists_553648832; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List the authenticated user's gists or if called anonymously, this will
  ## return all public gists.
  ## 
  ## 
  let valid = call_553648837.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553648837.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553648837.makeUrl(scheme.get, call_553648837.host, call_553648837.base,
                                   call_553648837.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553648837, uri, valid, content)

proc call*(call_553648838: Call_GetGists_553648832; Accept: string = "";
           since: string = ""): Recallable =
  ## getGists
  ## List the authenticated user's gists or if called anonymously, this will
  ## return all public gists.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: string
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  var query_553648839 = newJObject()
  var header_553648840 = newJObject()
  add(header_553648840, "Accept", newJString(Accept))
  add(query_553648839, "since", newJString(since))
  result = call_553648838.call(nil, query_553648839, header_553648840, nil, nil)

var getGists* = Call_GetGists_553648832(name: "getGists",
                                        meth: HttpMethod.HttpGet,
                                        host: "api.github.com", route: "/gists",
                                        validator: validate_GetGists_553648833,
                                        base: "/", makeUrl: url_GetGists_553648834,
                                        schemes: {Scheme.Https})
type
  Call_GetGistsPublic_553648859 = ref object of OpenApiRestCall_553648476
proc url_GetGistsPublic_553648861(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGistsPublic_553648860(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List all public gists.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_553648862 = query.getOrDefault("since")
  valid_553648862 = validateParameter(valid_553648862, JString,
                                      required = false, default = nil)
  if valid_553648862 != nil:
    section.add "since", valid_553648862
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553648863 = header.getOrDefault("Accept")
  valid_553648863 = validateParameter(valid_553648863, JString,
                                      required = false, default = nil)
  if valid_553648863 != nil:
    section.add "Accept", valid_553648863
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553648864: Call_GetGistsPublic_553648859; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List all public gists.
  ## 
  let valid = call_553648864.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553648864.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553648864.makeUrl(scheme.get, call_553648864.host, call_553648864.base,
                                   call_553648864.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553648864, uri, valid, content)

proc call*(call_553648865: Call_GetGistsPublic_553648859; Accept: string = "";
           since: string = ""): Recallable =
  ## getGistsPublic
  ## List all public gists.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: string
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  var query_553648866 = newJObject()
  var header_553648867 = newJObject()
  add(header_553648867, "Accept", newJString(Accept))
  add(query_553648866, "since", newJString(since))
  result = call_553648865.call(nil, query_553648866, header_553648867, nil, nil)

var getGistsPublic* = Call_GetGistsPublic_553648859(name: "getGistsPublic",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/gists/public",
    validator: validate_GetGistsPublic_553648860, base: "/",
    makeUrl: url_GetGistsPublic_553648861, schemes: {Scheme.Https})
type
  Call_GetGistsStarred_553648868 = ref object of OpenApiRestCall_553648476
proc url_GetGistsStarred_553648870(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode;
                                   query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGistsStarred_553648869(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List the authenticated user's starred gists.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_553648871 = query.getOrDefault("since")
  valid_553648871 = validateParameter(valid_553648871, JString,
                                      required = false, default = nil)
  if valid_553648871 != nil:
    section.add "since", valid_553648871
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553648872 = header.getOrDefault("Accept")
  valid_553648872 = validateParameter(valid_553648872, JString,
                                      required = false, default = nil)
  if valid_553648872 != nil:
    section.add "Accept", valid_553648872
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553648873: Call_GetGistsStarred_553648868; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List the authenticated user's starred gists.
  ## 
  let valid = call_553648873.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553648873.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553648873.makeUrl(scheme.get, call_553648873.host, call_553648873.base,
                                   call_553648873.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553648873, uri, valid, content)

proc call*(call_553648874: Call_GetGistsStarred_553648868; Accept: string = "";
           since: string = ""): Recallable =
  ## getGistsStarred
  ## List the authenticated user's starred gists.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: string
  ##        : Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
  ## Only gists updated at or after this time are returned.
  ## 
  var query_553648875 = newJObject()
  var header_553648876 = newJObject()
  add(header_553648876, "Accept", newJString(Accept))
  add(query_553648875, "since", newJString(since))
  result = call_553648874.call(nil, query_553648875, header_553648876, nil, nil)

var getGistsStarred* = Call_GetGistsStarred_553648868(name: "getGistsStarred",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/gists/starred",
    validator: validate_GetGistsStarred_553648869, base: "/",
    makeUrl: url_GetGistsStarred_553648870, schemes: {Scheme.Https})
type
  Call_GetGistsId_553648877 = ref object of OpenApiRestCall_553648476
proc url_GetGistsId_553648879(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
                 (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsId_553648878(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Get a single gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_553648891 = path.getOrDefault("id")
  valid_553648891 = validateParameter(valid_553648891, JInt, required = true,
                                      default = nil)
  if valid_553648891 != nil:
    section.add "id", valid_553648891
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553648892 = header.getOrDefault("Accept")
  valid_553648892 = validateParameter(valid_553648892, JString,
                                      required = false, default = nil)
  if valid_553648892 != nil:
    section.add "Accept", valid_553648892
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553648893: Call_GetGistsId_553648877; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get a single gist.
  ## 
  let valid = call_553648893.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553648893.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553648893.makeUrl(scheme.get, call_553648893.host, call_553648893.base,
                                   call_553648893.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553648893, uri, valid, content)

proc call*(call_553648894: Call_GetGistsId_553648877; id: int;
           Accept: string = ""): Recallable =
  ## getGistsId
  ## Get a single gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_553648895 = newJObject()
  var header_553648896 = newJObject()
  add(path_553648895, "id", newJInt(id))
  add(header_553648896, "Accept", newJString(Accept))
  result = call_553648894.call(path_553648895, nil, header_553648896, nil, nil)

var getGistsId* = Call_GetGistsId_553648877(name: "getGistsId",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/gists/{id}",
    validator: validate_GetGistsId_553648878, base: "/",
    makeUrl: url_GetGistsId_553648879, schemes: {Scheme.Https})
type
  Call_PatchGistsId_553648906 = ref object of OpenApiRestCall_553648476
proc url_PatchGistsId_553648908(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
                 (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchGistsId_553648907(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Edit a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_553648909 = path.getOrDefault("id")
  valid_553648909 = validateParameter(valid_553648909, JInt, required = true,
                                      default = nil)
  if valid_553648909 != nil:
    section.add "id", valid_553648909
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553648910 = header.getOrDefault("Accept")
  valid_553648910 = validateParameter(valid_553648910, JString,
                                      required = false, default = nil)
  if valid_553648910 != nil:
    section.add "Accept", valid_553648910
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553648912: Call_PatchGistsId_553648906; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Edit a gist.
  ## 
  let valid = call_553648912.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553648912.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553648912.makeUrl(scheme.get, call_553648912.host, call_553648912.base,
                                   call_553648912.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553648912, uri, valid, content)

proc call*(call_553648913: Call_PatchGistsId_553648906; id: int; body: JsonNode;
           Accept: string = ""): Recallable =
  ## patchGistsId
  ## Edit a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var path_553648914 = newJObject()
  var header_553648915 = newJObject()
  var body_553648916 = newJObject()
  add(path_553648914, "id", newJInt(id))
  add(header_553648915, "Accept", newJString(Accept))
  if body != nil:
    body_553648916 = body
  result = call_553648913.call(path_553648914, nil, header_553648915, nil, body_553648916)

var patchGistsId* = Call_PatchGistsId_553648906(name: "patchGistsId",
    meth: HttpMethod.HttpPatch, host: "api.github.com", route: "/gists/{id}",
    validator: validate_PatchGistsId_553648907, base: "/",
    makeUrl: url_PatchGistsId_553648908, schemes: {Scheme.Https})
type
  Call_DeleteGistsId_553648897 = ref object of OpenApiRestCall_553648476
proc url_DeleteGistsId_553648899(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
                 (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteGistsId_553648898(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Delete a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_553648900 = path.getOrDefault("id")
  valid_553648900 = validateParameter(valid_553648900, JInt, required = true,
                                      default = nil)
  if valid_553648900 != nil:
    section.add "id", valid_553648900
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553648901 = header.getOrDefault("Accept")
  valid_553648901 = validateParameter(valid_553648901, JString,
                                      required = false, default = nil)
  if valid_553648901 != nil:
    section.add "Accept", valid_553648901
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553648902: Call_DeleteGistsId_553648897; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Delete a gist.
  ## 
  let valid = call_553648902.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553648902.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553648902.makeUrl(scheme.get, call_553648902.host, call_553648902.base,
                                   call_553648902.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553648902, uri, valid, content)

proc call*(call_553648903: Call_DeleteGistsId_553648897; id: int;
           Accept: string = ""): Recallable =
  ## deleteGistsId
  ## Delete a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_553648904 = newJObject()
  var header_553648905 = newJObject()
  add(path_553648904, "id", newJInt(id))
  add(header_553648905, "Accept", newJString(Accept))
  result = call_553648903.call(path_553648904, nil, header_553648905, nil, nil)

var deleteGistsId* = Call_DeleteGistsId_553648897(name: "deleteGistsId",
    meth: HttpMethod.HttpDelete, host: "api.github.com", route: "/gists/{id}",
    validator: validate_DeleteGistsId_553648898, base: "/",
    makeUrl: url_DeleteGistsId_553648899, schemes: {Scheme.Https})
type
  Call_PostGistsIdComments_553648926 = ref object of OpenApiRestCall_553648476
proc url_PostGistsIdComments_553648928(protocol: Scheme; host: string;
                                       base: string; route: string;
                                       path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
                 (kind: VariableSegment, value: "id"),
                 (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostGistsIdComments_553648927(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Create a commen
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_553648929 = path.getOrDefault("id")
  valid_553648929 = validateParameter(valid_553648929, JInt, required = true,
                                      default = nil)
  if valid_553648929 != nil:
    section.add "id", valid_553648929
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553648930 = header.getOrDefault("Accept")
  valid_553648930 = validateParameter(valid_553648930, JString,
                                      required = false, default = nil)
  if valid_553648930 != nil:
    section.add "Accept", valid_553648930
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553648932: Call_PostGistsIdComments_553648926;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Create a commen
  ## 
  let valid = call_553648932.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553648932.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553648932.makeUrl(scheme.get, call_553648932.host, call_553648932.base,
                                   call_553648932.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553648932, uri, valid, content)

proc call*(call_553648933: Call_PostGistsIdComments_553648926; id: int;
           body: JsonNode; Accept: string = ""): Recallable =
  ## postGistsIdComments
  ## Create a commen
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var path_553648934 = newJObject()
  var header_553648935 = newJObject()
  var body_553648936 = newJObject()
  add(path_553648934, "id", newJInt(id))
  add(header_553648935, "Accept", newJString(Accept))
  if body != nil:
    body_553648936 = body
  result = call_553648933.call(path_553648934, nil, header_553648935, nil, body_553648936)

var postGistsIdComments* = Call_PostGistsIdComments_553648926(
    name: "postGistsIdComments", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/gists/{id}/comments",
    validator: validate_PostGistsIdComments_553648927, base: "/",
    makeUrl: url_PostGistsIdComments_553648928, schemes: {Scheme.Https})
type
  Call_GetGistsIdComments_553648917 = ref object of OpenApiRestCall_553648476
proc url_GetGistsIdComments_553648919(protocol: Scheme; host: string;
                                      base: string; route: string;
                                      path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
                 (kind: VariableSegment, value: "id"),
                 (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsIdComments_553648918(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List comments on a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_553648920 = path.getOrDefault("id")
  valid_553648920 = validateParameter(valid_553648920, JInt, required = true,
                                      default = nil)
  if valid_553648920 != nil:
    section.add "id", valid_553648920
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553648921 = header.getOrDefault("Accept")
  valid_553648921 = validateParameter(valid_553648921, JString,
                                      required = false, default = nil)
  if valid_553648921 != nil:
    section.add "Accept", valid_553648921
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553648922: Call_GetGistsIdComments_553648917;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List comments on a gist.
  ## 
  let valid = call_553648922.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553648922.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553648922.makeUrl(scheme.get, call_553648922.host, call_553648922.base,
                                   call_553648922.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553648922, uri, valid, content)

proc call*(call_553648923: Call_GetGistsIdComments_553648917; id: int;
           Accept: string = ""): Recallable =
  ## getGistsIdComments
  ## List comments on a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_553648924 = newJObject()
  var header_553648925 = newJObject()
  add(path_553648924, "id", newJInt(id))
  add(header_553648925, "Accept", newJString(Accept))
  result = call_553648923.call(path_553648924, nil, header_553648925, nil, nil)

var getGistsIdComments* = Call_GetGistsIdComments_553648917(
    name: "getGistsIdComments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/gists/{id}/comments",
    validator: validate_GetGistsIdComments_553648918, base: "/",
    makeUrl: url_GetGistsIdComments_553648919, schemes: {Scheme.Https})
type
  Call_GetGistsIdCommentsCommentId_553648937 = ref object of OpenApiRestCall_553648476
proc url_GetGistsIdCommentsCommentId_553648939(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
                 (kind: VariableSegment, value: "id"),
                 (kind: ConstantSegment, value: "/comments/"),
                 (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsIdCommentsCommentId_553648938(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get a single comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_553648940 = path.getOrDefault("id")
  valid_553648940 = validateParameter(valid_553648940, JInt, required = true,
                                      default = nil)
  if valid_553648940 != nil:
    section.add "id", valid_553648940
  var valid_553648941 = path.getOrDefault("commentId")
  valid_553648941 = validateParameter(valid_553648941, JInt, required = true,
                                      default = nil)
  if valid_553648941 != nil:
    section.add "commentId", valid_553648941
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553648942 = header.getOrDefault("Accept")
  valid_553648942 = validateParameter(valid_553648942, JString,
                                      required = false, default = nil)
  if valid_553648942 != nil:
    section.add "Accept", valid_553648942
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553648943: Call_GetGistsIdCommentsCommentId_553648937;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get a single comment.
  ## 
  let valid = call_553648943.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553648943.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553648943.makeUrl(scheme.get, call_553648943.host, call_553648943.base,
                                   call_553648943.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553648943, uri, valid, content)

proc call*(call_553648944: Call_GetGistsIdCommentsCommentId_553648937; id: int;
           commentId: int; Accept: string = ""): Recallable =
  ## getGistsIdCommentsCommentId
  ## Get a single comment.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_553648945 = newJObject()
  var header_553648946 = newJObject()
  add(path_553648945, "id", newJInt(id))
  add(header_553648946, "Accept", newJString(Accept))
  add(path_553648945, "commentId", newJInt(commentId))
  result = call_553648944.call(path_553648945, nil, header_553648946, nil, nil)

var getGistsIdCommentsCommentId* = Call_GetGistsIdCommentsCommentId_553648937(
    name: "getGistsIdCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/gists/{id}/comments/{commentId}",
    validator: validate_GetGistsIdCommentsCommentId_553648938, base: "/",
    makeUrl: url_GetGistsIdCommentsCommentId_553648939, schemes: {Scheme.Https})
type
  Call_PatchGistsIdCommentsCommentId_553648957 = ref object of OpenApiRestCall_553648476
proc url_PatchGistsIdCommentsCommentId_553648959(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
                 (kind: VariableSegment, value: "id"),
                 (kind: ConstantSegment, value: "/comments/"),
                 (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchGistsIdCommentsCommentId_553648958(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Edit a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_553648960 = path.getOrDefault("id")
  valid_553648960 = validateParameter(valid_553648960, JInt, required = true,
                                      default = nil)
  if valid_553648960 != nil:
    section.add "id", valid_553648960
  var valid_553648961 = path.getOrDefault("commentId")
  valid_553648961 = validateParameter(valid_553648961, JInt, required = true,
                                      default = nil)
  if valid_553648961 != nil:
    section.add "commentId", valid_553648961
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553648962 = header.getOrDefault("Accept")
  valid_553648962 = validateParameter(valid_553648962, JString,
                                      required = false, default = nil)
  if valid_553648962 != nil:
    section.add "Accept", valid_553648962
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553648964: Call_PatchGistsIdCommentsCommentId_553648957;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Edit a comment.
  ## 
  let valid = call_553648964.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553648964.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553648964.makeUrl(scheme.get, call_553648964.host, call_553648964.base,
                                   call_553648964.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553648964, uri, valid, content)

proc call*(call_553648965: Call_PatchGistsIdCommentsCommentId_553648957;
           id: int; body: JsonNode; commentId: int; Accept: string = ""): Recallable =
  ## patchGistsIdCommentsCommentId
  ## Edit a comment.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_553648966 = newJObject()
  var header_553648967 = newJObject()
  var body_553648968 = newJObject()
  add(path_553648966, "id", newJInt(id))
  add(header_553648967, "Accept", newJString(Accept))
  if body != nil:
    body_553648968 = body
  add(path_553648966, "commentId", newJInt(commentId))
  result = call_553648965.call(path_553648966, nil, header_553648967, nil, body_553648968)

var patchGistsIdCommentsCommentId* = Call_PatchGistsIdCommentsCommentId_553648957(
    name: "patchGistsIdCommentsCommentId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/gists/{id}/comments/{commentId}",
    validator: validate_PatchGistsIdCommentsCommentId_553648958, base: "/",
    makeUrl: url_PatchGistsIdCommentsCommentId_553648959,
    schemes: {Scheme.Https})
type
  Call_DeleteGistsIdCommentsCommentId_553648947 = ref object of OpenApiRestCall_553648476
proc url_DeleteGistsIdCommentsCommentId_553648949(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
                 (kind: VariableSegment, value: "id"),
                 (kind: ConstantSegment, value: "/comments/"),
                 (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteGistsIdCommentsCommentId_553648948(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Delete a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_553648950 = path.getOrDefault("id")
  valid_553648950 = validateParameter(valid_553648950, JInt, required = true,
                                      default = nil)
  if valid_553648950 != nil:
    section.add "id", valid_553648950
  var valid_553648951 = path.getOrDefault("commentId")
  valid_553648951 = validateParameter(valid_553648951, JInt, required = true,
                                      default = nil)
  if valid_553648951 != nil:
    section.add "commentId", valid_553648951
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553648952 = header.getOrDefault("Accept")
  valid_553648952 = validateParameter(valid_553648952, JString,
                                      required = false, default = nil)
  if valid_553648952 != nil:
    section.add "Accept", valid_553648952
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553648953: Call_DeleteGistsIdCommentsCommentId_553648947;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Delete a comment.
  ## 
  let valid = call_553648953.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553648953.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553648953.makeUrl(scheme.get, call_553648953.host, call_553648953.base,
                                   call_553648953.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553648953, uri, valid, content)

proc call*(call_553648954: Call_DeleteGistsIdCommentsCommentId_553648947;
           id: int; commentId: int; Accept: string = ""): Recallable =
  ## deleteGistsIdCommentsCommentId
  ## Delete a comment.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_553648955 = newJObject()
  var header_553648956 = newJObject()
  add(path_553648955, "id", newJInt(id))
  add(header_553648956, "Accept", newJString(Accept))
  add(path_553648955, "commentId", newJInt(commentId))
  result = call_553648954.call(path_553648955, nil, header_553648956, nil, nil)

var deleteGistsIdCommentsCommentId* = Call_DeleteGistsIdCommentsCommentId_553648947(
    name: "deleteGistsIdCommentsCommentId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/gists/{id}/comments/{commentId}",
    validator: validate_DeleteGistsIdCommentsCommentId_553648948, base: "/",
    makeUrl: url_DeleteGistsIdCommentsCommentId_553648949,
    schemes: {Scheme.Https})
type
  Call_PostGistsIdForks_553648969 = ref object of OpenApiRestCall_553648476
proc url_PostGistsIdForks_553648971(protocol: Scheme; host: string;
                                    base: string; route: string; path: JsonNode;
                                    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
                 (kind: VariableSegment, value: "id"),
                 (kind: ConstantSegment, value: "/forks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostGistsIdForks_553648970(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Fork a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_553648972 = path.getOrDefault("id")
  valid_553648972 = validateParameter(valid_553648972, JInt, required = true,
                                      default = nil)
  if valid_553648972 != nil:
    section.add "id", valid_553648972
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553648973 = header.getOrDefault("Accept")
  valid_553648973 = validateParameter(valid_553648973, JString,
                                      required = false, default = nil)
  if valid_553648973 != nil:
    section.add "Accept", valid_553648973
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553648974: Call_PostGistsIdForks_553648969;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Fork a gist.
  ## 
  let valid = call_553648974.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553648974.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553648974.makeUrl(scheme.get, call_553648974.host, call_553648974.base,
                                   call_553648974.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553648974, uri, valid, content)

proc call*(call_553648975: Call_PostGistsIdForks_553648969; id: int;
           Accept: string = ""): Recallable =
  ## postGistsIdForks
  ## Fork a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_553648976 = newJObject()
  var header_553648977 = newJObject()
  add(path_553648976, "id", newJInt(id))
  add(header_553648977, "Accept", newJString(Accept))
  result = call_553648975.call(path_553648976, nil, header_553648977, nil, nil)

var postGistsIdForks* = Call_PostGistsIdForks_553648969(
    name: "postGistsIdForks", meth: HttpMethod.HttpPost, host: "api.github.com",
    route: "/gists/{id}/forks", validator: validate_PostGistsIdForks_553648970,
    base: "/", makeUrl: url_PostGistsIdForks_553648971, schemes: {Scheme.Https})
type
  Call_PutGistsIdStar_553648987 = ref object of OpenApiRestCall_553648476
proc url_PutGistsIdStar_553648989(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
                 (kind: VariableSegment, value: "id"),
                 (kind: ConstantSegment, value: "/star")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutGistsIdStar_553648988(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Star a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_553648990 = path.getOrDefault("id")
  valid_553648990 = validateParameter(valid_553648990, JInt, required = true,
                                      default = nil)
  if valid_553648990 != nil:
    section.add "id", valid_553648990
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553648991 = header.getOrDefault("Accept")
  valid_553648991 = validateParameter(valid_553648991, JString,
                                      required = false, default = nil)
  if valid_553648991 != nil:
    section.add "Accept", valid_553648991
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553648992: Call_PutGistsIdStar_553648987; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Star a gist.
  ## 
  let valid = call_553648992.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553648992.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553648992.makeUrl(scheme.get, call_553648992.host, call_553648992.base,
                                   call_553648992.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553648992, uri, valid, content)

proc call*(call_553648993: Call_PutGistsIdStar_553648987; id: int;
           Accept: string = ""): Recallable =
  ## putGistsIdStar
  ## Star a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_553648994 = newJObject()
  var header_553648995 = newJObject()
  add(path_553648994, "id", newJInt(id))
  add(header_553648995, "Accept", newJString(Accept))
  result = call_553648993.call(path_553648994, nil, header_553648995, nil, nil)

var putGistsIdStar* = Call_PutGistsIdStar_553648987(name: "putGistsIdStar",
    meth: HttpMethod.HttpPut, host: "api.github.com", route: "/gists/{id}/star",
    validator: validate_PutGistsIdStar_553648988, base: "/",
    makeUrl: url_PutGistsIdStar_553648989, schemes: {Scheme.Https})
type
  Call_GetGistsIdStar_553648978 = ref object of OpenApiRestCall_553648476
proc url_GetGistsIdStar_553648980(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
                 (kind: VariableSegment, value: "id"),
                 (kind: ConstantSegment, value: "/star")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGistsIdStar_553648979(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Check if a gist is starred.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_553648981 = path.getOrDefault("id")
  valid_553648981 = validateParameter(valid_553648981, JInt, required = true,
                                      default = nil)
  if valid_553648981 != nil:
    section.add "id", valid_553648981
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553648982 = header.getOrDefault("Accept")
  valid_553648982 = validateParameter(valid_553648982, JString,
                                      required = false, default = nil)
  if valid_553648982 != nil:
    section.add "Accept", valid_553648982
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553648983: Call_GetGistsIdStar_553648978; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Check if a gist is starred.
  ## 
  let valid = call_553648983.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553648983.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553648983.makeUrl(scheme.get, call_553648983.host, call_553648983.base,
                                   call_553648983.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553648983, uri, valid, content)

proc call*(call_553648984: Call_GetGistsIdStar_553648978; id: int;
           Accept: string = ""): Recallable =
  ## getGistsIdStar
  ## Check if a gist is starred.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_553648985 = newJObject()
  var header_553648986 = newJObject()
  add(path_553648985, "id", newJInt(id))
  add(header_553648986, "Accept", newJString(Accept))
  result = call_553648984.call(path_553648985, nil, header_553648986, nil, nil)

var getGistsIdStar* = Call_GetGistsIdStar_553648978(name: "getGistsIdStar",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/gists/{id}/star",
    validator: validate_GetGistsIdStar_553648979, base: "/",
    makeUrl: url_GetGistsIdStar_553648980, schemes: {Scheme.Https})
type
  Call_DeleteGistsIdStar_553648996 = ref object of OpenApiRestCall_553648476
proc url_DeleteGistsIdStar_553648998(protocol: Scheme; host: string;
                                     base: string; route: string;
                                     path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gists/"),
                 (kind: VariableSegment, value: "id"),
                 (kind: ConstantSegment, value: "/star")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteGistsIdStar_553648997(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Unstar a gist.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of gist.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_553648999 = path.getOrDefault("id")
  valid_553648999 = validateParameter(valid_553648999, JInt, required = true,
                                      default = nil)
  if valid_553648999 != nil:
    section.add "id", valid_553648999
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649000 = header.getOrDefault("Accept")
  valid_553649000 = validateParameter(valid_553649000, JString,
                                      required = false, default = nil)
  if valid_553649000 != nil:
    section.add "Accept", valid_553649000
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649001: Call_DeleteGistsIdStar_553648996;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Unstar a gist.
  ## 
  let valid = call_553649001.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649001.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649001.makeUrl(scheme.get, call_553649001.host, call_553649001.base,
                                   call_553649001.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649001, uri, valid, content)

proc call*(call_553649002: Call_DeleteGistsIdStar_553648996; id: int;
           Accept: string = ""): Recallable =
  ## deleteGistsIdStar
  ## Unstar a gist.
  ##   id: int (required)
  ##     : Id of gist.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_553649003 = newJObject()
  var header_553649004 = newJObject()
  add(path_553649003, "id", newJInt(id))
  add(header_553649004, "Accept", newJString(Accept))
  result = call_553649002.call(path_553649003, nil, header_553649004, nil, nil)

var deleteGistsIdStar* = Call_DeleteGistsIdStar_553648996(
    name: "deleteGistsIdStar", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/gists/{id}/star",
    validator: validate_DeleteGistsIdStar_553648997, base: "/",
    makeUrl: url_DeleteGistsIdStar_553648998, schemes: {Scheme.Https})
type
  Call_GetGitignoreTemplates_553649005 = ref object of OpenApiRestCall_553648476
proc url_GetGitignoreTemplates_553649007(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGitignoreTemplates_553649006(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Listing available templates.
  ## List all templates available to pass as an option when creating a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649008 = header.getOrDefault("Accept")
  valid_553649008 = validateParameter(valid_553649008, JString,
                                      required = false, default = nil)
  if valid_553649008 != nil:
    section.add "Accept", valid_553649008
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649009: Call_GetGitignoreTemplates_553649005;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Listing available templates.
  ## List all templates available to pass as an option when creating a repository.
  ## 
  ## 
  let valid = call_553649009.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649009.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649009.makeUrl(scheme.get, call_553649009.host, call_553649009.base,
                                   call_553649009.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649009, uri, valid, content)

proc call*(call_553649010: Call_GetGitignoreTemplates_553649005;
           Accept: string = ""): Recallable =
  ## getGitignoreTemplates
  ## Listing available templates.
  ## List all templates available to pass as an option when creating a repository.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_553649011 = newJObject()
  add(header_553649011, "Accept", newJString(Accept))
  result = call_553649010.call(nil, nil, header_553649011, nil, nil)

var getGitignoreTemplates* = Call_GetGitignoreTemplates_553649005(
    name: "getGitignoreTemplates", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/gitignore/templates",
    validator: validate_GetGitignoreTemplates_553649006, base: "/",
    makeUrl: url_GetGitignoreTemplates_553649007, schemes: {Scheme.Https})
type
  Call_GetGitignoreTemplatesLanguage_553649012 = ref object of OpenApiRestCall_553648476
proc url_GetGitignoreTemplatesLanguage_553649014(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "language" in path, "`language` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/gitignore/templates/"),
                 (kind: VariableSegment, value: "language")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetGitignoreTemplatesLanguage_553649013(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get a single template.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   language: JString (required)
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `language` field"
  var valid_553649015 = path.getOrDefault("language")
  valid_553649015 = validateParameter(valid_553649015, JString, required = true,
                                      default = nil)
  if valid_553649015 != nil:
    section.add "language", valid_553649015
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649016 = header.getOrDefault("Accept")
  valid_553649016 = validateParameter(valid_553649016, JString,
                                      required = false, default = nil)
  if valid_553649016 != nil:
    section.add "Accept", valid_553649016
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649017: Call_GetGitignoreTemplatesLanguage_553649012;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get a single template.
  ## 
  let valid = call_553649017.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649017.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649017.makeUrl(scheme.get, call_553649017.host, call_553649017.base,
                                   call_553649017.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649017, uri, valid, content)

proc call*(call_553649018: Call_GetGitignoreTemplatesLanguage_553649012;
           language: string; Accept: string = ""): Recallable =
  ## getGitignoreTemplatesLanguage
  ## Get a single template.
  ##   language: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_553649019 = newJObject()
  var header_553649020 = newJObject()
  add(path_553649019, "language", newJString(language))
  add(header_553649020, "Accept", newJString(Accept))
  result = call_553649018.call(path_553649019, nil, header_553649020, nil, nil)

var getGitignoreTemplatesLanguage* = Call_GetGitignoreTemplatesLanguage_553649012(
    name: "getGitignoreTemplatesLanguage", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/gitignore/templates/{language}",
    validator: validate_GetGitignoreTemplatesLanguage_553649013, base: "/",
    makeUrl: url_GetGitignoreTemplatesLanguage_553649014,
    schemes: {Scheme.Https})
type
  Call_GetIssues_553649021 = ref object of OpenApiRestCall_553648476
proc url_GetIssues_553649023(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetIssues_553649022(path: JsonNode; query: JsonNode;
                                  header: JsonNode; formData: JsonNode;
                                  body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List issues.
  ## List all issues across all the authenticated user's visible repositories.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString (required)
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: JString (required)
  ##   direction: JString (required)
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_553649036 = query.getOrDefault("state")
  valid_553649036 = validateParameter(valid_553649036, JString, required = true,
                                      default = newJString("open"))
  if valid_553649036 != nil:
    section.add "state", valid_553649036
  var valid_553649037 = query.getOrDefault("labels")
  valid_553649037 = validateParameter(valid_553649037, JString, required = true,
                                      default = nil)
  if valid_553649037 != nil:
    section.add "labels", valid_553649037
  var valid_553649038 = query.getOrDefault("sort")
  valid_553649038 = validateParameter(valid_553649038, JString, required = true,
                                      default = newJString("created"))
  if valid_553649038 != nil:
    section.add "sort", valid_553649038
  var valid_553649039 = query.getOrDefault("direction")
  valid_553649039 = validateParameter(valid_553649039, JString, required = true,
                                      default = newJString("desc"))
  if valid_553649039 != nil:
    section.add "direction", valid_553649039
  var valid_553649040 = query.getOrDefault("filter")
  valid_553649040 = validateParameter(valid_553649040, JString, required = true,
                                      default = newJString("all"))
  if valid_553649040 != nil:
    section.add "filter", valid_553649040
  var valid_553649041 = query.getOrDefault("since")
  valid_553649041 = validateParameter(valid_553649041, JString,
                                      required = false, default = nil)
  if valid_553649041 != nil:
    section.add "since", valid_553649041
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649042 = header.getOrDefault("Accept")
  valid_553649042 = validateParameter(valid_553649042, JString,
                                      required = false, default = nil)
  if valid_553649042 != nil:
    section.add "Accept", valid_553649042
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649043: Call_GetIssues_553649021; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List issues.
  ## List all issues across all the authenticated user's visible repositories.
  ## 
  ## 
  let valid = call_553649043.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649043.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649043.makeUrl(scheme.get, call_553649043.host, call_553649043.base,
                                   call_553649043.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649043, uri, valid, content)

proc call*(call_553649044: Call_GetIssues_553649021; labels: string;
           state: string = "open"; Accept: string = "";
           sort: string = "created"; direction: string = "desc";
           filter: string = "all"; since: string = ""): Recallable =
  ## getIssues
  ## List issues.
  ## List all issues across all the authenticated user's visible repositories.
  ## 
  ##   state: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: string (required)
  ##   direction: string (required)
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  var query_553649045 = newJObject()
  var header_553649046 = newJObject()
  add(query_553649045, "state", newJString(state))
  add(header_553649046, "Accept", newJString(Accept))
  add(query_553649045, "labels", newJString(labels))
  add(query_553649045, "sort", newJString(sort))
  add(query_553649045, "direction", newJString(direction))
  add(query_553649045, "filter", newJString(filter))
  add(query_553649045, "since", newJString(since))
  result = call_553649044.call(nil, query_553649045, header_553649046, nil, nil)

var getIssues* = Call_GetIssues_553649021(name: "getIssues",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/issues",
    validator: validate_GetIssues_553649022, base: "/", makeUrl: url_GetIssues_553649023,
    schemes: {Scheme.Https})
type
  Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_553649047 = ref object of OpenApiRestCall_553648476
proc url_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_553649049(
    protocol: Scheme; host: string; base: string; route: string; path: JsonNode;
    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repository" in path, "`repository` is a required path parameter"
  assert "state" in path, "`state` is a required path parameter"
  assert "keyword" in path, "`keyword` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/issues/search/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repository"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "state"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "keyword")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_553649048(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode; content: string = ""): JsonNode {.nosinks.} =
  ## Find issues by state and keyword.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##   repository: JString (required)
  ##   keyword: JString (required)
  ##          : The search term.
  ##   state: JString (required)
  ##        : Indicates the state of the issues to return. Can be either open or closed.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649050 = path.getOrDefault("owner")
  valid_553649050 = validateParameter(valid_553649050, JString, required = true,
                                      default = nil)
  if valid_553649050 != nil:
    section.add "owner", valid_553649050
  var valid_553649051 = path.getOrDefault("repository")
  valid_553649051 = validateParameter(valid_553649051, JString, required = true,
                                      default = nil)
  if valid_553649051 != nil:
    section.add "repository", valid_553649051
  var valid_553649052 = path.getOrDefault("keyword")
  valid_553649052 = validateParameter(valid_553649052, JString, required = true,
                                      default = nil)
  if valid_553649052 != nil:
    section.add "keyword", valid_553649052
  var valid_553649053 = path.getOrDefault("state")
  valid_553649053 = validateParameter(valid_553649053, JString, required = true,
                                      default = newJString("open"))
  if valid_553649053 != nil:
    section.add "state", valid_553649053
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649054 = header.getOrDefault("Accept")
  valid_553649054 = validateParameter(valid_553649054, JString,
                                      required = false, default = nil)
  if valid_553649054 != nil:
    section.add "Accept", valid_553649054
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649055: Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_553649047;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Find issues by state and keyword.
  ## 
  let valid = call_553649055.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649055.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649055.makeUrl(scheme.get, call_553649055.host, call_553649055.base,
                                   call_553649055.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649055, uri, valid, content)

proc call*(call_553649056: Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_553649047;
           owner: string; repository: string; keyword: string;
           Accept: string = ""; state: string = "open"): Recallable =
  ## getLegacyIssuesSearchOwnerRepositoryStateKeyword
  ## Find issues by state and keyword.
  ##   owner: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repository: string (required)
  ##   keyword: string (required)
  ##          : The search term.
  ##   state: string (required)
  ##        : Indicates the state of the issues to return. Can be either open or closed.
  var path_553649057 = newJObject()
  var header_553649058 = newJObject()
  add(path_553649057, "owner", newJString(owner))
  add(header_553649058, "Accept", newJString(Accept))
  add(path_553649057, "repository", newJString(repository))
  add(path_553649057, "keyword", newJString(keyword))
  add(path_553649057, "state", newJString(state))
  result = call_553649056.call(path_553649057, nil, header_553649058, nil, nil)

var getLegacyIssuesSearchOwnerRepositoryStateKeyword* = Call_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_553649047(
    name: "getLegacyIssuesSearchOwnerRepositoryStateKeyword",
    meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/legacy/issues/search/{owner}/{repository}/{state}/{keyword}",
    validator: validate_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_553649048,
    base: "/", makeUrl: url_GetLegacyIssuesSearchOwnerRepositoryStateKeyword_553649049,
    schemes: {Scheme.Https})
type
  Call_GetLegacyReposSearchKeyword_553649059 = ref object of OpenApiRestCall_553648476
proc url_GetLegacyReposSearchKeyword_553649061(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyword" in path, "`keyword` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/repos/search/"),
                 (kind: VariableSegment, value: "keyword")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyReposSearchKeyword_553649060(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Find repositories by keyword. Note, this legacy method does not follow the v3 pagination pattern. This method returns up to 100 results per page and pages can be fetched using the start_page parameter.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyword: JString (required)
  ##          : The search term
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `keyword` field"
  var valid_553649062 = path.getOrDefault("keyword")
  valid_553649062 = validateParameter(valid_553649062, JString, required = true,
                                      default = nil)
  if valid_553649062 != nil:
    section.add "keyword", valid_553649062
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   language: JString
  ##           : Filter results by language
  ##   start_page: JString
  ##             : The page number to fetch
  ##   sort: JString
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  section = newJObject()
  var valid_553649063 = query.getOrDefault("order")
  valid_553649063 = validateParameter(valid_553649063, JString,
                                      required = false,
                                      default = newJString("desc"))
  if valid_553649063 != nil:
    section.add "order", valid_553649063
  var valid_553649064 = query.getOrDefault("language")
  valid_553649064 = validateParameter(valid_553649064, JString,
                                      required = false, default = nil)
  if valid_553649064 != nil:
    section.add "language", valid_553649064
  var valid_553649065 = query.getOrDefault("start_page")
  valid_553649065 = validateParameter(valid_553649065, JString,
                                      required = false, default = nil)
  if valid_553649065 != nil:
    section.add "start_page", valid_553649065
  var valid_553649066 = query.getOrDefault("sort")
  valid_553649066 = validateParameter(valid_553649066, JString,
                                      required = false,
                                      default = newJString("updated"))
  if valid_553649066 != nil:
    section.add "sort", valid_553649066
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649067 = header.getOrDefault("Accept")
  valid_553649067 = validateParameter(valid_553649067, JString,
                                      required = false, default = nil)
  if valid_553649067 != nil:
    section.add "Accept", valid_553649067
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649068: Call_GetLegacyReposSearchKeyword_553649059;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Find repositories by keyword. Note, this legacy method does not follow the v3 pagination pattern. This method returns up to 100 results per page and pages can be fetched using the start_page parameter.
  ## 
  let valid = call_553649068.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649068.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649068.makeUrl(scheme.get, call_553649068.host, call_553649068.base,
                                   call_553649068.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649068, uri, valid, content)

proc call*(call_553649069: Call_GetLegacyReposSearchKeyword_553649059;
           keyword: string; order: string = "desc"; language: string = "";
           Accept: string = ""; startPage: string = ""; sort: string = "updated"): Recallable =
  ## getLegacyReposSearchKeyword
  ## Find repositories by keyword. Note, this legacy method does not follow the v3 pagination pattern. This method returns up to 100 results per page and pages can be fetched using the start_page parameter.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   language: string
  ##           : Filter results by language
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   startPage: string
  ##            : The page number to fetch
  ##   sort: string
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  ##   keyword: string (required)
  ##          : The search term
  var path_553649070 = newJObject()
  var query_553649071 = newJObject()
  var header_553649072 = newJObject()
  add(query_553649071, "order", newJString(order))
  add(query_553649071, "language", newJString(language))
  add(header_553649072, "Accept", newJString(Accept))
  add(query_553649071, "start_page", newJString(startPage))
  add(query_553649071, "sort", newJString(sort))
  add(path_553649070, "keyword", newJString(keyword))
  result = call_553649069.call(path_553649070, query_553649071, header_553649072,
                               nil, nil)

var getLegacyReposSearchKeyword* = Call_GetLegacyReposSearchKeyword_553649059(
    name: "getLegacyReposSearchKeyword", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/legacy/repos/search/{keyword}",
    validator: validate_GetLegacyReposSearchKeyword_553649060, base: "/",
    makeUrl: url_GetLegacyReposSearchKeyword_553649061, schemes: {Scheme.Https})
type
  Call_GetLegacyUserEmailEmail_553649073 = ref object of OpenApiRestCall_553648476
proc url_GetLegacyUserEmailEmail_553649075(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "email" in path, "`email` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/user/email/"),
                 (kind: VariableSegment, value: "email")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyUserEmailEmail_553649074(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## This API call is added for compatibility reasons only.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   email: JString (required)
  ##        : The email address
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `email` field"
  var valid_553649076 = path.getOrDefault("email")
  valid_553649076 = validateParameter(valid_553649076, JString, required = true,
                                      default = nil)
  if valid_553649076 != nil:
    section.add "email", valid_553649076
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649077 = header.getOrDefault("Accept")
  valid_553649077 = validateParameter(valid_553649077, JString,
                                      required = false, default = nil)
  if valid_553649077 != nil:
    section.add "Accept", valid_553649077
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649078: Call_GetLegacyUserEmailEmail_553649073;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## This API call is added for compatibility reasons only.
  ## 
  let valid = call_553649078.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649078.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649078.makeUrl(scheme.get, call_553649078.host, call_553649078.base,
                                   call_553649078.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649078, uri, valid, content)

proc call*(call_553649079: Call_GetLegacyUserEmailEmail_553649073;
           email: string; Accept: string = ""): Recallable =
  ## getLegacyUserEmailEmail
  ## This API call is added for compatibility reasons only.
  ##   email: string (required)
  ##        : The email address
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_553649080 = newJObject()
  var header_553649081 = newJObject()
  add(path_553649080, "email", newJString(email))
  add(header_553649081, "Accept", newJString(Accept))
  result = call_553649079.call(path_553649080, nil, header_553649081, nil, nil)

var getLegacyUserEmailEmail* = Call_GetLegacyUserEmailEmail_553649073(
    name: "getLegacyUserEmailEmail", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/legacy/user/email/{email}",
    validator: validate_GetLegacyUserEmailEmail_553649074, base: "/",
    makeUrl: url_GetLegacyUserEmailEmail_553649075, schemes: {Scheme.Https})
type
  Call_GetLegacyUserSearchKeyword_553649082 = ref object of OpenApiRestCall_553648476
proc url_GetLegacyUserSearchKeyword_553649084(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyword" in path, "`keyword` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/legacy/user/search/"),
                 (kind: VariableSegment, value: "keyword")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetLegacyUserSearchKeyword_553649083(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Find users by keyword.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyword: JString (required)
  ##          : The search term
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `keyword` field"
  var valid_553649085 = path.getOrDefault("keyword")
  valid_553649085 = validateParameter(valid_553649085, JString, required = true,
                                      default = nil)
  if valid_553649085 != nil:
    section.add "keyword", valid_553649085
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   start_page: JString
  ##             : The page number to fetch
  ##   sort: JString
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  section = newJObject()
  var valid_553649086 = query.getOrDefault("order")
  valid_553649086 = validateParameter(valid_553649086, JString,
                                      required = false,
                                      default = newJString("desc"))
  if valid_553649086 != nil:
    section.add "order", valid_553649086
  var valid_553649087 = query.getOrDefault("start_page")
  valid_553649087 = validateParameter(valid_553649087, JString,
                                      required = false, default = nil)
  if valid_553649087 != nil:
    section.add "start_page", valid_553649087
  var valid_553649088 = query.getOrDefault("sort")
  valid_553649088 = validateParameter(valid_553649088, JString,
                                      required = false,
                                      default = newJString("updated"))
  if valid_553649088 != nil:
    section.add "sort", valid_553649088
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649089 = header.getOrDefault("Accept")
  valid_553649089 = validateParameter(valid_553649089, JString,
                                      required = false, default = nil)
  if valid_553649089 != nil:
    section.add "Accept", valid_553649089
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649090: Call_GetLegacyUserSearchKeyword_553649082;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Find users by keyword.
  ## 
  let valid = call_553649090.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649090.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649090.makeUrl(scheme.get, call_553649090.host, call_553649090.base,
                                   call_553649090.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649090, uri, valid, content)

proc call*(call_553649091: Call_GetLegacyUserSearchKeyword_553649082;
           keyword: string; order: string = "desc"; Accept: string = "";
           startPage: string = ""; sort: string = "updated"): Recallable =
  ## getLegacyUserSearchKeyword
  ## Find users by keyword.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   startPage: string
  ##            : The page number to fetch
  ##   sort: string
  ##       : The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
  ##   keyword: string (required)
  ##          : The search term
  var path_553649092 = newJObject()
  var query_553649093 = newJObject()
  var header_553649094 = newJObject()
  add(query_553649093, "order", newJString(order))
  add(header_553649094, "Accept", newJString(Accept))
  add(query_553649093, "start_page", newJString(startPage))
  add(query_553649093, "sort", newJString(sort))
  add(path_553649092, "keyword", newJString(keyword))
  result = call_553649091.call(path_553649092, query_553649093, header_553649094,
                               nil, nil)

var getLegacyUserSearchKeyword* = Call_GetLegacyUserSearchKeyword_553649082(
    name: "getLegacyUserSearchKeyword", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/legacy/user/search/{keyword}",
    validator: validate_GetLegacyUserSearchKeyword_553649083, base: "/",
    makeUrl: url_GetLegacyUserSearchKeyword_553649084, schemes: {Scheme.Https})
type
  Call_PostMarkdown_553649095 = ref object of OpenApiRestCall_553648476
proc url_PostMarkdown_553649097(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostMarkdown_553649096(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Render an arbitrary Markdown document
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649098 = header.getOrDefault("Accept")
  valid_553649098 = validateParameter(valid_553649098, JString,
                                      required = false, default = nil)
  if valid_553649098 != nil:
    section.add "Accept", valid_553649098
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553649100: Call_PostMarkdown_553649095; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Render an arbitrary Markdown document
  ## 
  let valid = call_553649100.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649100.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649100.makeUrl(scheme.get, call_553649100.host, call_553649100.base,
                                   call_553649100.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649100, uri, valid, content)

proc call*(call_553649101: Call_PostMarkdown_553649095; body: JsonNode;
           Accept: string = ""): Recallable =
  ## postMarkdown
  ## Render an arbitrary Markdown document
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_553649102 = newJObject()
  var body_553649103 = newJObject()
  add(header_553649102, "Accept", newJString(Accept))
  if body != nil:
    body_553649103 = body
  result = call_553649101.call(nil, nil, header_553649102, nil, body_553649103)

var postMarkdown* = Call_PostMarkdown_553649095(name: "postMarkdown",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/markdown",
    validator: validate_PostMarkdown_553649096, base: "/",
    makeUrl: url_PostMarkdown_553649097, schemes: {Scheme.Https})
type
  Call_PostMarkdownRaw_553649104 = ref object of OpenApiRestCall_553648476
proc url_PostMarkdownRaw_553649106(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode;
                                   query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostMarkdownRaw_553649105(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Render a Markdown document in raw mode
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649107 = header.getOrDefault("Accept")
  valid_553649107 = validateParameter(valid_553649107, JString,
                                      required = false, default = nil)
  if valid_553649107 != nil:
    section.add "Accept", valid_553649107
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649108: Call_PostMarkdownRaw_553649104; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Render a Markdown document in raw mode
  ## 
  let valid = call_553649108.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649108.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649108.makeUrl(scheme.get, call_553649108.host, call_553649108.base,
                                   call_553649108.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649108, uri, valid, content)

proc call*(call_553649109: Call_PostMarkdownRaw_553649104; Accept: string = ""): Recallable =
  ## postMarkdownRaw
  ## Render a Markdown document in raw mode
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_553649110 = newJObject()
  add(header_553649110, "Accept", newJString(Accept))
  result = call_553649109.call(nil, nil, header_553649110, nil, nil)

var postMarkdownRaw* = Call_PostMarkdownRaw_553649104(name: "postMarkdownRaw",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/markdown/raw",
    validator: validate_PostMarkdownRaw_553649105, base: "/",
    makeUrl: url_PostMarkdownRaw_553649106, schemes: {Scheme.Https})
type
  Call_GetMeta_553649111 = ref object of OpenApiRestCall_553648476
proc url_GetMeta_553649113(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetMeta_553649112(path: JsonNode; query: JsonNode;
                                header: JsonNode; formData: JsonNode;
                                body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## This gives some information about GitHub.com, the service.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649114 = header.getOrDefault("Accept")
  valid_553649114 = validateParameter(valid_553649114, JString,
                                      required = false, default = nil)
  if valid_553649114 != nil:
    section.add "Accept", valid_553649114
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649115: Call_GetMeta_553649111; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## This gives some information about GitHub.com, the service.
  ## 
  let valid = call_553649115.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649115.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649115.makeUrl(scheme.get, call_553649115.host, call_553649115.base,
                                   call_553649115.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649115, uri, valid, content)

proc call*(call_553649116: Call_GetMeta_553649111; Accept: string = ""): Recallable =
  ## getMeta
  ## This gives some information about GitHub.com, the service.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_553649117 = newJObject()
  add(header_553649117, "Accept", newJString(Accept))
  result = call_553649116.call(nil, nil, header_553649117, nil, nil)

var getMeta* = Call_GetMeta_553649111(name: "getMeta", meth: HttpMethod.HttpGet,
                                      host: "api.github.com", route: "/meta",
                                      validator: validate_GetMeta_553649112,
                                      base: "/", makeUrl: url_GetMeta_553649113,
                                      schemes: {Scheme.Https})
type
  Call_GetNetworksOwnerRepoEvents_553649118 = ref object of OpenApiRestCall_553648476
proc url_GetNetworksOwnerRepoEvents_553649120(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/networks/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetNetworksOwnerRepoEvents_553649119(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## List public events for a network of repositories.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of the owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649121 = path.getOrDefault("owner")
  valid_553649121 = validateParameter(valid_553649121, JString, required = true,
                                      default = nil)
  if valid_553649121 != nil:
    section.add "owner", valid_553649121
  var valid_553649122 = path.getOrDefault("repo")
  valid_553649122 = validateParameter(valid_553649122, JString, required = true,
                                      default = nil)
  if valid_553649122 != nil:
    section.add "repo", valid_553649122
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649123 = header.getOrDefault("Accept")
  valid_553649123 = validateParameter(valid_553649123, JString,
                                      required = false, default = nil)
  if valid_553649123 != nil:
    section.add "Accept", valid_553649123
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649124: Call_GetNetworksOwnerRepoEvents_553649118;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List public events for a network of repositories.
  ## 
  let valid = call_553649124.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649124.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649124.makeUrl(scheme.get, call_553649124.host, call_553649124.base,
                                   call_553649124.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649124, uri, valid, content)

proc call*(call_553649125: Call_GetNetworksOwnerRepoEvents_553649118;
           owner: string; repo: string; Accept: string = ""): Recallable =
  ## getNetworksOwnerRepoEvents
  ## List public events for a network of repositories.
  ##   owner: string (required)
  ##        : Name of the owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649126 = newJObject()
  var header_553649127 = newJObject()
  add(path_553649126, "owner", newJString(owner))
  add(header_553649127, "Accept", newJString(Accept))
  add(path_553649126, "repo", newJString(repo))
  result = call_553649125.call(path_553649126, nil, header_553649127, nil, nil)

var getNetworksOwnerRepoEvents* = Call_GetNetworksOwnerRepoEvents_553649118(
    name: "getNetworksOwnerRepoEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/networks/{owner}/{repo}/events",
    validator: validate_GetNetworksOwnerRepoEvents_553649119, base: "/",
    makeUrl: url_GetNetworksOwnerRepoEvents_553649120, schemes: {Scheme.Https})
type
  Call_PutNotifications_553649139 = ref object of OpenApiRestCall_553648476
proc url_PutNotifications_553649141(protocol: Scheme; host: string;
                                    base: string; route: string; path: JsonNode;
                                    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PutNotifications_553649140(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Mark as read.
  ## Marking a notification as "read" removes it from the default view on GitHub.com.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649142 = header.getOrDefault("Accept")
  valid_553649142 = validateParameter(valid_553649142, JString,
                                      required = false, default = nil)
  if valid_553649142 != nil:
    section.add "Accept", valid_553649142
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553649144: Call_PutNotifications_553649139;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Mark as read.
  ## Marking a notification as "read" removes it from the default view on GitHub.com.
  ## 
  ## 
  let valid = call_553649144.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649144.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649144.makeUrl(scheme.get, call_553649144.host, call_553649144.base,
                                   call_553649144.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649144, uri, valid, content)

proc call*(call_553649145: Call_PutNotifications_553649139; body: JsonNode;
           Accept: string = ""): Recallable =
  ## putNotifications
  ## Mark as read.
  ## Marking a notification as "read" removes it from the default view on GitHub.com.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_553649146 = newJObject()
  var body_553649147 = newJObject()
  add(header_553649146, "Accept", newJString(Accept))
  if body != nil:
    body_553649147 = body
  result = call_553649145.call(nil, nil, header_553649146, nil, body_553649147)

var putNotifications* = Call_PutNotifications_553649139(
    name: "putNotifications", meth: HttpMethod.HttpPut, host: "api.github.com",
    route: "/notifications", validator: validate_PutNotifications_553649140,
    base: "/", makeUrl: url_PutNotifications_553649141, schemes: {Scheme.Https})
type
  Call_GetNotifications_553649128 = ref object of OpenApiRestCall_553648476
proc url_GetNotifications_553649130(protocol: Scheme; host: string;
                                    base: string; route: string; path: JsonNode;
                                    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetNotifications_553649129(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List your notifications.
  ## List all notifications for the current user, grouped by repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   participating: JBool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  ##   all: JBool
  ##      : True to show notifications marked as read.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_553649131 = query.getOrDefault("participating")
  valid_553649131 = validateParameter(valid_553649131, JBool, required = false,
                                      default = nil)
  if valid_553649131 != nil:
    section.add "participating", valid_553649131
  var valid_553649132 = query.getOrDefault("all")
  valid_553649132 = validateParameter(valid_553649132, JBool, required = false,
                                      default = nil)
  if valid_553649132 != nil:
    section.add "all", valid_553649132
  var valid_553649133 = query.getOrDefault("since")
  valid_553649133 = validateParameter(valid_553649133, JString,
                                      required = false, default = nil)
  if valid_553649133 != nil:
    section.add "since", valid_553649133
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649134 = header.getOrDefault("Accept")
  valid_553649134 = validateParameter(valid_553649134, JString,
                                      required = false, default = nil)
  if valid_553649134 != nil:
    section.add "Accept", valid_553649134
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649135: Call_GetNotifications_553649128;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List your notifications.
  ## List all notifications for the current user, grouped by repository.
  ## 
  ## 
  let valid = call_553649135.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649135.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649135.makeUrl(scheme.get, call_553649135.host, call_553649135.base,
                                   call_553649135.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649135, uri, valid, content)

proc call*(call_553649136: Call_GetNotifications_553649128;
           participating: bool = false; all: bool = false; Accept: string = "";
           since: string = ""): Recallable =
  ## getNotifications
  ## List your notifications.
  ## List all notifications for the current user, grouped by repository.
  ## 
  ##   participating: bool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  ##   all: bool
  ##      : True to show notifications marked as read.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var query_553649137 = newJObject()
  var header_553649138 = newJObject()
  add(query_553649137, "participating", newJBool(participating))
  add(query_553649137, "all", newJBool(all))
  add(header_553649138, "Accept", newJString(Accept))
  add(query_553649137, "since", newJString(since))
  result = call_553649136.call(nil, query_553649137, header_553649138, nil, nil)

var getNotifications* = Call_GetNotifications_553649128(
    name: "getNotifications", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/notifications", validator: validate_GetNotifications_553649129,
    base: "/", makeUrl: url_GetNotifications_553649130, schemes: {Scheme.Https})
type
  Call_GetNotificationsThreadsId_553649148 = ref object of OpenApiRestCall_553648476
proc url_GetNotificationsThreadsId_553649150(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
                 (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetNotificationsThreadsId_553649149(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## View a single thread.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_553649151 = path.getOrDefault("id")
  valid_553649151 = validateParameter(valid_553649151, JInt, required = true,
                                      default = nil)
  if valid_553649151 != nil:
    section.add "id", valid_553649151
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649152 = header.getOrDefault("Accept")
  valid_553649152 = validateParameter(valid_553649152, JString,
                                      required = false, default = nil)
  if valid_553649152 != nil:
    section.add "Accept", valid_553649152
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649153: Call_GetNotificationsThreadsId_553649148;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## View a single thread.
  ## 
  let valid = call_553649153.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649153.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649153.makeUrl(scheme.get, call_553649153.host, call_553649153.base,
                                   call_553649153.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649153, uri, valid, content)

proc call*(call_553649154: Call_GetNotificationsThreadsId_553649148; id: int;
           Accept: string = ""): Recallable =
  ## getNotificationsThreadsId
  ## View a single thread.
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_553649155 = newJObject()
  var header_553649156 = newJObject()
  add(path_553649155, "id", newJInt(id))
  add(header_553649156, "Accept", newJString(Accept))
  result = call_553649154.call(path_553649155, nil, header_553649156, nil, nil)

var getNotificationsThreadsId* = Call_GetNotificationsThreadsId_553649148(
    name: "getNotificationsThreadsId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/notifications/threads/{id}",
    validator: validate_GetNotificationsThreadsId_553649149, base: "/",
    makeUrl: url_GetNotificationsThreadsId_553649150, schemes: {Scheme.Https})
type
  Call_PatchNotificationsThreadsId_553649157 = ref object of OpenApiRestCall_553648476
proc url_PatchNotificationsThreadsId_553649159(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
                 (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchNotificationsThreadsId_553649158(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Mark a thread as read
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_553649160 = path.getOrDefault("id")
  valid_553649160 = validateParameter(valid_553649160, JInt, required = true,
                                      default = nil)
  if valid_553649160 != nil:
    section.add "id", valid_553649160
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649161 = header.getOrDefault("Accept")
  valid_553649161 = validateParameter(valid_553649161, JString,
                                      required = false, default = nil)
  if valid_553649161 != nil:
    section.add "Accept", valid_553649161
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649162: Call_PatchNotificationsThreadsId_553649157;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Mark a thread as read
  ## 
  let valid = call_553649162.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649162.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649162.makeUrl(scheme.get, call_553649162.host, call_553649162.base,
                                   call_553649162.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649162, uri, valid, content)

proc call*(call_553649163: Call_PatchNotificationsThreadsId_553649157; id: int;
           Accept: string = ""): Recallable =
  ## patchNotificationsThreadsId
  ## Mark a thread as read
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_553649164 = newJObject()
  var header_553649165 = newJObject()
  add(path_553649164, "id", newJInt(id))
  add(header_553649165, "Accept", newJString(Accept))
  result = call_553649163.call(path_553649164, nil, header_553649165, nil, nil)

var patchNotificationsThreadsId* = Call_PatchNotificationsThreadsId_553649157(
    name: "patchNotificationsThreadsId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/notifications/threads/{id}",
    validator: validate_PatchNotificationsThreadsId_553649158, base: "/",
    makeUrl: url_PatchNotificationsThreadsId_553649159, schemes: {Scheme.Https})
type
  Call_PutNotificationsThreadsIdSubscription_553649175 = ref object of OpenApiRestCall_553648476
proc url_PutNotificationsThreadsIdSubscription_553649177(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
                 (kind: VariableSegment, value: "id"),
                 (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutNotificationsThreadsIdSubscription_553649176(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Set a Thread Subscription.
  ## This lets you subscribe to a thread, or ignore it. Subscribing to a thread
  ## is unnecessary if the user is already subscribed to the repository. Ignoring
  ## a thread will mute all future notifications (until you comment or get @mentioned).
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_553649178 = path.getOrDefault("id")
  valid_553649178 = validateParameter(valid_553649178, JInt, required = true,
                                      default = nil)
  if valid_553649178 != nil:
    section.add "id", valid_553649178
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649179 = header.getOrDefault("Accept")
  valid_553649179 = validateParameter(valid_553649179, JString,
                                      required = false, default = nil)
  if valid_553649179 != nil:
    section.add "Accept", valid_553649179
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553649181: Call_PutNotificationsThreadsIdSubscription_553649175;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Set a Thread Subscription.
  ## This lets you subscribe to a thread, or ignore it. Subscribing to a thread
  ## is unnecessary if the user is already subscribed to the repository. Ignoring
  ## a thread will mute all future notifications (until you comment or get @mentioned).
  ## 
  ## 
  let valid = call_553649181.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649181.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649181.makeUrl(scheme.get, call_553649181.host, call_553649181.base,
                                   call_553649181.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649181, uri, valid, content)

proc call*(call_553649182: Call_PutNotificationsThreadsIdSubscription_553649175;
           id: int; body: JsonNode; Accept: string = ""): Recallable =
  ## putNotificationsThreadsIdSubscription
  ## Set a Thread Subscription.
  ## This lets you subscribe to a thread, or ignore it. Subscribing to a thread
  ## is unnecessary if the user is already subscribed to the repository. Ignoring
  ## a thread will mute all future notifications (until you comment or get @mentioned).
  ## 
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var path_553649183 = newJObject()
  var header_553649184 = newJObject()
  var body_553649185 = newJObject()
  add(path_553649183, "id", newJInt(id))
  add(header_553649184, "Accept", newJString(Accept))
  if body != nil:
    body_553649185 = body
  result = call_553649182.call(path_553649183, nil, header_553649184, nil, body_553649185)

var putNotificationsThreadsIdSubscription* = Call_PutNotificationsThreadsIdSubscription_553649175(
    name: "putNotificationsThreadsIdSubscription", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/notifications/threads/{id}/subscription",
    validator: validate_PutNotificationsThreadsIdSubscription_553649176,
    base: "/", makeUrl: url_PutNotificationsThreadsIdSubscription_553649177,
    schemes: {Scheme.Https})
type
  Call_GetNotificationsThreadsIdSubscription_553649166 = ref object of OpenApiRestCall_553648476
proc url_GetNotificationsThreadsIdSubscription_553649168(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
                 (kind: VariableSegment, value: "id"),
                 (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetNotificationsThreadsIdSubscription_553649167(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get a Thread Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_553649169 = path.getOrDefault("id")
  valid_553649169 = validateParameter(valid_553649169, JInt, required = true,
                                      default = nil)
  if valid_553649169 != nil:
    section.add "id", valid_553649169
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649170 = header.getOrDefault("Accept")
  valid_553649170 = validateParameter(valid_553649170, JString,
                                      required = false, default = nil)
  if valid_553649170 != nil:
    section.add "Accept", valid_553649170
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649171: Call_GetNotificationsThreadsIdSubscription_553649166;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get a Thread Subscription.
  ## 
  let valid = call_553649171.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649171.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649171.makeUrl(scheme.get, call_553649171.host, call_553649171.base,
                                   call_553649171.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649171, uri, valid, content)

proc call*(call_553649172: Call_GetNotificationsThreadsIdSubscription_553649166;
           id: int; Accept: string = ""): Recallable =
  ## getNotificationsThreadsIdSubscription
  ## Get a Thread Subscription.
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_553649173 = newJObject()
  var header_553649174 = newJObject()
  add(path_553649173, "id", newJInt(id))
  add(header_553649174, "Accept", newJString(Accept))
  result = call_553649172.call(path_553649173, nil, header_553649174, nil, nil)

var getNotificationsThreadsIdSubscription* = Call_GetNotificationsThreadsIdSubscription_553649166(
    name: "getNotificationsThreadsIdSubscription", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/notifications/threads/{id}/subscription",
    validator: validate_GetNotificationsThreadsIdSubscription_553649167,
    base: "/", makeUrl: url_GetNotificationsThreadsIdSubscription_553649168,
    schemes: {Scheme.Https})
type
  Call_DeleteNotificationsThreadsIdSubscription_553649186 = ref object of OpenApiRestCall_553648476
proc url_DeleteNotificationsThreadsIdSubscription_553649188(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/notifications/threads/"),
                 (kind: VariableSegment, value: "id"),
                 (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteNotificationsThreadsIdSubscription_553649187(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Delete a Thread Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   id: JInt (required)
  ##     : Id of thread.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `id` field"
  var valid_553649189 = path.getOrDefault("id")
  valid_553649189 = validateParameter(valid_553649189, JInt, required = true,
                                      default = nil)
  if valid_553649189 != nil:
    section.add "id", valid_553649189
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649190 = header.getOrDefault("Accept")
  valid_553649190 = validateParameter(valid_553649190, JString,
                                      required = false, default = nil)
  if valid_553649190 != nil:
    section.add "Accept", valid_553649190
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649191: Call_DeleteNotificationsThreadsIdSubscription_553649186;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Delete a Thread Subscription.
  ## 
  let valid = call_553649191.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649191.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649191.makeUrl(scheme.get, call_553649191.host, call_553649191.base,
                                   call_553649191.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649191, uri, valid, content)

proc call*(call_553649192: Call_DeleteNotificationsThreadsIdSubscription_553649186;
           id: int; Accept: string = ""): Recallable =
  ## deleteNotificationsThreadsIdSubscription
  ## Delete a Thread Subscription.
  ##   id: int (required)
  ##     : Id of thread.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_553649193 = newJObject()
  var header_553649194 = newJObject()
  add(path_553649193, "id", newJInt(id))
  add(header_553649194, "Accept", newJString(Accept))
  result = call_553649192.call(path_553649193, nil, header_553649194, nil, nil)

var deleteNotificationsThreadsIdSubscription* = Call_DeleteNotificationsThreadsIdSubscription_553649186(
    name: "deleteNotificationsThreadsIdSubscription",
    meth: HttpMethod.HttpDelete, host: "api.github.com",
    route: "/notifications/threads/{id}/subscription",
    validator: validate_DeleteNotificationsThreadsIdSubscription_553649187,
    base: "/", makeUrl: url_DeleteNotificationsThreadsIdSubscription_553649188,
    schemes: {Scheme.Https})
type
  Call_GetOrgsOrg_553649195 = ref object of OpenApiRestCall_553648476
proc url_GetOrgsOrg_553649197(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
                 (kind: VariableSegment, value: "org")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrg_553649196(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Get an Organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_553649198 = path.getOrDefault("org")
  valid_553649198 = validateParameter(valid_553649198, JString, required = true,
                                      default = nil)
  if valid_553649198 != nil:
    section.add "org", valid_553649198
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649199 = header.getOrDefault("Accept")
  valid_553649199 = validateParameter(valid_553649199, JString,
                                      required = false, default = nil)
  if valid_553649199 != nil:
    section.add "Accept", valid_553649199
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649200: Call_GetOrgsOrg_553649195; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get an Organization.
  ## 
  let valid = call_553649200.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649200.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649200.makeUrl(scheme.get, call_553649200.host, call_553649200.base,
                                   call_553649200.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649200, uri, valid, content)

proc call*(call_553649201: Call_GetOrgsOrg_553649195; org: string;
           Accept: string = ""): Recallable =
  ## getOrgsOrg
  ## Get an Organization.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_553649202 = newJObject()
  var header_553649203 = newJObject()
  add(header_553649203, "Accept", newJString(Accept))
  add(path_553649202, "org", newJString(org))
  result = call_553649201.call(path_553649202, nil, header_553649203, nil, nil)

var getOrgsOrg* = Call_GetOrgsOrg_553649195(name: "getOrgsOrg",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/orgs/{org}",
    validator: validate_GetOrgsOrg_553649196, base: "/",
    makeUrl: url_GetOrgsOrg_553649197, schemes: {Scheme.Https})
type
  Call_PatchOrgsOrg_553649204 = ref object of OpenApiRestCall_553648476
proc url_PatchOrgsOrg_553649206(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
                 (kind: VariableSegment, value: "org")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchOrgsOrg_553649205(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Edit an Organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_553649207 = path.getOrDefault("org")
  valid_553649207 = validateParameter(valid_553649207, JString, required = true,
                                      default = nil)
  if valid_553649207 != nil:
    section.add "org", valid_553649207
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649208 = header.getOrDefault("Accept")
  valid_553649208 = validateParameter(valid_553649208, JString,
                                      required = false, default = nil)
  if valid_553649208 != nil:
    section.add "Accept", valid_553649208
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553649210: Call_PatchOrgsOrg_553649204; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Edit an Organization.
  ## 
  let valid = call_553649210.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649210.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649210.makeUrl(scheme.get, call_553649210.host, call_553649210.base,
                                   call_553649210.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649210, uri, valid, content)

proc call*(call_553649211: Call_PatchOrgsOrg_553649204; body: JsonNode;
           org: string; Accept: string = ""): Recallable =
  ## patchOrgsOrg
  ## Edit an Organization.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   org: string (required)
  ##      : Name of organisation.
  var path_553649212 = newJObject()
  var header_553649213 = newJObject()
  var body_553649214 = newJObject()
  add(header_553649213, "Accept", newJString(Accept))
  if body != nil:
    body_553649214 = body
  add(path_553649212, "org", newJString(org))
  result = call_553649211.call(path_553649212, nil, header_553649213, nil, body_553649214)

var patchOrgsOrg* = Call_PatchOrgsOrg_553649204(name: "patchOrgsOrg",
    meth: HttpMethod.HttpPatch, host: "api.github.com", route: "/orgs/{org}",
    validator: validate_PatchOrgsOrg_553649205, base: "/",
    makeUrl: url_PatchOrgsOrg_553649206, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgEvents_553649215 = ref object of OpenApiRestCall_553648476
proc url_GetOrgsOrgEvents_553649217(protocol: Scheme; host: string;
                                    base: string; route: string; path: JsonNode;
                                    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
                 (kind: VariableSegment, value: "org"),
                 (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgEvents_553649216(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List public events for an organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_553649218 = path.getOrDefault("org")
  valid_553649218 = validateParameter(valid_553649218, JString, required = true,
                                      default = nil)
  if valid_553649218 != nil:
    section.add "org", valid_553649218
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649219 = header.getOrDefault("Accept")
  valid_553649219 = validateParameter(valid_553649219, JString,
                                      required = false, default = nil)
  if valid_553649219 != nil:
    section.add "Accept", valid_553649219
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649220: Call_GetOrgsOrgEvents_553649215;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List public events for an organization.
  ## 
  let valid = call_553649220.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649220.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649220.makeUrl(scheme.get, call_553649220.host, call_553649220.base,
                                   call_553649220.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649220, uri, valid, content)

proc call*(call_553649221: Call_GetOrgsOrgEvents_553649215; org: string;
           Accept: string = ""): Recallable =
  ## getOrgsOrgEvents
  ## List public events for an organization.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_553649222 = newJObject()
  var header_553649223 = newJObject()
  add(header_553649223, "Accept", newJString(Accept))
  add(path_553649222, "org", newJString(org))
  result = call_553649221.call(path_553649222, nil, header_553649223, nil, nil)

var getOrgsOrgEvents* = Call_GetOrgsOrgEvents_553649215(
    name: "getOrgsOrgEvents", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/orgs/{org}/events", validator: validate_GetOrgsOrgEvents_553649216,
    base: "/", makeUrl: url_GetOrgsOrgEvents_553649217, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgIssues_553649224 = ref object of OpenApiRestCall_553648476
proc url_GetOrgsOrgIssues_553649226(protocol: Scheme; host: string;
                                    base: string; route: string; path: JsonNode;
                                    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
                 (kind: VariableSegment, value: "org"),
                 (kind: ConstantSegment, value: "/issues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgIssues_553649225(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List issues.
  ## List all issues for a given organization for the authenticated user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_553649227 = path.getOrDefault("org")
  valid_553649227 = validateParameter(valid_553649227, JString, required = true,
                                      default = nil)
  if valid_553649227 != nil:
    section.add "org", valid_553649227
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString (required)
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: JString (required)
  ##   direction: JString (required)
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_553649228 = query.getOrDefault("state")
  valid_553649228 = validateParameter(valid_553649228, JString, required = true,
                                      default = newJString("open"))
  if valid_553649228 != nil:
    section.add "state", valid_553649228
  var valid_553649229 = query.getOrDefault("labels")
  valid_553649229 = validateParameter(valid_553649229, JString, required = true,
                                      default = nil)
  if valid_553649229 != nil:
    section.add "labels", valid_553649229
  var valid_553649230 = query.getOrDefault("sort")
  valid_553649230 = validateParameter(valid_553649230, JString, required = true,
                                      default = newJString("created"))
  if valid_553649230 != nil:
    section.add "sort", valid_553649230
  var valid_553649231 = query.getOrDefault("direction")
  valid_553649231 = validateParameter(valid_553649231, JString, required = true,
                                      default = newJString("desc"))
  if valid_553649231 != nil:
    section.add "direction", valid_553649231
  var valid_553649232 = query.getOrDefault("filter")
  valid_553649232 = validateParameter(valid_553649232, JString, required = true,
                                      default = newJString("all"))
  if valid_553649232 != nil:
    section.add "filter", valid_553649232
  var valid_553649233 = query.getOrDefault("since")
  valid_553649233 = validateParameter(valid_553649233, JString,
                                      required = false, default = nil)
  if valid_553649233 != nil:
    section.add "since", valid_553649233
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649234 = header.getOrDefault("Accept")
  valid_553649234 = validateParameter(valid_553649234, JString,
                                      required = false, default = nil)
  if valid_553649234 != nil:
    section.add "Accept", valid_553649234
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649235: Call_GetOrgsOrgIssues_553649224;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List issues.
  ## List all issues for a given organization for the authenticated user.
  ## 
  ## 
  let valid = call_553649235.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649235.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649235.makeUrl(scheme.get, call_553649235.host, call_553649235.base,
                                   call_553649235.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649235, uri, valid, content)

proc call*(call_553649236: Call_GetOrgsOrgIssues_553649224; labels: string;
           org: string; state: string = "open"; Accept: string = "";
           sort: string = "created"; direction: string = "desc";
           filter: string = "all"; since: string = ""): Recallable =
  ## getOrgsOrgIssues
  ## List issues.
  ## List all issues for a given organization for the authenticated user.
  ## 
  ##   state: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: string (required)
  ##   direction: string (required)
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   org: string (required)
  ##      : Name of organisation.
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  var path_553649237 = newJObject()
  var query_553649238 = newJObject()
  var header_553649239 = newJObject()
  add(query_553649238, "state", newJString(state))
  add(header_553649239, "Accept", newJString(Accept))
  add(query_553649238, "labels", newJString(labels))
  add(query_553649238, "sort", newJString(sort))
  add(query_553649238, "direction", newJString(direction))
  add(query_553649238, "filter", newJString(filter))
  add(path_553649237, "org", newJString(org))
  add(query_553649238, "since", newJString(since))
  result = call_553649236.call(path_553649237, query_553649238, header_553649239,
                               nil, nil)

var getOrgsOrgIssues* = Call_GetOrgsOrgIssues_553649224(
    name: "getOrgsOrgIssues", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/orgs/{org}/issues", validator: validate_GetOrgsOrgIssues_553649225,
    base: "/", makeUrl: url_GetOrgsOrgIssues_553649226, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgMembers_553649240 = ref object of OpenApiRestCall_553648476
proc url_GetOrgsOrgMembers_553649242(protocol: Scheme; host: string;
                                     base: string; route: string;
                                     path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
                 (kind: VariableSegment, value: "org"),
                 (kind: ConstantSegment, value: "/members")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgMembers_553649241(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Members list.
  ## List all users who are members of an organization. A member is a user tha
  ## belongs to at least 1 team in the organization. If the authenticated user
  ## is also an owner of this organization then both concealed and public members
  ## will be returned. If the requester is not an owner of the organization the
  ## query will be redirected to the public members list.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_553649243 = path.getOrDefault("org")
  valid_553649243 = validateParameter(valid_553649243, JString, required = true,
                                      default = nil)
  if valid_553649243 != nil:
    section.add "org", valid_553649243
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649244 = header.getOrDefault("Accept")
  valid_553649244 = validateParameter(valid_553649244, JString,
                                      required = false, default = nil)
  if valid_553649244 != nil:
    section.add "Accept", valid_553649244
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649245: Call_GetOrgsOrgMembers_553649240;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Members list.
  ## List all users who are members of an organization. A member is a user tha
  ## belongs to at least 1 team in the organization. If the authenticated user
  ## is also an owner of this organization then both concealed and public members
  ## will be returned. If the requester is not an owner of the organization the
  ## query will be redirected to the public members list.
  ## 
  ## 
  let valid = call_553649245.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649245.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649245.makeUrl(scheme.get, call_553649245.host, call_553649245.base,
                                   call_553649245.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649245, uri, valid, content)

proc call*(call_553649246: Call_GetOrgsOrgMembers_553649240; org: string;
           Accept: string = ""): Recallable =
  ## getOrgsOrgMembers
  ## Members list.
  ## List all users who are members of an organization. A member is a user tha
  ## belongs to at least 1 team in the organization. If the authenticated user
  ## is also an owner of this organization then both concealed and public members
  ## will be returned. If the requester is not an owner of the organization the
  ## query will be redirected to the public members list.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_553649247 = newJObject()
  var header_553649248 = newJObject()
  add(header_553649248, "Accept", newJString(Accept))
  add(path_553649247, "org", newJString(org))
  result = call_553649246.call(path_553649247, nil, header_553649248, nil, nil)

var getOrgsOrgMembers* = Call_GetOrgsOrgMembers_553649240(
    name: "getOrgsOrgMembers", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/orgs/{org}/members", validator: validate_GetOrgsOrgMembers_553649241,
    base: "/", makeUrl: url_GetOrgsOrgMembers_553649242, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgMembersUsername_553649249 = ref object of OpenApiRestCall_553648476
proc url_GetOrgsOrgMembersUsername_553649251(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
                 (kind: VariableSegment, value: "org"),
                 (kind: ConstantSegment, value: "/members/"),
                 (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgMembersUsername_553649250(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Check if a user is, publicly or privately, a member of the organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of the user.
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `username` field"
  var valid_553649252 = path.getOrDefault("username")
  valid_553649252 = validateParameter(valid_553649252, JString, required = true,
                                      default = nil)
  if valid_553649252 != nil:
    section.add "username", valid_553649252
  var valid_553649253 = path.getOrDefault("org")
  valid_553649253 = validateParameter(valid_553649253, JString, required = true,
                                      default = nil)
  if valid_553649253 != nil:
    section.add "org", valid_553649253
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649254 = header.getOrDefault("Accept")
  valid_553649254 = validateParameter(valid_553649254, JString,
                                      required = false, default = nil)
  if valid_553649254 != nil:
    section.add "Accept", valid_553649254
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649255: Call_GetOrgsOrgMembersUsername_553649249;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Check if a user is, publicly or privately, a member of the organization.
  ## 
  let valid = call_553649255.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649255.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649255.makeUrl(scheme.get, call_553649255.host, call_553649255.base,
                                   call_553649255.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649255, uri, valid, content)

proc call*(call_553649256: Call_GetOrgsOrgMembersUsername_553649249;
           username: string; org: string; Accept: string = ""): Recallable =
  ## getOrgsOrgMembersUsername
  ## Check if a user is, publicly or privately, a member of the organization.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_553649257 = newJObject()
  var header_553649258 = newJObject()
  add(path_553649257, "username", newJString(username))
  add(header_553649258, "Accept", newJString(Accept))
  add(path_553649257, "org", newJString(org))
  result = call_553649256.call(path_553649257, nil, header_553649258, nil, nil)

var getOrgsOrgMembersUsername* = Call_GetOrgsOrgMembersUsername_553649249(
    name: "getOrgsOrgMembersUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/orgs/{org}/members/{username}",
    validator: validate_GetOrgsOrgMembersUsername_553649250, base: "/",
    makeUrl: url_GetOrgsOrgMembersUsername_553649251, schemes: {Scheme.Https})
type
  Call_DeleteOrgsOrgMembersUsername_553649259 = ref object of OpenApiRestCall_553648476
proc url_DeleteOrgsOrgMembersUsername_553649261(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
                 (kind: VariableSegment, value: "org"),
                 (kind: ConstantSegment, value: "/members/"),
                 (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteOrgsOrgMembersUsername_553649260(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Remove a member.
  ## Removing a user from this list will remove them from all teams and they
  ## will no longer have any access to the organization's repositories.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of the user.
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `username` field"
  var valid_553649262 = path.getOrDefault("username")
  valid_553649262 = validateParameter(valid_553649262, JString, required = true,
                                      default = nil)
  if valid_553649262 != nil:
    section.add "username", valid_553649262
  var valid_553649263 = path.getOrDefault("org")
  valid_553649263 = validateParameter(valid_553649263, JString, required = true,
                                      default = nil)
  if valid_553649263 != nil:
    section.add "org", valid_553649263
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649264 = header.getOrDefault("Accept")
  valid_553649264 = validateParameter(valid_553649264, JString,
                                      required = false, default = nil)
  if valid_553649264 != nil:
    section.add "Accept", valid_553649264
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649265: Call_DeleteOrgsOrgMembersUsername_553649259;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Remove a member.
  ## Removing a user from this list will remove them from all teams and they
  ## will no longer have any access to the organization's repositories.
  ## 
  ## 
  let valid = call_553649265.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649265.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649265.makeUrl(scheme.get, call_553649265.host, call_553649265.base,
                                   call_553649265.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649265, uri, valid, content)

proc call*(call_553649266: Call_DeleteOrgsOrgMembersUsername_553649259;
           username: string; org: string; Accept: string = ""): Recallable =
  ## deleteOrgsOrgMembersUsername
  ## Remove a member.
  ## Removing a user from this list will remove them from all teams and they
  ## will no longer have any access to the organization's repositories.
  ## 
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_553649267 = newJObject()
  var header_553649268 = newJObject()
  add(path_553649267, "username", newJString(username))
  add(header_553649268, "Accept", newJString(Accept))
  add(path_553649267, "org", newJString(org))
  result = call_553649266.call(path_553649267, nil, header_553649268, nil, nil)

var deleteOrgsOrgMembersUsername* = Call_DeleteOrgsOrgMembersUsername_553649259(
    name: "deleteOrgsOrgMembersUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/orgs/{org}/members/{username}",
    validator: validate_DeleteOrgsOrgMembersUsername_553649260, base: "/",
    makeUrl: url_DeleteOrgsOrgMembersUsername_553649261, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgPublicMembers_553649269 = ref object of OpenApiRestCall_553648476
proc url_GetOrgsOrgPublicMembers_553649271(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
                 (kind: VariableSegment, value: "org"),
                 (kind: ConstantSegment, value: "/public_members")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgPublicMembers_553649270(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Public members list.
  ## Members of an organization can choose to have their membership publicized
  ## or not.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_553649272 = path.getOrDefault("org")
  valid_553649272 = validateParameter(valid_553649272, JString, required = true,
                                      default = nil)
  if valid_553649272 != nil:
    section.add "org", valid_553649272
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649273 = header.getOrDefault("Accept")
  valid_553649273 = validateParameter(valid_553649273, JString,
                                      required = false, default = nil)
  if valid_553649273 != nil:
    section.add "Accept", valid_553649273
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649274: Call_GetOrgsOrgPublicMembers_553649269;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Public members list.
  ## Members of an organization can choose to have their membership publicized
  ## or not.
  ## 
  ## 
  let valid = call_553649274.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649274.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649274.makeUrl(scheme.get, call_553649274.host, call_553649274.base,
                                   call_553649274.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649274, uri, valid, content)

proc call*(call_553649275: Call_GetOrgsOrgPublicMembers_553649269; org: string;
           Accept: string = ""): Recallable =
  ## getOrgsOrgPublicMembers
  ## Public members list.
  ## Members of an organization can choose to have their membership publicized
  ## or not.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_553649276 = newJObject()
  var header_553649277 = newJObject()
  add(header_553649277, "Accept", newJString(Accept))
  add(path_553649276, "org", newJString(org))
  result = call_553649275.call(path_553649276, nil, header_553649277, nil, nil)

var getOrgsOrgPublicMembers* = Call_GetOrgsOrgPublicMembers_553649269(
    name: "getOrgsOrgPublicMembers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/orgs/{org}/public_members",
    validator: validate_GetOrgsOrgPublicMembers_553649270, base: "/",
    makeUrl: url_GetOrgsOrgPublicMembers_553649271, schemes: {Scheme.Https})
type
  Call_PutOrgsOrgPublicMembersUsername_553649288 = ref object of OpenApiRestCall_553648476
proc url_PutOrgsOrgPublicMembersUsername_553649290(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
                 (kind: VariableSegment, value: "org"),
                 (kind: ConstantSegment, value: "/public_members/"),
                 (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutOrgsOrgPublicMembersUsername_553649289(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Publicize a user's membership.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of the user.
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `username` field"
  var valid_553649291 = path.getOrDefault("username")
  valid_553649291 = validateParameter(valid_553649291, JString, required = true,
                                      default = nil)
  if valid_553649291 != nil:
    section.add "username", valid_553649291
  var valid_553649292 = path.getOrDefault("org")
  valid_553649292 = validateParameter(valid_553649292, JString, required = true,
                                      default = nil)
  if valid_553649292 != nil:
    section.add "org", valid_553649292
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649293 = header.getOrDefault("Accept")
  valid_553649293 = validateParameter(valid_553649293, JString,
                                      required = false, default = nil)
  if valid_553649293 != nil:
    section.add "Accept", valid_553649293
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649294: Call_PutOrgsOrgPublicMembersUsername_553649288;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Publicize a user's membership.
  ## 
  let valid = call_553649294.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649294.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649294.makeUrl(scheme.get, call_553649294.host, call_553649294.base,
                                   call_553649294.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649294, uri, valid, content)

proc call*(call_553649295: Call_PutOrgsOrgPublicMembersUsername_553649288;
           username: string; org: string; Accept: string = ""): Recallable =
  ## putOrgsOrgPublicMembersUsername
  ## Publicize a user's membership.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_553649296 = newJObject()
  var header_553649297 = newJObject()
  add(path_553649296, "username", newJString(username))
  add(header_553649297, "Accept", newJString(Accept))
  add(path_553649296, "org", newJString(org))
  result = call_553649295.call(path_553649296, nil, header_553649297, nil, nil)

var putOrgsOrgPublicMembersUsername* = Call_PutOrgsOrgPublicMembersUsername_553649288(
    name: "putOrgsOrgPublicMembersUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/orgs/{org}/public_members/{username}",
    validator: validate_PutOrgsOrgPublicMembersUsername_553649289, base: "/",
    makeUrl: url_PutOrgsOrgPublicMembersUsername_553649290,
    schemes: {Scheme.Https})
type
  Call_GetOrgsOrgPublicMembersUsername_553649278 = ref object of OpenApiRestCall_553648476
proc url_GetOrgsOrgPublicMembersUsername_553649280(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
                 (kind: VariableSegment, value: "org"),
                 (kind: ConstantSegment, value: "/public_members/"),
                 (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgPublicMembersUsername_553649279(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Check public membership.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of the user.
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `username` field"
  var valid_553649281 = path.getOrDefault("username")
  valid_553649281 = validateParameter(valid_553649281, JString, required = true,
                                      default = nil)
  if valid_553649281 != nil:
    section.add "username", valid_553649281
  var valid_553649282 = path.getOrDefault("org")
  valid_553649282 = validateParameter(valid_553649282, JString, required = true,
                                      default = nil)
  if valid_553649282 != nil:
    section.add "org", valid_553649282
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649283 = header.getOrDefault("Accept")
  valid_553649283 = validateParameter(valid_553649283, JString,
                                      required = false, default = nil)
  if valid_553649283 != nil:
    section.add "Accept", valid_553649283
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649284: Call_GetOrgsOrgPublicMembersUsername_553649278;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Check public membership.
  ## 
  let valid = call_553649284.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649284.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649284.makeUrl(scheme.get, call_553649284.host, call_553649284.base,
                                   call_553649284.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649284, uri, valid, content)

proc call*(call_553649285: Call_GetOrgsOrgPublicMembersUsername_553649278;
           username: string; org: string; Accept: string = ""): Recallable =
  ## getOrgsOrgPublicMembersUsername
  ## Check public membership.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_553649286 = newJObject()
  var header_553649287 = newJObject()
  add(path_553649286, "username", newJString(username))
  add(header_553649287, "Accept", newJString(Accept))
  add(path_553649286, "org", newJString(org))
  result = call_553649285.call(path_553649286, nil, header_553649287, nil, nil)

var getOrgsOrgPublicMembersUsername* = Call_GetOrgsOrgPublicMembersUsername_553649278(
    name: "getOrgsOrgPublicMembersUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/orgs/{org}/public_members/{username}",
    validator: validate_GetOrgsOrgPublicMembersUsername_553649279, base: "/",
    makeUrl: url_GetOrgsOrgPublicMembersUsername_553649280,
    schemes: {Scheme.Https})
type
  Call_DeleteOrgsOrgPublicMembersUsername_553649298 = ref object of OpenApiRestCall_553648476
proc url_DeleteOrgsOrgPublicMembersUsername_553649300(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
                 (kind: VariableSegment, value: "org"),
                 (kind: ConstantSegment, value: "/public_members/"),
                 (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteOrgsOrgPublicMembersUsername_553649299(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Conceal a user's membership.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of the user.
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `username` field"
  var valid_553649301 = path.getOrDefault("username")
  valid_553649301 = validateParameter(valid_553649301, JString, required = true,
                                      default = nil)
  if valid_553649301 != nil:
    section.add "username", valid_553649301
  var valid_553649302 = path.getOrDefault("org")
  valid_553649302 = validateParameter(valid_553649302, JString, required = true,
                                      default = nil)
  if valid_553649302 != nil:
    section.add "org", valid_553649302
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649303 = header.getOrDefault("Accept")
  valid_553649303 = validateParameter(valid_553649303, JString,
                                      required = false, default = nil)
  if valid_553649303 != nil:
    section.add "Accept", valid_553649303
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649304: Call_DeleteOrgsOrgPublicMembersUsername_553649298;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Conceal a user's membership.
  ## 
  let valid = call_553649304.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649304.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649304.makeUrl(scheme.get, call_553649304.host, call_553649304.base,
                                   call_553649304.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649304, uri, valid, content)

proc call*(call_553649305: Call_DeleteOrgsOrgPublicMembersUsername_553649298;
           username: string; org: string; Accept: string = ""): Recallable =
  ## deleteOrgsOrgPublicMembersUsername
  ## Conceal a user's membership.
  ##   username: string (required)
  ##           : Name of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_553649306 = newJObject()
  var header_553649307 = newJObject()
  add(path_553649306, "username", newJString(username))
  add(header_553649307, "Accept", newJString(Accept))
  add(path_553649306, "org", newJString(org))
  result = call_553649305.call(path_553649306, nil, header_553649307, nil, nil)

var deleteOrgsOrgPublicMembersUsername* = Call_DeleteOrgsOrgPublicMembersUsername_553649298(
    name: "deleteOrgsOrgPublicMembersUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/orgs/{org}/public_members/{username}",
    validator: validate_DeleteOrgsOrgPublicMembersUsername_553649299, base: "/",
    makeUrl: url_DeleteOrgsOrgPublicMembersUsername_553649300,
    schemes: {Scheme.Https})
type
  Call_PostOrgsOrgRepos_553649319 = ref object of OpenApiRestCall_553648476
proc url_PostOrgsOrgRepos_553649321(protocol: Scheme; host: string;
                                    base: string; route: string; path: JsonNode;
                                    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
                 (kind: VariableSegment, value: "org"),
                 (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostOrgsOrgRepos_553649320(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_553649322 = path.getOrDefault("org")
  valid_553649322 = validateParameter(valid_553649322, JString, required = true,
                                      default = nil)
  if valid_553649322 != nil:
    section.add "org", valid_553649322
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649323 = header.getOrDefault("Accept")
  valid_553649323 = validateParameter(valid_553649323, JString,
                                      required = false, default = nil)
  if valid_553649323 != nil:
    section.add "Accept", valid_553649323
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553649325: Call_PostOrgsOrgRepos_553649319;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  let valid = call_553649325.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649325.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649325.makeUrl(scheme.get, call_553649325.host, call_553649325.base,
                                   call_553649325.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649325, uri, valid, content)

proc call*(call_553649326: Call_PostOrgsOrgRepos_553649319; body: JsonNode;
           org: string; Accept: string = ""): Recallable =
  ## postOrgsOrgRepos
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   org: string (required)
  ##      : Name of organisation.
  var path_553649327 = newJObject()
  var header_553649328 = newJObject()
  var body_553649329 = newJObject()
  add(header_553649328, "Accept", newJString(Accept))
  if body != nil:
    body_553649329 = body
  add(path_553649327, "org", newJString(org))
  result = call_553649326.call(path_553649327, nil, header_553649328, nil, body_553649329)

var postOrgsOrgRepos* = Call_PostOrgsOrgRepos_553649319(
    name: "postOrgsOrgRepos", meth: HttpMethod.HttpPost, host: "api.github.com",
    route: "/orgs/{org}/repos", validator: validate_PostOrgsOrgRepos_553649320,
    base: "/", makeUrl: url_PostOrgsOrgRepos_553649321, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgRepos_553649308 = ref object of OpenApiRestCall_553648476
proc url_GetOrgsOrgRepos_553649310(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode;
                                   query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
                 (kind: VariableSegment, value: "org"),
                 (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgRepos_553649309(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List repositories for the specified org.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_553649311 = path.getOrDefault("org")
  valid_553649311 = validateParameter(valid_553649311, JString, required = true,
                                      default = nil)
  if valid_553649311 != nil:
    section.add "org", valid_553649311
  result.add "path", section
  ## parameters in `query` object:
  ##   type: JString
  section = newJObject()
  var valid_553649312 = query.getOrDefault("type")
  valid_553649312 = validateParameter(valid_553649312, JString,
                                      required = false,
                                      default = newJString("all"))
  if valid_553649312 != nil:
    section.add "type", valid_553649312
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649313 = header.getOrDefault("Accept")
  valid_553649313 = validateParameter(valid_553649313, JString,
                                      required = false, default = nil)
  if valid_553649313 != nil:
    section.add "Accept", valid_553649313
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649314: Call_GetOrgsOrgRepos_553649308; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List repositories for the specified org.
  ## 
  let valid = call_553649314.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649314.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649314.makeUrl(scheme.get, call_553649314.host, call_553649314.base,
                                   call_553649314.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649314, uri, valid, content)

proc call*(call_553649315: Call_GetOrgsOrgRepos_553649308; org: string;
           Accept: string = ""; `type`: string = "all"): Recallable =
  ## getOrgsOrgRepos
  ## List repositories for the specified org.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   type: string
  ##   org: string (required)
  ##      : Name of organisation.
  var path_553649316 = newJObject()
  var query_553649317 = newJObject()
  var header_553649318 = newJObject()
  add(header_553649318, "Accept", newJString(Accept))
  add(query_553649317, "type", newJString(`type`))
  add(path_553649316, "org", newJString(org))
  result = call_553649315.call(path_553649316, query_553649317, header_553649318,
                               nil, nil)

var getOrgsOrgRepos* = Call_GetOrgsOrgRepos_553649308(name: "getOrgsOrgRepos",
    meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/orgs/{org}/repos", validator: validate_GetOrgsOrgRepos_553649309,
    base: "/", makeUrl: url_GetOrgsOrgRepos_553649310, schemes: {Scheme.Https})
type
  Call_PostOrgsOrgTeams_553649339 = ref object of OpenApiRestCall_553648476
proc url_PostOrgsOrgTeams_553649341(protocol: Scheme; host: string;
                                    base: string; route: string; path: JsonNode;
                                    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
                 (kind: VariableSegment, value: "org"),
                 (kind: ConstantSegment, value: "/teams")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostOrgsOrgTeams_553649340(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Create team.
  ## In order to create a team, the authenticated user must be an owner of organization.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_553649342 = path.getOrDefault("org")
  valid_553649342 = validateParameter(valid_553649342, JString, required = true,
                                      default = nil)
  if valid_553649342 != nil:
    section.add "org", valid_553649342
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649343 = header.getOrDefault("Accept")
  valid_553649343 = validateParameter(valid_553649343, JString,
                                      required = false, default = nil)
  if valid_553649343 != nil:
    section.add "Accept", valid_553649343
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553649345: Call_PostOrgsOrgTeams_553649339;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Create team.
  ## In order to create a team, the authenticated user must be an owner of organization.
  ## 
  ## 
  let valid = call_553649345.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649345.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649345.makeUrl(scheme.get, call_553649345.host, call_553649345.base,
                                   call_553649345.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649345, uri, valid, content)

proc call*(call_553649346: Call_PostOrgsOrgTeams_553649339; body: JsonNode;
           org: string; Accept: string = ""): Recallable =
  ## postOrgsOrgTeams
  ## Create team.
  ## In order to create a team, the authenticated user must be an owner of organization.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   org: string (required)
  ##      : Name of organisation.
  var path_553649347 = newJObject()
  var header_553649348 = newJObject()
  var body_553649349 = newJObject()
  add(header_553649348, "Accept", newJString(Accept))
  if body != nil:
    body_553649349 = body
  add(path_553649347, "org", newJString(org))
  result = call_553649346.call(path_553649347, nil, header_553649348, nil, body_553649349)

var postOrgsOrgTeams* = Call_PostOrgsOrgTeams_553649339(
    name: "postOrgsOrgTeams", meth: HttpMethod.HttpPost, host: "api.github.com",
    route: "/orgs/{org}/teams", validator: validate_PostOrgsOrgTeams_553649340,
    base: "/", makeUrl: url_PostOrgsOrgTeams_553649341, schemes: {Scheme.Https})
type
  Call_GetOrgsOrgTeams_553649330 = ref object of OpenApiRestCall_553648476
proc url_GetOrgsOrgTeams_553649332(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode;
                                   query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/orgs/"),
                 (kind: VariableSegment, value: "org"),
                 (kind: ConstantSegment, value: "/teams")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetOrgsOrgTeams_553649331(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List teams.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   org: JString (required)
  ##      : Name of organisation.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `org` field"
  var valid_553649333 = path.getOrDefault("org")
  valid_553649333 = validateParameter(valid_553649333, JString, required = true,
                                      default = nil)
  if valid_553649333 != nil:
    section.add "org", valid_553649333
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649334 = header.getOrDefault("Accept")
  valid_553649334 = validateParameter(valid_553649334, JString,
                                      required = false, default = nil)
  if valid_553649334 != nil:
    section.add "Accept", valid_553649334
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649335: Call_GetOrgsOrgTeams_553649330; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List teams.
  ## 
  let valid = call_553649335.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649335.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649335.makeUrl(scheme.get, call_553649335.host, call_553649335.base,
                                   call_553649335.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649335, uri, valid, content)

proc call*(call_553649336: Call_GetOrgsOrgTeams_553649330; org: string;
           Accept: string = ""): Recallable =
  ## getOrgsOrgTeams
  ## List teams.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  ##      : Name of organisation.
  var path_553649337 = newJObject()
  var header_553649338 = newJObject()
  add(header_553649338, "Accept", newJString(Accept))
  add(path_553649337, "org", newJString(org))
  result = call_553649336.call(path_553649337, nil, header_553649338, nil, nil)

var getOrgsOrgTeams* = Call_GetOrgsOrgTeams_553649330(name: "getOrgsOrgTeams",
    meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/orgs/{org}/teams", validator: validate_GetOrgsOrgTeams_553649331,
    base: "/", makeUrl: url_GetOrgsOrgTeams_553649332, schemes: {Scheme.Https})
type
  Call_GetRateLimit_553649350 = ref object of OpenApiRestCall_553648476
proc url_GetRateLimit_553649352(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRateLimit_553649351(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Get your current rate limit status
  ## Note: Accessing this endpoint does not count against your rate limit.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649353 = header.getOrDefault("Accept")
  valid_553649353 = validateParameter(valid_553649353, JString,
                                      required = false, default = nil)
  if valid_553649353 != nil:
    section.add "Accept", valid_553649353
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649354: Call_GetRateLimit_553649350; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get your current rate limit status
  ## Note: Accessing this endpoint does not count against your rate limit.
  ## 
  ## 
  let valid = call_553649354.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649354.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649354.makeUrl(scheme.get, call_553649354.host, call_553649354.base,
                                   call_553649354.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649354, uri, valid, content)

proc call*(call_553649355: Call_GetRateLimit_553649350; Accept: string = ""): Recallable =
  ## getRateLimit
  ## Get your current rate limit status
  ## Note: Accessing this endpoint does not count against your rate limit.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_553649356 = newJObject()
  add(header_553649356, "Accept", newJString(Accept))
  result = call_553649355.call(nil, nil, header_553649356, nil, nil)

var getRateLimit* = Call_GetRateLimit_553649350(name: "getRateLimit",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/rate_limit",
    validator: validate_GetRateLimit_553649351, base: "/",
    makeUrl: url_GetRateLimit_553649352, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepo_553649357 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepo_553649359(protocol: Scheme; host: string;
                                     base: string; route: string;
                                     path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepo_553649358(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Get repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649360 = path.getOrDefault("owner")
  valid_553649360 = validateParameter(valid_553649360, JString, required = true,
                                      default = nil)
  if valid_553649360 != nil:
    section.add "owner", valid_553649360
  var valid_553649361 = path.getOrDefault("repo")
  valid_553649361 = validateParameter(valid_553649361, JString, required = true,
                                      default = nil)
  if valid_553649361 != nil:
    section.add "repo", valid_553649361
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649362 = header.getOrDefault("Accept")
  valid_553649362 = validateParameter(valid_553649362, JString,
                                      required = false, default = nil)
  if valid_553649362 != nil:
    section.add "Accept", valid_553649362
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649363: Call_GetReposOwnerRepo_553649357;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get repository.
  ## 
  let valid = call_553649363.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649363.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649363.makeUrl(scheme.get, call_553649363.host, call_553649363.base,
                                   call_553649363.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649363, uri, valid, content)

proc call*(call_553649364: Call_GetReposOwnerRepo_553649357; owner: string;
           repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepo
  ## Get repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649365 = newJObject()
  var header_553649366 = newJObject()
  add(path_553649365, "owner", newJString(owner))
  add(header_553649366, "Accept", newJString(Accept))
  add(path_553649365, "repo", newJString(repo))
  result = call_553649364.call(path_553649365, nil, header_553649366, nil, nil)

var getReposOwnerRepo* = Call_GetReposOwnerRepo_553649357(
    name: "getReposOwnerRepo", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/repos/{owner}/{repo}", validator: validate_GetReposOwnerRepo_553649358,
    base: "/", makeUrl: url_GetReposOwnerRepo_553649359, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepo_553649377 = ref object of OpenApiRestCall_553648476
proc url_PatchReposOwnerRepo_553649379(protocol: Scheme; host: string;
                                       base: string; route: string;
                                       path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepo_553649378(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Edit repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649380 = path.getOrDefault("owner")
  valid_553649380 = validateParameter(valid_553649380, JString, required = true,
                                      default = nil)
  if valid_553649380 != nil:
    section.add "owner", valid_553649380
  var valid_553649381 = path.getOrDefault("repo")
  valid_553649381 = validateParameter(valid_553649381, JString, required = true,
                                      default = nil)
  if valid_553649381 != nil:
    section.add "repo", valid_553649381
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649382 = header.getOrDefault("Accept")
  valid_553649382 = validateParameter(valid_553649382, JString,
                                      required = false, default = nil)
  if valid_553649382 != nil:
    section.add "Accept", valid_553649382
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553649384: Call_PatchReposOwnerRepo_553649377;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Edit repository.
  ## 
  let valid = call_553649384.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649384.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649384.makeUrl(scheme.get, call_553649384.host, call_553649384.base,
                                   call_553649384.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649384, uri, valid, content)

proc call*(call_553649385: Call_PatchReposOwnerRepo_553649377; owner: string;
           body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## patchReposOwnerRepo
  ## Edit repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649386 = newJObject()
  var header_553649387 = newJObject()
  var body_553649388 = newJObject()
  add(path_553649386, "owner", newJString(owner))
  add(header_553649387, "Accept", newJString(Accept))
  if body != nil:
    body_553649388 = body
  add(path_553649386, "repo", newJString(repo))
  result = call_553649385.call(path_553649386, nil, header_553649387, nil, body_553649388)

var patchReposOwnerRepo* = Call_PatchReposOwnerRepo_553649377(
    name: "patchReposOwnerRepo", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}",
    validator: validate_PatchReposOwnerRepo_553649378, base: "/",
    makeUrl: url_PatchReposOwnerRepo_553649379, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepo_553649367 = ref object of OpenApiRestCall_553648476
proc url_DeleteReposOwnerRepo_553649369(protocol: Scheme; host: string;
                                        base: string; route: string;
                                        path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepo_553649368(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Delete a Repository.
  ## Deleting a repository requires admin access. If OAuth is used, the delete_repo
  ## scope is required.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649370 = path.getOrDefault("owner")
  valid_553649370 = validateParameter(valid_553649370, JString, required = true,
                                      default = nil)
  if valid_553649370 != nil:
    section.add "owner", valid_553649370
  var valid_553649371 = path.getOrDefault("repo")
  valid_553649371 = validateParameter(valid_553649371, JString, required = true,
                                      default = nil)
  if valid_553649371 != nil:
    section.add "repo", valid_553649371
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649372 = header.getOrDefault("Accept")
  valid_553649372 = validateParameter(valid_553649372, JString,
                                      required = false, default = nil)
  if valid_553649372 != nil:
    section.add "Accept", valid_553649372
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649373: Call_DeleteReposOwnerRepo_553649367;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Delete a Repository.
  ## Deleting a repository requires admin access. If OAuth is used, the delete_repo
  ## scope is required.
  ## 
  ## 
  let valid = call_553649373.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649373.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649373.makeUrl(scheme.get, call_553649373.host, call_553649373.base,
                                   call_553649373.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649373, uri, valid, content)

proc call*(call_553649374: Call_DeleteReposOwnerRepo_553649367; owner: string;
           repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepo
  ## Delete a Repository.
  ## Deleting a repository requires admin access. If OAuth is used, the delete_repo
  ## scope is required.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649375 = newJObject()
  var header_553649376 = newJObject()
  add(path_553649375, "owner", newJString(owner))
  add(header_553649376, "Accept", newJString(Accept))
  add(path_553649375, "repo", newJString(repo))
  result = call_553649374.call(path_553649375, nil, header_553649376, nil, nil)

var deleteReposOwnerRepo* = Call_DeleteReposOwnerRepo_553649367(
    name: "deleteReposOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}",
    validator: validate_DeleteReposOwnerRepo_553649368, base: "/",
    makeUrl: url_DeleteReposOwnerRepo_553649369, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoAssignees_553649389 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoAssignees_553649391(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/assignees")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoAssignees_553649390(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## List assignees.
  ## This call lists all the available assignees (owner + collaborators) to which
  ## issues may be assigned.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649392 = path.getOrDefault("owner")
  valid_553649392 = validateParameter(valid_553649392, JString, required = true,
                                      default = nil)
  if valid_553649392 != nil:
    section.add "owner", valid_553649392
  var valid_553649393 = path.getOrDefault("repo")
  valid_553649393 = validateParameter(valid_553649393, JString, required = true,
                                      default = nil)
  if valid_553649393 != nil:
    section.add "repo", valid_553649393
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649394 = header.getOrDefault("Accept")
  valid_553649394 = validateParameter(valid_553649394, JString,
                                      required = false, default = nil)
  if valid_553649394 != nil:
    section.add "Accept", valid_553649394
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649395: Call_GetReposOwnerRepoAssignees_553649389;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List assignees.
  ## This call lists all the available assignees (owner + collaborators) to which
  ## issues may be assigned.
  ## 
  ## 
  let valid = call_553649395.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649395.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649395.makeUrl(scheme.get, call_553649395.host, call_553649395.base,
                                   call_553649395.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649395, uri, valid, content)

proc call*(call_553649396: Call_GetReposOwnerRepoAssignees_553649389;
           owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoAssignees
  ## List assignees.
  ## This call lists all the available assignees (owner + collaborators) to which
  ## issues may be assigned.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649397 = newJObject()
  var header_553649398 = newJObject()
  add(path_553649397, "owner", newJString(owner))
  add(header_553649398, "Accept", newJString(Accept))
  add(path_553649397, "repo", newJString(repo))
  result = call_553649396.call(path_553649397, nil, header_553649398, nil, nil)

var getReposOwnerRepoAssignees* = Call_GetReposOwnerRepoAssignees_553649389(
    name: "getReposOwnerRepoAssignees", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/assignees",
    validator: validate_GetReposOwnerRepoAssignees_553649390, base: "/",
    makeUrl: url_GetReposOwnerRepoAssignees_553649391, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoAssigneesAssignee_553649399 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoAssigneesAssignee_553649401(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "assignee" in path, "`assignee` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/assignees/"),
                 (kind: VariableSegment, value: "assignee")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoAssigneesAssignee_553649400(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Check assignee.
  ## You may also check to see if a particular user is an assignee for a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   assignee: JString (required)
  ##           : Login of the assignee.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649402 = path.getOrDefault("owner")
  valid_553649402 = validateParameter(valid_553649402, JString, required = true,
                                      default = nil)
  if valid_553649402 != nil:
    section.add "owner", valid_553649402
  var valid_553649403 = path.getOrDefault("assignee")
  valid_553649403 = validateParameter(valid_553649403, JString, required = true,
                                      default = nil)
  if valid_553649403 != nil:
    section.add "assignee", valid_553649403
  var valid_553649404 = path.getOrDefault("repo")
  valid_553649404 = validateParameter(valid_553649404, JString, required = true,
                                      default = nil)
  if valid_553649404 != nil:
    section.add "repo", valid_553649404
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649405 = header.getOrDefault("Accept")
  valid_553649405 = validateParameter(valid_553649405, JString,
                                      required = false, default = nil)
  if valid_553649405 != nil:
    section.add "Accept", valid_553649405
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649406: Call_GetReposOwnerRepoAssigneesAssignee_553649399;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Check assignee.
  ## You may also check to see if a particular user is an assignee for a repository.
  ## 
  ## 
  let valid = call_553649406.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649406.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649406.makeUrl(scheme.get, call_553649406.host, call_553649406.base,
                                   call_553649406.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649406, uri, valid, content)

proc call*(call_553649407: Call_GetReposOwnerRepoAssigneesAssignee_553649399;
           owner: string; assignee: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoAssigneesAssignee
  ## Check assignee.
  ## You may also check to see if a particular user is an assignee for a repository.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   assignee: string (required)
  ##           : Login of the assignee.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649408 = newJObject()
  var header_553649409 = newJObject()
  add(path_553649408, "owner", newJString(owner))
  add(path_553649408, "assignee", newJString(assignee))
  add(header_553649409, "Accept", newJString(Accept))
  add(path_553649408, "repo", newJString(repo))
  result = call_553649407.call(path_553649408, nil, header_553649409, nil, nil)

var getReposOwnerRepoAssigneesAssignee* = Call_GetReposOwnerRepoAssigneesAssignee_553649399(
    name: "getReposOwnerRepoAssigneesAssignee", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/assignees/{assignee}",
    validator: validate_GetReposOwnerRepoAssigneesAssignee_553649400, base: "/",
    makeUrl: url_GetReposOwnerRepoAssigneesAssignee_553649401,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoBranches_553649410 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoBranches_553649412(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/branches")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoBranches_553649411(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get list of branches
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649413 = path.getOrDefault("owner")
  valid_553649413 = validateParameter(valid_553649413, JString, required = true,
                                      default = nil)
  if valid_553649413 != nil:
    section.add "owner", valid_553649413
  var valid_553649414 = path.getOrDefault("repo")
  valid_553649414 = validateParameter(valid_553649414, JString, required = true,
                                      default = nil)
  if valid_553649414 != nil:
    section.add "repo", valid_553649414
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649415 = header.getOrDefault("Accept")
  valid_553649415 = validateParameter(valid_553649415, JString,
                                      required = false, default = nil)
  if valid_553649415 != nil:
    section.add "Accept", valid_553649415
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649416: Call_GetReposOwnerRepoBranches_553649410;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get list of branches
  ## 
  let valid = call_553649416.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649416.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649416.makeUrl(scheme.get, call_553649416.host, call_553649416.base,
                                   call_553649416.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649416, uri, valid, content)

proc call*(call_553649417: Call_GetReposOwnerRepoBranches_553649410;
           owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoBranches
  ## Get list of branches
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649418 = newJObject()
  var header_553649419 = newJObject()
  add(path_553649418, "owner", newJString(owner))
  add(header_553649419, "Accept", newJString(Accept))
  add(path_553649418, "repo", newJString(repo))
  result = call_553649417.call(path_553649418, nil, header_553649419, nil, nil)

var getReposOwnerRepoBranches* = Call_GetReposOwnerRepoBranches_553649410(
    name: "getReposOwnerRepoBranches", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/branches",
    validator: validate_GetReposOwnerRepoBranches_553649411, base: "/",
    makeUrl: url_GetReposOwnerRepoBranches_553649412, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoBranchesBranch_553649420 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoBranchesBranch_553649422(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "branch" in path, "`branch` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/branches/"),
                 (kind: VariableSegment, value: "branch")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoBranchesBranch_553649421(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get Branch
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   branch: JString (required)
  ##         : Name of the branch.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649423 = path.getOrDefault("owner")
  valid_553649423 = validateParameter(valid_553649423, JString, required = true,
                                      default = nil)
  if valid_553649423 != nil:
    section.add "owner", valid_553649423
  var valid_553649424 = path.getOrDefault("branch")
  valid_553649424 = validateParameter(valid_553649424, JString, required = true,
                                      default = nil)
  if valid_553649424 != nil:
    section.add "branch", valid_553649424
  var valid_553649425 = path.getOrDefault("repo")
  valid_553649425 = validateParameter(valid_553649425, JString, required = true,
                                      default = nil)
  if valid_553649425 != nil:
    section.add "repo", valid_553649425
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649426 = header.getOrDefault("Accept")
  valid_553649426 = validateParameter(valid_553649426, JString,
                                      required = false, default = nil)
  if valid_553649426 != nil:
    section.add "Accept", valid_553649426
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649427: Call_GetReposOwnerRepoBranchesBranch_553649420;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get Branch
  ## 
  let valid = call_553649427.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649427.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649427.makeUrl(scheme.get, call_553649427.host, call_553649427.base,
                                   call_553649427.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649427, uri, valid, content)

proc call*(call_553649428: Call_GetReposOwnerRepoBranchesBranch_553649420;
           owner: string; branch: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoBranchesBranch
  ## Get Branch
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   branch: string (required)
  ##         : Name of the branch.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649429 = newJObject()
  var header_553649430 = newJObject()
  add(path_553649429, "owner", newJString(owner))
  add(path_553649429, "branch", newJString(branch))
  add(header_553649430, "Accept", newJString(Accept))
  add(path_553649429, "repo", newJString(repo))
  result = call_553649428.call(path_553649429, nil, header_553649430, nil, nil)

var getReposOwnerRepoBranchesBranch* = Call_GetReposOwnerRepoBranchesBranch_553649420(
    name: "getReposOwnerRepoBranchesBranch", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/branches/{branch}",
    validator: validate_GetReposOwnerRepoBranchesBranch_553649421, base: "/",
    makeUrl: url_GetReposOwnerRepoBranchesBranch_553649422,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCollaborators_553649431 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoCollaborators_553649433(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/collaborators")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCollaborators_553649432(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## List.
  ## When authenticating as an organization owner of an organization-owned
  ## repository, all organization owners are included in the list of
  ## collaborators. Otherwise, only users with access to the repository are
  ## returned in the collaborators list.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649434 = path.getOrDefault("owner")
  valid_553649434 = validateParameter(valid_553649434, JString, required = true,
                                      default = nil)
  if valid_553649434 != nil:
    section.add "owner", valid_553649434
  var valid_553649435 = path.getOrDefault("repo")
  valid_553649435 = validateParameter(valid_553649435, JString, required = true,
                                      default = nil)
  if valid_553649435 != nil:
    section.add "repo", valid_553649435
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649436 = header.getOrDefault("Accept")
  valid_553649436 = validateParameter(valid_553649436, JString,
                                      required = false, default = nil)
  if valid_553649436 != nil:
    section.add "Accept", valid_553649436
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649437: Call_GetReposOwnerRepoCollaborators_553649431;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List.
  ## When authenticating as an organization owner of an organization-owned
  ## repository, all organization owners are included in the list of
  ## collaborators. Otherwise, only users with access to the repository are
  ## returned in the collaborators list.
  ## 
  ## 
  let valid = call_553649437.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649437.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649437.makeUrl(scheme.get, call_553649437.host, call_553649437.base,
                                   call_553649437.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649437, uri, valid, content)

proc call*(call_553649438: Call_GetReposOwnerRepoCollaborators_553649431;
           owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCollaborators
  ## List.
  ## When authenticating as an organization owner of an organization-owned
  ## repository, all organization owners are included in the list of
  ## collaborators. Otherwise, only users with access to the repository are
  ## returned in the collaborators list.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649439 = newJObject()
  var header_553649440 = newJObject()
  add(path_553649439, "owner", newJString(owner))
  add(header_553649440, "Accept", newJString(Accept))
  add(path_553649439, "repo", newJString(repo))
  result = call_553649438.call(path_553649439, nil, header_553649440, nil, nil)

var getReposOwnerRepoCollaborators* = Call_GetReposOwnerRepoCollaborators_553649431(
    name: "getReposOwnerRepoCollaborators", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators",
    validator: validate_GetReposOwnerRepoCollaborators_553649432, base: "/",
    makeUrl: url_GetReposOwnerRepoCollaborators_553649433,
    schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoCollaboratorsUser_553649452 = ref object of OpenApiRestCall_553648476
proc url_PutReposOwnerRepoCollaboratorsUser_553649454(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "user" in path, "`user` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/collaborators/"),
                 (kind: VariableSegment, value: "user")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoCollaboratorsUser_553649453(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Add collaborator.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   user: JString (required)
  ##       : Login of the user.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649455 = path.getOrDefault("owner")
  valid_553649455 = validateParameter(valid_553649455, JString, required = true,
                                      default = nil)
  if valid_553649455 != nil:
    section.add "owner", valid_553649455
  var valid_553649456 = path.getOrDefault("user")
  valid_553649456 = validateParameter(valid_553649456, JString, required = true,
                                      default = nil)
  if valid_553649456 != nil:
    section.add "user", valid_553649456
  var valid_553649457 = path.getOrDefault("repo")
  valid_553649457 = validateParameter(valid_553649457, JString, required = true,
                                      default = nil)
  if valid_553649457 != nil:
    section.add "repo", valid_553649457
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649458 = header.getOrDefault("Accept")
  valid_553649458 = validateParameter(valid_553649458, JString,
                                      required = false, default = nil)
  if valid_553649458 != nil:
    section.add "Accept", valid_553649458
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649459: Call_PutReposOwnerRepoCollaboratorsUser_553649452;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Add collaborator.
  ## 
  let valid = call_553649459.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649459.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649459.makeUrl(scheme.get, call_553649459.host, call_553649459.base,
                                   call_553649459.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649459, uri, valid, content)

proc call*(call_553649460: Call_PutReposOwnerRepoCollaboratorsUser_553649452;
           owner: string; user: string; repo: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoCollaboratorsUser
  ## Add collaborator.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   user: string (required)
  ##       : Login of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649461 = newJObject()
  var header_553649462 = newJObject()
  add(path_553649461, "owner", newJString(owner))
  add(path_553649461, "user", newJString(user))
  add(header_553649462, "Accept", newJString(Accept))
  add(path_553649461, "repo", newJString(repo))
  result = call_553649460.call(path_553649461, nil, header_553649462, nil, nil)

var putReposOwnerRepoCollaboratorsUser* = Call_PutReposOwnerRepoCollaboratorsUser_553649452(
    name: "putReposOwnerRepoCollaboratorsUser", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators/{user}",
    validator: validate_PutReposOwnerRepoCollaboratorsUser_553649453, base: "/",
    makeUrl: url_PutReposOwnerRepoCollaboratorsUser_553649454,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCollaboratorsUser_553649441 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoCollaboratorsUser_553649443(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "user" in path, "`user` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/collaborators/"),
                 (kind: VariableSegment, value: "user")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCollaboratorsUser_553649442(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Check if user is a collaborator
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   user: JString (required)
  ##       : Login of the user.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649444 = path.getOrDefault("owner")
  valid_553649444 = validateParameter(valid_553649444, JString, required = true,
                                      default = nil)
  if valid_553649444 != nil:
    section.add "owner", valid_553649444
  var valid_553649445 = path.getOrDefault("user")
  valid_553649445 = validateParameter(valid_553649445, JString, required = true,
                                      default = nil)
  if valid_553649445 != nil:
    section.add "user", valid_553649445
  var valid_553649446 = path.getOrDefault("repo")
  valid_553649446 = validateParameter(valid_553649446, JString, required = true,
                                      default = nil)
  if valid_553649446 != nil:
    section.add "repo", valid_553649446
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649447 = header.getOrDefault("Accept")
  valid_553649447 = validateParameter(valid_553649447, JString,
                                      required = false, default = nil)
  if valid_553649447 != nil:
    section.add "Accept", valid_553649447
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649448: Call_GetReposOwnerRepoCollaboratorsUser_553649441;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Check if user is a collaborator
  ## 
  let valid = call_553649448.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649448.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649448.makeUrl(scheme.get, call_553649448.host, call_553649448.base,
                                   call_553649448.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649448, uri, valid, content)

proc call*(call_553649449: Call_GetReposOwnerRepoCollaboratorsUser_553649441;
           owner: string; user: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCollaboratorsUser
  ## Check if user is a collaborator
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   user: string (required)
  ##       : Login of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649450 = newJObject()
  var header_553649451 = newJObject()
  add(path_553649450, "owner", newJString(owner))
  add(path_553649450, "user", newJString(user))
  add(header_553649451, "Accept", newJString(Accept))
  add(path_553649450, "repo", newJString(repo))
  result = call_553649449.call(path_553649450, nil, header_553649451, nil, nil)

var getReposOwnerRepoCollaboratorsUser* = Call_GetReposOwnerRepoCollaboratorsUser_553649441(
    name: "getReposOwnerRepoCollaboratorsUser", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators/{user}",
    validator: validate_GetReposOwnerRepoCollaboratorsUser_553649442, base: "/",
    makeUrl: url_GetReposOwnerRepoCollaboratorsUser_553649443,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoCollaboratorsUser_553649463 = ref object of OpenApiRestCall_553648476
proc url_DeleteReposOwnerRepoCollaboratorsUser_553649465(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "user" in path, "`user` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/collaborators/"),
                 (kind: VariableSegment, value: "user")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoCollaboratorsUser_553649464(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Remove collaborator.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   user: JString (required)
  ##       : Login of the user.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649466 = path.getOrDefault("owner")
  valid_553649466 = validateParameter(valid_553649466, JString, required = true,
                                      default = nil)
  if valid_553649466 != nil:
    section.add "owner", valid_553649466
  var valid_553649467 = path.getOrDefault("user")
  valid_553649467 = validateParameter(valid_553649467, JString, required = true,
                                      default = nil)
  if valid_553649467 != nil:
    section.add "user", valid_553649467
  var valid_553649468 = path.getOrDefault("repo")
  valid_553649468 = validateParameter(valid_553649468, JString, required = true,
                                      default = nil)
  if valid_553649468 != nil:
    section.add "repo", valid_553649468
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649469 = header.getOrDefault("Accept")
  valid_553649469 = validateParameter(valid_553649469, JString,
                                      required = false, default = nil)
  if valid_553649469 != nil:
    section.add "Accept", valid_553649469
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649470: Call_DeleteReposOwnerRepoCollaboratorsUser_553649463;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Remove collaborator.
  ## 
  let valid = call_553649470.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649470.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649470.makeUrl(scheme.get, call_553649470.host, call_553649470.base,
                                   call_553649470.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649470, uri, valid, content)

proc call*(call_553649471: Call_DeleteReposOwnerRepoCollaboratorsUser_553649463;
           owner: string; user: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoCollaboratorsUser
  ## Remove collaborator.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   user: string (required)
  ##       : Login of the user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649472 = newJObject()
  var header_553649473 = newJObject()
  add(path_553649472, "owner", newJString(owner))
  add(path_553649472, "user", newJString(user))
  add(header_553649473, "Accept", newJString(Accept))
  add(path_553649472, "repo", newJString(repo))
  result = call_553649471.call(path_553649472, nil, header_553649473, nil, nil)

var deleteReposOwnerRepoCollaboratorsUser* = Call_DeleteReposOwnerRepoCollaboratorsUser_553649463(
    name: "deleteReposOwnerRepoCollaboratorsUser", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/collaborators/{user}",
    validator: validate_DeleteReposOwnerRepoCollaboratorsUser_553649464,
    base: "/", makeUrl: url_DeleteReposOwnerRepoCollaboratorsUser_553649465,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoComments_553649474 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoComments_553649476(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoComments_553649475(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## List commit comments for a repository.
  ## Comments are ordered by ascending ID.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649477 = path.getOrDefault("owner")
  valid_553649477 = validateParameter(valid_553649477, JString, required = true,
                                      default = nil)
  if valid_553649477 != nil:
    section.add "owner", valid_553649477
  var valid_553649478 = path.getOrDefault("repo")
  valid_553649478 = validateParameter(valid_553649478, JString, required = true,
                                      default = nil)
  if valid_553649478 != nil:
    section.add "repo", valid_553649478
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649479 = header.getOrDefault("Accept")
  valid_553649479 = validateParameter(valid_553649479, JString,
                                      required = false, default = nil)
  if valid_553649479 != nil:
    section.add "Accept", valid_553649479
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649480: Call_GetReposOwnerRepoComments_553649474;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List commit comments for a repository.
  ## Comments are ordered by ascending ID.
  ## 
  ## 
  let valid = call_553649480.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649480.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649480.makeUrl(scheme.get, call_553649480.host, call_553649480.base,
                                   call_553649480.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649480, uri, valid, content)

proc call*(call_553649481: Call_GetReposOwnerRepoComments_553649474;
           owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoComments
  ## List commit comments for a repository.
  ## Comments are ordered by ascending ID.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649482 = newJObject()
  var header_553649483 = newJObject()
  add(path_553649482, "owner", newJString(owner))
  add(header_553649483, "Accept", newJString(Accept))
  add(path_553649482, "repo", newJString(repo))
  result = call_553649481.call(path_553649482, nil, header_553649483, nil, nil)

var getReposOwnerRepoComments* = Call_GetReposOwnerRepoComments_553649474(
    name: "getReposOwnerRepoComments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments",
    validator: validate_GetReposOwnerRepoComments_553649475, base: "/",
    makeUrl: url_GetReposOwnerRepoComments_553649476, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommentsCommentId_553649484 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoCommentsCommentId_553649486(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/comments/"),
                 (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommentsCommentId_553649485(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get a single commit comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649487 = path.getOrDefault("owner")
  valid_553649487 = validateParameter(valid_553649487, JString, required = true,
                                      default = nil)
  if valid_553649487 != nil:
    section.add "owner", valid_553649487
  var valid_553649488 = path.getOrDefault("repo")
  valid_553649488 = validateParameter(valid_553649488, JString, required = true,
                                      default = nil)
  if valid_553649488 != nil:
    section.add "repo", valid_553649488
  var valid_553649489 = path.getOrDefault("commentId")
  valid_553649489 = validateParameter(valid_553649489, JInt, required = true,
                                      default = nil)
  if valid_553649489 != nil:
    section.add "commentId", valid_553649489
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649490 = header.getOrDefault("Accept")
  valid_553649490 = validateParameter(valid_553649490, JString,
                                      required = false, default = nil)
  if valid_553649490 != nil:
    section.add "Accept", valid_553649490
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649491: Call_GetReposOwnerRepoCommentsCommentId_553649484;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get a single commit comment.
  ## 
  let valid = call_553649491.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649491.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649491.makeUrl(scheme.get, call_553649491.host, call_553649491.base,
                                   call_553649491.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649491, uri, valid, content)

proc call*(call_553649492: Call_GetReposOwnerRepoCommentsCommentId_553649484;
           owner: string; repo: string; commentId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommentsCommentId
  ## Get a single commit comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_553649493 = newJObject()
  var header_553649494 = newJObject()
  add(path_553649493, "owner", newJString(owner))
  add(header_553649494, "Accept", newJString(Accept))
  add(path_553649493, "repo", newJString(repo))
  add(path_553649493, "commentId", newJInt(commentId))
  result = call_553649492.call(path_553649493, nil, header_553649494, nil, nil)

var getReposOwnerRepoCommentsCommentId* = Call_GetReposOwnerRepoCommentsCommentId_553649484(
    name: "getReposOwnerRepoCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments/{commentId}",
    validator: validate_GetReposOwnerRepoCommentsCommentId_553649485, base: "/",
    makeUrl: url_GetReposOwnerRepoCommentsCommentId_553649486,
    schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoCommentsCommentId_553649506 = ref object of OpenApiRestCall_553648476
proc url_PatchReposOwnerRepoCommentsCommentId_553649508(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/comments/"),
                 (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoCommentsCommentId_553649507(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Update a commit comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649509 = path.getOrDefault("owner")
  valid_553649509 = validateParameter(valid_553649509, JString, required = true,
                                      default = nil)
  if valid_553649509 != nil:
    section.add "owner", valid_553649509
  var valid_553649510 = path.getOrDefault("repo")
  valid_553649510 = validateParameter(valid_553649510, JString, required = true,
                                      default = nil)
  if valid_553649510 != nil:
    section.add "repo", valid_553649510
  var valid_553649511 = path.getOrDefault("commentId")
  valid_553649511 = validateParameter(valid_553649511, JInt, required = true,
                                      default = nil)
  if valid_553649511 != nil:
    section.add "commentId", valid_553649511
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649512 = header.getOrDefault("Accept")
  valid_553649512 = validateParameter(valid_553649512, JString,
                                      required = false, default = nil)
  if valid_553649512 != nil:
    section.add "Accept", valid_553649512
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553649514: Call_PatchReposOwnerRepoCommentsCommentId_553649506;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Update a commit comment.
  ## 
  let valid = call_553649514.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649514.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649514.makeUrl(scheme.get, call_553649514.host, call_553649514.base,
                                   call_553649514.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649514, uri, valid, content)

proc call*(call_553649515: Call_PatchReposOwnerRepoCommentsCommentId_553649506;
           owner: string; body: JsonNode; repo: string; commentId: int;
           Accept: string = ""): Recallable =
  ## patchReposOwnerRepoCommentsCommentId
  ## Update a commit comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_553649516 = newJObject()
  var header_553649517 = newJObject()
  var body_553649518 = newJObject()
  add(path_553649516, "owner", newJString(owner))
  add(header_553649517, "Accept", newJString(Accept))
  if body != nil:
    body_553649518 = body
  add(path_553649516, "repo", newJString(repo))
  add(path_553649516, "commentId", newJInt(commentId))
  result = call_553649515.call(path_553649516, nil, header_553649517, nil, body_553649518)

var patchReposOwnerRepoCommentsCommentId* = Call_PatchReposOwnerRepoCommentsCommentId_553649506(
    name: "patchReposOwnerRepoCommentsCommentId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments/{commentId}",
    validator: validate_PatchReposOwnerRepoCommentsCommentId_553649507,
    base: "/", makeUrl: url_PatchReposOwnerRepoCommentsCommentId_553649508,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoCommentsCommentId_553649495 = ref object of OpenApiRestCall_553648476
proc url_DeleteReposOwnerRepoCommentsCommentId_553649497(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/comments/"),
                 (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoCommentsCommentId_553649496(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Delete a commit comment
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649498 = path.getOrDefault("owner")
  valid_553649498 = validateParameter(valid_553649498, JString, required = true,
                                      default = nil)
  if valid_553649498 != nil:
    section.add "owner", valid_553649498
  var valid_553649499 = path.getOrDefault("repo")
  valid_553649499 = validateParameter(valid_553649499, JString, required = true,
                                      default = nil)
  if valid_553649499 != nil:
    section.add "repo", valid_553649499
  var valid_553649500 = path.getOrDefault("commentId")
  valid_553649500 = validateParameter(valid_553649500, JInt, required = true,
                                      default = nil)
  if valid_553649500 != nil:
    section.add "commentId", valid_553649500
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649501 = header.getOrDefault("Accept")
  valid_553649501 = validateParameter(valid_553649501, JString,
                                      required = false, default = nil)
  if valid_553649501 != nil:
    section.add "Accept", valid_553649501
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649502: Call_DeleteReposOwnerRepoCommentsCommentId_553649495;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Delete a commit comment
  ## 
  let valid = call_553649502.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649502.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649502.makeUrl(scheme.get, call_553649502.host, call_553649502.base,
                                   call_553649502.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649502, uri, valid, content)

proc call*(call_553649503: Call_DeleteReposOwnerRepoCommentsCommentId_553649495;
           owner: string; repo: string; commentId: int; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoCommentsCommentId
  ## Delete a commit comment
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_553649504 = newJObject()
  var header_553649505 = newJObject()
  add(path_553649504, "owner", newJString(owner))
  add(header_553649505, "Accept", newJString(Accept))
  add(path_553649504, "repo", newJString(repo))
  add(path_553649504, "commentId", newJInt(commentId))
  result = call_553649503.call(path_553649504, nil, header_553649505, nil, nil)

var deleteReposOwnerRepoCommentsCommentId* = Call_DeleteReposOwnerRepoCommentsCommentId_553649495(
    name: "deleteReposOwnerRepoCommentsCommentId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/comments/{commentId}",
    validator: validate_DeleteReposOwnerRepoCommentsCommentId_553649496,
    base: "/", makeUrl: url_DeleteReposOwnerRepoCommentsCommentId_553649497,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommits_553649519 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoCommits_553649521(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/commits")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommits_553649520(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## List commits on a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649522 = path.getOrDefault("owner")
  valid_553649522 = validateParameter(valid_553649522, JString, required = true,
                                      default = nil)
  if valid_553649522 != nil:
    section.add "owner", valid_553649522
  var valid_553649523 = path.getOrDefault("repo")
  valid_553649523 = validateParameter(valid_553649523, JString, required = true,
                                      default = nil)
  if valid_553649523 != nil:
    section.add "repo", valid_553649523
  result.add "path", section
  ## parameters in `query` object:
  ##   path: JString
  ##       : Only commits containing this file path will be returned.
  ##   sha: JString
  ##      : Sha or branch to start listing commits from.
  ##   author: JString
  ##         : GitHub login, name, or email by which to filter by commit author.
  ##   until: JString
  ##        : ISO 8601 Date - Only commits before this date will be returned.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_553649524 = query.getOrDefault("path")
  valid_553649524 = validateParameter(valid_553649524, JString,
                                      required = false, default = nil)
  if valid_553649524 != nil:
    section.add "path", valid_553649524
  var valid_553649525 = query.getOrDefault("sha")
  valid_553649525 = validateParameter(valid_553649525, JString,
                                      required = false, default = nil)
  if valid_553649525 != nil:
    section.add "sha", valid_553649525
  var valid_553649526 = query.getOrDefault("author")
  valid_553649526 = validateParameter(valid_553649526, JString,
                                      required = false, default = nil)
  if valid_553649526 != nil:
    section.add "author", valid_553649526
  var valid_553649527 = query.getOrDefault("until")
  valid_553649527 = validateParameter(valid_553649527, JString,
                                      required = false, default = nil)
  if valid_553649527 != nil:
    section.add "until", valid_553649527
  var valid_553649528 = query.getOrDefault("since")
  valid_553649528 = validateParameter(valid_553649528, JString,
                                      required = false, default = nil)
  if valid_553649528 != nil:
    section.add "since", valid_553649528
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649529 = header.getOrDefault("Accept")
  valid_553649529 = validateParameter(valid_553649529, JString,
                                      required = false, default = nil)
  if valid_553649529 != nil:
    section.add "Accept", valid_553649529
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649530: Call_GetReposOwnerRepoCommits_553649519;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List commits on a repository.
  ## 
  let valid = call_553649530.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649530.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649530.makeUrl(scheme.get, call_553649530.host, call_553649530.base,
                                   call_553649530.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649530, uri, valid, content)

proc call*(call_553649531: Call_GetReposOwnerRepoCommits_553649519;
           owner: string; repo: string; path: string = ""; Accept: string = "";
           sha: string = ""; author: string = ""; until: string = "";
           since: string = ""): Recallable =
  ## getReposOwnerRepoCommits
  ## List commits on a repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   path: string
  ##       : Only commits containing this file path will be returned.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   sha: string
  ##      : Sha or branch to start listing commits from.
  ##   author: string
  ##         : GitHub login, name, or email by which to filter by commit author.
  ##   until: string
  ##        : ISO 8601 Date - Only commits before this date will be returned.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var path_553649532 = newJObject()
  var query_553649533 = newJObject()
  var header_553649534 = newJObject()
  add(path_553649532, "owner", newJString(owner))
  add(query_553649533, "path", newJString(path))
  add(header_553649534, "Accept", newJString(Accept))
  add(path_553649532, "repo", newJString(repo))
  add(query_553649533, "sha", newJString(sha))
  add(query_553649533, "author", newJString(author))
  add(query_553649533, "until", newJString(until))
  add(query_553649533, "since", newJString(since))
  result = call_553649531.call(path_553649532, query_553649533, header_553649534,
                               nil, nil)

var getReposOwnerRepoCommits* = Call_GetReposOwnerRepoCommits_553649519(
    name: "getReposOwnerRepoCommits", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/commits",
    validator: validate_GetReposOwnerRepoCommits_553649520, base: "/",
    makeUrl: url_GetReposOwnerRepoCommits_553649521, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommitsRefStatus_553649535 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoCommitsRefStatus_553649537(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/commits/"),
                 (kind: VariableSegment, value: "ref"),
                 (kind: ConstantSegment, value: "/status")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommitsRefStatus_553649536(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get the combined Status for a specific Ref
  ## The Combined status endpoint is currently available for developers to preview. During the preview period, the API may change without advance notice. Please see the blog post for full details.
  ## To access this endpoint during the preview period, you must provide a custom media type in the Accept header:
  ## application/vnd.github.she-hulk-preview+json
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   ref: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649538 = path.getOrDefault("owner")
  valid_553649538 = validateParameter(valid_553649538, JString, required = true,
                                      default = nil)
  if valid_553649538 != nil:
    section.add "owner", valid_553649538
  var valid_553649539 = path.getOrDefault("ref")
  valid_553649539 = validateParameter(valid_553649539, JString, required = true,
                                      default = nil)
  if valid_553649539 != nil:
    section.add "ref", valid_553649539
  var valid_553649540 = path.getOrDefault("repo")
  valid_553649540 = validateParameter(valid_553649540, JString, required = true,
                                      default = nil)
  if valid_553649540 != nil:
    section.add "repo", valid_553649540
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649541 = header.getOrDefault("Accept")
  valid_553649541 = validateParameter(valid_553649541, JString,
                                      required = false, default = nil)
  if valid_553649541 != nil:
    section.add "Accept", valid_553649541
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649542: Call_GetReposOwnerRepoCommitsRefStatus_553649535;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get the combined Status for a specific Ref
  ## The Combined status endpoint is currently available for developers to preview. During the preview period, the API may change without advance notice. Please see the blog post for full details.
  ## To access this endpoint during the preview period, you must provide a custom media type in the Accept header:
  ## application/vnd.github.she-hulk-preview+json
  ## 
  ## 
  let valid = call_553649542.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649542.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649542.makeUrl(scheme.get, call_553649542.host, call_553649542.base,
                                   call_553649542.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649542, uri, valid, content)

proc call*(call_553649543: Call_GetReposOwnerRepoCommitsRefStatus_553649535;
           owner: string; `ref`: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommitsRefStatus
  ## Get the combined Status for a specific Ref
  ## The Combined status endpoint is currently available for developers to preview. During the preview period, the API may change without advance notice. Please see the blog post for full details.
  ## To access this endpoint during the preview period, you must provide a custom media type in the Accept header:
  ## application/vnd.github.she-hulk-preview+json
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   ref: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649544 = newJObject()
  var header_553649545 = newJObject()
  add(path_553649544, "owner", newJString(owner))
  add(path_553649544, "ref", newJString(`ref`))
  add(header_553649545, "Accept", newJString(Accept))
  add(path_553649544, "repo", newJString(repo))
  result = call_553649543.call(path_553649544, nil, header_553649545, nil, nil)

var getReposOwnerRepoCommitsRefStatus* = Call_GetReposOwnerRepoCommitsRefStatus_553649535(
    name: "getReposOwnerRepoCommitsRefStatus", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/commits/{ref}/status",
    validator: validate_GetReposOwnerRepoCommitsRefStatus_553649536, base: "/",
    makeUrl: url_GetReposOwnerRepoCommitsRefStatus_553649537,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommitsShaCode_553649546 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoCommitsShaCode_553649548(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/commits/"),
                 (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommitsShaCode_553649547(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get a single commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  ##          : SHA-1 code of the commit.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649549 = path.getOrDefault("owner")
  valid_553649549 = validateParameter(valid_553649549, JString, required = true,
                                      default = nil)
  if valid_553649549 != nil:
    section.add "owner", valid_553649549
  var valid_553649550 = path.getOrDefault("repo")
  valid_553649550 = validateParameter(valid_553649550, JString, required = true,
                                      default = nil)
  if valid_553649550 != nil:
    section.add "repo", valid_553649550
  var valid_553649551 = path.getOrDefault("shaCode")
  valid_553649551 = validateParameter(valid_553649551, JString, required = true,
                                      default = nil)
  if valid_553649551 != nil:
    section.add "shaCode", valid_553649551
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649552 = header.getOrDefault("Accept")
  valid_553649552 = validateParameter(valid_553649552, JString,
                                      required = false, default = nil)
  if valid_553649552 != nil:
    section.add "Accept", valid_553649552
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649553: Call_GetReposOwnerRepoCommitsShaCode_553649546;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get a single commit.
  ## 
  let valid = call_553649553.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649553.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649553.makeUrl(scheme.get, call_553649553.host, call_553649553.base,
                                   call_553649553.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649553, uri, valid, content)

proc call*(call_553649554: Call_GetReposOwnerRepoCommitsShaCode_553649546;
           owner: string; repo: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommitsShaCode
  ## Get a single commit.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  ##          : SHA-1 code of the commit.
  var path_553649555 = newJObject()
  var header_553649556 = newJObject()
  add(path_553649555, "owner", newJString(owner))
  add(header_553649556, "Accept", newJString(Accept))
  add(path_553649555, "repo", newJString(repo))
  add(path_553649555, "shaCode", newJString(shaCode))
  result = call_553649554.call(path_553649555, nil, header_553649556, nil, nil)

var getReposOwnerRepoCommitsShaCode* = Call_GetReposOwnerRepoCommitsShaCode_553649546(
    name: "getReposOwnerRepoCommitsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/commits/{shaCode}",
    validator: validate_GetReposOwnerRepoCommitsShaCode_553649547, base: "/",
    makeUrl: url_GetReposOwnerRepoCommitsShaCode_553649548,
    schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoCommitsShaCodeComments_553649568 = ref object of OpenApiRestCall_553648476
proc url_PostReposOwnerRepoCommitsShaCodeComments_553649570(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/commits/"),
                 (kind: VariableSegment, value: "shaCode"),
                 (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoCommitsShaCodeComments_553649569(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Create a commit comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  ##          : SHA-1 code of the commit.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649571 = path.getOrDefault("owner")
  valid_553649571 = validateParameter(valid_553649571, JString, required = true,
                                      default = nil)
  if valid_553649571 != nil:
    section.add "owner", valid_553649571
  var valid_553649572 = path.getOrDefault("repo")
  valid_553649572 = validateParameter(valid_553649572, JString, required = true,
                                      default = nil)
  if valid_553649572 != nil:
    section.add "repo", valid_553649572
  var valid_553649573 = path.getOrDefault("shaCode")
  valid_553649573 = validateParameter(valid_553649573, JString, required = true,
                                      default = nil)
  if valid_553649573 != nil:
    section.add "shaCode", valid_553649573
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649574 = header.getOrDefault("Accept")
  valid_553649574 = validateParameter(valid_553649574, JString,
                                      required = false, default = nil)
  if valid_553649574 != nil:
    section.add "Accept", valid_553649574
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553649576: Call_PostReposOwnerRepoCommitsShaCodeComments_553649568;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Create a commit comment.
  ## 
  let valid = call_553649576.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649576.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649576.makeUrl(scheme.get, call_553649576.host, call_553649576.base,
                                   call_553649576.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649576, uri, valid, content)

proc call*(call_553649577: Call_PostReposOwnerRepoCommitsShaCodeComments_553649568;
           owner: string; body: JsonNode; repo: string; shaCode: string;
           Accept: string = ""): Recallable =
  ## postReposOwnerRepoCommitsShaCodeComments
  ## Create a commit comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  ##          : SHA-1 code of the commit.
  var path_553649578 = newJObject()
  var header_553649579 = newJObject()
  var body_553649580 = newJObject()
  add(path_553649578, "owner", newJString(owner))
  add(header_553649579, "Accept", newJString(Accept))
  if body != nil:
    body_553649580 = body
  add(path_553649578, "repo", newJString(repo))
  add(path_553649578, "shaCode", newJString(shaCode))
  result = call_553649577.call(path_553649578, nil, header_553649579, nil, body_553649580)

var postReposOwnerRepoCommitsShaCodeComments* = Call_PostReposOwnerRepoCommitsShaCodeComments_553649568(
    name: "postReposOwnerRepoCommitsShaCodeComments", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/commits/{shaCode}/comments",
    validator: validate_PostReposOwnerRepoCommitsShaCodeComments_553649569,
    base: "/", makeUrl: url_PostReposOwnerRepoCommitsShaCodeComments_553649570,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCommitsShaCodeComments_553649557 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoCommitsShaCodeComments_553649559(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/commits/"),
                 (kind: VariableSegment, value: "shaCode"),
                 (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCommitsShaCodeComments_553649558(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## List comments for a single commitList comments for a single commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  ##          : SHA-1 code of the commit.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649560 = path.getOrDefault("owner")
  valid_553649560 = validateParameter(valid_553649560, JString, required = true,
                                      default = nil)
  if valid_553649560 != nil:
    section.add "owner", valid_553649560
  var valid_553649561 = path.getOrDefault("repo")
  valid_553649561 = validateParameter(valid_553649561, JString, required = true,
                                      default = nil)
  if valid_553649561 != nil:
    section.add "repo", valid_553649561
  var valid_553649562 = path.getOrDefault("shaCode")
  valid_553649562 = validateParameter(valid_553649562, JString, required = true,
                                      default = nil)
  if valid_553649562 != nil:
    section.add "shaCode", valid_553649562
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649563 = header.getOrDefault("Accept")
  valid_553649563 = validateParameter(valid_553649563, JString,
                                      required = false, default = nil)
  if valid_553649563 != nil:
    section.add "Accept", valid_553649563
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649564: Call_GetReposOwnerRepoCommitsShaCodeComments_553649557;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List comments for a single commitList comments for a single commit.
  ## 
  let valid = call_553649564.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649564.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649564.makeUrl(scheme.get, call_553649564.host, call_553649564.base,
                                   call_553649564.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649564, uri, valid, content)

proc call*(call_553649565: Call_GetReposOwnerRepoCommitsShaCodeComments_553649557;
           owner: string; repo: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoCommitsShaCodeComments
  ## List comments for a single commitList comments for a single commit.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  ##          : SHA-1 code of the commit.
  var path_553649566 = newJObject()
  var header_553649567 = newJObject()
  add(path_553649566, "owner", newJString(owner))
  add(header_553649567, "Accept", newJString(Accept))
  add(path_553649566, "repo", newJString(repo))
  add(path_553649566, "shaCode", newJString(shaCode))
  result = call_553649565.call(path_553649566, nil, header_553649567, nil, nil)

var getReposOwnerRepoCommitsShaCodeComments* = Call_GetReposOwnerRepoCommitsShaCodeComments_553649557(
    name: "getReposOwnerRepoCommitsShaCodeComments", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/commits/{shaCode}/comments",
    validator: validate_GetReposOwnerRepoCommitsShaCodeComments_553649558,
    base: "/", makeUrl: url_GetReposOwnerRepoCommitsShaCodeComments_553649559,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoCompareBaseIdHeadId_553649581 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoCompareBaseIdHeadId_553649583(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "baseId" in path, "`baseId` is a required path parameter"
  assert "headId" in path, "`headId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/compare/"),
                 (kind: VariableSegment, value: "baseId"),
                 (kind: ConstantSegment, value: "..."),
                 (kind: VariableSegment, value: "headId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoCompareBaseIdHeadId_553649582(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Compare two commits
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   baseId: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   headId: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649584 = path.getOrDefault("owner")
  valid_553649584 = validateParameter(valid_553649584, JString, required = true,
                                      default = nil)
  if valid_553649584 != nil:
    section.add "owner", valid_553649584
  var valid_553649585 = path.getOrDefault("baseId")
  valid_553649585 = validateParameter(valid_553649585, JString, required = true,
                                      default = nil)
  if valid_553649585 != nil:
    section.add "baseId", valid_553649585
  var valid_553649586 = path.getOrDefault("repo")
  valid_553649586 = validateParameter(valid_553649586, JString, required = true,
                                      default = nil)
  if valid_553649586 != nil:
    section.add "repo", valid_553649586
  var valid_553649587 = path.getOrDefault("headId")
  valid_553649587 = validateParameter(valid_553649587, JString, required = true,
                                      default = nil)
  if valid_553649587 != nil:
    section.add "headId", valid_553649587
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649588 = header.getOrDefault("Accept")
  valid_553649588 = validateParameter(valid_553649588, JString,
                                      required = false, default = nil)
  if valid_553649588 != nil:
    section.add "Accept", valid_553649588
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649589: Call_GetReposOwnerRepoCompareBaseIdHeadId_553649581;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Compare two commits
  ## 
  let valid = call_553649589.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649589.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649589.makeUrl(scheme.get, call_553649589.host, call_553649589.base,
                                   call_553649589.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649589, uri, valid, content)

proc call*(call_553649590: Call_GetReposOwnerRepoCompareBaseIdHeadId_553649581;
           owner: string; baseId: string; repo: string; headId: string;
           Accept: string = ""): Recallable =
  ## getReposOwnerRepoCompareBaseIdHeadId
  ## Compare two commits
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   baseId: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   headId: string (required)
  var path_553649591 = newJObject()
  var header_553649592 = newJObject()
  add(path_553649591, "owner", newJString(owner))
  add(path_553649591, "baseId", newJString(baseId))
  add(header_553649592, "Accept", newJString(Accept))
  add(path_553649591, "repo", newJString(repo))
  add(path_553649591, "headId", newJString(headId))
  result = call_553649590.call(path_553649591, nil, header_553649592, nil, nil)

var getReposOwnerRepoCompareBaseIdHeadId* = Call_GetReposOwnerRepoCompareBaseIdHeadId_553649581(
    name: "getReposOwnerRepoCompareBaseIdHeadId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/compare/{baseId}...{headId}",
    validator: validate_GetReposOwnerRepoCompareBaseIdHeadId_553649582,
    base: "/", makeUrl: url_GetReposOwnerRepoCompareBaseIdHeadId_553649583,
    schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoContentsPath_553649607 = ref object of OpenApiRestCall_553648476
proc url_PutReposOwnerRepoContentsPath_553649609(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/contents/"),
                 (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoContentsPath_553649608(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Create a file.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   path: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649610 = path.getOrDefault("owner")
  valid_553649610 = validateParameter(valid_553649610, JString, required = true,
                                      default = nil)
  if valid_553649610 != nil:
    section.add "owner", valid_553649610
  var valid_553649611 = path.getOrDefault("repo")
  valid_553649611 = validateParameter(valid_553649611, JString, required = true,
                                      default = nil)
  if valid_553649611 != nil:
    section.add "repo", valid_553649611
  var valid_553649612 = path.getOrDefault("path")
  valid_553649612 = validateParameter(valid_553649612, JString, required = true,
                                      default = nil)
  if valid_553649612 != nil:
    section.add "path", valid_553649612
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649613 = header.getOrDefault("Accept")
  valid_553649613 = validateParameter(valid_553649613, JString,
                                      required = false, default = nil)
  if valid_553649613 != nil:
    section.add "Accept", valid_553649613
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553649615: Call_PutReposOwnerRepoContentsPath_553649607;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Create a file.
  ## 
  let valid = call_553649615.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649615.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649615.makeUrl(scheme.get, call_553649615.host, call_553649615.base,
                                   call_553649615.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649615, uri, valid, content)

proc call*(call_553649616: Call_PutReposOwnerRepoContentsPath_553649607;
           owner: string; body: JsonNode; repo: string; path: string;
           Accept: string = ""): Recallable =
  ## putReposOwnerRepoContentsPath
  ## Create a file.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   path: string (required)
  var path_553649617 = newJObject()
  var header_553649618 = newJObject()
  var body_553649619 = newJObject()
  add(path_553649617, "owner", newJString(owner))
  add(header_553649618, "Accept", newJString(Accept))
  if body != nil:
    body_553649619 = body
  add(path_553649617, "repo", newJString(repo))
  add(path_553649617, "path", newJString(path))
  result = call_553649616.call(path_553649617, nil, header_553649618, nil, body_553649619)

var putReposOwnerRepoContentsPath* = Call_PutReposOwnerRepoContentsPath_553649607(
    name: "putReposOwnerRepoContentsPath", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contents/{path}",
    validator: validate_PutReposOwnerRepoContentsPath_553649608, base: "/",
    makeUrl: url_PutReposOwnerRepoContentsPath_553649609,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoContentsPath_553649593 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoContentsPath_553649595(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/contents/"),
                 (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoContentsPath_553649594(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get contents.
  ## This method returns the contents of a file or directory in a repository.
  ## Files and symlinks support a custom media type for getting the raw content.
  ## Directories and submodules do not support custom media types.
  ## Note: This API supports files up to 1 megabyte in size.
  ## Here can be many outcomes. For details see "http://developer.github.com/v3/repos/contents/"
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   path: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649596 = path.getOrDefault("owner")
  valid_553649596 = validateParameter(valid_553649596, JString, required = true,
                                      default = nil)
  if valid_553649596 != nil:
    section.add "owner", valid_553649596
  var valid_553649597 = path.getOrDefault("repo")
  valid_553649597 = validateParameter(valid_553649597, JString, required = true,
                                      default = nil)
  if valid_553649597 != nil:
    section.add "repo", valid_553649597
  var valid_553649598 = path.getOrDefault("path")
  valid_553649598 = validateParameter(valid_553649598, JString, required = true,
                                      default = nil)
  if valid_553649598 != nil:
    section.add "path", valid_553649598
  result.add "path", section
  ## parameters in `query` object:
  ##   path: JString
  ##       : The content path.
  ##   ref: JString
  ##      : The String name of the Commit/Branch/Tag. Defaults to 'master'.
  section = newJObject()
  var valid_553649599 = query.getOrDefault("path")
  valid_553649599 = validateParameter(valid_553649599, JString,
                                      required = false, default = nil)
  if valid_553649599 != nil:
    section.add "path", valid_553649599
  var valid_553649600 = query.getOrDefault("ref")
  valid_553649600 = validateParameter(valid_553649600, JString,
                                      required = false, default = nil)
  if valid_553649600 != nil:
    section.add "ref", valid_553649600
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649601 = header.getOrDefault("Accept")
  valid_553649601 = validateParameter(valid_553649601, JString,
                                      required = false, default = nil)
  if valid_553649601 != nil:
    section.add "Accept", valid_553649601
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649602: Call_GetReposOwnerRepoContentsPath_553649593;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get contents.
  ## This method returns the contents of a file or directory in a repository.
  ## Files and symlinks support a custom media type for getting the raw content.
  ## Directories and submodules do not support custom media types.
  ## Note: This API supports files up to 1 megabyte in size.
  ## Here can be many outcomes. For details see "http://developer.github.com/v3/repos/contents/"
  ## 
  ## 
  let valid = call_553649602.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649602.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649602.makeUrl(scheme.get, call_553649602.host, call_553649602.base,
                                   call_553649602.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649602, uri, valid, content)

var getReposOwnerRepoContentsPath* = Call_GetReposOwnerRepoContentsPath_553649593(
    name: "getReposOwnerRepoContentsPath", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contents/{path}",
    validator: validate_GetReposOwnerRepoContentsPath_553649594, base: "/",
    makeUrl: url_GetReposOwnerRepoContentsPath_553649595,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoContentsPath_553649620 = ref object of OpenApiRestCall_553648476
proc url_DeleteReposOwnerRepoContentsPath_553649622(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/contents/"),
                 (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoContentsPath_553649621(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Delete a file.
  ## This method deletes a file in a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   path: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649623 = path.getOrDefault("owner")
  valid_553649623 = validateParameter(valid_553649623, JString, required = true,
                                      default = nil)
  if valid_553649623 != nil:
    section.add "owner", valid_553649623
  var valid_553649624 = path.getOrDefault("repo")
  valid_553649624 = validateParameter(valid_553649624, JString, required = true,
                                      default = nil)
  if valid_553649624 != nil:
    section.add "repo", valid_553649624
  var valid_553649625 = path.getOrDefault("path")
  valid_553649625 = validateParameter(valid_553649625, JString, required = true,
                                      default = nil)
  if valid_553649625 != nil:
    section.add "path", valid_553649625
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649626 = header.getOrDefault("Accept")
  valid_553649626 = validateParameter(valid_553649626, JString,
                                      required = false, default = nil)
  if valid_553649626 != nil:
    section.add "Accept", valid_553649626
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553649628: Call_DeleteReposOwnerRepoContentsPath_553649620;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Delete a file.
  ## This method deletes a file in a repository.
  ## 
  ## 
  let valid = call_553649628.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649628.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649628.makeUrl(scheme.get, call_553649628.host, call_553649628.base,
                                   call_553649628.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649628, uri, valid, content)

proc call*(call_553649629: Call_DeleteReposOwnerRepoContentsPath_553649620;
           owner: string; body: JsonNode; repo: string; path: string;
           Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoContentsPath
  ## Delete a file.
  ## This method deletes a file in a repository.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   path: string (required)
  var path_553649630 = newJObject()
  var header_553649631 = newJObject()
  var body_553649632 = newJObject()
  add(path_553649630, "owner", newJString(owner))
  add(header_553649631, "Accept", newJString(Accept))
  if body != nil:
    body_553649632 = body
  add(path_553649630, "repo", newJString(repo))
  add(path_553649630, "path", newJString(path))
  result = call_553649629.call(path_553649630, nil, header_553649631, nil, body_553649632)

var deleteReposOwnerRepoContentsPath* = Call_DeleteReposOwnerRepoContentsPath_553649620(
    name: "deleteReposOwnerRepoContentsPath", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contents/{path}",
    validator: validate_DeleteReposOwnerRepoContentsPath_553649621, base: "/",
    makeUrl: url_DeleteReposOwnerRepoContentsPath_553649622,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoContributors_553649633 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoContributors_553649635(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/contributors")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoContributors_553649634(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get list of contributors.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649636 = path.getOrDefault("owner")
  valid_553649636 = validateParameter(valid_553649636, JString, required = true,
                                      default = nil)
  if valid_553649636 != nil:
    section.add "owner", valid_553649636
  var valid_553649637 = path.getOrDefault("repo")
  valid_553649637 = validateParameter(valid_553649637, JString, required = true,
                                      default = nil)
  if valid_553649637 != nil:
    section.add "repo", valid_553649637
  result.add "path", section
  ## parameters in `query` object:
  ##   anon: JString (required)
  ##       : Set to 1 or true to include anonymous contributors in results.
  section = newJObject()
  assert query != nil,
         "query argument is necessary due to required `anon` field"
  var valid_553649638 = query.getOrDefault("anon")
  valid_553649638 = validateParameter(valid_553649638, JString, required = true,
                                      default = nil)
  if valid_553649638 != nil:
    section.add "anon", valid_553649638
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649639 = header.getOrDefault("Accept")
  valid_553649639 = validateParameter(valid_553649639, JString,
                                      required = false, default = nil)
  if valid_553649639 != nil:
    section.add "Accept", valid_553649639
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649640: Call_GetReposOwnerRepoContributors_553649633;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get list of contributors.
  ## 
  let valid = call_553649640.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649640.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649640.makeUrl(scheme.get, call_553649640.host, call_553649640.base,
                                   call_553649640.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649640, uri, valid, content)

proc call*(call_553649641: Call_GetReposOwnerRepoContributors_553649633;
           owner: string; repo: string; anon: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoContributors
  ## Get list of contributors.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   anon: string (required)
  ##       : Set to 1 or true to include anonymous contributors in results.
  var path_553649642 = newJObject()
  var query_553649643 = newJObject()
  var header_553649644 = newJObject()
  add(path_553649642, "owner", newJString(owner))
  add(header_553649644, "Accept", newJString(Accept))
  add(path_553649642, "repo", newJString(repo))
  add(query_553649643, "anon", newJString(anon))
  result = call_553649641.call(path_553649642, query_553649643, header_553649644,
                               nil, nil)

var getReposOwnerRepoContributors* = Call_GetReposOwnerRepoContributors_553649633(
    name: "getReposOwnerRepoContributors", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/contributors",
    validator: validate_GetReposOwnerRepoContributors_553649634, base: "/",
    makeUrl: url_GetReposOwnerRepoContributors_553649635,
    schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoDeployments_553649655 = ref object of OpenApiRestCall_553648476
proc url_PostReposOwnerRepoDeployments_553649657(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/deployments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoDeployments_553649656(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Users with push access can create a deployment for a given ref
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649658 = path.getOrDefault("owner")
  valid_553649658 = validateParameter(valid_553649658, JString, required = true,
                                      default = nil)
  if valid_553649658 != nil:
    section.add "owner", valid_553649658
  var valid_553649659 = path.getOrDefault("repo")
  valid_553649659 = validateParameter(valid_553649659, JString, required = true,
                                      default = nil)
  if valid_553649659 != nil:
    section.add "repo", valid_553649659
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649660 = header.getOrDefault("Accept")
  valid_553649660 = validateParameter(valid_553649660, JString,
                                      required = false, default = nil)
  if valid_553649660 != nil:
    section.add "Accept", valid_553649660
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553649662: Call_PostReposOwnerRepoDeployments_553649655;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Users with push access can create a deployment for a given ref
  ## 
  let valid = call_553649662.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649662.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649662.makeUrl(scheme.get, call_553649662.host, call_553649662.base,
                                   call_553649662.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649662, uri, valid, content)

proc call*(call_553649663: Call_PostReposOwnerRepoDeployments_553649655;
           owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoDeployments
  ## Users with push access can create a deployment for a given ref
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649664 = newJObject()
  var header_553649665 = newJObject()
  var body_553649666 = newJObject()
  add(path_553649664, "owner", newJString(owner))
  add(header_553649665, "Accept", newJString(Accept))
  if body != nil:
    body_553649666 = body
  add(path_553649664, "repo", newJString(repo))
  result = call_553649663.call(path_553649664, nil, header_553649665, nil, body_553649666)

var postReposOwnerRepoDeployments* = Call_PostReposOwnerRepoDeployments_553649655(
    name: "postReposOwnerRepoDeployments", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/deployments",
    validator: validate_PostReposOwnerRepoDeployments_553649656, base: "/",
    makeUrl: url_PostReposOwnerRepoDeployments_553649657,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDeployments_553649645 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoDeployments_553649647(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/deployments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDeployments_553649646(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Users with pull access can view deployments for a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649648 = path.getOrDefault("owner")
  valid_553649648 = validateParameter(valid_553649648, JString, required = true,
                                      default = nil)
  if valid_553649648 != nil:
    section.add "owner", valid_553649648
  var valid_553649649 = path.getOrDefault("repo")
  valid_553649649 = validateParameter(valid_553649649, JString, required = true,
                                      default = nil)
  if valid_553649649 != nil:
    section.add "repo", valid_553649649
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649650 = header.getOrDefault("Accept")
  valid_553649650 = validateParameter(valid_553649650, JString,
                                      required = false, default = nil)
  if valid_553649650 != nil:
    section.add "Accept", valid_553649650
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649651: Call_GetReposOwnerRepoDeployments_553649645;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Users with pull access can view deployments for a repository
  ## 
  let valid = call_553649651.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649651.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649651.makeUrl(scheme.get, call_553649651.host, call_553649651.base,
                                   call_553649651.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649651, uri, valid, content)

proc call*(call_553649652: Call_GetReposOwnerRepoDeployments_553649645;
           owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDeployments
  ## Users with pull access can view deployments for a repository
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649653 = newJObject()
  var header_553649654 = newJObject()
  add(path_553649653, "owner", newJString(owner))
  add(header_553649654, "Accept", newJString(Accept))
  add(path_553649653, "repo", newJString(repo))
  result = call_553649652.call(path_553649653, nil, header_553649654, nil, nil)

var getReposOwnerRepoDeployments* = Call_GetReposOwnerRepoDeployments_553649645(
    name: "getReposOwnerRepoDeployments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/deployments",
    validator: validate_GetReposOwnerRepoDeployments_553649646, base: "/",
    makeUrl: url_GetReposOwnerRepoDeployments_553649647, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoDeploymentsIdStatuses_553649678 = ref object of OpenApiRestCall_553648476
proc url_PostReposOwnerRepoDeploymentsIdStatuses_553649680(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/deployments/"),
                 (kind: VariableSegment, value: "id"),
                 (kind: ConstantSegment, value: "/statuses")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoDeploymentsIdStatuses_553649679(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Create a Deployment Status
  ## Users with push access can create deployment statuses for a given deployment:
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JInt (required)
  ##     : The Deployment ID to list the statuses from.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649681 = path.getOrDefault("owner")
  valid_553649681 = validateParameter(valid_553649681, JString, required = true,
                                      default = nil)
  if valid_553649681 != nil:
    section.add "owner", valid_553649681
  var valid_553649682 = path.getOrDefault("id")
  valid_553649682 = validateParameter(valid_553649682, JInt, required = true,
                                      default = nil)
  if valid_553649682 != nil:
    section.add "id", valid_553649682
  var valid_553649683 = path.getOrDefault("repo")
  valid_553649683 = validateParameter(valid_553649683, JString, required = true,
                                      default = nil)
  if valid_553649683 != nil:
    section.add "repo", valid_553649683
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649684 = header.getOrDefault("Accept")
  valid_553649684 = validateParameter(valid_553649684, JString,
                                      required = false, default = nil)
  if valid_553649684 != nil:
    section.add "Accept", valid_553649684
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553649686: Call_PostReposOwnerRepoDeploymentsIdStatuses_553649678;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Create a Deployment Status
  ## Users with push access can create deployment statuses for a given deployment:
  ## 
  ## 
  let valid = call_553649686.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649686.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649686.makeUrl(scheme.get, call_553649686.host, call_553649686.base,
                                   call_553649686.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649686, uri, valid, content)

proc call*(call_553649687: Call_PostReposOwnerRepoDeploymentsIdStatuses_553649678;
           owner: string; id: int; body: JsonNode; repo: string;
           Accept: string = ""): Recallable =
  ## postReposOwnerRepoDeploymentsIdStatuses
  ## Create a Deployment Status
  ## Users with push access can create deployment statuses for a given deployment:
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: int (required)
  ##     : The Deployment ID to list the statuses from.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649688 = newJObject()
  var header_553649689 = newJObject()
  var body_553649690 = newJObject()
  add(path_553649688, "owner", newJString(owner))
  add(path_553649688, "id", newJInt(id))
  add(header_553649689, "Accept", newJString(Accept))
  if body != nil:
    body_553649690 = body
  add(path_553649688, "repo", newJString(repo))
  result = call_553649687.call(path_553649688, nil, header_553649689, nil, body_553649690)

var postReposOwnerRepoDeploymentsIdStatuses* = Call_PostReposOwnerRepoDeploymentsIdStatuses_553649678(
    name: "postReposOwnerRepoDeploymentsIdStatuses", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/deployments/{id}/statuses",
    validator: validate_PostReposOwnerRepoDeploymentsIdStatuses_553649679,
    base: "/", makeUrl: url_PostReposOwnerRepoDeploymentsIdStatuses_553649680,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDeploymentsIdStatuses_553649667 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoDeploymentsIdStatuses_553649669(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/deployments/"),
                 (kind: VariableSegment, value: "id"),
                 (kind: ConstantSegment, value: "/statuses")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDeploymentsIdStatuses_553649668(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Users with pull access can view deployment statuses for a deployment
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JInt (required)
  ##     : The Deployment ID to list the statuses from.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649670 = path.getOrDefault("owner")
  valid_553649670 = validateParameter(valid_553649670, JString, required = true,
                                      default = nil)
  if valid_553649670 != nil:
    section.add "owner", valid_553649670
  var valid_553649671 = path.getOrDefault("id")
  valid_553649671 = validateParameter(valid_553649671, JInt, required = true,
                                      default = nil)
  if valid_553649671 != nil:
    section.add "id", valid_553649671
  var valid_553649672 = path.getOrDefault("repo")
  valid_553649672 = validateParameter(valid_553649672, JString, required = true,
                                      default = nil)
  if valid_553649672 != nil:
    section.add "repo", valid_553649672
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649673 = header.getOrDefault("Accept")
  valid_553649673 = validateParameter(valid_553649673, JString,
                                      required = false, default = nil)
  if valid_553649673 != nil:
    section.add "Accept", valid_553649673
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649674: Call_GetReposOwnerRepoDeploymentsIdStatuses_553649667;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Users with pull access can view deployment statuses for a deployment
  ## 
  let valid = call_553649674.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649674.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649674.makeUrl(scheme.get, call_553649674.host, call_553649674.base,
                                   call_553649674.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649674, uri, valid, content)

proc call*(call_553649675: Call_GetReposOwnerRepoDeploymentsIdStatuses_553649667;
           owner: string; id: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDeploymentsIdStatuses
  ## Users with pull access can view deployment statuses for a deployment
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: int (required)
  ##     : The Deployment ID to list the statuses from.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649676 = newJObject()
  var header_553649677 = newJObject()
  add(path_553649676, "owner", newJString(owner))
  add(path_553649676, "id", newJInt(id))
  add(header_553649677, "Accept", newJString(Accept))
  add(path_553649676, "repo", newJString(repo))
  result = call_553649675.call(path_553649676, nil, header_553649677, nil, nil)

var getReposOwnerRepoDeploymentsIdStatuses* = Call_GetReposOwnerRepoDeploymentsIdStatuses_553649667(
    name: "getReposOwnerRepoDeploymentsIdStatuses", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/deployments/{id}/statuses",
    validator: validate_GetReposOwnerRepoDeploymentsIdStatuses_553649668,
    base: "/", makeUrl: url_GetReposOwnerRepoDeploymentsIdStatuses_553649669,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDownloads_553649691 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoDownloads_553649693(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/downloads")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDownloads_553649692(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Deprecated. List downloads for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649694 = path.getOrDefault("owner")
  valid_553649694 = validateParameter(valid_553649694, JString, required = true,
                                      default = nil)
  if valid_553649694 != nil:
    section.add "owner", valid_553649694
  var valid_553649695 = path.getOrDefault("repo")
  valid_553649695 = validateParameter(valid_553649695, JString, required = true,
                                      default = nil)
  if valid_553649695 != nil:
    section.add "repo", valid_553649695
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649696 = header.getOrDefault("Accept")
  valid_553649696 = validateParameter(valid_553649696, JString,
                                      required = false, default = nil)
  if valid_553649696 != nil:
    section.add "Accept", valid_553649696
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649697: Call_GetReposOwnerRepoDownloads_553649691;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Deprecated. List downloads for a repository.
  ## 
  let valid = call_553649697.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649697.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649697.makeUrl(scheme.get, call_553649697.host, call_553649697.base,
                                   call_553649697.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649697, uri, valid, content)

proc call*(call_553649698: Call_GetReposOwnerRepoDownloads_553649691;
           owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDownloads
  ## Deprecated. List downloads for a repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649699 = newJObject()
  var header_553649700 = newJObject()
  add(path_553649699, "owner", newJString(owner))
  add(header_553649700, "Accept", newJString(Accept))
  add(path_553649699, "repo", newJString(repo))
  result = call_553649698.call(path_553649699, nil, header_553649700, nil, nil)

var getReposOwnerRepoDownloads* = Call_GetReposOwnerRepoDownloads_553649691(
    name: "getReposOwnerRepoDownloads", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/downloads",
    validator: validate_GetReposOwnerRepoDownloads_553649692, base: "/",
    makeUrl: url_GetReposOwnerRepoDownloads_553649693, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoDownloadsDownloadId_553649701 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoDownloadsDownloadId_553649703(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "downloadId" in path, "`downloadId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/downloads/"),
                 (kind: VariableSegment, value: "downloadId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoDownloadsDownloadId_553649702(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Deprecated. Get a single download.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   downloadId: JInt (required)
  ##             : Id of download.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649704 = path.getOrDefault("owner")
  valid_553649704 = validateParameter(valid_553649704, JString, required = true,
                                      default = nil)
  if valid_553649704 != nil:
    section.add "owner", valid_553649704
  var valid_553649705 = path.getOrDefault("repo")
  valid_553649705 = validateParameter(valid_553649705, JString, required = true,
                                      default = nil)
  if valid_553649705 != nil:
    section.add "repo", valid_553649705
  var valid_553649706 = path.getOrDefault("downloadId")
  valid_553649706 = validateParameter(valid_553649706, JInt, required = true,
                                      default = nil)
  if valid_553649706 != nil:
    section.add "downloadId", valid_553649706
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649707 = header.getOrDefault("Accept")
  valid_553649707 = validateParameter(valid_553649707, JString,
                                      required = false, default = nil)
  if valid_553649707 != nil:
    section.add "Accept", valid_553649707
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649708: Call_GetReposOwnerRepoDownloadsDownloadId_553649701;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Deprecated. Get a single download.
  ## 
  let valid = call_553649708.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649708.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649708.makeUrl(scheme.get, call_553649708.host, call_553649708.base,
                                   call_553649708.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649708, uri, valid, content)

proc call*(call_553649709: Call_GetReposOwnerRepoDownloadsDownloadId_553649701;
           owner: string; repo: string; downloadId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoDownloadsDownloadId
  ## Deprecated. Get a single download.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   downloadId: int (required)
  ##             : Id of download.
  var path_553649710 = newJObject()
  var header_553649711 = newJObject()
  add(path_553649710, "owner", newJString(owner))
  add(header_553649711, "Accept", newJString(Accept))
  add(path_553649710, "repo", newJString(repo))
  add(path_553649710, "downloadId", newJInt(downloadId))
  result = call_553649709.call(path_553649710, nil, header_553649711, nil, nil)

var getReposOwnerRepoDownloadsDownloadId* = Call_GetReposOwnerRepoDownloadsDownloadId_553649701(
    name: "getReposOwnerRepoDownloadsDownloadId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/downloads/{downloadId}",
    validator: validate_GetReposOwnerRepoDownloadsDownloadId_553649702,
    base: "/", makeUrl: url_GetReposOwnerRepoDownloadsDownloadId_553649703,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoDownloadsDownloadId_553649712 = ref object of OpenApiRestCall_553648476
proc url_DeleteReposOwnerRepoDownloadsDownloadId_553649714(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "downloadId" in path, "`downloadId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/downloads/"),
                 (kind: VariableSegment, value: "downloadId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoDownloadsDownloadId_553649713(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Deprecated. Delete a download.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   downloadId: JInt (required)
  ##             : Id of download.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649715 = path.getOrDefault("owner")
  valid_553649715 = validateParameter(valid_553649715, JString, required = true,
                                      default = nil)
  if valid_553649715 != nil:
    section.add "owner", valid_553649715
  var valid_553649716 = path.getOrDefault("repo")
  valid_553649716 = validateParameter(valid_553649716, JString, required = true,
                                      default = nil)
  if valid_553649716 != nil:
    section.add "repo", valid_553649716
  var valid_553649717 = path.getOrDefault("downloadId")
  valid_553649717 = validateParameter(valid_553649717, JInt, required = true,
                                      default = nil)
  if valid_553649717 != nil:
    section.add "downloadId", valid_553649717
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649718 = header.getOrDefault("Accept")
  valid_553649718 = validateParameter(valid_553649718, JString,
                                      required = false, default = nil)
  if valid_553649718 != nil:
    section.add "Accept", valid_553649718
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649719: Call_DeleteReposOwnerRepoDownloadsDownloadId_553649712;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Deprecated. Delete a download.
  ## 
  let valid = call_553649719.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649719.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649719.makeUrl(scheme.get, call_553649719.host, call_553649719.base,
                                   call_553649719.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649719, uri, valid, content)

proc call*(call_553649720: Call_DeleteReposOwnerRepoDownloadsDownloadId_553649712;
           owner: string; repo: string; downloadId: int; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoDownloadsDownloadId
  ## Deprecated. Delete a download.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   downloadId: int (required)
  ##             : Id of download.
  var path_553649721 = newJObject()
  var header_553649722 = newJObject()
  add(path_553649721, "owner", newJString(owner))
  add(header_553649722, "Accept", newJString(Accept))
  add(path_553649721, "repo", newJString(repo))
  add(path_553649721, "downloadId", newJInt(downloadId))
  result = call_553649720.call(path_553649721, nil, header_553649722, nil, nil)

var deleteReposOwnerRepoDownloadsDownloadId* = Call_DeleteReposOwnerRepoDownloadsDownloadId_553649712(
    name: "deleteReposOwnerRepoDownloadsDownloadId",
    meth: HttpMethod.HttpDelete, host: "api.github.com",
    route: "/repos/{owner}/{repo}/downloads/{downloadId}",
    validator: validate_DeleteReposOwnerRepoDownloadsDownloadId_553649713,
    base: "/", makeUrl: url_DeleteReposOwnerRepoDownloadsDownloadId_553649714,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoEvents_553649723 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoEvents_553649725(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoEvents_553649724(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Get list of repository events.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649726 = path.getOrDefault("owner")
  valid_553649726 = validateParameter(valid_553649726, JString, required = true,
                                      default = nil)
  if valid_553649726 != nil:
    section.add "owner", valid_553649726
  var valid_553649727 = path.getOrDefault("repo")
  valid_553649727 = validateParameter(valid_553649727, JString, required = true,
                                      default = nil)
  if valid_553649727 != nil:
    section.add "repo", valid_553649727
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649728 = header.getOrDefault("Accept")
  valid_553649728 = validateParameter(valid_553649728, JString,
                                      required = false, default = nil)
  if valid_553649728 != nil:
    section.add "Accept", valid_553649728
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649729: Call_GetReposOwnerRepoEvents_553649723;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get list of repository events.
  ## 
  let valid = call_553649729.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649729.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649729.makeUrl(scheme.get, call_553649729.host, call_553649729.base,
                                   call_553649729.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649729, uri, valid, content)

proc call*(call_553649730: Call_GetReposOwnerRepoEvents_553649723;
           owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoEvents
  ## Get list of repository events.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649731 = newJObject()
  var header_553649732 = newJObject()
  add(path_553649731, "owner", newJString(owner))
  add(header_553649732, "Accept", newJString(Accept))
  add(path_553649731, "repo", newJString(repo))
  result = call_553649730.call(path_553649731, nil, header_553649732, nil, nil)

var getReposOwnerRepoEvents* = Call_GetReposOwnerRepoEvents_553649723(
    name: "getReposOwnerRepoEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/events",
    validator: validate_GetReposOwnerRepoEvents_553649724, base: "/",
    makeUrl: url_GetReposOwnerRepoEvents_553649725, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoForks_553649745 = ref object of OpenApiRestCall_553648476
proc url_PostReposOwnerRepoForks_553649747(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/forks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoForks_553649746(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Create a fork.
  ## Forking a Repository happens asynchronously. Therefore, you may have to wai
  ## a short period before accessing the git objects. If this takes longer than 5
  ## minutes, be sure to contact Support.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649748 = path.getOrDefault("owner")
  valid_553649748 = validateParameter(valid_553649748, JString, required = true,
                                      default = nil)
  if valid_553649748 != nil:
    section.add "owner", valid_553649748
  var valid_553649749 = path.getOrDefault("repo")
  valid_553649749 = validateParameter(valid_553649749, JString, required = true,
                                      default = nil)
  if valid_553649749 != nil:
    section.add "repo", valid_553649749
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649750 = header.getOrDefault("Accept")
  valid_553649750 = validateParameter(valid_553649750, JString,
                                      required = false, default = nil)
  if valid_553649750 != nil:
    section.add "Accept", valid_553649750
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553649752: Call_PostReposOwnerRepoForks_553649745;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Create a fork.
  ## Forking a Repository happens asynchronously. Therefore, you may have to wai
  ## a short period before accessing the git objects. If this takes longer than 5
  ## minutes, be sure to contact Support.
  ## 
  ## 
  let valid = call_553649752.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649752.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649752.makeUrl(scheme.get, call_553649752.host, call_553649752.base,
                                   call_553649752.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649752, uri, valid, content)

proc call*(call_553649753: Call_PostReposOwnerRepoForks_553649745;
           owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoForks
  ## Create a fork.
  ## Forking a Repository happens asynchronously. Therefore, you may have to wai
  ## a short period before accessing the git objects. If this takes longer than 5
  ## minutes, be sure to contact Support.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649754 = newJObject()
  var header_553649755 = newJObject()
  var body_553649756 = newJObject()
  add(path_553649754, "owner", newJString(owner))
  add(header_553649755, "Accept", newJString(Accept))
  if body != nil:
    body_553649756 = body
  add(path_553649754, "repo", newJString(repo))
  result = call_553649753.call(path_553649754, nil, header_553649755, nil, body_553649756)

var postReposOwnerRepoForks* = Call_PostReposOwnerRepoForks_553649745(
    name: "postReposOwnerRepoForks", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/forks",
    validator: validate_PostReposOwnerRepoForks_553649746, base: "/",
    makeUrl: url_PostReposOwnerRepoForks_553649747, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoForks_553649733 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoForks_553649735(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/forks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoForks_553649734(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List forks.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649736 = path.getOrDefault("owner")
  valid_553649736 = validateParameter(valid_553649736, JString, required = true,
                                      default = nil)
  if valid_553649736 != nil:
    section.add "owner", valid_553649736
  var valid_553649737 = path.getOrDefault("repo")
  valid_553649737 = validateParameter(valid_553649737, JString, required = true,
                                      default = nil)
  if valid_553649737 != nil:
    section.add "repo", valid_553649737
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  section = newJObject()
  var valid_553649738 = query.getOrDefault("sort")
  valid_553649738 = validateParameter(valid_553649738, JString,
                                      required = false,
                                      default = newJString("newes"))
  if valid_553649738 != nil:
    section.add "sort", valid_553649738
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649739 = header.getOrDefault("Accept")
  valid_553649739 = validateParameter(valid_553649739, JString,
                                      required = false, default = nil)
  if valid_553649739 != nil:
    section.add "Accept", valid_553649739
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649740: Call_GetReposOwnerRepoForks_553649733;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List forks.
  ## 
  let valid = call_553649740.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649740.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649740.makeUrl(scheme.get, call_553649740.host, call_553649740.base,
                                   call_553649740.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649740, uri, valid, content)

proc call*(call_553649741: Call_GetReposOwnerRepoForks_553649733; owner: string;
           repo: string; Accept: string = ""; sort: string = "newes"): Recallable =
  ## getReposOwnerRepoForks
  ## List forks.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   sort: string
  var path_553649742 = newJObject()
  var query_553649743 = newJObject()
  var header_553649744 = newJObject()
  add(path_553649742, "owner", newJString(owner))
  add(header_553649744, "Accept", newJString(Accept))
  add(path_553649742, "repo", newJString(repo))
  add(query_553649743, "sort", newJString(sort))
  result = call_553649741.call(path_553649742, query_553649743, header_553649744,
                               nil, nil)

var getReposOwnerRepoForks* = Call_GetReposOwnerRepoForks_553649733(
    name: "getReposOwnerRepoForks", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/forks",
    validator: validate_GetReposOwnerRepoForks_553649734, base: "/",
    makeUrl: url_GetReposOwnerRepoForks_553649735, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitBlobs_553649757 = ref object of OpenApiRestCall_553648476
proc url_PostReposOwnerRepoGitBlobs_553649759(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/git/blobs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitBlobs_553649758(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Create a Blob.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649760 = path.getOrDefault("owner")
  valid_553649760 = validateParameter(valid_553649760, JString, required = true,
                                      default = nil)
  if valid_553649760 != nil:
    section.add "owner", valid_553649760
  var valid_553649761 = path.getOrDefault("repo")
  valid_553649761 = validateParameter(valid_553649761, JString, required = true,
                                      default = nil)
  if valid_553649761 != nil:
    section.add "repo", valid_553649761
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649762 = header.getOrDefault("Accept")
  valid_553649762 = validateParameter(valid_553649762, JString,
                                      required = false, default = nil)
  if valid_553649762 != nil:
    section.add "Accept", valid_553649762
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553649764: Call_PostReposOwnerRepoGitBlobs_553649757;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Create a Blob.
  ## 
  let valid = call_553649764.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649764.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649764.makeUrl(scheme.get, call_553649764.host, call_553649764.base,
                                   call_553649764.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649764, uri, valid, content)

proc call*(call_553649765: Call_PostReposOwnerRepoGitBlobs_553649757;
           owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitBlobs
  ## Create a Blob.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649766 = newJObject()
  var header_553649767 = newJObject()
  var body_553649768 = newJObject()
  add(path_553649766, "owner", newJString(owner))
  add(header_553649767, "Accept", newJString(Accept))
  if body != nil:
    body_553649768 = body
  add(path_553649766, "repo", newJString(repo))
  result = call_553649765.call(path_553649766, nil, header_553649767, nil, body_553649768)

var postReposOwnerRepoGitBlobs* = Call_PostReposOwnerRepoGitBlobs_553649757(
    name: "postReposOwnerRepoGitBlobs", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/blobs",
    validator: validate_PostReposOwnerRepoGitBlobs_553649758, base: "/",
    makeUrl: url_PostReposOwnerRepoGitBlobs_553649759, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitBlobsShaCode_553649769 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoGitBlobsShaCode_553649771(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/git/blobs/"),
                 (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitBlobsShaCode_553649770(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get a Blob.
  ## Since blobs can be any arbitrary binary data, the input and responses for
  ## the blob API takes an encoding parameter that can be either utf-8 or
  ## base64. If your data cannot be losslessly sent as a UTF-8 string, you can
  ## base64 encode it.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  ##          : SHA-1 code.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649772 = path.getOrDefault("owner")
  valid_553649772 = validateParameter(valid_553649772, JString, required = true,
                                      default = nil)
  if valid_553649772 != nil:
    section.add "owner", valid_553649772
  var valid_553649773 = path.getOrDefault("repo")
  valid_553649773 = validateParameter(valid_553649773, JString, required = true,
                                      default = nil)
  if valid_553649773 != nil:
    section.add "repo", valid_553649773
  var valid_553649774 = path.getOrDefault("shaCode")
  valid_553649774 = validateParameter(valid_553649774, JString, required = true,
                                      default = nil)
  if valid_553649774 != nil:
    section.add "shaCode", valid_553649774
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649775 = header.getOrDefault("Accept")
  valid_553649775 = validateParameter(valid_553649775, JString,
                                      required = false, default = nil)
  if valid_553649775 != nil:
    section.add "Accept", valid_553649775
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649776: Call_GetReposOwnerRepoGitBlobsShaCode_553649769;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get a Blob.
  ## Since blobs can be any arbitrary binary data, the input and responses for
  ## the blob API takes an encoding parameter that can be either utf-8 or
  ## base64. If your data cannot be losslessly sent as a UTF-8 string, you can
  ## base64 encode it.
  ## 
  ## 
  let valid = call_553649776.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649776.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649776.makeUrl(scheme.get, call_553649776.host, call_553649776.base,
                                   call_553649776.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649776, uri, valid, content)

proc call*(call_553649777: Call_GetReposOwnerRepoGitBlobsShaCode_553649769;
           owner: string; repo: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitBlobsShaCode
  ## Get a Blob.
  ## Since blobs can be any arbitrary binary data, the input and responses for
  ## the blob API takes an encoding parameter that can be either utf-8 or
  ## base64. If your data cannot be losslessly sent as a UTF-8 string, you can
  ## base64 encode it.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  ##          : SHA-1 code.
  var path_553649778 = newJObject()
  var header_553649779 = newJObject()
  add(path_553649778, "owner", newJString(owner))
  add(header_553649779, "Accept", newJString(Accept))
  add(path_553649778, "repo", newJString(repo))
  add(path_553649778, "shaCode", newJString(shaCode))
  result = call_553649777.call(path_553649778, nil, header_553649779, nil, nil)

var getReposOwnerRepoGitBlobsShaCode* = Call_GetReposOwnerRepoGitBlobsShaCode_553649769(
    name: "getReposOwnerRepoGitBlobsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/blobs/{shaCode}",
    validator: validate_GetReposOwnerRepoGitBlobsShaCode_553649770, base: "/",
    makeUrl: url_GetReposOwnerRepoGitBlobsShaCode_553649771,
    schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitCommits_553649780 = ref object of OpenApiRestCall_553648476
proc url_PostReposOwnerRepoGitCommits_553649782(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/git/commits")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitCommits_553649781(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Create a Commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649783 = path.getOrDefault("owner")
  valid_553649783 = validateParameter(valid_553649783, JString, required = true,
                                      default = nil)
  if valid_553649783 != nil:
    section.add "owner", valid_553649783
  var valid_553649784 = path.getOrDefault("repo")
  valid_553649784 = validateParameter(valid_553649784, JString, required = true,
                                      default = nil)
  if valid_553649784 != nil:
    section.add "repo", valid_553649784
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649785 = header.getOrDefault("Accept")
  valid_553649785 = validateParameter(valid_553649785, JString,
                                      required = false, default = nil)
  if valid_553649785 != nil:
    section.add "Accept", valid_553649785
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553649787: Call_PostReposOwnerRepoGitCommits_553649780;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Create a Commit.
  ## 
  let valid = call_553649787.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649787.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649787.makeUrl(scheme.get, call_553649787.host, call_553649787.base,
                                   call_553649787.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649787, uri, valid, content)

proc call*(call_553649788: Call_PostReposOwnerRepoGitCommits_553649780;
           owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitCommits
  ## Create a Commit.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649789 = newJObject()
  var header_553649790 = newJObject()
  var body_553649791 = newJObject()
  add(path_553649789, "owner", newJString(owner))
  add(header_553649790, "Accept", newJString(Accept))
  if body != nil:
    body_553649791 = body
  add(path_553649789, "repo", newJString(repo))
  result = call_553649788.call(path_553649789, nil, header_553649790, nil, body_553649791)

var postReposOwnerRepoGitCommits* = Call_PostReposOwnerRepoGitCommits_553649780(
    name: "postReposOwnerRepoGitCommits", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/commits",
    validator: validate_PostReposOwnerRepoGitCommits_553649781, base: "/",
    makeUrl: url_PostReposOwnerRepoGitCommits_553649782, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitCommitsShaCode_553649792 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoGitCommitsShaCode_553649794(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/git/commits/"),
                 (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitCommitsShaCode_553649793(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get a Commit.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  ##          : SHA-1 code.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649795 = path.getOrDefault("owner")
  valid_553649795 = validateParameter(valid_553649795, JString, required = true,
                                      default = nil)
  if valid_553649795 != nil:
    section.add "owner", valid_553649795
  var valid_553649796 = path.getOrDefault("repo")
  valid_553649796 = validateParameter(valid_553649796, JString, required = true,
                                      default = nil)
  if valid_553649796 != nil:
    section.add "repo", valid_553649796
  var valid_553649797 = path.getOrDefault("shaCode")
  valid_553649797 = validateParameter(valid_553649797, JString, required = true,
                                      default = nil)
  if valid_553649797 != nil:
    section.add "shaCode", valid_553649797
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649798 = header.getOrDefault("Accept")
  valid_553649798 = validateParameter(valid_553649798, JString,
                                      required = false, default = nil)
  if valid_553649798 != nil:
    section.add "Accept", valid_553649798
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649799: Call_GetReposOwnerRepoGitCommitsShaCode_553649792;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get a Commit.
  ## 
  let valid = call_553649799.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649799.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649799.makeUrl(scheme.get, call_553649799.host, call_553649799.base,
                                   call_553649799.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649799, uri, valid, content)

proc call*(call_553649800: Call_GetReposOwnerRepoGitCommitsShaCode_553649792;
           owner: string; repo: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitCommitsShaCode
  ## Get a Commit.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  ##          : SHA-1 code.
  var path_553649801 = newJObject()
  var header_553649802 = newJObject()
  add(path_553649801, "owner", newJString(owner))
  add(header_553649802, "Accept", newJString(Accept))
  add(path_553649801, "repo", newJString(repo))
  add(path_553649801, "shaCode", newJString(shaCode))
  result = call_553649800.call(path_553649801, nil, header_553649802, nil, nil)

var getReposOwnerRepoGitCommitsShaCode* = Call_GetReposOwnerRepoGitCommitsShaCode_553649792(
    name: "getReposOwnerRepoGitCommitsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/git/commits/{shaCode}",
    validator: validate_GetReposOwnerRepoGitCommitsShaCode_553649793, base: "/",
    makeUrl: url_GetReposOwnerRepoGitCommitsShaCode_553649794,
    schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitRefs_553649813 = ref object of OpenApiRestCall_553648476
proc url_PostReposOwnerRepoGitRefs_553649815(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/git/refs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitRefs_553649814(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Create a Reference
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649816 = path.getOrDefault("owner")
  valid_553649816 = validateParameter(valid_553649816, JString, required = true,
                                      default = nil)
  if valid_553649816 != nil:
    section.add "owner", valid_553649816
  var valid_553649817 = path.getOrDefault("repo")
  valid_553649817 = validateParameter(valid_553649817, JString, required = true,
                                      default = nil)
  if valid_553649817 != nil:
    section.add "repo", valid_553649817
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649818 = header.getOrDefault("Accept")
  valid_553649818 = validateParameter(valid_553649818, JString,
                                      required = false, default = nil)
  if valid_553649818 != nil:
    section.add "Accept", valid_553649818
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553649820: Call_PostReposOwnerRepoGitRefs_553649813;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Create a Reference
  ## 
  let valid = call_553649820.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649820.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649820.makeUrl(scheme.get, call_553649820.host, call_553649820.base,
                                   call_553649820.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649820, uri, valid, content)

proc call*(call_553649821: Call_PostReposOwnerRepoGitRefs_553649813;
           owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitRefs
  ## Create a Reference
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649822 = newJObject()
  var header_553649823 = newJObject()
  var body_553649824 = newJObject()
  add(path_553649822, "owner", newJString(owner))
  add(header_553649823, "Accept", newJString(Accept))
  if body != nil:
    body_553649824 = body
  add(path_553649822, "repo", newJString(repo))
  result = call_553649821.call(path_553649822, nil, header_553649823, nil, body_553649824)

var postReposOwnerRepoGitRefs* = Call_PostReposOwnerRepoGitRefs_553649813(
    name: "postReposOwnerRepoGitRefs", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs",
    validator: validate_PostReposOwnerRepoGitRefs_553649814, base: "/",
    makeUrl: url_PostReposOwnerRepoGitRefs_553649815, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitRefs_553649803 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoGitRefs_553649805(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/git/refs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitRefs_553649804(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get all References
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649806 = path.getOrDefault("owner")
  valid_553649806 = validateParameter(valid_553649806, JString, required = true,
                                      default = nil)
  if valid_553649806 != nil:
    section.add "owner", valid_553649806
  var valid_553649807 = path.getOrDefault("repo")
  valid_553649807 = validateParameter(valid_553649807, JString, required = true,
                                      default = nil)
  if valid_553649807 != nil:
    section.add "repo", valid_553649807
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649808 = header.getOrDefault("Accept")
  valid_553649808 = validateParameter(valid_553649808, JString,
                                      required = false, default = nil)
  if valid_553649808 != nil:
    section.add "Accept", valid_553649808
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649809: Call_GetReposOwnerRepoGitRefs_553649803;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get all References
  ## 
  let valid = call_553649809.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649809.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649809.makeUrl(scheme.get, call_553649809.host, call_553649809.base,
                                   call_553649809.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649809, uri, valid, content)

proc call*(call_553649810: Call_GetReposOwnerRepoGitRefs_553649803;
           owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitRefs
  ## Get all References
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649811 = newJObject()
  var header_553649812 = newJObject()
  add(path_553649811, "owner", newJString(owner))
  add(header_553649812, "Accept", newJString(Accept))
  add(path_553649811, "repo", newJString(repo))
  result = call_553649810.call(path_553649811, nil, header_553649812, nil, nil)

var getReposOwnerRepoGitRefs* = Call_GetReposOwnerRepoGitRefs_553649803(
    name: "getReposOwnerRepoGitRefs", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs",
    validator: validate_GetReposOwnerRepoGitRefs_553649804, base: "/",
    makeUrl: url_GetReposOwnerRepoGitRefs_553649805, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitRefsRef_553649825 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoGitRefsRef_553649827(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/git/refs/"),
                 (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitRefsRef_553649826(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get a Reference
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   ref: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649828 = path.getOrDefault("owner")
  valid_553649828 = validateParameter(valid_553649828, JString, required = true,
                                      default = nil)
  if valid_553649828 != nil:
    section.add "owner", valid_553649828
  var valid_553649829 = path.getOrDefault("ref")
  valid_553649829 = validateParameter(valid_553649829, JString, required = true,
                                      default = nil)
  if valid_553649829 != nil:
    section.add "ref", valid_553649829
  var valid_553649830 = path.getOrDefault("repo")
  valid_553649830 = validateParameter(valid_553649830, JString, required = true,
                                      default = nil)
  if valid_553649830 != nil:
    section.add "repo", valid_553649830
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649831 = header.getOrDefault("Accept")
  valid_553649831 = validateParameter(valid_553649831, JString,
                                      required = false, default = nil)
  if valid_553649831 != nil:
    section.add "Accept", valid_553649831
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649832: Call_GetReposOwnerRepoGitRefsRef_553649825;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get a Reference
  ## 
  let valid = call_553649832.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649832.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649832.makeUrl(scheme.get, call_553649832.host, call_553649832.base,
                                   call_553649832.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649832, uri, valid, content)

proc call*(call_553649833: Call_GetReposOwnerRepoGitRefsRef_553649825;
           owner: string; `ref`: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitRefsRef
  ## Get a Reference
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   ref: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649834 = newJObject()
  var header_553649835 = newJObject()
  add(path_553649834, "owner", newJString(owner))
  add(path_553649834, "ref", newJString(`ref`))
  add(header_553649835, "Accept", newJString(Accept))
  add(path_553649834, "repo", newJString(repo))
  result = call_553649833.call(path_553649834, nil, header_553649835, nil, nil)

var getReposOwnerRepoGitRefsRef* = Call_GetReposOwnerRepoGitRefsRef_553649825(
    name: "getReposOwnerRepoGitRefsRef", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs/{ref}",
    validator: validate_GetReposOwnerRepoGitRefsRef_553649826, base: "/",
    makeUrl: url_GetReposOwnerRepoGitRefsRef_553649827, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoGitRefsRef_553649847 = ref object of OpenApiRestCall_553648476
proc url_PatchReposOwnerRepoGitRefsRef_553649849(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/git/refs/"),
                 (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoGitRefsRef_553649848(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Update a Reference
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   ref: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649850 = path.getOrDefault("owner")
  valid_553649850 = validateParameter(valid_553649850, JString, required = true,
                                      default = nil)
  if valid_553649850 != nil:
    section.add "owner", valid_553649850
  var valid_553649851 = path.getOrDefault("ref")
  valid_553649851 = validateParameter(valid_553649851, JString, required = true,
                                      default = nil)
  if valid_553649851 != nil:
    section.add "ref", valid_553649851
  var valid_553649852 = path.getOrDefault("repo")
  valid_553649852 = validateParameter(valid_553649852, JString, required = true,
                                      default = nil)
  if valid_553649852 != nil:
    section.add "repo", valid_553649852
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649853 = header.getOrDefault("Accept")
  valid_553649853 = validateParameter(valid_553649853, JString,
                                      required = false, default = nil)
  if valid_553649853 != nil:
    section.add "Accept", valid_553649853
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553649855: Call_PatchReposOwnerRepoGitRefsRef_553649847;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Update a Reference
  ## 
  let valid = call_553649855.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649855.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649855.makeUrl(scheme.get, call_553649855.host, call_553649855.base,
                                   call_553649855.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649855, uri, valid, content)

proc call*(call_553649856: Call_PatchReposOwnerRepoGitRefsRef_553649847;
           owner: string; `ref`: string; body: JsonNode; repo: string;
           Accept: string = ""): Recallable =
  ## patchReposOwnerRepoGitRefsRef
  ## Update a Reference
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   ref: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649857 = newJObject()
  var header_553649858 = newJObject()
  var body_553649859 = newJObject()
  add(path_553649857, "owner", newJString(owner))
  add(path_553649857, "ref", newJString(`ref`))
  add(header_553649858, "Accept", newJString(Accept))
  if body != nil:
    body_553649859 = body
  add(path_553649857, "repo", newJString(repo))
  result = call_553649856.call(path_553649857, nil, header_553649858, nil, body_553649859)

var patchReposOwnerRepoGitRefsRef* = Call_PatchReposOwnerRepoGitRefsRef_553649847(
    name: "patchReposOwnerRepoGitRefsRef", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs/{ref}",
    validator: validate_PatchReposOwnerRepoGitRefsRef_553649848, base: "/",
    makeUrl: url_PatchReposOwnerRepoGitRefsRef_553649849,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoGitRefsRef_553649836 = ref object of OpenApiRestCall_553648476
proc url_DeleteReposOwnerRepoGitRefsRef_553649838(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/git/refs/"),
                 (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoGitRefsRef_553649837(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Delete a Reference
  ## Example: Deleting a branch: DELETE /repos/octocat/Hello-World/git/refs/heads/feature-a
  ## Example: Deleting a tag:        DELETE /repos/octocat/Hello-World/git/refs/tags/v1.0
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   ref: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649839 = path.getOrDefault("owner")
  valid_553649839 = validateParameter(valid_553649839, JString, required = true,
                                      default = nil)
  if valid_553649839 != nil:
    section.add "owner", valid_553649839
  var valid_553649840 = path.getOrDefault("ref")
  valid_553649840 = validateParameter(valid_553649840, JString, required = true,
                                      default = nil)
  if valid_553649840 != nil:
    section.add "ref", valid_553649840
  var valid_553649841 = path.getOrDefault("repo")
  valid_553649841 = validateParameter(valid_553649841, JString, required = true,
                                      default = nil)
  if valid_553649841 != nil:
    section.add "repo", valid_553649841
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649842 = header.getOrDefault("Accept")
  valid_553649842 = validateParameter(valid_553649842, JString,
                                      required = false, default = nil)
  if valid_553649842 != nil:
    section.add "Accept", valid_553649842
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649843: Call_DeleteReposOwnerRepoGitRefsRef_553649836;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Delete a Reference
  ## Example: Deleting a branch: DELETE /repos/octocat/Hello-World/git/refs/heads/feature-a
  ## Example: Deleting a tag:        DELETE /repos/octocat/Hello-World/git/refs/tags/v1.0
  ## 
  ## 
  let valid = call_553649843.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649843.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649843.makeUrl(scheme.get, call_553649843.host, call_553649843.base,
                                   call_553649843.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649843, uri, valid, content)

proc call*(call_553649844: Call_DeleteReposOwnerRepoGitRefsRef_553649836;
           owner: string; `ref`: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoGitRefsRef
  ## Delete a Reference
  ## Example: Deleting a branch: DELETE /repos/octocat/Hello-World/git/refs/heads/feature-a
  ## Example: Deleting a tag:        DELETE /repos/octocat/Hello-World/git/refs/tags/v1.0
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   ref: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649845 = newJObject()
  var header_553649846 = newJObject()
  add(path_553649845, "owner", newJString(owner))
  add(path_553649845, "ref", newJString(`ref`))
  add(header_553649846, "Accept", newJString(Accept))
  add(path_553649845, "repo", newJString(repo))
  result = call_553649844.call(path_553649845, nil, header_553649846, nil, nil)

var deleteReposOwnerRepoGitRefsRef* = Call_DeleteReposOwnerRepoGitRefsRef_553649836(
    name: "deleteReposOwnerRepoGitRefsRef", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/refs/{ref}",
    validator: validate_DeleteReposOwnerRepoGitRefsRef_553649837, base: "/",
    makeUrl: url_DeleteReposOwnerRepoGitRefsRef_553649838,
    schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitTags_553649860 = ref object of OpenApiRestCall_553648476
proc url_PostReposOwnerRepoGitTags_553649862(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/git/tags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitTags_553649861(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Create a Tag Object.
  ## Note that creating a tag object does not create the reference that makes a
  ## tag in Git. If you want to create an annotated tag in Git, you have to do
  ## this call to create the tag object, and then create the refs/tags/[tag]
  ## reference. If you want to create a lightweight tag, you only have to create
  ## the tag reference - this call would be unnecessary.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649863 = path.getOrDefault("owner")
  valid_553649863 = validateParameter(valid_553649863, JString, required = true,
                                      default = nil)
  if valid_553649863 != nil:
    section.add "owner", valid_553649863
  var valid_553649864 = path.getOrDefault("repo")
  valid_553649864 = validateParameter(valid_553649864, JString, required = true,
                                      default = nil)
  if valid_553649864 != nil:
    section.add "repo", valid_553649864
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649865 = header.getOrDefault("Accept")
  valid_553649865 = validateParameter(valid_553649865, JString,
                                      required = false, default = nil)
  if valid_553649865 != nil:
    section.add "Accept", valid_553649865
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553649867: Call_PostReposOwnerRepoGitTags_553649860;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Create a Tag Object.
  ## Note that creating a tag object does not create the reference that makes a
  ## tag in Git. If you want to create an annotated tag in Git, you have to do
  ## this call to create the tag object, and then create the refs/tags/[tag]
  ## reference. If you want to create a lightweight tag, you only have to create
  ## the tag reference - this call would be unnecessary.
  ## 
  ## 
  let valid = call_553649867.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649867.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649867.makeUrl(scheme.get, call_553649867.host, call_553649867.base,
                                   call_553649867.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649867, uri, valid, content)

proc call*(call_553649868: Call_PostReposOwnerRepoGitTags_553649860;
           owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitTags
  ## Create a Tag Object.
  ## Note that creating a tag object does not create the reference that makes a
  ## tag in Git. If you want to create an annotated tag in Git, you have to do
  ## this call to create the tag object, and then create the refs/tags/[tag]
  ## reference. If you want to create a lightweight tag, you only have to create
  ## the tag reference - this call would be unnecessary.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649869 = newJObject()
  var header_553649870 = newJObject()
  var body_553649871 = newJObject()
  add(path_553649869, "owner", newJString(owner))
  add(header_553649870, "Accept", newJString(Accept))
  if body != nil:
    body_553649871 = body
  add(path_553649869, "repo", newJString(repo))
  result = call_553649868.call(path_553649869, nil, header_553649870, nil, body_553649871)

var postReposOwnerRepoGitTags* = Call_PostReposOwnerRepoGitTags_553649860(
    name: "postReposOwnerRepoGitTags", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/tags",
    validator: validate_PostReposOwnerRepoGitTags_553649861, base: "/",
    makeUrl: url_PostReposOwnerRepoGitTags_553649862, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitTagsShaCode_553649872 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoGitTagsShaCode_553649874(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/git/tags/"),
                 (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitTagsShaCode_553649873(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get a Tag.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649875 = path.getOrDefault("owner")
  valid_553649875 = validateParameter(valid_553649875, JString, required = true,
                                      default = nil)
  if valid_553649875 != nil:
    section.add "owner", valid_553649875
  var valid_553649876 = path.getOrDefault("repo")
  valid_553649876 = validateParameter(valid_553649876, JString, required = true,
                                      default = nil)
  if valid_553649876 != nil:
    section.add "repo", valid_553649876
  var valid_553649877 = path.getOrDefault("shaCode")
  valid_553649877 = validateParameter(valid_553649877, JString, required = true,
                                      default = nil)
  if valid_553649877 != nil:
    section.add "shaCode", valid_553649877
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649878 = header.getOrDefault("Accept")
  valid_553649878 = validateParameter(valid_553649878, JString,
                                      required = false, default = nil)
  if valid_553649878 != nil:
    section.add "Accept", valid_553649878
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649879: Call_GetReposOwnerRepoGitTagsShaCode_553649872;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get a Tag.
  ## 
  let valid = call_553649879.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649879.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649879.makeUrl(scheme.get, call_553649879.host, call_553649879.base,
                                   call_553649879.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649879, uri, valid, content)

proc call*(call_553649880: Call_GetReposOwnerRepoGitTagsShaCode_553649872;
           owner: string; repo: string; shaCode: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitTagsShaCode
  ## Get a Tag.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  var path_553649881 = newJObject()
  var header_553649882 = newJObject()
  add(path_553649881, "owner", newJString(owner))
  add(header_553649882, "Accept", newJString(Accept))
  add(path_553649881, "repo", newJString(repo))
  add(path_553649881, "shaCode", newJString(shaCode))
  result = call_553649880.call(path_553649881, nil, header_553649882, nil, nil)

var getReposOwnerRepoGitTagsShaCode* = Call_GetReposOwnerRepoGitTagsShaCode_553649872(
    name: "getReposOwnerRepoGitTagsShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/tags/{shaCode}",
    validator: validate_GetReposOwnerRepoGitTagsShaCode_553649873, base: "/",
    makeUrl: url_GetReposOwnerRepoGitTagsShaCode_553649874,
    schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoGitTrees_553649883 = ref object of OpenApiRestCall_553648476
proc url_PostReposOwnerRepoGitTrees_553649885(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/git/trees")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoGitTrees_553649884(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Create a Tree.
  ## The tree creation API will take nested entries as well. If both a tree and
  ## a nested path modifying that tree are specified, it will overwrite the
  ## contents of that tree with the new path contents and write a new tree out.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649886 = path.getOrDefault("owner")
  valid_553649886 = validateParameter(valid_553649886, JString, required = true,
                                      default = nil)
  if valid_553649886 != nil:
    section.add "owner", valid_553649886
  var valid_553649887 = path.getOrDefault("repo")
  valid_553649887 = validateParameter(valid_553649887, JString, required = true,
                                      default = nil)
  if valid_553649887 != nil:
    section.add "repo", valid_553649887
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649888 = header.getOrDefault("Accept")
  valid_553649888 = validateParameter(valid_553649888, JString,
                                      required = false, default = nil)
  if valid_553649888 != nil:
    section.add "Accept", valid_553649888
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553649890: Call_PostReposOwnerRepoGitTrees_553649883;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Create a Tree.
  ## The tree creation API will take nested entries as well. If both a tree and
  ## a nested path modifying that tree are specified, it will overwrite the
  ## contents of that tree with the new path contents and write a new tree out.
  ## 
  ## 
  let valid = call_553649890.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649890.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649890.makeUrl(scheme.get, call_553649890.host, call_553649890.base,
                                   call_553649890.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649890, uri, valid, content)

proc call*(call_553649891: Call_PostReposOwnerRepoGitTrees_553649883;
           owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoGitTrees
  ## Create a Tree.
  ## The tree creation API will take nested entries as well. If both a tree and
  ## a nested path modifying that tree are specified, it will overwrite the
  ## contents of that tree with the new path contents and write a new tree out.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649892 = newJObject()
  var header_553649893 = newJObject()
  var body_553649894 = newJObject()
  add(path_553649892, "owner", newJString(owner))
  add(header_553649893, "Accept", newJString(Accept))
  if body != nil:
    body_553649894 = body
  add(path_553649892, "repo", newJString(repo))
  result = call_553649891.call(path_553649892, nil, header_553649893, nil, body_553649894)

var postReposOwnerRepoGitTrees* = Call_PostReposOwnerRepoGitTrees_553649883(
    name: "postReposOwnerRepoGitTrees", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/trees",
    validator: validate_PostReposOwnerRepoGitTrees_553649884, base: "/",
    makeUrl: url_PostReposOwnerRepoGitTrees_553649885, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoGitTreesShaCode_553649895 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoGitTreesShaCode_553649897(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "shaCode" in path, "`shaCode` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/git/trees/"),
                 (kind: VariableSegment, value: "shaCode")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoGitTreesShaCode_553649896(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get a Tree.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   shaCode: JString (required)
  ##          : Tree SHA.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649898 = path.getOrDefault("owner")
  valid_553649898 = validateParameter(valid_553649898, JString, required = true,
                                      default = nil)
  if valid_553649898 != nil:
    section.add "owner", valid_553649898
  var valid_553649899 = path.getOrDefault("repo")
  valid_553649899 = validateParameter(valid_553649899, JString, required = true,
                                      default = nil)
  if valid_553649899 != nil:
    section.add "repo", valid_553649899
  var valid_553649900 = path.getOrDefault("shaCode")
  valid_553649900 = validateParameter(valid_553649900, JString, required = true,
                                      default = nil)
  if valid_553649900 != nil:
    section.add "shaCode", valid_553649900
  result.add "path", section
  ## parameters in `query` object:
  ##   recursive: JInt
  ##            : Get a Tree Recursively. (0 or 1)
  section = newJObject()
  var valid_553649901 = query.getOrDefault("recursive")
  valid_553649901 = validateParameter(valid_553649901, JInt, required = false,
                                      default = nil)
  if valid_553649901 != nil:
    section.add "recursive", valid_553649901
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649902 = header.getOrDefault("Accept")
  valid_553649902 = validateParameter(valid_553649902, JString,
                                      required = false, default = nil)
  if valid_553649902 != nil:
    section.add "Accept", valid_553649902
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649903: Call_GetReposOwnerRepoGitTreesShaCode_553649895;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get a Tree.
  ## 
  let valid = call_553649903.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649903.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649903.makeUrl(scheme.get, call_553649903.host, call_553649903.base,
                                   call_553649903.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649903, uri, valid, content)

proc call*(call_553649904: Call_GetReposOwnerRepoGitTreesShaCode_553649895;
           owner: string; repo: string; shaCode: string; recursive: int = 0;
           Accept: string = ""): Recallable =
  ## getReposOwnerRepoGitTreesShaCode
  ## Get a Tree.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   recursive: int
  ##            : Get a Tree Recursively. (0 or 1)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   shaCode: string (required)
  ##          : Tree SHA.
  var path_553649905 = newJObject()
  var query_553649906 = newJObject()
  var header_553649907 = newJObject()
  add(path_553649905, "owner", newJString(owner))
  add(query_553649906, "recursive", newJInt(recursive))
  add(header_553649907, "Accept", newJString(Accept))
  add(path_553649905, "repo", newJString(repo))
  add(path_553649905, "shaCode", newJString(shaCode))
  result = call_553649904.call(path_553649905, query_553649906, header_553649907,
                               nil, nil)

var getReposOwnerRepoGitTreesShaCode* = Call_GetReposOwnerRepoGitTreesShaCode_553649895(
    name: "getReposOwnerRepoGitTreesShaCode", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/git/trees/{shaCode}",
    validator: validate_GetReposOwnerRepoGitTreesShaCode_553649896, base: "/",
    makeUrl: url_GetReposOwnerRepoGitTreesShaCode_553649897,
    schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoHooks_553649918 = ref object of OpenApiRestCall_553648476
proc url_PostReposOwnerRepoHooks_553649920(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/hooks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoHooks_553649919(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Create a hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649921 = path.getOrDefault("owner")
  valid_553649921 = validateParameter(valid_553649921, JString, required = true,
                                      default = nil)
  if valid_553649921 != nil:
    section.add "owner", valid_553649921
  var valid_553649922 = path.getOrDefault("repo")
  valid_553649922 = validateParameter(valid_553649922, JString, required = true,
                                      default = nil)
  if valid_553649922 != nil:
    section.add "repo", valid_553649922
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649923 = header.getOrDefault("Accept")
  valid_553649923 = validateParameter(valid_553649923, JString,
                                      required = false, default = nil)
  if valid_553649923 != nil:
    section.add "Accept", valid_553649923
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553649925: Call_PostReposOwnerRepoHooks_553649918;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Create a hook.
  ## 
  let valid = call_553649925.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649925.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649925.makeUrl(scheme.get, call_553649925.host, call_553649925.base,
                                   call_553649925.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649925, uri, valid, content)

proc call*(call_553649926: Call_PostReposOwnerRepoHooks_553649918;
           owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoHooks
  ## Create a hook.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649927 = newJObject()
  var header_553649928 = newJObject()
  var body_553649929 = newJObject()
  add(path_553649927, "owner", newJString(owner))
  add(header_553649928, "Accept", newJString(Accept))
  if body != nil:
    body_553649929 = body
  add(path_553649927, "repo", newJString(repo))
  result = call_553649926.call(path_553649927, nil, header_553649928, nil, body_553649929)

var postReposOwnerRepoHooks* = Call_PostReposOwnerRepoHooks_553649918(
    name: "postReposOwnerRepoHooks", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks",
    validator: validate_PostReposOwnerRepoHooks_553649919, base: "/",
    makeUrl: url_PostReposOwnerRepoHooks_553649920, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoHooks_553649908 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoHooks_553649910(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/hooks")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoHooks_553649909(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Get list of hooks.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649911 = path.getOrDefault("owner")
  valid_553649911 = validateParameter(valid_553649911, JString, required = true,
                                      default = nil)
  if valid_553649911 != nil:
    section.add "owner", valid_553649911
  var valid_553649912 = path.getOrDefault("repo")
  valid_553649912 = validateParameter(valid_553649912, JString, required = true,
                                      default = nil)
  if valid_553649912 != nil:
    section.add "repo", valid_553649912
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649913 = header.getOrDefault("Accept")
  valid_553649913 = validateParameter(valid_553649913, JString,
                                      required = false, default = nil)
  if valid_553649913 != nil:
    section.add "Accept", valid_553649913
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649914: Call_GetReposOwnerRepoHooks_553649908;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get list of hooks.
  ## 
  let valid = call_553649914.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649914.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649914.makeUrl(scheme.get, call_553649914.host, call_553649914.base,
                                   call_553649914.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649914, uri, valid, content)

proc call*(call_553649915: Call_GetReposOwnerRepoHooks_553649908; owner: string;
           repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoHooks
  ## Get list of hooks.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553649916 = newJObject()
  var header_553649917 = newJObject()
  add(path_553649916, "owner", newJString(owner))
  add(header_553649917, "Accept", newJString(Accept))
  add(path_553649916, "repo", newJString(repo))
  result = call_553649915.call(path_553649916, nil, header_553649917, nil, nil)

var getReposOwnerRepoHooks* = Call_GetReposOwnerRepoHooks_553649908(
    name: "getReposOwnerRepoHooks", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks",
    validator: validate_GetReposOwnerRepoHooks_553649909, base: "/",
    makeUrl: url_GetReposOwnerRepoHooks_553649910, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoHooksHookId_553649930 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoHooksHookId_553649932(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/hooks/"),
                 (kind: VariableSegment, value: "hookId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoHooksHookId_553649931(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get single hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   hookId: JInt (required)
  ##         : Id of hook.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649933 = path.getOrDefault("owner")
  valid_553649933 = validateParameter(valid_553649933, JString, required = true,
                                      default = nil)
  if valid_553649933 != nil:
    section.add "owner", valid_553649933
  var valid_553649934 = path.getOrDefault("repo")
  valid_553649934 = validateParameter(valid_553649934, JString, required = true,
                                      default = nil)
  if valid_553649934 != nil:
    section.add "repo", valid_553649934
  var valid_553649935 = path.getOrDefault("hookId")
  valid_553649935 = validateParameter(valid_553649935, JInt, required = true,
                                      default = nil)
  if valid_553649935 != nil:
    section.add "hookId", valid_553649935
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649936 = header.getOrDefault("Accept")
  valid_553649936 = validateParameter(valid_553649936, JString,
                                      required = false, default = nil)
  if valid_553649936 != nil:
    section.add "Accept", valid_553649936
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649937: Call_GetReposOwnerRepoHooksHookId_553649930;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get single hook.
  ## 
  let valid = call_553649937.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649937.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649937.makeUrl(scheme.get, call_553649937.host, call_553649937.base,
                                   call_553649937.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649937, uri, valid, content)

proc call*(call_553649938: Call_GetReposOwnerRepoHooksHookId_553649930;
           owner: string; repo: string; hookId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoHooksHookId
  ## Get single hook.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   hookId: int (required)
  ##         : Id of hook.
  var path_553649939 = newJObject()
  var header_553649940 = newJObject()
  add(path_553649939, "owner", newJString(owner))
  add(header_553649940, "Accept", newJString(Accept))
  add(path_553649939, "repo", newJString(repo))
  add(path_553649939, "hookId", newJInt(hookId))
  result = call_553649938.call(path_553649939, nil, header_553649940, nil, nil)

var getReposOwnerRepoHooksHookId* = Call_GetReposOwnerRepoHooksHookId_553649930(
    name: "getReposOwnerRepoHooksHookId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}",
    validator: validate_GetReposOwnerRepoHooksHookId_553649931, base: "/",
    makeUrl: url_GetReposOwnerRepoHooksHookId_553649932, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoHooksHookId_553649952 = ref object of OpenApiRestCall_553648476
proc url_PatchReposOwnerRepoHooksHookId_553649954(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/hooks/"),
                 (kind: VariableSegment, value: "hookId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoHooksHookId_553649953(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Edit a hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   hookId: JInt (required)
  ##         : Id of hook.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649955 = path.getOrDefault("owner")
  valid_553649955 = validateParameter(valid_553649955, JString, required = true,
                                      default = nil)
  if valid_553649955 != nil:
    section.add "owner", valid_553649955
  var valid_553649956 = path.getOrDefault("repo")
  valid_553649956 = validateParameter(valid_553649956, JString, required = true,
                                      default = nil)
  if valid_553649956 != nil:
    section.add "repo", valid_553649956
  var valid_553649957 = path.getOrDefault("hookId")
  valid_553649957 = validateParameter(valid_553649957, JInt, required = true,
                                      default = nil)
  if valid_553649957 != nil:
    section.add "hookId", valid_553649957
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649958 = header.getOrDefault("Accept")
  valid_553649958 = validateParameter(valid_553649958, JString,
                                      required = false, default = nil)
  if valid_553649958 != nil:
    section.add "Accept", valid_553649958
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553649960: Call_PatchReposOwnerRepoHooksHookId_553649952;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Edit a hook.
  ## 
  let valid = call_553649960.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649960.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649960.makeUrl(scheme.get, call_553649960.host, call_553649960.base,
                                   call_553649960.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649960, uri, valid, content)

proc call*(call_553649961: Call_PatchReposOwnerRepoHooksHookId_553649952;
           owner: string; body: JsonNode; repo: string; hookId: int;
           Accept: string = ""): Recallable =
  ## patchReposOwnerRepoHooksHookId
  ## Edit a hook.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   hookId: int (required)
  ##         : Id of hook.
  var path_553649962 = newJObject()
  var header_553649963 = newJObject()
  var body_553649964 = newJObject()
  add(path_553649962, "owner", newJString(owner))
  add(header_553649963, "Accept", newJString(Accept))
  if body != nil:
    body_553649964 = body
  add(path_553649962, "repo", newJString(repo))
  add(path_553649962, "hookId", newJInt(hookId))
  result = call_553649961.call(path_553649962, nil, header_553649963, nil, body_553649964)

var patchReposOwnerRepoHooksHookId* = Call_PatchReposOwnerRepoHooksHookId_553649952(
    name: "patchReposOwnerRepoHooksHookId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}",
    validator: validate_PatchReposOwnerRepoHooksHookId_553649953, base: "/",
    makeUrl: url_PatchReposOwnerRepoHooksHookId_553649954,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoHooksHookId_553649941 = ref object of OpenApiRestCall_553648476
proc url_DeleteReposOwnerRepoHooksHookId_553649943(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/hooks/"),
                 (kind: VariableSegment, value: "hookId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoHooksHookId_553649942(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Delete a hook.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   hookId: JInt (required)
  ##         : Id of hook.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649944 = path.getOrDefault("owner")
  valid_553649944 = validateParameter(valid_553649944, JString, required = true,
                                      default = nil)
  if valid_553649944 != nil:
    section.add "owner", valid_553649944
  var valid_553649945 = path.getOrDefault("repo")
  valid_553649945 = validateParameter(valid_553649945, JString, required = true,
                                      default = nil)
  if valid_553649945 != nil:
    section.add "repo", valid_553649945
  var valid_553649946 = path.getOrDefault("hookId")
  valid_553649946 = validateParameter(valid_553649946, JInt, required = true,
                                      default = nil)
  if valid_553649946 != nil:
    section.add "hookId", valid_553649946
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649947 = header.getOrDefault("Accept")
  valid_553649947 = validateParameter(valid_553649947, JString,
                                      required = false, default = nil)
  if valid_553649947 != nil:
    section.add "Accept", valid_553649947
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649948: Call_DeleteReposOwnerRepoHooksHookId_553649941;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Delete a hook.
  ## 
  let valid = call_553649948.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649948.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649948.makeUrl(scheme.get, call_553649948.host, call_553649948.base,
                                   call_553649948.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649948, uri, valid, content)

proc call*(call_553649949: Call_DeleteReposOwnerRepoHooksHookId_553649941;
           owner: string; repo: string; hookId: int; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoHooksHookId
  ## Delete a hook.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   hookId: int (required)
  ##         : Id of hook.
  var path_553649950 = newJObject()
  var header_553649951 = newJObject()
  add(path_553649950, "owner", newJString(owner))
  add(header_553649951, "Accept", newJString(Accept))
  add(path_553649950, "repo", newJString(repo))
  add(path_553649950, "hookId", newJInt(hookId))
  result = call_553649949.call(path_553649950, nil, header_553649951, nil, nil)

var deleteReposOwnerRepoHooksHookId* = Call_DeleteReposOwnerRepoHooksHookId_553649941(
    name: "deleteReposOwnerRepoHooksHookId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}",
    validator: validate_DeleteReposOwnerRepoHooksHookId_553649942, base: "/",
    makeUrl: url_DeleteReposOwnerRepoHooksHookId_553649943,
    schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoHooksHookIdTests_553649965 = ref object of OpenApiRestCall_553648476
proc url_PostReposOwnerRepoHooksHookIdTests_553649967(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "hookId" in path, "`hookId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/hooks/"),
                 (kind: VariableSegment, value: "hookId"),
                 (kind: ConstantSegment, value: "/tests")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoHooksHookIdTests_553649966(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Test a push hook.
  ## This will trigger the hook with the latest push to the current repository
  ## if the hook is subscribed to push events. If the hook is not subscribed
  ## to push events, the server will respond with 204 but no test POST will
  ## be generated.
  ## Note: Previously /repos/:owner/:repo/hooks/:id/tes
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   hookId: JInt (required)
  ##         : Id of hook.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649968 = path.getOrDefault("owner")
  valid_553649968 = validateParameter(valid_553649968, JString, required = true,
                                      default = nil)
  if valid_553649968 != nil:
    section.add "owner", valid_553649968
  var valid_553649969 = path.getOrDefault("repo")
  valid_553649969 = validateParameter(valid_553649969, JString, required = true,
                                      default = nil)
  if valid_553649969 != nil:
    section.add "repo", valid_553649969
  var valid_553649970 = path.getOrDefault("hookId")
  valid_553649970 = validateParameter(valid_553649970, JInt, required = true,
                                      default = nil)
  if valid_553649970 != nil:
    section.add "hookId", valid_553649970
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649971 = header.getOrDefault("Accept")
  valid_553649971 = validateParameter(valid_553649971, JString,
                                      required = false, default = nil)
  if valid_553649971 != nil:
    section.add "Accept", valid_553649971
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649972: Call_PostReposOwnerRepoHooksHookIdTests_553649965;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Test a push hook.
  ## This will trigger the hook with the latest push to the current repository
  ## if the hook is subscribed to push events. If the hook is not subscribed
  ## to push events, the server will respond with 204 but no test POST will
  ## be generated.
  ## Note: Previously /repos/:owner/:repo/hooks/:id/tes
  ## 
  ## 
  let valid = call_553649972.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649972.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649972.makeUrl(scheme.get, call_553649972.host, call_553649972.base,
                                   call_553649972.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649972, uri, valid, content)

proc call*(call_553649973: Call_PostReposOwnerRepoHooksHookIdTests_553649965;
           owner: string; repo: string; hookId: int; Accept: string = ""): Recallable =
  ## postReposOwnerRepoHooksHookIdTests
  ## Test a push hook.
  ## This will trigger the hook with the latest push to the current repository
  ## if the hook is subscribed to push events. If the hook is not subscribed
  ## to push events, the server will respond with 204 but no test POST will
  ## be generated.
  ## Note: Previously /repos/:owner/:repo/hooks/:id/tes
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   hookId: int (required)
  ##         : Id of hook.
  var path_553649974 = newJObject()
  var header_553649975 = newJObject()
  add(path_553649974, "owner", newJString(owner))
  add(header_553649975, "Accept", newJString(Accept))
  add(path_553649974, "repo", newJString(repo))
  add(path_553649974, "hookId", newJInt(hookId))
  result = call_553649973.call(path_553649974, nil, header_553649975, nil, nil)

var postReposOwnerRepoHooksHookIdTests* = Call_PostReposOwnerRepoHooksHookIdTests_553649965(
    name: "postReposOwnerRepoHooksHookIdTests", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/hooks/{hookId}/tests",
    validator: validate_PostReposOwnerRepoHooksHookIdTests_553649966, base: "/",
    makeUrl: url_PostReposOwnerRepoHooksHookIdTests_553649967,
    schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoIssues_553649993 = ref object of OpenApiRestCall_553648476
proc url_PostReposOwnerRepoIssues_553649995(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/issues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoIssues_553649994(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Create an issue.
  ## Any user with pull access to a repository can create an issue.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649996 = path.getOrDefault("owner")
  valid_553649996 = validateParameter(valid_553649996, JString, required = true,
                                      default = nil)
  if valid_553649996 != nil:
    section.add "owner", valid_553649996
  var valid_553649997 = path.getOrDefault("repo")
  valid_553649997 = validateParameter(valid_553649997, JString, required = true,
                                      default = nil)
  if valid_553649997 != nil:
    section.add "repo", valid_553649997
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649998 = header.getOrDefault("Accept")
  valid_553649998 = validateParameter(valid_553649998, JString,
                                      required = false, default = nil)
  if valid_553649998 != nil:
    section.add "Accept", valid_553649998
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553650000: Call_PostReposOwnerRepoIssues_553649993;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Create an issue.
  ## Any user with pull access to a repository can create an issue.
  ## 
  ## 
  let valid = call_553650000.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650000.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650000.makeUrl(scheme.get, call_553650000.host, call_553650000.base,
                                   call_553650000.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650000, uri, valid, content)

proc call*(call_553650001: Call_PostReposOwnerRepoIssues_553649993;
           owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoIssues
  ## Create an issue.
  ## Any user with pull access to a repository can create an issue.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650002 = newJObject()
  var header_553650003 = newJObject()
  var body_553650004 = newJObject()
  add(path_553650002, "owner", newJString(owner))
  add(header_553650003, "Accept", newJString(Accept))
  if body != nil:
    body_553650004 = body
  add(path_553650002, "repo", newJString(repo))
  result = call_553650001.call(path_553650002, nil, header_553650003, nil, body_553650004)

var postReposOwnerRepoIssues* = Call_PostReposOwnerRepoIssues_553649993(
    name: "postReposOwnerRepoIssues", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues",
    validator: validate_PostReposOwnerRepoIssues_553649994, base: "/",
    makeUrl: url_PostReposOwnerRepoIssues_553649995, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssues_553649976 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoIssues_553649978(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/issues")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssues_553649977(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List issues for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553649979 = path.getOrDefault("owner")
  valid_553649979 = validateParameter(valid_553649979, JString, required = true,
                                      default = nil)
  if valid_553649979 != nil:
    section.add "owner", valid_553649979
  var valid_553649980 = path.getOrDefault("repo")
  valid_553649980 = validateParameter(valid_553649980, JString, required = true,
                                      default = nil)
  if valid_553649980 != nil:
    section.add "repo", valid_553649980
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString (required)
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: JString (required)
  ##   direction: JString (required)
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_553649981 = query.getOrDefault("state")
  valid_553649981 = validateParameter(valid_553649981, JString, required = true,
                                      default = newJString("open"))
  if valid_553649981 != nil:
    section.add "state", valid_553649981
  var valid_553649982 = query.getOrDefault("labels")
  valid_553649982 = validateParameter(valid_553649982, JString, required = true,
                                      default = nil)
  if valid_553649982 != nil:
    section.add "labels", valid_553649982
  var valid_553649983 = query.getOrDefault("sort")
  valid_553649983 = validateParameter(valid_553649983, JString, required = true,
                                      default = newJString("created"))
  if valid_553649983 != nil:
    section.add "sort", valid_553649983
  var valid_553649984 = query.getOrDefault("direction")
  valid_553649984 = validateParameter(valid_553649984, JString, required = true,
                                      default = newJString("desc"))
  if valid_553649984 != nil:
    section.add "direction", valid_553649984
  var valid_553649985 = query.getOrDefault("filter")
  valid_553649985 = validateParameter(valid_553649985, JString, required = true,
                                      default = newJString("all"))
  if valid_553649985 != nil:
    section.add "filter", valid_553649985
  var valid_553649986 = query.getOrDefault("since")
  valid_553649986 = validateParameter(valid_553649986, JString,
                                      required = false, default = nil)
  if valid_553649986 != nil:
    section.add "since", valid_553649986
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553649987 = header.getOrDefault("Accept")
  valid_553649987 = validateParameter(valid_553649987, JString,
                                      required = false, default = nil)
  if valid_553649987 != nil:
    section.add "Accept", valid_553649987
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553649988: Call_GetReposOwnerRepoIssues_553649976;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List issues for a repository.
  ## 
  let valid = call_553649988.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553649988.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553649988.makeUrl(scheme.get, call_553649988.host, call_553649988.base,
                                   call_553649988.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553649988, uri, valid, content)

proc call*(call_553649989: Call_GetReposOwnerRepoIssues_553649976;
           owner: string; repo: string; labels: string; state: string = "open";
           Accept: string = ""; sort: string = "created";
           direction: string = "desc"; filter: string = "all";
           since: string = ""): Recallable =
  ## getReposOwnerRepoIssues
  ## List issues for a repository.
  ##   state: string (required)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: string (required)
  ##   direction: string (required)
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  var path_553649990 = newJObject()
  var query_553649991 = newJObject()
  var header_553649992 = newJObject()
  add(query_553649991, "state", newJString(state))
  add(path_553649990, "owner", newJString(owner))
  add(header_553649992, "Accept", newJString(Accept))
  add(path_553649990, "repo", newJString(repo))
  add(query_553649991, "labels", newJString(labels))
  add(query_553649991, "sort", newJString(sort))
  add(query_553649991, "direction", newJString(direction))
  add(query_553649991, "filter", newJString(filter))
  add(query_553649991, "since", newJString(since))
  result = call_553649989.call(path_553649990, query_553649991, header_553649992,
                               nil, nil)

var getReposOwnerRepoIssues* = Call_GetReposOwnerRepoIssues_553649976(
    name: "getReposOwnerRepoIssues", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues",
    validator: validate_GetReposOwnerRepoIssues_553649977, base: "/",
    makeUrl: url_GetReposOwnerRepoIssues_553649978, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesComments_553650005 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoIssuesComments_553650007(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/issues/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesComments_553650006(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## List comments in a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650008 = path.getOrDefault("owner")
  valid_553650008 = validateParameter(valid_553650008, JString, required = true,
                                      default = nil)
  if valid_553650008 != nil:
    section.add "owner", valid_553650008
  var valid_553650009 = path.getOrDefault("repo")
  valid_553650009 = validateParameter(valid_553650009, JString, required = true,
                                      default = nil)
  if valid_553650009 != nil:
    section.add "repo", valid_553650009
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_553650010 = query.getOrDefault("sort")
  valid_553650010 = validateParameter(valid_553650010, JString,
                                      required = false,
                                      default = newJString("created"))
  if valid_553650010 != nil:
    section.add "sort", valid_553650010
  var valid_553650011 = query.getOrDefault("direction")
  valid_553650011 = validateParameter(valid_553650011, JString,
                                      required = false, default = nil)
  if valid_553650011 != nil:
    section.add "direction", valid_553650011
  var valid_553650012 = query.getOrDefault("since")
  valid_553650012 = validateParameter(valid_553650012, JString,
                                      required = false, default = nil)
  if valid_553650012 != nil:
    section.add "since", valid_553650012
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650013 = header.getOrDefault("Accept")
  valid_553650013 = validateParameter(valid_553650013, JString,
                                      required = false, default = nil)
  if valid_553650013 != nil:
    section.add "Accept", valid_553650013
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650014: Call_GetReposOwnerRepoIssuesComments_553650005;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List comments in a repository.
  ## 
  let valid = call_553650014.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650014.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650014.makeUrl(scheme.get, call_553650014.host, call_553650014.base,
                                   call_553650014.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650014, uri, valid, content)

proc call*(call_553650015: Call_GetReposOwnerRepoIssuesComments_553650005;
           owner: string; repo: string; Accept: string = "";
           sort: string = "created"; direction: string = ""; since: string = ""): Recallable =
  ## getReposOwnerRepoIssuesComments
  ## List comments in a repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   sort: string
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var path_553650016 = newJObject()
  var query_553650017 = newJObject()
  var header_553650018 = newJObject()
  add(path_553650016, "owner", newJString(owner))
  add(header_553650018, "Accept", newJString(Accept))
  add(path_553650016, "repo", newJString(repo))
  add(query_553650017, "sort", newJString(sort))
  add(query_553650017, "direction", newJString(direction))
  add(query_553650017, "since", newJString(since))
  result = call_553650015.call(path_553650016, query_553650017, header_553650018,
                               nil, nil)

var getReposOwnerRepoIssuesComments* = Call_GetReposOwnerRepoIssuesComments_553650005(
    name: "getReposOwnerRepoIssuesComments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/comments",
    validator: validate_GetReposOwnerRepoIssuesComments_553650006, base: "/",
    makeUrl: url_GetReposOwnerRepoIssuesComments_553650007,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesCommentsCommentId_553650019 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoIssuesCommentsCommentId_553650021(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/issues/comments/"),
                 (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesCommentsCommentId_553650020(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get a single comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : ID of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650022 = path.getOrDefault("owner")
  valid_553650022 = validateParameter(valid_553650022, JString, required = true,
                                      default = nil)
  if valid_553650022 != nil:
    section.add "owner", valid_553650022
  var valid_553650023 = path.getOrDefault("repo")
  valid_553650023 = validateParameter(valid_553650023, JString, required = true,
                                      default = nil)
  if valid_553650023 != nil:
    section.add "repo", valid_553650023
  var valid_553650024 = path.getOrDefault("commentId")
  valid_553650024 = validateParameter(valid_553650024, JInt, required = true,
                                      default = nil)
  if valid_553650024 != nil:
    section.add "commentId", valid_553650024
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650025 = header.getOrDefault("Accept")
  valid_553650025 = validateParameter(valid_553650025, JString,
                                      required = false, default = nil)
  if valid_553650025 != nil:
    section.add "Accept", valid_553650025
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650026: Call_GetReposOwnerRepoIssuesCommentsCommentId_553650019;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get a single comment.
  ## 
  let valid = call_553650026.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650026.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650026.makeUrl(scheme.get, call_553650026.host, call_553650026.base,
                                   call_553650026.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650026, uri, valid, content)

proc call*(call_553650027: Call_GetReposOwnerRepoIssuesCommentsCommentId_553650019;
           owner: string; repo: string; commentId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesCommentsCommentId
  ## Get a single comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : ID of comment.
  var path_553650028 = newJObject()
  var header_553650029 = newJObject()
  add(path_553650028, "owner", newJString(owner))
  add(header_553650029, "Accept", newJString(Accept))
  add(path_553650028, "repo", newJString(repo))
  add(path_553650028, "commentId", newJInt(commentId))
  result = call_553650027.call(path_553650028, nil, header_553650029, nil, nil)

var getReposOwnerRepoIssuesCommentsCommentId* = Call_GetReposOwnerRepoIssuesCommentsCommentId_553650019(
    name: "getReposOwnerRepoIssuesCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/comments/{commentId}",
    validator: validate_GetReposOwnerRepoIssuesCommentsCommentId_553650020,
    base: "/", makeUrl: url_GetReposOwnerRepoIssuesCommentsCommentId_553650021,
    schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoIssuesCommentsCommentId_553650041 = ref object of OpenApiRestCall_553648476
proc url_PatchReposOwnerRepoIssuesCommentsCommentId_553650043(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/issues/comments/"),
                 (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoIssuesCommentsCommentId_553650042(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode; content: string = ""): JsonNode {.nosinks.} =
  ## Edit a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : ID of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650044 = path.getOrDefault("owner")
  valid_553650044 = validateParameter(valid_553650044, JString, required = true,
                                      default = nil)
  if valid_553650044 != nil:
    section.add "owner", valid_553650044
  var valid_553650045 = path.getOrDefault("repo")
  valid_553650045 = validateParameter(valid_553650045, JString, required = true,
                                      default = nil)
  if valid_553650045 != nil:
    section.add "repo", valid_553650045
  var valid_553650046 = path.getOrDefault("commentId")
  valid_553650046 = validateParameter(valid_553650046, JInt, required = true,
                                      default = nil)
  if valid_553650046 != nil:
    section.add "commentId", valid_553650046
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650047 = header.getOrDefault("Accept")
  valid_553650047 = validateParameter(valid_553650047, JString,
                                      required = false, default = nil)
  if valid_553650047 != nil:
    section.add "Accept", valid_553650047
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553650049: Call_PatchReposOwnerRepoIssuesCommentsCommentId_553650041;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Edit a comment.
  ## 
  let valid = call_553650049.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650049.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650049.makeUrl(scheme.get, call_553650049.host, call_553650049.base,
                                   call_553650049.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650049, uri, valid, content)

proc call*(call_553650050: Call_PatchReposOwnerRepoIssuesCommentsCommentId_553650041;
           owner: string; body: JsonNode; repo: string; commentId: int;
           Accept: string = ""): Recallable =
  ## patchReposOwnerRepoIssuesCommentsCommentId
  ## Edit a comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : ID of comment.
  var path_553650051 = newJObject()
  var header_553650052 = newJObject()
  var body_553650053 = newJObject()
  add(path_553650051, "owner", newJString(owner))
  add(header_553650052, "Accept", newJString(Accept))
  if body != nil:
    body_553650053 = body
  add(path_553650051, "repo", newJString(repo))
  add(path_553650051, "commentId", newJInt(commentId))
  result = call_553650050.call(path_553650051, nil, header_553650052, nil, body_553650053)

var patchReposOwnerRepoIssuesCommentsCommentId* = Call_PatchReposOwnerRepoIssuesCommentsCommentId_553650041(
    name: "patchReposOwnerRepoIssuesCommentsCommentId",
    meth: HttpMethod.HttpPatch, host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/comments/{commentId}",
    validator: validate_PatchReposOwnerRepoIssuesCommentsCommentId_553650042,
    base: "/", makeUrl: url_PatchReposOwnerRepoIssuesCommentsCommentId_553650043,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoIssuesCommentsCommentId_553650030 = ref object of OpenApiRestCall_553648476
proc url_DeleteReposOwnerRepoIssuesCommentsCommentId_553650032(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/issues/comments/"),
                 (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoIssuesCommentsCommentId_553650031(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode; content: string = ""): JsonNode {.nosinks.} =
  ## Delete a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : ID of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650033 = path.getOrDefault("owner")
  valid_553650033 = validateParameter(valid_553650033, JString, required = true,
                                      default = nil)
  if valid_553650033 != nil:
    section.add "owner", valid_553650033
  var valid_553650034 = path.getOrDefault("repo")
  valid_553650034 = validateParameter(valid_553650034, JString, required = true,
                                      default = nil)
  if valid_553650034 != nil:
    section.add "repo", valid_553650034
  var valid_553650035 = path.getOrDefault("commentId")
  valid_553650035 = validateParameter(valid_553650035, JInt, required = true,
                                      default = nil)
  if valid_553650035 != nil:
    section.add "commentId", valid_553650035
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650036 = header.getOrDefault("Accept")
  valid_553650036 = validateParameter(valid_553650036, JString,
                                      required = false, default = nil)
  if valid_553650036 != nil:
    section.add "Accept", valid_553650036
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650037: Call_DeleteReposOwnerRepoIssuesCommentsCommentId_553650030;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Delete a comment.
  ## 
  let valid = call_553650037.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650037.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650037.makeUrl(scheme.get, call_553650037.host, call_553650037.base,
                                   call_553650037.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650037, uri, valid, content)

proc call*(call_553650038: Call_DeleteReposOwnerRepoIssuesCommentsCommentId_553650030;
           owner: string; repo: string; commentId: int; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoIssuesCommentsCommentId
  ## Delete a comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : ID of comment.
  var path_553650039 = newJObject()
  var header_553650040 = newJObject()
  add(path_553650039, "owner", newJString(owner))
  add(header_553650040, "Accept", newJString(Accept))
  add(path_553650039, "repo", newJString(repo))
  add(path_553650039, "commentId", newJInt(commentId))
  result = call_553650038.call(path_553650039, nil, header_553650040, nil, nil)

var deleteReposOwnerRepoIssuesCommentsCommentId* = Call_DeleteReposOwnerRepoIssuesCommentsCommentId_553650030(
    name: "deleteReposOwnerRepoIssuesCommentsCommentId",
    meth: HttpMethod.HttpDelete, host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/comments/{commentId}",
    validator: validate_DeleteReposOwnerRepoIssuesCommentsCommentId_553650031,
    base: "/", makeUrl: url_DeleteReposOwnerRepoIssuesCommentsCommentId_553650032,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesEvents_553650054 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoIssuesEvents_553650056(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/issues/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesEvents_553650055(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## List issue events for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650057 = path.getOrDefault("owner")
  valid_553650057 = validateParameter(valid_553650057, JString, required = true,
                                      default = nil)
  if valid_553650057 != nil:
    section.add "owner", valid_553650057
  var valid_553650058 = path.getOrDefault("repo")
  valid_553650058 = validateParameter(valid_553650058, JString, required = true,
                                      default = nil)
  if valid_553650058 != nil:
    section.add "repo", valid_553650058
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650059 = header.getOrDefault("Accept")
  valid_553650059 = validateParameter(valid_553650059, JString,
                                      required = false, default = nil)
  if valid_553650059 != nil:
    section.add "Accept", valid_553650059
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650060: Call_GetReposOwnerRepoIssuesEvents_553650054;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List issue events for a repository.
  ## 
  let valid = call_553650060.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650060.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650060.makeUrl(scheme.get, call_553650060.host, call_553650060.base,
                                   call_553650060.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650060, uri, valid, content)

proc call*(call_553650061: Call_GetReposOwnerRepoIssuesEvents_553650054;
           owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesEvents
  ## List issue events for a repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650062 = newJObject()
  var header_553650063 = newJObject()
  add(path_553650062, "owner", newJString(owner))
  add(header_553650063, "Accept", newJString(Accept))
  add(path_553650062, "repo", newJString(repo))
  result = call_553650061.call(path_553650062, nil, header_553650063, nil, nil)

var getReposOwnerRepoIssuesEvents* = Call_GetReposOwnerRepoIssuesEvents_553650054(
    name: "getReposOwnerRepoIssuesEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/events",
    validator: validate_GetReposOwnerRepoIssuesEvents_553650055, base: "/",
    makeUrl: url_GetReposOwnerRepoIssuesEvents_553650056,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesEventsEventId_553650064 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoIssuesEventsEventId_553650066(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "eventId" in path, "`eventId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/issues/events/"),
                 (kind: VariableSegment, value: "eventId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesEventsEventId_553650065(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get a single event.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   eventId: JInt (required)
  ##          : Id of the event.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650067 = path.getOrDefault("owner")
  valid_553650067 = validateParameter(valid_553650067, JString, required = true,
                                      default = nil)
  if valid_553650067 != nil:
    section.add "owner", valid_553650067
  var valid_553650068 = path.getOrDefault("repo")
  valid_553650068 = validateParameter(valid_553650068, JString, required = true,
                                      default = nil)
  if valid_553650068 != nil:
    section.add "repo", valid_553650068
  var valid_553650069 = path.getOrDefault("eventId")
  valid_553650069 = validateParameter(valid_553650069, JInt, required = true,
                                      default = nil)
  if valid_553650069 != nil:
    section.add "eventId", valid_553650069
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650070 = header.getOrDefault("Accept")
  valid_553650070 = validateParameter(valid_553650070, JString,
                                      required = false, default = nil)
  if valid_553650070 != nil:
    section.add "Accept", valid_553650070
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650071: Call_GetReposOwnerRepoIssuesEventsEventId_553650064;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get a single event.
  ## 
  let valid = call_553650071.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650071.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650071.makeUrl(scheme.get, call_553650071.host, call_553650071.base,
                                   call_553650071.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650071, uri, valid, content)

proc call*(call_553650072: Call_GetReposOwnerRepoIssuesEventsEventId_553650064;
           owner: string; repo: string; eventId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesEventsEventId
  ## Get a single event.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   eventId: int (required)
  ##          : Id of the event.
  var path_553650073 = newJObject()
  var header_553650074 = newJObject()
  add(path_553650073, "owner", newJString(owner))
  add(header_553650074, "Accept", newJString(Accept))
  add(path_553650073, "repo", newJString(repo))
  add(path_553650073, "eventId", newJInt(eventId))
  result = call_553650072.call(path_553650073, nil, header_553650074, nil, nil)

var getReposOwnerRepoIssuesEventsEventId* = Call_GetReposOwnerRepoIssuesEventsEventId_553650064(
    name: "getReposOwnerRepoIssuesEventsEventId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/events/{eventId}",
    validator: validate_GetReposOwnerRepoIssuesEventsEventId_553650065,
    base: "/", makeUrl: url_GetReposOwnerRepoIssuesEventsEventId_553650066,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumber_553650075 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoIssuesNumber_553650077(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/issues/"),
                 (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumber_553650076(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get a single issue
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650078 = path.getOrDefault("owner")
  valid_553650078 = validateParameter(valid_553650078, JString, required = true,
                                      default = nil)
  if valid_553650078 != nil:
    section.add "owner", valid_553650078
  var valid_553650079 = path.getOrDefault("number")
  valid_553650079 = validateParameter(valid_553650079, JInt, required = true,
                                      default = nil)
  if valid_553650079 != nil:
    section.add "number", valid_553650079
  var valid_553650080 = path.getOrDefault("repo")
  valid_553650080 = validateParameter(valid_553650080, JString, required = true,
                                      default = nil)
  if valid_553650080 != nil:
    section.add "repo", valid_553650080
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650081 = header.getOrDefault("Accept")
  valid_553650081 = validateParameter(valid_553650081, JString,
                                      required = false, default = nil)
  if valid_553650081 != nil:
    section.add "Accept", valid_553650081
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650082: Call_GetReposOwnerRepoIssuesNumber_553650075;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get a single issue
  ## 
  let valid = call_553650082.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650082.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650082.makeUrl(scheme.get, call_553650082.host, call_553650082.base,
                                   call_553650082.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650082, uri, valid, content)

proc call*(call_553650083: Call_GetReposOwnerRepoIssuesNumber_553650075;
           owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumber
  ## Get a single issue
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650084 = newJObject()
  var header_553650085 = newJObject()
  add(path_553650084, "owner", newJString(owner))
  add(path_553650084, "number", newJInt(number))
  add(header_553650085, "Accept", newJString(Accept))
  add(path_553650084, "repo", newJString(repo))
  result = call_553650083.call(path_553650084, nil, header_553650085, nil, nil)

var getReposOwnerRepoIssuesNumber* = Call_GetReposOwnerRepoIssuesNumber_553650075(
    name: "getReposOwnerRepoIssuesNumber", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}",
    validator: validate_GetReposOwnerRepoIssuesNumber_553650076, base: "/",
    makeUrl: url_GetReposOwnerRepoIssuesNumber_553650077,
    schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoIssuesNumber_553650086 = ref object of OpenApiRestCall_553648476
proc url_PatchReposOwnerRepoIssuesNumber_553650088(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/issues/"),
                 (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoIssuesNumber_553650087(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Edit an issue.
  ## Issue owners and users with push access can edit an issue.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650089 = path.getOrDefault("owner")
  valid_553650089 = validateParameter(valid_553650089, JString, required = true,
                                      default = nil)
  if valid_553650089 != nil:
    section.add "owner", valid_553650089
  var valid_553650090 = path.getOrDefault("number")
  valid_553650090 = validateParameter(valid_553650090, JInt, required = true,
                                      default = nil)
  if valid_553650090 != nil:
    section.add "number", valid_553650090
  var valid_553650091 = path.getOrDefault("repo")
  valid_553650091 = validateParameter(valid_553650091, JString, required = true,
                                      default = nil)
  if valid_553650091 != nil:
    section.add "repo", valid_553650091
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650092 = header.getOrDefault("Accept")
  valid_553650092 = validateParameter(valid_553650092, JString,
                                      required = false, default = nil)
  if valid_553650092 != nil:
    section.add "Accept", valid_553650092
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553650094: Call_PatchReposOwnerRepoIssuesNumber_553650086;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Edit an issue.
  ## Issue owners and users with push access can edit an issue.
  ## 
  ## 
  let valid = call_553650094.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650094.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650094.makeUrl(scheme.get, call_553650094.host, call_553650094.base,
                                   call_553650094.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650094, uri, valid, content)

proc call*(call_553650095: Call_PatchReposOwnerRepoIssuesNumber_553650086;
           owner: string; number: int; body: JsonNode; repo: string;
           Accept: string = ""): Recallable =
  ## patchReposOwnerRepoIssuesNumber
  ## Edit an issue.
  ## Issue owners and users with push access can edit an issue.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650096 = newJObject()
  var header_553650097 = newJObject()
  var body_553650098 = newJObject()
  add(path_553650096, "owner", newJString(owner))
  add(path_553650096, "number", newJInt(number))
  add(header_553650097, "Accept", newJString(Accept))
  if body != nil:
    body_553650098 = body
  add(path_553650096, "repo", newJString(repo))
  result = call_553650095.call(path_553650096, nil, header_553650097, nil, body_553650098)

var patchReposOwnerRepoIssuesNumber* = Call_PatchReposOwnerRepoIssuesNumber_553650086(
    name: "patchReposOwnerRepoIssuesNumber", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/issues/{number}",
    validator: validate_PatchReposOwnerRepoIssuesNumber_553650087, base: "/",
    makeUrl: url_PatchReposOwnerRepoIssuesNumber_553650088,
    schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoIssuesNumberComments_553650110 = ref object of OpenApiRestCall_553648476
proc url_PostReposOwnerRepoIssuesNumberComments_553650112(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/issues/"),
                 (kind: VariableSegment, value: "number"),
                 (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoIssuesNumberComments_553650111(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Create a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650113 = path.getOrDefault("owner")
  valid_553650113 = validateParameter(valid_553650113, JString, required = true,
                                      default = nil)
  if valid_553650113 != nil:
    section.add "owner", valid_553650113
  var valid_553650114 = path.getOrDefault("number")
  valid_553650114 = validateParameter(valid_553650114, JInt, required = true,
                                      default = nil)
  if valid_553650114 != nil:
    section.add "number", valid_553650114
  var valid_553650115 = path.getOrDefault("repo")
  valid_553650115 = validateParameter(valid_553650115, JString, required = true,
                                      default = nil)
  if valid_553650115 != nil:
    section.add "repo", valid_553650115
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650116 = header.getOrDefault("Accept")
  valid_553650116 = validateParameter(valid_553650116, JString,
                                      required = false, default = nil)
  if valid_553650116 != nil:
    section.add "Accept", valid_553650116
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553650118: Call_PostReposOwnerRepoIssuesNumberComments_553650110;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Create a comment.
  ## 
  let valid = call_553650118.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650118.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650118.makeUrl(scheme.get, call_553650118.host, call_553650118.base,
                                   call_553650118.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650118, uri, valid, content)

proc call*(call_553650119: Call_PostReposOwnerRepoIssuesNumberComments_553650110;
           owner: string; number: int; body: JsonNode; repo: string;
           Accept: string = ""): Recallable =
  ## postReposOwnerRepoIssuesNumberComments
  ## Create a comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650120 = newJObject()
  var header_553650121 = newJObject()
  var body_553650122 = newJObject()
  add(path_553650120, "owner", newJString(owner))
  add(path_553650120, "number", newJInt(number))
  add(header_553650121, "Accept", newJString(Accept))
  if body != nil:
    body_553650122 = body
  add(path_553650120, "repo", newJString(repo))
  result = call_553650119.call(path_553650120, nil, header_553650121, nil, body_553650122)

var postReposOwnerRepoIssuesNumberComments* = Call_PostReposOwnerRepoIssuesNumberComments_553650110(
    name: "postReposOwnerRepoIssuesNumberComments", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/{number}/comments",
    validator: validate_PostReposOwnerRepoIssuesNumberComments_553650111,
    base: "/", makeUrl: url_PostReposOwnerRepoIssuesNumberComments_553650112,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumberComments_553650099 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoIssuesNumberComments_553650101(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/issues/"),
                 (kind: VariableSegment, value: "number"),
                 (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumberComments_553650100(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## List comments on an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650102 = path.getOrDefault("owner")
  valid_553650102 = validateParameter(valid_553650102, JString, required = true,
                                      default = nil)
  if valid_553650102 != nil:
    section.add "owner", valid_553650102
  var valid_553650103 = path.getOrDefault("number")
  valid_553650103 = validateParameter(valid_553650103, JInt, required = true,
                                      default = nil)
  if valid_553650103 != nil:
    section.add "number", valid_553650103
  var valid_553650104 = path.getOrDefault("repo")
  valid_553650104 = validateParameter(valid_553650104, JString, required = true,
                                      default = nil)
  if valid_553650104 != nil:
    section.add "repo", valid_553650104
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650105 = header.getOrDefault("Accept")
  valid_553650105 = validateParameter(valid_553650105, JString,
                                      required = false, default = nil)
  if valid_553650105 != nil:
    section.add "Accept", valid_553650105
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650106: Call_GetReposOwnerRepoIssuesNumberComments_553650099;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List comments on an issue.
  ## 
  let valid = call_553650106.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650106.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650106.makeUrl(scheme.get, call_553650106.host, call_553650106.base,
                                   call_553650106.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650106, uri, valid, content)

proc call*(call_553650107: Call_GetReposOwnerRepoIssuesNumberComments_553650099;
           owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumberComments
  ## List comments on an issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650108 = newJObject()
  var header_553650109 = newJObject()
  add(path_553650108, "owner", newJString(owner))
  add(path_553650108, "number", newJInt(number))
  add(header_553650109, "Accept", newJString(Accept))
  add(path_553650108, "repo", newJString(repo))
  result = call_553650107.call(path_553650108, nil, header_553650109, nil, nil)

var getReposOwnerRepoIssuesNumberComments* = Call_GetReposOwnerRepoIssuesNumberComments_553650099(
    name: "getReposOwnerRepoIssuesNumberComments", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/{number}/comments",
    validator: validate_GetReposOwnerRepoIssuesNumberComments_553650100,
    base: "/", makeUrl: url_GetReposOwnerRepoIssuesNumberComments_553650101,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumberEvents_553650123 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoIssuesNumberEvents_553650125(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/issues/"),
                 (kind: VariableSegment, value: "number"),
                 (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumberEvents_553650124(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## List events for an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650126 = path.getOrDefault("owner")
  valid_553650126 = validateParameter(valid_553650126, JString, required = true,
                                      default = nil)
  if valid_553650126 != nil:
    section.add "owner", valid_553650126
  var valid_553650127 = path.getOrDefault("number")
  valid_553650127 = validateParameter(valid_553650127, JInt, required = true,
                                      default = nil)
  if valid_553650127 != nil:
    section.add "number", valid_553650127
  var valid_553650128 = path.getOrDefault("repo")
  valid_553650128 = validateParameter(valid_553650128, JString, required = true,
                                      default = nil)
  if valid_553650128 != nil:
    section.add "repo", valid_553650128
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650129 = header.getOrDefault("Accept")
  valid_553650129 = validateParameter(valid_553650129, JString,
                                      required = false, default = nil)
  if valid_553650129 != nil:
    section.add "Accept", valid_553650129
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650130: Call_GetReposOwnerRepoIssuesNumberEvents_553650123;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List events for an issue.
  ## 
  let valid = call_553650130.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650130.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650130.makeUrl(scheme.get, call_553650130.host, call_553650130.base,
                                   call_553650130.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650130, uri, valid, content)

proc call*(call_553650131: Call_GetReposOwnerRepoIssuesNumberEvents_553650123;
           owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumberEvents
  ## List events for an issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650132 = newJObject()
  var header_553650133 = newJObject()
  add(path_553650132, "owner", newJString(owner))
  add(path_553650132, "number", newJInt(number))
  add(header_553650133, "Accept", newJString(Accept))
  add(path_553650132, "repo", newJString(repo))
  result = call_553650131.call(path_553650132, nil, header_553650133, nil, nil)

var getReposOwnerRepoIssuesNumberEvents* = Call_GetReposOwnerRepoIssuesNumberEvents_553650123(
    name: "getReposOwnerRepoIssuesNumberEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/{number}/events",
    validator: validate_GetReposOwnerRepoIssuesNumberEvents_553650124,
    base: "/", makeUrl: url_GetReposOwnerRepoIssuesNumberEvents_553650125,
    schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoIssuesNumberLabels_553650145 = ref object of OpenApiRestCall_553648476
proc url_PutReposOwnerRepoIssuesNumberLabels_553650147(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/issues/"),
                 (kind: VariableSegment, value: "number"),
                 (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoIssuesNumberLabels_553650146(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Replace all labels for an issue.
  ## Sending an empty array ([]) will remove all Labels from the Issue.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650148 = path.getOrDefault("owner")
  valid_553650148 = validateParameter(valid_553650148, JString, required = true,
                                      default = nil)
  if valid_553650148 != nil:
    section.add "owner", valid_553650148
  var valid_553650149 = path.getOrDefault("number")
  valid_553650149 = validateParameter(valid_553650149, JInt, required = true,
                                      default = nil)
  if valid_553650149 != nil:
    section.add "number", valid_553650149
  var valid_553650150 = path.getOrDefault("repo")
  valid_553650150 = validateParameter(valid_553650150, JString, required = true,
                                      default = nil)
  if valid_553650150 != nil:
    section.add "repo", valid_553650150
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650151 = header.getOrDefault("Accept")
  valid_553650151 = validateParameter(valid_553650151, JString,
                                      required = false, default = nil)
  if valid_553650151 != nil:
    section.add "Accept", valid_553650151
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553650153: Call_PutReposOwnerRepoIssuesNumberLabels_553650145;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Replace all labels for an issue.
  ## Sending an empty array ([]) will remove all Labels from the Issue.
  ## 
  ## 
  let valid = call_553650153.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650153.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650153.makeUrl(scheme.get, call_553650153.host, call_553650153.base,
                                   call_553650153.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650153, uri, valid, content)

proc call*(call_553650154: Call_PutReposOwnerRepoIssuesNumberLabels_553650145;
           owner: string; number: int; body: JsonNode; repo: string;
           Accept: string = ""): Recallable =
  ## putReposOwnerRepoIssuesNumberLabels
  ## Replace all labels for an issue.
  ## Sending an empty array ([]) will remove all Labels from the Issue.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650155 = newJObject()
  var header_553650156 = newJObject()
  var body_553650157 = newJObject()
  add(path_553650155, "owner", newJString(owner))
  add(path_553650155, "number", newJInt(number))
  add(header_553650156, "Accept", newJString(Accept))
  if body != nil:
    body_553650157 = body
  add(path_553650155, "repo", newJString(repo))
  result = call_553650154.call(path_553650155, nil, header_553650156, nil, body_553650157)

var putReposOwnerRepoIssuesNumberLabels* = Call_PutReposOwnerRepoIssuesNumberLabels_553650145(
    name: "putReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpPut,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_PutReposOwnerRepoIssuesNumberLabels_553650146,
    base: "/", makeUrl: url_PutReposOwnerRepoIssuesNumberLabels_553650147,
    schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoIssuesNumberLabels_553650158 = ref object of OpenApiRestCall_553648476
proc url_PostReposOwnerRepoIssuesNumberLabels_553650160(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/issues/"),
                 (kind: VariableSegment, value: "number"),
                 (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoIssuesNumberLabels_553650159(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Add labels to an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650161 = path.getOrDefault("owner")
  valid_553650161 = validateParameter(valid_553650161, JString, required = true,
                                      default = nil)
  if valid_553650161 != nil:
    section.add "owner", valid_553650161
  var valid_553650162 = path.getOrDefault("number")
  valid_553650162 = validateParameter(valid_553650162, JInt, required = true,
                                      default = nil)
  if valid_553650162 != nil:
    section.add "number", valid_553650162
  var valid_553650163 = path.getOrDefault("repo")
  valid_553650163 = validateParameter(valid_553650163, JString, required = true,
                                      default = nil)
  if valid_553650163 != nil:
    section.add "repo", valid_553650163
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650164 = header.getOrDefault("Accept")
  valid_553650164 = validateParameter(valid_553650164, JString,
                                      required = false, default = nil)
  if valid_553650164 != nil:
    section.add "Accept", valid_553650164
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553650166: Call_PostReposOwnerRepoIssuesNumberLabels_553650158;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Add labels to an issue.
  ## 
  let valid = call_553650166.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650166.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650166.makeUrl(scheme.get, call_553650166.host, call_553650166.base,
                                   call_553650166.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650166, uri, valid, content)

proc call*(call_553650167: Call_PostReposOwnerRepoIssuesNumberLabels_553650158;
           owner: string; number: int; body: JsonNode; repo: string;
           Accept: string = ""): Recallable =
  ## postReposOwnerRepoIssuesNumberLabels
  ## Add labels to an issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650168 = newJObject()
  var header_553650169 = newJObject()
  var body_553650170 = newJObject()
  add(path_553650168, "owner", newJString(owner))
  add(path_553650168, "number", newJInt(number))
  add(header_553650169, "Accept", newJString(Accept))
  if body != nil:
    body_553650170 = body
  add(path_553650168, "repo", newJString(repo))
  result = call_553650167.call(path_553650168, nil, header_553650169, nil, body_553650170)

var postReposOwnerRepoIssuesNumberLabels* = Call_PostReposOwnerRepoIssuesNumberLabels_553650158(
    name: "postReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_PostReposOwnerRepoIssuesNumberLabels_553650159,
    base: "/", makeUrl: url_PostReposOwnerRepoIssuesNumberLabels_553650160,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoIssuesNumberLabels_553650134 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoIssuesNumberLabels_553650136(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/issues/"),
                 (kind: VariableSegment, value: "number"),
                 (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoIssuesNumberLabels_553650135(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## List labels on an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650137 = path.getOrDefault("owner")
  valid_553650137 = validateParameter(valid_553650137, JString, required = true,
                                      default = nil)
  if valid_553650137 != nil:
    section.add "owner", valid_553650137
  var valid_553650138 = path.getOrDefault("number")
  valid_553650138 = validateParameter(valid_553650138, JInt, required = true,
                                      default = nil)
  if valid_553650138 != nil:
    section.add "number", valid_553650138
  var valid_553650139 = path.getOrDefault("repo")
  valid_553650139 = validateParameter(valid_553650139, JString, required = true,
                                      default = nil)
  if valid_553650139 != nil:
    section.add "repo", valid_553650139
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650140 = header.getOrDefault("Accept")
  valid_553650140 = validateParameter(valid_553650140, JString,
                                      required = false, default = nil)
  if valid_553650140 != nil:
    section.add "Accept", valid_553650140
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650141: Call_GetReposOwnerRepoIssuesNumberLabels_553650134;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List labels on an issue.
  ## 
  let valid = call_553650141.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650141.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650141.makeUrl(scheme.get, call_553650141.host, call_553650141.base,
                                   call_553650141.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650141, uri, valid, content)

proc call*(call_553650142: Call_GetReposOwnerRepoIssuesNumberLabels_553650134;
           owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoIssuesNumberLabels
  ## List labels on an issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650143 = newJObject()
  var header_553650144 = newJObject()
  add(path_553650143, "owner", newJString(owner))
  add(path_553650143, "number", newJInt(number))
  add(header_553650144, "Accept", newJString(Accept))
  add(path_553650143, "repo", newJString(repo))
  result = call_553650142.call(path_553650143, nil, header_553650144, nil, nil)

var getReposOwnerRepoIssuesNumberLabels* = Call_GetReposOwnerRepoIssuesNumberLabels_553650134(
    name: "getReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_GetReposOwnerRepoIssuesNumberLabels_553650135,
    base: "/", makeUrl: url_GetReposOwnerRepoIssuesNumberLabels_553650136,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoIssuesNumberLabels_553650171 = ref object of OpenApiRestCall_553648476
proc url_DeleteReposOwnerRepoIssuesNumberLabels_553650173(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/issues/"),
                 (kind: VariableSegment, value: "number"),
                 (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoIssuesNumberLabels_553650172(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Remove all labels from an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650174 = path.getOrDefault("owner")
  valid_553650174 = validateParameter(valid_553650174, JString, required = true,
                                      default = nil)
  if valid_553650174 != nil:
    section.add "owner", valid_553650174
  var valid_553650175 = path.getOrDefault("number")
  valid_553650175 = validateParameter(valid_553650175, JInt, required = true,
                                      default = nil)
  if valid_553650175 != nil:
    section.add "number", valid_553650175
  var valid_553650176 = path.getOrDefault("repo")
  valid_553650176 = validateParameter(valid_553650176, JString, required = true,
                                      default = nil)
  if valid_553650176 != nil:
    section.add "repo", valid_553650176
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650177 = header.getOrDefault("Accept")
  valid_553650177 = validateParameter(valid_553650177, JString,
                                      required = false, default = nil)
  if valid_553650177 != nil:
    section.add "Accept", valid_553650177
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650178: Call_DeleteReposOwnerRepoIssuesNumberLabels_553650171;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Remove all labels from an issue.
  ## 
  let valid = call_553650178.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650178.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650178.makeUrl(scheme.get, call_553650178.host, call_553650178.base,
                                   call_553650178.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650178, uri, valid, content)

proc call*(call_553650179: Call_DeleteReposOwnerRepoIssuesNumberLabels_553650171;
           owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoIssuesNumberLabels
  ## Remove all labels from an issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650180 = newJObject()
  var header_553650181 = newJObject()
  add(path_553650180, "owner", newJString(owner))
  add(path_553650180, "number", newJInt(number))
  add(header_553650181, "Accept", newJString(Accept))
  add(path_553650180, "repo", newJString(repo))
  result = call_553650179.call(path_553650180, nil, header_553650181, nil, nil)

var deleteReposOwnerRepoIssuesNumberLabels* = Call_DeleteReposOwnerRepoIssuesNumberLabels_553650171(
    name: "deleteReposOwnerRepoIssuesNumberLabels", meth: HttpMethod.HttpDelete,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/{number}/labels",
    validator: validate_DeleteReposOwnerRepoIssuesNumberLabels_553650172,
    base: "/", makeUrl: url_DeleteReposOwnerRepoIssuesNumberLabels_553650173,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoIssuesNumberLabelsName_553650182 = ref object of OpenApiRestCall_553648476
proc url_DeleteReposOwnerRepoIssuesNumberLabelsName_553650184(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/issues/"),
                 (kind: VariableSegment, value: "number"),
                 (kind: ConstantSegment, value: "/labels/"),
                 (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoIssuesNumberLabelsName_553650183(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode; content: string = ""): JsonNode {.nosinks.} =
  ## Remove a label from an issue.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of issue.
  ##   name: JString (required)
  ##       : Name of the label.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650185 = path.getOrDefault("owner")
  valid_553650185 = validateParameter(valid_553650185, JString, required = true,
                                      default = nil)
  if valid_553650185 != nil:
    section.add "owner", valid_553650185
  var valid_553650186 = path.getOrDefault("number")
  valid_553650186 = validateParameter(valid_553650186, JInt, required = true,
                                      default = nil)
  if valid_553650186 != nil:
    section.add "number", valid_553650186
  var valid_553650187 = path.getOrDefault("name")
  valid_553650187 = validateParameter(valid_553650187, JString, required = true,
                                      default = nil)
  if valid_553650187 != nil:
    section.add "name", valid_553650187
  var valid_553650188 = path.getOrDefault("repo")
  valid_553650188 = validateParameter(valid_553650188, JString, required = true,
                                      default = nil)
  if valid_553650188 != nil:
    section.add "repo", valid_553650188
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650189 = header.getOrDefault("Accept")
  valid_553650189 = validateParameter(valid_553650189, JString,
                                      required = false, default = nil)
  if valid_553650189 != nil:
    section.add "Accept", valid_553650189
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650190: Call_DeleteReposOwnerRepoIssuesNumberLabelsName_553650182;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Remove a label from an issue.
  ## 
  let valid = call_553650190.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650190.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650190.makeUrl(scheme.get, call_553650190.host, call_553650190.base,
                                   call_553650190.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650190, uri, valid, content)

proc call*(call_553650191: Call_DeleteReposOwnerRepoIssuesNumberLabelsName_553650182;
           owner: string; number: int; name: string; repo: string;
           Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoIssuesNumberLabelsName
  ## Remove a label from an issue.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of issue.
  ##   name: string (required)
  ##       : Name of the label.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650192 = newJObject()
  var header_553650193 = newJObject()
  add(path_553650192, "owner", newJString(owner))
  add(path_553650192, "number", newJInt(number))
  add(path_553650192, "name", newJString(name))
  add(header_553650193, "Accept", newJString(Accept))
  add(path_553650192, "repo", newJString(repo))
  result = call_553650191.call(path_553650192, nil, header_553650193, nil, nil)

var deleteReposOwnerRepoIssuesNumberLabelsName* = Call_DeleteReposOwnerRepoIssuesNumberLabelsName_553650182(
    name: "deleteReposOwnerRepoIssuesNumberLabelsName",
    meth: HttpMethod.HttpDelete, host: "api.github.com",
    route: "/repos/{owner}/{repo}/issues/{number}/labels/{name}",
    validator: validate_DeleteReposOwnerRepoIssuesNumberLabelsName_553650183,
    base: "/", makeUrl: url_DeleteReposOwnerRepoIssuesNumberLabelsName_553650184,
    schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoKeys_553650204 = ref object of OpenApiRestCall_553648476
proc url_PostReposOwnerRepoKeys_553650206(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/keys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoKeys_553650205(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Create a key.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650207 = path.getOrDefault("owner")
  valid_553650207 = validateParameter(valid_553650207, JString, required = true,
                                      default = nil)
  if valid_553650207 != nil:
    section.add "owner", valid_553650207
  var valid_553650208 = path.getOrDefault("repo")
  valid_553650208 = validateParameter(valid_553650208, JString, required = true,
                                      default = nil)
  if valid_553650208 != nil:
    section.add "repo", valid_553650208
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650209 = header.getOrDefault("Accept")
  valid_553650209 = validateParameter(valid_553650209, JString,
                                      required = false, default = nil)
  if valid_553650209 != nil:
    section.add "Accept", valid_553650209
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553650211: Call_PostReposOwnerRepoKeys_553650204;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Create a key.
  ## 
  let valid = call_553650211.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650211.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650211.makeUrl(scheme.get, call_553650211.host, call_553650211.base,
                                   call_553650211.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650211, uri, valid, content)

proc call*(call_553650212: Call_PostReposOwnerRepoKeys_553650204; owner: string;
           body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoKeys
  ## Create a key.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650213 = newJObject()
  var header_553650214 = newJObject()
  var body_553650215 = newJObject()
  add(path_553650213, "owner", newJString(owner))
  add(header_553650214, "Accept", newJString(Accept))
  if body != nil:
    body_553650215 = body
  add(path_553650213, "repo", newJString(repo))
  result = call_553650212.call(path_553650213, nil, header_553650214, nil, body_553650215)

var postReposOwnerRepoKeys* = Call_PostReposOwnerRepoKeys_553650204(
    name: "postReposOwnerRepoKeys", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/keys",
    validator: validate_PostReposOwnerRepoKeys_553650205, base: "/",
    makeUrl: url_PostReposOwnerRepoKeys_553650206, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoKeys_553650194 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoKeys_553650196(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/keys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoKeys_553650195(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Get list of keys.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650197 = path.getOrDefault("owner")
  valid_553650197 = validateParameter(valid_553650197, JString, required = true,
                                      default = nil)
  if valid_553650197 != nil:
    section.add "owner", valid_553650197
  var valid_553650198 = path.getOrDefault("repo")
  valid_553650198 = validateParameter(valid_553650198, JString, required = true,
                                      default = nil)
  if valid_553650198 != nil:
    section.add "repo", valid_553650198
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650199 = header.getOrDefault("Accept")
  valid_553650199 = validateParameter(valid_553650199, JString,
                                      required = false, default = nil)
  if valid_553650199 != nil:
    section.add "Accept", valid_553650199
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650200: Call_GetReposOwnerRepoKeys_553650194;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get list of keys.
  ## 
  let valid = call_553650200.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650200.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650200.makeUrl(scheme.get, call_553650200.host, call_553650200.base,
                                   call_553650200.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650200, uri, valid, content)

proc call*(call_553650201: Call_GetReposOwnerRepoKeys_553650194; owner: string;
           repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoKeys
  ## Get list of keys.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650202 = newJObject()
  var header_553650203 = newJObject()
  add(path_553650202, "owner", newJString(owner))
  add(header_553650203, "Accept", newJString(Accept))
  add(path_553650202, "repo", newJString(repo))
  result = call_553650201.call(path_553650202, nil, header_553650203, nil, nil)

var getReposOwnerRepoKeys* = Call_GetReposOwnerRepoKeys_553650194(
    name: "getReposOwnerRepoKeys", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/keys",
    validator: validate_GetReposOwnerRepoKeys_553650195, base: "/",
    makeUrl: url_GetReposOwnerRepoKeys_553650196, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoKeysKeyId_553650216 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoKeysKeyId_553650218(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/keys/"),
                 (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoKeysKeyId_553650217(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get a key
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   keyId: JInt (required)
  ##        : Id of key.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650219 = path.getOrDefault("owner")
  valid_553650219 = validateParameter(valid_553650219, JString, required = true,
                                      default = nil)
  if valid_553650219 != nil:
    section.add "owner", valid_553650219
  var valid_553650220 = path.getOrDefault("keyId")
  valid_553650220 = validateParameter(valid_553650220, JInt, required = true,
                                      default = nil)
  if valid_553650220 != nil:
    section.add "keyId", valid_553650220
  var valid_553650221 = path.getOrDefault("repo")
  valid_553650221 = validateParameter(valid_553650221, JString, required = true,
                                      default = nil)
  if valid_553650221 != nil:
    section.add "repo", valid_553650221
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650222 = header.getOrDefault("Accept")
  valid_553650222 = validateParameter(valid_553650222, JString,
                                      required = false, default = nil)
  if valid_553650222 != nil:
    section.add "Accept", valid_553650222
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650223: Call_GetReposOwnerRepoKeysKeyId_553650216;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get a key
  ## 
  let valid = call_553650223.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650223.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650223.makeUrl(scheme.get, call_553650223.host, call_553650223.base,
                                   call_553650223.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650223, uri, valid, content)

proc call*(call_553650224: Call_GetReposOwnerRepoKeysKeyId_553650216;
           owner: string; keyId: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoKeysKeyId
  ## Get a key
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   keyId: int (required)
  ##        : Id of key.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650225 = newJObject()
  var header_553650226 = newJObject()
  add(path_553650225, "owner", newJString(owner))
  add(header_553650226, "Accept", newJString(Accept))
  add(path_553650225, "keyId", newJInt(keyId))
  add(path_553650225, "repo", newJString(repo))
  result = call_553650224.call(path_553650225, nil, header_553650226, nil, nil)

var getReposOwnerRepoKeysKeyId* = Call_GetReposOwnerRepoKeysKeyId_553650216(
    name: "getReposOwnerRepoKeysKeyId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/keys/{keyId}",
    validator: validate_GetReposOwnerRepoKeysKeyId_553650217, base: "/",
    makeUrl: url_GetReposOwnerRepoKeysKeyId_553650218, schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoKeysKeyId_553650227 = ref object of OpenApiRestCall_553648476
proc url_DeleteReposOwnerRepoKeysKeyId_553650229(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/keys/"),
                 (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoKeysKeyId_553650228(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Delete a key.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   keyId: JInt (required)
  ##        : Id of key.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650230 = path.getOrDefault("owner")
  valid_553650230 = validateParameter(valid_553650230, JString, required = true,
                                      default = nil)
  if valid_553650230 != nil:
    section.add "owner", valid_553650230
  var valid_553650231 = path.getOrDefault("keyId")
  valid_553650231 = validateParameter(valid_553650231, JInt, required = true,
                                      default = nil)
  if valid_553650231 != nil:
    section.add "keyId", valid_553650231
  var valid_553650232 = path.getOrDefault("repo")
  valid_553650232 = validateParameter(valid_553650232, JString, required = true,
                                      default = nil)
  if valid_553650232 != nil:
    section.add "repo", valid_553650232
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650233 = header.getOrDefault("Accept")
  valid_553650233 = validateParameter(valid_553650233, JString,
                                      required = false, default = nil)
  if valid_553650233 != nil:
    section.add "Accept", valid_553650233
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650234: Call_DeleteReposOwnerRepoKeysKeyId_553650227;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Delete a key.
  ## 
  let valid = call_553650234.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650234.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650234.makeUrl(scheme.get, call_553650234.host, call_553650234.base,
                                   call_553650234.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650234, uri, valid, content)

proc call*(call_553650235: Call_DeleteReposOwnerRepoKeysKeyId_553650227;
           owner: string; keyId: int; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoKeysKeyId
  ## Delete a key.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   keyId: int (required)
  ##        : Id of key.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650236 = newJObject()
  var header_553650237 = newJObject()
  add(path_553650236, "owner", newJString(owner))
  add(header_553650237, "Accept", newJString(Accept))
  add(path_553650236, "keyId", newJInt(keyId))
  add(path_553650236, "repo", newJString(repo))
  result = call_553650235.call(path_553650236, nil, header_553650237, nil, nil)

var deleteReposOwnerRepoKeysKeyId* = Call_DeleteReposOwnerRepoKeysKeyId_553650227(
    name: "deleteReposOwnerRepoKeysKeyId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/keys/{keyId}",
    validator: validate_DeleteReposOwnerRepoKeysKeyId_553650228, base: "/",
    makeUrl: url_DeleteReposOwnerRepoKeysKeyId_553650229,
    schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoLabels_553650248 = ref object of OpenApiRestCall_553648476
proc url_PostReposOwnerRepoLabels_553650250(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoLabels_553650249(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Create a label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650251 = path.getOrDefault("owner")
  valid_553650251 = validateParameter(valid_553650251, JString, required = true,
                                      default = nil)
  if valid_553650251 != nil:
    section.add "owner", valid_553650251
  var valid_553650252 = path.getOrDefault("repo")
  valid_553650252 = validateParameter(valid_553650252, JString, required = true,
                                      default = nil)
  if valid_553650252 != nil:
    section.add "repo", valid_553650252
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650253 = header.getOrDefault("Accept")
  valid_553650253 = validateParameter(valid_553650253, JString,
                                      required = false, default = nil)
  if valid_553650253 != nil:
    section.add "Accept", valid_553650253
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553650255: Call_PostReposOwnerRepoLabels_553650248;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Create a label.
  ## 
  let valid = call_553650255.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650255.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650255.makeUrl(scheme.get, call_553650255.host, call_553650255.base,
                                   call_553650255.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650255, uri, valid, content)

proc call*(call_553650256: Call_PostReposOwnerRepoLabels_553650248;
           owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoLabels
  ## Create a label.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650257 = newJObject()
  var header_553650258 = newJObject()
  var body_553650259 = newJObject()
  add(path_553650257, "owner", newJString(owner))
  add(header_553650258, "Accept", newJString(Accept))
  if body != nil:
    body_553650259 = body
  add(path_553650257, "repo", newJString(repo))
  result = call_553650256.call(path_553650257, nil, header_553650258, nil, body_553650259)

var postReposOwnerRepoLabels* = Call_PostReposOwnerRepoLabels_553650248(
    name: "postReposOwnerRepoLabels", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels",
    validator: validate_PostReposOwnerRepoLabels_553650249, base: "/",
    makeUrl: url_PostReposOwnerRepoLabels_553650250, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoLabels_553650238 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoLabels_553650240(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoLabels_553650239(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List all labels for this repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650241 = path.getOrDefault("owner")
  valid_553650241 = validateParameter(valid_553650241, JString, required = true,
                                      default = nil)
  if valid_553650241 != nil:
    section.add "owner", valid_553650241
  var valid_553650242 = path.getOrDefault("repo")
  valid_553650242 = validateParameter(valid_553650242, JString, required = true,
                                      default = nil)
  if valid_553650242 != nil:
    section.add "repo", valid_553650242
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650243 = header.getOrDefault("Accept")
  valid_553650243 = validateParameter(valid_553650243, JString,
                                      required = false, default = nil)
  if valid_553650243 != nil:
    section.add "Accept", valid_553650243
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650244: Call_GetReposOwnerRepoLabels_553650238;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List all labels for this repository.
  ## 
  let valid = call_553650244.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650244.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650244.makeUrl(scheme.get, call_553650244.host, call_553650244.base,
                                   call_553650244.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650244, uri, valid, content)

proc call*(call_553650245: Call_GetReposOwnerRepoLabels_553650238;
           owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoLabels
  ## List all labels for this repository.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650246 = newJObject()
  var header_553650247 = newJObject()
  add(path_553650246, "owner", newJString(owner))
  add(header_553650247, "Accept", newJString(Accept))
  add(path_553650246, "repo", newJString(repo))
  result = call_553650245.call(path_553650246, nil, header_553650247, nil, nil)

var getReposOwnerRepoLabels* = Call_GetReposOwnerRepoLabels_553650238(
    name: "getReposOwnerRepoLabels", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels",
    validator: validate_GetReposOwnerRepoLabels_553650239, base: "/",
    makeUrl: url_GetReposOwnerRepoLabels_553650240, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoLabelsName_553650260 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoLabelsName_553650262(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/labels/"),
                 (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoLabelsName_553650261(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get a single label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   name: JString (required)
  ##       : Name of the label.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650263 = path.getOrDefault("owner")
  valid_553650263 = validateParameter(valid_553650263, JString, required = true,
                                      default = nil)
  if valid_553650263 != nil:
    section.add "owner", valid_553650263
  var valid_553650264 = path.getOrDefault("name")
  valid_553650264 = validateParameter(valid_553650264, JString, required = true,
                                      default = nil)
  if valid_553650264 != nil:
    section.add "name", valid_553650264
  var valid_553650265 = path.getOrDefault("repo")
  valid_553650265 = validateParameter(valid_553650265, JString, required = true,
                                      default = nil)
  if valid_553650265 != nil:
    section.add "repo", valid_553650265
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650266 = header.getOrDefault("Accept")
  valid_553650266 = validateParameter(valid_553650266, JString,
                                      required = false, default = nil)
  if valid_553650266 != nil:
    section.add "Accept", valid_553650266
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650267: Call_GetReposOwnerRepoLabelsName_553650260;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get a single label.
  ## 
  let valid = call_553650267.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650267.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650267.makeUrl(scheme.get, call_553650267.host, call_553650267.base,
                                   call_553650267.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650267, uri, valid, content)

proc call*(call_553650268: Call_GetReposOwnerRepoLabelsName_553650260;
           owner: string; name: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoLabelsName
  ## Get a single label.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   name: string (required)
  ##       : Name of the label.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650269 = newJObject()
  var header_553650270 = newJObject()
  add(path_553650269, "owner", newJString(owner))
  add(path_553650269, "name", newJString(name))
  add(header_553650270, "Accept", newJString(Accept))
  add(path_553650269, "repo", newJString(repo))
  result = call_553650268.call(path_553650269, nil, header_553650270, nil, nil)

var getReposOwnerRepoLabelsName* = Call_GetReposOwnerRepoLabelsName_553650260(
    name: "getReposOwnerRepoLabelsName", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels/{name}",
    validator: validate_GetReposOwnerRepoLabelsName_553650261, base: "/",
    makeUrl: url_GetReposOwnerRepoLabelsName_553650262, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoLabelsName_553650282 = ref object of OpenApiRestCall_553648476
proc url_PatchReposOwnerRepoLabelsName_553650284(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/labels/"),
                 (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoLabelsName_553650283(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Update a label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   name: JString (required)
  ##       : Name of the label.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650285 = path.getOrDefault("owner")
  valid_553650285 = validateParameter(valid_553650285, JString, required = true,
                                      default = nil)
  if valid_553650285 != nil:
    section.add "owner", valid_553650285
  var valid_553650286 = path.getOrDefault("name")
  valid_553650286 = validateParameter(valid_553650286, JString, required = true,
                                      default = nil)
  if valid_553650286 != nil:
    section.add "name", valid_553650286
  var valid_553650287 = path.getOrDefault("repo")
  valid_553650287 = validateParameter(valid_553650287, JString, required = true,
                                      default = nil)
  if valid_553650287 != nil:
    section.add "repo", valid_553650287
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650288 = header.getOrDefault("Accept")
  valid_553650288 = validateParameter(valid_553650288, JString,
                                      required = false, default = nil)
  if valid_553650288 != nil:
    section.add "Accept", valid_553650288
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553650290: Call_PatchReposOwnerRepoLabelsName_553650282;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Update a label.
  ## 
  let valid = call_553650290.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650290.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650290.makeUrl(scheme.get, call_553650290.host, call_553650290.base,
                                   call_553650290.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650290, uri, valid, content)

proc call*(call_553650291: Call_PatchReposOwnerRepoLabelsName_553650282;
           owner: string; name: string; body: JsonNode; repo: string;
           Accept: string = ""): Recallable =
  ## patchReposOwnerRepoLabelsName
  ## Update a label.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   name: string (required)
  ##       : Name of the label.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650292 = newJObject()
  var header_553650293 = newJObject()
  var body_553650294 = newJObject()
  add(path_553650292, "owner", newJString(owner))
  add(path_553650292, "name", newJString(name))
  add(header_553650293, "Accept", newJString(Accept))
  if body != nil:
    body_553650294 = body
  add(path_553650292, "repo", newJString(repo))
  result = call_553650291.call(path_553650292, nil, header_553650293, nil, body_553650294)

var patchReposOwnerRepoLabelsName* = Call_PatchReposOwnerRepoLabelsName_553650282(
    name: "patchReposOwnerRepoLabelsName", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels/{name}",
    validator: validate_PatchReposOwnerRepoLabelsName_553650283, base: "/",
    makeUrl: url_PatchReposOwnerRepoLabelsName_553650284,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoLabelsName_553650271 = ref object of OpenApiRestCall_553648476
proc url_DeleteReposOwnerRepoLabelsName_553650273(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "name" in path, "`name` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/labels/"),
                 (kind: VariableSegment, value: "name")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoLabelsName_553650272(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Delete a label.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   name: JString (required)
  ##       : Name of the label.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650274 = path.getOrDefault("owner")
  valid_553650274 = validateParameter(valid_553650274, JString, required = true,
                                      default = nil)
  if valid_553650274 != nil:
    section.add "owner", valid_553650274
  var valid_553650275 = path.getOrDefault("name")
  valid_553650275 = validateParameter(valid_553650275, JString, required = true,
                                      default = nil)
  if valid_553650275 != nil:
    section.add "name", valid_553650275
  var valid_553650276 = path.getOrDefault("repo")
  valid_553650276 = validateParameter(valid_553650276, JString, required = true,
                                      default = nil)
  if valid_553650276 != nil:
    section.add "repo", valid_553650276
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650277 = header.getOrDefault("Accept")
  valid_553650277 = validateParameter(valid_553650277, JString,
                                      required = false, default = nil)
  if valid_553650277 != nil:
    section.add "Accept", valid_553650277
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650278: Call_DeleteReposOwnerRepoLabelsName_553650271;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Delete a label.
  ## 
  let valid = call_553650278.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650278.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650278.makeUrl(scheme.get, call_553650278.host, call_553650278.base,
                                   call_553650278.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650278, uri, valid, content)

proc call*(call_553650279: Call_DeleteReposOwnerRepoLabelsName_553650271;
           owner: string; name: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoLabelsName
  ## Delete a label.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   name: string (required)
  ##       : Name of the label.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650280 = newJObject()
  var header_553650281 = newJObject()
  add(path_553650280, "owner", newJString(owner))
  add(path_553650280, "name", newJString(name))
  add(header_553650281, "Accept", newJString(Accept))
  add(path_553650280, "repo", newJString(repo))
  result = call_553650279.call(path_553650280, nil, header_553650281, nil, nil)

var deleteReposOwnerRepoLabelsName* = Call_DeleteReposOwnerRepoLabelsName_553650271(
    name: "deleteReposOwnerRepoLabelsName", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/labels/{name}",
    validator: validate_DeleteReposOwnerRepoLabelsName_553650272, base: "/",
    makeUrl: url_DeleteReposOwnerRepoLabelsName_553650273,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoLanguages_553650295 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoLanguages_553650297(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/languages")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoLanguages_553650296(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## List languages.
  ## List languages for the specified repository. The value on the right of a
  ## language is the number of bytes of code written in that language.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650298 = path.getOrDefault("owner")
  valid_553650298 = validateParameter(valid_553650298, JString, required = true,
                                      default = nil)
  if valid_553650298 != nil:
    section.add "owner", valid_553650298
  var valid_553650299 = path.getOrDefault("repo")
  valid_553650299 = validateParameter(valid_553650299, JString, required = true,
                                      default = nil)
  if valid_553650299 != nil:
    section.add "repo", valid_553650299
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650300 = header.getOrDefault("Accept")
  valid_553650300 = validateParameter(valid_553650300, JString,
                                      required = false, default = nil)
  if valid_553650300 != nil:
    section.add "Accept", valid_553650300
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650301: Call_GetReposOwnerRepoLanguages_553650295;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List languages.
  ## List languages for the specified repository. The value on the right of a
  ## language is the number of bytes of code written in that language.
  ## 
  ## 
  let valid = call_553650301.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650301.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650301.makeUrl(scheme.get, call_553650301.host, call_553650301.base,
                                   call_553650301.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650301, uri, valid, content)

proc call*(call_553650302: Call_GetReposOwnerRepoLanguages_553650295;
           owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoLanguages
  ## List languages.
  ## List languages for the specified repository. The value on the right of a
  ## language is the number of bytes of code written in that language.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650303 = newJObject()
  var header_553650304 = newJObject()
  add(path_553650303, "owner", newJString(owner))
  add(header_553650304, "Accept", newJString(Accept))
  add(path_553650303, "repo", newJString(repo))
  result = call_553650302.call(path_553650303, nil, header_553650304, nil, nil)

var getReposOwnerRepoLanguages* = Call_GetReposOwnerRepoLanguages_553650295(
    name: "getReposOwnerRepoLanguages", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/languages",
    validator: validate_GetReposOwnerRepoLanguages_553650296, base: "/",
    makeUrl: url_GetReposOwnerRepoLanguages_553650297, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoMerges_553650305 = ref object of OpenApiRestCall_553648476
proc url_PostReposOwnerRepoMerges_553650307(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/merges")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoMerges_553650306(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Perform a merge.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650308 = path.getOrDefault("owner")
  valid_553650308 = validateParameter(valid_553650308, JString, required = true,
                                      default = nil)
  if valid_553650308 != nil:
    section.add "owner", valid_553650308
  var valid_553650309 = path.getOrDefault("repo")
  valid_553650309 = validateParameter(valid_553650309, JString, required = true,
                                      default = nil)
  if valid_553650309 != nil:
    section.add "repo", valid_553650309
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650310 = header.getOrDefault("Accept")
  valid_553650310 = validateParameter(valid_553650310, JString,
                                      required = false, default = nil)
  if valid_553650310 != nil:
    section.add "Accept", valid_553650310
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553650312: Call_PostReposOwnerRepoMerges_553650305;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Perform a merge.
  ## 
  let valid = call_553650312.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650312.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650312.makeUrl(scheme.get, call_553650312.host, call_553650312.base,
                                   call_553650312.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650312, uri, valid, content)

proc call*(call_553650313: Call_PostReposOwnerRepoMerges_553650305;
           owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoMerges
  ## Perform a merge.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650314 = newJObject()
  var header_553650315 = newJObject()
  var body_553650316 = newJObject()
  add(path_553650314, "owner", newJString(owner))
  add(header_553650315, "Accept", newJString(Accept))
  if body != nil:
    body_553650316 = body
  add(path_553650314, "repo", newJString(repo))
  result = call_553650313.call(path_553650314, nil, header_553650315, nil, body_553650316)

var postReposOwnerRepoMerges* = Call_PostReposOwnerRepoMerges_553650305(
    name: "postReposOwnerRepoMerges", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/merges",
    validator: validate_PostReposOwnerRepoMerges_553650306, base: "/",
    makeUrl: url_PostReposOwnerRepoMerges_553650307, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoMilestones_553650331 = ref object of OpenApiRestCall_553648476
proc url_PostReposOwnerRepoMilestones_553650333(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/milestones")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoMilestones_553650332(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Create a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650334 = path.getOrDefault("owner")
  valid_553650334 = validateParameter(valid_553650334, JString, required = true,
                                      default = nil)
  if valid_553650334 != nil:
    section.add "owner", valid_553650334
  var valid_553650335 = path.getOrDefault("repo")
  valid_553650335 = validateParameter(valid_553650335, JString, required = true,
                                      default = nil)
  if valid_553650335 != nil:
    section.add "repo", valid_553650335
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650336 = header.getOrDefault("Accept")
  valid_553650336 = validateParameter(valid_553650336, JString,
                                      required = false, default = nil)
  if valid_553650336 != nil:
    section.add "Accept", valid_553650336
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553650338: Call_PostReposOwnerRepoMilestones_553650331;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Create a milestone.
  ## 
  let valid = call_553650338.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650338.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650338.makeUrl(scheme.get, call_553650338.host, call_553650338.base,
                                   call_553650338.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650338, uri, valid, content)

proc call*(call_553650339: Call_PostReposOwnerRepoMilestones_553650331;
           owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoMilestones
  ## Create a milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650340 = newJObject()
  var header_553650341 = newJObject()
  var body_553650342 = newJObject()
  add(path_553650340, "owner", newJString(owner))
  add(header_553650341, "Accept", newJString(Accept))
  if body != nil:
    body_553650342 = body
  add(path_553650340, "repo", newJString(repo))
  result = call_553650339.call(path_553650340, nil, header_553650341, nil, body_553650342)

var postReposOwnerRepoMilestones* = Call_PostReposOwnerRepoMilestones_553650331(
    name: "postReposOwnerRepoMilestones", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones",
    validator: validate_PostReposOwnerRepoMilestones_553650332, base: "/",
    makeUrl: url_PostReposOwnerRepoMilestones_553650333, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoMilestones_553650317 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoMilestones_553650319(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/milestones")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoMilestones_553650318(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## List milestones for a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650320 = path.getOrDefault("owner")
  valid_553650320 = validateParameter(valid_553650320, JString, required = true,
                                      default = nil)
  if valid_553650320 != nil:
    section.add "owner", valid_553650320
  var valid_553650321 = path.getOrDefault("repo")
  valid_553650321 = validateParameter(valid_553650321, JString, required = true,
                                      default = nil)
  if valid_553650321 != nil:
    section.add "repo", valid_553650321
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString
  ##        : String to filter by state.
  ##   sort: JString
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  section = newJObject()
  var valid_553650322 = query.getOrDefault("state")
  valid_553650322 = validateParameter(valid_553650322, JString,
                                      required = false,
                                      default = newJString("open"))
  if valid_553650322 != nil:
    section.add "state", valid_553650322
  var valid_553650323 = query.getOrDefault("sort")
  valid_553650323 = validateParameter(valid_553650323, JString,
                                      required = false,
                                      default = newJString("due_date"))
  if valid_553650323 != nil:
    section.add "sort", valid_553650323
  var valid_553650324 = query.getOrDefault("direction")
  valid_553650324 = validateParameter(valid_553650324, JString,
                                      required = false, default = nil)
  if valid_553650324 != nil:
    section.add "direction", valid_553650324
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650325 = header.getOrDefault("Accept")
  valid_553650325 = validateParameter(valid_553650325, JString,
                                      required = false, default = nil)
  if valid_553650325 != nil:
    section.add "Accept", valid_553650325
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650326: Call_GetReposOwnerRepoMilestones_553650317;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List milestones for a repository.
  ## 
  let valid = call_553650326.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650326.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650326.makeUrl(scheme.get, call_553650326.host, call_553650326.base,
                                   call_553650326.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650326, uri, valid, content)

proc call*(call_553650327: Call_GetReposOwnerRepoMilestones_553650317;
           owner: string; repo: string; state: string = "open";
           Accept: string = ""; sort: string = "due_date";
           direction: string = ""): Recallable =
  ## getReposOwnerRepoMilestones
  ## List milestones for a repository.
  ##   state: string
  ##        : String to filter by state.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   sort: string
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  var path_553650328 = newJObject()
  var query_553650329 = newJObject()
  var header_553650330 = newJObject()
  add(query_553650329, "state", newJString(state))
  add(path_553650328, "owner", newJString(owner))
  add(header_553650330, "Accept", newJString(Accept))
  add(path_553650328, "repo", newJString(repo))
  add(query_553650329, "sort", newJString(sort))
  add(query_553650329, "direction", newJString(direction))
  result = call_553650327.call(path_553650328, query_553650329, header_553650330,
                               nil, nil)

var getReposOwnerRepoMilestones* = Call_GetReposOwnerRepoMilestones_553650317(
    name: "getReposOwnerRepoMilestones", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones",
    validator: validate_GetReposOwnerRepoMilestones_553650318, base: "/",
    makeUrl: url_GetReposOwnerRepoMilestones_553650319, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoMilestonesNumber_553650343 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoMilestonesNumber_553650345(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/milestones/"),
                 (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoMilestonesNumber_553650344(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get a single milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650346 = path.getOrDefault("owner")
  valid_553650346 = validateParameter(valid_553650346, JString, required = true,
                                      default = nil)
  if valid_553650346 != nil:
    section.add "owner", valid_553650346
  var valid_553650347 = path.getOrDefault("number")
  valid_553650347 = validateParameter(valid_553650347, JInt, required = true,
                                      default = nil)
  if valid_553650347 != nil:
    section.add "number", valid_553650347
  var valid_553650348 = path.getOrDefault("repo")
  valid_553650348 = validateParameter(valid_553650348, JString, required = true,
                                      default = nil)
  if valid_553650348 != nil:
    section.add "repo", valid_553650348
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650349 = header.getOrDefault("Accept")
  valid_553650349 = validateParameter(valid_553650349, JString,
                                      required = false, default = nil)
  if valid_553650349 != nil:
    section.add "Accept", valid_553650349
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650350: Call_GetReposOwnerRepoMilestonesNumber_553650343;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get a single milestone.
  ## 
  let valid = call_553650350.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650350.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650350.makeUrl(scheme.get, call_553650350.host, call_553650350.base,
                                   call_553650350.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650350, uri, valid, content)

proc call*(call_553650351: Call_GetReposOwnerRepoMilestonesNumber_553650343;
           owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoMilestonesNumber
  ## Get a single milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650352 = newJObject()
  var header_553650353 = newJObject()
  add(path_553650352, "owner", newJString(owner))
  add(path_553650352, "number", newJInt(number))
  add(header_553650353, "Accept", newJString(Accept))
  add(path_553650352, "repo", newJString(repo))
  result = call_553650351.call(path_553650352, nil, header_553650353, nil, nil)

var getReposOwnerRepoMilestonesNumber* = Call_GetReposOwnerRepoMilestonesNumber_553650343(
    name: "getReposOwnerRepoMilestonesNumber", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones/{number}",
    validator: validate_GetReposOwnerRepoMilestonesNumber_553650344, base: "/",
    makeUrl: url_GetReposOwnerRepoMilestonesNumber_553650345,
    schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoMilestonesNumber_553650365 = ref object of OpenApiRestCall_553648476
proc url_PatchReposOwnerRepoMilestonesNumber_553650367(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/milestones/"),
                 (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoMilestonesNumber_553650366(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Update a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650368 = path.getOrDefault("owner")
  valid_553650368 = validateParameter(valid_553650368, JString, required = true,
                                      default = nil)
  if valid_553650368 != nil:
    section.add "owner", valid_553650368
  var valid_553650369 = path.getOrDefault("number")
  valid_553650369 = validateParameter(valid_553650369, JInt, required = true,
                                      default = nil)
  if valid_553650369 != nil:
    section.add "number", valid_553650369
  var valid_553650370 = path.getOrDefault("repo")
  valid_553650370 = validateParameter(valid_553650370, JString, required = true,
                                      default = nil)
  if valid_553650370 != nil:
    section.add "repo", valid_553650370
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650371 = header.getOrDefault("Accept")
  valid_553650371 = validateParameter(valid_553650371, JString,
                                      required = false, default = nil)
  if valid_553650371 != nil:
    section.add "Accept", valid_553650371
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553650373: Call_PatchReposOwnerRepoMilestonesNumber_553650365;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Update a milestone.
  ## 
  let valid = call_553650373.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650373.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650373.makeUrl(scheme.get, call_553650373.host, call_553650373.base,
                                   call_553650373.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650373, uri, valid, content)

proc call*(call_553650374: Call_PatchReposOwnerRepoMilestonesNumber_553650365;
           owner: string; number: int; body: JsonNode; repo: string;
           Accept: string = ""): Recallable =
  ## patchReposOwnerRepoMilestonesNumber
  ## Update a milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650375 = newJObject()
  var header_553650376 = newJObject()
  var body_553650377 = newJObject()
  add(path_553650375, "owner", newJString(owner))
  add(path_553650375, "number", newJInt(number))
  add(header_553650376, "Accept", newJString(Accept))
  if body != nil:
    body_553650377 = body
  add(path_553650375, "repo", newJString(repo))
  result = call_553650374.call(path_553650375, nil, header_553650376, nil, body_553650377)

var patchReposOwnerRepoMilestonesNumber* = Call_PatchReposOwnerRepoMilestonesNumber_553650365(
    name: "patchReposOwnerRepoMilestonesNumber", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones/{number}",
    validator: validate_PatchReposOwnerRepoMilestonesNumber_553650366,
    base: "/", makeUrl: url_PatchReposOwnerRepoMilestonesNumber_553650367,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoMilestonesNumber_553650354 = ref object of OpenApiRestCall_553648476
proc url_DeleteReposOwnerRepoMilestonesNumber_553650356(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/milestones/"),
                 (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoMilestonesNumber_553650355(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Delete a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650357 = path.getOrDefault("owner")
  valid_553650357 = validateParameter(valid_553650357, JString, required = true,
                                      default = nil)
  if valid_553650357 != nil:
    section.add "owner", valid_553650357
  var valid_553650358 = path.getOrDefault("number")
  valid_553650358 = validateParameter(valid_553650358, JInt, required = true,
                                      default = nil)
  if valid_553650358 != nil:
    section.add "number", valid_553650358
  var valid_553650359 = path.getOrDefault("repo")
  valid_553650359 = validateParameter(valid_553650359, JString, required = true,
                                      default = nil)
  if valid_553650359 != nil:
    section.add "repo", valid_553650359
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650360 = header.getOrDefault("Accept")
  valid_553650360 = validateParameter(valid_553650360, JString,
                                      required = false, default = nil)
  if valid_553650360 != nil:
    section.add "Accept", valid_553650360
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650361: Call_DeleteReposOwnerRepoMilestonesNumber_553650354;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Delete a milestone.
  ## 
  let valid = call_553650361.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650361.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650361.makeUrl(scheme.get, call_553650361.host, call_553650361.base,
                                   call_553650361.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650361, uri, valid, content)

proc call*(call_553650362: Call_DeleteReposOwnerRepoMilestonesNumber_553650354;
           owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoMilestonesNumber
  ## Delete a milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650363 = newJObject()
  var header_553650364 = newJObject()
  add(path_553650363, "owner", newJString(owner))
  add(path_553650363, "number", newJInt(number))
  add(header_553650364, "Accept", newJString(Accept))
  add(path_553650363, "repo", newJString(repo))
  result = call_553650362.call(path_553650363, nil, header_553650364, nil, nil)

var deleteReposOwnerRepoMilestonesNumber* = Call_DeleteReposOwnerRepoMilestonesNumber_553650354(
    name: "deleteReposOwnerRepoMilestonesNumber", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/milestones/{number}",
    validator: validate_DeleteReposOwnerRepoMilestonesNumber_553650355,
    base: "/", makeUrl: url_DeleteReposOwnerRepoMilestonesNumber_553650356,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoMilestonesNumberLabels_553650378 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoMilestonesNumberLabels_553650380(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/milestones/"),
                 (kind: VariableSegment, value: "number"),
                 (kind: ConstantSegment, value: "/labels")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoMilestonesNumberLabels_553650379(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get labels for every issue in a milestone.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Number of milestone.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650381 = path.getOrDefault("owner")
  valid_553650381 = validateParameter(valid_553650381, JString, required = true,
                                      default = nil)
  if valid_553650381 != nil:
    section.add "owner", valid_553650381
  var valid_553650382 = path.getOrDefault("number")
  valid_553650382 = validateParameter(valid_553650382, JInt, required = true,
                                      default = nil)
  if valid_553650382 != nil:
    section.add "number", valid_553650382
  var valid_553650383 = path.getOrDefault("repo")
  valid_553650383 = validateParameter(valid_553650383, JString, required = true,
                                      default = nil)
  if valid_553650383 != nil:
    section.add "repo", valid_553650383
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650384 = header.getOrDefault("Accept")
  valid_553650384 = validateParameter(valid_553650384, JString,
                                      required = false, default = nil)
  if valid_553650384 != nil:
    section.add "Accept", valid_553650384
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650385: Call_GetReposOwnerRepoMilestonesNumberLabels_553650378;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get labels for every issue in a milestone.
  ## 
  let valid = call_553650385.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650385.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650385.makeUrl(scheme.get, call_553650385.host, call_553650385.base,
                                   call_553650385.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650385, uri, valid, content)

proc call*(call_553650386: Call_GetReposOwnerRepoMilestonesNumberLabels_553650378;
           owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoMilestonesNumberLabels
  ## Get labels for every issue in a milestone.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Number of milestone.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650387 = newJObject()
  var header_553650388 = newJObject()
  add(path_553650387, "owner", newJString(owner))
  add(path_553650387, "number", newJInt(number))
  add(header_553650388, "Accept", newJString(Accept))
  add(path_553650387, "repo", newJString(repo))
  result = call_553650386.call(path_553650387, nil, header_553650388, nil, nil)

var getReposOwnerRepoMilestonesNumberLabels* = Call_GetReposOwnerRepoMilestonesNumberLabels_553650378(
    name: "getReposOwnerRepoMilestonesNumberLabels", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/milestones/{number}/labels",
    validator: validate_GetReposOwnerRepoMilestonesNumberLabels_553650379,
    base: "/", makeUrl: url_GetReposOwnerRepoMilestonesNumberLabels_553650380,
    schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoNotifications_553650403 = ref object of OpenApiRestCall_553648476
proc url_PutReposOwnerRepoNotifications_553650405(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/notifications")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoNotifications_553650404(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Mark notifications as read in a repository.
  ## Marking all notifications in a repository as "read" removes them from the
  ## default view on GitHub.com.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650406 = path.getOrDefault("owner")
  valid_553650406 = validateParameter(valid_553650406, JString, required = true,
                                      default = nil)
  if valid_553650406 != nil:
    section.add "owner", valid_553650406
  var valid_553650407 = path.getOrDefault("repo")
  valid_553650407 = validateParameter(valid_553650407, JString, required = true,
                                      default = nil)
  if valid_553650407 != nil:
    section.add "repo", valid_553650407
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650408 = header.getOrDefault("Accept")
  valid_553650408 = validateParameter(valid_553650408, JString,
                                      required = false, default = nil)
  if valid_553650408 != nil:
    section.add "Accept", valid_553650408
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553650410: Call_PutReposOwnerRepoNotifications_553650403;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Mark notifications as read in a repository.
  ## Marking all notifications in a repository as "read" removes them from the
  ## default view on GitHub.com.
  ## 
  ## 
  let valid = call_553650410.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650410.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650410.makeUrl(scheme.get, call_553650410.host, call_553650410.base,
                                   call_553650410.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650410, uri, valid, content)

proc call*(call_553650411: Call_PutReposOwnerRepoNotifications_553650403;
           owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoNotifications
  ## Mark notifications as read in a repository.
  ## Marking all notifications in a repository as "read" removes them from the
  ## default view on GitHub.com.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650412 = newJObject()
  var header_553650413 = newJObject()
  var body_553650414 = newJObject()
  add(path_553650412, "owner", newJString(owner))
  add(header_553650413, "Accept", newJString(Accept))
  if body != nil:
    body_553650414 = body
  add(path_553650412, "repo", newJString(repo))
  result = call_553650411.call(path_553650412, nil, header_553650413, nil, body_553650414)

var putReposOwnerRepoNotifications* = Call_PutReposOwnerRepoNotifications_553650403(
    name: "putReposOwnerRepoNotifications", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/notifications",
    validator: validate_PutReposOwnerRepoNotifications_553650404, base: "/",
    makeUrl: url_PutReposOwnerRepoNotifications_553650405,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoNotifications_553650389 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoNotifications_553650391(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/notifications")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoNotifications_553650390(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## List your notifications in a repository
  ## List all notifications for the current user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650392 = path.getOrDefault("owner")
  valid_553650392 = validateParameter(valid_553650392, JString, required = true,
                                      default = nil)
  if valid_553650392 != nil:
    section.add "owner", valid_553650392
  var valid_553650393 = path.getOrDefault("repo")
  valid_553650393 = validateParameter(valid_553650393, JString, required = true,
                                      default = nil)
  if valid_553650393 != nil:
    section.add "repo", valid_553650393
  result.add "path", section
  ## parameters in `query` object:
  ##   participating: JBool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  ##   all: JBool
  ##      : True to show notifications marked as read.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_553650394 = query.getOrDefault("participating")
  valid_553650394 = validateParameter(valid_553650394, JBool, required = false,
                                      default = nil)
  if valid_553650394 != nil:
    section.add "participating", valid_553650394
  var valid_553650395 = query.getOrDefault("all")
  valid_553650395 = validateParameter(valid_553650395, JBool, required = false,
                                      default = nil)
  if valid_553650395 != nil:
    section.add "all", valid_553650395
  var valid_553650396 = query.getOrDefault("since")
  valid_553650396 = validateParameter(valid_553650396, JString,
                                      required = false, default = nil)
  if valid_553650396 != nil:
    section.add "since", valid_553650396
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650397 = header.getOrDefault("Accept")
  valid_553650397 = validateParameter(valid_553650397, JString,
                                      required = false, default = nil)
  if valid_553650397 != nil:
    section.add "Accept", valid_553650397
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650398: Call_GetReposOwnerRepoNotifications_553650389;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List your notifications in a repository
  ## List all notifications for the current user.
  ## 
  ## 
  let valid = call_553650398.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650398.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650398.makeUrl(scheme.get, call_553650398.host, call_553650398.base,
                                   call_553650398.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650398, uri, valid, content)

proc call*(call_553650399: Call_GetReposOwnerRepoNotifications_553650389;
           owner: string; repo: string; participating: bool = false;
           all: bool = false; Accept: string = ""; since: string = ""): Recallable =
  ## getReposOwnerRepoNotifications
  ## List your notifications in a repository
  ## List all notifications for the current user.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   participating: bool
  ##                : True to show only notifications in which the user is directly participating
  ## or mentioned.
  ## 
  ##   all: bool
  ##      : True to show notifications marked as read.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var path_553650400 = newJObject()
  var query_553650401 = newJObject()
  var header_553650402 = newJObject()
  add(path_553650400, "owner", newJString(owner))
  add(query_553650401, "participating", newJBool(participating))
  add(query_553650401, "all", newJBool(all))
  add(header_553650402, "Accept", newJString(Accept))
  add(path_553650400, "repo", newJString(repo))
  add(query_553650401, "since", newJString(since))
  result = call_553650399.call(path_553650400, query_553650401, header_553650402,
                               nil, nil)

var getReposOwnerRepoNotifications* = Call_GetReposOwnerRepoNotifications_553650389(
    name: "getReposOwnerRepoNotifications", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/notifications",
    validator: validate_GetReposOwnerRepoNotifications_553650390, base: "/",
    makeUrl: url_GetReposOwnerRepoNotifications_553650391,
    schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoPulls_553650429 = ref object of OpenApiRestCall_553648476
proc url_PostReposOwnerRepoPulls_553650431(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/pulls")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoPulls_553650430(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Create a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650432 = path.getOrDefault("owner")
  valid_553650432 = validateParameter(valid_553650432, JString, required = true,
                                      default = nil)
  if valid_553650432 != nil:
    section.add "owner", valid_553650432
  var valid_553650433 = path.getOrDefault("repo")
  valid_553650433 = validateParameter(valid_553650433, JString, required = true,
                                      default = nil)
  if valid_553650433 != nil:
    section.add "repo", valid_553650433
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650434 = header.getOrDefault("Accept")
  valid_553650434 = validateParameter(valid_553650434, JString,
                                      required = false, default = nil)
  if valid_553650434 != nil:
    section.add "Accept", valid_553650434
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553650436: Call_PostReposOwnerRepoPulls_553650429;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Create a pull request.
  ## 
  let valid = call_553650436.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650436.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650436.makeUrl(scheme.get, call_553650436.host, call_553650436.base,
                                   call_553650436.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650436, uri, valid, content)

proc call*(call_553650437: Call_PostReposOwnerRepoPulls_553650429;
           owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoPulls
  ## Create a pull request.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650438 = newJObject()
  var header_553650439 = newJObject()
  var body_553650440 = newJObject()
  add(path_553650438, "owner", newJString(owner))
  add(header_553650439, "Accept", newJString(Accept))
  if body != nil:
    body_553650440 = body
  add(path_553650438, "repo", newJString(repo))
  result = call_553650437.call(path_553650438, nil, header_553650439, nil, body_553650440)

var postReposOwnerRepoPulls* = Call_PostReposOwnerRepoPulls_553650429(
    name: "postReposOwnerRepoPulls", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls",
    validator: validate_PostReposOwnerRepoPulls_553650430, base: "/",
    makeUrl: url_PostReposOwnerRepoPulls_553650431, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPulls_553650415 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoPulls_553650417(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/pulls")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPulls_553650416(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List pull requests.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650418 = path.getOrDefault("owner")
  valid_553650418 = validateParameter(valid_553650418, JString, required = true,
                                      default = nil)
  if valid_553650418 != nil:
    section.add "owner", valid_553650418
  var valid_553650419 = path.getOrDefault("repo")
  valid_553650419 = validateParameter(valid_553650419, JString, required = true,
                                      default = nil)
  if valid_553650419 != nil:
    section.add "repo", valid_553650419
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString
  ##        : String to filter by state.
  ##   head: JString
  ##       : Filter pulls by head user and branch name in the format of 'user:ref-name'.
  ## Example: github:new-script-format.
  ## 
  ##   base: JString
  ##       : Filter pulls by base branch name. Example - gh-pages.
  section = newJObject()
  var valid_553650420 = query.getOrDefault("state")
  valid_553650420 = validateParameter(valid_553650420, JString,
                                      required = false,
                                      default = newJString("open"))
  if valid_553650420 != nil:
    section.add "state", valid_553650420
  var valid_553650421 = query.getOrDefault("head")
  valid_553650421 = validateParameter(valid_553650421, JString,
                                      required = false, default = nil)
  if valid_553650421 != nil:
    section.add "head", valid_553650421
  var valid_553650422 = query.getOrDefault("base")
  valid_553650422 = validateParameter(valid_553650422, JString,
                                      required = false, default = nil)
  if valid_553650422 != nil:
    section.add "base", valid_553650422
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650423 = header.getOrDefault("Accept")
  valid_553650423 = validateParameter(valid_553650423, JString,
                                      required = false, default = nil)
  if valid_553650423 != nil:
    section.add "Accept", valid_553650423
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650424: Call_GetReposOwnerRepoPulls_553650415;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List pull requests.
  ## 
  let valid = call_553650424.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650424.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650424.makeUrl(scheme.get, call_553650424.host, call_553650424.base,
                                   call_553650424.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650424, uri, valid, content)

proc call*(call_553650425: Call_GetReposOwnerRepoPulls_553650415; owner: string;
           repo: string; state: string = "open"; head: string = "";
           base: string = ""; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPulls
  ## List pull requests.
  ##   state: string
  ##        : String to filter by state.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   head: string
  ##       : Filter pulls by head user and branch name in the format of 'user:ref-name'.
  ## Example: github:new-script-format.
  ## 
  ##   base: string
  ##       : Filter pulls by base branch name. Example - gh-pages.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650426 = newJObject()
  var query_553650427 = newJObject()
  var header_553650428 = newJObject()
  add(query_553650427, "state", newJString(state))
  add(path_553650426, "owner", newJString(owner))
  add(query_553650427, "head", newJString(head))
  add(query_553650427, "base", newJString(base))
  add(header_553650428, "Accept", newJString(Accept))
  add(path_553650426, "repo", newJString(repo))
  result = call_553650425.call(path_553650426, query_553650427, header_553650428,
                               nil, nil)

var getReposOwnerRepoPulls* = Call_GetReposOwnerRepoPulls_553650415(
    name: "getReposOwnerRepoPulls", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls",
    validator: validate_GetReposOwnerRepoPulls_553650416, base: "/",
    makeUrl: url_GetReposOwnerRepoPulls_553650417, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsComments_553650441 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoPullsComments_553650443(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/pulls/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsComments_553650442(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## List comments in a repository.
  ## By default, Review Comments are ordered by ascending ID.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650444 = path.getOrDefault("owner")
  valid_553650444 = validateParameter(valid_553650444, JString, required = true,
                                      default = nil)
  if valid_553650444 != nil:
    section.add "owner", valid_553650444
  var valid_553650445 = path.getOrDefault("repo")
  valid_553650445 = validateParameter(valid_553650445, JString, required = true,
                                      default = nil)
  if valid_553650445 != nil:
    section.add "repo", valid_553650445
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_553650446 = query.getOrDefault("sort")
  valid_553650446 = validateParameter(valid_553650446, JString,
                                      required = false,
                                      default = newJString("created"))
  if valid_553650446 != nil:
    section.add "sort", valid_553650446
  var valid_553650447 = query.getOrDefault("direction")
  valid_553650447 = validateParameter(valid_553650447, JString,
                                      required = false, default = nil)
  if valid_553650447 != nil:
    section.add "direction", valid_553650447
  var valid_553650448 = query.getOrDefault("since")
  valid_553650448 = validateParameter(valid_553650448, JString,
                                      required = false, default = nil)
  if valid_553650448 != nil:
    section.add "since", valid_553650448
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650449 = header.getOrDefault("Accept")
  valid_553650449 = validateParameter(valid_553650449, JString,
                                      required = false, default = nil)
  if valid_553650449 != nil:
    section.add "Accept", valid_553650449
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650450: Call_GetReposOwnerRepoPullsComments_553650441;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List comments in a repository.
  ## By default, Review Comments are ordered by ascending ID.
  ## 
  ## 
  let valid = call_553650450.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650450.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650450.makeUrl(scheme.get, call_553650450.host, call_553650450.base,
                                   call_553650450.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650450, uri, valid, content)

proc call*(call_553650451: Call_GetReposOwnerRepoPullsComments_553650441;
           owner: string; repo: string; Accept: string = "";
           sort: string = "created"; direction: string = ""; since: string = ""): Recallable =
  ## getReposOwnerRepoPullsComments
  ## List comments in a repository.
  ## By default, Review Comments are ordered by ascending ID.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   sort: string
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var path_553650452 = newJObject()
  var query_553650453 = newJObject()
  var header_553650454 = newJObject()
  add(path_553650452, "owner", newJString(owner))
  add(header_553650454, "Accept", newJString(Accept))
  add(path_553650452, "repo", newJString(repo))
  add(query_553650453, "sort", newJString(sort))
  add(query_553650453, "direction", newJString(direction))
  add(query_553650453, "since", newJString(since))
  result = call_553650451.call(path_553650452, query_553650453, header_553650454,
                               nil, nil)

var getReposOwnerRepoPullsComments* = Call_GetReposOwnerRepoPullsComments_553650441(
    name: "getReposOwnerRepoPullsComments", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/comments",
    validator: validate_GetReposOwnerRepoPullsComments_553650442, base: "/",
    makeUrl: url_GetReposOwnerRepoPullsComments_553650443,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsCommentsCommentId_553650455 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoPullsCommentsCommentId_553650457(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/pulls/comments/"),
                 (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsCommentsCommentId_553650456(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get a single comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650458 = path.getOrDefault("owner")
  valid_553650458 = validateParameter(valid_553650458, JString, required = true,
                                      default = nil)
  if valid_553650458 != nil:
    section.add "owner", valid_553650458
  var valid_553650459 = path.getOrDefault("repo")
  valid_553650459 = validateParameter(valid_553650459, JString, required = true,
                                      default = nil)
  if valid_553650459 != nil:
    section.add "repo", valid_553650459
  var valid_553650460 = path.getOrDefault("commentId")
  valid_553650460 = validateParameter(valid_553650460, JInt, required = true,
                                      default = nil)
  if valid_553650460 != nil:
    section.add "commentId", valid_553650460
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650461 = header.getOrDefault("Accept")
  valid_553650461 = validateParameter(valid_553650461, JString,
                                      required = false, default = nil)
  if valid_553650461 != nil:
    section.add "Accept", valid_553650461
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650462: Call_GetReposOwnerRepoPullsCommentsCommentId_553650455;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get a single comment.
  ## 
  let valid = call_553650462.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650462.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650462.makeUrl(scheme.get, call_553650462.host, call_553650462.base,
                                   call_553650462.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650462, uri, valid, content)

proc call*(call_553650463: Call_GetReposOwnerRepoPullsCommentsCommentId_553650455;
           owner: string; repo: string; commentId: int; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsCommentsCommentId
  ## Get a single comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_553650464 = newJObject()
  var header_553650465 = newJObject()
  add(path_553650464, "owner", newJString(owner))
  add(header_553650465, "Accept", newJString(Accept))
  add(path_553650464, "repo", newJString(repo))
  add(path_553650464, "commentId", newJInt(commentId))
  result = call_553650463.call(path_553650464, nil, header_553650465, nil, nil)

var getReposOwnerRepoPullsCommentsCommentId* = Call_GetReposOwnerRepoPullsCommentsCommentId_553650455(
    name: "getReposOwnerRepoPullsCommentsCommentId", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/comments/{commentId}",
    validator: validate_GetReposOwnerRepoPullsCommentsCommentId_553650456,
    base: "/", makeUrl: url_GetReposOwnerRepoPullsCommentsCommentId_553650457,
    schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoPullsCommentsCommentId_553650477 = ref object of OpenApiRestCall_553648476
proc url_PatchReposOwnerRepoPullsCommentsCommentId_553650479(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/pulls/comments/"),
                 (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoPullsCommentsCommentId_553650478(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode; content: string = ""): JsonNode {.nosinks.} =
  ## Edit a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650480 = path.getOrDefault("owner")
  valid_553650480 = validateParameter(valid_553650480, JString, required = true,
                                      default = nil)
  if valid_553650480 != nil:
    section.add "owner", valid_553650480
  var valid_553650481 = path.getOrDefault("repo")
  valid_553650481 = validateParameter(valid_553650481, JString, required = true,
                                      default = nil)
  if valid_553650481 != nil:
    section.add "repo", valid_553650481
  var valid_553650482 = path.getOrDefault("commentId")
  valid_553650482 = validateParameter(valid_553650482, JInt, required = true,
                                      default = nil)
  if valid_553650482 != nil:
    section.add "commentId", valid_553650482
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650483 = header.getOrDefault("Accept")
  valid_553650483 = validateParameter(valid_553650483, JString,
                                      required = false, default = nil)
  if valid_553650483 != nil:
    section.add "Accept", valid_553650483
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553650485: Call_PatchReposOwnerRepoPullsCommentsCommentId_553650477;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Edit a comment.
  ## 
  let valid = call_553650485.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650485.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650485.makeUrl(scheme.get, call_553650485.host, call_553650485.base,
                                   call_553650485.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650485, uri, valid, content)

proc call*(call_553650486: Call_PatchReposOwnerRepoPullsCommentsCommentId_553650477;
           owner: string; body: JsonNode; repo: string; commentId: int;
           Accept: string = ""): Recallable =
  ## patchReposOwnerRepoPullsCommentsCommentId
  ## Edit a comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_553650487 = newJObject()
  var header_553650488 = newJObject()
  var body_553650489 = newJObject()
  add(path_553650487, "owner", newJString(owner))
  add(header_553650488, "Accept", newJString(Accept))
  if body != nil:
    body_553650489 = body
  add(path_553650487, "repo", newJString(repo))
  add(path_553650487, "commentId", newJInt(commentId))
  result = call_553650486.call(path_553650487, nil, header_553650488, nil, body_553650489)

var patchReposOwnerRepoPullsCommentsCommentId* = Call_PatchReposOwnerRepoPullsCommentsCommentId_553650477(
    name: "patchReposOwnerRepoPullsCommentsCommentId",
    meth: HttpMethod.HttpPatch, host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/comments/{commentId}",
    validator: validate_PatchReposOwnerRepoPullsCommentsCommentId_553650478,
    base: "/", makeUrl: url_PatchReposOwnerRepoPullsCommentsCommentId_553650479,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoPullsCommentsCommentId_553650466 = ref object of OpenApiRestCall_553648476
proc url_DeleteReposOwnerRepoPullsCommentsCommentId_553650468(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "commentId" in path, "`commentId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/pulls/comments/"),
                 (kind: VariableSegment, value: "commentId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoPullsCommentsCommentId_553650467(
    path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
    body: JsonNode; content: string = ""): JsonNode {.nosinks.} =
  ## Delete a comment.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   commentId: JInt (required)
  ##            : Id of comment.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650469 = path.getOrDefault("owner")
  valid_553650469 = validateParameter(valid_553650469, JString, required = true,
                                      default = nil)
  if valid_553650469 != nil:
    section.add "owner", valid_553650469
  var valid_553650470 = path.getOrDefault("repo")
  valid_553650470 = validateParameter(valid_553650470, JString, required = true,
                                      default = nil)
  if valid_553650470 != nil:
    section.add "repo", valid_553650470
  var valid_553650471 = path.getOrDefault("commentId")
  valid_553650471 = validateParameter(valid_553650471, JInt, required = true,
                                      default = nil)
  if valid_553650471 != nil:
    section.add "commentId", valid_553650471
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650472 = header.getOrDefault("Accept")
  valid_553650472 = validateParameter(valid_553650472, JString,
                                      required = false, default = nil)
  if valid_553650472 != nil:
    section.add "Accept", valid_553650472
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650473: Call_DeleteReposOwnerRepoPullsCommentsCommentId_553650466;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Delete a comment.
  ## 
  let valid = call_553650473.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650473.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650473.makeUrl(scheme.get, call_553650473.host, call_553650473.base,
                                   call_553650473.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650473, uri, valid, content)

proc call*(call_553650474: Call_DeleteReposOwnerRepoPullsCommentsCommentId_553650466;
           owner: string; repo: string; commentId: int; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoPullsCommentsCommentId
  ## Delete a comment.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   commentId: int (required)
  ##            : Id of comment.
  var path_553650475 = newJObject()
  var header_553650476 = newJObject()
  add(path_553650475, "owner", newJString(owner))
  add(header_553650476, "Accept", newJString(Accept))
  add(path_553650475, "repo", newJString(repo))
  add(path_553650475, "commentId", newJInt(commentId))
  result = call_553650474.call(path_553650475, nil, header_553650476, nil, nil)

var deleteReposOwnerRepoPullsCommentsCommentId* = Call_DeleteReposOwnerRepoPullsCommentsCommentId_553650466(
    name: "deleteReposOwnerRepoPullsCommentsCommentId",
    meth: HttpMethod.HttpDelete, host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/comments/{commentId}",
    validator: validate_DeleteReposOwnerRepoPullsCommentsCommentId_553650467,
    base: "/", makeUrl: url_DeleteReposOwnerRepoPullsCommentsCommentId_553650468,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumber_553650490 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoPullsNumber_553650492(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/pulls/"),
                 (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumber_553650491(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get a single pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650493 = path.getOrDefault("owner")
  valid_553650493 = validateParameter(valid_553650493, JString, required = true,
                                      default = nil)
  if valid_553650493 != nil:
    section.add "owner", valid_553650493
  var valid_553650494 = path.getOrDefault("number")
  valid_553650494 = validateParameter(valid_553650494, JInt, required = true,
                                      default = nil)
  if valid_553650494 != nil:
    section.add "number", valid_553650494
  var valid_553650495 = path.getOrDefault("repo")
  valid_553650495 = validateParameter(valid_553650495, JString, required = true,
                                      default = nil)
  if valid_553650495 != nil:
    section.add "repo", valid_553650495
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650496 = header.getOrDefault("Accept")
  valid_553650496 = validateParameter(valid_553650496, JString,
                                      required = false, default = nil)
  if valid_553650496 != nil:
    section.add "Accept", valid_553650496
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650497: Call_GetReposOwnerRepoPullsNumber_553650490;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get a single pull request.
  ## 
  let valid = call_553650497.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650497.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650497.makeUrl(scheme.get, call_553650497.host, call_553650497.base,
                                   call_553650497.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650497, uri, valid, content)

proc call*(call_553650498: Call_GetReposOwnerRepoPullsNumber_553650490;
           owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumber
  ## Get a single pull request.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650499 = newJObject()
  var header_553650500 = newJObject()
  add(path_553650499, "owner", newJString(owner))
  add(path_553650499, "number", newJInt(number))
  add(header_553650500, "Accept", newJString(Accept))
  add(path_553650499, "repo", newJString(repo))
  result = call_553650498.call(path_553650499, nil, header_553650500, nil, nil)

var getReposOwnerRepoPullsNumber* = Call_GetReposOwnerRepoPullsNumber_553650490(
    name: "getReposOwnerRepoPullsNumber", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}",
    validator: validate_GetReposOwnerRepoPullsNumber_553650491, base: "/",
    makeUrl: url_GetReposOwnerRepoPullsNumber_553650492, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoPullsNumber_553650501 = ref object of OpenApiRestCall_553648476
proc url_PatchReposOwnerRepoPullsNumber_553650503(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/pulls/"),
                 (kind: VariableSegment, value: "number")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoPullsNumber_553650502(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Update a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650504 = path.getOrDefault("owner")
  valid_553650504 = validateParameter(valid_553650504, JString, required = true,
                                      default = nil)
  if valid_553650504 != nil:
    section.add "owner", valid_553650504
  var valid_553650505 = path.getOrDefault("number")
  valid_553650505 = validateParameter(valid_553650505, JInt, required = true,
                                      default = nil)
  if valid_553650505 != nil:
    section.add "number", valid_553650505
  var valid_553650506 = path.getOrDefault("repo")
  valid_553650506 = validateParameter(valid_553650506, JString, required = true,
                                      default = nil)
  if valid_553650506 != nil:
    section.add "repo", valid_553650506
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650507 = header.getOrDefault("Accept")
  valid_553650507 = validateParameter(valid_553650507, JString,
                                      required = false, default = nil)
  if valid_553650507 != nil:
    section.add "Accept", valid_553650507
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553650509: Call_PatchReposOwnerRepoPullsNumber_553650501;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Update a pull request.
  ## 
  let valid = call_553650509.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650509.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650509.makeUrl(scheme.get, call_553650509.host, call_553650509.base,
                                   call_553650509.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650509, uri, valid, content)

proc call*(call_553650510: Call_PatchReposOwnerRepoPullsNumber_553650501;
           owner: string; number: int; body: JsonNode; repo: string;
           Accept: string = ""): Recallable =
  ## patchReposOwnerRepoPullsNumber
  ## Update a pull request.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650511 = newJObject()
  var header_553650512 = newJObject()
  var body_553650513 = newJObject()
  add(path_553650511, "owner", newJString(owner))
  add(path_553650511, "number", newJInt(number))
  add(header_553650512, "Accept", newJString(Accept))
  if body != nil:
    body_553650513 = body
  add(path_553650511, "repo", newJString(repo))
  result = call_553650510.call(path_553650511, nil, header_553650512, nil, body_553650513)

var patchReposOwnerRepoPullsNumber* = Call_PatchReposOwnerRepoPullsNumber_553650501(
    name: "patchReposOwnerRepoPullsNumber", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}",
    validator: validate_PatchReposOwnerRepoPullsNumber_553650502, base: "/",
    makeUrl: url_PatchReposOwnerRepoPullsNumber_553650503,
    schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoPullsNumberComments_553650525 = ref object of OpenApiRestCall_553648476
proc url_PostReposOwnerRepoPullsNumberComments_553650527(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/pulls/"),
                 (kind: VariableSegment, value: "number"),
                 (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoPullsNumberComments_553650526(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Create a comment.
  ##   #TODO Alternative input ( http://developer.github.com/v3/pulls/comments/ )
  ##   description: |
  ##     Alternative Input.
  ##     Instead of passing commit_id, path, and position you can reply to an
  ##     existing Pull Request Comment like this:
  ## 
  ##         body
  ##            Required string
  ##         in_reply_to
  ##            Required number - Comment id to reply to.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650528 = path.getOrDefault("owner")
  valid_553650528 = validateParameter(valid_553650528, JString, required = true,
                                      default = nil)
  if valid_553650528 != nil:
    section.add "owner", valid_553650528
  var valid_553650529 = path.getOrDefault("number")
  valid_553650529 = validateParameter(valid_553650529, JInt, required = true,
                                      default = nil)
  if valid_553650529 != nil:
    section.add "number", valid_553650529
  var valid_553650530 = path.getOrDefault("repo")
  valid_553650530 = validateParameter(valid_553650530, JString, required = true,
                                      default = nil)
  if valid_553650530 != nil:
    section.add "repo", valid_553650530
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650531 = header.getOrDefault("Accept")
  valid_553650531 = validateParameter(valid_553650531, JString,
                                      required = false, default = nil)
  if valid_553650531 != nil:
    section.add "Accept", valid_553650531
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553650533: Call_PostReposOwnerRepoPullsNumberComments_553650525;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Create a comment.
  ##   #TODO Alternative input ( http://developer.github.com/v3/pulls/comments/ )
  ##   description: |
  ##     Alternative Input.
  ##     Instead of passing commit_id, path, and position you can reply to an
  ##     existing Pull Request Comment like this:
  ## 
  ##         body
  ##            Required string
  ##         in_reply_to
  ##            Required number - Comment id to reply to.
  ## 
  ## 
  let valid = call_553650533.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650533.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650533.makeUrl(scheme.get, call_553650533.host, call_553650533.base,
                                   call_553650533.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650533, uri, valid, content)

proc call*(call_553650534: Call_PostReposOwnerRepoPullsNumberComments_553650525;
           owner: string; number: int; body: JsonNode; repo: string;
           Accept: string = ""): Recallable =
  ## postReposOwnerRepoPullsNumberComments
  ## Create a comment.
  ##   #TODO Alternative input ( http://developer.github.com/v3/pulls/comments/ )
  ##   description: |
  ##     Alternative Input.
  ##     Instead of passing commit_id, path, and position you can reply to an
  ##     existing Pull Request Comment like this:
  ## 
  ##         body
  ##            Required string
  ##         in_reply_to
  ##            Required number - Comment id to reply to.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650535 = newJObject()
  var header_553650536 = newJObject()
  var body_553650537 = newJObject()
  add(path_553650535, "owner", newJString(owner))
  add(path_553650535, "number", newJInt(number))
  add(header_553650536, "Accept", newJString(Accept))
  if body != nil:
    body_553650537 = body
  add(path_553650535, "repo", newJString(repo))
  result = call_553650534.call(path_553650535, nil, header_553650536, nil, body_553650537)

var postReposOwnerRepoPullsNumberComments* = Call_PostReposOwnerRepoPullsNumberComments_553650525(
    name: "postReposOwnerRepoPullsNumberComments", meth: HttpMethod.HttpPost,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/{number}/comments",
    validator: validate_PostReposOwnerRepoPullsNumberComments_553650526,
    base: "/", makeUrl: url_PostReposOwnerRepoPullsNumberComments_553650527,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberComments_553650514 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoPullsNumberComments_553650516(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/pulls/"),
                 (kind: VariableSegment, value: "number"),
                 (kind: ConstantSegment, value: "/comments")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberComments_553650515(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## List comments on a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650517 = path.getOrDefault("owner")
  valid_553650517 = validateParameter(valid_553650517, JString, required = true,
                                      default = nil)
  if valid_553650517 != nil:
    section.add "owner", valid_553650517
  var valid_553650518 = path.getOrDefault("number")
  valid_553650518 = validateParameter(valid_553650518, JInt, required = true,
                                      default = nil)
  if valid_553650518 != nil:
    section.add "number", valid_553650518
  var valid_553650519 = path.getOrDefault("repo")
  valid_553650519 = validateParameter(valid_553650519, JString, required = true,
                                      default = nil)
  if valid_553650519 != nil:
    section.add "repo", valid_553650519
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650520 = header.getOrDefault("Accept")
  valid_553650520 = validateParameter(valid_553650520, JString,
                                      required = false, default = nil)
  if valid_553650520 != nil:
    section.add "Accept", valid_553650520
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650521: Call_GetReposOwnerRepoPullsNumberComments_553650514;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List comments on a pull request.
  ## 
  let valid = call_553650521.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650521.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650521.makeUrl(scheme.get, call_553650521.host, call_553650521.base,
                                   call_553650521.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650521, uri, valid, content)

proc call*(call_553650522: Call_GetReposOwnerRepoPullsNumberComments_553650514;
           owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberComments
  ## List comments on a pull request.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650523 = newJObject()
  var header_553650524 = newJObject()
  add(path_553650523, "owner", newJString(owner))
  add(path_553650523, "number", newJInt(number))
  add(header_553650524, "Accept", newJString(Accept))
  add(path_553650523, "repo", newJString(repo))
  result = call_553650522.call(path_553650523, nil, header_553650524, nil, nil)

var getReposOwnerRepoPullsNumberComments* = Call_GetReposOwnerRepoPullsNumberComments_553650514(
    name: "getReposOwnerRepoPullsNumberComments", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/{number}/comments",
    validator: validate_GetReposOwnerRepoPullsNumberComments_553650515,
    base: "/", makeUrl: url_GetReposOwnerRepoPullsNumberComments_553650516,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberCommits_553650538 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoPullsNumberCommits_553650540(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/pulls/"),
                 (kind: VariableSegment, value: "number"),
                 (kind: ConstantSegment, value: "/commits")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberCommits_553650539(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## List commits on a pull request.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650541 = path.getOrDefault("owner")
  valid_553650541 = validateParameter(valid_553650541, JString, required = true,
                                      default = nil)
  if valid_553650541 != nil:
    section.add "owner", valid_553650541
  var valid_553650542 = path.getOrDefault("number")
  valid_553650542 = validateParameter(valid_553650542, JInt, required = true,
                                      default = nil)
  if valid_553650542 != nil:
    section.add "number", valid_553650542
  var valid_553650543 = path.getOrDefault("repo")
  valid_553650543 = validateParameter(valid_553650543, JString, required = true,
                                      default = nil)
  if valid_553650543 != nil:
    section.add "repo", valid_553650543
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650544 = header.getOrDefault("Accept")
  valid_553650544 = validateParameter(valid_553650544, JString,
                                      required = false, default = nil)
  if valid_553650544 != nil:
    section.add "Accept", valid_553650544
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650545: Call_GetReposOwnerRepoPullsNumberCommits_553650538;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List commits on a pull request.
  ## 
  let valid = call_553650545.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650545.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650545.makeUrl(scheme.get, call_553650545.host, call_553650545.base,
                                   call_553650545.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650545, uri, valid, content)

proc call*(call_553650546: Call_GetReposOwnerRepoPullsNumberCommits_553650538;
           owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberCommits
  ## List commits on a pull request.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650547 = newJObject()
  var header_553650548 = newJObject()
  add(path_553650547, "owner", newJString(owner))
  add(path_553650547, "number", newJInt(number))
  add(header_553650548, "Accept", newJString(Accept))
  add(path_553650547, "repo", newJString(repo))
  result = call_553650546.call(path_553650547, nil, header_553650548, nil, nil)

var getReposOwnerRepoPullsNumberCommits* = Call_GetReposOwnerRepoPullsNumberCommits_553650538(
    name: "getReposOwnerRepoPullsNumberCommits", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/pulls/{number}/commits",
    validator: validate_GetReposOwnerRepoPullsNumberCommits_553650539,
    base: "/", makeUrl: url_GetReposOwnerRepoPullsNumberCommits_553650540,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberFiles_553650549 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoPullsNumberFiles_553650551(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/pulls/"),
                 (kind: VariableSegment, value: "number"),
                 (kind: ConstantSegment, value: "/files")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberFiles_553650550(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## List pull requests files.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650552 = path.getOrDefault("owner")
  valid_553650552 = validateParameter(valid_553650552, JString, required = true,
                                      default = nil)
  if valid_553650552 != nil:
    section.add "owner", valid_553650552
  var valid_553650553 = path.getOrDefault("number")
  valid_553650553 = validateParameter(valid_553650553, JInt, required = true,
                                      default = nil)
  if valid_553650553 != nil:
    section.add "number", valid_553650553
  var valid_553650554 = path.getOrDefault("repo")
  valid_553650554 = validateParameter(valid_553650554, JString, required = true,
                                      default = nil)
  if valid_553650554 != nil:
    section.add "repo", valid_553650554
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650555 = header.getOrDefault("Accept")
  valid_553650555 = validateParameter(valid_553650555, JString,
                                      required = false, default = nil)
  if valid_553650555 != nil:
    section.add "Accept", valid_553650555
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650556: Call_GetReposOwnerRepoPullsNumberFiles_553650549;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List pull requests files.
  ## 
  let valid = call_553650556.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650556.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650556.makeUrl(scheme.get, call_553650556.host, call_553650556.base,
                                   call_553650556.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650556, uri, valid, content)

proc call*(call_553650557: Call_GetReposOwnerRepoPullsNumberFiles_553650549;
           owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberFiles
  ## List pull requests files.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650558 = newJObject()
  var header_553650559 = newJObject()
  add(path_553650558, "owner", newJString(owner))
  add(path_553650558, "number", newJInt(number))
  add(header_553650559, "Accept", newJString(Accept))
  add(path_553650558, "repo", newJString(repo))
  result = call_553650557.call(path_553650558, nil, header_553650559, nil, nil)

var getReposOwnerRepoPullsNumberFiles* = Call_GetReposOwnerRepoPullsNumberFiles_553650549(
    name: "getReposOwnerRepoPullsNumberFiles", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/files",
    validator: validate_GetReposOwnerRepoPullsNumberFiles_553650550, base: "/",
    makeUrl: url_GetReposOwnerRepoPullsNumberFiles_553650551,
    schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoPullsNumberMerge_553650571 = ref object of OpenApiRestCall_553648476
proc url_PutReposOwnerRepoPullsNumberMerge_553650573(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/pulls/"),
                 (kind: VariableSegment, value: "number"),
                 (kind: ConstantSegment, value: "/merge")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoPullsNumberMerge_553650572(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Merge a pull request (Merge Button's)
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650574 = path.getOrDefault("owner")
  valid_553650574 = validateParameter(valid_553650574, JString, required = true,
                                      default = nil)
  if valid_553650574 != nil:
    section.add "owner", valid_553650574
  var valid_553650575 = path.getOrDefault("number")
  valid_553650575 = validateParameter(valid_553650575, JInt, required = true,
                                      default = nil)
  if valid_553650575 != nil:
    section.add "number", valid_553650575
  var valid_553650576 = path.getOrDefault("repo")
  valid_553650576 = validateParameter(valid_553650576, JString, required = true,
                                      default = nil)
  if valid_553650576 != nil:
    section.add "repo", valid_553650576
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650577 = header.getOrDefault("Accept")
  valid_553650577 = validateParameter(valid_553650577, JString,
                                      required = false, default = nil)
  if valid_553650577 != nil:
    section.add "Accept", valid_553650577
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553650579: Call_PutReposOwnerRepoPullsNumberMerge_553650571;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Merge a pull request (Merge Button's)
  ## 
  let valid = call_553650579.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650579.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650579.makeUrl(scheme.get, call_553650579.host, call_553650579.base,
                                   call_553650579.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650579, uri, valid, content)

proc call*(call_553650580: Call_PutReposOwnerRepoPullsNumberMerge_553650571;
           owner: string; number: int; body: JsonNode; repo: string;
           Accept: string = ""): Recallable =
  ## putReposOwnerRepoPullsNumberMerge
  ## Merge a pull request (Merge Button's)
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650581 = newJObject()
  var header_553650582 = newJObject()
  var body_553650583 = newJObject()
  add(path_553650581, "owner", newJString(owner))
  add(path_553650581, "number", newJInt(number))
  add(header_553650582, "Accept", newJString(Accept))
  if body != nil:
    body_553650583 = body
  add(path_553650581, "repo", newJString(repo))
  result = call_553650580.call(path_553650581, nil, header_553650582, nil, body_553650583)

var putReposOwnerRepoPullsNumberMerge* = Call_PutReposOwnerRepoPullsNumberMerge_553650571(
    name: "putReposOwnerRepoPullsNumberMerge", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/merge",
    validator: validate_PutReposOwnerRepoPullsNumberMerge_553650572, base: "/",
    makeUrl: url_PutReposOwnerRepoPullsNumberMerge_553650573,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoPullsNumberMerge_553650560 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoPullsNumberMerge_553650562(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "number" in path, "`number` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/pulls/"),
                 (kind: VariableSegment, value: "number"),
                 (kind: ConstantSegment, value: "/merge")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoPullsNumberMerge_553650561(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get if a pull request has been merged.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   number: JInt (required)
  ##         : Id of pull.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650563 = path.getOrDefault("owner")
  valid_553650563 = validateParameter(valid_553650563, JString, required = true,
                                      default = nil)
  if valid_553650563 != nil:
    section.add "owner", valid_553650563
  var valid_553650564 = path.getOrDefault("number")
  valid_553650564 = validateParameter(valid_553650564, JInt, required = true,
                                      default = nil)
  if valid_553650564 != nil:
    section.add "number", valid_553650564
  var valid_553650565 = path.getOrDefault("repo")
  valid_553650565 = validateParameter(valid_553650565, JString, required = true,
                                      default = nil)
  if valid_553650565 != nil:
    section.add "repo", valid_553650565
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650566 = header.getOrDefault("Accept")
  valid_553650566 = validateParameter(valid_553650566, JString,
                                      required = false, default = nil)
  if valid_553650566 != nil:
    section.add "Accept", valid_553650566
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650567: Call_GetReposOwnerRepoPullsNumberMerge_553650560;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get if a pull request has been merged.
  ## 
  let valid = call_553650567.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650567.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650567.makeUrl(scheme.get, call_553650567.host, call_553650567.base,
                                   call_553650567.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650567, uri, valid, content)

proc call*(call_553650568: Call_GetReposOwnerRepoPullsNumberMerge_553650560;
           owner: string; number: int; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoPullsNumberMerge
  ## Get if a pull request has been merged.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   number: int (required)
  ##         : Id of pull.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650569 = newJObject()
  var header_553650570 = newJObject()
  add(path_553650569, "owner", newJString(owner))
  add(path_553650569, "number", newJInt(number))
  add(header_553650570, "Accept", newJString(Accept))
  add(path_553650569, "repo", newJString(repo))
  result = call_553650568.call(path_553650569, nil, header_553650570, nil, nil)

var getReposOwnerRepoPullsNumberMerge* = Call_GetReposOwnerRepoPullsNumberMerge_553650560(
    name: "getReposOwnerRepoPullsNumberMerge", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/pulls/{number}/merge",
    validator: validate_GetReposOwnerRepoPullsNumberMerge_553650561, base: "/",
    makeUrl: url_GetReposOwnerRepoPullsNumberMerge_553650562,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReadme_553650584 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoReadme_553650586(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/readme")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReadme_553650585(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Get the README.
  ## This method returns the preferred README for a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650587 = path.getOrDefault("owner")
  valid_553650587 = validateParameter(valid_553650587, JString, required = true,
                                      default = nil)
  if valid_553650587 != nil:
    section.add "owner", valid_553650587
  var valid_553650588 = path.getOrDefault("repo")
  valid_553650588 = validateParameter(valid_553650588, JString, required = true,
                                      default = nil)
  if valid_553650588 != nil:
    section.add "repo", valid_553650588
  result.add "path", section
  ## parameters in `query` object:
  ##   ref: JString
  ##      : The String name of the Commit/Branch/Tag. Defaults to master.
  section = newJObject()
  var valid_553650589 = query.getOrDefault("ref")
  valid_553650589 = validateParameter(valid_553650589, JString,
                                      required = false, default = nil)
  if valid_553650589 != nil:
    section.add "ref", valid_553650589
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650590 = header.getOrDefault("Accept")
  valid_553650590 = validateParameter(valid_553650590, JString,
                                      required = false, default = nil)
  if valid_553650590 != nil:
    section.add "Accept", valid_553650590
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650591: Call_GetReposOwnerRepoReadme_553650584;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get the README.
  ## This method returns the preferred README for a repository.
  ## 
  ## 
  let valid = call_553650591.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650591.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650591.makeUrl(scheme.get, call_553650591.host, call_553650591.base,
                                   call_553650591.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650591, uri, valid, content)

proc call*(call_553650592: Call_GetReposOwnerRepoReadme_553650584;
           owner: string; repo: string; Accept: string = ""; `ref`: string = ""): Recallable =
  ## getReposOwnerRepoReadme
  ## Get the README.
  ## This method returns the preferred README for a repository.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   ref: string
  ##      : The String name of the Commit/Branch/Tag. Defaults to master.
  var path_553650593 = newJObject()
  var query_553650594 = newJObject()
  var header_553650595 = newJObject()
  add(path_553650593, "owner", newJString(owner))
  add(header_553650595, "Accept", newJString(Accept))
  add(path_553650593, "repo", newJString(repo))
  add(query_553650594, "ref", newJString(`ref`))
  result = call_553650592.call(path_553650593, query_553650594, header_553650595,
                               nil, nil)

var getReposOwnerRepoReadme* = Call_GetReposOwnerRepoReadme_553650584(
    name: "getReposOwnerRepoReadme", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/readme",
    validator: validate_GetReposOwnerRepoReadme_553650585, base: "/",
    makeUrl: url_GetReposOwnerRepoReadme_553650586, schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoReleases_553650606 = ref object of OpenApiRestCall_553648476
proc url_PostReposOwnerRepoReleases_553650608(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/releases")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoReleases_553650607(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Create a release
  ## Users with push access to the repository can create a release.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650609 = path.getOrDefault("owner")
  valid_553650609 = validateParameter(valid_553650609, JString, required = true,
                                      default = nil)
  if valid_553650609 != nil:
    section.add "owner", valid_553650609
  var valid_553650610 = path.getOrDefault("repo")
  valid_553650610 = validateParameter(valid_553650610, JString, required = true,
                                      default = nil)
  if valid_553650610 != nil:
    section.add "repo", valid_553650610
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650611 = header.getOrDefault("Accept")
  valid_553650611 = validateParameter(valid_553650611, JString,
                                      required = false, default = nil)
  if valid_553650611 != nil:
    section.add "Accept", valid_553650611
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553650613: Call_PostReposOwnerRepoReleases_553650606;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Create a release
  ## Users with push access to the repository can create a release.
  ## 
  ## 
  let valid = call_553650613.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650613.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650613.makeUrl(scheme.get, call_553650613.host, call_553650613.base,
                                   call_553650613.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650613, uri, valid, content)

proc call*(call_553650614: Call_PostReposOwnerRepoReleases_553650606;
           owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## postReposOwnerRepoReleases
  ## Create a release
  ## Users with push access to the repository can create a release.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650615 = newJObject()
  var header_553650616 = newJObject()
  var body_553650617 = newJObject()
  add(path_553650615, "owner", newJString(owner))
  add(header_553650616, "Accept", newJString(Accept))
  if body != nil:
    body_553650617 = body
  add(path_553650615, "repo", newJString(repo))
  result = call_553650614.call(path_553650615, nil, header_553650616, nil, body_553650617)

var postReposOwnerRepoReleases* = Call_PostReposOwnerRepoReleases_553650606(
    name: "postReposOwnerRepoReleases", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases",
    validator: validate_PostReposOwnerRepoReleases_553650607, base: "/",
    makeUrl: url_PostReposOwnerRepoReleases_553650608, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleases_553650596 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoReleases_553650598(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/releases")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleases_553650597(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Users with push access to the repository will receive all releases (i.e., published releases and draft releases). Users with pull access will receive published releases only
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650599 = path.getOrDefault("owner")
  valid_553650599 = validateParameter(valid_553650599, JString, required = true,
                                      default = nil)
  if valid_553650599 != nil:
    section.add "owner", valid_553650599
  var valid_553650600 = path.getOrDefault("repo")
  valid_553650600 = validateParameter(valid_553650600, JString, required = true,
                                      default = nil)
  if valid_553650600 != nil:
    section.add "repo", valid_553650600
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650601 = header.getOrDefault("Accept")
  valid_553650601 = validateParameter(valid_553650601, JString,
                                      required = false, default = nil)
  if valid_553650601 != nil:
    section.add "Accept", valid_553650601
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650602: Call_GetReposOwnerRepoReleases_553650596;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Users with push access to the repository will receive all releases (i.e., published releases and draft releases). Users with pull access will receive published releases only
  ## 
  let valid = call_553650602.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650602.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650602.makeUrl(scheme.get, call_553650602.host, call_553650602.base,
                                   call_553650602.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650602, uri, valid, content)

proc call*(call_553650603: Call_GetReposOwnerRepoReleases_553650596;
           owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleases
  ## Users with push access to the repository will receive all releases (i.e., published releases and draft releases). Users with pull access will receive published releases only
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650604 = newJObject()
  var header_553650605 = newJObject()
  add(path_553650604, "owner", newJString(owner))
  add(header_553650605, "Accept", newJString(Accept))
  add(path_553650604, "repo", newJString(repo))
  result = call_553650603.call(path_553650604, nil, header_553650605, nil, nil)

var getReposOwnerRepoReleases* = Call_GetReposOwnerRepoReleases_553650596(
    name: "getReposOwnerRepoReleases", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases",
    validator: validate_GetReposOwnerRepoReleases_553650597, base: "/",
    makeUrl: url_GetReposOwnerRepoReleases_553650598, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleasesAssetsId_553650618 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoReleasesAssetsId_553650620(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/releases/assets/"),
                 (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleasesAssetsId_553650619(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get a single release asset
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650621 = path.getOrDefault("owner")
  valid_553650621 = validateParameter(valid_553650621, JString, required = true,
                                      default = nil)
  if valid_553650621 != nil:
    section.add "owner", valid_553650621
  var valid_553650622 = path.getOrDefault("id")
  valid_553650622 = validateParameter(valid_553650622, JString, required = true,
                                      default = nil)
  if valid_553650622 != nil:
    section.add "id", valid_553650622
  var valid_553650623 = path.getOrDefault("repo")
  valid_553650623 = validateParameter(valid_553650623, JString, required = true,
                                      default = nil)
  if valid_553650623 != nil:
    section.add "repo", valid_553650623
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650624 = header.getOrDefault("Accept")
  valid_553650624 = validateParameter(valid_553650624, JString,
                                      required = false, default = nil)
  if valid_553650624 != nil:
    section.add "Accept", valid_553650624
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650625: Call_GetReposOwnerRepoReleasesAssetsId_553650618;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get a single release asset
  ## 
  let valid = call_553650625.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650625.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650625.makeUrl(scheme.get, call_553650625.host, call_553650625.base,
                                   call_553650625.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650625, uri, valid, content)

proc call*(call_553650626: Call_GetReposOwnerRepoReleasesAssetsId_553650618;
           owner: string; id: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleasesAssetsId
  ## Get a single release asset
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650627 = newJObject()
  var header_553650628 = newJObject()
  add(path_553650627, "owner", newJString(owner))
  add(path_553650627, "id", newJString(id))
  add(header_553650628, "Accept", newJString(Accept))
  add(path_553650627, "repo", newJString(repo))
  result = call_553650626.call(path_553650627, nil, header_553650628, nil, nil)

var getReposOwnerRepoReleasesAssetsId* = Call_GetReposOwnerRepoReleasesAssetsId_553650618(
    name: "getReposOwnerRepoReleasesAssetsId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/assets/{id}",
    validator: validate_GetReposOwnerRepoReleasesAssetsId_553650619, base: "/",
    makeUrl: url_GetReposOwnerRepoReleasesAssetsId_553650620,
    schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoReleasesAssetsId_553650640 = ref object of OpenApiRestCall_553648476
proc url_PatchReposOwnerRepoReleasesAssetsId_553650642(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/releases/assets/"),
                 (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoReleasesAssetsId_553650641(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Edit a release asset
  ## Users with push access to the repository can edit a release asset.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650643 = path.getOrDefault("owner")
  valid_553650643 = validateParameter(valid_553650643, JString, required = true,
                                      default = nil)
  if valid_553650643 != nil:
    section.add "owner", valid_553650643
  var valid_553650644 = path.getOrDefault("id")
  valid_553650644 = validateParameter(valid_553650644, JString, required = true,
                                      default = nil)
  if valid_553650644 != nil:
    section.add "id", valid_553650644
  var valid_553650645 = path.getOrDefault("repo")
  valid_553650645 = validateParameter(valid_553650645, JString, required = true,
                                      default = nil)
  if valid_553650645 != nil:
    section.add "repo", valid_553650645
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650646 = header.getOrDefault("Accept")
  valid_553650646 = validateParameter(valid_553650646, JString,
                                      required = false, default = nil)
  if valid_553650646 != nil:
    section.add "Accept", valid_553650646
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553650648: Call_PatchReposOwnerRepoReleasesAssetsId_553650640;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Edit a release asset
  ## Users with push access to the repository can edit a release asset.
  ## 
  ## 
  let valid = call_553650648.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650648.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650648.makeUrl(scheme.get, call_553650648.host, call_553650648.base,
                                   call_553650648.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650648, uri, valid, content)

proc call*(call_553650649: Call_PatchReposOwnerRepoReleasesAssetsId_553650640;
           owner: string; id: string; body: JsonNode; repo: string;
           Accept: string = ""): Recallable =
  ## patchReposOwnerRepoReleasesAssetsId
  ## Edit a release asset
  ## Users with push access to the repository can edit a release asset.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650650 = newJObject()
  var header_553650651 = newJObject()
  var body_553650652 = newJObject()
  add(path_553650650, "owner", newJString(owner))
  add(path_553650650, "id", newJString(id))
  add(header_553650651, "Accept", newJString(Accept))
  if body != nil:
    body_553650652 = body
  add(path_553650650, "repo", newJString(repo))
  result = call_553650649.call(path_553650650, nil, header_553650651, nil, body_553650652)

var patchReposOwnerRepoReleasesAssetsId* = Call_PatchReposOwnerRepoReleasesAssetsId_553650640(
    name: "patchReposOwnerRepoReleasesAssetsId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/assets/{id}",
    validator: validate_PatchReposOwnerRepoReleasesAssetsId_553650641,
    base: "/", makeUrl: url_PatchReposOwnerRepoReleasesAssetsId_553650642,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoReleasesAssetsId_553650629 = ref object of OpenApiRestCall_553648476
proc url_DeleteReposOwnerRepoReleasesAssetsId_553650631(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/releases/assets/"),
                 (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoReleasesAssetsId_553650630(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Delete a release asset
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650632 = path.getOrDefault("owner")
  valid_553650632 = validateParameter(valid_553650632, JString, required = true,
                                      default = nil)
  if valid_553650632 != nil:
    section.add "owner", valid_553650632
  var valid_553650633 = path.getOrDefault("id")
  valid_553650633 = validateParameter(valid_553650633, JString, required = true,
                                      default = nil)
  if valid_553650633 != nil:
    section.add "id", valid_553650633
  var valid_553650634 = path.getOrDefault("repo")
  valid_553650634 = validateParameter(valid_553650634, JString, required = true,
                                      default = nil)
  if valid_553650634 != nil:
    section.add "repo", valid_553650634
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650635 = header.getOrDefault("Accept")
  valid_553650635 = validateParameter(valid_553650635, JString,
                                      required = false, default = nil)
  if valid_553650635 != nil:
    section.add "Accept", valid_553650635
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650636: Call_DeleteReposOwnerRepoReleasesAssetsId_553650629;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Delete a release asset
  ## 
  let valid = call_553650636.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650636.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650636.makeUrl(scheme.get, call_553650636.host, call_553650636.base,
                                   call_553650636.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650636, uri, valid, content)

proc call*(call_553650637: Call_DeleteReposOwnerRepoReleasesAssetsId_553650629;
           owner: string; id: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoReleasesAssetsId
  ## Delete a release asset
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650638 = newJObject()
  var header_553650639 = newJObject()
  add(path_553650638, "owner", newJString(owner))
  add(path_553650638, "id", newJString(id))
  add(header_553650639, "Accept", newJString(Accept))
  add(path_553650638, "repo", newJString(repo))
  result = call_553650637.call(path_553650638, nil, header_553650639, nil, nil)

var deleteReposOwnerRepoReleasesAssetsId* = Call_DeleteReposOwnerRepoReleasesAssetsId_553650629(
    name: "deleteReposOwnerRepoReleasesAssetsId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/assets/{id}",
    validator: validate_DeleteReposOwnerRepoReleasesAssetsId_553650630,
    base: "/", makeUrl: url_DeleteReposOwnerRepoReleasesAssetsId_553650631,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleasesId_553650653 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoReleasesId_553650655(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/releases/"),
                 (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleasesId_553650654(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get a single release
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650656 = path.getOrDefault("owner")
  valid_553650656 = validateParameter(valid_553650656, JString, required = true,
                                      default = nil)
  if valid_553650656 != nil:
    section.add "owner", valid_553650656
  var valid_553650657 = path.getOrDefault("id")
  valid_553650657 = validateParameter(valid_553650657, JString, required = true,
                                      default = nil)
  if valid_553650657 != nil:
    section.add "id", valid_553650657
  var valid_553650658 = path.getOrDefault("repo")
  valid_553650658 = validateParameter(valid_553650658, JString, required = true,
                                      default = nil)
  if valid_553650658 != nil:
    section.add "repo", valid_553650658
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650659 = header.getOrDefault("Accept")
  valid_553650659 = validateParameter(valid_553650659, JString,
                                      required = false, default = nil)
  if valid_553650659 != nil:
    section.add "Accept", valid_553650659
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650660: Call_GetReposOwnerRepoReleasesId_553650653;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get a single release
  ## 
  let valid = call_553650660.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650660.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650660.makeUrl(scheme.get, call_553650660.host, call_553650660.base,
                                   call_553650660.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650660, uri, valid, content)

proc call*(call_553650661: Call_GetReposOwnerRepoReleasesId_553650653;
           owner: string; id: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleasesId
  ## Get a single release
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650662 = newJObject()
  var header_553650663 = newJObject()
  add(path_553650662, "owner", newJString(owner))
  add(path_553650662, "id", newJString(id))
  add(header_553650663, "Accept", newJString(Accept))
  add(path_553650662, "repo", newJString(repo))
  result = call_553650661.call(path_553650662, nil, header_553650663, nil, nil)

var getReposOwnerRepoReleasesId* = Call_GetReposOwnerRepoReleasesId_553650653(
    name: "getReposOwnerRepoReleasesId", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}",
    validator: validate_GetReposOwnerRepoReleasesId_553650654, base: "/",
    makeUrl: url_GetReposOwnerRepoReleasesId_553650655, schemes: {Scheme.Https})
type
  Call_PatchReposOwnerRepoReleasesId_553650675 = ref object of OpenApiRestCall_553648476
proc url_PatchReposOwnerRepoReleasesId_553650677(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/releases/"),
                 (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchReposOwnerRepoReleasesId_553650676(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Users with push access to the repository can edit a release
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650678 = path.getOrDefault("owner")
  valid_553650678 = validateParameter(valid_553650678, JString, required = true,
                                      default = nil)
  if valid_553650678 != nil:
    section.add "owner", valid_553650678
  var valid_553650679 = path.getOrDefault("id")
  valid_553650679 = validateParameter(valid_553650679, JString, required = true,
                                      default = nil)
  if valid_553650679 != nil:
    section.add "id", valid_553650679
  var valid_553650680 = path.getOrDefault("repo")
  valid_553650680 = validateParameter(valid_553650680, JString, required = true,
                                      default = nil)
  if valid_553650680 != nil:
    section.add "repo", valid_553650680
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650681 = header.getOrDefault("Accept")
  valid_553650681 = validateParameter(valid_553650681, JString,
                                      required = false, default = nil)
  if valid_553650681 != nil:
    section.add "Accept", valid_553650681
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553650683: Call_PatchReposOwnerRepoReleasesId_553650675;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Users with push access to the repository can edit a release
  ## 
  let valid = call_553650683.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650683.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650683.makeUrl(scheme.get, call_553650683.host, call_553650683.base,
                                   call_553650683.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650683, uri, valid, content)

proc call*(call_553650684: Call_PatchReposOwnerRepoReleasesId_553650675;
           owner: string; id: string; body: JsonNode; repo: string;
           Accept: string = ""): Recallable =
  ## patchReposOwnerRepoReleasesId
  ## Users with push access to the repository can edit a release
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650685 = newJObject()
  var header_553650686 = newJObject()
  var body_553650687 = newJObject()
  add(path_553650685, "owner", newJString(owner))
  add(path_553650685, "id", newJString(id))
  add(header_553650686, "Accept", newJString(Accept))
  if body != nil:
    body_553650687 = body
  add(path_553650685, "repo", newJString(repo))
  result = call_553650684.call(path_553650685, nil, header_553650686, nil, body_553650687)

var patchReposOwnerRepoReleasesId* = Call_PatchReposOwnerRepoReleasesId_553650675(
    name: "patchReposOwnerRepoReleasesId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}",
    validator: validate_PatchReposOwnerRepoReleasesId_553650676, base: "/",
    makeUrl: url_PatchReposOwnerRepoReleasesId_553650677,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoReleasesId_553650664 = ref object of OpenApiRestCall_553648476
proc url_DeleteReposOwnerRepoReleasesId_553650666(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/releases/"),
                 (kind: VariableSegment, value: "id")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoReleasesId_553650665(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Users with push access to the repository can delete a release.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650667 = path.getOrDefault("owner")
  valid_553650667 = validateParameter(valid_553650667, JString, required = true,
                                      default = nil)
  if valid_553650667 != nil:
    section.add "owner", valid_553650667
  var valid_553650668 = path.getOrDefault("id")
  valid_553650668 = validateParameter(valid_553650668, JString, required = true,
                                      default = nil)
  if valid_553650668 != nil:
    section.add "id", valid_553650668
  var valid_553650669 = path.getOrDefault("repo")
  valid_553650669 = validateParameter(valid_553650669, JString, required = true,
                                      default = nil)
  if valid_553650669 != nil:
    section.add "repo", valid_553650669
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650670 = header.getOrDefault("Accept")
  valid_553650670 = validateParameter(valid_553650670, JString,
                                      required = false, default = nil)
  if valid_553650670 != nil:
    section.add "Accept", valid_553650670
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650671: Call_DeleteReposOwnerRepoReleasesId_553650664;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Users with push access to the repository can delete a release.
  ## 
  let valid = call_553650671.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650671.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650671.makeUrl(scheme.get, call_553650671.host, call_553650671.base,
                                   call_553650671.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650671, uri, valid, content)

proc call*(call_553650672: Call_DeleteReposOwnerRepoReleasesId_553650664;
           owner: string; id: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoReleasesId
  ## Users with push access to the repository can delete a release.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650673 = newJObject()
  var header_553650674 = newJObject()
  add(path_553650673, "owner", newJString(owner))
  add(path_553650673, "id", newJString(id))
  add(header_553650674, "Accept", newJString(Accept))
  add(path_553650673, "repo", newJString(repo))
  result = call_553650672.call(path_553650673, nil, header_553650674, nil, nil)

var deleteReposOwnerRepoReleasesId* = Call_DeleteReposOwnerRepoReleasesId_553650664(
    name: "deleteReposOwnerRepoReleasesId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}",
    validator: validate_DeleteReposOwnerRepoReleasesId_553650665, base: "/",
    makeUrl: url_DeleteReposOwnerRepoReleasesId_553650666,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoReleasesIdAssets_553650688 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoReleasesIdAssets_553650690(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "id" in path, "`id` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/releases/"),
                 (kind: VariableSegment, value: "id"),
                 (kind: ConstantSegment, value: "/assets")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoReleasesIdAssets_553650689(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## List assets for a release
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   id: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650691 = path.getOrDefault("owner")
  valid_553650691 = validateParameter(valid_553650691, JString, required = true,
                                      default = nil)
  if valid_553650691 != nil:
    section.add "owner", valid_553650691
  var valid_553650692 = path.getOrDefault("id")
  valid_553650692 = validateParameter(valid_553650692, JString, required = true,
                                      default = nil)
  if valid_553650692 != nil:
    section.add "id", valid_553650692
  var valid_553650693 = path.getOrDefault("repo")
  valid_553650693 = validateParameter(valid_553650693, JString, required = true,
                                      default = nil)
  if valid_553650693 != nil:
    section.add "repo", valid_553650693
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650694 = header.getOrDefault("Accept")
  valid_553650694 = validateParameter(valid_553650694, JString,
                                      required = false, default = nil)
  if valid_553650694 != nil:
    section.add "Accept", valid_553650694
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650695: Call_GetReposOwnerRepoReleasesIdAssets_553650688;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List assets for a release
  ## 
  let valid = call_553650695.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650695.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650695.makeUrl(scheme.get, call_553650695.host, call_553650695.base,
                                   call_553650695.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650695, uri, valid, content)

proc call*(call_553650696: Call_GetReposOwnerRepoReleasesIdAssets_553650688;
           owner: string; id: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoReleasesIdAssets
  ## List assets for a release
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   id: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650697 = newJObject()
  var header_553650698 = newJObject()
  add(path_553650697, "owner", newJString(owner))
  add(path_553650697, "id", newJString(id))
  add(header_553650698, "Accept", newJString(Accept))
  add(path_553650697, "repo", newJString(repo))
  result = call_553650696.call(path_553650697, nil, header_553650698, nil, nil)

var getReposOwnerRepoReleasesIdAssets* = Call_GetReposOwnerRepoReleasesIdAssets_553650688(
    name: "getReposOwnerRepoReleasesIdAssets", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/releases/{id}/assets",
    validator: validate_GetReposOwnerRepoReleasesIdAssets_553650689, base: "/",
    makeUrl: url_GetReposOwnerRepoReleasesIdAssets_553650690,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStargazers_553650699 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoStargazers_553650701(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/stargazers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStargazers_553650700(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## List Stargazers.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650702 = path.getOrDefault("owner")
  valid_553650702 = validateParameter(valid_553650702, JString, required = true,
                                      default = nil)
  if valid_553650702 != nil:
    section.add "owner", valid_553650702
  var valid_553650703 = path.getOrDefault("repo")
  valid_553650703 = validateParameter(valid_553650703, JString, required = true,
                                      default = nil)
  if valid_553650703 != nil:
    section.add "repo", valid_553650703
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650704 = header.getOrDefault("Accept")
  valid_553650704 = validateParameter(valid_553650704, JString,
                                      required = false, default = nil)
  if valid_553650704 != nil:
    section.add "Accept", valid_553650704
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650705: Call_GetReposOwnerRepoStargazers_553650699;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List Stargazers.
  ## 
  let valid = call_553650705.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650705.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650705.makeUrl(scheme.get, call_553650705.host, call_553650705.base,
                                   call_553650705.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650705, uri, valid, content)

proc call*(call_553650706: Call_GetReposOwnerRepoStargazers_553650699;
           owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStargazers
  ## List Stargazers.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650707 = newJObject()
  var header_553650708 = newJObject()
  add(path_553650707, "owner", newJString(owner))
  add(header_553650708, "Accept", newJString(Accept))
  add(path_553650707, "repo", newJString(repo))
  result = call_553650706.call(path_553650707, nil, header_553650708, nil, nil)

var getReposOwnerRepoStargazers* = Call_GetReposOwnerRepoStargazers_553650699(
    name: "getReposOwnerRepoStargazers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stargazers",
    validator: validate_GetReposOwnerRepoStargazers_553650700, base: "/",
    makeUrl: url_GetReposOwnerRepoStargazers_553650701, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsCodeFrequency_553650709 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoStatsCodeFrequency_553650711(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/stats/code_frequency")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsCodeFrequency_553650710(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get the number of additions and deletions per week.
  ## Returns a weekly aggregate of the number of additions and deletions pushed
  ## to a repository.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650712 = path.getOrDefault("owner")
  valid_553650712 = validateParameter(valid_553650712, JString, required = true,
                                      default = nil)
  if valid_553650712 != nil:
    section.add "owner", valid_553650712
  var valid_553650713 = path.getOrDefault("repo")
  valid_553650713 = validateParameter(valid_553650713, JString, required = true,
                                      default = nil)
  if valid_553650713 != nil:
    section.add "repo", valid_553650713
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650714 = header.getOrDefault("Accept")
  valid_553650714 = validateParameter(valid_553650714, JString,
                                      required = false, default = nil)
  if valid_553650714 != nil:
    section.add "Accept", valid_553650714
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650715: Call_GetReposOwnerRepoStatsCodeFrequency_553650709;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get the number of additions and deletions per week.
  ## Returns a weekly aggregate of the number of additions and deletions pushed
  ## to a repository.
  ## 
  ## 
  let valid = call_553650715.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650715.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650715.makeUrl(scheme.get, call_553650715.host, call_553650715.base,
                                   call_553650715.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650715, uri, valid, content)

proc call*(call_553650716: Call_GetReposOwnerRepoStatsCodeFrequency_553650709;
           owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsCodeFrequency
  ## Get the number of additions and deletions per week.
  ## Returns a weekly aggregate of the number of additions and deletions pushed
  ## to a repository.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650717 = newJObject()
  var header_553650718 = newJObject()
  add(path_553650717, "owner", newJString(owner))
  add(header_553650718, "Accept", newJString(Accept))
  add(path_553650717, "repo", newJString(repo))
  result = call_553650716.call(path_553650717, nil, header_553650718, nil, nil)

var getReposOwnerRepoStatsCodeFrequency* = Call_GetReposOwnerRepoStatsCodeFrequency_553650709(
    name: "getReposOwnerRepoStatsCodeFrequency", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/code_frequency",
    validator: validate_GetReposOwnerRepoStatsCodeFrequency_553650710,
    base: "/", makeUrl: url_GetReposOwnerRepoStatsCodeFrequency_553650711,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsCommitActivity_553650719 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoStatsCommitActivity_553650721(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/stats/commit_activity")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsCommitActivity_553650720(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get the last year of commit activity data.
  ## Returns the last year of commit activity grouped by week. The days array
  ## is a group of commits per day, starting on Sunday.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650722 = path.getOrDefault("owner")
  valid_553650722 = validateParameter(valid_553650722, JString, required = true,
                                      default = nil)
  if valid_553650722 != nil:
    section.add "owner", valid_553650722
  var valid_553650723 = path.getOrDefault("repo")
  valid_553650723 = validateParameter(valid_553650723, JString, required = true,
                                      default = nil)
  if valid_553650723 != nil:
    section.add "repo", valid_553650723
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650724 = header.getOrDefault("Accept")
  valid_553650724 = validateParameter(valid_553650724, JString,
                                      required = false, default = nil)
  if valid_553650724 != nil:
    section.add "Accept", valid_553650724
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650725: Call_GetReposOwnerRepoStatsCommitActivity_553650719;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get the last year of commit activity data.
  ## Returns the last year of commit activity grouped by week. The days array
  ## is a group of commits per day, starting on Sunday.
  ## 
  ## 
  let valid = call_553650725.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650725.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650725.makeUrl(scheme.get, call_553650725.host, call_553650725.base,
                                   call_553650725.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650725, uri, valid, content)

proc call*(call_553650726: Call_GetReposOwnerRepoStatsCommitActivity_553650719;
           owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsCommitActivity
  ## Get the last year of commit activity data.
  ## Returns the last year of commit activity grouped by week. The days array
  ## is a group of commits per day, starting on Sunday.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650727 = newJObject()
  var header_553650728 = newJObject()
  add(path_553650727, "owner", newJString(owner))
  add(header_553650728, "Accept", newJString(Accept))
  add(path_553650727, "repo", newJString(repo))
  result = call_553650726.call(path_553650727, nil, header_553650728, nil, nil)

var getReposOwnerRepoStatsCommitActivity* = Call_GetReposOwnerRepoStatsCommitActivity_553650719(
    name: "getReposOwnerRepoStatsCommitActivity", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/stats/commit_activity",
    validator: validate_GetReposOwnerRepoStatsCommitActivity_553650720,
    base: "/", makeUrl: url_GetReposOwnerRepoStatsCommitActivity_553650721,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsContributors_553650729 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoStatsContributors_553650731(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/stats/contributors")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsContributors_553650730(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get contributors list with additions, deletions, and commit counts.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650732 = path.getOrDefault("owner")
  valid_553650732 = validateParameter(valid_553650732, JString, required = true,
                                      default = nil)
  if valid_553650732 != nil:
    section.add "owner", valid_553650732
  var valid_553650733 = path.getOrDefault("repo")
  valid_553650733 = validateParameter(valid_553650733, JString, required = true,
                                      default = nil)
  if valid_553650733 != nil:
    section.add "repo", valid_553650733
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650734 = header.getOrDefault("Accept")
  valid_553650734 = validateParameter(valid_553650734, JString,
                                      required = false, default = nil)
  if valid_553650734 != nil:
    section.add "Accept", valid_553650734
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650735: Call_GetReposOwnerRepoStatsContributors_553650729;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get contributors list with additions, deletions, and commit counts.
  ## 
  let valid = call_553650735.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650735.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650735.makeUrl(scheme.get, call_553650735.host, call_553650735.base,
                                   call_553650735.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650735, uri, valid, content)

proc call*(call_553650736: Call_GetReposOwnerRepoStatsContributors_553650729;
           owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsContributors
  ## Get contributors list with additions, deletions, and commit counts.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650737 = newJObject()
  var header_553650738 = newJObject()
  add(path_553650737, "owner", newJString(owner))
  add(header_553650738, "Accept", newJString(Accept))
  add(path_553650737, "repo", newJString(repo))
  result = call_553650736.call(path_553650737, nil, header_553650738, nil, nil)

var getReposOwnerRepoStatsContributors* = Call_GetReposOwnerRepoStatsContributors_553650729(
    name: "getReposOwnerRepoStatsContributors", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/contributors",
    validator: validate_GetReposOwnerRepoStatsContributors_553650730, base: "/",
    makeUrl: url_GetReposOwnerRepoStatsContributors_553650731,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsParticipation_553650739 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoStatsParticipation_553650741(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/stats/participation")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsParticipation_553650740(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get the weekly commit count for the repo owner and everyone else.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650742 = path.getOrDefault("owner")
  valid_553650742 = validateParameter(valid_553650742, JString, required = true,
                                      default = nil)
  if valid_553650742 != nil:
    section.add "owner", valid_553650742
  var valid_553650743 = path.getOrDefault("repo")
  valid_553650743 = validateParameter(valid_553650743, JString, required = true,
                                      default = nil)
  if valid_553650743 != nil:
    section.add "repo", valid_553650743
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650744 = header.getOrDefault("Accept")
  valid_553650744 = validateParameter(valid_553650744, JString,
                                      required = false, default = nil)
  if valid_553650744 != nil:
    section.add "Accept", valid_553650744
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650745: Call_GetReposOwnerRepoStatsParticipation_553650739;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get the weekly commit count for the repo owner and everyone else.
  ## 
  let valid = call_553650745.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650745.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650745.makeUrl(scheme.get, call_553650745.host, call_553650745.base,
                                   call_553650745.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650745, uri, valid, content)

proc call*(call_553650746: Call_GetReposOwnerRepoStatsParticipation_553650739;
           owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsParticipation
  ## Get the weekly commit count for the repo owner and everyone else.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650747 = newJObject()
  var header_553650748 = newJObject()
  add(path_553650747, "owner", newJString(owner))
  add(header_553650748, "Accept", newJString(Accept))
  add(path_553650747, "repo", newJString(repo))
  result = call_553650746.call(path_553650747, nil, header_553650748, nil, nil)

var getReposOwnerRepoStatsParticipation* = Call_GetReposOwnerRepoStatsParticipation_553650739(
    name: "getReposOwnerRepoStatsParticipation", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/participation",
    validator: validate_GetReposOwnerRepoStatsParticipation_553650740,
    base: "/", makeUrl: url_GetReposOwnerRepoStatsParticipation_553650741,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatsPunchCard_553650749 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoStatsPunchCard_553650751(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/stats/punch_card")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatsPunchCard_553650750(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get the number of commits per hour in each day.
  ## Each array contains the day number, hour number, and number of commits
  ## 0-6 Sunday - Saturday
  ## 0-23 Hour of day
  ## Number of commits
  ## 
  ## For example, [2, 14, 25] indicates that there were 25 total commits, during
  ## the 2.00pm hour on Tuesdays. All times are based on the time zone of
  ## individual commits.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650752 = path.getOrDefault("owner")
  valid_553650752 = validateParameter(valid_553650752, JString, required = true,
                                      default = nil)
  if valid_553650752 != nil:
    section.add "owner", valid_553650752
  var valid_553650753 = path.getOrDefault("repo")
  valid_553650753 = validateParameter(valid_553650753, JString, required = true,
                                      default = nil)
  if valid_553650753 != nil:
    section.add "repo", valid_553650753
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650754 = header.getOrDefault("Accept")
  valid_553650754 = validateParameter(valid_553650754, JString,
                                      required = false, default = nil)
  if valid_553650754 != nil:
    section.add "Accept", valid_553650754
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650755: Call_GetReposOwnerRepoStatsPunchCard_553650749;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get the number of commits per hour in each day.
  ## Each array contains the day number, hour number, and number of commits
  ## 0-6 Sunday - Saturday
  ## 0-23 Hour of day
  ## Number of commits
  ## 
  ## For example, [2, 14, 25] indicates that there were 25 total commits, during
  ## the 2.00pm hour on Tuesdays. All times are based on the time zone of
  ## individual commits.
  ## 
  ## 
  let valid = call_553650755.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650755.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650755.makeUrl(scheme.get, call_553650755.host, call_553650755.base,
                                   call_553650755.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650755, uri, valid, content)

proc call*(call_553650756: Call_GetReposOwnerRepoStatsPunchCard_553650749;
           owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatsPunchCard
  ## Get the number of commits per hour in each day.
  ## Each array contains the day number, hour number, and number of commits
  ## 0-6 Sunday - Saturday
  ## 0-23 Hour of day
  ## Number of commits
  ## 
  ## For example, [2, 14, 25] indicates that there were 25 total commits, during
  ## the 2.00pm hour on Tuesdays. All times are based on the time zone of
  ## individual commits.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650757 = newJObject()
  var header_553650758 = newJObject()
  add(path_553650757, "owner", newJString(owner))
  add(header_553650758, "Accept", newJString(Accept))
  add(path_553650757, "repo", newJString(repo))
  result = call_553650756.call(path_553650757, nil, header_553650758, nil, nil)

var getReposOwnerRepoStatsPunchCard* = Call_GetReposOwnerRepoStatsPunchCard_553650749(
    name: "getReposOwnerRepoStatsPunchCard", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/stats/punch_card",
    validator: validate_GetReposOwnerRepoStatsPunchCard_553650750, base: "/",
    makeUrl: url_GetReposOwnerRepoStatsPunchCard_553650751,
    schemes: {Scheme.Https})
type
  Call_PostReposOwnerRepoStatusesRef_553650770 = ref object of OpenApiRestCall_553648476
proc url_PostReposOwnerRepoStatusesRef_553650772(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/statuses/"),
                 (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PostReposOwnerRepoStatusesRef_553650771(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Create a Status.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   ref: JString (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650773 = path.getOrDefault("owner")
  valid_553650773 = validateParameter(valid_553650773, JString, required = true,
                                      default = nil)
  if valid_553650773 != nil:
    section.add "owner", valid_553650773
  var valid_553650774 = path.getOrDefault("ref")
  valid_553650774 = validateParameter(valid_553650774, JString, required = true,
                                      default = nil)
  if valid_553650774 != nil:
    section.add "ref", valid_553650774
  var valid_553650775 = path.getOrDefault("repo")
  valid_553650775 = validateParameter(valid_553650775, JString, required = true,
                                      default = nil)
  if valid_553650775 != nil:
    section.add "repo", valid_553650775
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650776 = header.getOrDefault("Accept")
  valid_553650776 = validateParameter(valid_553650776, JString,
                                      required = false, default = nil)
  if valid_553650776 != nil:
    section.add "Accept", valid_553650776
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553650778: Call_PostReposOwnerRepoStatusesRef_553650770;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Create a Status.
  ## 
  let valid = call_553650778.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650778.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650778.makeUrl(scheme.get, call_553650778.host, call_553650778.base,
                                   call_553650778.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650778, uri, valid, content)

proc call*(call_553650779: Call_PostReposOwnerRepoStatusesRef_553650770;
           owner: string; `ref`: string; body: JsonNode; repo: string;
           Accept: string = ""): Recallable =
  ## postReposOwnerRepoStatusesRef
  ## Create a Status.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   ref: string (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650780 = newJObject()
  var header_553650781 = newJObject()
  var body_553650782 = newJObject()
  add(path_553650780, "owner", newJString(owner))
  add(path_553650780, "ref", newJString(`ref`))
  add(header_553650781, "Accept", newJString(Accept))
  if body != nil:
    body_553650782 = body
  add(path_553650780, "repo", newJString(repo))
  result = call_553650779.call(path_553650780, nil, header_553650781, nil, body_553650782)

var postReposOwnerRepoStatusesRef* = Call_PostReposOwnerRepoStatusesRef_553650770(
    name: "postReposOwnerRepoStatusesRef", meth: HttpMethod.HttpPost,
    host: "api.github.com", route: "/repos/{owner}/{repo}/statuses/{ref}",
    validator: validate_PostReposOwnerRepoStatusesRef_553650771, base: "/",
    makeUrl: url_PostReposOwnerRepoStatusesRef_553650772,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoStatusesRef_553650759 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoStatusesRef_553650761(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "ref" in path, "`ref` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/statuses/"),
                 (kind: VariableSegment, value: "ref")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoStatusesRef_553650760(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## List Statuses for a specific Ref.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   ref: JString (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650762 = path.getOrDefault("owner")
  valid_553650762 = validateParameter(valid_553650762, JString, required = true,
                                      default = nil)
  if valid_553650762 != nil:
    section.add "owner", valid_553650762
  var valid_553650763 = path.getOrDefault("ref")
  valid_553650763 = validateParameter(valid_553650763, JString, required = true,
                                      default = nil)
  if valid_553650763 != nil:
    section.add "ref", valid_553650763
  var valid_553650764 = path.getOrDefault("repo")
  valid_553650764 = validateParameter(valid_553650764, JString, required = true,
                                      default = nil)
  if valid_553650764 != nil:
    section.add "repo", valid_553650764
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650765 = header.getOrDefault("Accept")
  valid_553650765 = validateParameter(valid_553650765, JString,
                                      required = false, default = nil)
  if valid_553650765 != nil:
    section.add "Accept", valid_553650765
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650766: Call_GetReposOwnerRepoStatusesRef_553650759;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List Statuses for a specific Ref.
  ## 
  let valid = call_553650766.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650766.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650766.makeUrl(scheme.get, call_553650766.host, call_553650766.base,
                                   call_553650766.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650766, uri, valid, content)

proc call*(call_553650767: Call_GetReposOwnerRepoStatusesRef_553650759;
           owner: string; `ref`: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoStatusesRef
  ## List Statuses for a specific Ref.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   ref: string (required)
  ##      : Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650768 = newJObject()
  var header_553650769 = newJObject()
  add(path_553650768, "owner", newJString(owner))
  add(path_553650768, "ref", newJString(`ref`))
  add(header_553650769, "Accept", newJString(Accept))
  add(path_553650768, "repo", newJString(repo))
  result = call_553650767.call(path_553650768, nil, header_553650769, nil, nil)

var getReposOwnerRepoStatusesRef* = Call_GetReposOwnerRepoStatusesRef_553650759(
    name: "getReposOwnerRepoStatusesRef", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/statuses/{ref}",
    validator: validate_GetReposOwnerRepoStatusesRef_553650760, base: "/",
    makeUrl: url_GetReposOwnerRepoStatusesRef_553650761, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoSubscribers_553650783 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoSubscribers_553650785(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/subscribers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoSubscribers_553650784(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## List watchers.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650786 = path.getOrDefault("owner")
  valid_553650786 = validateParameter(valid_553650786, JString, required = true,
                                      default = nil)
  if valid_553650786 != nil:
    section.add "owner", valid_553650786
  var valid_553650787 = path.getOrDefault("repo")
  valid_553650787 = validateParameter(valid_553650787, JString, required = true,
                                      default = nil)
  if valid_553650787 != nil:
    section.add "repo", valid_553650787
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650788 = header.getOrDefault("Accept")
  valid_553650788 = validateParameter(valid_553650788, JString,
                                      required = false, default = nil)
  if valid_553650788 != nil:
    section.add "Accept", valid_553650788
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650789: Call_GetReposOwnerRepoSubscribers_553650783;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List watchers.
  ## 
  let valid = call_553650789.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650789.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650789.makeUrl(scheme.get, call_553650789.host, call_553650789.base,
                                   call_553650789.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650789, uri, valid, content)

proc call*(call_553650790: Call_GetReposOwnerRepoSubscribers_553650783;
           owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoSubscribers
  ## List watchers.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650791 = newJObject()
  var header_553650792 = newJObject()
  add(path_553650791, "owner", newJString(owner))
  add(header_553650792, "Accept", newJString(Accept))
  add(path_553650791, "repo", newJString(repo))
  result = call_553650790.call(path_553650791, nil, header_553650792, nil, nil)

var getReposOwnerRepoSubscribers* = Call_GetReposOwnerRepoSubscribers_553650783(
    name: "getReposOwnerRepoSubscribers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscribers",
    validator: validate_GetReposOwnerRepoSubscribers_553650784, base: "/",
    makeUrl: url_GetReposOwnerRepoSubscribers_553650785, schemes: {Scheme.Https})
type
  Call_PutReposOwnerRepoSubscription_553650803 = ref object of OpenApiRestCall_553648476
proc url_PutReposOwnerRepoSubscription_553650805(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutReposOwnerRepoSubscription_553650804(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Set a Repository Subscription
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650806 = path.getOrDefault("owner")
  valid_553650806 = validateParameter(valid_553650806, JString, required = true,
                                      default = nil)
  if valid_553650806 != nil:
    section.add "owner", valid_553650806
  var valid_553650807 = path.getOrDefault("repo")
  valid_553650807 = validateParameter(valid_553650807, JString, required = true,
                                      default = nil)
  if valid_553650807 != nil:
    section.add "repo", valid_553650807
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650808 = header.getOrDefault("Accept")
  valid_553650808 = validateParameter(valid_553650808, JString,
                                      required = false, default = nil)
  if valid_553650808 != nil:
    section.add "Accept", valid_553650808
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553650810: Call_PutReposOwnerRepoSubscription_553650803;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Set a Repository Subscription
  ## 
  let valid = call_553650810.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650810.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650810.makeUrl(scheme.get, call_553650810.host, call_553650810.base,
                                   call_553650810.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650810, uri, valid, content)

proc call*(call_553650811: Call_PutReposOwnerRepoSubscription_553650803;
           owner: string; body: JsonNode; repo: string; Accept: string = ""): Recallable =
  ## putReposOwnerRepoSubscription
  ## Set a Repository Subscription
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650812 = newJObject()
  var header_553650813 = newJObject()
  var body_553650814 = newJObject()
  add(path_553650812, "owner", newJString(owner))
  add(header_553650813, "Accept", newJString(Accept))
  if body != nil:
    body_553650814 = body
  add(path_553650812, "repo", newJString(repo))
  result = call_553650811.call(path_553650812, nil, header_553650813, nil, body_553650814)

var putReposOwnerRepoSubscription* = Call_PutReposOwnerRepoSubscription_553650803(
    name: "putReposOwnerRepoSubscription", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscription",
    validator: validate_PutReposOwnerRepoSubscription_553650804, base: "/",
    makeUrl: url_PutReposOwnerRepoSubscription_553650805,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoSubscription_553650793 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoSubscription_553650795(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoSubscription_553650794(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get a Repository Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650796 = path.getOrDefault("owner")
  valid_553650796 = validateParameter(valid_553650796, JString, required = true,
                                      default = nil)
  if valid_553650796 != nil:
    section.add "owner", valid_553650796
  var valid_553650797 = path.getOrDefault("repo")
  valid_553650797 = validateParameter(valid_553650797, JString, required = true,
                                      default = nil)
  if valid_553650797 != nil:
    section.add "repo", valid_553650797
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650798 = header.getOrDefault("Accept")
  valid_553650798 = validateParameter(valid_553650798, JString,
                                      required = false, default = nil)
  if valid_553650798 != nil:
    section.add "Accept", valid_553650798
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650799: Call_GetReposOwnerRepoSubscription_553650793;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get a Repository Subscription.
  ## 
  let valid = call_553650799.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650799.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650799.makeUrl(scheme.get, call_553650799.host, call_553650799.base,
                                   call_553650799.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650799, uri, valid, content)

proc call*(call_553650800: Call_GetReposOwnerRepoSubscription_553650793;
           owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoSubscription
  ## Get a Repository Subscription.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650801 = newJObject()
  var header_553650802 = newJObject()
  add(path_553650801, "owner", newJString(owner))
  add(header_553650802, "Accept", newJString(Accept))
  add(path_553650801, "repo", newJString(repo))
  result = call_553650800.call(path_553650801, nil, header_553650802, nil, nil)

var getReposOwnerRepoSubscription* = Call_GetReposOwnerRepoSubscription_553650793(
    name: "getReposOwnerRepoSubscription", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscription",
    validator: validate_GetReposOwnerRepoSubscription_553650794, base: "/",
    makeUrl: url_GetReposOwnerRepoSubscription_553650795,
    schemes: {Scheme.Https})
type
  Call_DeleteReposOwnerRepoSubscription_553650815 = ref object of OpenApiRestCall_553648476
proc url_DeleteReposOwnerRepoSubscription_553650817(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/subscription")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteReposOwnerRepoSubscription_553650816(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Delete a Repository Subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650818 = path.getOrDefault("owner")
  valid_553650818 = validateParameter(valid_553650818, JString, required = true,
                                      default = nil)
  if valid_553650818 != nil:
    section.add "owner", valid_553650818
  var valid_553650819 = path.getOrDefault("repo")
  valid_553650819 = validateParameter(valid_553650819, JString, required = true,
                                      default = nil)
  if valid_553650819 != nil:
    section.add "repo", valid_553650819
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650820 = header.getOrDefault("Accept")
  valid_553650820 = validateParameter(valid_553650820, JString,
                                      required = false, default = nil)
  if valid_553650820 != nil:
    section.add "Accept", valid_553650820
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650821: Call_DeleteReposOwnerRepoSubscription_553650815;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Delete a Repository Subscription.
  ## 
  let valid = call_553650821.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650821.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650821.makeUrl(scheme.get, call_553650821.host, call_553650821.base,
                                   call_553650821.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650821, uri, valid, content)

proc call*(call_553650822: Call_DeleteReposOwnerRepoSubscription_553650815;
           owner: string; repo: string; Accept: string = ""): Recallable =
  ## deleteReposOwnerRepoSubscription
  ## Delete a Repository Subscription.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650823 = newJObject()
  var header_553650824 = newJObject()
  add(path_553650823, "owner", newJString(owner))
  add(header_553650824, "Accept", newJString(Accept))
  add(path_553650823, "repo", newJString(repo))
  result = call_553650822.call(path_553650823, nil, header_553650824, nil, nil)

var deleteReposOwnerRepoSubscription* = Call_DeleteReposOwnerRepoSubscription_553650815(
    name: "deleteReposOwnerRepoSubscription", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/repos/{owner}/{repo}/subscription",
    validator: validate_DeleteReposOwnerRepoSubscription_553650816, base: "/",
    makeUrl: url_DeleteReposOwnerRepoSubscription_553650817,
    schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoTags_553650825 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoTags_553650827(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/tags")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoTags_553650826(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Get list of tags.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650828 = path.getOrDefault("owner")
  valid_553650828 = validateParameter(valid_553650828, JString, required = true,
                                      default = nil)
  if valid_553650828 != nil:
    section.add "owner", valid_553650828
  var valid_553650829 = path.getOrDefault("repo")
  valid_553650829 = validateParameter(valid_553650829, JString, required = true,
                                      default = nil)
  if valid_553650829 != nil:
    section.add "repo", valid_553650829
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650830 = header.getOrDefault("Accept")
  valid_553650830 = validateParameter(valid_553650830, JString,
                                      required = false, default = nil)
  if valid_553650830 != nil:
    section.add "Accept", valid_553650830
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650831: Call_GetReposOwnerRepoTags_553650825;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get list of tags.
  ## 
  let valid = call_553650831.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650831.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650831.makeUrl(scheme.get, call_553650831.host, call_553650831.base,
                                   call_553650831.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650831, uri, valid, content)

proc call*(call_553650832: Call_GetReposOwnerRepoTags_553650825; owner: string;
           repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoTags
  ## Get list of tags.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650833 = newJObject()
  var header_553650834 = newJObject()
  add(path_553650833, "owner", newJString(owner))
  add(header_553650834, "Accept", newJString(Accept))
  add(path_553650833, "repo", newJString(repo))
  result = call_553650832.call(path_553650833, nil, header_553650834, nil, nil)

var getReposOwnerRepoTags* = Call_GetReposOwnerRepoTags_553650825(
    name: "getReposOwnerRepoTags", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/tags",
    validator: validate_GetReposOwnerRepoTags_553650826, base: "/",
    makeUrl: url_GetReposOwnerRepoTags_553650827, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoTeams_553650835 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoTeams_553650837(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/teams")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoTeams_553650836(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Get list of teams
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650838 = path.getOrDefault("owner")
  valid_553650838 = validateParameter(valid_553650838, JString, required = true,
                                      default = nil)
  if valid_553650838 != nil:
    section.add "owner", valid_553650838
  var valid_553650839 = path.getOrDefault("repo")
  valid_553650839 = validateParameter(valid_553650839, JString, required = true,
                                      default = nil)
  if valid_553650839 != nil:
    section.add "repo", valid_553650839
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650840 = header.getOrDefault("Accept")
  valid_553650840 = validateParameter(valid_553650840, JString,
                                      required = false, default = nil)
  if valid_553650840 != nil:
    section.add "Accept", valid_553650840
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650841: Call_GetReposOwnerRepoTeams_553650835;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get list of teams
  ## 
  let valid = call_553650841.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650841.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650841.makeUrl(scheme.get, call_553650841.host, call_553650841.base,
                                   call_553650841.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650841, uri, valid, content)

proc call*(call_553650842: Call_GetReposOwnerRepoTeams_553650835; owner: string;
           repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoTeams
  ## Get list of teams
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650843 = newJObject()
  var header_553650844 = newJObject()
  add(path_553650843, "owner", newJString(owner))
  add(header_553650844, "Accept", newJString(Accept))
  add(path_553650843, "repo", newJString(repo))
  result = call_553650842.call(path_553650843, nil, header_553650844, nil, nil)

var getReposOwnerRepoTeams* = Call_GetReposOwnerRepoTeams_553650835(
    name: "getReposOwnerRepoTeams", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/teams",
    validator: validate_GetReposOwnerRepoTeams_553650836, base: "/",
    makeUrl: url_GetReposOwnerRepoTeams_553650837, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoWatchers_553650845 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoWatchers_553650847(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/watchers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoWatchers_553650846(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## List Stargazers. New implementation.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650848 = path.getOrDefault("owner")
  valid_553650848 = validateParameter(valid_553650848, JString, required = true,
                                      default = nil)
  if valid_553650848 != nil:
    section.add "owner", valid_553650848
  var valid_553650849 = path.getOrDefault("repo")
  valid_553650849 = validateParameter(valid_553650849, JString, required = true,
                                      default = nil)
  if valid_553650849 != nil:
    section.add "repo", valid_553650849
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650850 = header.getOrDefault("Accept")
  valid_553650850 = validateParameter(valid_553650850, JString,
                                      required = false, default = nil)
  if valid_553650850 != nil:
    section.add "Accept", valid_553650850
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650851: Call_GetReposOwnerRepoWatchers_553650845;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List Stargazers. New implementation.
  ## 
  let valid = call_553650851.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650851.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650851.makeUrl(scheme.get, call_553650851.host, call_553650851.base,
                                   call_553650851.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650851, uri, valid, content)

proc call*(call_553650852: Call_GetReposOwnerRepoWatchers_553650845;
           owner: string; repo: string; Accept: string = ""): Recallable =
  ## getReposOwnerRepoWatchers
  ## List Stargazers. New implementation.
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553650853 = newJObject()
  var header_553650854 = newJObject()
  add(path_553650853, "owner", newJString(owner))
  add(header_553650854, "Accept", newJString(Accept))
  add(path_553650853, "repo", newJString(repo))
  result = call_553650852.call(path_553650853, nil, header_553650854, nil, nil)

var getReposOwnerRepoWatchers* = Call_GetReposOwnerRepoWatchers_553650845(
    name: "getReposOwnerRepoWatchers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/repos/{owner}/{repo}/watchers",
    validator: validate_GetReposOwnerRepoWatchers_553650846, base: "/",
    makeUrl: url_GetReposOwnerRepoWatchers_553650847, schemes: {Scheme.Https})
type
  Call_GetReposOwnerRepoArchiveFormatPath_553650855 = ref object of OpenApiRestCall_553648476
proc url_GetReposOwnerRepoArchiveFormatPath_553650857(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  assert "archive_format" in path,
         "`archive_format` is a required path parameter"
  assert "path" in path, "`path` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "archive_format"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "path")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetReposOwnerRepoArchiveFormatPath_553650856(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get archive link.
  ## This method will return a 302 to a URL to download a tarball or zipball
  ## archive for a repository. Please make sure your HTTP framework is
  ## configured to follow redirects or you will need to use the Location header
  ## to make a second GET request.
  ## Note: For private repositories, these links are temporary and expire quickly.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of repository owner.
  ##   archive_format: JString (required)
  ##   repo: JString (required)
  ##       : Name of repository.
  ##   path: JString (required)
  ##       : Valid Git reference, defaults to 'master'.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553650858 = path.getOrDefault("owner")
  valid_553650858 = validateParameter(valid_553650858, JString, required = true,
                                      default = nil)
  if valid_553650858 != nil:
    section.add "owner", valid_553650858
  var valid_553650859 = path.getOrDefault("archive_format")
  valid_553650859 = validateParameter(valid_553650859, JString, required = true,
                                      default = newJString("tarball"))
  if valid_553650859 != nil:
    section.add "archive_format", valid_553650859
  var valid_553650860 = path.getOrDefault("repo")
  valid_553650860 = validateParameter(valid_553650860, JString, required = true,
                                      default = nil)
  if valid_553650860 != nil:
    section.add "repo", valid_553650860
  var valid_553650861 = path.getOrDefault("path")
  valid_553650861 = validateParameter(valid_553650861, JString, required = true,
                                      default = nil)
  if valid_553650861 != nil:
    section.add "path", valid_553650861
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650862 = header.getOrDefault("Accept")
  valid_553650862 = validateParameter(valid_553650862, JString,
                                      required = false, default = nil)
  if valid_553650862 != nil:
    section.add "Accept", valid_553650862
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650863: Call_GetReposOwnerRepoArchiveFormatPath_553650855;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get archive link.
  ## This method will return a 302 to a URL to download a tarball or zipball
  ## archive for a repository. Please make sure your HTTP framework is
  ## configured to follow redirects or you will need to use the Location header
  ## to make a second GET request.
  ## Note: For private repositories, these links are temporary and expire quickly.
  ## 
  ## 
  let valid = call_553650863.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650863.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650863.makeUrl(scheme.get, call_553650863.host, call_553650863.base,
                                   call_553650863.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650863, uri, valid, content)

proc call*(call_553650864: Call_GetReposOwnerRepoArchiveFormatPath_553650855;
           owner: string; repo: string; path: string;
           archiveFormat: string = "tarball"; Accept: string = ""): Recallable =
  ## getReposOwnerRepoArchiveFormatPath
  ## Get archive link.
  ## This method will return a 302 to a URL to download a tarball or zipball
  ## archive for a repository. Please make sure your HTTP framework is
  ## configured to follow redirects or you will need to use the Location header
  ## to make a second GET request.
  ## Note: For private repositories, these links are temporary and expire quickly.
  ## 
  ##   owner: string (required)
  ##        : Name of repository owner.
  ##   archiveFormat: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  ##   path: string (required)
  ##       : Valid Git reference, defaults to 'master'.
  var path_553650865 = newJObject()
  var header_553650866 = newJObject()
  add(path_553650865, "owner", newJString(owner))
  add(path_553650865, "archive_format", newJString(archiveFormat))
  add(header_553650866, "Accept", newJString(Accept))
  add(path_553650865, "repo", newJString(repo))
  add(path_553650865, "path", newJString(path))
  result = call_553650864.call(path_553650865, nil, header_553650866, nil, nil)

var getReposOwnerRepoArchiveFormatPath* = Call_GetReposOwnerRepoArchiveFormatPath_553650855(
    name: "getReposOwnerRepoArchiveFormatPath", meth: HttpMethod.HttpGet,
    host: "api.github.com",
    route: "/repos/{owner}/{repo}/{archive_format}/{path}",
    validator: validate_GetReposOwnerRepoArchiveFormatPath_553650856, base: "/",
    makeUrl: url_GetReposOwnerRepoArchiveFormatPath_553650857,
    schemes: {Scheme.Https})
type
  Call_GetRepositories_553650867 = ref object of OpenApiRestCall_553648476
proc url_GetRepositories_553650869(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode;
                                   query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRepositories_553650868(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List all public repositories.
  ## This provides a dump of every public repository, in the order that they
  ## were created.
  ## Note: Pagination is powered exclusively by the since parameter. is the
  ## Link header to get the URL for the next page of repositories.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_553650870 = query.getOrDefault("since")
  valid_553650870 = validateParameter(valid_553650870, JString,
                                      required = false, default = nil)
  if valid_553650870 != nil:
    section.add "since", valid_553650870
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650871 = header.getOrDefault("Accept")
  valid_553650871 = validateParameter(valid_553650871, JString,
                                      required = false, default = nil)
  if valid_553650871 != nil:
    section.add "Accept", valid_553650871
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650872: Call_GetRepositories_553650867; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List all public repositories.
  ## This provides a dump of every public repository, in the order that they
  ## were created.
  ## Note: Pagination is powered exclusively by the since parameter. is the
  ## Link header to get the URL for the next page of repositories.
  ## 
  ## 
  let valid = call_553650872.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650872.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650872.makeUrl(scheme.get, call_553650872.host, call_553650872.base,
                                   call_553650872.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650872, uri, valid, content)

proc call*(call_553650873: Call_GetRepositories_553650867; Accept: string = "";
           since: string = ""): Recallable =
  ## getRepositories
  ## List all public repositories.
  ## This provides a dump of every public repository, in the order that they
  ## were created.
  ## Note: Pagination is powered exclusively by the since parameter. is the
  ## Link header to get the URL for the next page of repositories.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var query_553650874 = newJObject()
  var header_553650875 = newJObject()
  add(header_553650875, "Accept", newJString(Accept))
  add(query_553650874, "since", newJString(since))
  result = call_553650873.call(nil, query_553650874, header_553650875, nil, nil)

var getRepositories* = Call_GetRepositories_553650867(name: "getRepositories",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/repositories",
    validator: validate_GetRepositories_553650868, base: "/",
    makeUrl: url_GetRepositories_553650869, schemes: {Scheme.Https})
type
  Call_GetSearchCode_553650876 = ref object of OpenApiRestCall_553648476
proc url_GetSearchCode_553650878(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchCode_553650877(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Search code.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   sort: JString
  ##       : Can only be 'indexed', which indicates how recently a file has been indexed
  ## by the GitHub search infrastructure. If not provided, results are sorted
  ## by best match.
  ## 
  ##   q: JString (required)
  ##    : The search terms. This can be any combination of the supported code
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier
  ## you can restrict the search to just the file contents, the file path,
  ## or both.
  ## 'Languages' Searches code based on the language it's written in.
  ## 'Forks' Filters repositories based on the number of forks, and/or
  ## whether code from forked repositories should be included in the results
  ## at all.
  ## 'Size' Finds files that match a certain size (in bytes).
  ## 'Path' Specifies the path that the resulting file must be at.
  ## 'Extension' Matches files with a certain extension.
  ## 'Users' or 'Repositories' Limits searches to a specific user or repository.
  ## 
  section = newJObject()
  var valid_553650879 = query.getOrDefault("order")
  valid_553650879 = validateParameter(valid_553650879, JString,
                                      required = false,
                                      default = newJString("desc"))
  if valid_553650879 != nil:
    section.add "order", valid_553650879
  var valid_553650880 = query.getOrDefault("sort")
  valid_553650880 = validateParameter(valid_553650880, JString,
                                      required = false,
                                      default = newJString("indexed"))
  if valid_553650880 != nil:
    section.add "sort", valid_553650880
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_553650881 = query.getOrDefault("q")
  valid_553650881 = validateParameter(valid_553650881, JString, required = true,
                                      default = nil)
  if valid_553650881 != nil:
    section.add "q", valid_553650881
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650882 = header.getOrDefault("Accept")
  valid_553650882 = validateParameter(valid_553650882, JString,
                                      required = false, default = nil)
  if valid_553650882 != nil:
    section.add "Accept", valid_553650882
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650883: Call_GetSearchCode_553650876; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Search code.
  ## 
  let valid = call_553650883.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650883.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650883.makeUrl(scheme.get, call_553650883.host, call_553650883.base,
                                   call_553650883.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650883, uri, valid, content)

proc call*(call_553650884: Call_GetSearchCode_553650876; q: string;
           order: string = "desc"; Accept: string = ""; sort: string = "indexed"): Recallable =
  ## getSearchCode
  ## Search code.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##       : Can only be 'indexed', which indicates how recently a file has been indexed
  ## by the GitHub search infrastructure. If not provided, results are sorted
  ## by best match.
  ## 
  ##   q: string (required)
  ##    : The search terms. This can be any combination of the supported code
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier
  ## you can restrict the search to just the file contents, the file path,
  ## or both.
  ## 'Languages' Searches code based on the language it's written in.
  ## 'Forks' Filters repositories based on the number of forks, and/or
  ## whether code from forked repositories should be included in the results
  ## at all.
  ## 'Size' Finds files that match a certain size (in bytes).
  ## 'Path' Specifies the path that the resulting file must be at.
  ## 'Extension' Matches files with a certain extension.
  ## 'Users' or 'Repositories' Limits searches to a specific user or repository.
  ## 
  var query_553650885 = newJObject()
  var header_553650886 = newJObject()
  add(query_553650885, "order", newJString(order))
  add(header_553650886, "Accept", newJString(Accept))
  add(query_553650885, "sort", newJString(sort))
  add(query_553650885, "q", newJString(q))
  result = call_553650884.call(nil, query_553650885, header_553650886, nil, nil)

var getSearchCode* = Call_GetSearchCode_553650876(name: "getSearchCode",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/search/code",
    validator: validate_GetSearchCode_553650877, base: "/",
    makeUrl: url_GetSearchCode_553650878, schemes: {Scheme.Https})
type
  Call_GetSearchIssues_553650887 = ref object of OpenApiRestCall_553648476
proc url_GetSearchIssues_553650889(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode;
                                   query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchIssues_553650888(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Find issues by state and keyword. (This method returns up to 100 results per page.)
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   sort: JString
  ##       : The sort field. Can be comments, created, or updated. Default: results are sorted by best match.
  ##   q: JString (required)
  ##    : The q search term can also contain any combination of the supported issue search qualifiers:
  section = newJObject()
  var valid_553650890 = query.getOrDefault("order")
  valid_553650890 = validateParameter(valid_553650890, JString,
                                      required = false,
                                      default = newJString("desc"))
  if valid_553650890 != nil:
    section.add "order", valid_553650890
  var valid_553650891 = query.getOrDefault("sort")
  valid_553650891 = validateParameter(valid_553650891, JString,
                                      required = false,
                                      default = newJString("updated"))
  if valid_553650891 != nil:
    section.add "sort", valid_553650891
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_553650892 = query.getOrDefault("q")
  valid_553650892 = validateParameter(valid_553650892, JString, required = true,
                                      default = nil)
  if valid_553650892 != nil:
    section.add "q", valid_553650892
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650893 = header.getOrDefault("Accept")
  valid_553650893 = validateParameter(valid_553650893, JString,
                                      required = false, default = nil)
  if valid_553650893 != nil:
    section.add "Accept", valid_553650893
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650894: Call_GetSearchIssues_553650887; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Find issues by state and keyword. (This method returns up to 100 results per page.)
  ## 
  let valid = call_553650894.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650894.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650894.makeUrl(scheme.get, call_553650894.host, call_553650894.base,
                                   call_553650894.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650894, uri, valid, content)

proc call*(call_553650895: Call_GetSearchIssues_553650887; q: string;
           order: string = "desc"; Accept: string = ""; sort: string = "updated"): Recallable =
  ## getSearchIssues
  ## Find issues by state and keyword. (This method returns up to 100 results per page.)
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##       : The sort field. Can be comments, created, or updated. Default: results are sorted by best match.
  ##   q: string (required)
  ##    : The q search term can also contain any combination of the supported issue search qualifiers:
  var query_553650896 = newJObject()
  var header_553650897 = newJObject()
  add(query_553650896, "order", newJString(order))
  add(header_553650897, "Accept", newJString(Accept))
  add(query_553650896, "sort", newJString(sort))
  add(query_553650896, "q", newJString(q))
  result = call_553650895.call(nil, query_553650896, header_553650897, nil, nil)

var getSearchIssues* = Call_GetSearchIssues_553650887(name: "getSearchIssues",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/search/issues",
    validator: validate_GetSearchIssues_553650888, base: "/",
    makeUrl: url_GetSearchIssues_553650889, schemes: {Scheme.Https})
type
  Call_GetSearchRepositories_553650898 = ref object of OpenApiRestCall_553648476
proc url_GetSearchRepositories_553650900(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchRepositories_553650899(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Search repositories.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   sort: JString
  ##       : If not provided, results are sorted by best match.
  ##   q: JString (required)
  ##    : The search terms. This can be any combination of the supported repository
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the repository name, description, readme,
  ## or any combination of these.
  ## 'Size' Finds repositories that match a certain size (in kilobytes).
  ## 'Forks' Filters repositories based on the number of forks, and/or whether
  ## forked repositories should be included in the results at all.
  ## 'Created' and 'Last Updated' Filters repositories based on times of
  ## creation, or when they were last updated.
  ## 'Users or Repositories' Limits searches to a specific user or repository.
  ## 'Languages' Searches repositories based on the language they are written in.
  ## 'Stars' Searches repositories based on the number of stars.
  ## 
  section = newJObject()
  var valid_553650901 = query.getOrDefault("order")
  valid_553650901 = validateParameter(valid_553650901, JString,
                                      required = false,
                                      default = newJString("desc"))
  if valid_553650901 != nil:
    section.add "order", valid_553650901
  var valid_553650902 = query.getOrDefault("sort")
  valid_553650902 = validateParameter(valid_553650902, JString,
                                      required = false,
                                      default = newJString("stars"))
  if valid_553650902 != nil:
    section.add "sort", valid_553650902
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_553650903 = query.getOrDefault("q")
  valid_553650903 = validateParameter(valid_553650903, JString, required = true,
                                      default = nil)
  if valid_553650903 != nil:
    section.add "q", valid_553650903
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650904 = header.getOrDefault("Accept")
  valid_553650904 = validateParameter(valid_553650904, JString,
                                      required = false, default = nil)
  if valid_553650904 != nil:
    section.add "Accept", valid_553650904
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650905: Call_GetSearchRepositories_553650898;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Search repositories.
  ## 
  let valid = call_553650905.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650905.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650905.makeUrl(scheme.get, call_553650905.host, call_553650905.base,
                                   call_553650905.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650905, uri, valid, content)

proc call*(call_553650906: Call_GetSearchRepositories_553650898; q: string;
           order: string = "desc"; Accept: string = ""; sort: string = "stars"): Recallable =
  ## getSearchRepositories
  ## Search repositories.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##       : If not provided, results are sorted by best match.
  ##   q: string (required)
  ##    : The search terms. This can be any combination of the supported repository
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the repository name, description, readme,
  ## or any combination of these.
  ## 'Size' Finds repositories that match a certain size (in kilobytes).
  ## 'Forks' Filters repositories based on the number of forks, and/or whether
  ## forked repositories should be included in the results at all.
  ## 'Created' and 'Last Updated' Filters repositories based on times of
  ## creation, or when they were last updated.
  ## 'Users or Repositories' Limits searches to a specific user or repository.
  ## 'Languages' Searches repositories based on the language they are written in.
  ## 'Stars' Searches repositories based on the number of stars.
  ## 
  var query_553650907 = newJObject()
  var header_553650908 = newJObject()
  add(query_553650907, "order", newJString(order))
  add(header_553650908, "Accept", newJString(Accept))
  add(query_553650907, "sort", newJString(sort))
  add(query_553650907, "q", newJString(q))
  result = call_553650906.call(nil, query_553650907, header_553650908, nil, nil)

var getSearchRepositories* = Call_GetSearchRepositories_553650898(
    name: "getSearchRepositories", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/search/repositories",
    validator: validate_GetSearchRepositories_553650899, base: "/",
    makeUrl: url_GetSearchRepositories_553650900, schemes: {Scheme.Https})
type
  Call_GetSearchUsers_553650909 = ref object of OpenApiRestCall_553648476
proc url_GetSearchUsers_553650911(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetSearchUsers_553650910(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Search users.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   order: JString
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   sort: JString
  ##       : If not provided, results are sorted by best match.
  ##   q: JString (required)
  ##    : The search terms. This can be any combination of the supported user
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the username, public email, full name,
  ## location, or any combination of these.
  ## 'Repository count' Filters users based on the number of repositories they
  ## have.
  ## 'Location' Filter users by the location indicated in their profile.
  ## 'Language' Search for users that have repositories that match a certain
  ## language.
  ## 'Created' Filter users based on when they joined.
  ## 'Followers' Filter users based on the number of followers they have.
  ## 
  section = newJObject()
  var valid_553650912 = query.getOrDefault("order")
  valid_553650912 = validateParameter(valid_553650912, JString,
                                      required = false,
                                      default = newJString("desc"))
  if valid_553650912 != nil:
    section.add "order", valid_553650912
  var valid_553650913 = query.getOrDefault("sort")
  valid_553650913 = validateParameter(valid_553650913, JString,
                                      required = false,
                                      default = newJString("followers"))
  if valid_553650913 != nil:
    section.add "sort", valid_553650913
  assert query != nil, "query argument is necessary due to required `q` field"
  var valid_553650914 = query.getOrDefault("q")
  valid_553650914 = validateParameter(valid_553650914, JString, required = true,
                                      default = nil)
  if valid_553650914 != nil:
    section.add "q", valid_553650914
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650915 = header.getOrDefault("Accept")
  valid_553650915 = validateParameter(valid_553650915, JString,
                                      required = false, default = nil)
  if valid_553650915 != nil:
    section.add "Accept", valid_553650915
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650916: Call_GetSearchUsers_553650909; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Search users.
  ## 
  let valid = call_553650916.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650916.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650916.makeUrl(scheme.get, call_553650916.host, call_553650916.base,
                                   call_553650916.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650916, uri, valid, content)

proc call*(call_553650917: Call_GetSearchUsers_553650909; q: string;
           order: string = "desc"; Accept: string = "";
           sort: string = "followers"): Recallable =
  ## getSearchUsers
  ## Search users.
  ##   order: string
  ##        : The sort field. if sort param is provided. Can be either asc or desc.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##       : If not provided, results are sorted by best match.
  ##   q: string (required)
  ##    : The search terms. This can be any combination of the supported user
  ## search parameters:
  ## 'Search In' Qualifies which fields are searched. With this qualifier you
  ## can restrict the search to just the username, public email, full name,
  ## location, or any combination of these.
  ## 'Repository count' Filters users based on the number of repositories they
  ## have.
  ## 'Location' Filter users by the location indicated in their profile.
  ## 'Language' Search for users that have repositories that match a certain
  ## language.
  ## 'Created' Filter users based on when they joined.
  ## 'Followers' Filter users based on the number of followers they have.
  ## 
  var query_553650918 = newJObject()
  var header_553650919 = newJObject()
  add(query_553650918, "order", newJString(order))
  add(header_553650919, "Accept", newJString(Accept))
  add(query_553650918, "sort", newJString(sort))
  add(query_553650918, "q", newJString(q))
  result = call_553650917.call(nil, query_553650918, header_553650919, nil, nil)

var getSearchUsers* = Call_GetSearchUsers_553650909(name: "getSearchUsers",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/search/users",
    validator: validate_GetSearchUsers_553650910, base: "/",
    makeUrl: url_GetSearchUsers_553650911, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamId_553650920 = ref object of OpenApiRestCall_553648476
proc url_GetTeamsTeamId_553650922(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
                 (kind: VariableSegment, value: "teamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamId_553650921(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Get team.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `teamId` field"
  var valid_553650923 = path.getOrDefault("teamId")
  valid_553650923 = validateParameter(valid_553650923, JInt, required = true,
                                      default = nil)
  if valid_553650923 != nil:
    section.add "teamId", valid_553650923
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650924 = header.getOrDefault("Accept")
  valid_553650924 = validateParameter(valid_553650924, JString,
                                      required = false, default = nil)
  if valid_553650924 != nil:
    section.add "Accept", valid_553650924
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650925: Call_GetTeamsTeamId_553650920; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get team.
  ## 
  let valid = call_553650925.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650925.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650925.makeUrl(scheme.get, call_553650925.host, call_553650925.base,
                                   call_553650925.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650925, uri, valid, content)

proc call*(call_553650926: Call_GetTeamsTeamId_553650920; teamId: int;
           Accept: string = ""): Recallable =
  ## getTeamsTeamId
  ## Get team.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_553650927 = newJObject()
  var header_553650928 = newJObject()
  add(header_553650928, "Accept", newJString(Accept))
  add(path_553650927, "teamId", newJInt(teamId))
  result = call_553650926.call(path_553650927, nil, header_553650928, nil, nil)

var getTeamsTeamId* = Call_GetTeamsTeamId_553650920(name: "getTeamsTeamId",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/teams/{teamId}",
    validator: validate_GetTeamsTeamId_553650921, base: "/",
    makeUrl: url_GetTeamsTeamId_553650922, schemes: {Scheme.Https})
type
  Call_PatchTeamsTeamId_553650938 = ref object of OpenApiRestCall_553648476
proc url_PatchTeamsTeamId_553650940(protocol: Scheme; host: string;
                                    base: string; route: string; path: JsonNode;
                                    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
                 (kind: VariableSegment, value: "teamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PatchTeamsTeamId_553650939(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Edit team.
  ## In order to edit a team, the authenticated user must be an owner of the org
  ## that the team is associated with.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `teamId` field"
  var valid_553650941 = path.getOrDefault("teamId")
  valid_553650941 = validateParameter(valid_553650941, JInt, required = true,
                                      default = nil)
  if valid_553650941 != nil:
    section.add "teamId", valid_553650941
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650942 = header.getOrDefault("Accept")
  valid_553650942 = validateParameter(valid_553650942, JString,
                                      required = false, default = nil)
  if valid_553650942 != nil:
    section.add "Accept", valid_553650942
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553650944: Call_PatchTeamsTeamId_553650938;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Edit team.
  ## In order to edit a team, the authenticated user must be an owner of the org
  ## that the team is associated with.
  ## 
  ## 
  let valid = call_553650944.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650944.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650944.makeUrl(scheme.get, call_553650944.host, call_553650944.base,
                                   call_553650944.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650944, uri, valid, content)

proc call*(call_553650945: Call_PatchTeamsTeamId_553650938; body: JsonNode;
           teamId: int; Accept: string = ""): Recallable =
  ## patchTeamsTeamId
  ## Edit team.
  ## In order to edit a team, the authenticated user must be an owner of the org
  ## that the team is associated with.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  ##   teamId: int (required)
  ##         : Id of team.
  var path_553650946 = newJObject()
  var header_553650947 = newJObject()
  var body_553650948 = newJObject()
  add(header_553650947, "Accept", newJString(Accept))
  if body != nil:
    body_553650948 = body
  add(path_553650946, "teamId", newJInt(teamId))
  result = call_553650945.call(path_553650946, nil, header_553650947, nil, body_553650948)

var patchTeamsTeamId* = Call_PatchTeamsTeamId_553650938(
    name: "patchTeamsTeamId", meth: HttpMethod.HttpPatch,
    host: "api.github.com", route: "/teams/{teamId}",
    validator: validate_PatchTeamsTeamId_553650939, base: "/",
    makeUrl: url_PatchTeamsTeamId_553650940, schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamId_553650929 = ref object of OpenApiRestCall_553648476
proc url_DeleteTeamsTeamId_553650931(protocol: Scheme; host: string;
                                     base: string; route: string;
                                     path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
                 (kind: VariableSegment, value: "teamId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamId_553650930(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Delete team.
  ## In order to delete a team, the authenticated user must be an owner of the
  ## org that the team is associated with.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `teamId` field"
  var valid_553650932 = path.getOrDefault("teamId")
  valid_553650932 = validateParameter(valid_553650932, JInt, required = true,
                                      default = nil)
  if valid_553650932 != nil:
    section.add "teamId", valid_553650932
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650933 = header.getOrDefault("Accept")
  valid_553650933 = validateParameter(valid_553650933, JString,
                                      required = false, default = nil)
  if valid_553650933 != nil:
    section.add "Accept", valid_553650933
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650934: Call_DeleteTeamsTeamId_553650929;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Delete team.
  ## In order to delete a team, the authenticated user must be an owner of the
  ## org that the team is associated with.
  ## 
  ## 
  let valid = call_553650934.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650934.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650934.makeUrl(scheme.get, call_553650934.host, call_553650934.base,
                                   call_553650934.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650934, uri, valid, content)

proc call*(call_553650935: Call_DeleteTeamsTeamId_553650929; teamId: int;
           Accept: string = ""): Recallable =
  ## deleteTeamsTeamId
  ## Delete team.
  ## In order to delete a team, the authenticated user must be an owner of the
  ## org that the team is associated with.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_553650936 = newJObject()
  var header_553650937 = newJObject()
  add(header_553650937, "Accept", newJString(Accept))
  add(path_553650936, "teamId", newJInt(teamId))
  result = call_553650935.call(path_553650936, nil, header_553650937, nil, nil)

var deleteTeamsTeamId* = Call_DeleteTeamsTeamId_553650929(
    name: "deleteTeamsTeamId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/teams/{teamId}",
    validator: validate_DeleteTeamsTeamId_553650930, base: "/",
    makeUrl: url_DeleteTeamsTeamId_553650931, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdMembers_553650949 = ref object of OpenApiRestCall_553648476
proc url_GetTeamsTeamIdMembers_553650951(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
                 (kind: VariableSegment, value: "teamId"),
                 (kind: ConstantSegment, value: "/members")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdMembers_553650950(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List team members.
  ## In order to list members in a team, the authenticated user must be a member
  ## of the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `teamId` field"
  var valid_553650952 = path.getOrDefault("teamId")
  valid_553650952 = validateParameter(valid_553650952, JInt, required = true,
                                      default = nil)
  if valid_553650952 != nil:
    section.add "teamId", valid_553650952
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650953 = header.getOrDefault("Accept")
  valid_553650953 = validateParameter(valid_553650953, JString,
                                      required = false, default = nil)
  if valid_553650953 != nil:
    section.add "Accept", valid_553650953
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650954: Call_GetTeamsTeamIdMembers_553650949;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List team members.
  ## In order to list members in a team, the authenticated user must be a member
  ## of the team.
  ## 
  ## 
  let valid = call_553650954.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650954.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650954.makeUrl(scheme.get, call_553650954.host, call_553650954.base,
                                   call_553650954.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650954, uri, valid, content)

proc call*(call_553650955: Call_GetTeamsTeamIdMembers_553650949; teamId: int;
           Accept: string = ""): Recallable =
  ## getTeamsTeamIdMembers
  ## List team members.
  ## In order to list members in a team, the authenticated user must be a member
  ## of the team.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_553650956 = newJObject()
  var header_553650957 = newJObject()
  add(header_553650957, "Accept", newJString(Accept))
  add(path_553650956, "teamId", newJInt(teamId))
  result = call_553650955.call(path_553650956, nil, header_553650957, nil, nil)

var getTeamsTeamIdMembers* = Call_GetTeamsTeamIdMembers_553650949(
    name: "getTeamsTeamIdMembers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/teams/{teamId}/members",
    validator: validate_GetTeamsTeamIdMembers_553650950, base: "/",
    makeUrl: url_GetTeamsTeamIdMembers_553650951, schemes: {Scheme.Https})
type
  Call_PutTeamsTeamIdMembersUsername_553650968 = ref object of OpenApiRestCall_553648476
proc url_PutTeamsTeamIdMembersUsername_553650970(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
                 (kind: VariableSegment, value: "teamId"),
                 (kind: ConstantSegment, value: "/members/"),
                 (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutTeamsTeamIdMembersUsername_553650969(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## The API (described below) is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Add team membership API instead. It allows you to invite new organization members to your teams.
  ## 
  ## Add team member.
  ## In order to add a user to a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `username` field"
  var valid_553650971 = path.getOrDefault("username")
  valid_553650971 = validateParameter(valid_553650971, JString, required = true,
                                      default = nil)
  if valid_553650971 != nil:
    section.add "username", valid_553650971
  var valid_553650972 = path.getOrDefault("teamId")
  valid_553650972 = validateParameter(valid_553650972, JInt, required = true,
                                      default = nil)
  if valid_553650972 != nil:
    section.add "teamId", valid_553650972
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650973 = header.getOrDefault("Accept")
  valid_553650973 = validateParameter(valid_553650973, JString,
                                      required = false, default = nil)
  if valid_553650973 != nil:
    section.add "Accept", valid_553650973
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650974: Call_PutTeamsTeamIdMembersUsername_553650968;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## The API (described below) is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Add team membership API instead. It allows you to invite new organization members to your teams.
  ## 
  ## Add team member.
  ## In order to add a user to a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## 
  ## 
  let valid = call_553650974.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650974.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650974.makeUrl(scheme.get, call_553650974.host, call_553650974.base,
                                   call_553650974.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650974, uri, valid, content)

proc call*(call_553650975: Call_PutTeamsTeamIdMembersUsername_553650968;
           username: string; teamId: int; Accept: string = ""): Recallable =
  ## putTeamsTeamIdMembersUsername
  ## The API (described below) is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Add team membership API instead. It allows you to invite new organization members to your teams.
  ## 
  ## Add team member.
  ## In order to add a user to a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_553650976 = newJObject()
  var header_553650977 = newJObject()
  add(path_553650976, "username", newJString(username))
  add(header_553650977, "Accept", newJString(Accept))
  add(path_553650976, "teamId", newJInt(teamId))
  result = call_553650975.call(path_553650976, nil, header_553650977, nil, nil)

var putTeamsTeamIdMembersUsername* = Call_PutTeamsTeamIdMembersUsername_553650968(
    name: "putTeamsTeamIdMembersUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/teams/{teamId}/members/{username}",
    validator: validate_PutTeamsTeamIdMembersUsername_553650969, base: "/",
    makeUrl: url_PutTeamsTeamIdMembersUsername_553650970,
    schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdMembersUsername_553650958 = ref object of OpenApiRestCall_553648476
proc url_GetTeamsTeamIdMembersUsername_553650960(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
                 (kind: VariableSegment, value: "teamId"),
                 (kind: ConstantSegment, value: "/members/"),
                 (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdMembersUsername_553650959(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## The "Get team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Get team membership API instead. It allows you to get both active and pending memberships.
  ## 
  ## Get team member.
  ## In order to get if a user is a member of a team, the authenticated user mus
  ## be a member of the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `username` field"
  var valid_553650961 = path.getOrDefault("username")
  valid_553650961 = validateParameter(valid_553650961, JString, required = true,
                                      default = nil)
  if valid_553650961 != nil:
    section.add "username", valid_553650961
  var valid_553650962 = path.getOrDefault("teamId")
  valid_553650962 = validateParameter(valid_553650962, JInt, required = true,
                                      default = nil)
  if valid_553650962 != nil:
    section.add "teamId", valid_553650962
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650963 = header.getOrDefault("Accept")
  valid_553650963 = validateParameter(valid_553650963, JString,
                                      required = false, default = nil)
  if valid_553650963 != nil:
    section.add "Accept", valid_553650963
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650964: Call_GetTeamsTeamIdMembersUsername_553650958;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## The "Get team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Get team membership API instead. It allows you to get both active and pending memberships.
  ## 
  ## Get team member.
  ## In order to get if a user is a member of a team, the authenticated user mus
  ## be a member of the team.
  ## 
  ## 
  let valid = call_553650964.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650964.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650964.makeUrl(scheme.get, call_553650964.host, call_553650964.base,
                                   call_553650964.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650964, uri, valid, content)

proc call*(call_553650965: Call_GetTeamsTeamIdMembersUsername_553650958;
           username: string; teamId: int; Accept: string = ""): Recallable =
  ## getTeamsTeamIdMembersUsername
  ## The "Get team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Get team membership API instead. It allows you to get both active and pending memberships.
  ## 
  ## Get team member.
  ## In order to get if a user is a member of a team, the authenticated user mus
  ## be a member of the team.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_553650966 = newJObject()
  var header_553650967 = newJObject()
  add(path_553650966, "username", newJString(username))
  add(header_553650967, "Accept", newJString(Accept))
  add(path_553650966, "teamId", newJInt(teamId))
  result = call_553650965.call(path_553650966, nil, header_553650967, nil, nil)

var getTeamsTeamIdMembersUsername* = Call_GetTeamsTeamIdMembersUsername_553650958(
    name: "getTeamsTeamIdMembersUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/teams/{teamId}/members/{username}",
    validator: validate_GetTeamsTeamIdMembersUsername_553650959, base: "/",
    makeUrl: url_GetTeamsTeamIdMembersUsername_553650960,
    schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamIdMembersUsername_553650978 = ref object of OpenApiRestCall_553648476
proc url_DeleteTeamsTeamIdMembersUsername_553650980(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
                 (kind: VariableSegment, value: "teamId"),
                 (kind: ConstantSegment, value: "/members/"),
                 (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamIdMembersUsername_553650979(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## The "Remove team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Remove team membership API instead. It allows you to remove both active and pending memberships.
  ## 
  ## Remove team member.
  ## In order to remove a user from a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## NOTE This does not delete the user, it just remove them from the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `username` field"
  var valid_553650981 = path.getOrDefault("username")
  valid_553650981 = validateParameter(valid_553650981, JString, required = true,
                                      default = nil)
  if valid_553650981 != nil:
    section.add "username", valid_553650981
  var valid_553650982 = path.getOrDefault("teamId")
  valid_553650982 = validateParameter(valid_553650982, JInt, required = true,
                                      default = nil)
  if valid_553650982 != nil:
    section.add "teamId", valid_553650982
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650983 = header.getOrDefault("Accept")
  valid_553650983 = validateParameter(valid_553650983, JString,
                                      required = false, default = nil)
  if valid_553650983 != nil:
    section.add "Accept", valid_553650983
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650984: Call_DeleteTeamsTeamIdMembersUsername_553650978;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## The "Remove team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Remove team membership API instead. It allows you to remove both active and pending memberships.
  ## 
  ## Remove team member.
  ## In order to remove a user from a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## NOTE This does not delete the user, it just remove them from the team.
  ## 
  ## 
  let valid = call_553650984.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650984.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650984.makeUrl(scheme.get, call_553650984.host, call_553650984.base,
                                   call_553650984.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650984, uri, valid, content)

proc call*(call_553650985: Call_DeleteTeamsTeamIdMembersUsername_553650978;
           username: string; teamId: int; Accept: string = ""): Recallable =
  ## deleteTeamsTeamIdMembersUsername
  ## The "Remove team member" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Remove team membership API instead. It allows you to remove both active and pending memberships.
  ## 
  ## Remove team member.
  ## In order to remove a user from a team, the authenticated user must have 'admin'
  ## permissions to the team or be an owner of the org that the team is associated
  ## with.
  ## NOTE This does not delete the user, it just remove them from the team.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_553650986 = newJObject()
  var header_553650987 = newJObject()
  add(path_553650986, "username", newJString(username))
  add(header_553650987, "Accept", newJString(Accept))
  add(path_553650986, "teamId", newJInt(teamId))
  result = call_553650985.call(path_553650986, nil, header_553650987, nil, nil)

var deleteTeamsTeamIdMembersUsername* = Call_DeleteTeamsTeamIdMembersUsername_553650978(
    name: "deleteTeamsTeamIdMembersUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/teams/{teamId}/members/{username}",
    validator: validate_DeleteTeamsTeamIdMembersUsername_553650979, base: "/",
    makeUrl: url_DeleteTeamsTeamIdMembersUsername_553650980,
    schemes: {Scheme.Https})
type
  Call_PutTeamsTeamIdMembershipsUsername_553650998 = ref object of OpenApiRestCall_553648476
proc url_PutTeamsTeamIdMembershipsUsername_553651000(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
                 (kind: VariableSegment, value: "teamId"),
                 (kind: ConstantSegment, value: "/memberships/"),
                 (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutTeamsTeamIdMembershipsUsername_553650999(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Add team membership.
  ## In order to add a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with.
  ## 
  ## If the user is already a part of the team's organization (meaning they're on at least one other team in the organization), this endpoint will add the user to the team.
  ## 
  ## If the user is completely unaffiliated with the team's organization (meaning they're on none of the organization's teams), this endpoint will send an invitation to the user via email. This newly-created membership will be in the 'pending' state until the user accepts the invitation, at which point the membership will transition to the 'active' state and the user will be added as a member of the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `username` field"
  var valid_553651001 = path.getOrDefault("username")
  valid_553651001 = validateParameter(valid_553651001, JString, required = true,
                                      default = nil)
  if valid_553651001 != nil:
    section.add "username", valid_553651001
  var valid_553651002 = path.getOrDefault("teamId")
  valid_553651002 = validateParameter(valid_553651002, JInt, required = true,
                                      default = nil)
  if valid_553651002 != nil:
    section.add "teamId", valid_553651002
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651003 = header.getOrDefault("Accept")
  valid_553651003 = validateParameter(valid_553651003, JString,
                                      required = false, default = nil)
  if valid_553651003 != nil:
    section.add "Accept", valid_553651003
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651004: Call_PutTeamsTeamIdMembershipsUsername_553650998;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Add team membership.
  ## In order to add a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with.
  ## 
  ## If the user is already a part of the team's organization (meaning they're on at least one other team in the organization), this endpoint will add the user to the team.
  ## 
  ## If the user is completely unaffiliated with the team's organization (meaning they're on none of the organization's teams), this endpoint will send an invitation to the user via email. This newly-created membership will be in the 'pending' state until the user accepts the invitation, at which point the membership will transition to the 'active' state and the user will be added as a member of the team.
  ## 
  ## 
  let valid = call_553651004.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651004.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651004.makeUrl(scheme.get, call_553651004.host, call_553651004.base,
                                   call_553651004.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651004, uri, valid, content)

proc call*(call_553651005: Call_PutTeamsTeamIdMembershipsUsername_553650998;
           username: string; teamId: int; Accept: string = ""): Recallable =
  ## putTeamsTeamIdMembershipsUsername
  ## Add team membership.
  ## In order to add a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with.
  ## 
  ## If the user is already a part of the team's organization (meaning they're on at least one other team in the organization), this endpoint will add the user to the team.
  ## 
  ## If the user is completely unaffiliated with the team's organization (meaning they're on none of the organization's teams), this endpoint will send an invitation to the user via email. This newly-created membership will be in the 'pending' state until the user accepts the invitation, at which point the membership will transition to the 'active' state and the user will be added as a member of the team.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_553651006 = newJObject()
  var header_553651007 = newJObject()
  add(path_553651006, "username", newJString(username))
  add(header_553651007, "Accept", newJString(Accept))
  add(path_553651006, "teamId", newJInt(teamId))
  result = call_553651005.call(path_553651006, nil, header_553651007, nil, nil)

var putTeamsTeamIdMembershipsUsername* = Call_PutTeamsTeamIdMembershipsUsername_553650998(
    name: "putTeamsTeamIdMembershipsUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/teams/{teamId}/memberships/{username}",
    validator: validate_PutTeamsTeamIdMembershipsUsername_553650999, base: "/",
    makeUrl: url_PutTeamsTeamIdMembershipsUsername_553651000,
    schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdMembershipsUsername_553650988 = ref object of OpenApiRestCall_553648476
proc url_GetTeamsTeamIdMembershipsUsername_553650990(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
                 (kind: VariableSegment, value: "teamId"),
                 (kind: ConstantSegment, value: "/memberships/"),
                 (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdMembershipsUsername_553650989(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Get team membership.
  ## In order to get a user's membership with a team, the authenticated user must be a member of the team or an owner of the team's organization.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `username` field"
  var valid_553650991 = path.getOrDefault("username")
  valid_553650991 = validateParameter(valid_553650991, JString, required = true,
                                      default = nil)
  if valid_553650991 != nil:
    section.add "username", valid_553650991
  var valid_553650992 = path.getOrDefault("teamId")
  valid_553650992 = validateParameter(valid_553650992, JInt, required = true,
                                      default = nil)
  if valid_553650992 != nil:
    section.add "teamId", valid_553650992
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553650993 = header.getOrDefault("Accept")
  valid_553650993 = validateParameter(valid_553650993, JString,
                                      required = false, default = nil)
  if valid_553650993 != nil:
    section.add "Accept", valid_553650993
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553650994: Call_GetTeamsTeamIdMembershipsUsername_553650988;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get team membership.
  ## In order to get a user's membership with a team, the authenticated user must be a member of the team or an owner of the team's organization.
  ## 
  ## 
  let valid = call_553650994.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553650994.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553650994.makeUrl(scheme.get, call_553650994.host, call_553650994.base,
                                   call_553650994.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553650994, uri, valid, content)

proc call*(call_553650995: Call_GetTeamsTeamIdMembershipsUsername_553650988;
           username: string; teamId: int; Accept: string = ""): Recallable =
  ## getTeamsTeamIdMembershipsUsername
  ## Get team membership.
  ## In order to get a user's membership with a team, the authenticated user must be a member of the team or an owner of the team's organization.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_553650996 = newJObject()
  var header_553650997 = newJObject()
  add(path_553650996, "username", newJString(username))
  add(header_553650997, "Accept", newJString(Accept))
  add(path_553650996, "teamId", newJInt(teamId))
  result = call_553650995.call(path_553650996, nil, header_553650997, nil, nil)

var getTeamsTeamIdMembershipsUsername* = Call_GetTeamsTeamIdMembershipsUsername_553650988(
    name: "getTeamsTeamIdMembershipsUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/teams/{teamId}/memberships/{username}",
    validator: validate_GetTeamsTeamIdMembershipsUsername_553650989, base: "/",
    makeUrl: url_GetTeamsTeamIdMembershipsUsername_553650990,
    schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamIdMembershipsUsername_553651008 = ref object of OpenApiRestCall_553648476
proc url_DeleteTeamsTeamIdMembershipsUsername_553651010(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
                 (kind: VariableSegment, value: "teamId"),
                 (kind: ConstantSegment, value: "/memberships/"),
                 (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamIdMembershipsUsername_553651009(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Remove team membership.
  ## In order to remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. NOTE: This does not delete the user, it just removes their membership from the team.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of a member.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `username` field"
  var valid_553651011 = path.getOrDefault("username")
  valid_553651011 = validateParameter(valid_553651011, JString, required = true,
                                      default = nil)
  if valid_553651011 != nil:
    section.add "username", valid_553651011
  var valid_553651012 = path.getOrDefault("teamId")
  valid_553651012 = validateParameter(valid_553651012, JInt, required = true,
                                      default = nil)
  if valid_553651012 != nil:
    section.add "teamId", valid_553651012
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651013 = header.getOrDefault("Accept")
  valid_553651013 = validateParameter(valid_553651013, JString,
                                      required = false, default = nil)
  if valid_553651013 != nil:
    section.add "Accept", valid_553651013
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651014: Call_DeleteTeamsTeamIdMembershipsUsername_553651008;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Remove team membership.
  ## In order to remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. NOTE: This does not delete the user, it just removes their membership from the team.
  ## 
  ## 
  let valid = call_553651014.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651014.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651014.makeUrl(scheme.get, call_553651014.host, call_553651014.base,
                                   call_553651014.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651014, uri, valid, content)

proc call*(call_553651015: Call_DeleteTeamsTeamIdMembershipsUsername_553651008;
           username: string; teamId: int; Accept: string = ""): Recallable =
  ## deleteTeamsTeamIdMembershipsUsername
  ## Remove team membership.
  ## In order to remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. NOTE: This does not delete the user, it just removes their membership from the team.
  ## 
  ##   username: string (required)
  ##           : Name of a member.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_553651016 = newJObject()
  var header_553651017 = newJObject()
  add(path_553651016, "username", newJString(username))
  add(header_553651017, "Accept", newJString(Accept))
  add(path_553651016, "teamId", newJInt(teamId))
  result = call_553651015.call(path_553651016, nil, header_553651017, nil, nil)

var deleteTeamsTeamIdMembershipsUsername* = Call_DeleteTeamsTeamIdMembershipsUsername_553651008(
    name: "deleteTeamsTeamIdMembershipsUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/teams/{teamId}/memberships/{username}",
    validator: validate_DeleteTeamsTeamIdMembershipsUsername_553651009,
    base: "/", makeUrl: url_DeleteTeamsTeamIdMembershipsUsername_553651010,
    schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdRepos_553651018 = ref object of OpenApiRestCall_553648476
proc url_GetTeamsTeamIdRepos_553651020(protocol: Scheme; host: string;
                                       base: string; route: string;
                                       path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
                 (kind: VariableSegment, value: "teamId"),
                 (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdRepos_553651019(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List team repos
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `teamId` field"
  var valid_553651021 = path.getOrDefault("teamId")
  valid_553651021 = validateParameter(valid_553651021, JInt, required = true,
                                      default = nil)
  if valid_553651021 != nil:
    section.add "teamId", valid_553651021
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651022 = header.getOrDefault("Accept")
  valid_553651022 = validateParameter(valid_553651022, JString,
                                      required = false, default = nil)
  if valid_553651022 != nil:
    section.add "Accept", valid_553651022
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651023: Call_GetTeamsTeamIdRepos_553651018;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List team repos
  ## 
  let valid = call_553651023.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651023.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651023.makeUrl(scheme.get, call_553651023.host, call_553651023.base,
                                   call_553651023.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651023, uri, valid, content)

proc call*(call_553651024: Call_GetTeamsTeamIdRepos_553651018; teamId: int;
           Accept: string = ""): Recallable =
  ## getTeamsTeamIdRepos
  ## List team repos
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_553651025 = newJObject()
  var header_553651026 = newJObject()
  add(header_553651026, "Accept", newJString(Accept))
  add(path_553651025, "teamId", newJInt(teamId))
  result = call_553651024.call(path_553651025, nil, header_553651026, nil, nil)

var getTeamsTeamIdRepos* = Call_GetTeamsTeamIdRepos_553651018(
    name: "getTeamsTeamIdRepos", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/teams/{teamId}/repos",
    validator: validate_GetTeamsTeamIdRepos_553651019, base: "/",
    makeUrl: url_GetTeamsTeamIdRepos_553651020, schemes: {Scheme.Https})
type
  Call_PutTeamsTeamIdReposOwnerRepo_553651038 = ref object of OpenApiRestCall_553648476
proc url_PutTeamsTeamIdReposOwnerRepo_553651040(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
                 (kind: VariableSegment, value: "teamId"),
                 (kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutTeamsTeamIdReposOwnerRepo_553651039(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## In order to add a repository to a team, the authenticated user must be an owner of the org that the team is associated with. Also, the repository must be owned by the organization, or a direct fork of a repository owned by the organization.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of a organization.
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553651041 = path.getOrDefault("owner")
  valid_553651041 = validateParameter(valid_553651041, JString, required = true,
                                      default = nil)
  if valid_553651041 != nil:
    section.add "owner", valid_553651041
  var valid_553651042 = path.getOrDefault("repo")
  valid_553651042 = validateParameter(valid_553651042, JString, required = true,
                                      default = nil)
  if valid_553651042 != nil:
    section.add "repo", valid_553651042
  var valid_553651043 = path.getOrDefault("teamId")
  valid_553651043 = validateParameter(valid_553651043, JInt, required = true,
                                      default = nil)
  if valid_553651043 != nil:
    section.add "teamId", valid_553651043
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651044 = header.getOrDefault("Accept")
  valid_553651044 = validateParameter(valid_553651044, JString,
                                      required = false, default = nil)
  if valid_553651044 != nil:
    section.add "Accept", valid_553651044
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651045: Call_PutTeamsTeamIdReposOwnerRepo_553651038;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## In order to add a repository to a team, the authenticated user must be an owner of the org that the team is associated with. Also, the repository must be owned by the organization, or a direct fork of a repository owned by the organization.
  ## 
  let valid = call_553651045.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651045.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651045.makeUrl(scheme.get, call_553651045.host, call_553651045.base,
                                   call_553651045.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651045, uri, valid, content)

proc call*(call_553651046: Call_PutTeamsTeamIdReposOwnerRepo_553651038;
           owner: string; repo: string; teamId: int; Accept: string = ""): Recallable =
  ## putTeamsTeamIdReposOwnerRepo
  ## In order to add a repository to a team, the authenticated user must be an owner of the org that the team is associated with. Also, the repository must be owned by the organization, or a direct fork of a repository owned by the organization.
  ##   owner: string (required)
  ##        : Name of a organization.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_553651047 = newJObject()
  var header_553651048 = newJObject()
  add(path_553651047, "owner", newJString(owner))
  add(header_553651048, "Accept", newJString(Accept))
  add(path_553651047, "repo", newJString(repo))
  add(path_553651047, "teamId", newJInt(teamId))
  result = call_553651046.call(path_553651047, nil, header_553651048, nil, nil)

var putTeamsTeamIdReposOwnerRepo* = Call_PutTeamsTeamIdReposOwnerRepo_553651038(
    name: "putTeamsTeamIdReposOwnerRepo", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/teams/{teamId}/repos/{owner}/{repo}",
    validator: validate_PutTeamsTeamIdReposOwnerRepo_553651039, base: "/",
    makeUrl: url_PutTeamsTeamIdReposOwnerRepo_553651040, schemes: {Scheme.Https})
type
  Call_GetTeamsTeamIdReposOwnerRepo_553651027 = ref object of OpenApiRestCall_553648476
proc url_GetTeamsTeamIdReposOwnerRepo_553651029(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
                 (kind: VariableSegment, value: "teamId"),
                 (kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetTeamsTeamIdReposOwnerRepo_553651028(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Check if a team manages a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553651030 = path.getOrDefault("owner")
  valid_553651030 = validateParameter(valid_553651030, JString, required = true,
                                      default = nil)
  if valid_553651030 != nil:
    section.add "owner", valid_553651030
  var valid_553651031 = path.getOrDefault("repo")
  valid_553651031 = validateParameter(valid_553651031, JString, required = true,
                                      default = nil)
  if valid_553651031 != nil:
    section.add "repo", valid_553651031
  var valid_553651032 = path.getOrDefault("teamId")
  valid_553651032 = validateParameter(valid_553651032, JInt, required = true,
                                      default = nil)
  if valid_553651032 != nil:
    section.add "teamId", valid_553651032
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651033 = header.getOrDefault("Accept")
  valid_553651033 = validateParameter(valid_553651033, JString,
                                      required = false, default = nil)
  if valid_553651033 != nil:
    section.add "Accept", valid_553651033
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651034: Call_GetTeamsTeamIdReposOwnerRepo_553651027;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Check if a team manages a repository
  ## 
  let valid = call_553651034.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651034.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651034.makeUrl(scheme.get, call_553651034.host, call_553651034.base,
                                   call_553651034.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651034, uri, valid, content)

proc call*(call_553651035: Call_GetTeamsTeamIdReposOwnerRepo_553651027;
           owner: string; repo: string; teamId: int; Accept: string = ""): Recallable =
  ## getTeamsTeamIdReposOwnerRepo
  ## Check if a team manages a repository
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_553651036 = newJObject()
  var header_553651037 = newJObject()
  add(path_553651036, "owner", newJString(owner))
  add(header_553651037, "Accept", newJString(Accept))
  add(path_553651036, "repo", newJString(repo))
  add(path_553651036, "teamId", newJInt(teamId))
  result = call_553651035.call(path_553651036, nil, header_553651037, nil, nil)

var getTeamsTeamIdReposOwnerRepo* = Call_GetTeamsTeamIdReposOwnerRepo_553651027(
    name: "getTeamsTeamIdReposOwnerRepo", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/teams/{teamId}/repos/{owner}/{repo}",
    validator: validate_GetTeamsTeamIdReposOwnerRepo_553651028, base: "/",
    makeUrl: url_GetTeamsTeamIdReposOwnerRepo_553651029, schemes: {Scheme.Https})
type
  Call_DeleteTeamsTeamIdReposOwnerRepo_553651049 = ref object of OpenApiRestCall_553648476
proc url_DeleteTeamsTeamIdReposOwnerRepo_553651051(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "teamId" in path, "`teamId` is a required path parameter"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/teams/"),
                 (kind: VariableSegment, value: "teamId"),
                 (kind: ConstantSegment, value: "/repos/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteTeamsTeamIdReposOwnerRepo_553651050(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## In order to remove a repository from a team, the authenticated user must be an owner of the org that the team is associated with. NOTE: This does not delete the repository, it just removes it from the team.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  ##   repo: JString (required)
  ##       : Name of a repository.
  ##   teamId: JInt (required)
  ##         : Id of team.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553651052 = path.getOrDefault("owner")
  valid_553651052 = validateParameter(valid_553651052, JString, required = true,
                                      default = nil)
  if valid_553651052 != nil:
    section.add "owner", valid_553651052
  var valid_553651053 = path.getOrDefault("repo")
  valid_553651053 = validateParameter(valid_553651053, JString, required = true,
                                      default = nil)
  if valid_553651053 != nil:
    section.add "repo", valid_553651053
  var valid_553651054 = path.getOrDefault("teamId")
  valid_553651054 = validateParameter(valid_553651054, JInt, required = true,
                                      default = nil)
  if valid_553651054 != nil:
    section.add "teamId", valid_553651054
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651055 = header.getOrDefault("Accept")
  valid_553651055 = validateParameter(valid_553651055, JString,
                                      required = false, default = nil)
  if valid_553651055 != nil:
    section.add "Accept", valid_553651055
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651056: Call_DeleteTeamsTeamIdReposOwnerRepo_553651049;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## In order to remove a repository from a team, the authenticated user must be an owner of the org that the team is associated with. NOTE: This does not delete the repository, it just removes it from the team.
  ## 
  let valid = call_553651056.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651056.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651056.makeUrl(scheme.get, call_553651056.host, call_553651056.base,
                                   call_553651056.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651056, uri, valid, content)

proc call*(call_553651057: Call_DeleteTeamsTeamIdReposOwnerRepo_553651049;
           owner: string; repo: string; teamId: int; Accept: string = ""): Recallable =
  ## deleteTeamsTeamIdReposOwnerRepo
  ## In order to remove a repository from a team, the authenticated user must be an owner of the org that the team is associated with. NOTE: This does not delete the repository, it just removes it from the team.
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  ##   teamId: int (required)
  ##         : Id of team.
  var path_553651058 = newJObject()
  var header_553651059 = newJObject()
  add(path_553651058, "owner", newJString(owner))
  add(header_553651059, "Accept", newJString(Accept))
  add(path_553651058, "repo", newJString(repo))
  add(path_553651058, "teamId", newJInt(teamId))
  result = call_553651057.call(path_553651058, nil, header_553651059, nil, nil)

var deleteTeamsTeamIdReposOwnerRepo* = Call_DeleteTeamsTeamIdReposOwnerRepo_553651049(
    name: "deleteTeamsTeamIdReposOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/teams/{teamId}/repos/{owner}/{repo}",
    validator: validate_DeleteTeamsTeamIdReposOwnerRepo_553651050, base: "/",
    makeUrl: url_DeleteTeamsTeamIdReposOwnerRepo_553651051,
    schemes: {Scheme.Https})
type
  Call_GetUser_553651060 = ref object of OpenApiRestCall_553648476
proc url_GetUser_553651062(protocol: Scheme; host: string; base: string;
                           route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUser_553651061(path: JsonNode; query: JsonNode;
                                header: JsonNode; formData: JsonNode;
                                body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Get the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651063 = header.getOrDefault("Accept")
  valid_553651063 = validateParameter(valid_553651063, JString,
                                      required = false, default = nil)
  if valid_553651063 != nil:
    section.add "Accept", valid_553651063
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651064: Call_GetUser_553651060; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get the authenticated user.
  ## 
  let valid = call_553651064.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651064.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651064.makeUrl(scheme.get, call_553651064.host, call_553651064.base,
                                   call_553651064.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651064, uri, valid, content)

proc call*(call_553651065: Call_GetUser_553651060; Accept: string = ""): Recallable =
  ## getUser
  ## Get the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_553651066 = newJObject()
  add(header_553651066, "Accept", newJString(Accept))
  result = call_553651065.call(nil, nil, header_553651066, nil, nil)

var getUser* = Call_GetUser_553651060(name: "getUser", meth: HttpMethod.HttpGet,
                                      host: "api.github.com", route: "/user",
                                      validator: validate_GetUser_553651061,
                                      base: "/", makeUrl: url_GetUser_553651062,
                                      schemes: {Scheme.Https})
type
  Call_PatchUser_553651067 = ref object of OpenApiRestCall_553648476
proc url_PatchUser_553651069(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PatchUser_553651068(path: JsonNode; query: JsonNode;
                                  header: JsonNode; formData: JsonNode;
                                  body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Update the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651070 = header.getOrDefault("Accept")
  valid_553651070 = validateParameter(valid_553651070, JString,
                                      required = false, default = nil)
  if valid_553651070 != nil:
    section.add "Accept", valid_553651070
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553651072: Call_PatchUser_553651067; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Update the authenticated user.
  ## 
  let valid = call_553651072.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651072.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651072.makeUrl(scheme.get, call_553651072.host, call_553651072.base,
                                   call_553651072.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651072, uri, valid, content)

proc call*(call_553651073: Call_PatchUser_553651067; body: JsonNode;
           Accept: string = ""): Recallable =
  ## patchUser
  ## Update the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_553651074 = newJObject()
  var body_553651075 = newJObject()
  add(header_553651074, "Accept", newJString(Accept))
  if body != nil:
    body_553651075 = body
  result = call_553651073.call(nil, nil, header_553651074, nil, body_553651075)

var patchUser* = Call_PatchUser_553651067(name: "patchUser",
    meth: HttpMethod.HttpPatch, host: "api.github.com", route: "/user",
    validator: validate_PatchUser_553651068, base: "/", makeUrl: url_PatchUser_553651069,
    schemes: {Scheme.Https})
type
  Call_PostUserEmails_553651083 = ref object of OpenApiRestCall_553648476
proc url_PostUserEmails_553651085(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostUserEmails_553651084(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Add email address(es).
  ## You can post a single email address or an array of addresses.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651086 = header.getOrDefault("Accept")
  valid_553651086 = validateParameter(valid_553651086, JString,
                                      required = false, default = nil)
  if valid_553651086 != nil:
    section.add "Accept", valid_553651086
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553651088: Call_PostUserEmails_553651083; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Add email address(es).
  ## You can post a single email address or an array of addresses.
  ## 
  ## 
  let valid = call_553651088.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651088.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651088.makeUrl(scheme.get, call_553651088.host, call_553651088.base,
                                   call_553651088.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651088, uri, valid, content)

proc call*(call_553651089: Call_PostUserEmails_553651083; body: JsonNode;
           Accept: string = ""): Recallable =
  ## postUserEmails
  ## Add email address(es).
  ## You can post a single email address or an array of addresses.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  var header_553651090 = newJObject()
  var body_553651091 = newJObject()
  add(header_553651090, "Accept", newJString(Accept))
  if body != nil:
    body_553651091 = body
  result = call_553651089.call(nil, nil, header_553651090, nil, body_553651091)

var postUserEmails* = Call_PostUserEmails_553651083(name: "postUserEmails",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/user/emails",
    validator: validate_PostUserEmails_553651084, base: "/",
    makeUrl: url_PostUserEmails_553651085, schemes: {Scheme.Https})
type
  Call_GetUserEmails_553651076 = ref object of OpenApiRestCall_553648476
proc url_GetUserEmails_553651078(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserEmails_553651077(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List email addresses for a user.
  ## In the final version of the API, this method will return an array of hashes
  ## with extended information for each email address indicating if the address
  ## has been verified and if it's primary email address for GitHub.
  ## Until API v3 is finalized, use the application/vnd.github.v3 media type to
  ## get other response format.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651079 = header.getOrDefault("Accept")
  valid_553651079 = validateParameter(valid_553651079, JString,
                                      required = false, default = nil)
  if valid_553651079 != nil:
    section.add "Accept", valid_553651079
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651080: Call_GetUserEmails_553651076; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List email addresses for a user.
  ## In the final version of the API, this method will return an array of hashes
  ## with extended information for each email address indicating if the address
  ## has been verified and if it's primary email address for GitHub.
  ## Until API v3 is finalized, use the application/vnd.github.v3 media type to
  ## get other response format.
  ## 
  ## 
  let valid = call_553651080.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651080.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651080.makeUrl(scheme.get, call_553651080.host, call_553651080.base,
                                   call_553651080.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651080, uri, valid, content)

proc call*(call_553651081: Call_GetUserEmails_553651076; Accept: string = ""): Recallable =
  ## getUserEmails
  ## List email addresses for a user.
  ## In the final version of the API, this method will return an array of hashes
  ## with extended information for each email address indicating if the address
  ## has been verified and if it's primary email address for GitHub.
  ## Until API v3 is finalized, use the application/vnd.github.v3 media type to
  ## get other response format.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_553651082 = newJObject()
  add(header_553651082, "Accept", newJString(Accept))
  result = call_553651081.call(nil, nil, header_553651082, nil, nil)

var getUserEmails* = Call_GetUserEmails_553651076(name: "getUserEmails",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/emails",
    validator: validate_GetUserEmails_553651077, base: "/",
    makeUrl: url_GetUserEmails_553651078, schemes: {Scheme.Https})
type
  Call_DeleteUserEmails_553651092 = ref object of OpenApiRestCall_553648476
proc url_DeleteUserEmails_553651094(protocol: Scheme; host: string;
                                    base: string; route: string; path: JsonNode;
                                    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_DeleteUserEmails_553651093(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Delete email address(es).
  ## You can include a single email address or an array of addresses.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651095 = header.getOrDefault("Accept")
  valid_553651095 = validateParameter(valid_553651095, JString,
                                      required = false, default = nil)
  if valid_553651095 != nil:
    section.add "Accept", valid_553651095
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JArray (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JArray, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553651097: Call_DeleteUserEmails_553651092;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Delete email address(es).
  ## You can include a single email address or an array of addresses.
  ## 
  ## 
  let valid = call_553651097.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651097.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651097.makeUrl(scheme.get, call_553651097.host, call_553651097.base,
                                   call_553651097.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651097, uri, valid, content)

proc call*(call_553651098: Call_DeleteUserEmails_553651092; body: JsonNode;
           Accept: string = ""): Recallable =
  ## deleteUserEmails
  ## Delete email address(es).
  ## You can include a single email address or an array of addresses.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JArray (required)
  var header_553651099 = newJObject()
  var body_553651100 = newJObject()
  add(header_553651099, "Accept", newJString(Accept))
  if body != nil:
    body_553651100 = body
  result = call_553651098.call(nil, nil, header_553651099, nil, body_553651100)

var deleteUserEmails* = Call_DeleteUserEmails_553651092(
    name: "deleteUserEmails", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/emails",
    validator: validate_DeleteUserEmails_553651093, base: "/",
    makeUrl: url_DeleteUserEmails_553651094, schemes: {Scheme.Https})
type
  Call_GetUserFollowers_553651101 = ref object of OpenApiRestCall_553648476
proc url_GetUserFollowers_553651103(protocol: Scheme; host: string;
                                    base: string; route: string; path: JsonNode;
                                    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserFollowers_553651102(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List the authenticated user's followers
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651104 = header.getOrDefault("Accept")
  valid_553651104 = validateParameter(valid_553651104, JString,
                                      required = false, default = nil)
  if valid_553651104 != nil:
    section.add "Accept", valid_553651104
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651105: Call_GetUserFollowers_553651101;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List the authenticated user's followers
  ## 
  let valid = call_553651105.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651105.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651105.makeUrl(scheme.get, call_553651105.host, call_553651105.base,
                                   call_553651105.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651105, uri, valid, content)

proc call*(call_553651106: Call_GetUserFollowers_553651101; Accept: string = ""): Recallable =
  ## getUserFollowers
  ## List the authenticated user's followers
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_553651107 = newJObject()
  add(header_553651107, "Accept", newJString(Accept))
  result = call_553651106.call(nil, nil, header_553651107, nil, nil)

var getUserFollowers* = Call_GetUserFollowers_553651101(
    name: "getUserFollowers", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/user/followers", validator: validate_GetUserFollowers_553651102,
    base: "/", makeUrl: url_GetUserFollowers_553651103, schemes: {Scheme.Https})
type
  Call_GetUserFollowing_553651108 = ref object of OpenApiRestCall_553648476
proc url_GetUserFollowing_553651110(protocol: Scheme; host: string;
                                    base: string; route: string; path: JsonNode;
                                    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserFollowing_553651109(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List who the authenticated user is following.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651111 = header.getOrDefault("Accept")
  valid_553651111 = validateParameter(valid_553651111, JString,
                                      required = false, default = nil)
  if valid_553651111 != nil:
    section.add "Accept", valid_553651111
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651112: Call_GetUserFollowing_553651108;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List who the authenticated user is following.
  ## 
  let valid = call_553651112.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651112.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651112.makeUrl(scheme.get, call_553651112.host, call_553651112.base,
                                   call_553651112.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651112, uri, valid, content)

proc call*(call_553651113: Call_GetUserFollowing_553651108; Accept: string = ""): Recallable =
  ## getUserFollowing
  ## List who the authenticated user is following.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_553651114 = newJObject()
  add(header_553651114, "Accept", newJString(Accept))
  result = call_553651113.call(nil, nil, header_553651114, nil, nil)

var getUserFollowing* = Call_GetUserFollowing_553651108(
    name: "getUserFollowing", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/user/following", validator: validate_GetUserFollowing_553651109,
    base: "/", makeUrl: url_GetUserFollowing_553651110, schemes: {Scheme.Https})
type
  Call_PutUserFollowingUsername_553651124 = ref object of OpenApiRestCall_553648476
proc url_PutUserFollowingUsername_553651126(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/following/"),
                 (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutUserFollowingUsername_553651125(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Follow a user.
  ## Following a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `username` field"
  var valid_553651127 = path.getOrDefault("username")
  valid_553651127 = validateParameter(valid_553651127, JString, required = true,
                                      default = nil)
  if valid_553651127 != nil:
    section.add "username", valid_553651127
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651128 = header.getOrDefault("Accept")
  valid_553651128 = validateParameter(valid_553651128, JString,
                                      required = false, default = nil)
  if valid_553651128 != nil:
    section.add "Accept", valid_553651128
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651129: Call_PutUserFollowingUsername_553651124;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Follow a user.
  ## Following a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  let valid = call_553651129.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651129.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651129.makeUrl(scheme.get, call_553651129.host, call_553651129.base,
                                   call_553651129.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651129, uri, valid, content)

proc call*(call_553651130: Call_PutUserFollowingUsername_553651124;
           username: string; Accept: string = ""): Recallable =
  ## putUserFollowingUsername
  ## Follow a user.
  ## Following a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_553651131 = newJObject()
  var header_553651132 = newJObject()
  add(path_553651131, "username", newJString(username))
  add(header_553651132, "Accept", newJString(Accept))
  result = call_553651130.call(path_553651131, nil, header_553651132, nil, nil)

var putUserFollowingUsername* = Call_PutUserFollowingUsername_553651124(
    name: "putUserFollowingUsername", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/user/following/{username}",
    validator: validate_PutUserFollowingUsername_553651125, base: "/",
    makeUrl: url_PutUserFollowingUsername_553651126, schemes: {Scheme.Https})
type
  Call_GetUserFollowingUsername_553651115 = ref object of OpenApiRestCall_553648476
proc url_GetUserFollowingUsername_553651117(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/following/"),
                 (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserFollowingUsername_553651116(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Check if you are following a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `username` field"
  var valid_553651118 = path.getOrDefault("username")
  valid_553651118 = validateParameter(valid_553651118, JString, required = true,
                                      default = nil)
  if valid_553651118 != nil:
    section.add "username", valid_553651118
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651119 = header.getOrDefault("Accept")
  valid_553651119 = validateParameter(valid_553651119, JString,
                                      required = false, default = nil)
  if valid_553651119 != nil:
    section.add "Accept", valid_553651119
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651120: Call_GetUserFollowingUsername_553651115;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Check if you are following a user.
  ## 
  let valid = call_553651120.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651120.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651120.makeUrl(scheme.get, call_553651120.host, call_553651120.base,
                                   call_553651120.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651120, uri, valid, content)

proc call*(call_553651121: Call_GetUserFollowingUsername_553651115;
           username: string; Accept: string = ""): Recallable =
  ## getUserFollowingUsername
  ## Check if you are following a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_553651122 = newJObject()
  var header_553651123 = newJObject()
  add(path_553651122, "username", newJString(username))
  add(header_553651123, "Accept", newJString(Accept))
  result = call_553651121.call(path_553651122, nil, header_553651123, nil, nil)

var getUserFollowingUsername* = Call_GetUserFollowingUsername_553651115(
    name: "getUserFollowingUsername", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/user/following/{username}",
    validator: validate_GetUserFollowingUsername_553651116, base: "/",
    makeUrl: url_GetUserFollowingUsername_553651117, schemes: {Scheme.Https})
type
  Call_DeleteUserFollowingUsername_553651133 = ref object of OpenApiRestCall_553648476
proc url_DeleteUserFollowingUsername_553651135(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/following/"),
                 (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserFollowingUsername_553651134(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Unfollow a user.
  ## Unfollowing a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `username` field"
  var valid_553651136 = path.getOrDefault("username")
  valid_553651136 = validateParameter(valid_553651136, JString, required = true,
                                      default = nil)
  if valid_553651136 != nil:
    section.add "username", valid_553651136
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651137 = header.getOrDefault("Accept")
  valid_553651137 = validateParameter(valid_553651137, JString,
                                      required = false, default = nil)
  if valid_553651137 != nil:
    section.add "Accept", valid_553651137
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651138: Call_DeleteUserFollowingUsername_553651133;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Unfollow a user.
  ## Unfollowing a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ## 
  let valid = call_553651138.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651138.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651138.makeUrl(scheme.get, call_553651138.host, call_553651138.base,
                                   call_553651138.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651138, uri, valid, content)

proc call*(call_553651139: Call_DeleteUserFollowingUsername_553651133;
           username: string; Accept: string = ""): Recallable =
  ## deleteUserFollowingUsername
  ## Unfollow a user.
  ## Unfollowing a user requires the user to be logged in and authenticated with
  ## basic auth or OAuth with the user:follow scope.
  ## 
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_553651140 = newJObject()
  var header_553651141 = newJObject()
  add(path_553651140, "username", newJString(username))
  add(header_553651141, "Accept", newJString(Accept))
  result = call_553651139.call(path_553651140, nil, header_553651141, nil, nil)

var deleteUserFollowingUsername* = Call_DeleteUserFollowingUsername_553651133(
    name: "deleteUserFollowingUsername", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/following/{username}",
    validator: validate_DeleteUserFollowingUsername_553651134, base: "/",
    makeUrl: url_DeleteUserFollowingUsername_553651135, schemes: {Scheme.Https})
type
  Call_GetUserIssues_553651142 = ref object of OpenApiRestCall_553648476
proc url_GetUserIssues_553651144(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserIssues_553651143(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List issues.
  ## List all issues across owned and member repositories for the authenticated
  ## user.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   state: JString (required)
  ##   labels: JString (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: JString (required)
  ##   direction: JString (required)
  ##   filter: JString (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: JString
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  section = newJObject()
  var valid_553651145 = query.getOrDefault("state")
  valid_553651145 = validateParameter(valid_553651145, JString, required = true,
                                      default = newJString("open"))
  if valid_553651145 != nil:
    section.add "state", valid_553651145
  var valid_553651146 = query.getOrDefault("labels")
  valid_553651146 = validateParameter(valid_553651146, JString, required = true,
                                      default = nil)
  if valid_553651146 != nil:
    section.add "labels", valid_553651146
  var valid_553651147 = query.getOrDefault("sort")
  valid_553651147 = validateParameter(valid_553651147, JString, required = true,
                                      default = newJString("created"))
  if valid_553651147 != nil:
    section.add "sort", valid_553651147
  var valid_553651148 = query.getOrDefault("direction")
  valid_553651148 = validateParameter(valid_553651148, JString, required = true,
                                      default = newJString("desc"))
  if valid_553651148 != nil:
    section.add "direction", valid_553651148
  var valid_553651149 = query.getOrDefault("filter")
  valid_553651149 = validateParameter(valid_553651149, JString, required = true,
                                      default = newJString("all"))
  if valid_553651149 != nil:
    section.add "filter", valid_553651149
  var valid_553651150 = query.getOrDefault("since")
  valid_553651150 = validateParameter(valid_553651150, JString,
                                      required = false, default = nil)
  if valid_553651150 != nil:
    section.add "since", valid_553651150
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651151 = header.getOrDefault("Accept")
  valid_553651151 = validateParameter(valid_553651151, JString,
                                      required = false, default = nil)
  if valid_553651151 != nil:
    section.add "Accept", valid_553651151
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651152: Call_GetUserIssues_553651142; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List issues.
  ## List all issues across owned and member repositories for the authenticated
  ## user.
  ## 
  ## 
  let valid = call_553651152.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651152.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651152.makeUrl(scheme.get, call_553651152.host, call_553651152.base,
                                   call_553651152.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651152, uri, valid, content)

proc call*(call_553651153: Call_GetUserIssues_553651142; labels: string;
           state: string = "open"; Accept: string = "";
           sort: string = "created"; direction: string = "desc";
           filter: string = "all"; since: string = ""): Recallable =
  ## getUserIssues
  ## List issues.
  ## List all issues across owned and member repositories for the authenticated
  ## user.
  ## 
  ##   state: string (required)
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   labels: string (required)
  ##         : String list of comma separated Label names. Example - bug,ui,@high.
  ##   sort: string (required)
  ##   direction: string (required)
  ##   filter: string (required)
  ##         : Issues assigned to you / created by you / mentioning you / you're
  ## subscribed to updates for / All issues the authenticated user can see
  ## 
  ##   since: string
  ##        : Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Only issues updated at or after this time are returned.
  ## 
  var query_553651154 = newJObject()
  var header_553651155 = newJObject()
  add(query_553651154, "state", newJString(state))
  add(header_553651155, "Accept", newJString(Accept))
  add(query_553651154, "labels", newJString(labels))
  add(query_553651154, "sort", newJString(sort))
  add(query_553651154, "direction", newJString(direction))
  add(query_553651154, "filter", newJString(filter))
  add(query_553651154, "since", newJString(since))
  result = call_553651153.call(nil, query_553651154, header_553651155, nil, nil)

var getUserIssues* = Call_GetUserIssues_553651142(name: "getUserIssues",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/issues",
    validator: validate_GetUserIssues_553651143, base: "/",
    makeUrl: url_GetUserIssues_553651144, schemes: {Scheme.Https})
type
  Call_PostUserKeys_553651163 = ref object of OpenApiRestCall_553648476
proc url_PostUserKeys_553651165(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostUserKeys_553651164(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Create a public key.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651166 = header.getOrDefault("Accept")
  valid_553651166 = validateParameter(valid_553651166, JString,
                                      required = false, default = nil)
  if valid_553651166 != nil:
    section.add "Accept", valid_553651166
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553651168: Call_PostUserKeys_553651163; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Create a public key.
  ## 
  let valid = call_553651168.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651168.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651168.makeUrl(scheme.get, call_553651168.host, call_553651168.base,
                                   call_553651168.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651168, uri, valid, content)

proc call*(call_553651169: Call_PostUserKeys_553651163; body: JsonNode;
           Accept: string = ""): Recallable =
  ## postUserKeys
  ## Create a public key.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_553651170 = newJObject()
  var body_553651171 = newJObject()
  add(header_553651170, "Accept", newJString(Accept))
  if body != nil:
    body_553651171 = body
  result = call_553651169.call(nil, nil, header_553651170, nil, body_553651171)

var postUserKeys* = Call_PostUserKeys_553651163(name: "postUserKeys",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/user/keys",
    validator: validate_PostUserKeys_553651164, base: "/",
    makeUrl: url_PostUserKeys_553651165, schemes: {Scheme.Https})
type
  Call_GetUserKeys_553651156 = ref object of OpenApiRestCall_553648476
proc url_GetUserKeys_553651158(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserKeys_553651157(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List your public keys.
  ## Lists the current user's keys. Management of public keys via the API requires
  ## that you are authenticated through basic auth, or OAuth with the 'user', 'write:public_key' scopes.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651159 = header.getOrDefault("Accept")
  valid_553651159 = validateParameter(valid_553651159, JString,
                                      required = false, default = nil)
  if valid_553651159 != nil:
    section.add "Accept", valid_553651159
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651160: Call_GetUserKeys_553651156; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List your public keys.
  ## Lists the current user's keys. Management of public keys via the API requires
  ## that you are authenticated through basic auth, or OAuth with the 'user', 'write:public_key' scopes.
  ## 
  ## 
  let valid = call_553651160.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651160.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651160.makeUrl(scheme.get, call_553651160.host, call_553651160.base,
                                   call_553651160.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651160, uri, valid, content)

proc call*(call_553651161: Call_GetUserKeys_553651156; Accept: string = ""): Recallable =
  ## getUserKeys
  ## List your public keys.
  ## Lists the current user's keys. Management of public keys via the API requires
  ## that you are authenticated through basic auth, or OAuth with the 'user', 'write:public_key' scopes.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_553651162 = newJObject()
  add(header_553651162, "Accept", newJString(Accept))
  result = call_553651161.call(nil, nil, header_553651162, nil, nil)

var getUserKeys* = Call_GetUserKeys_553651156(name: "getUserKeys",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/keys",
    validator: validate_GetUserKeys_553651157, base: "/",
    makeUrl: url_GetUserKeys_553651158, schemes: {Scheme.Https})
type
  Call_GetUserKeysKeyId_553651172 = ref object of OpenApiRestCall_553648476
proc url_GetUserKeysKeyId_553651174(protocol: Scheme; host: string;
                                    base: string; route: string; path: JsonNode;
                                    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/keys/"),
                 (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserKeysKeyId_553651173(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Get a single public key.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyId: JInt (required)
  ##        : ID of key.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyId` field"
  var valid_553651175 = path.getOrDefault("keyId")
  valid_553651175 = validateParameter(valid_553651175, JInt, required = true,
                                      default = nil)
  if valid_553651175 != nil:
    section.add "keyId", valid_553651175
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651176 = header.getOrDefault("Accept")
  valid_553651176 = validateParameter(valid_553651176, JString,
                                      required = false, default = nil)
  if valid_553651176 != nil:
    section.add "Accept", valid_553651176
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651177: Call_GetUserKeysKeyId_553651172;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get a single public key.
  ## 
  let valid = call_553651177.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651177.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651177.makeUrl(scheme.get, call_553651177.host, call_553651177.base,
                                   call_553651177.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651177, uri, valid, content)

proc call*(call_553651178: Call_GetUserKeysKeyId_553651172; keyId: int;
           Accept: string = ""): Recallable =
  ## getUserKeysKeyId
  ## Get a single public key.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   keyId: int (required)
  ##        : ID of key.
  var path_553651179 = newJObject()
  var header_553651180 = newJObject()
  add(header_553651180, "Accept", newJString(Accept))
  add(path_553651179, "keyId", newJInt(keyId))
  result = call_553651178.call(path_553651179, nil, header_553651180, nil, nil)

var getUserKeysKeyId* = Call_GetUserKeysKeyId_553651172(
    name: "getUserKeysKeyId", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/user/keys/{keyId}", validator: validate_GetUserKeysKeyId_553651173,
    base: "/", makeUrl: url_GetUserKeysKeyId_553651174, schemes: {Scheme.Https})
type
  Call_DeleteUserKeysKeyId_553651181 = ref object of OpenApiRestCall_553648476
proc url_DeleteUserKeysKeyId_553651183(protocol: Scheme; host: string;
                                       base: string; route: string;
                                       path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "keyId" in path, "`keyId` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/keys/"),
                 (kind: VariableSegment, value: "keyId")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserKeysKeyId_553651182(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Delete a public key. Removes a public key. Requires that you are authenticated via Basic Auth or via OAuth with at least admin:public_key scope.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   keyId: JInt (required)
  ##        : ID of key.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `keyId` field"
  var valid_553651184 = path.getOrDefault("keyId")
  valid_553651184 = validateParameter(valid_553651184, JInt, required = true,
                                      default = nil)
  if valid_553651184 != nil:
    section.add "keyId", valid_553651184
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651185 = header.getOrDefault("Accept")
  valid_553651185 = validateParameter(valid_553651185, JString,
                                      required = false, default = nil)
  if valid_553651185 != nil:
    section.add "Accept", valid_553651185
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651186: Call_DeleteUserKeysKeyId_553651181;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Delete a public key. Removes a public key. Requires that you are authenticated via Basic Auth or via OAuth with at least admin:public_key scope.
  ## 
  let valid = call_553651186.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651186.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651186.makeUrl(scheme.get, call_553651186.host, call_553651186.base,
                                   call_553651186.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651186, uri, valid, content)

proc call*(call_553651187: Call_DeleteUserKeysKeyId_553651181; keyId: int;
           Accept: string = ""): Recallable =
  ## deleteUserKeysKeyId
  ## Delete a public key. Removes a public key. Requires that you are authenticated via Basic Auth or via OAuth with at least admin:public_key scope.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   keyId: int (required)
  ##        : ID of key.
  var path_553651188 = newJObject()
  var header_553651189 = newJObject()
  add(header_553651189, "Accept", newJString(Accept))
  add(path_553651188, "keyId", newJInt(keyId))
  result = call_553651187.call(path_553651188, nil, header_553651189, nil, nil)

var deleteUserKeysKeyId* = Call_DeleteUserKeysKeyId_553651181(
    name: "deleteUserKeysKeyId", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/keys/{keyId}",
    validator: validate_DeleteUserKeysKeyId_553651182, base: "/",
    makeUrl: url_DeleteUserKeysKeyId_553651183, schemes: {Scheme.Https})
type
  Call_GetUserOrgs_553651190 = ref object of OpenApiRestCall_553648476
proc url_GetUserOrgs_553651192(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserOrgs_553651191(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List public and private organizations for the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651193 = header.getOrDefault("Accept")
  valid_553651193 = validateParameter(valid_553651193, JString,
                                      required = false, default = nil)
  if valid_553651193 != nil:
    section.add "Accept", valid_553651193
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651194: Call_GetUserOrgs_553651190; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List public and private organizations for the authenticated user.
  ## 
  let valid = call_553651194.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651194.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651194.makeUrl(scheme.get, call_553651194.host, call_553651194.base,
                                   call_553651194.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651194, uri, valid, content)

proc call*(call_553651195: Call_GetUserOrgs_553651190; Accept: string = ""): Recallable =
  ## getUserOrgs
  ## List public and private organizations for the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_553651196 = newJObject()
  add(header_553651196, "Accept", newJString(Accept))
  result = call_553651195.call(nil, nil, header_553651196, nil, nil)

var getUserOrgs* = Call_GetUserOrgs_553651190(name: "getUserOrgs",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/orgs",
    validator: validate_GetUserOrgs_553651191, base: "/",
    makeUrl: url_GetUserOrgs_553651192, schemes: {Scheme.Https})
type
  Call_PostUserRepos_553651206 = ref object of OpenApiRestCall_553648476
proc url_PostUserRepos_553651208(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostUserRepos_553651207(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651209 = header.getOrDefault("Accept")
  valid_553651209 = validateParameter(valid_553651209, JString,
                                      required = false, default = nil)
  if valid_553651209 != nil:
    section.add "Accept", valid_553651209
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  ## parameters in `body` object:
  ##   body: JObject (required)
  if `==`(content, ""): assert body != nil, "body argument is necessary"
  if `==`(content, ""):
    section = validateParameter(body, JObject, required = true, default = nil)
  if body != nil:
    result.add "body", body

proc call*(call_553651211: Call_PostUserRepos_553651206; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ## 
  let valid = call_553651211.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651211.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651211.makeUrl(scheme.get, call_553651211.host, call_553651211.base,
                                   call_553651211.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651211, uri, valid, content)

proc call*(call_553651212: Call_PostUserRepos_553651206; body: JsonNode;
           Accept: string = ""): Recallable =
  ## postUserRepos
  ## Create a new repository for the authenticated user. OAuth users must supply
  ## repo scope.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   body: JObject (required)
  var header_553651213 = newJObject()
  var body_553651214 = newJObject()
  add(header_553651213, "Accept", newJString(Accept))
  if body != nil:
    body_553651214 = body
  result = call_553651212.call(nil, nil, header_553651213, nil, body_553651214)

var postUserRepos* = Call_PostUserRepos_553651206(name: "postUserRepos",
    meth: HttpMethod.HttpPost, host: "api.github.com", route: "/user/repos",
    validator: validate_PostUserRepos_553651207, base: "/",
    makeUrl: url_PostUserRepos_553651208, schemes: {Scheme.Https})
type
  Call_GetUserRepos_553651197 = ref object of OpenApiRestCall_553648476
proc url_GetUserRepos_553651199(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserRepos_553651198(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List repositories for the authenticated user. Note that this does not include
  ## repositories owned by organizations which the user can access. You can lis
  ## user organizations and list organization repositories separately.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   type: JString
  section = newJObject()
  var valid_553651200 = query.getOrDefault("type")
  valid_553651200 = validateParameter(valid_553651200, JString,
                                      required = false,
                                      default = newJString("all"))
  if valid_553651200 != nil:
    section.add "type", valid_553651200
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651201 = header.getOrDefault("Accept")
  valid_553651201 = validateParameter(valid_553651201, JString,
                                      required = false, default = nil)
  if valid_553651201 != nil:
    section.add "Accept", valid_553651201
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651202: Call_GetUserRepos_553651197; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List repositories for the authenticated user. Note that this does not include
  ## repositories owned by organizations which the user can access. You can lis
  ## user organizations and list organization repositories separately.
  ## 
  ## 
  let valid = call_553651202.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651202.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651202.makeUrl(scheme.get, call_553651202.host, call_553651202.base,
                                   call_553651202.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651202, uri, valid, content)

proc call*(call_553651203: Call_GetUserRepos_553651197; Accept: string = "";
           `type`: string = "all"): Recallable =
  ## getUserRepos
  ## List repositories for the authenticated user. Note that this does not include
  ## repositories owned by organizations which the user can access. You can lis
  ## user organizations and list organization repositories separately.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   type: string
  var query_553651204 = newJObject()
  var header_553651205 = newJObject()
  add(header_553651205, "Accept", newJString(Accept))
  add(query_553651204, "type", newJString(`type`))
  result = call_553651203.call(nil, query_553651204, header_553651205, nil, nil)

var getUserRepos* = Call_GetUserRepos_553651197(name: "getUserRepos",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/repos",
    validator: validate_GetUserRepos_553651198, base: "/",
    makeUrl: url_GetUserRepos_553651199, schemes: {Scheme.Https})
type
  Call_GetUserStarred_553651215 = ref object of OpenApiRestCall_553648476
proc url_GetUserStarred_553651217(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserStarred_553651216(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List repositories being starred by the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   sort: JString
  ##   direction: JString
  ##            : Ignored without 'sort' parameter.
  section = newJObject()
  var valid_553651218 = query.getOrDefault("sort")
  valid_553651218 = validateParameter(valid_553651218, JString,
                                      required = false,
                                      default = newJString("created"))
  if valid_553651218 != nil:
    section.add "sort", valid_553651218
  var valid_553651219 = query.getOrDefault("direction")
  valid_553651219 = validateParameter(valid_553651219, JString,
                                      required = false, default = nil)
  if valid_553651219 != nil:
    section.add "direction", valid_553651219
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651220 = header.getOrDefault("Accept")
  valid_553651220 = validateParameter(valid_553651220, JString,
                                      required = false, default = nil)
  if valid_553651220 != nil:
    section.add "Accept", valid_553651220
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651221: Call_GetUserStarred_553651215; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List repositories being starred by the authenticated user.
  ## 
  let valid = call_553651221.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651221.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651221.makeUrl(scheme.get, call_553651221.host, call_553651221.base,
                                   call_553651221.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651221, uri, valid, content)

proc call*(call_553651222: Call_GetUserStarred_553651215; Accept: string = "";
           sort: string = "created"; direction: string = ""): Recallable =
  ## getUserStarred
  ## List repositories being starred by the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   sort: string
  ##   direction: string
  ##            : Ignored without 'sort' parameter.
  var query_553651223 = newJObject()
  var header_553651224 = newJObject()
  add(header_553651224, "Accept", newJString(Accept))
  add(query_553651223, "sort", newJString(sort))
  add(query_553651223, "direction", newJString(direction))
  result = call_553651222.call(nil, query_553651223, header_553651224, nil, nil)

var getUserStarred* = Call_GetUserStarred_553651215(name: "getUserStarred",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/starred",
    validator: validate_GetUserStarred_553651216, base: "/",
    makeUrl: url_GetUserStarred_553651217, schemes: {Scheme.Https})
type
  Call_PutUserStarredOwnerRepo_553651235 = ref object of OpenApiRestCall_553648476
proc url_PutUserStarredOwnerRepo_553651237(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/starred/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutUserStarredOwnerRepo_553651236(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Star a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  ##   repo: JString (required)
  ##       : Name of a repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553651238 = path.getOrDefault("owner")
  valid_553651238 = validateParameter(valid_553651238, JString, required = true,
                                      default = nil)
  if valid_553651238 != nil:
    section.add "owner", valid_553651238
  var valid_553651239 = path.getOrDefault("repo")
  valid_553651239 = validateParameter(valid_553651239, JString, required = true,
                                      default = nil)
  if valid_553651239 != nil:
    section.add "repo", valid_553651239
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651240 = header.getOrDefault("Accept")
  valid_553651240 = validateParameter(valid_553651240, JString,
                                      required = false, default = nil)
  if valid_553651240 != nil:
    section.add "Accept", valid_553651240
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651241: Call_PutUserStarredOwnerRepo_553651235;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Star a repository.
  ## 
  let valid = call_553651241.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651241.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651241.makeUrl(scheme.get, call_553651241.host, call_553651241.base,
                                   call_553651241.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651241, uri, valid, content)

proc call*(call_553651242: Call_PutUserStarredOwnerRepo_553651235;
           owner: string; repo: string; Accept: string = ""): Recallable =
  ## putUserStarredOwnerRepo
  ## Star a repository.
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  var path_553651243 = newJObject()
  var header_553651244 = newJObject()
  add(path_553651243, "owner", newJString(owner))
  add(header_553651244, "Accept", newJString(Accept))
  add(path_553651243, "repo", newJString(repo))
  result = call_553651242.call(path_553651243, nil, header_553651244, nil, nil)

var putUserStarredOwnerRepo* = Call_PutUserStarredOwnerRepo_553651235(
    name: "putUserStarredOwnerRepo", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/user/starred/{owner}/{repo}",
    validator: validate_PutUserStarredOwnerRepo_553651236, base: "/",
    makeUrl: url_PutUserStarredOwnerRepo_553651237, schemes: {Scheme.Https})
type
  Call_GetUserStarredOwnerRepo_553651225 = ref object of OpenApiRestCall_553648476
proc url_GetUserStarredOwnerRepo_553651227(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/starred/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserStarredOwnerRepo_553651226(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Check if you are starring a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  ##   repo: JString (required)
  ##       : Name of a repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553651228 = path.getOrDefault("owner")
  valid_553651228 = validateParameter(valid_553651228, JString, required = true,
                                      default = nil)
  if valid_553651228 != nil:
    section.add "owner", valid_553651228
  var valid_553651229 = path.getOrDefault("repo")
  valid_553651229 = validateParameter(valid_553651229, JString, required = true,
                                      default = nil)
  if valid_553651229 != nil:
    section.add "repo", valid_553651229
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651230 = header.getOrDefault("Accept")
  valid_553651230 = validateParameter(valid_553651230, JString,
                                      required = false, default = nil)
  if valid_553651230 != nil:
    section.add "Accept", valid_553651230
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651231: Call_GetUserStarredOwnerRepo_553651225;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Check if you are starring a repository.
  ## 
  let valid = call_553651231.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651231.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651231.makeUrl(scheme.get, call_553651231.host, call_553651231.base,
                                   call_553651231.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651231, uri, valid, content)

proc call*(call_553651232: Call_GetUserStarredOwnerRepo_553651225;
           owner: string; repo: string; Accept: string = ""): Recallable =
  ## getUserStarredOwnerRepo
  ## Check if you are starring a repository.
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  var path_553651233 = newJObject()
  var header_553651234 = newJObject()
  add(path_553651233, "owner", newJString(owner))
  add(header_553651234, "Accept", newJString(Accept))
  add(path_553651233, "repo", newJString(repo))
  result = call_553651232.call(path_553651233, nil, header_553651234, nil, nil)

var getUserStarredOwnerRepo* = Call_GetUserStarredOwnerRepo_553651225(
    name: "getUserStarredOwnerRepo", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/user/starred/{owner}/{repo}",
    validator: validate_GetUserStarredOwnerRepo_553651226, base: "/",
    makeUrl: url_GetUserStarredOwnerRepo_553651227, schemes: {Scheme.Https})
type
  Call_DeleteUserStarredOwnerRepo_553651245 = ref object of OpenApiRestCall_553648476
proc url_DeleteUserStarredOwnerRepo_553651247(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/starred/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserStarredOwnerRepo_553651246(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Unstar a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of a repository owner.
  ##   repo: JString (required)
  ##       : Name of a repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553651248 = path.getOrDefault("owner")
  valid_553651248 = validateParameter(valid_553651248, JString, required = true,
                                      default = nil)
  if valid_553651248 != nil:
    section.add "owner", valid_553651248
  var valid_553651249 = path.getOrDefault("repo")
  valid_553651249 = validateParameter(valid_553651249, JString, required = true,
                                      default = nil)
  if valid_553651249 != nil:
    section.add "repo", valid_553651249
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651250 = header.getOrDefault("Accept")
  valid_553651250 = validateParameter(valid_553651250, JString,
                                      required = false, default = nil)
  if valid_553651250 != nil:
    section.add "Accept", valid_553651250
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651251: Call_DeleteUserStarredOwnerRepo_553651245;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Unstar a repository
  ## 
  let valid = call_553651251.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651251.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651251.makeUrl(scheme.get, call_553651251.host, call_553651251.base,
                                   call_553651251.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651251, uri, valid, content)

proc call*(call_553651252: Call_DeleteUserStarredOwnerRepo_553651245;
           owner: string; repo: string; Accept: string = ""): Recallable =
  ## deleteUserStarredOwnerRepo
  ## Unstar a repository
  ##   owner: string (required)
  ##        : Name of a repository owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of a repository.
  var path_553651253 = newJObject()
  var header_553651254 = newJObject()
  add(path_553651253, "owner", newJString(owner))
  add(header_553651254, "Accept", newJString(Accept))
  add(path_553651253, "repo", newJString(repo))
  result = call_553651252.call(path_553651253, nil, header_553651254, nil, nil)

var deleteUserStarredOwnerRepo* = Call_DeleteUserStarredOwnerRepo_553651245(
    name: "deleteUserStarredOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/starred/{owner}/{repo}",
    validator: validate_DeleteUserStarredOwnerRepo_553651246, base: "/",
    makeUrl: url_DeleteUserStarredOwnerRepo_553651247, schemes: {Scheme.Https})
type
  Call_GetUserSubscriptions_553651255 = ref object of OpenApiRestCall_553648476
proc url_GetUserSubscriptions_553651257(protocol: Scheme; host: string;
                                        base: string; route: string;
                                        path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserSubscriptions_553651256(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List repositories being watched by the authenticated user.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651258 = header.getOrDefault("Accept")
  valid_553651258 = validateParameter(valid_553651258, JString,
                                      required = false, default = nil)
  if valid_553651258 != nil:
    section.add "Accept", valid_553651258
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651259: Call_GetUserSubscriptions_553651255;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List repositories being watched by the authenticated user.
  ## 
  let valid = call_553651259.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651259.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651259.makeUrl(scheme.get, call_553651259.host, call_553651259.base,
                                   call_553651259.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651259, uri, valid, content)

proc call*(call_553651260: Call_GetUserSubscriptions_553651255;
           Accept: string = ""): Recallable =
  ## getUserSubscriptions
  ## List repositories being watched by the authenticated user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_553651261 = newJObject()
  add(header_553651261, "Accept", newJString(Accept))
  result = call_553651260.call(nil, nil, header_553651261, nil, nil)

var getUserSubscriptions* = Call_GetUserSubscriptions_553651255(
    name: "getUserSubscriptions", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/user/subscriptions",
    validator: validate_GetUserSubscriptions_553651256, base: "/",
    makeUrl: url_GetUserSubscriptions_553651257, schemes: {Scheme.Https})
type
  Call_PutUserSubscriptionsOwnerRepo_553651272 = ref object of OpenApiRestCall_553648476
proc url_PutUserSubscriptionsOwnerRepo_553651274(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/subscriptions/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_PutUserSubscriptionsOwnerRepo_553651273(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Watch a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of the owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553651275 = path.getOrDefault("owner")
  valid_553651275 = validateParameter(valid_553651275, JString, required = true,
                                      default = nil)
  if valid_553651275 != nil:
    section.add "owner", valid_553651275
  var valid_553651276 = path.getOrDefault("repo")
  valid_553651276 = validateParameter(valid_553651276, JString, required = true,
                                      default = nil)
  if valid_553651276 != nil:
    section.add "repo", valid_553651276
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651277 = header.getOrDefault("Accept")
  valid_553651277 = validateParameter(valid_553651277, JString,
                                      required = false, default = nil)
  if valid_553651277 != nil:
    section.add "Accept", valid_553651277
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651278: Call_PutUserSubscriptionsOwnerRepo_553651272;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Watch a repository.
  ## 
  let valid = call_553651278.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651278.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651278.makeUrl(scheme.get, call_553651278.host, call_553651278.base,
                                   call_553651278.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651278, uri, valid, content)

proc call*(call_553651279: Call_PutUserSubscriptionsOwnerRepo_553651272;
           owner: string; repo: string; Accept: string = ""): Recallable =
  ## putUserSubscriptionsOwnerRepo
  ## Watch a repository.
  ##   owner: string (required)
  ##        : Name of the owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553651280 = newJObject()
  var header_553651281 = newJObject()
  add(path_553651280, "owner", newJString(owner))
  add(header_553651281, "Accept", newJString(Accept))
  add(path_553651280, "repo", newJString(repo))
  result = call_553651279.call(path_553651280, nil, header_553651281, nil, nil)

var putUserSubscriptionsOwnerRepo* = Call_PutUserSubscriptionsOwnerRepo_553651272(
    name: "putUserSubscriptionsOwnerRepo", meth: HttpMethod.HttpPut,
    host: "api.github.com", route: "/user/subscriptions/{owner}/{repo}",
    validator: validate_PutUserSubscriptionsOwnerRepo_553651273, base: "/",
    makeUrl: url_PutUserSubscriptionsOwnerRepo_553651274,
    schemes: {Scheme.Https})
type
  Call_GetUserSubscriptionsOwnerRepo_553651262 = ref object of OpenApiRestCall_553648476
proc url_GetUserSubscriptionsOwnerRepo_553651264(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/subscriptions/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUserSubscriptionsOwnerRepo_553651263(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Check if you are watching a repository.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of the owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553651265 = path.getOrDefault("owner")
  valid_553651265 = validateParameter(valid_553651265, JString, required = true,
                                      default = nil)
  if valid_553651265 != nil:
    section.add "owner", valid_553651265
  var valid_553651266 = path.getOrDefault("repo")
  valid_553651266 = validateParameter(valid_553651266, JString, required = true,
                                      default = nil)
  if valid_553651266 != nil:
    section.add "repo", valid_553651266
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651267 = header.getOrDefault("Accept")
  valid_553651267 = validateParameter(valid_553651267, JString,
                                      required = false, default = nil)
  if valid_553651267 != nil:
    section.add "Accept", valid_553651267
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651268: Call_GetUserSubscriptionsOwnerRepo_553651262;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Check if you are watching a repository.
  ## 
  let valid = call_553651268.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651268.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651268.makeUrl(scheme.get, call_553651268.host, call_553651268.base,
                                   call_553651268.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651268, uri, valid, content)

proc call*(call_553651269: Call_GetUserSubscriptionsOwnerRepo_553651262;
           owner: string; repo: string; Accept: string = ""): Recallable =
  ## getUserSubscriptionsOwnerRepo
  ## Check if you are watching a repository.
  ##   owner: string (required)
  ##        : Name of the owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553651270 = newJObject()
  var header_553651271 = newJObject()
  add(path_553651270, "owner", newJString(owner))
  add(header_553651271, "Accept", newJString(Accept))
  add(path_553651270, "repo", newJString(repo))
  result = call_553651269.call(path_553651270, nil, header_553651271, nil, nil)

var getUserSubscriptionsOwnerRepo* = Call_GetUserSubscriptionsOwnerRepo_553651262(
    name: "getUserSubscriptionsOwnerRepo", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/user/subscriptions/{owner}/{repo}",
    validator: validate_GetUserSubscriptionsOwnerRepo_553651263, base: "/",
    makeUrl: url_GetUserSubscriptionsOwnerRepo_553651264,
    schemes: {Scheme.Https})
type
  Call_DeleteUserSubscriptionsOwnerRepo_553651282 = ref object of OpenApiRestCall_553648476
proc url_DeleteUserSubscriptionsOwnerRepo_553651284(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "owner" in path, "`owner` is a required path parameter"
  assert "repo" in path, "`repo` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/user/subscriptions/"),
                 (kind: VariableSegment, value: "owner"),
                 (kind: ConstantSegment, value: "/"),
                 (kind: VariableSegment, value: "repo")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_DeleteUserSubscriptionsOwnerRepo_553651283(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Stop watching a repository
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   owner: JString (required)
  ##        : Name of the owner.
  ##   repo: JString (required)
  ##       : Name of repository.
  section = newJObject()
  assert path != nil, "path argument is necessary due to required `owner` field"
  var valid_553651285 = path.getOrDefault("owner")
  valid_553651285 = validateParameter(valid_553651285, JString, required = true,
                                      default = nil)
  if valid_553651285 != nil:
    section.add "owner", valid_553651285
  var valid_553651286 = path.getOrDefault("repo")
  valid_553651286 = validateParameter(valid_553651286, JString, required = true,
                                      default = nil)
  if valid_553651286 != nil:
    section.add "repo", valid_553651286
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651287 = header.getOrDefault("Accept")
  valid_553651287 = validateParameter(valid_553651287, JString,
                                      required = false, default = nil)
  if valid_553651287 != nil:
    section.add "Accept", valid_553651287
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651288: Call_DeleteUserSubscriptionsOwnerRepo_553651282;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Stop watching a repository
  ## 
  let valid = call_553651288.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651288.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651288.makeUrl(scheme.get, call_553651288.host, call_553651288.base,
                                   call_553651288.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651288, uri, valid, content)

proc call*(call_553651289: Call_DeleteUserSubscriptionsOwnerRepo_553651282;
           owner: string; repo: string; Accept: string = ""): Recallable =
  ## deleteUserSubscriptionsOwnerRepo
  ## Stop watching a repository
  ##   owner: string (required)
  ##        : Name of the owner.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   repo: string (required)
  ##       : Name of repository.
  var path_553651290 = newJObject()
  var header_553651291 = newJObject()
  add(path_553651290, "owner", newJString(owner))
  add(header_553651291, "Accept", newJString(Accept))
  add(path_553651290, "repo", newJString(repo))
  result = call_553651289.call(path_553651290, nil, header_553651291, nil, nil)

var deleteUserSubscriptionsOwnerRepo* = Call_DeleteUserSubscriptionsOwnerRepo_553651282(
    name: "deleteUserSubscriptionsOwnerRepo", meth: HttpMethod.HttpDelete,
    host: "api.github.com", route: "/user/subscriptions/{owner}/{repo}",
    validator: validate_DeleteUserSubscriptionsOwnerRepo_553651283, base: "/",
    makeUrl: url_DeleteUserSubscriptionsOwnerRepo_553651284,
    schemes: {Scheme.Https})
type
  Call_GetUserTeams_553651292 = ref object of OpenApiRestCall_553648476
proc url_GetUserTeams_553651294(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUserTeams_553651293(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List all of the teams across all of the organizations to which the authenticated user belongs. This method requires user or repo scope when authenticating via OAuth.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651295 = header.getOrDefault("Accept")
  valid_553651295 = validateParameter(valid_553651295, JString,
                                      required = false, default = nil)
  if valid_553651295 != nil:
    section.add "Accept", valid_553651295
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651296: Call_GetUserTeams_553651292; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List all of the teams across all of the organizations to which the authenticated user belongs. This method requires user or repo scope when authenticating via OAuth.
  ## 
  let valid = call_553651296.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651296.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651296.makeUrl(scheme.get, call_553651296.host, call_553651296.base,
                                   call_553651296.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651296, uri, valid, content)

proc call*(call_553651297: Call_GetUserTeams_553651292; Accept: string = ""): Recallable =
  ## getUserTeams
  ## List all of the teams across all of the organizations to which the authenticated user belongs. This method requires user or repo scope when authenticating via OAuth.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var header_553651298 = newJObject()
  add(header_553651298, "Accept", newJString(Accept))
  result = call_553651297.call(nil, nil, header_553651298, nil, nil)

var getUserTeams* = Call_GetUserTeams_553651292(name: "getUserTeams",
    meth: HttpMethod.HttpGet, host: "api.github.com", route: "/user/teams",
    validator: validate_GetUserTeams_553651293, base: "/",
    makeUrl: url_GetUserTeams_553651294, schemes: {Scheme.Https})
type
  Call_GetUsers_553651299 = ref object of OpenApiRestCall_553648476
proc url_GetUsers_553651301(protocol: Scheme; host: string; base: string;
                            route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetUsers_553651300(path: JsonNode; query: JsonNode;
                                 header: JsonNode; formData: JsonNode;
                                 body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Get all users.
  ## This provides a dump of every user, in the order that they signed up for GitHub.
  ## Note: Pagination is powered exclusively by the since parameter. Use the Link
  ## header to get the URL for the next page of users.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JInt
  ##        : The integer ID of the last user that you've seen.
  section = newJObject()
  var valid_553651302 = query.getOrDefault("since")
  valid_553651302 = validateParameter(valid_553651302, JInt, required = false,
                                      default = nil)
  if valid_553651302 != nil:
    section.add "since", valid_553651302
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651303 = header.getOrDefault("Accept")
  valid_553651303 = validateParameter(valid_553651303, JString,
                                      required = false, default = nil)
  if valid_553651303 != nil:
    section.add "Accept", valid_553651303
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651304: Call_GetUsers_553651299; path: JsonNode = nil;
           query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get all users.
  ## This provides a dump of every user, in the order that they signed up for GitHub.
  ## Note: Pagination is powered exclusively by the since parameter. Use the Link
  ## header to get the URL for the next page of users.
  ## 
  ## 
  let valid = call_553651304.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651304.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651304.makeUrl(scheme.get, call_553651304.host, call_553651304.base,
                                   call_553651304.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651304, uri, valid, content)

proc call*(call_553651305: Call_GetUsers_553651299; Accept: string = "";
           since: int = 0): Recallable =
  ## getUsers
  ## Get all users.
  ## This provides a dump of every user, in the order that they signed up for GitHub.
  ## Note: Pagination is powered exclusively by the since parameter. Use the Link
  ## header to get the URL for the next page of users.
  ## 
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: int
  ##        : The integer ID of the last user that you've seen.
  var query_553651306 = newJObject()
  var header_553651307 = newJObject()
  add(header_553651307, "Accept", newJString(Accept))
  add(query_553651306, "since", newJInt(since))
  result = call_553651305.call(nil, query_553651306, header_553651307, nil, nil)

var getUsers* = Call_GetUsers_553651299(name: "getUsers",
                                        meth: HttpMethod.HttpGet,
                                        host: "api.github.com", route: "/users",
                                        validator: validate_GetUsers_553651300,
                                        base: "/", makeUrl: url_GetUsers_553651301,
                                        schemes: {Scheme.Https})
type
  Call_GetUsersUsername_553651308 = ref object of OpenApiRestCall_553648476
proc url_GetUsersUsername_553651310(protocol: Scheme; host: string;
                                    base: string; route: string; path: JsonNode;
                                    query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
                 (kind: VariableSegment, value: "username")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsername_553651309(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## Get a single user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `username` field"
  var valid_553651311 = path.getOrDefault("username")
  valid_553651311 = validateParameter(valid_553651311, JString, required = true,
                                      default = nil)
  if valid_553651311 != nil:
    section.add "username", valid_553651311
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651312 = header.getOrDefault("Accept")
  valid_553651312 = validateParameter(valid_553651312, JString,
                                      required = false, default = nil)
  if valid_553651312 != nil:
    section.add "Accept", valid_553651312
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651313: Call_GetUsersUsername_553651308;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Get a single user.
  ## 
  let valid = call_553651313.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651313.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651313.makeUrl(scheme.get, call_553651313.host, call_553651313.base,
                                   call_553651313.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651313, uri, valid, content)

proc call*(call_553651314: Call_GetUsersUsername_553651308; username: string;
           Accept: string = ""): Recallable =
  ## getUsersUsername
  ## Get a single user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_553651315 = newJObject()
  var header_553651316 = newJObject()
  add(path_553651315, "username", newJString(username))
  add(header_553651316, "Accept", newJString(Accept))
  result = call_553651314.call(path_553651315, nil, header_553651316, nil, nil)

var getUsersUsername* = Call_GetUsersUsername_553651308(
    name: "getUsersUsername", meth: HttpMethod.HttpGet, host: "api.github.com",
    route: "/users/{username}", validator: validate_GetUsersUsername_553651309,
    base: "/", makeUrl: url_GetUsersUsername_553651310, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameEvents_553651317 = ref object of OpenApiRestCall_553648476
proc url_GetUsersUsernameEvents_553651319(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
                 (kind: VariableSegment, value: "username"),
                 (kind: ConstantSegment, value: "/events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameEvents_553651318(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `username` field"
  var valid_553651320 = path.getOrDefault("username")
  valid_553651320 = validateParameter(valid_553651320, JString, required = true,
                                      default = nil)
  if valid_553651320 != nil:
    section.add "username", valid_553651320
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651321 = header.getOrDefault("Accept")
  valid_553651321 = validateParameter(valid_553651321, JString,
                                      required = false, default = nil)
  if valid_553651321 != nil:
    section.add "Accept", valid_553651321
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651322: Call_GetUsersUsernameEvents_553651317;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
  ## 
  let valid = call_553651322.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651322.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651322.makeUrl(scheme.get, call_553651322.host, call_553651322.base,
                                   call_553651322.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651322, uri, valid, content)

proc call*(call_553651323: Call_GetUsersUsernameEvents_553651317;
           username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameEvents
  ## If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_553651324 = newJObject()
  var header_553651325 = newJObject()
  add(path_553651324, "username", newJString(username))
  add(header_553651325, "Accept", newJString(Accept))
  result = call_553651323.call(path_553651324, nil, header_553651325, nil, nil)

var getUsersUsernameEvents* = Call_GetUsersUsernameEvents_553651317(
    name: "getUsersUsernameEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/events",
    validator: validate_GetUsersUsernameEvents_553651318, base: "/",
    makeUrl: url_GetUsersUsernameEvents_553651319, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameEventsOrgsOrg_553651326 = ref object of OpenApiRestCall_553648476
proc url_GetUsersUsernameEventsOrgsOrg_553651328(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  assert "org" in path, "`org` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
                 (kind: VariableSegment, value: "username"),
                 (kind: ConstantSegment, value: "/events/orgs/"),
                 (kind: VariableSegment, value: "org")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameEventsOrgsOrg_553651327(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## This is the user's organization dashboard. You must be authenticated as the user to view this.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  ##   org: JString (required)
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `username` field"
  var valid_553651329 = path.getOrDefault("username")
  valid_553651329 = validateParameter(valid_553651329, JString, required = true,
                                      default = nil)
  if valid_553651329 != nil:
    section.add "username", valid_553651329
  var valid_553651330 = path.getOrDefault("org")
  valid_553651330 = validateParameter(valid_553651330, JString, required = true,
                                      default = nil)
  if valid_553651330 != nil:
    section.add "org", valid_553651330
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651331 = header.getOrDefault("Accept")
  valid_553651331 = validateParameter(valid_553651331, JString,
                                      required = false, default = nil)
  if valid_553651331 != nil:
    section.add "Accept", valid_553651331
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651332: Call_GetUsersUsernameEventsOrgsOrg_553651326;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## This is the user's organization dashboard. You must be authenticated as the user to view this.
  ## 
  let valid = call_553651332.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651332.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651332.makeUrl(scheme.get, call_553651332.host, call_553651332.base,
                                   call_553651332.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651332, uri, valid, content)

proc call*(call_553651333: Call_GetUsersUsernameEventsOrgsOrg_553651326;
           username: string; org: string; Accept: string = ""): Recallable =
  ## getUsersUsernameEventsOrgsOrg
  ## This is the user's organization dashboard. You must be authenticated as the user to view this.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   org: string (required)
  var path_553651334 = newJObject()
  var header_553651335 = newJObject()
  add(path_553651334, "username", newJString(username))
  add(header_553651335, "Accept", newJString(Accept))
  add(path_553651334, "org", newJString(org))
  result = call_553651333.call(path_553651334, nil, header_553651335, nil, nil)

var getUsersUsernameEventsOrgsOrg* = Call_GetUsersUsernameEventsOrgsOrg_553651326(
    name: "getUsersUsernameEventsOrgsOrg", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/events/orgs/{org}",
    validator: validate_GetUsersUsernameEventsOrgsOrg_553651327, base: "/",
    makeUrl: url_GetUsersUsernameEventsOrgsOrg_553651328,
    schemes: {Scheme.Https})
type
  Call_GetUsersUsernameFollowers_553651336 = ref object of OpenApiRestCall_553648476
proc url_GetUsersUsernameFollowers_553651338(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
                 (kind: VariableSegment, value: "username"),
                 (kind: ConstantSegment, value: "/followers")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameFollowers_553651337(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## List a user's followers
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `username` field"
  var valid_553651339 = path.getOrDefault("username")
  valid_553651339 = validateParameter(valid_553651339, JString, required = true,
                                      default = nil)
  if valid_553651339 != nil:
    section.add "username", valid_553651339
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651340 = header.getOrDefault("Accept")
  valid_553651340 = validateParameter(valid_553651340, JString,
                                      required = false, default = nil)
  if valid_553651340 != nil:
    section.add "Accept", valid_553651340
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651341: Call_GetUsersUsernameFollowers_553651336;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List a user's followers
  ## 
  let valid = call_553651341.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651341.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651341.makeUrl(scheme.get, call_553651341.host, call_553651341.base,
                                   call_553651341.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651341, uri, valid, content)

proc call*(call_553651342: Call_GetUsersUsernameFollowers_553651336;
           username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameFollowers
  ## List a user's followers
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_553651343 = newJObject()
  var header_553651344 = newJObject()
  add(path_553651343, "username", newJString(username))
  add(header_553651344, "Accept", newJString(Accept))
  result = call_553651342.call(path_553651343, nil, header_553651344, nil, nil)

var getUsersUsernameFollowers* = Call_GetUsersUsernameFollowers_553651336(
    name: "getUsersUsernameFollowers", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/followers",
    validator: validate_GetUsersUsernameFollowers_553651337, base: "/",
    makeUrl: url_GetUsersUsernameFollowers_553651338, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameFollowingTargetUser_553651345 = ref object of OpenApiRestCall_553648476
proc url_GetUsersUsernameFollowingTargetUser_553651347(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  assert "targetUser" in path, "`targetUser` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
                 (kind: VariableSegment, value: "username"),
                 (kind: ConstantSegment, value: "/following/"),
                 (kind: VariableSegment, value: "targetUser")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameFollowingTargetUser_553651346(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## Check if one user follows another.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  ##   targetUser: JString (required)
  ##             : Name of user.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `username` field"
  var valid_553651348 = path.getOrDefault("username")
  valid_553651348 = validateParameter(valid_553651348, JString, required = true,
                                      default = nil)
  if valid_553651348 != nil:
    section.add "username", valid_553651348
  var valid_553651349 = path.getOrDefault("targetUser")
  valid_553651349 = validateParameter(valid_553651349, JString, required = true,
                                      default = nil)
  if valid_553651349 != nil:
    section.add "targetUser", valid_553651349
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651350 = header.getOrDefault("Accept")
  valid_553651350 = validateParameter(valid_553651350, JString,
                                      required = false, default = nil)
  if valid_553651350 != nil:
    section.add "Accept", valid_553651350
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651351: Call_GetUsersUsernameFollowingTargetUser_553651345;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## Check if one user follows another.
  ## 
  let valid = call_553651351.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651351.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651351.makeUrl(scheme.get, call_553651351.host, call_553651351.base,
                                   call_553651351.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651351, uri, valid, content)

proc call*(call_553651352: Call_GetUsersUsernameFollowingTargetUser_553651345;
           username: string; targetUser: string; Accept: string = ""): Recallable =
  ## getUsersUsernameFollowingTargetUser
  ## Check if one user follows another.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   targetUser: string (required)
  ##             : Name of user.
  var path_553651353 = newJObject()
  var header_553651354 = newJObject()
  add(path_553651353, "username", newJString(username))
  add(header_553651354, "Accept", newJString(Accept))
  add(path_553651353, "targetUser", newJString(targetUser))
  result = call_553651352.call(path_553651353, nil, header_553651354, nil, nil)

var getUsersUsernameFollowingTargetUser* = Call_GetUsersUsernameFollowingTargetUser_553651345(
    name: "getUsersUsernameFollowingTargetUser", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/following/{targetUser}",
    validator: validate_GetUsersUsernameFollowingTargetUser_553651346,
    base: "/", makeUrl: url_GetUsersUsernameFollowingTargetUser_553651347,
    schemes: {Scheme.Https})
type
  Call_GetUsersUsernameGists_553651355 = ref object of OpenApiRestCall_553648476
proc url_GetUsersUsernameGists_553651357(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
                 (kind: VariableSegment, value: "username"),
                 (kind: ConstantSegment, value: "/gists")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameGists_553651356(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List a users gists.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `username` field"
  var valid_553651358 = path.getOrDefault("username")
  valid_553651358 = validateParameter(valid_553651358, JString, required = true,
                                      default = nil)
  if valid_553651358 != nil:
    section.add "username", valid_553651358
  result.add "path", section
  ## parameters in `query` object:
  ##   since: JString
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  section = newJObject()
  var valid_553651359 = query.getOrDefault("since")
  valid_553651359 = validateParameter(valid_553651359, JString,
                                      required = false, default = nil)
  if valid_553651359 != nil:
    section.add "since", valid_553651359
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651360 = header.getOrDefault("Accept")
  valid_553651360 = validateParameter(valid_553651360, JString,
                                      required = false, default = nil)
  if valid_553651360 != nil:
    section.add "Accept", valid_553651360
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651361: Call_GetUsersUsernameGists_553651355;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List a users gists.
  ## 
  let valid = call_553651361.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651361.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651361.makeUrl(scheme.get, call_553651361.host, call_553651361.base,
                                   call_553651361.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651361, uri, valid, content)

proc call*(call_553651362: Call_GetUsersUsernameGists_553651355;
           username: string; Accept: string = ""; since: string = ""): Recallable =
  ## getUsersUsernameGists
  ## List a users gists.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   since: string
  ##        : The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
  ## Example: "2012-10-09T23:39:01Z".
  ## 
  var path_553651363 = newJObject()
  var query_553651364 = newJObject()
  var header_553651365 = newJObject()
  add(path_553651363, "username", newJString(username))
  add(header_553651365, "Accept", newJString(Accept))
  add(query_553651364, "since", newJString(since))
  result = call_553651362.call(path_553651363, query_553651364, header_553651365,
                               nil, nil)

var getUsersUsernameGists* = Call_GetUsersUsernameGists_553651355(
    name: "getUsersUsernameGists", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/gists",
    validator: validate_GetUsersUsernameGists_553651356, base: "/",
    makeUrl: url_GetUsersUsernameGists_553651357, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameKeys_553651366 = ref object of OpenApiRestCall_553648476
proc url_GetUsersUsernameKeys_553651368(protocol: Scheme; host: string;
                                        base: string; route: string;
                                        path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
                 (kind: VariableSegment, value: "username"),
                 (kind: ConstantSegment, value: "/keys")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameKeys_553651367(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List public keys for a user.
  ## Lists the verified public keys for a user. This is accessible by anyone.
  ## 
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `username` field"
  var valid_553651369 = path.getOrDefault("username")
  valid_553651369 = validateParameter(valid_553651369, JString, required = true,
                                      default = nil)
  if valid_553651369 != nil:
    section.add "username", valid_553651369
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651370 = header.getOrDefault("Accept")
  valid_553651370 = validateParameter(valid_553651370, JString,
                                      required = false, default = nil)
  if valid_553651370 != nil:
    section.add "Accept", valid_553651370
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651371: Call_GetUsersUsernameKeys_553651366;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List public keys for a user.
  ## Lists the verified public keys for a user. This is accessible by anyone.
  ## 
  ## 
  let valid = call_553651371.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651371.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651371.makeUrl(scheme.get, call_553651371.host, call_553651371.base,
                                   call_553651371.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651371, uri, valid, content)

proc call*(call_553651372: Call_GetUsersUsernameKeys_553651366;
           username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameKeys
  ## List public keys for a user.
  ## Lists the verified public keys for a user. This is accessible by anyone.
  ## 
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_553651373 = newJObject()
  var header_553651374 = newJObject()
  add(path_553651373, "username", newJString(username))
  add(header_553651374, "Accept", newJString(Accept))
  result = call_553651372.call(path_553651373, nil, header_553651374, nil, nil)

var getUsersUsernameKeys* = Call_GetUsersUsernameKeys_553651366(
    name: "getUsersUsernameKeys", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/keys",
    validator: validate_GetUsersUsernameKeys_553651367, base: "/",
    makeUrl: url_GetUsersUsernameKeys_553651368, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameOrgs_553651375 = ref object of OpenApiRestCall_553648476
proc url_GetUsersUsernameOrgs_553651377(protocol: Scheme; host: string;
                                        base: string; route: string;
                                        path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
                 (kind: VariableSegment, value: "username"),
                 (kind: ConstantSegment, value: "/orgs")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameOrgs_553651376(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List all public organizations for a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `username` field"
  var valid_553651378 = path.getOrDefault("username")
  valid_553651378 = validateParameter(valid_553651378, JString, required = true,
                                      default = nil)
  if valid_553651378 != nil:
    section.add "username", valid_553651378
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651379 = header.getOrDefault("Accept")
  valid_553651379 = validateParameter(valid_553651379, JString,
                                      required = false, default = nil)
  if valid_553651379 != nil:
    section.add "Accept", valid_553651379
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651380: Call_GetUsersUsernameOrgs_553651375;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List all public organizations for a user.
  ## 
  let valid = call_553651380.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651380.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651380.makeUrl(scheme.get, call_553651380.host, call_553651380.base,
                                   call_553651380.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651380, uri, valid, content)

proc call*(call_553651381: Call_GetUsersUsernameOrgs_553651375;
           username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameOrgs
  ## List all public organizations for a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_553651382 = newJObject()
  var header_553651383 = newJObject()
  add(path_553651382, "username", newJString(username))
  add(header_553651383, "Accept", newJString(Accept))
  result = call_553651381.call(path_553651382, nil, header_553651383, nil, nil)

var getUsersUsernameOrgs* = Call_GetUsersUsernameOrgs_553651375(
    name: "getUsersUsernameOrgs", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/orgs",
    validator: validate_GetUsersUsernameOrgs_553651376, base: "/",
    makeUrl: url_GetUsersUsernameOrgs_553651377, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameReceivedEvents_553651384 = ref object of OpenApiRestCall_553648476
proc url_GetUsersUsernameReceivedEvents_553651386(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
                 (kind: VariableSegment, value: "username"),
                 (kind: ConstantSegment, value: "/received_events")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameReceivedEvents_553651385(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## These are events that you'll only see public events.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `username` field"
  var valid_553651387 = path.getOrDefault("username")
  valid_553651387 = validateParameter(valid_553651387, JString, required = true,
                                      default = nil)
  if valid_553651387 != nil:
    section.add "username", valid_553651387
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651388 = header.getOrDefault("Accept")
  valid_553651388 = validateParameter(valid_553651388, JString,
                                      required = false, default = nil)
  if valid_553651388 != nil:
    section.add "Accept", valid_553651388
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651389: Call_GetUsersUsernameReceivedEvents_553651384;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## These are events that you'll only see public events.
  ## 
  let valid = call_553651389.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651389.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651389.makeUrl(scheme.get, call_553651389.host, call_553651389.base,
                                   call_553651389.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651389, uri, valid, content)

proc call*(call_553651390: Call_GetUsersUsernameReceivedEvents_553651384;
           username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameReceivedEvents
  ## These are events that you'll only see public events.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_553651391 = newJObject()
  var header_553651392 = newJObject()
  add(path_553651391, "username", newJString(username))
  add(header_553651392, "Accept", newJString(Accept))
  result = call_553651390.call(path_553651391, nil, header_553651392, nil, nil)

var getUsersUsernameReceivedEvents* = Call_GetUsersUsernameReceivedEvents_553651384(
    name: "getUsersUsernameReceivedEvents", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/received_events",
    validator: validate_GetUsersUsernameReceivedEvents_553651385, base: "/",
    makeUrl: url_GetUsersUsernameReceivedEvents_553651386,
    schemes: {Scheme.Https})
type
  Call_GetUsersUsernameReceivedEventsPublic_553651393 = ref object of OpenApiRestCall_553648476
proc url_GetUsersUsernameReceivedEventsPublic_553651395(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
                 (kind: VariableSegment, value: "username"),
                 (kind: ConstantSegment, value: "/received_events/public")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameReceivedEventsPublic_553651394(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## List public events that a user has received
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `username` field"
  var valid_553651396 = path.getOrDefault("username")
  valid_553651396 = validateParameter(valid_553651396, JString, required = true,
                                      default = nil)
  if valid_553651396 != nil:
    section.add "username", valid_553651396
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651397 = header.getOrDefault("Accept")
  valid_553651397 = validateParameter(valid_553651397, JString,
                                      required = false, default = nil)
  if valid_553651397 != nil:
    section.add "Accept", valid_553651397
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651398: Call_GetUsersUsernameReceivedEventsPublic_553651393;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List public events that a user has received
  ## 
  let valid = call_553651398.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651398.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651398.makeUrl(scheme.get, call_553651398.host, call_553651398.base,
                                   call_553651398.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651398, uri, valid, content)

proc call*(call_553651399: Call_GetUsersUsernameReceivedEventsPublic_553651393;
           username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameReceivedEventsPublic
  ## List public events that a user has received
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_553651400 = newJObject()
  var header_553651401 = newJObject()
  add(path_553651400, "username", newJString(username))
  add(header_553651401, "Accept", newJString(Accept))
  result = call_553651399.call(path_553651400, nil, header_553651401, nil, nil)

var getUsersUsernameReceivedEventsPublic* = Call_GetUsersUsernameReceivedEventsPublic_553651393(
    name: "getUsersUsernameReceivedEventsPublic", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/received_events/public",
    validator: validate_GetUsersUsernameReceivedEventsPublic_553651394,
    base: "/", makeUrl: url_GetUsersUsernameReceivedEventsPublic_553651395,
    schemes: {Scheme.Https})
type
  Call_GetUsersUsernameRepos_553651402 = ref object of OpenApiRestCall_553648476
proc url_GetUsersUsernameRepos_553651404(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
                 (kind: VariableSegment, value: "username"),
                 (kind: ConstantSegment, value: "/repos")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameRepos_553651403(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List public repositories for the specified user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `username` field"
  var valid_553651405 = path.getOrDefault("username")
  valid_553651405 = validateParameter(valid_553651405, JString, required = true,
                                      default = nil)
  if valid_553651405 != nil:
    section.add "username", valid_553651405
  result.add "path", section
  ## parameters in `query` object:
  ##   type: JString
  section = newJObject()
  var valid_553651406 = query.getOrDefault("type")
  valid_553651406 = validateParameter(valid_553651406, JString,
                                      required = false,
                                      default = newJString("all"))
  if valid_553651406 != nil:
    section.add "type", valid_553651406
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651407 = header.getOrDefault("Accept")
  valid_553651407 = validateParameter(valid_553651407, JString,
                                      required = false, default = nil)
  if valid_553651407 != nil:
    section.add "Accept", valid_553651407
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651408: Call_GetUsersUsernameRepos_553651402;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List public repositories for the specified user.
  ## 
  let valid = call_553651408.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651408.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651408.makeUrl(scheme.get, call_553651408.host, call_553651408.base,
                                   call_553651408.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651408, uri, valid, content)

proc call*(call_553651409: Call_GetUsersUsernameRepos_553651402;
           username: string; Accept: string = ""; `type`: string = "all"): Recallable =
  ## getUsersUsernameRepos
  ## List public repositories for the specified user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  ##   type: string
  var path_553651410 = newJObject()
  var query_553651411 = newJObject()
  var header_553651412 = newJObject()
  add(path_553651410, "username", newJString(username))
  add(header_553651412, "Accept", newJString(Accept))
  add(query_553651411, "type", newJString(`type`))
  result = call_553651409.call(path_553651410, query_553651411, header_553651412,
                               nil, nil)

var getUsersUsernameRepos* = Call_GetUsersUsernameRepos_553651402(
    name: "getUsersUsernameRepos", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/repos",
    validator: validate_GetUsersUsernameRepos_553651403, base: "/",
    makeUrl: url_GetUsersUsernameRepos_553651404, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameStarred_553651413 = ref object of OpenApiRestCall_553648476
proc url_GetUsersUsernameStarred_553651415(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
                 (kind: VariableSegment, value: "username"),
                 (kind: ConstantSegment, value: "/starred")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameStarred_553651414(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; content: string = ""): JsonNode {.
    nosinks.} =
  ## List repositories being starred by a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `username` field"
  var valid_553651416 = path.getOrDefault("username")
  valid_553651416 = validateParameter(valid_553651416, JString, required = true,
                                      default = nil)
  if valid_553651416 != nil:
    section.add "username", valid_553651416
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651417 = header.getOrDefault("Accept")
  valid_553651417 = validateParameter(valid_553651417, JString,
                                      required = false, default = nil)
  if valid_553651417 != nil:
    section.add "Accept", valid_553651417
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651418: Call_GetUsersUsernameStarred_553651413;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List repositories being starred by a user.
  ## 
  let valid = call_553651418.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651418.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651418.makeUrl(scheme.get, call_553651418.host, call_553651418.base,
                                   call_553651418.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651418, uri, valid, content)

proc call*(call_553651419: Call_GetUsersUsernameStarred_553651413;
           username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameStarred
  ## List repositories being starred by a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_553651420 = newJObject()
  var header_553651421 = newJObject()
  add(path_553651420, "username", newJString(username))
  add(header_553651421, "Accept", newJString(Accept))
  result = call_553651419.call(path_553651420, nil, header_553651421, nil, nil)

var getUsersUsernameStarred* = Call_GetUsersUsernameStarred_553651413(
    name: "getUsersUsernameStarred", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/starred",
    validator: validate_GetUsersUsernameStarred_553651414, base: "/",
    makeUrl: url_GetUsersUsernameStarred_553651415, schemes: {Scheme.Https})
type
  Call_GetUsersUsernameSubscriptions_553651422 = ref object of OpenApiRestCall_553648476
proc url_GetUsersUsernameSubscriptions_553651424(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  assert path != nil, "path is required to populate template"
  assert "username" in path, "`username` is a required path parameter"
  const
    segments = @[(kind: ConstantSegment, value: "/users/"),
                 (kind: VariableSegment, value: "username"),
                 (kind: ConstantSegment, value: "/subscriptions")]
  var hydrated = hydratePath(path, segments)
  if hydrated.isNone:
    raise newException(ValueError, "unable to fully hydrate path")
  if base == "/" and hydrated.get.startsWith "/":
    result.path = hydrated.get
  else:
    result.path = base & hydrated.get

proc validate_GetUsersUsernameSubscriptions_553651423(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    content: string = ""): JsonNode {.nosinks.} =
  ## List repositories being watched by a user.
  ## 
  var section: JsonNode
  result = newJObject()
  ## parameters in `path` object:
  ##   username: JString (required)
  ##           : Name of user.
  section = newJObject()
  assert path != nil,
         "path argument is necessary due to required `username` field"
  var valid_553651425 = path.getOrDefault("username")
  valid_553651425 = validateParameter(valid_553651425, JString, required = true,
                                      default = nil)
  if valid_553651425 != nil:
    section.add "username", valid_553651425
  result.add "path", section
  section = newJObject()
  result.add "query", section
  ## parameters in `header` object:
  ##   Accept: JString
  ##         : Is used to set specified media type.
  section = newJObject()
  var valid_553651426 = header.getOrDefault("Accept")
  valid_553651426 = validateParameter(valid_553651426, JString,
                                      required = false, default = nil)
  if valid_553651426 != nil:
    section.add "Accept", valid_553651426
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_553651427: Call_GetUsersUsernameSubscriptions_553651422;
           path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
           formData: JsonNode = nil; body: JsonNode = nil; content: string = ""): Recallable =
  ## List repositories being watched by a user.
  ## 
  let valid = call_553651427.validator(path, query, header, formData, body,
                                       content)
  let scheme = call_553651427.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let uri = call_553651427.makeUrl(scheme.get, call_553651427.host, call_553651427.base,
                                   call_553651427.route,
                                   valid.getOrDefault("path"),
                                   valid.getOrDefault("query"))
  result = hook(call_553651427, uri, valid, content)

proc call*(call_553651428: Call_GetUsersUsernameSubscriptions_553651422;
           username: string; Accept: string = ""): Recallable =
  ## getUsersUsernameSubscriptions
  ## List repositories being watched by a user.
  ##   username: string (required)
  ##           : Name of user.
  ##   Accept: string
  ##         : Is used to set specified media type.
  var path_553651429 = newJObject()
  var header_553651430 = newJObject()
  add(path_553651429, "username", newJString(username))
  add(header_553651430, "Accept", newJString(Accept))
  result = call_553651428.call(path_553651429, nil, header_553651430, nil, nil)

var getUsersUsernameSubscriptions* = Call_GetUsersUsernameSubscriptions_553651422(
    name: "getUsersUsernameSubscriptions", meth: HttpMethod.HttpGet,
    host: "api.github.com", route: "/users/{username}/subscriptions",
    validator: validate_GetUsersUsernameSubscriptions_553651423, base: "/",
    makeUrl: url_GetUsersUsernameSubscriptions_553651424,
    schemes: {Scheme.Https})
export
  rest

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode; body: string): Recallable {.
    base.} =
  var headers = massageHeaders(input.getOrDefault("header")).newHttpHeaders
  let token = os.getEnv("GITHUB_TOKEN", "")
  if not headers.hasKey("Authorization") and token.len > 0:
    headers.add "Authorization", "token " & token
  if headers.hasKey "Accept":
    headers.del "Accept"
  headers.add "Accept", "application/vnd.github.v3+json"
  result = newRecallable(call, url, headers, body)
